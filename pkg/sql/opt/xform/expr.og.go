// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

var opLayoutTable = [...]opLayout{
	opt.UnknownOp:         0xFF, // will cause a crash if used
	opt.SubqueryOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.VariableOp:        makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.ConstOp:           makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.NullOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.TrueOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FalseOp:           makeOpLayout(0 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.PlaceholderOp:     makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.TupleOp:           makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ProjectionsOp:     makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.AggregationsOp:    makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.ExistsOp:          makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FiltersOp:         makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.AndOp:             makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.OrOp:              makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotOp:             makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.EqOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LtOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.GtOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.GeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NeOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.InOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotInOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LikeOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotLikeOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ILikeOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotILikeOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.SimilarToOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotSimilarToOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.RegMatchOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotRegMatchOp:     makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.RegIMatchOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.NotRegIMatchOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.IsOp:              makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.IsNotOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ContainsOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.BitandOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.BitorOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.BitxorOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.PlusOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.MinusOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.MultOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.DivOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FloorDivOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ModOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.PowOp:             makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ConcatOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LShiftOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.RShiftOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FetchValOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FetchTextOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FetchValPathOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FetchTextPathOp:   makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.UnaryMinusOp:      makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.UnaryComplementOp: makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.CastOp:            makeOpLayout(1 /*base*/, 0 /*list*/, 2 /*priv*/, 0 /*enforcer*/),
	opt.CaseOp:            makeOpLayout(1 /*base*/, 2 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.WhenOp:            makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FunctionOp:        makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.CoalesceOp:        makeOpLayout(0 /*base*/, 1 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.UnsupportedExprOp: makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.ScanOp:            makeOpLayout(0 /*base*/, 0 /*list*/, 1 /*priv*/, 0 /*enforcer*/),
	opt.ValuesOp:          makeOpLayout(0 /*base*/, 1 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.SelectOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.ProjectOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.InnerJoinOp:       makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LeftJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.RightJoinOp:       makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FullJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.SemiJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.AntiJoinOp:        makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.InnerJoinApplyOp:  makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.LeftJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.RightJoinApplyOp:  makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.FullJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.SemiJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.AntiJoinApplyOp:   makeOpLayout(3 /*base*/, 0 /*list*/, 0 /*priv*/, 0 /*enforcer*/),
	opt.GroupByOp:         makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.UnionOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.IntersectOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.ExceptOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.UnionAllOp:        makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.IntersectAllOp:    makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.ExceptAllOp:       makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.LimitOp:           makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.OffsetOp:          makeOpLayout(2 /*base*/, 0 /*list*/, 3 /*priv*/, 0 /*enforcer*/),
	opt.SortOp:            makeOpLayout(1 /*base*/, 0 /*list*/, 0 /*priv*/, 1 /*enforcer*/),
}

var isScalarLookup = [...]bool{
	false, // UnknownOp

	true,  // SubqueryOp
	true,  // VariableOp
	true,  // ConstOp
	true,  // NullOp
	true,  // TrueOp
	true,  // FalseOp
	true,  // PlaceholderOp
	true,  // TupleOp
	true,  // ProjectionsOp
	true,  // AggregationsOp
	true,  // ExistsOp
	true,  // FiltersOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	true,  // CastOp
	true,  // CaseOp
	true,  // WhenOp
	true,  // FunctionOp
	true,  // CoalesceOp
	true,  // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isConstValueLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	true,  // ConstOp
	true,  // NullOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isBooleanLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	true,  // TrueOp
	true,  // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	true,  // FiltersOp
	true,  // AndOp
	true,  // OrOp
	true,  // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isComparisonLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	true,  // EqOp
	true,  // LtOp
	true,  // GtOp
	true,  // LeOp
	true,  // GeOp
	true,  // NeOp
	true,  // InOp
	true,  // NotInOp
	true,  // LikeOp
	true,  // NotLikeOp
	true,  // ILikeOp
	true,  // NotILikeOp
	true,  // SimilarToOp
	true,  // NotSimilarToOp
	true,  // RegMatchOp
	true,  // NotRegMatchOp
	true,  // RegIMatchOp
	true,  // NotRegIMatchOp
	true,  // IsOp
	true,  // IsNotOp
	true,  // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isBinaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	true,  // BitandOp
	true,  // BitorOp
	true,  // BitxorOp
	true,  // PlusOp
	true,  // MinusOp
	true,  // MultOp
	true,  // DivOp
	true,  // FloorDivOp
	true,  // ModOp
	true,  // PowOp
	true,  // ConcatOp
	true,  // LShiftOp
	true,  // RShiftOp
	true,  // FetchValOp
	true,  // FetchTextOp
	true,  // FetchValPathOp
	true,  // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isUnaryLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	true,  // UnaryMinusOp
	true,  // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isRelationalLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	true,  // ScanOp
	true,  // ValuesOp
	true,  // SelectOp
	true,  // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	true,  // GroupByOp
	true,  // UnionOp
	true,  // IntersectOp
	true,  // ExceptOp
	true,  // UnionAllOp
	true,  // IntersectAllOp
	true,  // ExceptAllOp
	true,  // LimitOp
	true,  // OffsetOp
	false, // SortOp
}

var isJoinLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	true,  // InnerJoinOp
	true,  // LeftJoinOp
	true,  // RightJoinOp
	true,  // FullJoinOp
	true,  // SemiJoinOp
	true,  // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isJoinApplyLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	true,  // InnerJoinApplyOp
	true,  // LeftJoinApplyOp
	true,  // RightJoinApplyOp
	true,  // FullJoinApplyOp
	true,  // SemiJoinApplyOp
	true,  // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	false, // SortOp
}

var isEnforcerLookup = [...]bool{
	false, // UnknownOp

	false, // SubqueryOp
	false, // VariableOp
	false, // ConstOp
	false, // NullOp
	false, // TrueOp
	false, // FalseOp
	false, // PlaceholderOp
	false, // TupleOp
	false, // ProjectionsOp
	false, // AggregationsOp
	false, // ExistsOp
	false, // FiltersOp
	false, // AndOp
	false, // OrOp
	false, // NotOp
	false, // EqOp
	false, // LtOp
	false, // GtOp
	false, // LeOp
	false, // GeOp
	false, // NeOp
	false, // InOp
	false, // NotInOp
	false, // LikeOp
	false, // NotLikeOp
	false, // ILikeOp
	false, // NotILikeOp
	false, // SimilarToOp
	false, // NotSimilarToOp
	false, // RegMatchOp
	false, // NotRegMatchOp
	false, // RegIMatchOp
	false, // NotRegIMatchOp
	false, // IsOp
	false, // IsNotOp
	false, // ContainsOp
	false, // BitandOp
	false, // BitorOp
	false, // BitxorOp
	false, // PlusOp
	false, // MinusOp
	false, // MultOp
	false, // DivOp
	false, // FloorDivOp
	false, // ModOp
	false, // PowOp
	false, // ConcatOp
	false, // LShiftOp
	false, // RShiftOp
	false, // FetchValOp
	false, // FetchTextOp
	false, // FetchValPathOp
	false, // FetchTextPathOp
	false, // UnaryMinusOp
	false, // UnaryComplementOp
	false, // CastOp
	false, // CaseOp
	false, // WhenOp
	false, // FunctionOp
	false, // CoalesceOp
	false, // UnsupportedExprOp
	false, // ScanOp
	false, // ValuesOp
	false, // SelectOp
	false, // ProjectOp
	false, // InnerJoinOp
	false, // LeftJoinOp
	false, // RightJoinOp
	false, // FullJoinOp
	false, // SemiJoinOp
	false, // AntiJoinOp
	false, // InnerJoinApplyOp
	false, // LeftJoinApplyOp
	false, // RightJoinApplyOp
	false, // FullJoinApplyOp
	false, // SemiJoinApplyOp
	false, // AntiJoinApplyOp
	false, // GroupByOp
	false, // UnionOp
	false, // IntersectOp
	false, // ExceptOp
	false, // UnionAllOp
	false, // IntersectAllOp
	false, // ExceptAllOp
	false, // LimitOp
	false, // OffsetOp
	true,  // SortOp
}

func (ev ExprView) IsScalar() bool {
	return isScalarLookup[ev.op]
}

func (ev ExprView) IsConstValue() bool {
	return isConstValueLookup[ev.op]
}

func (ev ExprView) IsBoolean() bool {
	return isBooleanLookup[ev.op]
}

func (ev ExprView) IsComparison() bool {
	return isComparisonLookup[ev.op]
}

func (ev ExprView) IsBinary() bool {
	return isBinaryLookup[ev.op]
}

func (ev ExprView) IsUnary() bool {
	return isUnaryLookup[ev.op]
}

func (ev ExprView) IsRelational() bool {
	return isRelationalLookup[ev.op]
}

func (ev ExprView) IsJoin() bool {
	return isJoinLookup[ev.op]
}

func (ev ExprView) IsJoinApply() bool {
	return isJoinApplyLookup[ev.op]
}

func (ev ExprView) IsEnforcer() bool {
	return isEnforcerLookup[ev.op]
}

func (me *memoExpr) isScalar() bool {
	return isScalarLookup[me.op]
}

func (me *memoExpr) isConstValue() bool {
	return isConstValueLookup[me.op]
}

func (me *memoExpr) isBoolean() bool {
	return isBooleanLookup[me.op]
}

func (me *memoExpr) isComparison() bool {
	return isComparisonLookup[me.op]
}

func (me *memoExpr) isBinary() bool {
	return isBinaryLookup[me.op]
}

func (me *memoExpr) isUnary() bool {
	return isUnaryLookup[me.op]
}

func (me *memoExpr) isRelational() bool {
	return isRelationalLookup[me.op]
}

func (me *memoExpr) isJoin() bool {
	return isJoinLookup[me.op]
}

func (me *memoExpr) isJoinApply() bool {
	return isJoinApplyLookup[me.op]
}

func (me *memoExpr) isEnforcer() bool {
	return isEnforcerLookup[me.op]
}

type subqueryExpr memoExpr

func makeSubqueryExpr(input opt.GroupID, projection opt.GroupID) subqueryExpr {
	return subqueryExpr{op: opt.SubqueryOp, state: exprState{uint32(input), uint32(projection)}}
}

func (e *subqueryExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *subqueryExpr) projection() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *subqueryExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSubquery() *subqueryExpr {
	if m.op != opt.SubqueryOp {
		return nil
	}
	return (*subqueryExpr)(m)
}

// variableExpr is the typed scalar value of a column in the query. The private
// field is a Metadata.ColumnIndex that references the column by index.
type variableExpr memoExpr

func makeVariableExpr(col opt.PrivateID) variableExpr {
	return variableExpr{op: opt.VariableOp, state: exprState{uint32(col)}}
}

func (e *variableExpr) col() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *variableExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asVariable() *variableExpr {
	if m.op != opt.VariableOp {
		return nil
	}
	return (*variableExpr)(m)
}

// constExpr is a typed scalar constant value. The private field is a tree.Datum
// value having any datum type that's legal in the expression's context.
type constExpr memoExpr

func makeConstExpr(value opt.PrivateID) constExpr {
	return constExpr{op: opt.ConstOp, state: exprState{uint32(value)}}
}

func (e *constExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *constExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConst() *constExpr {
	if m.op != opt.ConstOp {
		return nil
	}
	return (*constExpr)(m)
}

// nullExpr is the constant SQL null value that has "unknown value" semantics. If
// the Typ field is not types.Unknown, then the value is known to be in the
// domain of that type. This is important for preserving correct types in
// replacement patterns. For example:
//   (Plus (Function ...) (Const 1))
//
// If the function in that expression has a static type of Int, but then it gets
// constant folded to (Null), then its type must remain as Int. Any other type
// violates logical equivalence of the expression, breaking type inference and
// possibly changing the results of execution. The solution is to tag the null
// with the correct type:
//   (Plus (Null (Int)) (Const 1))
//
// Null is its own operator rather than a Const datum in order to make matching
// and replacement easier and more efficient, as patterns can contain (Null)
// expressions.
type nullExpr memoExpr

func makeNullExpr(typ opt.PrivateID) nullExpr {
	return nullExpr{op: opt.NullOp, state: exprState{uint32(typ)}}
}

func (e *nullExpr) typ() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *nullExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNull() *nullExpr {
	if m.op != opt.NullOp {
		return nil
	}
	return (*nullExpr)(m)
}

// trueExpr is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
type trueExpr memoExpr

func makeTrueExpr() trueExpr {
	return trueExpr{op: opt.TrueOp, state: exprState{}}
}

func (e *trueExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTrue() *trueExpr {
	if m.op != opt.TrueOp {
		return nil
	}
	return (*trueExpr)(m)
}

// falseExpr is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
type falseExpr memoExpr

func makeFalseExpr() falseExpr {
	return falseExpr{op: opt.FalseOp, state: exprState{}}
}

func (e *falseExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFalse() *falseExpr {
	if m.op != opt.FalseOp {
		return nil
	}
	return (*falseExpr)(m)
}

type placeholderExpr memoExpr

func makePlaceholderExpr(value opt.PrivateID) placeholderExpr {
	return placeholderExpr{op: opt.PlaceholderOp, state: exprState{uint32(value)}}
}

func (e *placeholderExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *placeholderExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlaceholder() *placeholderExpr {
	if m.op != opt.PlaceholderOp {
		return nil
	}
	return (*placeholderExpr)(m)
}

type tupleExpr memoExpr

func makeTupleExpr(elems opt.ListID) tupleExpr {
	return tupleExpr{op: opt.TupleOp, state: exprState{elems.Offset, elems.Length}}
}

func (e *tupleExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *tupleExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asTuple() *tupleExpr {
	if m.op != opt.TupleOp {
		return nil
	}
	return (*tupleExpr)(m)
}

// projectionsExpr is a set of typed scalar expressions that will become output
// columns for a containing Project operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *opt.ColList. It
// is not legal for Cols to be empty.
type projectionsExpr memoExpr

func makeProjectionsExpr(elems opt.ListID, cols opt.PrivateID) projectionsExpr {
	return projectionsExpr{op: opt.ProjectionsOp, state: exprState{elems.Offset, elems.Length, uint32(cols)}}
}

func (e *projectionsExpr) elems() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *projectionsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *projectionsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProjections() *projectionsExpr {
	if m.op != opt.ProjectionsOp {
		return nil
	}
	return (*projectionsExpr)(m)
}

// aggregationsExpr is a set of aggregate expressions that will become output
// columns for a containing GroupBy operator. The private Cols field contains
// the list of column indexes returned by the expression, as a *ColList. It
// is legal for Cols to be empty.
type aggregationsExpr memoExpr

func makeAggregationsExpr(aggs opt.ListID, cols opt.PrivateID) aggregationsExpr {
	return aggregationsExpr{op: opt.AggregationsOp, state: exprState{aggs.Offset, aggs.Length, uint32(cols)}}
}

func (e *aggregationsExpr) aggs() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *aggregationsExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *aggregationsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAggregations() *aggregationsExpr {
	if m.op != opt.AggregationsOp {
		return nil
	}
	return (*aggregationsExpr)(m)
}

type existsExpr memoExpr

func makeExistsExpr(input opt.GroupID) existsExpr {
	return existsExpr{op: opt.ExistsOp, state: exprState{uint32(input)}}
}

func (e *existsExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *existsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExists() *existsExpr {
	if m.op != opt.ExistsOp {
		return nil
	}
	return (*existsExpr)(m)
}

// filtersExpr is a boolean And operator that only appears as the Filters child of
// a Select operator, or the On child of a Join operator. For example:
//   (Select
//     (Scan a)
//     (Filters (Gt (Variable a) 1) (Lt (Variable a) 5))
//   )
//
// Normalization rules ensure that a Filters expression is always created if
// there is at least one condition, so that other rules can rely on its presence
// when matching, even in the case where there is only one condition. The
// semantics of the Filters operator are identical to those of the And operator.
type filtersExpr memoExpr

func makeFiltersExpr(conditions opt.ListID) filtersExpr {
	return filtersExpr{op: opt.FiltersOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *filtersExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *filtersExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFilters() *filtersExpr {
	if m.op != opt.FiltersOp {
		return nil
	}
	return (*filtersExpr)(m)
}

// andExpr is the boolean conjunction operator that evalutes to true if all of its
// conditions evaluate to true. If the conditions list is empty, it evalutes to
// true.
type andExpr memoExpr

func makeAndExpr(conditions opt.ListID) andExpr {
	return andExpr{op: opt.AndOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *andExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *andExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAnd() *andExpr {
	if m.op != opt.AndOp {
		return nil
	}
	return (*andExpr)(m)
}

// orExpr is the boolean disjunction operator that evalutes to true if any of its
// conditions evaluate to true. If the conditions list is empty, it evaluates to
// false.
type orExpr memoExpr

func makeOrExpr(conditions opt.ListID) orExpr {
	return orExpr{op: opt.OrOp, state: exprState{conditions.Offset, conditions.Length}}
}

func (e *orExpr) conditions() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *orExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOr() *orExpr {
	if m.op != opt.OrOp {
		return nil
	}
	return (*orExpr)(m)
}

// notExpr is the boolean negation operator that evaluates to true if its input
// evalutes to false.
type notExpr memoExpr

func makeNotExpr(input opt.GroupID) notExpr {
	return notExpr{op: opt.NotOp, state: exprState{uint32(input)}}
}

func (e *notExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNot() *notExpr {
	if m.op != opt.NotOp {
		return nil
	}
	return (*notExpr)(m)
}

type eqExpr memoExpr

func makeEqExpr(left opt.GroupID, right opt.GroupID) eqExpr {
	return eqExpr{op: opt.EqOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *eqExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *eqExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *eqExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asEq() *eqExpr {
	if m.op != opt.EqOp {
		return nil
	}
	return (*eqExpr)(m)
}

type ltExpr memoExpr

func makeLtExpr(left opt.GroupID, right opt.GroupID) ltExpr {
	return ltExpr{op: opt.LtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *ltExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *ltExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *ltExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLt() *ltExpr {
	if m.op != opt.LtOp {
		return nil
	}
	return (*ltExpr)(m)
}

type gtExpr memoExpr

func makeGtExpr(left opt.GroupID, right opt.GroupID) gtExpr {
	return gtExpr{op: opt.GtOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *gtExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *gtExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *gtExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGt() *gtExpr {
	if m.op != opt.GtOp {
		return nil
	}
	return (*gtExpr)(m)
}

type leExpr memoExpr

func makeLeExpr(left opt.GroupID, right opt.GroupID) leExpr {
	return leExpr{op: opt.LeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *leExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLe() *leExpr {
	if m.op != opt.LeOp {
		return nil
	}
	return (*leExpr)(m)
}

type geExpr memoExpr

func makeGeExpr(left opt.GroupID, right opt.GroupID) geExpr {
	return geExpr{op: opt.GeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *geExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *geExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *geExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGe() *geExpr {
	if m.op != opt.GeOp {
		return nil
	}
	return (*geExpr)(m)
}

type neExpr memoExpr

func makeNeExpr(left opt.GroupID, right opt.GroupID) neExpr {
	return neExpr{op: opt.NeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *neExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *neExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *neExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNe() *neExpr {
	if m.op != opt.NeOp {
		return nil
	}
	return (*neExpr)(m)
}

type inExpr memoExpr

func makeInExpr(left opt.GroupID, right opt.GroupID) inExpr {
	return inExpr{op: opt.InOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *inExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *inExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *inExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIn() *inExpr {
	if m.op != opt.InOp {
		return nil
	}
	return (*inExpr)(m)
}

type notInExpr memoExpr

func makeNotInExpr(left opt.GroupID, right opt.GroupID) notInExpr {
	return notInExpr{op: opt.NotInOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notInExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notInExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notInExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotIn() *notInExpr {
	if m.op != opt.NotInOp {
		return nil
	}
	return (*notInExpr)(m)
}

type likeExpr memoExpr

func makeLikeExpr(left opt.GroupID, right opt.GroupID) likeExpr {
	return likeExpr{op: opt.LikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *likeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *likeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *likeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLike() *likeExpr {
	if m.op != opt.LikeOp {
		return nil
	}
	return (*likeExpr)(m)
}

type notLikeExpr memoExpr

func makeNotLikeExpr(left opt.GroupID, right opt.GroupID) notLikeExpr {
	return notLikeExpr{op: opt.NotLikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotLike() *notLikeExpr {
	if m.op != opt.NotLikeOp {
		return nil
	}
	return (*notLikeExpr)(m)
}

type iLikeExpr memoExpr

func makeILikeExpr(left opt.GroupID, right opt.GroupID) iLikeExpr {
	return iLikeExpr{op: opt.ILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *iLikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *iLikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *iLikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asILike() *iLikeExpr {
	if m.op != opt.ILikeOp {
		return nil
	}
	return (*iLikeExpr)(m)
}

type notILikeExpr memoExpr

func makeNotILikeExpr(left opt.GroupID, right opt.GroupID) notILikeExpr {
	return notILikeExpr{op: opt.NotILikeOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notILikeExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notILikeExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notILikeExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotILike() *notILikeExpr {
	if m.op != opt.NotILikeOp {
		return nil
	}
	return (*notILikeExpr)(m)
}

type similarToExpr memoExpr

func makeSimilarToExpr(left opt.GroupID, right opt.GroupID) similarToExpr {
	return similarToExpr{op: opt.SimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *similarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *similarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *similarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSimilarTo() *similarToExpr {
	if m.op != opt.SimilarToOp {
		return nil
	}
	return (*similarToExpr)(m)
}

type notSimilarToExpr memoExpr

func makeNotSimilarToExpr(left opt.GroupID, right opt.GroupID) notSimilarToExpr {
	return notSimilarToExpr{op: opt.NotSimilarToOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notSimilarToExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notSimilarToExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notSimilarToExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotSimilarTo() *notSimilarToExpr {
	if m.op != opt.NotSimilarToOp {
		return nil
	}
	return (*notSimilarToExpr)(m)
}

type regMatchExpr memoExpr

func makeRegMatchExpr(left opt.GroupID, right opt.GroupID) regMatchExpr {
	return regMatchExpr{op: opt.RegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegMatch() *regMatchExpr {
	if m.op != opt.RegMatchOp {
		return nil
	}
	return (*regMatchExpr)(m)
}

type notRegMatchExpr memoExpr

func makeNotRegMatchExpr(left opt.GroupID, right opt.GroupID) notRegMatchExpr {
	return notRegMatchExpr{op: opt.NotRegMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegMatch() *notRegMatchExpr {
	if m.op != opt.NotRegMatchOp {
		return nil
	}
	return (*notRegMatchExpr)(m)
}

type regIMatchExpr memoExpr

func makeRegIMatchExpr(left opt.GroupID, right opt.GroupID) regIMatchExpr {
	return regIMatchExpr{op: opt.RegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *regIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *regIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *regIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRegIMatch() *regIMatchExpr {
	if m.op != opt.RegIMatchOp {
		return nil
	}
	return (*regIMatchExpr)(m)
}

type notRegIMatchExpr memoExpr

func makeNotRegIMatchExpr(left opt.GroupID, right opt.GroupID) notRegIMatchExpr {
	return notRegIMatchExpr{op: opt.NotRegIMatchOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *notRegIMatchExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *notRegIMatchExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *notRegIMatchExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asNotRegIMatch() *notRegIMatchExpr {
	if m.op != opt.NotRegIMatchOp {
		return nil
	}
	return (*notRegIMatchExpr)(m)
}

type isExpr memoExpr

func makeIsExpr(left opt.GroupID, right opt.GroupID) isExpr {
	return isExpr{op: opt.IsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIs() *isExpr {
	if m.op != opt.IsOp {
		return nil
	}
	return (*isExpr)(m)
}

type isNotExpr memoExpr

func makeIsNotExpr(left opt.GroupID, right opt.GroupID) isNotExpr {
	return isNotExpr{op: opt.IsNotOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *isNotExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *isNotExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *isNotExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIsNot() *isNotExpr {
	if m.op != opt.IsNotOp {
		return nil
	}
	return (*isNotExpr)(m)
}

type containsExpr memoExpr

func makeContainsExpr(left opt.GroupID, right opt.GroupID) containsExpr {
	return containsExpr{op: opt.ContainsOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *containsExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *containsExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *containsExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asContains() *containsExpr {
	if m.op != opt.ContainsOp {
		return nil
	}
	return (*containsExpr)(m)
}

type bitandExpr memoExpr

func makeBitandExpr(left opt.GroupID, right opt.GroupID) bitandExpr {
	return bitandExpr{op: opt.BitandOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitandExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitandExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitandExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitand() *bitandExpr {
	if m.op != opt.BitandOp {
		return nil
	}
	return (*bitandExpr)(m)
}

type bitorExpr memoExpr

func makeBitorExpr(left opt.GroupID, right opt.GroupID) bitorExpr {
	return bitorExpr{op: opt.BitorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitor() *bitorExpr {
	if m.op != opt.BitorOp {
		return nil
	}
	return (*bitorExpr)(m)
}

type bitxorExpr memoExpr

func makeBitxorExpr(left opt.GroupID, right opt.GroupID) bitxorExpr {
	return bitxorExpr{op: opt.BitxorOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *bitxorExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *bitxorExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *bitxorExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asBitxor() *bitxorExpr {
	if m.op != opt.BitxorOp {
		return nil
	}
	return (*bitxorExpr)(m)
}

type plusExpr memoExpr

func makePlusExpr(left opt.GroupID, right opt.GroupID) plusExpr {
	return plusExpr{op: opt.PlusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *plusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *plusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *plusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPlus() *plusExpr {
	if m.op != opt.PlusOp {
		return nil
	}
	return (*plusExpr)(m)
}

type minusExpr memoExpr

func makeMinusExpr(left opt.GroupID, right opt.GroupID) minusExpr {
	return minusExpr{op: opt.MinusOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *minusExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *minusExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *minusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMinus() *minusExpr {
	if m.op != opt.MinusOp {
		return nil
	}
	return (*minusExpr)(m)
}

type multExpr memoExpr

func makeMultExpr(left opt.GroupID, right opt.GroupID) multExpr {
	return multExpr{op: opt.MultOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *multExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *multExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *multExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMult() *multExpr {
	if m.op != opt.MultOp {
		return nil
	}
	return (*multExpr)(m)
}

type divExpr memoExpr

func makeDivExpr(left opt.GroupID, right opt.GroupID) divExpr {
	return divExpr{op: opt.DivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *divExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *divExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *divExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asDiv() *divExpr {
	if m.op != opt.DivOp {
		return nil
	}
	return (*divExpr)(m)
}

type floorDivExpr memoExpr

func makeFloorDivExpr(left opt.GroupID, right opt.GroupID) floorDivExpr {
	return floorDivExpr{op: opt.FloorDivOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *floorDivExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *floorDivExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *floorDivExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFloorDiv() *floorDivExpr {
	if m.op != opt.FloorDivOp {
		return nil
	}
	return (*floorDivExpr)(m)
}

type modExpr memoExpr

func makeModExpr(left opt.GroupID, right opt.GroupID) modExpr {
	return modExpr{op: opt.ModOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *modExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *modExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *modExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asMod() *modExpr {
	if m.op != opt.ModOp {
		return nil
	}
	return (*modExpr)(m)
}

type powExpr memoExpr

func makePowExpr(left opt.GroupID, right opt.GroupID) powExpr {
	return powExpr{op: opt.PowOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *powExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *powExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *powExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asPow() *powExpr {
	if m.op != opt.PowOp {
		return nil
	}
	return (*powExpr)(m)
}

type concatExpr memoExpr

func makeConcatExpr(left opt.GroupID, right opt.GroupID) concatExpr {
	return concatExpr{op: opt.ConcatOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *concatExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *concatExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *concatExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asConcat() *concatExpr {
	if m.op != opt.ConcatOp {
		return nil
	}
	return (*concatExpr)(m)
}

type lShiftExpr memoExpr

func makeLShiftExpr(left opt.GroupID, right opt.GroupID) lShiftExpr {
	return lShiftExpr{op: opt.LShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *lShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *lShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *lShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLShift() *lShiftExpr {
	if m.op != opt.LShiftOp {
		return nil
	}
	return (*lShiftExpr)(m)
}

type rShiftExpr memoExpr

func makeRShiftExpr(left opt.GroupID, right opt.GroupID) rShiftExpr {
	return rShiftExpr{op: opt.RShiftOp, state: exprState{uint32(left), uint32(right)}}
}

func (e *rShiftExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rShiftExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rShiftExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRShift() *rShiftExpr {
	if m.op != opt.RShiftOp {
		return nil
	}
	return (*rShiftExpr)(m)
}

type fetchValExpr memoExpr

func makeFetchValExpr(json opt.GroupID, index opt.GroupID) fetchValExpr {
	return fetchValExpr{op: opt.FetchValOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchValExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchVal() *fetchValExpr {
	if m.op != opt.FetchValOp {
		return nil
	}
	return (*fetchValExpr)(m)
}

type fetchTextExpr memoExpr

func makeFetchTextExpr(json opt.GroupID, index opt.GroupID) fetchTextExpr {
	return fetchTextExpr{op: opt.FetchTextOp, state: exprState{uint32(json), uint32(index)}}
}

func (e *fetchTextExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextExpr) index() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchText() *fetchTextExpr {
	if m.op != opt.FetchTextOp {
		return nil
	}
	return (*fetchTextExpr)(m)
}

type fetchValPathExpr memoExpr

func makeFetchValPathExpr(json opt.GroupID, path opt.GroupID) fetchValPathExpr {
	return fetchValPathExpr{op: opt.FetchValPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchValPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchValPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchValPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchValPath() *fetchValPathExpr {
	if m.op != opt.FetchValPathOp {
		return nil
	}
	return (*fetchValPathExpr)(m)
}

type fetchTextPathExpr memoExpr

func makeFetchTextPathExpr(json opt.GroupID, path opt.GroupID) fetchTextPathExpr {
	return fetchTextPathExpr{op: opt.FetchTextPathOp, state: exprState{uint32(json), uint32(path)}}
}

func (e *fetchTextPathExpr) json() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fetchTextPathExpr) path() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fetchTextPathExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFetchTextPath() *fetchTextPathExpr {
	if m.op != opt.FetchTextPathOp {
		return nil
	}
	return (*fetchTextPathExpr)(m)
}

type unaryMinusExpr memoExpr

func makeUnaryMinusExpr(input opt.GroupID) unaryMinusExpr {
	return unaryMinusExpr{op: opt.UnaryMinusOp, state: exprState{uint32(input)}}
}

func (e *unaryMinusExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryMinusExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryMinus() *unaryMinusExpr {
	if m.op != opt.UnaryMinusOp {
		return nil
	}
	return (*unaryMinusExpr)(m)
}

type unaryComplementExpr memoExpr

func makeUnaryComplementExpr(input opt.GroupID) unaryComplementExpr {
	return unaryComplementExpr{op: opt.UnaryComplementOp, state: exprState{uint32(input)}}
}

func (e *unaryComplementExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unaryComplementExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnaryComplement() *unaryComplementExpr {
	if m.op != opt.UnaryComplementOp {
		return nil
	}
	return (*unaryComplementExpr)(m)
}

type castExpr memoExpr

func makeCastExpr(input opt.GroupID, typ opt.PrivateID) castExpr {
	return castExpr{op: opt.CastOp, state: exprState{uint32(input), uint32(typ)}}
}

func (e *castExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *castExpr) typ() opt.PrivateID {
	return opt.PrivateID(e.state[1])
}

func (e *castExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asCast() *castExpr {
	if m.op != opt.CastOp {
		return nil
	}
	return (*castExpr)(m)
}

// caseExpr is a CASE statement of the form:
//   CASE [ <Input> ]
//       WHEN <condval1> THEN <expr1>
//     [ WHEN <condval2> THEN <expr2> ] ...
//     [ ELSE <expr> ]
//   END
//
// The Case operator evaluates <Input> (if not provided, Input is set to True),
// then picks the WHEN branch where <condval> is equal to
// <cond>, then evaluates and returns the corresponding THEN expression. If no
// WHEN branch matches, the ELSE expression is evaluated and returned, if any.
// Otherwise, NULL is returned.
//
// Note that the Whens list inside Case is used to represent all the WHEN
// branches as well as the ELSE statement if it exists. It is of the form:
// [(When <condval1> <expr1>),(When <condval2> <expr2>),...,<expr>]
type caseExpr memoExpr

func makeCaseExpr(input opt.GroupID, whens opt.ListID) caseExpr {
	return caseExpr{op: opt.CaseOp, state: exprState{uint32(input), whens.Offset, whens.Length}}
}

func (e *caseExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *caseExpr) whens() opt.ListID {
	return opt.ListID{Offset: e.state[1], Length: e.state[2]}
}

func (e *caseExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asCase() *caseExpr {
	if m.op != opt.CaseOp {
		return nil
	}
	return (*caseExpr)(m)
}

// whenExpr represents a single WHEN ... THEN ... condition inside a CASE statement.
// It is the type of each list item in Whens (except for the last item which is
// a raw expression for the ELSE statement).
type whenExpr memoExpr

func makeWhenExpr(condition opt.GroupID, value opt.GroupID) whenExpr {
	return whenExpr{op: opt.WhenOp, state: exprState{uint32(condition), uint32(value)}}
}

func (e *whenExpr) condition() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *whenExpr) value() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *whenExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asWhen() *whenExpr {
	if m.op != opt.WhenOp {
		return nil
	}
	return (*whenExpr)(m)
}

// functionExpr invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The private field is an opt.FuncOpDef struct that provides the
// name of the function as well as a pointer to the builtin overload definition.
type functionExpr memoExpr

func makeFunctionExpr(args opt.ListID, def opt.PrivateID) functionExpr {
	return functionExpr{op: opt.FunctionOp, state: exprState{args.Offset, args.Length, uint32(def)}}
}

func (e *functionExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *functionExpr) def() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *functionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFunction() *functionExpr {
	if m.op != opt.FunctionOp {
		return nil
	}
	return (*functionExpr)(m)
}

type coalesceExpr memoExpr

func makeCoalesceExpr(args opt.ListID) coalesceExpr {
	return coalesceExpr{op: opt.CoalesceOp, state: exprState{args.Offset, args.Length}}
}

func (e *coalesceExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *coalesceExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asCoalesce() *coalesceExpr {
	if m.op != opt.CoalesceOp {
		return nil
	}
	return (*coalesceExpr)(m)
}

// unsupportedExprExpr is used for interfacing with the old planner code. It can
// encapsulate a TypedExpr that is otherwise not supported by the optimizer.
type unsupportedExprExpr memoExpr

func makeUnsupportedExprExpr(value opt.PrivateID) unsupportedExprExpr {
	return unsupportedExprExpr{op: opt.UnsupportedExprOp, state: exprState{uint32(value)}}
}

func (e *unsupportedExprExpr) value() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *unsupportedExprExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnsupportedExpr() *unsupportedExprExpr {
	if m.op != opt.UnsupportedExprOp {
		return nil
	}
	return (*unsupportedExprExpr)(m)
}

// scanExpr returns a result set containing every row in the specified table. The
// private Def field is an *opt.ScanOpDef that identifies the table to scan, as
// well as the subset of columns to project from it. Rows and columns are not
// expected to have any particular ordering unless a physical property requires
// it.
type scanExpr memoExpr

func makeScanExpr(def opt.PrivateID) scanExpr {
	return scanExpr{op: opt.ScanOp, state: exprState{uint32(def)}}
}

func (e *scanExpr) def() opt.PrivateID {
	return opt.PrivateID(e.state[0])
}

func (e *scanExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asScan() *scanExpr {
	if m.op != opt.ScanOp {
		return nil
	}
	return (*scanExpr)(m)
}

// valuesExpr returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as a *ColList. It is legal for Cols to be empty.
type valuesExpr memoExpr

func makeValuesExpr(rows opt.ListID, cols opt.PrivateID) valuesExpr {
	return valuesExpr{op: opt.ValuesOp, state: exprState{rows.Offset, rows.Length, uint32(cols)}}
}

func (e *valuesExpr) rows() opt.ListID {
	return opt.ListID{Offset: e.state[0], Length: e.state[1]}
}

func (e *valuesExpr) cols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *valuesExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asValues() *valuesExpr {
	if m.op != opt.ValuesOp {
		return nil
	}
	return (*valuesExpr)(m)
}

// selectExpr filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded. While
// the Filter operand can be any boolean expression, normalization rules will
// typically convert it to a Filters operator in order to make conjunction list
// matching easier.
type selectExpr memoExpr

func makeSelectExpr(input opt.GroupID, filter opt.GroupID) selectExpr {
	return selectExpr{op: opt.SelectOp, state: exprState{uint32(input), uint32(filter)}}
}

func (e *selectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *selectExpr) filter() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *selectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSelect() *selectExpr {
	if m.op != opt.SelectOp {
		return nil
	}
	return (*selectExpr)(m)
}

// projectExpr modifies the set of columns returned by the input result set. Columns
// can be removed, reordered, or renamed. In addition, new columns can be
// synthesized. Projections is a scalar Projections list operator that contains
// the list of expressions that describe the output columns. The Cols field of
// the Projections operator provides the indexes of each of the output columns.
type projectExpr memoExpr

func makeProjectExpr(input opt.GroupID, projections opt.GroupID) projectExpr {
	return projectExpr{op: opt.ProjectOp, state: exprState{uint32(input), uint32(projections)}}
}

func (e *projectExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *projectExpr) projections() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *projectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asProject() *projectExpr {
	if m.op != opt.ProjectOp {
		return nil
	}
	return (*projectExpr)(m)
}

// innerJoinExpr creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
type innerJoinExpr memoExpr

func makeInnerJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinExpr {
	return innerJoinExpr{op: opt.InnerJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoin() *innerJoinExpr {
	if m.op != opt.InnerJoinOp {
		return nil
	}
	return (*innerJoinExpr)(m)
}

type leftJoinExpr memoExpr

func makeLeftJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinExpr {
	return leftJoinExpr{op: opt.LeftJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoin() *leftJoinExpr {
	if m.op != opt.LeftJoinOp {
		return nil
	}
	return (*leftJoinExpr)(m)
}

type rightJoinExpr memoExpr

func makeRightJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinExpr {
	return rightJoinExpr{op: opt.RightJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoin() *rightJoinExpr {
	if m.op != opt.RightJoinOp {
		return nil
	}
	return (*rightJoinExpr)(m)
}

type fullJoinExpr memoExpr

func makeFullJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinExpr {
	return fullJoinExpr{op: opt.FullJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoin() *fullJoinExpr {
	if m.op != opt.FullJoinOp {
		return nil
	}
	return (*fullJoinExpr)(m)
}

type semiJoinExpr memoExpr

func makeSemiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinExpr {
	return semiJoinExpr{op: opt.SemiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoin() *semiJoinExpr {
	if m.op != opt.SemiJoinOp {
		return nil
	}
	return (*semiJoinExpr)(m)
}

type antiJoinExpr memoExpr

func makeAntiJoinExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinExpr {
	return antiJoinExpr{op: opt.AntiJoinOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoin() *antiJoinExpr {
	if m.op != opt.AntiJoinOp {
		return nil
	}
	return (*antiJoinExpr)(m)
}

// innerJoinApplyExpr has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
type innerJoinApplyExpr memoExpr

func makeInnerJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) innerJoinApplyExpr {
	return innerJoinApplyExpr{op: opt.InnerJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *innerJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *innerJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *innerJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *innerJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asInnerJoinApply() *innerJoinApplyExpr {
	if m.op != opt.InnerJoinApplyOp {
		return nil
	}
	return (*innerJoinApplyExpr)(m)
}

type leftJoinApplyExpr memoExpr

func makeLeftJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) leftJoinApplyExpr {
	return leftJoinApplyExpr{op: opt.LeftJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *leftJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *leftJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *leftJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *leftJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLeftJoinApply() *leftJoinApplyExpr {
	if m.op != opt.LeftJoinApplyOp {
		return nil
	}
	return (*leftJoinApplyExpr)(m)
}

type rightJoinApplyExpr memoExpr

func makeRightJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) rightJoinApplyExpr {
	return rightJoinApplyExpr{op: opt.RightJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *rightJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *rightJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *rightJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *rightJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asRightJoinApply() *rightJoinApplyExpr {
	if m.op != opt.RightJoinApplyOp {
		return nil
	}
	return (*rightJoinApplyExpr)(m)
}

type fullJoinApplyExpr memoExpr

func makeFullJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) fullJoinApplyExpr {
	return fullJoinApplyExpr{op: opt.FullJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *fullJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *fullJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *fullJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *fullJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFullJoinApply() *fullJoinApplyExpr {
	if m.op != opt.FullJoinApplyOp {
		return nil
	}
	return (*fullJoinApplyExpr)(m)
}

type semiJoinApplyExpr memoExpr

func makeSemiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) semiJoinApplyExpr {
	return semiJoinApplyExpr{op: opt.SemiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *semiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *semiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *semiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *semiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asSemiJoinApply() *semiJoinApplyExpr {
	if m.op != opt.SemiJoinApplyOp {
		return nil
	}
	return (*semiJoinApplyExpr)(m)
}

type antiJoinApplyExpr memoExpr

func makeAntiJoinApplyExpr(left opt.GroupID, right opt.GroupID, on opt.GroupID) antiJoinApplyExpr {
	return antiJoinApplyExpr{op: opt.AntiJoinApplyOp, state: exprState{uint32(left), uint32(right), uint32(on)}}
}

func (e *antiJoinApplyExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *antiJoinApplyExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *antiJoinApplyExpr) on() opt.GroupID {
	return opt.GroupID(e.state[2])
}

func (e *antiJoinApplyExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asAntiJoinApply() *antiJoinApplyExpr {
	if m.op != opt.AntiJoinApplyOp {
		return nil
	}
	return (*antiJoinApplyExpr)(m)
}

// groupByExpr is an operator that is used for performing aggregations (for queries
// with aggregate functions, HAVING clauses and/or group by expressions). It
// groups results that are equal on the grouping columns and computes
// aggregations as described by Aggregations (which is always an Aggregations
// operator). The arguments of the aggregations are columns from the input.
type groupByExpr memoExpr

func makeGroupByExpr(input opt.GroupID, aggregations opt.GroupID, groupingCols opt.PrivateID) groupByExpr {
	return groupByExpr{op: opt.GroupByOp, state: exprState{uint32(input), uint32(aggregations), uint32(groupingCols)}}
}

func (e *groupByExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *groupByExpr) aggregations() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *groupByExpr) groupingCols() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *groupByExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asGroupBy() *groupByExpr {
	if m.op != opt.GroupByOp {
		return nil
	}
	return (*groupByExpr)(m)
}

// unionExpr is an operator used to combine the Left and Right input relations into
// a single set containing rows from both inputs. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Union with the output columns. See the comment above opt.SetOpColMap
// for more details.
type unionExpr memoExpr

func makeUnionExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) unionExpr {
	return unionExpr{op: opt.UnionOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unionExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *unionExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *unionExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnion() *unionExpr {
	if m.op != opt.UnionOp {
		return nil
	}
	return (*unionExpr)(m)
}

// intersectExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that are also present in the Right relation. Duplicate rows are
// discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Intersect with the output columns. See the comment above
// opt.SetOpColMap for more details.
type intersectExpr memoExpr

func makeIntersectExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) intersectExpr {
	return intersectExpr{op: opt.IntersectOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *intersectExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *intersectExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *intersectExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *intersectExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersect() *intersectExpr {
	if m.op != opt.IntersectOp {
		return nil
	}
	return (*intersectExpr)(m)
}

// exceptExpr is an operator used to perform a set difference between the Left and
// Right input relations. The result consists only of rows in the Left relation
// that are not present in the Right relation. Duplicate rows are discarded.
// The private field, ColMap, matches columns from the Left and Right inputs
// of the Except with the output columns. See the comment above opt.SetOpColMap
// for more details.
type exceptExpr memoExpr

func makeExceptExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) exceptExpr {
	return exceptExpr{op: opt.ExceptOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *exceptExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *exceptExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *exceptExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *exceptExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExcept() *exceptExpr {
	if m.op != opt.ExceptOp {
		return nil
	}
	return (*exceptExpr)(m)
}

// unionAllExpr is an operator used to combine the Left and Right input relations
// into a single set containing rows from both inputs. Duplicate rows are
// not discarded. For example:
//   SELECT x FROM xx UNION ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       2    ->    1
//     2       3          1
//                        2
//                        2
//                        3
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the UnionAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type unionAllExpr memoExpr

func makeUnionAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) unionAllExpr {
	return unionAllExpr{op: opt.UnionAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *unionAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *unionAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *unionAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *unionAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asUnionAll() *unionAllExpr {
	if m.op != opt.UnionAllOp {
		return nil
	}
	return (*unionAllExpr)(m)
}

// intersectAllExpr is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that have a corresponding row in the Right relation. Duplicate rows
// are not discarded. This effectively creates a one-to-one mapping between the
// Left and Right rows. For example:
//   SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1          1
//     1       1    ->    1
//     1       2          2
//     2       2          2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the IntersectAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type intersectAllExpr memoExpr

func makeIntersectAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) intersectAllExpr {
	return intersectAllExpr{op: opt.IntersectAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *intersectAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *intersectAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *intersectAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *intersectAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asIntersectAll() *intersectAllExpr {
	if m.op != opt.IntersectAllOp {
		return nil
	}
	return (*intersectAllExpr)(m)
}

// exceptAllExpr is an operator used to perform a set difference between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that do not have a corresponding row in the Right relation.
// Duplicate rows are not discarded. This effectively creates a one-to-one
// mapping between the Left and Right rows. For example:
//   SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
//     x       y         out
//   -----   -----      -----
//     1       1    ->    1
//     1       1          4
//     1       2
//     2       2
//     2       3
//     4
//
// The private field, ColMap, matches columns from the Left and Right inputs
// of the ExceptAll with the output columns. See the comment above
// opt.SetOpColMap for more details.
type exceptAllExpr memoExpr

func makeExceptAllExpr(left opt.GroupID, right opt.GroupID, colMap opt.PrivateID) exceptAllExpr {
	return exceptAllExpr{op: opt.ExceptAllOp, state: exprState{uint32(left), uint32(right), uint32(colMap)}}
}

func (e *exceptAllExpr) left() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *exceptAllExpr) right() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *exceptAllExpr) colMap() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *exceptAllExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asExceptAll() *exceptAllExpr {
	if m.op != opt.ExceptAllOp {
		return nil
	}
	return (*exceptAllExpr)(m)
}

// limitExpr returns a limited subset of the results in the input relation.
// The limit expression is a scalar value; the operator returns at most this many
// rows. The private field is an *opt.Ordering which indicates the desired
// row ordering (the first rows with respect to this ordering are returned).
type limitExpr memoExpr

func makeLimitExpr(input opt.GroupID, limit opt.GroupID, ordering opt.PrivateID) limitExpr {
	return limitExpr{op: opt.LimitOp, state: exprState{uint32(input), uint32(limit), uint32(ordering)}}
}

func (e *limitExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *limitExpr) limit() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *limitExpr) ordering() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *limitExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asLimit() *limitExpr {
	if m.op != opt.LimitOp {
		return nil
	}
	return (*limitExpr)(m)
}

// offsetExpr filters out the first Offset rows of the input relation; used in
// conjunction with Limit.
type offsetExpr memoExpr

func makeOffsetExpr(input opt.GroupID, offset opt.GroupID, ordering opt.PrivateID) offsetExpr {
	return offsetExpr{op: opt.OffsetOp, state: exprState{uint32(input), uint32(offset), uint32(ordering)}}
}

func (e *offsetExpr) input() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *offsetExpr) offset() opt.GroupID {
	return opt.GroupID(e.state[1])
}

func (e *offsetExpr) ordering() opt.PrivateID {
	return opt.PrivateID(e.state[2])
}

func (e *offsetExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asOffset() *offsetExpr {
	if m.op != opt.OffsetOp {
		return nil
	}
	return (*offsetExpr)(m)
}
