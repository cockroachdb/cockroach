// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package xform

import (
	"fmt"
	"sort"

	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

//go:generate optgen -out factory.og.go factory ../ops/*.opt rules/*.opt

// Factory constructs a normalized expression tree within the memo. As each
// kind of expression is constructed by the factory, it transitively runs
// normalization transformations defined for that expression type. This may
// result in the construction of a different type of expression than what was
// requested. If, after normalization, the expression is already part of the
// memo, then construction is a no-op. Otherwise, a new memo group is created,
// with the normalized expression as its first and only expression.
//
// Factory is largely auto-generated by optgen. The generated code can be found
// in factory.og.go. The factory.go file contains helper functions that are
// invoked by normalization patterns. While most patterns are specified in the
// optgen DSL, the factory always calls the `onConstruct` method as its last
// step, in order to allow any custom manual code to execute.
type factory struct {
	mem     *memo
	evalCtx *tree.EvalContext

	// maxSteps sets the maximum number of optimization patterns that the
	// factory will apply. Once this maximum is reached, the factory will
	// construct the requested operator without applying any rewrites to it.
	// This method is useful for debugging, in order to see intermediate
	// optimization steps.
	maxSteps OptimizeSteps

	// lastRule stores the name of the last rule that was triggered, for
	// debugging purposes.
	lastRuleName RuleName
}

var _ opt.Factory = &factory{}

// NewFactory returns a new Factory structure with a new, blank memo
// structure inside.
func newFactory(evalCtx *tree.EvalContext, maxSteps OptimizeSteps) *factory {
	return &factory{mem: newMemo(), evalCtx: evalCtx, maxSteps: maxSteps}
}

// Metadata returns the query-specific metadata, which includes information
// about the columns and tables used in this particular query.
func (f *factory) Metadata() *opt.Metadata {
	return f.mem.metadata
}

// InternList adds the given list of group IDs to memo storage and returns an
// ID that can be used for later lookup. If the same list was added previously,
// this method is a no-op and returns the ID of the previous value.
func (f *factory) InternList(items []opt.GroupID) opt.ListID {
	return f.mem.internList(items)
}

// InternPrivate adds the given private value to the memo and returns an ID
// that can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (f *factory) InternPrivate(private interface{}) opt.PrivateID {
	return f.mem.internPrivate(private)
}

// allowOptimizations returns true if optimizations are currently enabled. Each
// individual optimization decrements the maxSteps counter. Once it reaches
// zero (or if it was zero to begin with), no further optimizations will be
// performed.
func (f *factory) allowOptimizations() bool {
	return f.maxSteps > 0
}

// reportOptimization is called when an optimization has been performed on the
// tree. It decrements the maxSteps counter. Once that reaches zero, no further
// optimizations will be performed. It also stores the name of the rule that
// was triggered, which is useful for debugging.
func (f *factory) reportOptimization(name RuleName) {
	f.lastRuleName = name
	f.maxSteps--
}

// onConstruct is called as a final step by each factory construction method,
// so that any custom manual pattern matching/replacement code can be run.
func (f *factory) onConstruct(group opt.GroupID) opt.GroupID {
	return group
}

// ----------------------------------------------------------------------
//
// Private extraction functions
//   Helper functions that make extracting common private types easier.
//
// ----------------------------------------------------------------------

func (f *factory) extractColList(private opt.PrivateID) opt.ColList {
	return *f.mem.lookupPrivate(private).(*opt.ColList)
}

// ----------------------------------------------------------------------
//
// List functions
//   General custom match and replace functions used to test and construct
//   lists.
//
// ----------------------------------------------------------------------

// listOnlyHasNulls if every item in the given list is a Null op. If the list
// is empty, listOnlyHasNulls returns false.
func (f *factory) listOnlyHasNulls(list opt.ListID) bool {
	if list.Length == 0 {
		return false
	}

	for _, item := range f.mem.lookupList(list) {
		if f.mem.lookupNormExpr(item).op != opt.NullOp {
			return false
		}
	}
	return true
}

// isSortedUniqueList returns true if the list is in sorted order, with no
// duplicates. See the comment for listSorter.compare for comparison rule
// details.
func (f *factory) isSortedUniqueList(list opt.ListID) bool {
	ls := listSorter{f: f, list: f.mem.lookupList(list)}
	for i := 0; i < int(list.Length-1); i++ {
		if !ls.less(i, i+1) {
			return false
		}
	}
	return true
}

// constructSortedUniqueList sorts the given list and removes duplicates, and
// returns the resulting list. See the comment for listSorter.compare for
// comparison rule details.
func (f *factory) constructSortedUniqueList(list opt.ListID) opt.ListID {
	// Make a copy of the list, since it needs to stay immutable.
	newList := make([]opt.GroupID, list.Length)
	copy(newList, f.mem.lookupList(list))
	ls := listSorter{f: f, list: newList}

	// Sort the list.
	sort.Slice(ls.list, ls.less)

	// Remove duplicates from the list.
	n := 0
	for i := 0; i < int(list.Length); i++ {
		if i == 0 || ls.compare(i-1, i) < 0 {
			newList[n] = newList[i]
			n++
		}
	}
	return f.mem.internList(newList[:n])
}

// listSorter is a helper struct that implements the sort.Slice "less"
// comparison function.
type listSorter struct {
	f    *factory
	list []opt.GroupID
}

// less returns true if item i in the list compares less than item j.
// sort.Slice uses this method to sort the list.
func (s listSorter) less(i, j int) bool {
	return s.compare(i, j) < 0
}

// compare returns -1 if item i compares less than item j, 0 if they are equal,
// and 1 if item i compares greater. Constants sort before non-constants, and
// are sorted and uniquified according to Datum comparison rules. Non-constants
// are sorted and uniquified by GroupID (arbitrary, but stable).
func (s listSorter) compare(i, j int) int {
	// If both are constant values, then use datum comparison.
	isLeftConst := s.f.mem.lookupNormExpr(s.list[i]).isConstValue()
	isRightConst := s.f.mem.lookupNormExpr(s.list[j]).isConstValue()
	if isLeftConst {
		if !isRightConst {
			// Constant always sorts before non-constant
			return -1
		}

		leftD := ExtractConstDatum(makeNormExprView(s.f.mem, s.list[i]))
		rightD := ExtractConstDatum(makeNormExprView(s.f.mem, s.list[j]))
		return leftD.Compare(s.f.evalCtx, rightD)
	} else if isRightConst {
		// Non-constant always sorts after constant.
		return 1
	}

	// Arbitrarily order by GroupID.
	if s.list[i] < s.list[j] {
		return -1
	} else if s.list[i] > s.list[j] {
		return 1
	}
	return 0
}

// ----------------------------------------------------------------------
//
// Typing functions
//   General custom match and replace functions used to test and construct
//   expression data types.
//
// ----------------------------------------------------------------------

// hasType returns true if the given expression has a static type that's
// equivalent to the requested type.
func (f *factory) hasType(group opt.GroupID, typ opt.PrivateID) bool {
	groupType := f.mem.lookupGroup(group).logical.Scalar.Type
	requestedType := f.mem.lookupPrivate(typ).(types.T)
	return groupType.Equivalent(requestedType)
}

func (f *factory) boolType() opt.PrivateID {
	return f.InternPrivate(types.Bool)
}

// canConstructBinary returns true if (op left right) has a valid binary op
// overload and is therefore legal to construct. For example, while
// (Minus <date> <int>) is valid, (Minus <int> <date>) is not.
func (f *factory) canConstructBinary(op opt.Operator, left, right opt.GroupID) bool {
	leftType := f.mem.lookupGroup(left).logical.Scalar.Type
	rightType := f.mem.lookupGroup(right).logical.Scalar.Type
	_, ok := findBinaryOverload(opt.MinusOp, rightType, leftType)
	return ok
}

// ----------------------------------------------------------------------
//
// Property functions
//   General custom match and replace functions used to test expression
//   logical properties.
//
// ----------------------------------------------------------------------

// lookupLogical returns the given group's logical properties.
func (f *factory) lookupLogical(group opt.GroupID) *LogicalProps {
	return &f.mem.lookupGroup(group).logical
}

// lookupRelational returns the given group's logical relational properties.
func (f *factory) lookupRelational(group opt.GroupID) *RelationalProps {
	return f.mem.lookupGroup(group).logical.Relational
}

// outputCols is a helper function that extracts the set of columns projected
// by the given operator. In addition to extracting columns from any relational
// operator, outputCols can also extract columns from the Projections and
// Aggregations scalar operators, which are used with Project and GroupBy.
func (f *factory) outputCols(group opt.GroupID) opt.ColSet {
	// Handle columns projected by relational operators.
	logical := f.lookupLogical(group)
	if logical.Relational != nil {
		return f.lookupRelational(group).OutputCols
	}

	// Handle columns projected by Aggregations and Projections operators.
	var colList opt.PrivateID
	expr := f.mem.lookupNormExpr(group)
	switch expr.op {
	case opt.AggregationsOp:
		colList = expr.asAggregations().cols()
	case opt.ProjectionsOp:
		colList = expr.asProjections().cols()
	default:
		panic(fmt.Sprintf("outputCols doesn't support op %s", expr.op))
	}

	return opt.ColListToSet(f.extractColList(colList))
}

// outerCols returns the set of outer columns associated with the given group,
// whether it be a relational or scalar operator.
func (f *factory) outerCols(group opt.GroupID) opt.ColSet {
	return f.lookupLogical(group).OuterCols()
}

// onlyConstants returns true if the scalar expression is a "constant
// expression tree", meaning that it will always evaluate to the same result.
// See the CommuteConst pattern comment for more details.
func (f *factory) onlyConstants(group opt.GroupID) bool {
	// TODO(andyk): Consider impact of "impure" functions with side effects.
	return f.mem.lookupGroup(group).logical.Scalar.OuterCols.Empty()
}

// hasSameCols returns true if the two groups have an identical set of output
// columns.
func (f *factory) hasSameCols(left, right opt.GroupID) bool {
	return f.outputCols(left).Equals(f.outputCols(right))
}

// ----------------------------------------------------------------------
//
// Project Rules
//   Custom match and replace functions used with project.opt rules.
//
// ----------------------------------------------------------------------

// neededCols returns the set of columns needed by the given group. It is an
// alias for outerCols that's used for clarity with the UnusedCols patterns.
func (f *factory) neededCols(group opt.GroupID) opt.ColSet {
	return f.outerCols(group)
}

// neededCols2 unions the set of columns needed by either of the given groups.
func (f *factory) neededCols2(left, right opt.GroupID) opt.ColSet {
	return f.outerCols(left).Union(f.outerCols(right))
}

// neededCols3 unions the set of columns needed by any of the given groups.
func (f *factory) neededCols3(group1, group2, group3 opt.GroupID) opt.ColSet {
	cols := f.outerCols(group1)
	cols.UnionWith(f.outerCols(group2))
	cols.UnionWith(f.outerCols(group3))
	return cols
}

// neededColsGroupBy unions the columns needed by either of a GroupBy's
// operands - either aggregations or groupingCols. This case doesn't fit any
// of the neededCols methods because groupingCols is a private, not a group.
func (f *factory) neededColsGroupBy(aggs opt.GroupID, groupingCols opt.PrivateID) opt.ColSet {
	colSet := *f.mem.lookupPrivate(groupingCols).(*opt.ColSet)
	return f.outerCols(aggs).Union(colSet)
}

// neededColsLimit unions the columns needed by Projections with the columns in
// the Ordering of a Limit/Offset operator.
func (f *factory) neededColsLimit(projections opt.GroupID, ordering opt.PrivateID) opt.ColSet {
	colSet := f.outerCols(projections).Copy()
	for _, col := range *f.mem.lookupPrivate(ordering).(*opt.Ordering) {
		colSet.Add(int(col.Index()))
	}
	return colSet
}

// hasUnusedColumns returns true if the target group has additional columns
// that are not part of the neededCols set.
func (f *factory) hasUnusedColumns(target opt.GroupID, neededCols opt.ColSet) bool {
	return !f.outputCols(target).Difference(neededCols).Empty()
}

// filterUnusedColumns creates an expression that discards any outputs columns
// of the given group that are not used. If the target expression type supports
// column filtering (like Scan, Values, Projections, etc.), then create a new
// instance of that operator that does the filtering. Otherwise, construct a
// Project operator that wraps the operator and does the filtering.
func (f *factory) filterUnusedColumns(target opt.GroupID, neededCols opt.ColSet) opt.GroupID {
	targetExpr := f.mem.lookupNormExpr(target)
	switch targetExpr.op {
	case opt.ScanOp:
		return f.filterUnusedScanColumns(target, neededCols)

	case opt.ValuesOp:
		return f.filterUnusedValuesColumns(target, neededCols)
	}

	// Get the subset of the target group's output columns that are in the
	// needed set (and discard those that aren't).
	colSet := f.outputCols(target).Intersection(neededCols)
	cnt := colSet.Len()

	// Create a new list of groups to project, along with the list of column
	// indexes to be projected. These will become inputs to the construction of
	// the Projections or Aggregations operator.
	groupList := make([]opt.GroupID, 0, cnt)
	colList := make(opt.ColList, 0, cnt)

	switch targetExpr.op {
	case opt.ProjectionsOp, opt.AggregationsOp:
		// Get groups from existing lists.
		var existingList []opt.GroupID
		var existingCols opt.ColList
		if targetExpr.op == opt.ProjectionsOp {
			existingList = f.mem.lookupList(targetExpr.asProjections().elems())
			existingCols = f.extractColList(targetExpr.asProjections().cols())
		} else {
			existingList = f.mem.lookupList(targetExpr.asAggregations().aggs())
			existingCols = f.extractColList(targetExpr.asAggregations().cols())
		}

		for i, group := range existingList {
			// Only add groups that are part of the needed columns.
			if neededCols.Contains(int(existingCols[i])) {
				groupList = append(groupList, group)
				colList = append(colList, existingCols[i])
			}
		}

	default:
		// Construct new variable groups for each output column that's needed.
		colSet.ForEach(func(i int) {
			v := f.ConstructVariable(f.InternPrivate(opt.ColumnIndex(i)))
			groupList = append(groupList, v)
			colList = append(colList, opt.ColumnIndex(i))
		})
	}

	if targetExpr.op == opt.AggregationsOp {
		return f.ConstructAggregations(f.InternList(groupList), f.InternPrivate(&colList))
	}

	projections := f.ConstructProjections(f.InternList(groupList), f.InternPrivate(&colList))
	if targetExpr.op == opt.ProjectionsOp {
		return projections
	}

	// Else wrap in Project operator.
	return f.ConstructProject(target, projections)
}

// filterUnusedScanColumns constructs a new Scan operator based on the given
// existing Scan operator, but projecting only the needed columns.
func (f *factory) filterUnusedScanColumns(scan opt.GroupID, neededCols opt.ColSet) opt.GroupID {
	colSet := f.outputCols(scan).Intersection(neededCols)
	scanExpr := f.mem.lookupNormExpr(scan).asScan()
	existing := f.mem.lookupPrivate(scanExpr.def()).(*opt.ScanOpDef)
	new := opt.ScanOpDef{Table: existing.Table, Cols: colSet}
	return f.ConstructScan(f.mem.internPrivate(&new))
}

// filterUnusedValuesColumns constructs a new Values operator based on the
// given existing Values operator. The new operator will have the same set of
// rows, but containing only the needed columns. Other columns are discarded.
func (f *factory) filterUnusedValuesColumns(values opt.GroupID, neededCols opt.ColSet) opt.GroupID {
	valuesExpr := f.mem.lookupNormExpr(values).asValues()
	existingCols := f.extractColList(valuesExpr.cols())
	newCols := make(opt.ColList, 0, neededCols.Len())

	existingRows := f.mem.lookupList(valuesExpr.rows())
	newRows := make([]opt.GroupID, 0, len(existingRows))

	// Create new list of columns that only contains needed columns.
	for _, colIndex := range existingCols {
		if !neededCols.Contains(int(colIndex)) {
			continue
		}
		newCols = append(newCols, colIndex)
	}

	// newElems is used to store tuple values, and can be allocated once and
	// reused repeatedly, since InternList will copy values to memo storage.
	newElems := make([]opt.GroupID, len(newCols))

	for _, row := range existingRows {
		existingElems := f.mem.lookupList(f.mem.lookupNormExpr(row).asTuple().elems())

		n := 0
		for i, elem := range existingElems {
			if !neededCols.Contains(int(existingCols[i])) {
				continue
			}

			newElems[n] = elem
			n++
		}

		newRows = append(newRows, f.ConstructTuple(f.InternList(newElems)))
	}

	return f.ConstructValues(f.InternList(newRows), f.InternPrivate(&newCols))
}

// ----------------------------------------------------------------------
//
// Select Rules
//   Custom match and replace functions used with select.opt rules.
//
// ----------------------------------------------------------------------

// emptyGroupingCols returns true if the given grouping columns for a GroupBy
// operator are empty.
func (f *factory) emptyGroupingCols(cols opt.PrivateID) bool {
	return f.mem.lookupPrivate(cols).(*opt.ColSet).Empty()
}

// isCorrelated returns true if variables in the source expression reference
// columns in the destination expression. For example:
//   (InnerJoin
//     (Scan a)
//     (Scan b)
//     (Eq (Variable a.x) (Const 1))
//   )
//
// The (Eq) expression is correlated with the (Scan a) expression because it
// references one of its columns. But the (Eq) expression is not correlated
// with the (Scan b) expression.
func (f *factory) isCorrelated(src, dst opt.GroupID) bool {
	return f.outerCols(src).Intersects(f.outputCols(dst))
}

// extractCorrelatedConditions returns a new list containing only those
// expressions from the given list that are correlated with the destination
// expression. For example:
//   (InnerJoin
//     (Scan a)
//     (Scan b)
//     (Filters [
//       (Eq (Variable a.x) (Variable b.x))
//       (Gt (Variable a.x) (Const 1))
//     ])
//   )
//
// Calling extractCorrelatedConditions with the filter conditions list and
// (Scan b) as the destination would extract the (Eq) expression, since it
// references columns from b.
func (f *factory) extractCorrelatedConditions(list opt.ListID, dst opt.GroupID) opt.ListID {
	extracted := make([]opt.GroupID, 0, list.Length)
	for _, item := range f.mem.lookupList(list) {
		if f.isCorrelated(item, dst) {
			extracted = append(extracted, item)
		}
	}
	return f.mem.internList(extracted)
}

// extractUncorrelatedConditions is the inverse of extractCorrelatedConditions.
// Instead of extracting correlated expressions, it extracts list expressions
// that are *not* correlated with the destination.
func (f *factory) extractUncorrelatedConditions(list opt.ListID, dst opt.GroupID) opt.ListID {
	extracted := make([]opt.GroupID, 0, list.Length)
	for _, item := range f.mem.lookupList(list) {
		if !f.isCorrelated(item, dst) {
			extracted = append(extracted, item)
		}
	}
	return f.mem.internList(extracted)
}

// concatFilters creates a new Filters operator that contains conditions from
// both the left and right boolean filter expressions. If the left or right
// expression is itself a Filters operator, then it is "flattened" by merging
// its conditions into the new Filters operator.
func (f *factory) concatFilters(left, right opt.GroupID) opt.GroupID {
	leftExpr := f.mem.lookupNormExpr(left)
	rightExpr := f.mem.lookupNormExpr(right)

	// Handle cases where left/right filters are constant boolean values.
	if leftExpr.op == opt.TrueOp || rightExpr.op == opt.FalseOp {
		return right
	}
	if rightExpr.op == opt.TrueOp || leftExpr.op == opt.FalseOp {
		return left
	}

	// Determine how large to make the conditions slice (at least 2 slots).
	cnt := 2
	leftFiltersExpr := leftExpr.asFilters()
	if leftFiltersExpr != nil {
		cnt += int(leftFiltersExpr.conditions().Length) - 1
	}
	rightFiltersExpr := rightExpr.asFilters()
	if rightFiltersExpr != nil {
		cnt += int(rightFiltersExpr.conditions().Length) - 1
	}

	// Create the conditions slice and populate it.
	conditions := make([]opt.GroupID, 0, cnt)
	if leftFiltersExpr != nil {
		conditions = append(conditions, f.mem.lookupList(leftFiltersExpr.conditions())...)
	} else {
		conditions = append(conditions, left)
	}
	if rightFiltersExpr != nil {
		conditions = append(conditions, f.mem.lookupList(rightFiltersExpr.conditions())...)
	} else {
		conditions = append(conditions, right)
	}
	return f.ConstructFilters(f.InternList(conditions))
}

// ----------------------------------------------------------------------
//
// Boolean Rules
//   Custom match and replace functions used with bool.opt rules.
//
// ----------------------------------------------------------------------

// simplifyAnd removes True operands from an And operator, and eliminates the
// And operator altogether if any operand is False. It also "flattens" any And
// operator child by merging its conditions into the top-level list. Only one
// level of flattening is necessary, since this pattern would have already
// matched any And operator children. If, after simplification, no operands
// remain, then simplifyAnd returns True.
func (f *factory) simplifyAnd(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length+1)
	for _, item := range f.mem.lookupList(conditions) {
		itemExpr := f.mem.lookupNormExpr(item)

		switch itemExpr.op {
		case opt.AndOp:
			// Flatten nested And operands.
			list = append(list, f.mem.lookupList(itemExpr.asAnd().conditions())...)

		case opt.TrueOp:
			// And operator skips True operands.

		case opt.FalseOp:
			// Entire And evaluates to False if any operand is False.
			return item

		default:
			list = append(list, item)
		}
	}

	if len(list) == 0 {
		return f.ConstructTrue()
	}
	return f.ConstructAnd(f.mem.internList(list))
}

// simplifyOr removes False operands from an Or operator, and eliminates the Or
// operator altogether if any operand is True. It also "flattens" any Or
// operator child by merging its conditions into the top-level list. Only one
// level of flattening is necessary, since this pattern would have already
// matched any Or operator children. If, after simplification, no operands
// remain, then simplifyOr returns False.
func (f *factory) simplifyOr(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length+1)
	for _, item := range f.mem.lookupList(conditions) {
		itemExpr := f.mem.lookupNormExpr(item)

		switch itemExpr.op {
		case opt.OrOp:
			// Flatten nested Or operands.
			list = append(list, f.mem.lookupList(itemExpr.asOr().conditions())...)

		case opt.FalseOp:
			// Or operator skips False operands.

		case opt.TrueOp:
			// Entire Or evaluates to True if any operand is True.
			return item

		default:
			list = append(list, item)
		}
	}

	if len(list) == 0 {
		return f.ConstructFalse()
	}
	return f.ConstructOr(f.mem.internList(list))
}

// simplifyFilters behaves the same way as simplifyAnd, with one addition: if
// the conditions include a Null value in any position, then the entire
// expression is False. This works because the Filters expression only appears
// as a Select or Join filter condition, both of which treat a Null filter
// conjunct exactly as if it were False.
func (f *factory) simplifyFilters(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length+1)
	for _, item := range f.mem.lookupList(conditions) {
		itemExpr := f.mem.lookupNormExpr(item)

		switch itemExpr.op {
		case opt.AndOp:
			// Flatten nested And operands.
			list = append(list, f.mem.lookupList(itemExpr.asAnd().conditions())...)

		case opt.TrueOp:
			// Filters operator skips True operands.

		case opt.FalseOp:
			// Filters expression evaluates to False if any operand is False.
			return item

		case opt.NullOp:
			// Filters expression evaluates to False if any operand is False.
			return f.ConstructFalse()

		default:
			list = append(list, item)
		}
	}

	if len(list) == 0 {
		return f.ConstructTrue()
	}
	return f.ConstructFilters(f.mem.internList(list))
}

// negateConditions negates the given conditions and puts them in a new list.
func (f *factory) negateConditions(conditions opt.ListID) opt.ListID {
	list := f.mem.lookupList(conditions)
	negCond := make([]opt.GroupID, len(list))
	for i := range list {
		negCond[i] = f.ConstructNot(list[i])
	}
	return f.mem.internList(negCond)
}

// negateComparison negates a comparison op like:
//   a.x = 5
// to:
//   a.x <> 5
func (f *factory) negateComparison(cmp opt.Operator, left, right opt.GroupID) opt.GroupID {
	switch cmp {
	case opt.EqOp:
		return f.ConstructNe(left, right)
	case opt.NeOp:
		return f.ConstructEq(left, right)
	case opt.GtOp:
		return f.ConstructLe(left, right)
	case opt.GeOp:
		return f.ConstructLt(left, right)
	case opt.LtOp:
		return f.ConstructGe(left, right)
	case opt.LeOp:
		return f.ConstructGt(left, right)
	case opt.InOp:
		return f.ConstructNotIn(left, right)
	case opt.NotInOp:
		return f.ConstructIn(left, right)
	case opt.LikeOp:
		return f.ConstructNotLike(left, right)
	case opt.NotLikeOp:
		return f.ConstructLike(left, right)
	case opt.ILikeOp:
		return f.ConstructNotILike(left, right)
	case opt.NotILikeOp:
		return f.ConstructILike(left, right)
	case opt.SimilarToOp:
		return f.ConstructNotSimilarTo(left, right)
	case opt.NotSimilarToOp:
		return f.ConstructSimilarTo(left, right)
	case opt.RegMatchOp:
		return f.ConstructNotRegMatch(left, right)
	case opt.NotRegMatchOp:
		return f.ConstructRegMatch(left, right)
	case opt.RegIMatchOp:
		return f.ConstructNotRegIMatch(left, right)
	case opt.NotRegIMatchOp:
		return f.ConstructRegIMatch(left, right)
	case opt.IsOp:
		return f.ConstructIsNot(left, right)
	case opt.IsNotOp:
		return f.ConstructIs(left, right)
	default:
		panic(fmt.Sprintf("unexpected operator: %v", cmp))
	}
}

// commuteInequality swaps the operands of an inequality comparison expression,
// changing the operator to compensate:
//   5 < x
// to:
//   x > 5
func (f *factory) commuteInequality(op opt.Operator, left, right opt.GroupID) opt.GroupID {
	switch op {
	case opt.GeOp:
		return f.ConstructLe(right, left)
	case opt.GtOp:
		return f.ConstructLt(right, left)
	case opt.LeOp:
		return f.ConstructGe(right, left)
	case opt.LtOp:
		return f.ConstructGt(right, left)
	}
	panic(fmt.Sprintf("called commuteInequality with operator %s", op))
}

// ----------------------------------------------------------------------
//
// Comparison Rules
//   Custom match and replace functions used with comp.opt rules.
//
// ----------------------------------------------------------------------

// normalizeTupleEquality remaps the elements of two tuples compared for
// equality, like this:
//   (a, b, c) = (x, y, z)
// into this:
//   (a = x) AND (b = y) AND (c = z)
func (f *factory) normalizeTupleEquality(left, right opt.ListID) opt.GroupID {
	if left.Length != right.Length {
		panic("tuple length mismatch")
	}

	leftList := f.mem.lookupList(left)
	rightList := f.mem.lookupList(right)
	conditions := make([]opt.GroupID, left.Length)
	for i := range conditions {
		conditions[i] = f.ConstructEq(leftList[i], rightList[i])
	}
	return f.ConstructAnd(f.InternList(conditions))
}

// ----------------------------------------------------------------------
//
// Scalar Rules
//   Custom match and replace functions used with scalar.opt rules.
//
// ----------------------------------------------------------------------

// simplifyCoalesce discards any leading null operands, and then if the next
// operand is a constant, replaces with that constant.
func (f *factory) simplifyCoalesce(args opt.ListID) opt.GroupID {
	argList := f.mem.lookupList(args)
	for i := 0; i < int(args.Length-1); i++ {
		// If item is not a constant value, then its value may turn out to be
		// null, so no more folding. Return operands from then on.
		item := f.mem.lookupNormExpr(argList[i])
		if !item.isConstValue() {
			return f.ConstructCoalesce(f.InternList(argList[i:]))
		}

		if item.op != opt.NullOp {
			return argList[i]
		}
	}

	// All operands up to the last were null (or the last is the only operand),
	// so return the last operand without the wrapping COALESCE function.
	return argList[args.Length-1]
}

// allowNullArgs returns true if the binary operator with the given inputs
// allows one of those inputs to be null. If not, then the binary operator will
// simply be replaced by null.
func (f *factory) allowNullArgs(op opt.Operator, left, right opt.GroupID) bool {
	leftType := f.mem.lookupGroup(left).logical.Scalar.Type
	rightType := f.mem.lookupGroup(right).logical.Scalar.Type
	overload, ok := findBinaryOverload(op, leftType, rightType)
	if !ok {
		panic(fmt.Sprintf("could not find overload for binary expression %s", op))
	}
	return overload.allowNullArgs
}

// foldNullUnary replaces the unary operator with a typed null value having the
// same type as the unary operator would have.
func (f *factory) foldNullUnary(op opt.Operator, input opt.GroupID) opt.GroupID {
	typ := f.mem.lookupGroup(input).logical.Scalar.Type
	return f.ConstructNull(f.InternPrivate(inferUnaryType(op, typ)))
}

// foldNullBinary replaces the binary operator with a typed null value having
// the same type as the binary operator would have.
func (f *factory) foldNullBinary(op opt.Operator, left, right opt.GroupID) opt.GroupID {
	leftType := f.mem.lookupGroup(left).logical.Scalar.Type
	rightType := f.mem.lookupGroup(right).logical.Scalar.Type
	return f.ConstructNull(f.InternPrivate(inferBinaryType(op, leftType, rightType)))
}

// ----------------------------------------------------------------------
//
// Numeric Rules
//   Custom match and replace functions used with numeric.opt rules.
//
// ----------------------------------------------------------------------

// isZero returns true if the input expression is a numeric constant with a
// value of zero.
func (f *factory) isZero(input opt.GroupID) bool {
	d := f.mem.lookupPrivate(f.mem.lookupNormExpr(input).asConst().value()).(tree.Datum)
	switch t := d.(type) {
	case *tree.DDecimal:
		return t.Decimal.Sign() == 0
	case *tree.DFloat:
		return *t == 0
	case *tree.DInt:
		return *t == 0
	}
	return false
}

// isOne returns true if the input expression is a numeric constant with a
// value of one.
func (f *factory) isOne(input opt.GroupID) bool {
	d := f.mem.lookupPrivate(f.mem.lookupNormExpr(input).asConst().value()).(tree.Datum)
	switch t := d.(type) {
	case *tree.DDecimal:
		return t.Decimal.Cmp(&tree.DecimalOne.Decimal) == 0
	case *tree.DFloat:
		return *t == 1.0
	case *tree.DInt:
		return *t == 1
	}
	return false
}
