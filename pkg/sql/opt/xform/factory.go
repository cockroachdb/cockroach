// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package xform

import (
	"fmt"

	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/optbase"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

//go:generate optgen -out factory.og.go factory ../ops/scalar.opt ../ops/relational.opt ../ops/enforcer.opt rules/project.opt rules/scalar.opt rules/bool.opt rules/comp.opt rules/numeric.opt

// Factory constructs a normalized expression tree within the memo. As each
// kind of expression is constructed by the factory, it transitively runs
// normalization transformations defined for that expression type. This may
// result in the construction of a different type of expression than what was
// requested. If, after normalization, the expression is already part of the
// memo, then construction is a no-op. Otherwise, a new memo group is created,
// with the normalized expression as its first and only expression.
//
// Factory is largely auto-generated by optgen. The generated code can be found
// in factory.og.go. The factory.go file contains helper functions that are
// invoked by normalization patterns. While most patterns are specified in the
// optgen DSL, the factory always calls the `onConstruct` method as its last
// step, in order to allow any custom manual code to execute.
type factory struct {
	mem *memo

	// maxSteps sets the maximum number of optimization patterns that the
	// factory will apply. Once this maximum is reached, the factory will
	// construct the requested operator without applying any rewrites to it.
	// This method is useful for debugging, in order to see intermediate
	// optimization steps.
	maxSteps OptimizeSteps
}

var _ opt.Factory = &factory{}

// NewFactory returns a new Factory structure with a new, blank memo
// structure inside.
func newFactory(catalog optbase.Catalog, maxSteps OptimizeSteps) *factory {
	return &factory{mem: newMemo(catalog), maxSteps: maxSteps}
}

// Metadata returns the query-specific metadata, which includes information
// about the columns and tables used in this particular query.
func (f *factory) Metadata() *opt.Metadata {
	return f.mem.metadata
}

// InternList adds the given list of group IDs to memo storage and returns an
// ID that can be used for later lookup. If the same list was added previously,
// this method is a no-op and returns the ID of the previous value.
func (f *factory) InternList(items []opt.GroupID) opt.ListID {
	return f.mem.internList(items)
}

// InternPrivate adds the given private value to the memo and returns an ID
// that can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (f *factory) InternPrivate(private interface{}) opt.PrivateID {
	return f.mem.internPrivate(private)
}

// allowOptimizations returns true if optimizations are currently enabled. Each
// individual optimization decrements the maxSteps counter. Once it reaches
// zero (or if it was zero to begin with), no further optimizations will be
// performed.
func (f *factory) allowOptimizations() bool {
	return f.maxSteps > 0
}

// reportOptimization is called when an optimization has been performed on the
// tree. It decrements the maxSteps counter. Once that reaches zero, no further
// optimizations will be performed.
func (f *factory) reportOptimization() {
	f.maxSteps--
}

// onConstruct is called as a final step by each factory construction method,
// so that any custom manual pattern matching/replacement code can be run.
func (f *factory) onConstruct(group opt.GroupID) opt.GroupID {
	return group
}

// ----------------------------------------------------------------------
//
// List functions
//   General custom match and replace functions used to test and construct
//   lists.
//
// ----------------------------------------------------------------------

// listOnlyHasNulls if every item in the given list is a Null op. If the list
// is empty, listOnlyHasNulls returns false.
func (f *factory) listOnlyHasNulls(list opt.ListID) bool {
	if list.Length == 0 {
		return false
	}

	for _, item := range f.mem.lookupList(list) {
		if f.mem.lookupNormExpr(item).op != opt.NullOp {
			return false
		}
	}
	return true
}

// ----------------------------------------------------------------------
//
// Typing functions
//   General custom match and replace functions used to test and construct
//   expression data types.
//
// ----------------------------------------------------------------------

func (f *factory) boolType() opt.PrivateID {
	return f.InternPrivate(types.Bool)
}

// ----------------------------------------------------------------------
//
// Project Rules
//   Custom match and replace functions used with project.opt rules.
//
// ----------------------------------------------------------------------

// hasSameProjectionCols returns true if the given expression has the same set
// of output columns that the given Projections expression has.
func (f *factory) hasSameProjectionCols(group, projections opt.GroupID) bool {
	groupOutputCols := f.mem.lookupGroup(group).logical.Relational.OutputCols
	projectionsExpr := f.mem.lookupNormExpr(projections).asProjections()
	colList := *f.mem.lookupPrivate(projectionsExpr.cols()).(*opt.ColList)
	projectOutputCols := opt.ColListToSet(colList)
	return groupOutputCols.Equals(projectOutputCols)
}

// ----------------------------------------------------------------------
//
// Boolean Rules
//   Custom match and replace functions used with bool.opt rules.
//
// ----------------------------------------------------------------------

// flattenAnd constructs an And operator from the list of input conditions.
// If any of the conditions is itself an And operator, then "flatten" it by
// merging its conditions into the top-level list. Only one level of flattening
// is necessary, since this pattern would have already matched any And operator
// children.
func (f *factory) flattenAnd(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length+1)
	for _, item := range f.mem.lookupList(conditions) {
		and := f.mem.lookupNormExpr(item).asAnd()
		if and != nil {
			list = append(list, f.mem.lookupList(and.conditions())...)
		} else {
			list = append(list, item)
		}
	}
	return f.ConstructAnd(f.mem.internList(list))
}

// flattenOr constructs an Or operator from the list of input conditions. If
// any of the conditions is itself an Or operator, then "flatten" it by merging
// its conditions into the top-level list. Only one level of flattening is
// necessary, since this pattern would have already matched any Or operator
// children.
func (f *factory) flattenOr(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length+1)
	for _, item := range f.mem.lookupList(conditions) {
		or := f.mem.lookupNormExpr(item).asOr()
		if or != nil {
			list = append(list, f.mem.lookupList(or.conditions())...)
		} else {
			list = append(list, item)
		}
	}
	return f.ConstructOr(f.mem.internList(list))
}

// simplifyAnd removes True operands from an And operator, and eliminates the
// And operator altogether if any operand is False. If, after simplification,
// no operands remain, then simplifyAnd returns True.
func (f *factory) simplifyAnd(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length-1)
	for _, item := range f.mem.lookupList(conditions) {
		itemExpr := f.mem.lookupNormExpr(item)

		switch itemExpr.op {
		case opt.FalseOp:
			// Entire And evaluates to False if any operand is False.
			return item
		case opt.TrueOp:
			// And operator skips True operands.
		default:
			list = append(list, item)
		}
	}

	if len(list) == 0 {
		return f.ConstructTrue()
	}
	return f.ConstructAnd(f.mem.internList(list))
}

// simplifyOr removes False operands from an Or operator, and eliminates the
// Or operator altogether if any operand is True. If, after simplification,
// no operands remain, then simplifyOr returns False.
func (f *factory) simplifyOr(conditions opt.ListID) opt.GroupID {
	list := make([]opt.GroupID, 0, conditions.Length-1)
	for _, item := range f.mem.lookupList(conditions) {
		itemExpr := f.mem.lookupNormExpr(item)

		switch itemExpr.op {
		case opt.TrueOp:
			// Entire Or evaluates to True if any operand is True.
			return item
		case opt.FalseOp:
			// Or operator skips False operands.
		default:
			list = append(list, item)
		}
	}

	if len(list) == 0 {
		return f.ConstructFalse()
	}
	return f.ConstructOr(f.mem.internList(list))
}

// invertComparison negates a comparison op like:
//   a.x = 5
// to:
//   a.x <> 5
func (f *factory) invertComparison(cmp opt.Operator, left, right opt.GroupID) opt.GroupID {
	switch cmp {
	case opt.EqOp:
		return f.ConstructNe(left, right)
	case opt.NeOp:
		return f.ConstructEq(left, right)
	case opt.GtOp:
		return f.ConstructLe(left, right)
	case opt.GeOp:
		return f.ConstructLt(left, right)
	case opt.LtOp:
		return f.ConstructGe(left, right)
	case opt.LeOp:
		return f.ConstructGt(left, right)
	case opt.InOp:
		return f.ConstructNotIn(left, right)
	case opt.NotInOp:
		return f.ConstructIn(left, right)
	case opt.LikeOp:
		return f.ConstructNotLike(left, right)
	case opt.NotLikeOp:
		return f.ConstructLike(left, right)
	case opt.ILikeOp:
		return f.ConstructNotILike(left, right)
	case opt.NotILikeOp:
		return f.ConstructILike(left, right)
	case opt.SimilarToOp:
		return f.ConstructNotSimilarTo(left, right)
	case opt.NotSimilarToOp:
		return f.ConstructSimilarTo(left, right)
	case opt.RegMatchOp:
		return f.ConstructNotRegMatch(left, right)
	case opt.NotRegMatchOp:
		return f.ConstructRegMatch(left, right)
	case opt.RegIMatchOp:
		return f.ConstructNotRegIMatch(left, right)
	case opt.NotRegIMatchOp:
		return f.ConstructRegIMatch(left, right)
	case opt.IsOp:
		return f.ConstructIsNot(left, right)
	case opt.IsNotOp:
		return f.ConstructIs(left, right)
	default:
		panic(fmt.Sprintf("unexpected operator: %v", cmp))
	}
}

// ----------------------------------------------------------------------
//
// Comparison Rules
//   Custom match and replace functions used with comp.opt rules.
//
// ----------------------------------------------------------------------

// normalizeTupleEquality remaps the elements of two tuples compared for
// equality, like this:
//   (a, b, c) = (x, y, z)
// into this:
//   (a = x) AND (b = y) AND (c = z)
func (f *factory) normalizeTupleEquality(left, right opt.ListID) opt.GroupID {
	if left.Length != right.Length {
		panic("tuple length mismatch")
	}

	leftList := f.mem.lookupList(left)
	rightList := f.mem.lookupList(right)
	conditions := make([]opt.GroupID, left.Length)
	for i := range conditions {
		conditions[i] = f.ConstructEq(leftList[i], rightList[i])
	}
	return f.ConstructAnd(f.InternList(conditions))
}

// ----------------------------------------------------------------------
//
// Scalar Rules
//   Custom match and replace functions used with scalar.opt rules.
//
// ----------------------------------------------------------------------

// simplifyCoalesce discards any leading null operands, and then if the next
// operand is a constant, replaces with that constant.
func (f *factory) simplifyCoalesce(args opt.ListID) opt.GroupID {
	argList := f.mem.lookupList(args)
	for i := 0; i < int(args.Length-1); i++ {
		// If item is not a constant value, then its value may turn out to be
		// null, so no more folding. Return operands from then on.
		item := f.mem.lookupNormExpr(argList[i])
		if !item.isConstValue() {
			return f.ConstructCoalesce(f.InternList(argList[i:]))
		}

		if item.op != opt.NullOp {
			return argList[i]
		}
	}

	// All operands up to the last were null (or the last is the only operand),
	// so return the last operand without the wrapping COALESCE function.
	return argList[args.Length-1]
}

// allowNullArgs returns true if the binary operator with the given inputs
// allows one of those inputs to be null. If not, then the binary operator will
// simply be replaced by null.
func (f *factory) allowNullArgs(op opt.Operator, left, right opt.GroupID) bool {
	leftType := f.mem.lookupGroup(left).logical.Scalar.Type
	rightType := f.mem.lookupGroup(right).logical.Scalar.Type
	_, allowNulls := resolveBinary(op, leftType, rightType)
	return allowNulls
}

// foldNullUnary replaces the unary operator with a typed null value having the
// same type as the unary operator would have.
func (f *factory) foldNullUnary(op opt.Operator, input opt.GroupID) opt.GroupID {
	typ := f.mem.lookupGroup(input).logical.Scalar.Type
	return f.ConstructNull(f.InternPrivate(inferUnaryType(op, typ)))
}

// foldNullBinary replaces the binary operator with a typed null value having
// the same type as the binary operator would have.
func (f *factory) foldNullBinary(op opt.Operator, left, right opt.GroupID) opt.GroupID {
	leftType := f.mem.lookupGroup(left).logical.Scalar.Type
	rightType := f.mem.lookupGroup(right).logical.Scalar.Type
	return f.ConstructNull(f.InternPrivate(inferBinaryType(op, leftType, rightType)))
}

// ----------------------------------------------------------------------
//
// Numeric Rules
//   Custom match and replace functions used with numeric.opt rules.
//
// ----------------------------------------------------------------------

// isZero returns true if the input expression is a numeric constant with a
// value of zero.
func (f *factory) isZero(input opt.GroupID) bool {
	d := f.mem.lookupPrivate(f.mem.lookupNormExpr(input).asConst().value()).(tree.Datum)
	switch t := d.(type) {
	case *tree.DDecimal:
		return t.Decimal.Sign() == 0
	case *tree.DFloat:
		return *t == 0
	case *tree.DInt:
		return *t == 0
	}
	return false
}

// isOne returns true if the input expression is a numeric constant with a
// value of one.
func (f *factory) isOne(input opt.GroupID) bool {
	d := f.mem.lookupPrivate(f.mem.lookupNormExpr(input).asConst().value()).(tree.Datum)
	switch t := d.(type) {
	case *tree.DDecimal:
		return t.Decimal.Cmp(&tree.DecimalOne.Decimal) == 0
	case *tree.DFloat:
		return *t == 1.0
	case *tree.DInt:
		return *t == 1
	}
	return false
}
