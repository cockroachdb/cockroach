// Code generated by langgen; DO NOT EDIT.

package lang

import (
	"bytes"
	"fmt"
)

type RootExpr struct {
	Defines DefineSetExpr
	Rules   RuleSetExpr
	Src     *SourceLoc
}

func (e *RootExpr) Op() Operator {
	return RootOp
}

func (e *RootExpr) ChildCount() int {
	return 2
}

func (e *RootExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Defines
	case 1:
		return &e.Rules
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *RootExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Defines"
	case 1:
		return "Rules"
	}
	return ""
}

func (e *RootExpr) Value() interface{} {
	return nil
}

func (e *RootExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &RootExpr{Defines: *children[0].(*DefineSetExpr), Rules: *children[1].(*RuleSetExpr), Src: e.Source()}
	}
	return e
}

func (e *RootExpr) Source() *SourceLoc {
	return e.Src
}

func (e *RootExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *RootExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type DefineSetExpr []*DefineExpr

func (e *DefineSetExpr) Op() Operator {
	return DefineSetOp
}

func (e *DefineSetExpr) ChildCount() int {
	return len(*e)
}

func (e *DefineSetExpr) Child(nth int) Expr {
	return (*e)[nth]
}

func (e *DefineSetExpr) ChildName(nth int) string {
	return ""
}

func (e *DefineSetExpr) Value() interface{} {
	return nil
}

func (e *DefineSetExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(DefineSetExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = children[i].(*DefineExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *DefineSetExpr) Source() *SourceLoc {
	return nil
}

func (e *DefineSetExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *DefineSetExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type RuleSetExpr []*RuleExpr

func (e *RuleSetExpr) Op() Operator {
	return RuleSetOp
}

func (e *RuleSetExpr) ChildCount() int {
	return len(*e)
}

func (e *RuleSetExpr) Child(nth int) Expr {
	return (*e)[nth]
}

func (e *RuleSetExpr) ChildName(nth int) string {
	return ""
}

func (e *RuleSetExpr) Value() interface{} {
	return nil
}

func (e *RuleSetExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(RuleSetExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = children[i].(*RuleExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *RuleSetExpr) Source() *SourceLoc {
	return nil
}

func (e *RuleSetExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *RuleSetExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type DefineExpr struct {
	Comments CommentsExpr
	Tags     TagsExpr
	Name     StringExpr
	Fields   DefineFieldsExpr
	Src      *SourceLoc
}

func (e *DefineExpr) Op() Operator {
	return DefineOp
}

func (e *DefineExpr) ChildCount() int {
	return 4
}

func (e *DefineExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Comments
	case 1:
		return &e.Tags
	case 2:
		return &e.Name
	case 3:
		return &e.Fields
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *DefineExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Comments"
	case 1:
		return "Tags"
	case 2:
		return "Name"
	case 3:
		return "Fields"
	}
	return ""
}

func (e *DefineExpr) Value() interface{} {
	return nil
}

func (e *DefineExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &DefineExpr{Comments: *children[0].(*CommentsExpr), Tags: *children[1].(*TagsExpr), Name: *children[2].(*StringExpr), Fields: *children[3].(*DefineFieldsExpr), Src: e.Source()}
	}
	return e
}

func (e *DefineExpr) Source() *SourceLoc {
	return e.Src
}

func (e *DefineExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *DefineExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type CommentsExpr []CommentExpr

func (e *CommentsExpr) Op() Operator {
	return CommentsOp
}

func (e *CommentsExpr) ChildCount() int {
	return len(*e)
}

func (e *CommentsExpr) Child(nth int) Expr {
	return &(*e)[nth]
}

func (e *CommentsExpr) ChildName(nth int) string {
	return ""
}

func (e *CommentsExpr) Value() interface{} {
	return nil
}

func (e *CommentsExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(CommentsExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = *children[i].(*CommentExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *CommentsExpr) Source() *SourceLoc {
	return nil
}

func (e *CommentsExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *CommentsExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type CommentExpr string

func (e *CommentExpr) Op() Operator {
	return CommentOp
}

func (e *CommentExpr) ChildCount() int {
	return 0
}

func (e *CommentExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *CommentExpr) ChildName(nth int) string {
	return ""
}

func (e *CommentExpr) Value() interface{} {
	return string(*e)
}

func (e *CommentExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *CommentExpr) Source() *SourceLoc {
	return nil
}

func (e *CommentExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *CommentExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type TagsExpr []TagExpr

func (e *TagsExpr) Op() Operator {
	return TagsOp
}

func (e *TagsExpr) ChildCount() int {
	return len(*e)
}

func (e *TagsExpr) Child(nth int) Expr {
	return &(*e)[nth]
}

func (e *TagsExpr) ChildName(nth int) string {
	return ""
}

func (e *TagsExpr) Value() interface{} {
	return nil
}

func (e *TagsExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(TagsExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = *children[i].(*TagExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *TagsExpr) Source() *SourceLoc {
	return nil
}

func (e *TagsExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *TagsExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type TagExpr string

func (e *TagExpr) Op() Operator {
	return TagOp
}

func (e *TagExpr) ChildCount() int {
	return 0
}

func (e *TagExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *TagExpr) ChildName(nth int) string {
	return ""
}

func (e *TagExpr) Value() interface{} {
	return string(*e)
}

func (e *TagExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *TagExpr) Source() *SourceLoc {
	return nil
}

func (e *TagExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *TagExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type DefineFieldsExpr []*DefineFieldExpr

func (e *DefineFieldsExpr) Op() Operator {
	return DefineFieldsOp
}

func (e *DefineFieldsExpr) ChildCount() int {
	return len(*e)
}

func (e *DefineFieldsExpr) Child(nth int) Expr {
	return (*e)[nth]
}

func (e *DefineFieldsExpr) ChildName(nth int) string {
	return ""
}

func (e *DefineFieldsExpr) Value() interface{} {
	return nil
}

func (e *DefineFieldsExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(DefineFieldsExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = children[i].(*DefineFieldExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *DefineFieldsExpr) Source() *SourceLoc {
	return nil
}

func (e *DefineFieldsExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *DefineFieldsExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type DefineFieldExpr struct {
	Name StringExpr
	Type StringExpr
	Src  *SourceLoc
}

func (e *DefineFieldExpr) Op() Operator {
	return DefineFieldOp
}

func (e *DefineFieldExpr) ChildCount() int {
	return 2
}

func (e *DefineFieldExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Name
	case 1:
		return &e.Type
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *DefineFieldExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Name"
	case 1:
		return "Type"
	}
	return ""
}

func (e *DefineFieldExpr) Value() interface{} {
	return nil
}

func (e *DefineFieldExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &DefineFieldExpr{Name: *children[0].(*StringExpr), Type: *children[1].(*StringExpr), Src: e.Source()}
	}
	return e
}

func (e *DefineFieldExpr) Source() *SourceLoc {
	return e.Src
}

func (e *DefineFieldExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *DefineFieldExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type RuleExpr struct {
	Comments CommentsExpr
	Name     StringExpr
	Tags     TagsExpr
	Match    *MatchExpr
	Replace  Expr
	Src      *SourceLoc
}

func (e *RuleExpr) Op() Operator {
	return RuleOp
}

func (e *RuleExpr) ChildCount() int {
	return 5
}

func (e *RuleExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Comments
	case 1:
		return &e.Name
	case 2:
		return &e.Tags
	case 3:
		return e.Match
	case 4:
		return e.Replace
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *RuleExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Comments"
	case 1:
		return "Name"
	case 2:
		return "Tags"
	case 3:
		return "Match"
	case 4:
		return "Replace"
	}
	return ""
}

func (e *RuleExpr) Value() interface{} {
	return nil
}

func (e *RuleExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &RuleExpr{Comments: *children[0].(*CommentsExpr), Name: *children[1].(*StringExpr), Tags: *children[2].(*TagsExpr), Match: children[3].(*MatchExpr), Replace: children[4], Src: e.Source()}
	}
	return e
}

func (e *RuleExpr) Source() *SourceLoc {
	return e.Src
}

func (e *RuleExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *RuleExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type BindExpr struct {
	Label  StringExpr
	Target Expr
	Src    *SourceLoc
}

func (e *BindExpr) Op() Operator {
	return BindOp
}

func (e *BindExpr) ChildCount() int {
	return 2
}

func (e *BindExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Label
	case 1:
		return e.Target
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *BindExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Label"
	case 1:
		return "Target"
	}
	return ""
}

func (e *BindExpr) Value() interface{} {
	return nil
}

func (e *BindExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &BindExpr{Label: *children[0].(*StringExpr), Target: children[1], Src: e.Source()}
	}
	return e
}

func (e *BindExpr) Source() *SourceLoc {
	return e.Src
}

func (e *BindExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *BindExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type RefExpr struct {
	Label StringExpr
	Src   *SourceLoc
}

func (e *RefExpr) Op() Operator {
	return RefOp
}

func (e *RefExpr) ChildCount() int {
	return 1
}

func (e *RefExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Label
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *RefExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Label"
	}
	return ""
}

func (e *RefExpr) Value() interface{} {
	return nil
}

func (e *RefExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &RefExpr{Label: *children[0].(*StringExpr), Src: e.Source()}
	}
	return e
}

func (e *RefExpr) Source() *SourceLoc {
	return e.Src
}

func (e *RefExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *RefExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchExpr struct {
	Names NamesExpr
	Args  ListExpr
	Src   *SourceLoc
}

func (e *MatchExpr) Op() Operator {
	return MatchOp
}

func (e *MatchExpr) ChildCount() int {
	return 2
}

func (e *MatchExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Names
	case 1:
		return &e.Args
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Names"
	case 1:
		return "Args"
	}
	return ""
}

func (e *MatchExpr) Value() interface{} {
	return nil
}

func (e *MatchExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchExpr{Names: *children[0].(*NamesExpr), Args: *children[1].(*ListExpr), Src: e.Source()}
	}
	return e
}

func (e *MatchExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type NamesExpr []NameExpr

func (e *NamesExpr) Op() Operator {
	return NamesOp
}

func (e *NamesExpr) ChildCount() int {
	return len(*e)
}

func (e *NamesExpr) Child(nth int) Expr {
	return &(*e)[nth]
}

func (e *NamesExpr) ChildName(nth int) string {
	return ""
}

func (e *NamesExpr) Value() interface{} {
	return nil
}

func (e *NamesExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := make(NamesExpr, len(children))
		for i := 0; i < len(children); i++ {
			typedChildren[i] = *children[i].(*NameExpr)
		}
		return &typedChildren
	}
	return e
}

func (e *NamesExpr) Source() *SourceLoc {
	return nil
}

func (e *NamesExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *NamesExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type NameExpr string

func (e *NameExpr) Op() Operator {
	return NameOp
}

func (e *NameExpr) ChildCount() int {
	return 0
}

func (e *NameExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *NameExpr) ChildName(nth int) string {
	return ""
}

func (e *NameExpr) Value() interface{} {
	return string(*e)
}

func (e *NameExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *NameExpr) Source() *SourceLoc {
	return nil
}

func (e *NameExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *NameExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchAndExpr struct {
	Left  Expr
	Right Expr
	Src   *SourceLoc
}

func (e *MatchAndExpr) Op() Operator {
	return MatchAndOp
}

func (e *MatchAndExpr) ChildCount() int {
	return 2
}

func (e *MatchAndExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.Left
	case 1:
		return e.Right
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchAndExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Left"
	case 1:
		return "Right"
	}
	return ""
}

func (e *MatchAndExpr) Value() interface{} {
	return nil
}

func (e *MatchAndExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchAndExpr{Left: children[0], Right: children[1], Src: e.Source()}
	}
	return e
}

func (e *MatchAndExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchAndExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchAndExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchNotExpr struct {
	Input Expr
	Src   *SourceLoc
}

func (e *MatchNotExpr) Op() Operator {
	return MatchNotOp
}

func (e *MatchNotExpr) ChildCount() int {
	return 1
}

func (e *MatchNotExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.Input
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchNotExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Input"
	}
	return ""
}

func (e *MatchNotExpr) Value() interface{} {
	return nil
}

func (e *MatchNotExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchNotExpr{Input: children[0], Src: e.Source()}
	}
	return e
}

func (e *MatchNotExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchNotExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchNotExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchAnyExpr struct {
}

func (e *MatchAnyExpr) Op() Operator {
	return MatchAnyOp
}

func (e *MatchAnyExpr) ChildCount() int {
	return 0
}

func (e *MatchAnyExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchAnyExpr) ChildName(nth int) string {
	return ""
}

func (e *MatchAnyExpr) Value() interface{} {
	return nil
}

func (e *MatchAnyExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *MatchAnyExpr) Source() *SourceLoc {
	return nil
}

func (e *MatchAnyExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchAnyExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchListAnyExpr struct {
	MatchItem Expr
	Src       *SourceLoc
}

func (e *MatchListAnyExpr) Op() Operator {
	return MatchListAnyOp
}

func (e *MatchListAnyExpr) ChildCount() int {
	return 1
}

func (e *MatchListAnyExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.MatchItem
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchListAnyExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "MatchItem"
	}
	return ""
}

func (e *MatchListAnyExpr) Value() interface{} {
	return nil
}

func (e *MatchListAnyExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchListAnyExpr{MatchItem: children[0], Src: e.Source()}
	}
	return e
}

func (e *MatchListAnyExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchListAnyExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchListAnyExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchListFirstExpr struct {
	MatchItem Expr
	Src       *SourceLoc
}

func (e *MatchListFirstExpr) Op() Operator {
	return MatchListFirstOp
}

func (e *MatchListFirstExpr) ChildCount() int {
	return 1
}

func (e *MatchListFirstExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.MatchItem
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchListFirstExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "MatchItem"
	}
	return ""
}

func (e *MatchListFirstExpr) Value() interface{} {
	return nil
}

func (e *MatchListFirstExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchListFirstExpr{MatchItem: children[0], Src: e.Source()}
	}
	return e
}

func (e *MatchListFirstExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchListFirstExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchListFirstExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchListLastExpr struct {
	MatchItem Expr
	Src       *SourceLoc
}

func (e *MatchListLastExpr) Op() Operator {
	return MatchListLastOp
}

func (e *MatchListLastExpr) ChildCount() int {
	return 1
}

func (e *MatchListLastExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.MatchItem
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchListLastExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "MatchItem"
	}
	return ""
}

func (e *MatchListLastExpr) Value() interface{} {
	return nil
}

func (e *MatchListLastExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchListLastExpr{MatchItem: children[0], Src: e.Source()}
	}
	return e
}

func (e *MatchListLastExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchListLastExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchListLastExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchListSingleExpr struct {
	MatchItem Expr
	Src       *SourceLoc
}

func (e *MatchListSingleExpr) Op() Operator {
	return MatchListSingleOp
}

func (e *MatchListSingleExpr) ChildCount() int {
	return 1
}

func (e *MatchListSingleExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.MatchItem
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchListSingleExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "MatchItem"
	}
	return ""
}

func (e *MatchListSingleExpr) Value() interface{} {
	return nil
}

func (e *MatchListSingleExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &MatchListSingleExpr{MatchItem: children[0], Src: e.Source()}
	}
	return e
}

func (e *MatchListSingleExpr) Source() *SourceLoc {
	return e.Src
}

func (e *MatchListSingleExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchListSingleExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type MatchListEmptyExpr struct {
}

func (e *MatchListEmptyExpr) Op() Operator {
	return MatchListEmptyOp
}

func (e *MatchListEmptyExpr) ChildCount() int {
	return 0
}

func (e *MatchListEmptyExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *MatchListEmptyExpr) ChildName(nth int) string {
	return ""
}

func (e *MatchListEmptyExpr) Value() interface{} {
	return nil
}

func (e *MatchListEmptyExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *MatchListEmptyExpr) Source() *SourceLoc {
	return nil
}

func (e *MatchListEmptyExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *MatchListEmptyExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type ConstructExpr struct {
	Name Expr
	Args ListExpr
	Src  *SourceLoc
}

func (e *ConstructExpr) Op() Operator {
	return ConstructOp
}

func (e *ConstructExpr) ChildCount() int {
	return 2
}

func (e *ConstructExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return e.Name
	case 1:
		return &e.Args
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *ConstructExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Name"
	case 1:
		return "Args"
	}
	return ""
}

func (e *ConstructExpr) Value() interface{} {
	return nil
}

func (e *ConstructExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &ConstructExpr{Name: children[0], Args: *children[1].(*ListExpr), Src: e.Source()}
	}
	return e
}

func (e *ConstructExpr) Source() *SourceLoc {
	return e.Src
}

func (e *ConstructExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *ConstructExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type ConstructListExpr struct {
	Items ListExpr
	Src   *SourceLoc
}

func (e *ConstructListExpr) Op() Operator {
	return ConstructListOp
}

func (e *ConstructListExpr) ChildCount() int {
	return 1
}

func (e *ConstructListExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Items
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *ConstructListExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Items"
	}
	return ""
}

func (e *ConstructListExpr) Value() interface{} {
	return nil
}

func (e *ConstructListExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &ConstructListExpr{Items: *children[0].(*ListExpr), Src: e.Source()}
	}
	return e
}

func (e *ConstructListExpr) Source() *SourceLoc {
	return e.Src
}

func (e *ConstructListExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *ConstructListExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type ListExpr []Expr

func (e *ListExpr) Op() Operator {
	return ListOp
}

func (e *ListExpr) ChildCount() int {
	return len(*e)
}

func (e *ListExpr) Child(nth int) Expr {
	return (*e)[nth]
}

func (e *ListExpr) ChildName(nth int) string {
	return ""
}

func (e *ListExpr) Value() interface{} {
	return nil
}

func (e *ListExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		typedChildren := ListExpr(children)
		return &typedChildren
	}
	return e
}

func (e *ListExpr) Source() *SourceLoc {
	return nil
}

func (e *ListExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *ListExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type StringExpr string

func (e *StringExpr) Op() Operator {
	return StringOp
}

func (e *StringExpr) ChildCount() int {
	return 0
}

func (e *StringExpr) Child(nth int) Expr {
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *StringExpr) ChildName(nth int) string {
	return ""
}

func (e *StringExpr) Value() interface{} {
	return string(*e)
}

func (e *StringExpr) Visit(visit VisitFunc) Expr {
	return e
}

func (e *StringExpr) Source() *SourceLoc {
	return nil
}

func (e *StringExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *StringExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}

type CustomFuncExpr struct {
	Name NameExpr
	Args ListExpr
	Src  *SourceLoc
}

func (e *CustomFuncExpr) Op() Operator {
	return CustomFuncOp
}

func (e *CustomFuncExpr) ChildCount() int {
	return 2
}

func (e *CustomFuncExpr) Child(nth int) Expr {
	switch nth {
	case 0:
		return &e.Name
	case 1:
		return &e.Args
	}
	panic(fmt.Sprintf("child index %d is out of range", nth))
}

func (e *CustomFuncExpr) ChildName(nth int) string {
	switch nth {
	case 0:
		return "Name"
	case 1:
		return "Args"
	}
	return ""
}

func (e *CustomFuncExpr) Value() interface{} {
	return nil
}

func (e *CustomFuncExpr) Visit(visit VisitFunc) Expr {
	children := visitChildren(e, visit)
	if children != nil {
		return &CustomFuncExpr{Name: *children[0].(*NameExpr), Args: *children[1].(*ListExpr), Src: e.Source()}
	}
	return e
}

func (e *CustomFuncExpr) Source() *SourceLoc {
	return e.Src
}

func (e *CustomFuncExpr) String() string {
	var buf bytes.Buffer
	e.Format(&buf, 0)
	return buf.String()
}

func (e *CustomFuncExpr) Format(buf *bytes.Buffer, level int) {
	formatExpr(e, buf, level)
}
