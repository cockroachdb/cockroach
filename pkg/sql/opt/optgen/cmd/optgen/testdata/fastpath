optgen fastpath test.opt
[Relational]
define Scan {
    _ ScanPrivate
}

[Private]
define ScanPrivate {
    Table      TableID
    Index      int
    Cols       ColSet
    Constraint Constraint
    HardLimit  ScanLimit
    Flags      ScanFlags
}

[Relational]
define Limit {
    Input RelExpr
    Limit ScalarExpr

    Ordering OrderingChoice
}

[Scalar, ConstValue]
define Const {
    Value Datum
}

[Relational]
define InnerJoin {
    Left RelExpr
    Right RelExpr
}

# Fast-path rules can define a replace expression to use as the final plan
# for the query.
[TestReplaceRoot, FastPath]
(Limit $scan:(Scan $private:*) (Const 1))
=>
(Scan (SetScanHardLimit $private))

# Fast-path rules can use the matched root expression as the final plan for
# the query.
[TestKeepRoot, FastPath]
(Limit $scan:(Scan $private:*) & (IsCanonicalScan $private) *)
=>
(Root)

# Fast-path rules can access the root expression and its required properties.
# Top-level custom functions are not allowed, though.
[TestRequiredPropsAccess, FastPath]
(InnerJoin (InnerJoin) & (ShouldReorderJoins (Root)) & (CheckRequired (Required)))
=>
(Limit (ReorderJoins (Root)) (Const 1))
----
----
// Code generated by optgen; [omitted]

package fastpath

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props/physical"
)

// tryFastPath should not be used directly; use TryOptimizerFastPath instead.
func (_fp *fastPathExplorer) tryFastPath(
	_root opt.Expr,
	_required *physical.Required,
) (_rel memo.RelExpr, _ok bool) {
	switch t := _root.(type) {
	case *memo.LimitExpr:
		return _fp.fastPathLimit(t, _required)
	case *memo.InnerJoinExpr:
		return _fp.fastPathInnerJoin(t, _required)
	}

	// No rules for other operator types.
	return nil, false
}

func (_fp *fastPathExplorer) fastPathLimit(
	_root *memo.LimitExpr,
	_required *physical.Required,
) (_rel memo.RelExpr, _ok bool) {
	opt.MaybeInjectOptimizerTestingPanic(_fp.ctx, _fp.evalCtx)
	// [TestReplaceRoot]
	{
		scan := _root.Input
		_scan, _ := scan.(*memo.ScanExpr)
		if _scan != nil {
			private := &_scan.ScanPrivate
			_const, _ := _root.Limit.(*memo.ConstExpr)
			if _const != nil {
				if _fp.f.funcs.EqualsNumber(_const.Value, 1) {
					_expr := &memo.ScanExpr{
						ScanPrivate: *_fp.funcs.SetScanHardLimit(private),
					}

					_interned := _fp.mem.AddScanToGroup(_expr, _root)
					return _interned, true
				}
			}
		}
	}

	// [TestKeepRoot]
	{
		scan := _root.Input
		_scan, _ := scan.(*memo.ScanExpr)
		if _scan != nil {
			private := &_scan.ScanPrivate
			if _fp.funcs.IsCanonicalScan(private) {
				// The matched expression will be kept as-is.
				return _root, true
			}
		}
	}

	return nil, false
}

func (_fp *fastPathExplorer) fastPathInnerJoin(
	_root *memo.InnerJoinExpr,
	_required *physical.Required,
) (_rel memo.RelExpr, _ok bool) {
	opt.MaybeInjectOptimizerTestingPanic(_fp.ctx, _fp.evalCtx)
	// [TestRequiredPropsAccess]
	{
		_innerJoin, _ := _root.Left.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			if _fp.funcs.ShouldReorderJoins(_root) {
				if _fp.funcs.CheckRequired(_required) {
					_expr := &memo.LimitExpr{
						Input: _fp.funcs.ReorderJoins(_root),
						Limit: _fp.f.ConstructConst(
							tree.NewDInt(1),
						),
					}

					_interned := _fp.mem.AddLimitToGroup(_expr, _root)
					return _interned, true
				}
			}
		}
	}

	return nil, false
}
----
----
