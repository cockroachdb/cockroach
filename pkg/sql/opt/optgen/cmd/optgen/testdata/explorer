#
# 1. One level of match patterns
# 2. Two levels of match patterns
# 3. Three levels of match patterns
# 4. Scalar match pattern
# 5. Custom match and replace functions
# 6. Dynamic name matching
# 7. Multiple patterns for a rule
# 8. Negated expressions
#
optgen explorer test.opt
[Join]
define InnerJoin {
    Left  Expr
    Right Expr
    On    Expr
}

[Join]
define InnerJoinApply {
    Left  Expr
    Right Expr
    On    Expr
}

define Select {
    Input  Expr
    Filter Expr
}

define GroupBy {
    Input        Expr
    Aggregations Expr
    GroupingCols ColSet
}

[Scalar, HasConditions]
define Filters {
    Conditions ExprList
}

[Scalar, HasConditions]
define And {
    Conditions ExprList
}

[CommuteJoin, Explore]
(InnerJoin $r:* $s:*) => (InnerJoin $s $r)

[AssociateJoin, Explore]
(InnerJoin
    (InnerJoin $r:* $s:* (Filters|HasConditions|And $lowerConditions:*))
    $t:*
    $filters:(Filters $upperConditions:*) & (IsCorrelated $filters $r) & (IsCorrelated $filters $t)
)
=>
(InnerJoin
    (InnerJoin
        $r
        $t
        (Filters (ConstructConditionsNotUsing $s $lowerConditions $upperConditions))
    )
    $s
    (Filters (ConstructConditionsUsing $s $lowerConditions $upperConditions))
)

[PushDownGroupBy, Explore]
(Select
    (GroupBy
        $input:(InnerJoin|Join $left:* $right:* $on:*)
        $aggregations:*
        $groupingCols:*
    )
    $filter:* & ^(IsCorrelated $filter $right)
)
=>
(InnerJoin
    (Select
        (GroupBy
            $left
            $aggregations
            $groupingCols
        )
        $filter
    )
    $right
    $on
)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

func (_e *explorer) exploreExpr(
	_state *exploreState, _eid memo.ExprID,
) (_fullyExplored bool) {
	_expr := _e.mem.Expr(_eid)
	switch _expr.Operator() {
	case opt.InnerJoinOp:
		return _e.exploreInnerJoin(_state, _eid, _expr.AsInnerJoin())
	case opt.SelectOp:
		return _e.exploreSelect(_state, _eid, _expr.AsSelect())
	}

	// No rules for other operator types.
	return true
}

func (_e *explorer) exploreInnerJoin(
	_state *exploreState, _innerJoin memo.GroupID, _innerJoinExpr memo.InnerJoinExpr,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [CommuteJoin]
	{
		if _innerJoin.Expr >= _state.start {
			r := _innerJoinExpr.Left()
			s := _innerJoinExpr.Right()
			if _e.o.allowOptimizations() {
				_e.o.reportOptimization(CommuteJoin)
				_e.mem.MemoizeDenormExpr(_innerJoin, memo.MakeInnerJoinExpr(
					s,
					r,
				))

			}
		}
	}

	// [AssociateJoin]
	{
		_partlyExplored := _innerJoin.Expr < _state.start
		_state := _e.exploreGroup(_innerJoinExpr.Left())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _innerJoinExpr.Left(), Expr: _ord}
			_innerJoinExpr2 := _e.mem.Expr(_eid).AsInnerJoin()
			if _innerJoinExpr2 != nil {
				r := _innerJoinExpr2.Left()
				s := _innerJoinExpr2.Right()
				_eid := memo.MakeNormExprID(_innerJoinExpr2.On())
				_expr := _e.mem.Expr(_eid)
				if _expr.Operator() == opt.FiltersOp || _expr.IsHasConditions() || _expr.Operator() == opt.AndOp {
					lowerConditions := _expr.ChildGroup(_e.mem, 0)
					t := _innerJoinExpr.Right()
					filters := _innerJoinExpr.On()
					_eid := memo.MakeNormExprID(_innerJoinExpr.On())
					_filtersExpr := _e.mem.Expr(_eid).AsFilters()
					if _filtersExpr != nil {
						upperConditions := _filtersExpr.Conditions()
						if _e.isCorrelated(filters, r) {
							if _e.isCorrelated(filters, t) {
								if _e.o.allowOptimizations() {
									_e.o.reportOptimization(AssociateJoin)
									_e.mem.MemoizeDenormExpr(_innerJoin, memo.MakeInnerJoinExpr(
										_e.f.ConstructInnerJoin(
											r,
											t,
											_e.f.ConstructFilters(
												_e.constructConditionsNotUsing(s, lowerConditions, upperConditions),
											),
										),
										s,
										_e.f.ConstructFilters(
											_e.constructConditionsUsing(s, lowerConditions, upperConditions),
										),
									))

								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSelect(
	_state *exploreState, _select memo.GroupID, _selectExpr memo.SelectExpr,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [PushDownGroupBy]
	{
		_partlyExplored := _select.Expr < _state.start
		_state := _e.exploreGroup(_selectExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		for _ord := 0; _ord < _state.end; _ord++ {
			_partlyExplored := _partlyExplored && _ord < _state.start
			_eid := memo.ExprID{Group: _selectExpr.Input(), Expr: _ord}
			_groupByExpr := _e.mem.Expr(_eid).AsGroupBy()
			if _groupByExpr != nil {
				input := _groupByExpr.Input()
				_state := _e.exploreGroup(_groupByExpr.Input())
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				start := memo.ExprOrdinal(0)
				if _partlyExplored {
					start = _state.start
				}
				for _ord := start; _ord < _state.end; _ord++ {
					_eid := memo.ExprID{Group: _groupByExpr.Input(), Expr: _ord}
					_expr := _e.mem.Expr(_eid)
					if _expr.Operator() == opt.InnerJoinOp || _expr.IsJoin() {
						left := _expr.ChildGroup(_e.mem, 0)
						right := _expr.ChildGroup(_e.mem, 1)
						on := _expr.ChildGroup(_e.mem, 2)
						aggregations := _groupByExpr.Aggregations()
						groupingCols := _groupByExpr.GroupingCols()
						filter := _selectExpr.Filter()
						if !_e.isCorrelated(filter, right) {
							if _e.o.allowOptimizations() {
								_e.o.reportOptimization(PushDownGroupBy)
								_e.mem.MemoizeDenormExpr(_select, memo.MakeInnerJoinExpr(
									_e.f.ConstructSelect(
										_e.f.ConstructGroupBy(
											left,
											aggregations,
											groupingCols,
										),
										filter,
									),
									right,
									on,
								))

							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}
----
----
