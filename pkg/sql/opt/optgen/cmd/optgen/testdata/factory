#
# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
#
optgen factory test.opt
# Not is a negate operator.
define Not {
    Input Expr
}

define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}

# This shouldn't be added to the factory.
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructNot constructs an expression for the Not operator.
// Not is a negate operator.
func (_f *factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_notExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notExpr)))
}

// ConstructFuncCall constructs an expression for the FuncCall operator.
func (_f *factory) ConstructFuncCall(
	name opt.GroupID,
	args opt.ListID,
	def opt.PrivateID,
) opt.GroupID {
	_funcCallExpr := makeFuncCallExpr(name, args, def)
	_group := _f.mem.lookupGroupByFingerprint(_funcCallExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_funcCallExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_funcCallExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNot(children[0])
	}

	// FuncCallOp
	dynConstructLookup[opt.FuncCallOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFuncCall(children[0], f.InternList(children[1:]), private)
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate static matching and replacement code.
#
optgen factory test.opt
define InnerJoin {
    Left  Expr
    Right Expr
}

[CommuteJoin]
(InnerJoin $r:* $s:*) => (InnerJoin $s $r)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr))
	}

	// [CommuteJoin]
	{
		r := left
		s := right
		_f.reportOptimization()
		_group = _f.ConstructInnerJoin(s, r)
		_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [2]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoin(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate multiple match names, not expr, custom function, and use OpName
# builtin to construct replacement expression with name known at compile-time.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Ne {
    Left  Expr
    Right Expr
}

[NormalizeVarOrder]
(Eq | Ne $left:* $right:* & ^(IsHigherExpr $right $left))
=>
((OpName) $right $left)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr))
	}

	// [NormalizeVarOrder]
	{
		if !_f.isHigherExpr(right, left) {
			_f.reportOptimization()
			_group = _f.ConstructEq(right, left)
			_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *factory) ConstructNe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_neExpr := makeNeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_neExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_neExpr))
	}

	// [NormalizeVarOrder]
	{
		if !_f.isHigherExpr(right, left) {
			_f.reportOptimization()
			_group = _f.ConstructNe(right, left)
			_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_neExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNe(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate not match of op with no args, string match, list match, string
# construction, custom replace function.
#
optgen factory test.opt
define Func {
    Name Expr
    Args ExprList
}

define Variable {
    Col ColumnIndex
}

[Concat]
(Func "concat" $args:[ ... $item:^(Variable) & (IsEmpty $item) ... ])
=>
(Func "concat" (RemoveListItem $args $item))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructFunc constructs an expression for the Func operator.
func (_f *factory) ConstructFunc(
	name opt.GroupID,
	args opt.ListID,
) opt.GroupID {
	_funcExpr := makeFuncExpr(name, args)
	_group := _f.mem.lookupGroupByFingerprint(_funcExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_funcExpr))
	}

	// [Concat]
	{
		if name == m.mem.internPrivate("concat") {
			for _, _item := range _f.mem.lookupList(args) {
				item := _item
				_variable := _f.mem.lookupNormExpr(_item).asVariable()
				if _variable == nil {
					if _f.isEmpty(item) {
						_f.reportOptimization()
						_group = _f.ConstructFunc(m.mem.internPrivate(tree.NewDString("concat")), _f.removeListItem(args, item))
						_f.mem.addAltFingerprint(_funcExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_funcExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
func (_f *factory) ConstructVariable(
	col opt.PrivateID,
) opt.GroupID {
	_variableExpr := makeVariableExpr(col)
	_group := _f.mem.lookupGroupByFingerprint(_variableExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_variableExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_variableExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// FuncOp
	dynConstructLookup[opt.FuncOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFunc(children[0], f.InternList(children[1:]))
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructVariable(private)
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate not match of op with args and not match of list. Nest matches within
# one another and use match of tag name. Match both tag and define name.
# Construct dynamic replacement and use opname literal.
#
optgen factory test.opt
define Select {
    Input Expr
    Filter Expr
}

[Join]
define InnerJoin {
    Left  Expr
    Right Expr
}

[Join]
define FullJoin {
    Left  Expr
    Right Expr
}

define Union {
    Left  Expr
    Right Expr
}

define And {
    Left  Expr
    Right Expr
}

[Test]
(Select
    $input:^(Join|Union $r:* $s:*)
    $args:[ ... $item:(Join $t:* $u:*) ... ]
)
=>
((OpName $item) (Select $t $u) (Custom $item (OpName)))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructSelect constructs an expression for the Select operator.
func (_f *factory) ConstructSelect(
	input opt.GroupID,
	filter opt.GroupID,
) opt.GroupID {
	_selectExpr := makeSelectExpr(input, filter)
	_group := _f.mem.lookupGroupByFingerprint(_selectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_selectExpr))
	}

	// [Test]
	{
		_match := false
		_norm := _f.mem.lookupNormExpr(input)
		if isJoinLookup[_norm.op] || _norm.op == UnionOp {
			_e := makeExprView(_f.mem, input, defaultPhysPropsID)
			r := _e.ChildGroup(0)
			s := _e.ChildGroup(1)
			_match = true
		}

		if !_match {
			args := filter
			for _, _item := range _f.mem.lookupList(filter) {
				item := _item
				_norm2 := _f.mem.lookupNormExpr(_item)
				if isJoinLookup[_norm2.op] {
					_e2 := makeExprView(_f.mem, _item, defaultPhysPropsID)
					t := _e2.ChildGroup(0)
					u := _e2.ChildGroup(1)
					_f.reportOptimization()
					_group = _f.DynamicConstruct(_f.mem.lookupNormExpr(item).op, []GroupID{_f.ConstructSelect(t, u), _f.custom(item, SelectOp)}, 0)
					_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_selectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_innerJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *factory) ConstructFullJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_fullJoinExpr := makeFullJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_fullJoinExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
func (_f *factory) ConstructUnion(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_unionExpr := makeUnionExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_unionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_unionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_unionExpr)))
}

// ConstructAnd constructs an expression for the And operator.
func (_f *factory) ConstructAnd(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_andExpr := makeAndExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_andExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_andExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_andExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [6]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSelect(children[0], children[1])
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoin(children[0], children[1])
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFullJoin(children[0], children[1])
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnion(children[0], children[1])
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAnd(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate match and nomatch for both constant and dynamic match cases, with
# and without child matchers.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Ne {
    Left  Expr
    Right Expr
}

[Constant]
(Eq
    (Eq (Eq) ^(Eq))
    ^(Eq (Eq) ^(Eq))
)
=>
"foo"

[Dynamic]
(Ne
    (Eq|Ne (Eq|Ne) ^(Eq|Ne))
    ^(Eq|Ne (Eq|Ne) ^(Eq|Ne))
)
=>
"foo"
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr))
	}

	// [Constant]
	{
		_eq := _f.mem.lookupNormExpr(left).asEq()
		if _eq != nil {
			_eq2 := _f.mem.lookupNormExpr(_eq.Left()).asEq()
			if _eq2 != nil {
				_eq3 := _f.mem.lookupNormExpr(_eq.Right()).asEq()
				if _eq3 == nil {
					_match := false
					_eq4 := _f.mem.lookupNormExpr(right).asEq()
					if _eq4 != nil {
						_eq5 := _f.mem.lookupNormExpr(_eq4.Left()).asEq()
						if _eq5 != nil {
							_eq6 := _f.mem.lookupNormExpr(_eq4.Right()).asEq()
							if _eq6 == nil {
								_match = true
							}
						}
					}

					if !_match {
						_f.reportOptimization()
						_group = m.mem.internPrivate(tree.NewDString("foo"))
						_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_eqExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *factory) ConstructNe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_neExpr := makeNeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_neExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr((*memoExpr)(&_neExpr))
	}

	// [Dynamic]
	{
		_norm := _f.mem.lookupNormExpr(left)
		if _norm.op == EqOp || _norm.op == NeOp {
			_e := makeExprView(_f.mem, left, defaultPhysPropsID)
			_norm2 := _f.mem.lookupNormExpr(_e.ChildGroup(0))
			if _norm2.op == EqOp || _norm2.op == NeOp {
				_norm3 := _f.mem.lookupNormExpr(_e.ChildGroup(1))
				if !(_norm3.op == EqOp || _norm3.op == NeOp) {
					_match := false
					_norm4 := _f.mem.lookupNormExpr(right)
					if _norm4.op == EqOp || _norm4.op == NeOp {
						_e2 := makeExprView(_f.mem, right, defaultPhysPropsID)
						_norm5 := _f.mem.lookupNormExpr(_e2.ChildGroup(0))
						if _norm5.op == EqOp || _norm5.op == NeOp {
							_norm6 := _f.mem.lookupNormExpr(_e2.ChildGroup(1))
							if !(_norm6.op == EqOp || _norm6.op == NeOp) {
								_match = true
							}
						}
					}

					if !_match {
						_f.reportOptimization()
						_group = m.mem.internPrivate(tree.NewDString("foo"))
						_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_neExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNe(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----
