#
# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
#
optgen factory test.opt
define Not {
    Input Expr
}

define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}

# This shouldn't be added to the factory.
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt/opt"
)

func (_f *factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notExpr)))
}

func (_f *factory) ConstructFuncCall(
	name opt.GroupID,
	args opt.ListID,
	def opt.PrivateID,
) opt.GroupID {
	_funcCallExpr := makeFuncCallExpr(name, args, def)
	_group := _f.mem.lookupGroupByFingerprint(_funcCallExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_funcCallExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNot(children[0])
	}

	// FuncCallOp
	dynConstructLookup[opt.FuncCallOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFuncCall(children[0], f.StoreList(children[1:]), private)
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----
