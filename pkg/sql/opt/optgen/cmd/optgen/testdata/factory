#
# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
#
optgen factory test.opt
# Not is a negate operator.
define Not {
    Input Expr
}

define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}

# This shouldn't be added to the factory.
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructNot constructs an expression for the Not operator.
// Not is a negate operator.
func (_f *factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notExpr)))
}

// ConstructFuncCall constructs an expression for the FuncCall operator.
func (_f *factory) ConstructFuncCall(
	name opt.GroupID,
	args opt.ListID,
	def opt.PrivateID,
) opt.GroupID {
	_funcCallExpr := makeFuncCallExpr(name, args, def)
	_group := _f.mem.lookupGroupByFingerprint(_funcCallExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_funcCallExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_funcCallExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNot(children[0])
	}

	// FuncCallOp
	dynConstructLookup[opt.FuncCallOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFuncCall(children[0], f.InternList(children[1:]), private)
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate static matching and replacement code.
#
optgen factory test.opt
define InnerJoin {
    Left  Expr
    Right Expr
}

[CommuteJoin]
(InnerJoin $r:* $s:*) => (InnerJoin $s $r)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr))
	}

	// [CommuteJoin]
	{
		r := left
		s := right
		_f.reportOptimization()
		_group = _f.ConstructInnerJoin(s, r)
		_f.mem.addAltFingerprint(_innerJoinExpr.fingerprint(), _group)
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [2]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoin(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate multiple match names, not expr, custom function, literal names in
# match and replace patterns, and use OpName builtin to construct replacement
# expression with name known at compile-time.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Lt {
    Left  Expr
    Right Expr
}

define Plus {
    Left  Expr
    Right Expr
}

define Minus {
    Left  Expr
    Right Expr
}

define Const {
}

[NormalizeVarPlus]
(Eq | Lt
    (Plus
        $leftLeft:^(Const)
        $leftRight:(Const)
    )
    $right:(Const) & ^(IsInvalidBinary Minus $right $leftRight)
) =>
((OpName)
    $leftLeft
    (ConstructBinary Minus $right $leftRight)
)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_eqExpr))
	}

	// [NormalizeVarPlus]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			_const := _f.mem.lookupNormExpr(_plus.left()).asConst()
			if _const == nil {
				leftRight := _plus.right()
				_const2 := _f.mem.lookupNormExpr(_plus.right()).asConst()
				if _const2 != nil {
					_const3 := _f.mem.lookupNormExpr(right).asConst()
					if _const3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							_f.reportOptimization()
							_group = _f.ConstructEq(leftLeft, _f.constructBinary(opt.MinusOp, right, leftRight))
							_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_eqExpr)))
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *factory) ConstructLt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_ltExpr := makeLtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_ltExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_ltExpr))
	}

	// [NormalizeVarPlus]
	{
		_plus := _f.mem.lookupNormExpr(left).asPlus()
		if _plus != nil {
			leftLeft := _plus.left()
			_const := _f.mem.lookupNormExpr(_plus.left()).asConst()
			if _const == nil {
				leftRight := _plus.right()
				_const2 := _f.mem.lookupNormExpr(_plus.right()).asConst()
				if _const2 != nil {
					_const3 := _f.mem.lookupNormExpr(right).asConst()
					if _const3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							_f.reportOptimization()
							_group = _f.ConstructLt(leftLeft, _f.constructBinary(opt.MinusOp, right, leftRight))
							_f.mem.addAltFingerprint(_ltExpr.fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_ltExpr)))
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *factory) ConstructPlus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_plusExpr := makePlusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_plusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_plusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *factory) ConstructMinus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_minusExpr := makeMinusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_minusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_minusExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_minusExpr)))
}

// ConstructConst constructs an expression for the Const operator.
func (_f *factory) ConstructConst() opt.GroupID {
	_constExpr := makeConstExpr()
	_group := _f.mem.lookupGroupByFingerprint(_constExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_constExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_constExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [6]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLt(children[0], children[1])
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructPlus(children[0], children[1])
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructMinus(children[0], children[1])
	}

	// ConstOp
	dynConstructLookup[opt.ConstOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructConst()
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate not match of op with no args, string match, list match, string
# construction, custom replace function.
#
optgen factory test.opt
define Func {
    Name Expr
    Args ExprList
}

define Variable {
    Col ColumnIndex
}

[Concat]
(Func "concat" $args:[ ... $item:^(Variable) & (IsEmpty $item) ... ])
=>
(Func "concat" (RemoveListItem $args $item))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructFunc constructs an expression for the Func operator.
func (_f *factory) ConstructFunc(
	name opt.GroupID,
	args opt.ListID,
) opt.GroupID {
	_funcExpr := makeFuncExpr(name, args)
	_group := _f.mem.lookupGroupByFingerprint(_funcExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_funcExpr))
	}

	// [Concat]
	{
		if name == m.mem.internPrivate("concat") {
			for _, _item := range _f.mem.lookupList(args) {
				item := _item
				_variable := _f.mem.lookupNormExpr(_item).asVariable()
				if _variable == nil {
					if _f.isEmpty(item) {
						_f.reportOptimization()
						_group = _f.ConstructFunc(m.mem.internPrivate(tree.NewDString("concat")), _f.removeListItem(args, item))
						_f.mem.addAltFingerprint(_funcExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_funcExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
func (_f *factory) ConstructVariable(
	col opt.PrivateID,
) opt.GroupID {
	_variableExpr := makeVariableExpr(col)
	_group := _f.mem.lookupGroupByFingerprint(_variableExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_variableExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_variableExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// FuncOp
	dynConstructLookup[opt.FuncOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFunc(children[0], f.InternList(children[1:]))
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructVariable(private)
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate not match of op with args and not match of list. Nest matches within
# one another and use match of tag name. Match both tag and define name.
# Construct dynamic replacement and use opname literal.
#
optgen factory test.opt
define Select {
    Input Expr
    Filter Expr
}

[Join]
define InnerJoin {
    Left  Expr
    Right Expr
}

[Join]
define FullJoin {
    Left  Expr
    Right Expr
}

define Union {
    Left  Expr
    Right Expr
}

define And {
    Left  Expr
    Right Expr
}

[Test]
(Select
    $input:^(Join|Union $r:* $s:*)
    $args:[ ... $item:(Join $t:* $u:*) ... ]
)
=>
((OpName $item) (Select $t $u) (Custom $item (OpName)))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructSelect constructs an expression for the Select operator.
func (_f *factory) ConstructSelect(
	input opt.GroupID,
	filter opt.GroupID,
) opt.GroupID {
	_selectExpr := makeSelectExpr(input, filter)
	_group := _f.mem.lookupGroupByFingerprint(_selectExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_selectExpr))
	}

	// [Test]
	{
		_match := false
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.isJoin() || _norm.op == opt.UnionOp {
			_e := makeExprView(_f.mem, input, opt.NormPhysPropsID)
			r := _e.ChildGroup(0)
			s := _e.ChildGroup(1)
			_match = true
		}

		if !_match {
			args := filter
			for _, _item := range _f.mem.lookupList(filter) {
				item := _item
				_norm2 := _f.mem.lookupNormExpr(_item)
				if _norm2.isJoin() {
					_e2 := makeExprView(_f.mem, _item, opt.NormPhysPropsID)
					t := _e2.ChildGroup(0)
					u := _e2.ChildGroup(1)
					_f.reportOptimization()
					_group = _f.DynamicConstruct(_f.mem.lookupNormExpr(item).op, []opt.GroupID{_f.ConstructSelect(t, u), _f.custom(item, opt.SelectOp)}, 0)
					_f.mem.addAltFingerprint(_selectExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_selectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *factory) ConstructInnerJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_innerJoinExpr := makeInnerJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_innerJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_innerJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *factory) ConstructFullJoin(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_fullJoinExpr := makeFullJoinExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_fullJoinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_fullJoinExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_fullJoinExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
func (_f *factory) ConstructUnion(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_unionExpr := makeUnionExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_unionExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_unionExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_unionExpr)))
}

// ConstructAnd constructs an expression for the And operator.
func (_f *factory) ConstructAnd(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_andExpr := makeAndExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_andExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_andExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_andExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [6]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructSelect(children[0], children[1])
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructInnerJoin(children[0], children[1])
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructFullJoin(children[0], children[1])
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructUnion(children[0], children[1])
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructAnd(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate match for all list match operators.
#
optgen factory test.opt
define List {
    Items ExprList
}

[List]
(List $any:[
    ...
    (List $first:[
        (List $last:[
            ...
            (List $single:[
                (List $empty:[])
            ])
        ])
        ...
    ])
    ...
])
=>
(Construct $any $first $last $single $empty)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructList constructs an expression for the List operator.
func (_f *factory) ConstructList(
	items opt.ListID,
) opt.GroupID {
	_listExpr := makeListExpr(items)
	_group := _f.mem.lookupGroupByFingerprint(_listExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_listExpr))
	}

	// [List]
	{
		any := items
		for _, _item := range _f.mem.lookupList(items) {
			_list := _f.mem.lookupNormExpr(_item).asList()
			if _list != nil {
				first := _list.items()
				if _list.items().Length > 0 {
					_item := _f.mem.lookupList(_list.items())[0]
					_list2 := _f.mem.lookupNormExpr(_item).asList()
					if _list2 != nil {
						last := _list2.items()
						if _list2.items().Length > 0 {
							_item := _f.mem.lookupList(_list2.items())[_list2.items().Length-1]
							_list3 := _f.mem.lookupNormExpr(_item).asList()
							if _list3 != nil {
								single := _list3.items()
								if _list3.items().Length == 1 {
									_item := _f.mem.lookupList(_list3.items())[0]
									_list4 := _f.mem.lookupNormExpr(_item).asList()
									if _list4 != nil {
										empty := _list4.items()
										if _list4.items().Length == 0 {
											_f.reportOptimization()
											_group = _f.construct(any, first, last, single, empty)
											_f.mem.addAltFingerprint(_listExpr.fingerprint(), _group)
											return _group
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_listExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [2]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructList(f.InternList(children))
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate list construction operators.
#
optgen factory test.opt
define Join {
    Left  Expr
    Right Expr
    On    Expr
}

[ConstructList]
(Join $left:* $right:* $on:*)
=>
(Construct [] [ $left ] [ $left $right] [ [$on] ])
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructJoin constructs an expression for the Join operator.
func (_f *factory) ConstructJoin(
	left opt.GroupID,
	right opt.GroupID,
	on opt.GroupID,
) opt.GroupID {
	_joinExpr := makeJoinExpr(left, right, on)
	_group := _f.mem.lookupGroupByFingerprint(_joinExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_joinExpr))
	}

	// [ConstructList]
	{
		_f.reportOptimization()
		_group = _f.construct(_f.mem.internList([]opt.GroupID{}), _f.mem.internList([]opt.GroupID{left}), _f.mem.internList([]opt.GroupID{left, right}), _f.mem.internList([]opt.GroupID{_f.mem.internList([]opt.GroupID{on})}))
		_f.mem.addAltFingerprint(_joinExpr.fingerprint(), _group)
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_joinExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [2]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// JoinOp
	dynConstructLookup[opt.JoinOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructJoin(children[0], children[1], children[2])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----
#
# Generate no match for all list match operators that support it.
#
optgen factory test.opt
define List {
    Items ExprList
}

define Op {
    Empty  Expr
    Single Expr
}

[ListNot]
(Op
    $empty:(List ^[])
    $single:(List ^[ * ])
)
=>
(Op $empty $single)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructList constructs an expression for the List operator.
func (_f *factory) ConstructList(
	items opt.ListID,
) opt.GroupID {
	_listExpr := makeListExpr(items)
	_group := _f.mem.lookupGroupByFingerprint(_listExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_listExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_listExpr)))
}

// ConstructOp constructs an expression for the Op operator.
func (_f *factory) ConstructOp(
	empty opt.GroupID,
	single opt.GroupID,
) opt.GroupID {
	_opExpr := makeOpExpr(empty, single)
	_group := _f.mem.lookupGroupByFingerprint(_opExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_opExpr))
	}

	// [ListNot]
	{
		_list := _f.mem.lookupNormExpr(empty).asList()
		if _list != nil {
			if _list.items().Length != 0 {
				_list2 := _f.mem.lookupNormExpr(single).asList()
				if _list2 != nil {
					if _list2.items().Length != 1 {
						_f.reportOptimization()
						_group = _f.ConstructOp(empty, single)
						_f.mem.addAltFingerprint(_opExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_opExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructList(f.InternList(children))
	}

	// OpOp
	dynConstructLookup[opt.OpOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructOp(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate match and nomatch for both constant and dynamic match cases, with
# and without child matchers.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Ne {
    Left  Expr
    Right Expr
}

[Constant]
(Eq
    (Eq (Eq) ^(Eq))
    ^(Eq (Eq) ^(Eq))
)
=>
"foo"

[Dynamic]
(Ne
    (Eq|Ne (Eq|Ne) ^(Eq|Ne))
    ^(Eq|Ne (Eq|Ne) ^(Eq|Ne))
)
=>
"foo"
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *factory) ConstructEq(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_eqExpr := makeEqExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_eqExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_eqExpr))
	}

	// [Constant]
	{
		_eq := _f.mem.lookupNormExpr(left).asEq()
		if _eq != nil {
			_eq2 := _f.mem.lookupNormExpr(_eq.left()).asEq()
			if _eq2 != nil {
				_eq3 := _f.mem.lookupNormExpr(_eq.right()).asEq()
				if _eq3 == nil {
					_match := false
					_eq4 := _f.mem.lookupNormExpr(right).asEq()
					if _eq4 != nil {
						_eq5 := _f.mem.lookupNormExpr(_eq4.left()).asEq()
						if _eq5 != nil {
							_eq6 := _f.mem.lookupNormExpr(_eq4.right()).asEq()
							if _eq6 == nil {
								_match = true
							}
						}
					}

					if !_match {
						_f.reportOptimization()
						_group = m.mem.internPrivate(tree.NewDString("foo"))
						_f.mem.addAltFingerprint(_eqExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_eqExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *factory) ConstructNe(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_neExpr := makeNeExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_neExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_neExpr))
	}

	// [Dynamic]
	{
		_norm := _f.mem.lookupNormExpr(left)
		if _norm.op == opt.EqOp || _norm.op == opt.NeOp {
			_e := makeExprView(_f.mem, left, opt.NormPhysPropsID)
			_norm2 := _f.mem.lookupNormExpr(_e.ChildGroup(0))
			if _norm2.op == opt.EqOp || _norm2.op == opt.NeOp {
				_norm3 := _f.mem.lookupNormExpr(_e.ChildGroup(1))
				if !(_norm3.op == opt.EqOp || _norm3.op == opt.NeOp) {
					_match := false
					_norm4 := _f.mem.lookupNormExpr(right)
					if _norm4.op == opt.EqOp || _norm4.op == opt.NeOp {
						_e2 := makeExprView(_f.mem, right, opt.NormPhysPropsID)
						_norm5 := _f.mem.lookupNormExpr(_e2.ChildGroup(0))
						if _norm5.op == opt.EqOp || _norm5.op == opt.NeOp {
							_norm6 := _f.mem.lookupNormExpr(_e2.ChildGroup(1))
							if !(_norm6.op == opt.EqOp || _norm6.op == opt.NeOp) {
								_match = true
							}
						}
					}

					if !_match {
						_f.reportOptimization()
						_group = m.mem.internPrivate(tree.NewDString("foo"))
						_f.mem.addAltFingerprint(_neExpr.fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_neExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructEq(children[0], children[1])
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNe(children[0], children[1])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate nested custom matching functions, including OpName.
#
optgen factory test.opt
[Binary]
define Plus {
    Left  Expr
    Right Expr
}

[Binary]
define Minus {
    Left  Expr
    Right Expr
}

define Null {}

[Fold]
(Binary
    $left:*
    (Null) & ^(HasNullableArgs (OpName) (AnotherFunc (OpName $left)))
)
=>
(Null)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructPlus constructs an expression for the Plus operator.
func (_f *factory) ConstructPlus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_plusExpr := makePlusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_plusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_plusExpr))
	}

	// [Fold]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.hasNullableArgs(opt.PlusOp, _f.anotherFunc(_f.mem.lookupNormExpr(left).op)) {
				_f.reportOptimization()
				_group = _f.ConstructNull()
				_f.mem.addAltFingerprint(_plusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *factory) ConstructMinus(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_minusExpr := makeMinusExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_minusExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_minusExpr))
	}

	// [Fold]
	{
		_null := _f.mem.lookupNormExpr(right).asNull()
		if _null != nil {
			if !_f.hasNullableArgs(opt.MinusOp, _f.anotherFunc(_f.mem.lookupNormExpr(left).op)) {
				_f.reportOptimization()
				_group = _f.ConstructNull()
				_f.mem.addAltFingerprint(_minusExpr.fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_minusExpr)))
}

// ConstructNull constructs an expression for the Null operator.
func (_f *factory) ConstructNull() opt.GroupID {
	_nullExpr := makeNullExpr()
	_group := _f.mem.lookupGroupByFingerprint(_nullExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_nullExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_nullExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [4]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructPlus(children[0], children[1])
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructMinus(children[0], children[1])
	}

	// NullOp
	dynConstructLookup[opt.NullOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNull()
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----

#
# Generate multiple op matchers combined into a boolean expression.
#
optgen factory test.opt
[Comparison]
define Lt {
    Left  Expr
    Right Expr
}

[Comparison]
define Gt {
    Left  Expr
    Right Expr
}

[Comparison]
define Contains {
    Left  Expr
    Right Expr
}

define Not {
    Input Expr
}

[Invert]
(Not $input:(Comparison $left:* $right:*) & ^(Contains) & (SomeOtherCondition $input))
=>
(Invert (OpName $input) $left $right)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ConstructLt constructs an expression for the Lt operator.
func (_f *factory) ConstructLt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_ltExpr := makeLtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_ltExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_ltExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_ltExpr)))
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *factory) ConstructGt(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_gtExpr := makeGtExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_gtExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_gtExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_gtExpr)))
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *factory) ConstructContains(
	left opt.GroupID,
	right opt.GroupID,
) opt.GroupID {
	_containsExpr := makeContainsExpr(left, right)
	_group := _f.mem.lookupGroupByFingerprint(_containsExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_containsExpr))
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_containsExpr)))
}

// ConstructNot constructs an expression for the Not operator.
func (_f *factory) ConstructNot(
	input opt.GroupID,
) opt.GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.allowOptimizations() {
		return _f.mem.memoizeNormExpr(memoExpr(_notExpr))
	}

	// [Invert]
	{
		_norm := _f.mem.lookupNormExpr(input)
		if _norm.isComparison() {
			_e := makeExprView(_f.mem, input, opt.NormPhysPropsID)
			left := _e.ChildGroup(0)
			right := _e.ChildGroup(1)
			_contains := _f.mem.lookupNormExpr(input).asContains()
			if _contains == nil {
				if _f.someOtherCondition(input) {
					_f.reportOptimization()
					_group = _f.invert(_f.mem.lookupNormExpr(input).op, left, right)
					_f.mem.addAltFingerprint(_notExpr.fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr(memoExpr(_notExpr)))
}

type dynConstructLookupFunc func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID

var dynConstructLookup [5]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		panic("op type not initialized")
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructLt(children[0], children[1])
	}

	// GtOp
	dynConstructLookup[opt.GtOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructGt(children[0], children[1])
	}

	// ContainsOp
	dynConstructLookup[opt.ContainsOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructContains(children[0], children[1])
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *factory, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
		return f.ConstructNot(children[0])
	}

}

func (f *factory) DynamicConstruct(op opt.Operator, children []opt.GroupID, private opt.PrivateID) opt.GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----
