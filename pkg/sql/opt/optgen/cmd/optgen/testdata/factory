#
# Generate code for interesting rule.
#
optgen factory test.opt
[Relational]
define Select {
    Input   RelExpr
    Filters FiltersExpr
}

[Relational, Join, JoinNonApply]
define InnerJoin {
    Left  RelExpr
    Right RelExpr
    On    FiltersExpr
}

[Relational, Join, JoinApply]
define InnerJoinApply {
    Left  RelExpr
    Right RelExpr
    On    FiltersExpr
}

[Scalar, Bool, List]
define Filters {
}

[Scalar, Bool, ListItem, ScalarProps]
define FiltersItem {
    Condition ScalarExpr
}

[Scalar, ListItem]
define KVOptionsItem {
    Value ScalarExpr
    Key   string
}

[PushSelectIntoJoinLeft, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filters:[
        ...
        $item:* & (IsBoundBy $item $leftCols:(OutputCols $left))
        ...
    ]
)
=>
(Select
    ((OpName $input)
        (Select
            $left
            (ExtractBoundConditions $filters $leftCols)
        )
        $right
        $on
    )
    (ExtractUnboundConditions $filters $leftCols)
)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props/physical"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

// ConstructSelect constructs an expression for the Select operator.
func (_f *Factory) ConstructSelect(
	input memo.RelExpr,
	filters memo.FiltersExpr,
) memo.RelExpr {
	// [PushSelectIntoJoinLeft]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.InnerJoinApplyOp {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			for i := range filters {
				item := &filters[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoJoinLeft) {
						on := on
						_expr := _f.ConstructSelect(
							_f.DynamicConstruct(
								input.Op(),
								_f.ConstructSelect(
									left,
									_f.funcs.ExtractBoundConditions(filters, leftCols),
								),
								right,
								&on,
							).(memo.RelExpr),
							_f.funcs.ExtractUnboundConditions(filters, leftCols),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoJoinLeft, nil, _expr)
						}
						return _expr
					}
				}
			}
		}
	}

	e := _f.mem.MemoizeSelect(input, filters)
	return _f.onConstructRelational(e)
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *Factory) ConstructInnerJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
) memo.RelExpr {
	e := _f.mem.MemoizeInnerJoin(left, right, on)
	return _f.onConstructRelational(e)
}

// ConstructInnerJoinApply constructs an expression for the InnerJoinApply operator.
func (_f *Factory) ConstructInnerJoinApply(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
) memo.RelExpr {
	e := _f.mem.MemoizeInnerJoinApply(left, right, on)
	return _f.onConstructRelational(e)
}

// ConstructFiltersItem constructs an expression for the FiltersItem operator.
func (_f *Factory) ConstructFiltersItem(
	condition opt.ScalarExpr,
) memo.FiltersItem {
	item := memo.FiltersItem{Condition: condition}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructKVOptionsItem constructs an expression for the KVOptionsItem operator.
func (_f *Factory) ConstructKVOptionsItem(
	value opt.ScalarExpr,
	key string,
) memo.KVOptionsItem {
	item := memo.KVOptionsItem{Value: value, Key: key}
	return item
}

// Replace enables an expression subtree to be rewritten under the control of
// the caller. It passes each child of the given expression to the replace
// callback. The caller can continue traversing the expression tree within the
// callback by recursively calling Replace. It can also return a replacement
// expression; if it does, then Replace will rebuild the operator and its
// ancestors via a calls to the corresponding factory Construct methods. Here
// is example usage:
//
//   var replace func(e opt.Expr) opt.Expr
//   replace = func(e opt.Expr) opt.Expr {
//     if e.Op() == opt.VariableOp {
//       return getReplaceVar(e)
//     }
//     return factory.Replace(e, replace)
//   }
//   replace(root, replace)
//
// Here, all variables in the tree are being replaced by some other expression
// in a pre-order traversal of the tree. Post-order traversal is trivially
// achieved by moving the factory.Replace call to the top of the replace
// function rather than bottom.
func (f *Factory) Replace(e opt.Expr, replace ReplaceFunc) opt.Expr {
	switch t := e.(type) {
	case *memo.SelectExpr:
		input := replace(t.Input).(memo.RelExpr)
		filters, filtersChanged := f.replaceFiltersExpr(t.Filters, replace)
		if input != t.Input || filtersChanged {
			return f.ConstructSelect(input, filters)
		}
		return t

	case *memo.InnerJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructInnerJoin(left, right, on)
		}
		return t

	case *memo.InnerJoinApplyExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructInnerJoinApply(left, right, on)
		}
		return t

	case *memo.FiltersExpr:
		if after, changed := f.replaceFiltersExpr(*t, replace); changed {
			return &after
		}
		return t

	}
	panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(e.Op())))
}

func (f *Factory) replaceFiltersExpr(list memo.FiltersExpr, replace ReplaceFunc) (_ memo.FiltersExpr, changed bool) {
	var newList []memo.FiltersItem
	for i := range list {
		before := list[i].Condition
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.FiltersItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructFiltersItem(after)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

// CopyAndReplaceDefault performs the default traversal and cloning behavior
// for the CopyAndReplace method. It constructs a copy of the given source
// operator using children copied (and potentially remapped) by the given replace
// function. See comments for CopyAndReplace for more details.
func (f *Factory) CopyAndReplaceDefault(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	switch t := src.(type) {
	case *memo.SelectExpr:
		return f.ConstructSelect(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.Filters, replace),
		)

	case *memo.InnerJoinExpr:
		return f.ConstructInnerJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
		)

	case *memo.InnerJoinApplyExpr:
		return f.ConstructInnerJoinApply(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
		)

	}
	panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(src.Op())))
}

func (f *Factory) copyAndReplaceDefaultFiltersExpr(src memo.FiltersExpr, replace ReplaceFunc) (dst memo.FiltersExpr) {
	dst = make(memo.FiltersExpr, len(src))
	for i := range src {
		dst[i].Condition = f.invokeReplace(src[i].Condition, replace).(opt.ScalarExpr)
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

// invokeReplace wraps the user-provided replace function. See comments for
// CopyAndReplace for more details.
func (f *Factory) invokeReplace(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	if rel, ok := src.(memo.RelExpr); ok {
		src = rel.FirstExpr()
	}
	return replace(src)
}

func (f *Factory) DynamicConstruct(op opt.Operator, args ...interface{}) opt.Expr {
	switch op {
	case opt.SelectOp:
		return f.ConstructSelect(
			args[0].(memo.RelExpr),
			*args[1].(*memo.FiltersExpr),
		)
	case opt.InnerJoinOp:
		return f.ConstructInnerJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
		)
	case opt.InnerJoinApplyOp:
		return f.ConstructInnerJoinApply(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
		)
	}
	panic(errors.AssertionFailedf("cannot dynamically construct operator %s", errors.Safe(op)))
}
----
----

#
# Generate code for testing rules that manipulate a strongly-typed child
# expression. Try several different variations of the rule to test various
# static and dynamic matching and replacing variations.
#
optgen factory test.opt

[Scalar]
define Variable {
    Col ColumnID
}

[Scalar, Aggregate]
define Min {
    Input VariableExpr
}

[Scalar, Aggregate]
define Max {
    Input VariableExpr
}

[Scalar]
define AggDistinct {
    Input ScalarExpr
}

[EliminateAggDistinct1, Normalize]
(AggDistinct
    $input:(Min | Max)
)
=>
$input

[EliminateAggDistinct2, Normalize]
(AggDistinct
    $input:(Min | Max $variable:*)
)
=>
((OpName $input) $variable)

[EliminateAggDistinct3, Normalize]
(AggDistinct
    $input:(Min $variable:*)
)
=>
(Min $variable)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props/physical"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

// ConstructVariable constructs an expression for the Variable operator.
func (_f *Factory) ConstructVariable(
	col opt.ColumnID,
) opt.ScalarExpr {
	e := _f.mem.MemoizeVariable(col)
	return _f.onConstructScalar(e)
}

// ConstructMin constructs an expression for the Min operator.
func (_f *Factory) ConstructMin(
	input *memo.VariableExpr,
) opt.ScalarExpr {
	e := _f.mem.MemoizeMin(input)
	return _f.onConstructScalar(e)
}

// ConstructMax constructs an expression for the Max operator.
func (_f *Factory) ConstructMax(
	input *memo.VariableExpr,
) opt.ScalarExpr {
	e := _f.mem.MemoizeMax(input)
	return _f.onConstructScalar(e)
}

// ConstructAggDistinct constructs an expression for the AggDistinct operator.
func (_f *Factory) ConstructAggDistinct(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	// [EliminateAggDistinct1]
	{
		if input.Op() == opt.MinOp || input.Op() == opt.MaxOp {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinct1) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAggDistinct1, nil, _expr)
				}
				return _expr
			}
		}
	}

	// [EliminateAggDistinct2]
	{
		if input.Op() == opt.MinOp || input.Op() == opt.MaxOp {
			variable := input.Child(0).(*memo.VariableExpr)
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinct2) {
				_expr := _f.DynamicConstruct(
					input.Op(),
					variable,
				).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAggDistinct2, nil, _expr)
				}
				return _expr
			}
		}
	}

	// [EliminateAggDistinct3]
	{
		_min, _ := input.(*memo.MinExpr)
		if _min != nil {
			variable := _min.Input
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinct3) {
				_expr := _f.ConstructMin(
					variable,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAggDistinct3, nil, _expr)
				}
				return _expr
			}
		}
	}

	e := _f.mem.MemoizeAggDistinct(input)
	return _f.onConstructScalar(e)
}

// Replace enables an expression subtree to be rewritten under the control of
// the caller. It passes each child of the given expression to the replace
// callback. The caller can continue traversing the expression tree within the
// callback by recursively calling Replace. It can also return a replacement
// expression; if it does, then Replace will rebuild the operator and its
// ancestors via a calls to the corresponding factory Construct methods. Here
// is example usage:
//
//   var replace func(e opt.Expr) opt.Expr
//   replace = func(e opt.Expr) opt.Expr {
//     if e.Op() == opt.VariableOp {
//       return getReplaceVar(e)
//     }
//     return factory.Replace(e, replace)
//   }
//   replace(root, replace)
//
// Here, all variables in the tree are being replaced by some other expression
// in a pre-order traversal of the tree. Post-order traversal is trivially
// achieved by moving the factory.Replace call to the top of the replace
// function rather than bottom.
func (f *Factory) Replace(e opt.Expr, replace ReplaceFunc) opt.Expr {
	switch t := e.(type) {
	case *memo.VariableExpr:
		return t

	case *memo.MinExpr:
		input := replace(t.Input).(*memo.VariableExpr)
		if input != t.Input {
			return f.ConstructMin(input)
		}
		return t

	case *memo.MaxExpr:
		input := replace(t.Input).(*memo.VariableExpr)
		if input != t.Input {
			return f.ConstructMax(input)
		}
		return t

	case *memo.AggDistinctExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructAggDistinct(input)
		}
		return t

	}
	panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(e.Op())))
}

// CopyAndReplaceDefault performs the default traversal and cloning behavior
// for the CopyAndReplace method. It constructs a copy of the given source
// operator using children copied (and potentially remapped) by the given replace
// function. See comments for CopyAndReplace for more details.
func (f *Factory) CopyAndReplaceDefault(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	switch t := src.(type) {
	case *memo.VariableExpr:
		return t

	case *memo.MinExpr:
		return f.ConstructMin(
			f.invokeReplace(t.Input, replace).(*memo.VariableExpr),
		)

	case *memo.MaxExpr:
		return f.ConstructMax(
			f.invokeReplace(t.Input, replace).(*memo.VariableExpr),
		)

	case *memo.AggDistinctExpr:
		return f.ConstructAggDistinct(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	}
	panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(src.Op())))
}

// invokeReplace wraps the user-provided replace function. See comments for
// CopyAndReplace for more details.
func (f *Factory) invokeReplace(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	if rel, ok := src.(memo.RelExpr); ok {
		src = rel.FirstExpr()
	}
	return replace(src)
}

func (f *Factory) DynamicConstruct(op opt.Operator, args ...interface{}) opt.Expr {
	switch op {
	case opt.VariableOp:
		return f.ConstructVariable(
			*args[0].(*opt.ColumnID),
		)
	case opt.MinOp:
		return f.ConstructMin(
			args[0].(*memo.VariableExpr),
		)
	case opt.MaxOp:
		return f.ConstructMax(
			args[0].(*memo.VariableExpr),
		)
	case opt.AggDistinctOp:
		return f.ConstructAggDistinct(
			args[0].(opt.ScalarExpr),
		)
	}
	panic(errors.AssertionFailedf("cannot dynamically construct operator %s", errors.Safe(op)))
}
----
----
