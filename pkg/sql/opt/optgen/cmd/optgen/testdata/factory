#
# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
#
optgen factory test.opt
# Not is a negate operator.
define Not {
    Input Expr
}

define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}

# This shouldn't be added to the factory.
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructNot constructs an expression for the Not operator.
// Not is a negate operator.
func (_f *Factory) ConstructNot(
	input memo.GroupID,
) memo.GroupID {
	_notExpr := memo.MakeNotExpr(input)
	_group := _f.mem.GroupByFingerprint(_notExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_notExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_notExpr)))
}

// ConstructFuncCall constructs an expression for the FuncCall operator.
func (_f *Factory) ConstructFuncCall(
	name memo.GroupID,
	args memo.ListID,
	def memo.PrivateID,
) memo.GroupID {
	_funcCallExpr := memo.MakeFuncCallExpr(name, args, def)
	_group := _f.mem.GroupByFingerprint(_funcCallExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_funcCallExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_funcCallExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNot(memo.GroupID(operands[0]))
	}

	// FuncCallOp
	dynConstructLookup[opt.FuncCallOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFuncCall(memo.GroupID(operands[0]), operands[1].ListID(), memo.PrivateID(operands[2]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate static matching and replacement code.
#
optgen factory test.opt
define InnerJoin {
    Left  Expr
    Right Expr
}

[CommuteJoin, Normalize]
(InnerJoin $r:* $s:*) => (InnerJoin $s $r)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *Factory) ConstructInnerJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_innerJoinExpr := memo.MakeInnerJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_innerJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_innerJoinExpr))
	}

	// [CommuteJoin]
	{
		r := left
		s := right
		_f.o.reportOptimization(CommuteJoin)
		_group = _f.ConstructInnerJoin(
			s,
			r,
		)
		_f.mem.AddAltFingerprint(_innerJoinExpr.Fingerprint(), _group)
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_innerJoinExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructInnerJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate multiple match names, not expr, custom function, literal names in
# match and replace patterns, and use OpName builtin to construct replacement
# expression with name known at compile-time.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Lt {
    Left  Expr
    Right Expr
}

define Plus {
    Left  Expr
    Right Expr
}

define Minus {
    Left  Expr
    Right Expr
}

define Const {
}

[NormalizeVarPlus, Normalize]
(Eq | Lt
    (Plus
        $leftLeft:^(Const)
        $leftRight:(Const)
    )
    $right:(Const) & ^(IsInvalidBinary Minus $right $leftRight)
) =>
((OpName)
    $leftLeft
    (ConstructBinary Minus $right $leftRight)
)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_eqExpr := memo.MakeEqExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_eqExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_eqExpr))
	}

	// [NormalizeVarPlus]
	{
		_plus := _f.mem.NormExpr(left).AsPlus()
		if _plus != nil {
			leftLeft := _plus.Left()
			_const := _f.mem.NormExpr(_plus.Left()).AsConst()
			if _const == nil {
				leftRight := _plus.Right()
				_const2 := _f.mem.NormExpr(_plus.Right()).AsConst()
				if _const2 != nil {
					_const3 := _f.mem.NormExpr(right).AsConst()
					if _const3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeVarPlus)
							_group = _f.ConstructEq(
								leftLeft,
								_f.constructBinary(opt.MinusOp, right, leftRight),
							)
							_f.mem.AddAltFingerprint(_eqExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_eqExpr)))
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_ltExpr := memo.MakeLtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_ltExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_ltExpr))
	}

	// [NormalizeVarPlus]
	{
		_plus := _f.mem.NormExpr(left).AsPlus()
		if _plus != nil {
			leftLeft := _plus.Left()
			_const := _f.mem.NormExpr(_plus.Left()).AsConst()
			if _const == nil {
				leftRight := _plus.Right()
				_const2 := _f.mem.NormExpr(_plus.Right()).AsConst()
				if _const2 != nil {
					_const3 := _f.mem.NormExpr(right).AsConst()
					if _const3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							_f.o.reportOptimization(NormalizeVarPlus)
							_group = _f.ConstructLt(
								leftLeft,
								_f.constructBinary(opt.MinusOp, right, leftRight),
							)
							_f.mem.AddAltFingerprint(_ltExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_ltExpr)))
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_plusExpr := memo.MakePlusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_plusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_plusExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_minusExpr := memo.MakeMinusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_minusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_minusExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_minusExpr)))
}

// ConstructConst constructs an expression for the Const operator.
func (_f *Factory) ConstructConst() memo.GroupID {
	_constExpr := memo.MakeConstExpr()
	_group := _f.mem.GroupByFingerprint(_constExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_constExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_constExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructEq(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructLt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructPlus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructMinus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// ConstOp
	dynConstructLookup[opt.ConstOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructConst()
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate not match of op with no args, string match, list match, string
# construction, custom replace function.
#
optgen factory test.opt
define Func {
    Name Expr
    Args ExprList
}

define Variable {
    Col ColumnID
}

[Concat, Normalize]
(Func "concat" $args:[ ... $item:^(Variable) & (IsEmpty $item) ... ])
=>
(Func "concat" (RemoveListItem $args $item))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructFunc constructs an expression for the Func operator.
func (_f *Factory) ConstructFunc(
	name memo.GroupID,
	args memo.ListID,
) memo.GroupID {
	_funcExpr := memo.MakeFuncExpr(name, args)
	_group := _f.mem.GroupByFingerprint(_funcExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_funcExpr))
	}

	// [Concat]
	{
		if name == m.mem.InternPrivate("concat") {
			for _, _item := range _f.mem.LookupList(args) {
				item := _item
				_variable := _f.mem.NormExpr(_item).AsVariable()
				if _variable == nil {
					if _f.isEmpty(item) {
						_f.o.reportOptimization(Concat)
						_group = _f.ConstructFunc(
							m.mem.InternPrivate(tree.NewDString("concat")),
							_f.removeListItem(args, item),
						)
						_f.mem.AddAltFingerprint(_funcExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_funcExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
func (_f *Factory) ConstructVariable(
	col memo.PrivateID,
) memo.GroupID {
	_variableExpr := memo.MakeVariableExpr(col)
	_group := _f.mem.GroupByFingerprint(_variableExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_variableExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_variableExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// FuncOp
	dynConstructLookup[opt.FuncOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFunc(memo.GroupID(operands[0]), operands[1].ListID())
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructVariable(memo.PrivateID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate not match of op with args and not match of list. Nest matches within
# one another and use match of tag name. Match both tag and define name.
# Construct dynamic replacement and use opname literal.
#
optgen factory test.opt
define Select {
    Input Expr
    Filter Expr
}

[Join]
define InnerJoin {
    Left  Expr
    Right Expr
}

[Join]
define FullJoin {
    Left  Expr
    Right Expr
}

define Union {
    Left  Expr
    Right Expr
}

define And {
    Left  Expr
    Right Expr
}

[Test, Normalize]
(Select
    $input:^(Join|Union $r:* $s:*)
    $args:[ ... $item:(Join $t:* $u:*) ... ]
)
=>
((OpName $item) (Select $t $u) (Custom $item (OpName)))
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructSelect constructs an expression for the Select operator.
func (_f *Factory) ConstructSelect(
	input memo.GroupID,
	filter memo.GroupID,
) memo.GroupID {
	_selectExpr := memo.MakeSelectExpr(input, filter)
	_group := _f.mem.GroupByFingerprint(_selectExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_selectExpr))
	}

	// [Test]
	{
		_match := false
		_norm := _f.mem.NormExpr(input)
		if _norm.IsJoin() || _norm.Operator() == opt.UnionOp {
			r := _norm.ChildGroup(_f.mem, 0)
			s := _norm.ChildGroup(_f.mem, 1)
			_match = true
		}

		if !_match {
			args := filter
			for _, _item := range _f.mem.LookupList(filter) {
				item := _item
				_norm2 := _f.mem.NormExpr(_item)
				if _norm2.IsJoin() {
					t := _norm2.ChildGroup(_f.mem, 0)
					u := _norm2.ChildGroup(_f.mem, 1)
					_f.o.reportOptimization(Test)
					_group = _f.DynamicConstruct(
						_f.mem.NormExpr(item).Operator(),
						DynamicOperands{
							DynamicID(_f.ConstructSelect(
								t,
								u,
							)),
							DynamicID(_f.custom(item, opt.SelectOp)),
						},
					)
					_f.mem.AddAltFingerprint(_selectExpr.Fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_selectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *Factory) ConstructInnerJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_innerJoinExpr := memo.MakeInnerJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_innerJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_innerJoinExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_innerJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *Factory) ConstructFullJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_fullJoinExpr := memo.MakeFullJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_fullJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_fullJoinExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_fullJoinExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
func (_f *Factory) ConstructUnion(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_unionExpr := memo.MakeUnionExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_unionExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_unionExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_unionExpr)))
}

// ConstructAnd constructs an expression for the And operator.
func (_f *Factory) ConstructAnd(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_andExpr := memo.MakeAndExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_andExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_andExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_andExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructSelect(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructInnerJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFullJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructUnion(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructAnd(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate match for all list match operators.
#
optgen factory test.opt
define List {
    Items ExprList
}

[List, Normalize]
(List $any:[
    ...
    (List $first:[
        (List $last:[
            ...
            (List $single:[
                (List $empty:[])
            ])
        ])
        ...
    ])
    ...
])
=>
(Construct $any $first $last $single $empty)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructList constructs an expression for the List operator.
func (_f *Factory) ConstructList(
	items memo.ListID,
) memo.GroupID {
	_listExpr := memo.MakeListExpr(items)
	_group := _f.mem.GroupByFingerprint(_listExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_listExpr))
	}

	// [List]
	{
		any := items
		for _, _item := range _f.mem.LookupList(items) {
			_list := _f.mem.NormExpr(_item).AsList()
			if _list != nil {
				first := _list.Items()
				if _list.Items().Length > 0 {
					_item := _f.mem.LookupList(_list.Items())[0]
					_list2 := _f.mem.NormExpr(_item).AsList()
					if _list2 != nil {
						last := _list2.Items()
						if _list2.Items().Length > 0 {
							_item := _f.mem.LookupList(_list2.Items())[_list2.Items().Length-1]
							_list3 := _f.mem.NormExpr(_item).AsList()
							if _list3 != nil {
								single := _list3.Items()
								if _list3.Items().Length == 1 {
									_item := _f.mem.LookupList(_list3.Items())[0]
									_list4 := _f.mem.NormExpr(_item).AsList()
									if _list4 != nil {
										empty := _list4.Items()
										if _list4.Items().Length == 0 {
											_f.o.reportOptimization(List)
											_group = _f.construct(any, first, last, single, empty)
											_f.mem.AddAltFingerprint(_listExpr.Fingerprint(), _group)
											return _group
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_listExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructList(operands[0].ListID())
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate list construction operators.
#
optgen factory test.opt
define Join {
    Left  Expr
    Right Expr
    On    Expr
}

[ConstructList, Normalize]
(Join $left:* $right:* $on:*)
=>
(Construct [] [ $left ] [ $left $right] [ [$on] ])
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructJoin constructs an expression for the Join operator.
func (_f *Factory) ConstructJoin(
	left memo.GroupID,
	right memo.GroupID,
	on memo.GroupID,
) memo.GroupID {
	_joinExpr := memo.MakeJoinExpr(left, right, on)
	_group := _f.mem.GroupByFingerprint(_joinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_joinExpr))
	}

	// [ConstructList]
	{
		_f.o.reportOptimization(ConstructList)
		_group = _f.construct(_f.mem.InternList([]memo.GroupID{}), _f.mem.InternList([]memo.GroupID{left}), _f.mem.InternList([]memo.GroupID{left, right}), _f.mem.InternList([]memo.GroupID{_f.mem.InternList([]memo.GroupID{on})}))
		_f.mem.AddAltFingerprint(_joinExpr.Fingerprint(), _group)
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_joinExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// JoinOp
	dynConstructLookup[opt.JoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]), memo.GroupID(operands[2]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----
#
# Generate no match for all list match operators that support it.
#
optgen factory test.opt
define List {
    Items ExprList
}

define Op {
    Empty  Expr
    Single Expr
}

[ListNot, Normalize]
(Op
    $empty:(List ^[])
    $single:(List ^[ * ])
)
=>
(Op $empty $single)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructList constructs an expression for the List operator.
func (_f *Factory) ConstructList(
	items memo.ListID,
) memo.GroupID {
	_listExpr := memo.MakeListExpr(items)
	_group := _f.mem.GroupByFingerprint(_listExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_listExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_listExpr)))
}

// ConstructOp constructs an expression for the Op operator.
func (_f *Factory) ConstructOp(
	empty memo.GroupID,
	single memo.GroupID,
) memo.GroupID {
	_opExpr := memo.MakeOpExpr(empty, single)
	_group := _f.mem.GroupByFingerprint(_opExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_opExpr))
	}

	// [ListNot]
	{
		_list := _f.mem.NormExpr(empty).AsList()
		if _list != nil {
			if _list.Items().Length != 0 {
				_list2 := _f.mem.NormExpr(single).AsList()
				if _list2 != nil {
					if _list2.Items().Length != 1 {
						_f.o.reportOptimization(ListNot)
						_group = _f.ConstructOp(
							empty,
							single,
						)
						_f.mem.AddAltFingerprint(_opExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_opExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructList(operands[0].ListID())
	}

	// OpOp
	dynConstructLookup[opt.OpOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructOp(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate match and nomatch for both constant and dynamic match cases, with
# and without child matchers.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Ne {
    Left  Expr
    Right Expr
}

[Constant, Normalize]
(Eq
    (Eq (Eq) ^(Eq))
    ^(Eq (Eq) ^(Eq))
)
=>
"foo"

[Dynamic, Normalize]
(Ne
    (Eq|Ne (Eq|Ne) ^(Eq|Ne))
    ^(Eq|Ne (Eq|Ne) ^(Eq|Ne))
)
=>
"foo"
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_eqExpr := memo.MakeEqExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_eqExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_eqExpr))
	}

	// [Constant]
	{
		_eq := _f.mem.NormExpr(left).AsEq()
		if _eq != nil {
			_eq2 := _f.mem.NormExpr(_eq.Left()).AsEq()
			if _eq2 != nil {
				_eq3 := _f.mem.NormExpr(_eq.Right()).AsEq()
				if _eq3 == nil {
					_match := false
					_eq4 := _f.mem.NormExpr(right).AsEq()
					if _eq4 != nil {
						_eq5 := _f.mem.NormExpr(_eq4.Left()).AsEq()
						if _eq5 != nil {
							_eq6 := _f.mem.NormExpr(_eq4.Right()).AsEq()
							if _eq6 == nil {
								_match = true
							}
						}
					}

					if !_match {
						_f.o.reportOptimization(Constant)
						_group = m.mem.InternPrivate(tree.NewDString("foo"))
						_f.mem.AddAltFingerprint(_eqExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_eqExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *Factory) ConstructNe(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_neExpr := memo.MakeNeExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_neExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_neExpr))
	}

	// [Dynamic]
	{
		_norm := _f.mem.NormExpr(left)
		if _norm.Operator() == opt.EqOp || _norm.Operator() == opt.NeOp {
			_norm2 := _f.mem.NormExpr(_norm.ChildGroup(_f.mem, 0))
			if _norm2.Operator() == opt.EqOp || _norm2.Operator() == opt.NeOp {
				_norm3 := _f.mem.NormExpr(_norm.ChildGroup(_f.mem, 1))
				if !(_norm3.Operator() == opt.EqOp || _norm3.Operator() == opt.NeOp) {
					_match := false
					_norm4 := _f.mem.NormExpr(right)
					if _norm4.Operator() == opt.EqOp || _norm4.Operator() == opt.NeOp {
						_norm5 := _f.mem.NormExpr(_norm4.ChildGroup(_f.mem, 0))
						if _norm5.Operator() == opt.EqOp || _norm5.Operator() == opt.NeOp {
							_norm6 := _f.mem.NormExpr(_norm4.ChildGroup(_f.mem, 1))
							if !(_norm6.Operator() == opt.EqOp || _norm6.Operator() == opt.NeOp) {
								_match = true
							}
						}
					}

					if !_match {
						_f.o.reportOptimization(Dynamic)
						_group = m.mem.InternPrivate(tree.NewDString("foo"))
						_f.mem.AddAltFingerprint(_neExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_neExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructEq(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNe(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate nested custom matching functions, including OpName.
#
optgen factory test.opt
[Binary]
define Plus {
    Left  Expr
    Right Expr
}

[Binary]
define Minus {
    Left  Expr
    Right Expr
}

define Null {}

[Fold, Normalize]
(Binary
    $left:*
    (Null) & ^(HasNullableArgs (OpName) (AnotherFunc (OpName $left)))
)
=>
(Null)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_plusExpr := memo.MakePlusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_plusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_plusExpr))
	}

	// [Fold]
	{
		_null := _f.mem.NormExpr(right).AsNull()
		if _null != nil {
			if !_f.hasNullableArgs(opt.PlusOp, _f.anotherFunc(_f.mem.NormExpr(left).Operator())) {
				_f.o.reportOptimization(Fold)
				_group = _f.ConstructNull()
				_f.mem.AddAltFingerprint(_plusExpr.Fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_minusExpr := memo.MakeMinusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_minusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_minusExpr))
	}

	// [Fold]
	{
		_null := _f.mem.NormExpr(right).AsNull()
		if _null != nil {
			if !_f.hasNullableArgs(opt.MinusOp, _f.anotherFunc(_f.mem.NormExpr(left).Operator())) {
				_f.o.reportOptimization(Fold)
				_group = _f.ConstructNull()
				_f.mem.AddAltFingerprint(_minusExpr.Fingerprint(), _group)
				return _group
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_minusExpr)))
}

// ConstructNull constructs an expression for the Null operator.
func (_f *Factory) ConstructNull() memo.GroupID {
	_nullExpr := memo.MakeNullExpr()
	_group := _f.mem.GroupByFingerprint(_nullExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_nullExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_nullExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructPlus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructMinus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NullOp
	dynConstructLookup[opt.NullOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNull()
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate multiple op matchers combined into a boolean expression.
#
optgen factory test.opt
[Comparison]
define Lt {
    Left  Expr
    Right Expr
}

[Comparison]
define Gt {
    Left  Expr
    Right Expr
}

[Comparison]
define Contains {
    Left  Expr
    Right Expr
}

define Not {
    Input Expr
}

[Invert, Normalize]
(Not $input:(Comparison $left:* $right:*) & ^(Contains) & (SomeOtherCondition $input))
=>
(Invert (OpName $input) $left $right)
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_ltExpr := memo.MakeLtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_ltExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_ltExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_ltExpr)))
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *Factory) ConstructGt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_gtExpr := memo.MakeGtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_gtExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_gtExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_gtExpr)))
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *Factory) ConstructContains(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_containsExpr := memo.MakeContainsExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_containsExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_containsExpr))
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_containsExpr)))
}

// ConstructNot constructs an expression for the Not operator.
func (_f *Factory) ConstructNot(
	input memo.GroupID,
) memo.GroupID {
	_notExpr := memo.MakeNotExpr(input)
	_group := _f.mem.GroupByFingerprint(_notExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	if !_f.o.allowOptimizations() {
		return _f.mem.MemoizeNormExpr(memo.Expr(_notExpr))
	}

	// [Invert]
	{
		_norm := _f.mem.NormExpr(input)
		if _norm.IsComparison() {
			left := _norm.ChildGroup(_f.mem, 0)
			right := _norm.ChildGroup(_f.mem, 1)
			_contains := _f.mem.NormExpr(input).AsContains()
			if _contains == nil {
				if _f.someOtherCondition(input) {
					_f.o.reportOptimization(Invert)
					_group = _f.invert(_f.mem.NormExpr(input).Operator(), left, right)
					_f.mem.AddAltFingerprint(_notExpr.Fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(memo.Expr(_notExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructLt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// GtOp
	dynConstructLookup[opt.GtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructGt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// ContainsOp
	dynConstructLookup[opt.ContainsOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructContains(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNot(memo.GroupID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----
