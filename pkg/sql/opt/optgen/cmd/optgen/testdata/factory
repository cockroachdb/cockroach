# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
optgen -pkg test factory test.opt
define Not {
    Input Expr
}
define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}
----
----
// Code generated by optgen; DO NOT EDIT.

package test

func (_f *Factory) ConstructNot(
	input GroupID,
) GroupID {
	_notExpr := makeNotExpr(input)
	_group := _f.mem.lookupGroupByFingerprint(_notExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_notExpr)))
}

func (_f *Factory) ConstructFuncCall(
	name GroupID,
	args ListID,
	def PrivateID,
) GroupID {
	_funcCallExpr := makeFuncCallExpr(name, args, def)
	_group := _f.mem.lookupGroupByFingerprint(_funcCallExpr.fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.memoizeNormExpr((*memoExpr)(&_funcCallExpr)))
}

type dynConstructLookupFunc func(f *Factory, children []GroupID, private PrivateID) GroupID

var dynConstructLookup [3]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[UnknownOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[NotOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructNot(children[0])
	}

	// FuncCallOp
	dynConstructLookup[FuncCallOp] = func(f *Factory, children []GroupID, private PrivateID) GroupID {
		return f.ConstructFuncCall(children[0], f.StoreList(children[1:]), private)
	}

}

func (f *Factory) DynamicConstruct(op Operator, children []GroupID, private PrivateID) GroupID {
	return dynConstructLookup[op](f, children, private)
}
----
----
