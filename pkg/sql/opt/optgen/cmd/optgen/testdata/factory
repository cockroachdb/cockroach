#
# Generate construct methods for factory that have GroupID, ListID, and
# PrivateID args.
#
optgen factory test.opt
# Not is a negate operator.
define Not {
    Input Expr
}

define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncOpDef
}

# This shouldn't be added to the factory.
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// InternFuncOpDef adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (_f *Factory) InternFuncOpDef(val *memo.FuncOpDef) memo.PrivateID {
	return _f.mem.InternFuncOpDef(val)
}

// ConstructNot constructs an expression for the Not operator.
// Not is a negate operator.
func (_f *Factory) ConstructNot(
	input memo.GroupID,
) memo.GroupID {
	_notExpr := memo.MakeNotExpr(input)
	_group := _f.mem.GroupByFingerprint(_notExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_notExpr)))
}

// ConstructFuncCall constructs an expression for the FuncCall operator.
func (_f *Factory) ConstructFuncCall(
	name memo.GroupID,
	args memo.ListID,
	def memo.PrivateID,
) memo.GroupID {
	_funcCallExpr := memo.MakeFuncCallExpr(name, args, def)
	_group := _f.mem.GroupByFingerprint(_funcCallExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_funcCallExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNot(memo.GroupID(operands[0]))
	}

	// FuncCallOp
	dynConstructLookup[opt.FuncCallOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFuncCall(memo.GroupID(operands[0]), operands[1].ListID(), memo.PrivateID(operands[2]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate static matching and replacement code.
#
optgen factory test.opt
define InnerJoin {
    Left  Expr
    Right Expr
}

[CommuteJoin, Normalize]
(InnerJoin $r:* $s:*) => (InnerJoin $s $r)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *Factory) ConstructInnerJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_innerJoinExpr := memo.MakeInnerJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_innerJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [CommuteJoin]
	{
		r := left
		s := right
		if _f.onRuleMatch == nil || _f.onRuleMatch(opt.CommuteJoin) {
			_group = _f.ConstructInnerJoin(
				s,
				r,
			)
			_f.mem.AddAltFingerprint(_innerJoinExpr.Fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_innerJoinExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructInnerJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate multiple match names, not expr, custom function, literal names in
# match and replace patterns, and use OpName builtin to construct replacement
# expression with name known at compile-time.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Lt {
    Left  Expr
    Right Expr
}

define Plus {
    Left  Expr
    Right Expr
}

define Minus {
    Left  Expr
    Right Expr
}

define Const {
    Value Datum
}

[NormalizeVarPlus, Normalize]
(Eq | Lt
    (Plus
        $leftLeft:^(Const)
        $leftRight:(Const)
    )
    $right:(Const) & ^(IsInvalidBinary Minus $right $leftRight)
) =>
((OpName)
    $leftLeft
    (ConstructBinary Minus $right $leftRight)
)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// InternDatum adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (_f *Factory) InternDatum(val tree.Datum) memo.PrivateID {
	return _f.mem.InternDatum(val)
}

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_eqExpr := memo.MakeEqExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_eqExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [NormalizeVarPlus]
	{
		_plusExpr := _f.mem.NormExpr(left).AsPlus()
		if _plusExpr != nil {
			leftLeft := _plusExpr.Left()
			_constExpr := _f.mem.NormExpr(_plusExpr.Left()).AsConst()
			if _constExpr == nil {
				leftRight := _plusExpr.Right()
				_constExpr2 := _f.mem.NormExpr(_plusExpr.Right()).AsConst()
				if _constExpr2 != nil {
					_constExpr3 := _f.mem.NormExpr(right).AsConst()
					if _constExpr3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							if _f.onRuleMatch == nil || _f.onRuleMatch(opt.NormalizeVarPlus) {
								_group = _f.ConstructEq(
									leftLeft,
									_f.constructBinary(opt.MinusOp, right, leftRight),
								)
								_f.mem.AddAltFingerprint(_eqExpr.Fingerprint(), _group)
								return _group
							}
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_eqExpr)))
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_ltExpr := memo.MakeLtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_ltExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [NormalizeVarPlus]
	{
		_plusExpr := _f.mem.NormExpr(left).AsPlus()
		if _plusExpr != nil {
			leftLeft := _plusExpr.Left()
			_constExpr := _f.mem.NormExpr(_plusExpr.Left()).AsConst()
			if _constExpr == nil {
				leftRight := _plusExpr.Right()
				_constExpr2 := _f.mem.NormExpr(_plusExpr.Right()).AsConst()
				if _constExpr2 != nil {
					_constExpr3 := _f.mem.NormExpr(right).AsConst()
					if _constExpr3 != nil {
						if !_f.isInvalidBinary(opt.MinusOp, right, leftRight) {
							if _f.onRuleMatch == nil || _f.onRuleMatch(opt.NormalizeVarPlus) {
								_group = _f.ConstructLt(
									leftLeft,
									_f.constructBinary(opt.MinusOp, right, leftRight),
								)
								_f.mem.AddAltFingerprint(_ltExpr.Fingerprint(), _group)
								return _group
							}
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_ltExpr)))
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_plusExpr := memo.MakePlusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_plusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_minusExpr := memo.MakeMinusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_minusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_minusExpr)))
}

// ConstructConst constructs an expression for the Const operator.
func (_f *Factory) ConstructConst(
	value memo.PrivateID,
) memo.GroupID {
	_constExpr := memo.MakeConstExpr(value)
	_group := _f.mem.GroupByFingerprint(_constExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_constExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructEq(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructLt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructPlus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructMinus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// ConstOp
	dynConstructLookup[opt.ConstOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructConst(memo.PrivateID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate not match of op with no args, string match, list match, string
# construction, custom replace function.
#
optgen factory test.opt
define Func {
    Name Expr
    Args ExprList
    Def  FuncOpDef
}

define Variable {
    Col ColumnID
}

[Concat, Normalize]
(Func "concat" $args:[ ... $item:^(Variable) & (IsEmpty $item) ... ])
=>
(Func "concat" (RemoveListItem $args $item))
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// InternFuncOpDef adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (_f *Factory) InternFuncOpDef(val *memo.FuncOpDef) memo.PrivateID {
	return _f.mem.InternFuncOpDef(val)
}

// InternColumnID adds the given value to the memo and returns an ID that
// can be used for later lookup. If the same value was added previously,
// this method is a no-op and returns the ID of the previous value.
func (_f *Factory) InternColumnID(val opt.ColumnID) memo.PrivateID {
	return _f.mem.InternColumnID(val)
}

// ConstructFunc constructs an expression for the Func operator.
func (_f *Factory) ConstructFunc(
	name memo.GroupID,
	args memo.ListID,
	def memo.PrivateID,
) memo.GroupID {
	_funcExpr := memo.MakeFuncExpr(name, args, def)
	_group := _f.mem.GroupByFingerprint(_funcExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Concat]
	{
		if name == m.mem.InternPrivate("concat") {
			for _, _item := range _f.mem.LookupList(args) {
				item := _item
				_variableExpr := _f.mem.NormExpr(_item).AsVariable()
				if _variableExpr == nil {
					if _f.isEmpty(item) {
						if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Concat) {
							_group = _f.ConstructFunc(
								m.mem.InternPrivate(tree.NewDString("concat")),
								_f.removeListItem(args, item),
							)
							_f.mem.AddAltFingerprint(_funcExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_funcExpr)))
}

// ConstructVariable constructs an expression for the Variable operator.
func (_f *Factory) ConstructVariable(
	col memo.PrivateID,
) memo.GroupID {
	_variableExpr := memo.MakeVariableExpr(col)
	_group := _f.mem.GroupByFingerprint(_variableExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_variableExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// FuncOp
	dynConstructLookup[opt.FuncOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFunc(memo.GroupID(operands[0]), operands[1].ListID(), memo.PrivateID(operands[2]))
	}

	// VariableOp
	dynConstructLookup[opt.VariableOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructVariable(memo.PrivateID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate not match of op with args and not match of list. Nest matches within
# one another and use match of tag name. Match both tag and define name.
# Construct dynamic replacement and use opname literal.
#
optgen factory test.opt
define Select {
    Input Expr
    Filter Expr
}

[Join]
define InnerJoin {
    Left  Expr
    Right Expr
}

[Join]
define FullJoin {
    Left  Expr
    Right Expr
}

define Union {
    Left  Expr
    Right Expr
}

define And {
    Left  Expr
    Right Expr
}

[Test, Normalize]
(Select
    $input:^(Join|Union $r:* $s:*)
    $args:[ ... $item:(Join $t:* $u:*) ... ]
)
=>
((OpName $item) (Select $t $u) (Custom $item (OpName)))
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructSelect constructs an expression for the Select operator.
func (_f *Factory) ConstructSelect(
	input memo.GroupID,
	filter memo.GroupID,
) memo.GroupID {
	_selectExpr := memo.MakeSelectExpr(input, filter)
	_group := _f.mem.GroupByFingerprint(_selectExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Test]
	{
		_match := false
		_expr := _f.mem.NormExpr(input)
		if _expr.IsJoin() || _expr.Operator() == opt.UnionOp {
			r := _expr.ChildGroup(_f.mem, 0)
			s := _expr.ChildGroup(_f.mem, 1)
			_match = true
		}

		if !_match {
			args := filter
			for _, _item := range _f.mem.LookupList(filter) {
				item := _item
				_expr2 := _f.mem.NormExpr(_item)
				if _expr2.IsJoin() {
					t := _expr2.ChildGroup(_f.mem, 0)
					u := _expr2.ChildGroup(_f.mem, 1)
					if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Test) {
						_group = _f.DynamicConstruct(
							_f.mem.NormExpr(item).Operator(),
							DynamicOperands{
								DynamicID(_f.ConstructSelect(
									t,
									u,
								)),
								DynamicID(_f.custom(item, opt.SelectOp)),
							},
						)
						_f.mem.AddAltFingerprint(_selectExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_selectExpr)))
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
func (_f *Factory) ConstructInnerJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_innerJoinExpr := memo.MakeInnerJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_innerJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_innerJoinExpr)))
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *Factory) ConstructFullJoin(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_fullJoinExpr := memo.MakeFullJoinExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_fullJoinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_fullJoinExpr)))
}

// ConstructUnion constructs an expression for the Union operator.
func (_f *Factory) ConstructUnion(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_unionExpr := memo.MakeUnionExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_unionExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_unionExpr)))
}

// ConstructAnd constructs an expression for the And operator.
func (_f *Factory) ConstructAnd(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_andExpr := memo.MakeAndExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_andExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_andExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// SelectOp
	dynConstructLookup[opt.SelectOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructSelect(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// InnerJoinOp
	dynConstructLookup[opt.InnerJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructInnerJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// FullJoinOp
	dynConstructLookup[opt.FullJoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructFullJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// UnionOp
	dynConstructLookup[opt.UnionOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructUnion(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// AndOp
	dynConstructLookup[opt.AndOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructAnd(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate match for all list match operators.
#
optgen factory test.opt
define List {
    Items ExprList
}

[List, Normalize]
(List $any:[
    ...
    (List $first:[
        (List $last:[
            ...
            (List $single:[
                (List $empty:[])
            ])
        ])
        ...
    ])
    ...
])
=>
(Construct $any $first $last $single $empty)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructList constructs an expression for the List operator.
func (_f *Factory) ConstructList(
	items memo.ListID,
) memo.GroupID {
	_listExpr := memo.MakeListExpr(items)
	_group := _f.mem.GroupByFingerprint(_listExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [List]
	{
		any := items
		for _, _item := range _f.mem.LookupList(items) {
			_listExpr2 := _f.mem.NormExpr(_item).AsList()
			if _listExpr2 != nil {
				first := _listExpr2.Items()
				if _listExpr2.Items().Length > 0 {
					_item := _f.mem.LookupList(_listExpr2.Items())[0]
					_listExpr3 := _f.mem.NormExpr(_item).AsList()
					if _listExpr3 != nil {
						last := _listExpr3.Items()
						if _listExpr3.Items().Length > 0 {
							_item := _f.mem.LookupList(_listExpr3.Items())[_listExpr3.Items().Length-1]
							_listExpr4 := _f.mem.NormExpr(_item).AsList()
							if _listExpr4 != nil {
								single := _listExpr4.Items()
								if _listExpr4.Items().Length == 1 {
									_item := _f.mem.LookupList(_listExpr4.Items())[0]
									_listExpr5 := _f.mem.NormExpr(_item).AsList()
									if _listExpr5 != nil {
										empty := _listExpr5.Items()
										if _listExpr5.Items().Length == 0 {
											if _f.onRuleMatch == nil || _f.onRuleMatch(opt.List) {
												_group = _f.construct(any, first, last, single, empty)
												_f.mem.AddAltFingerprint(_listExpr.Fingerprint(), _group)
												return _group
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_listExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructList(operands[0].ListID())
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate list construction operators.
#
optgen factory test.opt
define Join {
    Left  Expr
    Right Expr
    On    Expr
}

[ConstructList, Normalize]
(Join $left:* $right:* $on:*)
=>
(Construct [] [ $left ] [ $left $right] [ [$on] ])
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructJoin constructs an expression for the Join operator.
func (_f *Factory) ConstructJoin(
	left memo.GroupID,
	right memo.GroupID,
	on memo.GroupID,
) memo.GroupID {
	_joinExpr := memo.MakeJoinExpr(left, right, on)
	_group := _f.mem.GroupByFingerprint(_joinExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [ConstructList]
	{
		if _f.onRuleMatch == nil || _f.onRuleMatch(opt.ConstructList) {
			_group = _f.construct(_f.mem.InternList([]memo.GroupID{}), _f.mem.InternList([]memo.GroupID{left}), _f.mem.InternList([]memo.GroupID{left, right}), _f.mem.InternList([]memo.GroupID{_f.mem.InternList([]memo.GroupID{on})}))
			_f.mem.AddAltFingerprint(_joinExpr.Fingerprint(), _group)
			return _group
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_joinExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// JoinOp
	dynConstructLookup[opt.JoinOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructJoin(memo.GroupID(operands[0]), memo.GroupID(operands[1]), memo.GroupID(operands[2]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----
#
# Generate no match for all list match operators that support it.
#
optgen factory test.opt
define List {
    Items ExprList
}

define Op {
    Empty  Expr
    Single Expr
}

[ListNot, Normalize]
(Op
    $empty:(List ^[])
    $single:(List ^[ * ])
)
=>
(Op $empty $single)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructList constructs an expression for the List operator.
func (_f *Factory) ConstructList(
	items memo.ListID,
) memo.GroupID {
	_listExpr := memo.MakeListExpr(items)
	_group := _f.mem.GroupByFingerprint(_listExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_listExpr)))
}

// ConstructOp constructs an expression for the Op operator.
func (_f *Factory) ConstructOp(
	empty memo.GroupID,
	single memo.GroupID,
) memo.GroupID {
	_opExpr := memo.MakeOpExpr(empty, single)
	_group := _f.mem.GroupByFingerprint(_opExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [ListNot]
	{
		_listExpr := _f.mem.NormExpr(empty).AsList()
		if _listExpr != nil {
			if _listExpr.Items().Length != 0 {
				_listExpr2 := _f.mem.NormExpr(single).AsList()
				if _listExpr2 != nil {
					if _listExpr2.Items().Length != 1 {
						if _f.onRuleMatch == nil || _f.onRuleMatch(opt.ListNot) {
							_group = _f.ConstructOp(
								empty,
								single,
							)
							_f.mem.AddAltFingerprint(_opExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_opExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// ListOp
	dynConstructLookup[opt.ListOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructList(operands[0].ListID())
	}

	// OpOp
	dynConstructLookup[opt.OpOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructOp(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate match and nomatch for both constant and dynamic match cases, with
# and without child matchers.
#
optgen factory test.opt
define Eq {
    Left  Expr
    Right Expr
}

define Ne {
    Left  Expr
    Right Expr
}

[Constant, Normalize]
(Eq
    (Eq (Eq) ^(Eq))
    ^(Eq (Eq) ^(Eq))
)
=>
"foo"

[Dynamic, Normalize]
(Ne
    (Eq|Ne (Eq|Ne) ^(Eq|Ne))
    ^(Eq|Ne (Eq|Ne) ^(Eq|Ne))
)
=>
"foo"
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_eqExpr := memo.MakeEqExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_eqExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Constant]
	{
		_eqExpr2 := _f.mem.NormExpr(left).AsEq()
		if _eqExpr2 != nil {
			_eqExpr3 := _f.mem.NormExpr(_eqExpr2.Left()).AsEq()
			if _eqExpr3 != nil {
				_eqExpr4 := _f.mem.NormExpr(_eqExpr2.Right()).AsEq()
				if _eqExpr4 == nil {
					_match := false
					_eqExpr5 := _f.mem.NormExpr(right).AsEq()
					if _eqExpr5 != nil {
						_eqExpr6 := _f.mem.NormExpr(_eqExpr5.Left()).AsEq()
						if _eqExpr6 != nil {
							_eqExpr7 := _f.mem.NormExpr(_eqExpr5.Right()).AsEq()
							if _eqExpr7 == nil {
								_match = true
							}
						}
					}

					if !_match {
						if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Constant) {
							_group = m.mem.InternPrivate(tree.NewDString("foo"))
							_f.mem.AddAltFingerprint(_eqExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_eqExpr)))
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *Factory) ConstructNe(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_neExpr := memo.MakeNeExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_neExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Dynamic]
	{
		_expr := _f.mem.NormExpr(left)
		if _expr.Operator() == opt.EqOp || _expr.Operator() == opt.NeOp {
			_expr2 := _f.mem.NormExpr(_expr.ChildGroup(_f.mem, 0))
			if _expr2.Operator() == opt.EqOp || _expr2.Operator() == opt.NeOp {
				_expr3 := _f.mem.NormExpr(_expr.ChildGroup(_f.mem, 1))
				if !(_expr3.Operator() == opt.EqOp || _expr3.Operator() == opt.NeOp) {
					_match := false
					_expr4 := _f.mem.NormExpr(right)
					if _expr4.Operator() == opt.EqOp || _expr4.Operator() == opt.NeOp {
						_expr5 := _f.mem.NormExpr(_expr4.ChildGroup(_f.mem, 0))
						if _expr5.Operator() == opt.EqOp || _expr5.Operator() == opt.NeOp {
							_expr6 := _f.mem.NormExpr(_expr4.ChildGroup(_f.mem, 1))
							if !(_expr6.Operator() == opt.EqOp || _expr6.Operator() == opt.NeOp) {
								_match = true
							}
						}
					}

					if !_match {
						if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Dynamic) {
							_group = m.mem.InternPrivate(tree.NewDString("foo"))
							_f.mem.AddAltFingerprint(_neExpr.Fingerprint(), _group)
							return _group
						}
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_neExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// EqOp
	dynConstructLookup[opt.EqOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructEq(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NeOp
	dynConstructLookup[opt.NeOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNe(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate nested custom matching functions, including OpName.
#
optgen factory test.opt
[Binary]
define Plus {
    Left  Expr
    Right Expr
}

[Binary]
define Minus {
    Left  Expr
    Right Expr
}

define Null {}

[Fold, Normalize]
(Binary
    $left:*
    (Null) & ^(HasNullableArgs (OpName) (AnotherFunc (OpName $left)))
)
=>
(Null)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_plusExpr := memo.MakePlusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_plusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Fold]
	{
		_nullExpr := _f.mem.NormExpr(right).AsNull()
		if _nullExpr != nil {
			if !_f.hasNullableArgs(opt.PlusOp, _f.anotherFunc(_f.mem.NormExpr(left).Operator())) {
				if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Fold) {
					_group = _f.ConstructNull()
					_f.mem.AddAltFingerprint(_plusExpr.Fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_plusExpr)))
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_minusExpr := memo.MakeMinusExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_minusExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Fold]
	{
		_nullExpr := _f.mem.NormExpr(right).AsNull()
		if _nullExpr != nil {
			if !_f.hasNullableArgs(opt.MinusOp, _f.anotherFunc(_f.mem.NormExpr(left).Operator())) {
				if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Fold) {
					_group = _f.ConstructNull()
					_f.mem.AddAltFingerprint(_minusExpr.Fingerprint(), _group)
					return _group
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_minusExpr)))
}

// ConstructNull constructs an expression for the Null operator.
func (_f *Factory) ConstructNull() memo.GroupID {
	_nullExpr := memo.MakeNullExpr()
	_group := _f.mem.GroupByFingerprint(_nullExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_nullExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// PlusOp
	dynConstructLookup[opt.PlusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructPlus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// MinusOp
	dynConstructLookup[opt.MinusOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructMinus(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NullOp
	dynConstructLookup[opt.NullOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNull()
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----

#
# Generate multiple op matchers combined into a boolean expression.
#
optgen factory test.opt
[Comparison]
define Lt {
    Left  Expr
    Right Expr
}

[Comparison]
define Gt {
    Left  Expr
    Right Expr
}

[Comparison]
define Contains {
    Left  Expr
    Right Expr
}

define Not {
    Input Expr
}

[Invert, Normalize]
(Not $input:(Comparison $left:* $right:*) & ^(Contains) & (SomeOtherCondition $input))
=>
(Invert (OpName $input) $left $right)
----
----
// Code generated by optgen; [omitted]

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_ltExpr := memo.MakeLtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_ltExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_ltExpr)))
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *Factory) ConstructGt(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_gtExpr := memo.MakeGtExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_gtExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_gtExpr)))
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *Factory) ConstructContains(
	left memo.GroupID,
	right memo.GroupID,
) memo.GroupID {
	_containsExpr := memo.MakeContainsExpr(left, right)
	_group := _f.mem.GroupByFingerprint(_containsExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_containsExpr)))
}

// ConstructNot constructs an expression for the Not operator.
func (_f *Factory) ConstructNot(
	input memo.GroupID,
) memo.GroupID {
	_notExpr := memo.MakeNotExpr(input)
	_group := _f.mem.GroupByFingerprint(_notExpr.Fingerprint())
	if _group != 0 {
		return _group
	}

	// [Invert]
	{
		_expr := _f.mem.NormExpr(input)
		if _expr.IsComparison() {
			left := _expr.ChildGroup(_f.mem, 0)
			right := _expr.ChildGroup(_f.mem, 1)
			_containsExpr := _f.mem.NormExpr(input).AsContains()
			if _containsExpr == nil {
				if _f.someOtherCondition(input) {
					if _f.onRuleMatch == nil || _f.onRuleMatch(opt.Invert) {
						_group = _f.invert(_f.mem.NormExpr(input).Operator(), left, right)
						_f.mem.AddAltFingerprint(_notExpr.Fingerprint(), _group)
						return _group
					}
				}
			}
		}
	}

	return _f.onConstruct(_f.mem.MemoizeNormExpr(_f.evalCtx, memo.Expr(_notExpr)))
}

type dynConstructLookupFunc func(f *Factory, operands DynamicOperands) memo.GroupID

var dynConstructLookup [opt.NumOperators]dynConstructLookupFunc

func init() {
	// UnknownOp
	dynConstructLookup[opt.UnknownOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		panic("op type not initialized")
	}

	// LtOp
	dynConstructLookup[opt.LtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructLt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// GtOp
	dynConstructLookup[opt.GtOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructGt(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// ContainsOp
	dynConstructLookup[opt.ContainsOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructContains(memo.GroupID(operands[0]), memo.GroupID(operands[1]))
	}

	// NotOp
	dynConstructLookup[opt.NotOp] = func(f *Factory, operands DynamicOperands) memo.GroupID {
		return f.ConstructNot(memo.GroupID(operands[0]))
	}

}

func (f *Factory) DynamicConstruct(op opt.Operator, operands DynamicOperands) memo.GroupID {
	return dynConstructLookup[op](f, operands)
}
----
----
