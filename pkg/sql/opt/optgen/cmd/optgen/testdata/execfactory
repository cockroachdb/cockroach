optgen execfactory test.opt
# Scan runs a scan of a specified index of a table, possibly with an index
# constraint and/or a hard limit.
define Scan {
    Table cat.Table
    # Index is a field that has a comment.
    Index cat.Index
    Params exec.ScanParams
    ReqOrdering exec.OutputOrdering
}

define Values {
    Rows [][]tree.TypedExpr
    # Columns is a field that has a multi-line
    # comment.
    Columns colinfo.ResultColumns
}
----
----
// Code generated by optgen; [omitted]

package exec

import (
	"context"

	"github.com/cockroachdb/cockroach/pkg/sql/catalog/colinfo"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	"github.com/cockroachdb/cockroach/pkg/sql/inverted"
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/cat"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
)

// Factory defines the interface for building an execution plan, which consists
// of a tree of execution nodes (currently a sql.planNode tree).
//
// The tree is always built bottom-up. The Construct methods either construct
// leaf nodes, or they take other nodes previously constructed by this same
// factory as children.
//
// The PlanGistFactory further requires that the factory methods be called in
// natural tree order, that is, after an operator's children are constructed the
// next factory method to be called must be the parent of those nodes. The gist's
// flattened tree representation relies on this to enable the use of a stack to
// hold children, thus avoiding the complexity of dealing with other tree traversal
// methods.
//
// The TypedExprs passed to these functions refer to columns of the input node
// via IndexedVars.
type Factory interface {
	// ConstructPlan creates a plan enclosing the given plan and (optionally)
	// subqueries, cascades, and checks.
	//
	// Subqueries are executed before the root tree, which can refer to subquery
	// results using tree.Subquery nodes.
	//
	// Cascades are executed after the root tree. They can return more cascades
	// and checks which should also be executed.
	//
	// Checks are executed after all cascades have been executed. They don't
	// return results but can generate errors (e.g. foreign key check failures).
	//
	// RootRowCount is the number of rows returned by the root node, negative if
	// the stats weren't available to make a good estimate.
	ConstructPlan(
		root Node,
		subqueries []Subquery,
		cascades, triggers []PostQuery,
		checks []Node,
		rootRowCount int64,
		flags PlanFlags,
	) (Plan, error)

	// Ctx returns the ctx of this execution.
	Ctx() context.Context

	// ConstructScan creates a node for a Scan operation.
	//
	// Scan runs a scan of a specified index of a table, possibly with an index
	// constraint and/or a hard limit.
	ConstructScan(
		table cat.Table,
		// index is a field that has a comment.
		index cat.Index,
		params ScanParams,
		reqOrdering OutputOrdering,
	) (Node, error)

	// ConstructValues creates a node for a Values operation.
	ConstructValues(
		rows [][]tree.TypedExpr,
		// columns is a field that has a multi-line
		// comment.
		columns colinfo.ResultColumns,
	) (Node, error)
}

// StubFactory is a do-nothing implementation of Factory, used for testing.
type StubFactory struct{}

var _ Factory = StubFactory{}

func (StubFactory) ConstructPlan(
	root Node,
	subqueries []Subquery,
	cascades, triggers []PostQuery,
	checks []Node,
	rootRowCount int64,
	flags PlanFlags,
) (Plan, error) {
	return struct{}{}, nil
}

func (StubFactory) Ctx() context.Context {
	return context.Background()
}

func (StubFactory) ConstructScan(
	table cat.Table,
	index cat.Index,
	params ScanParams,
	reqOrdering OutputOrdering,
) (Node, error) {
	return struct{}{}, nil
}

func (StubFactory) ConstructValues(
	rows [][]tree.TypedExpr,
	columns colinfo.ResultColumns,
) (Node, error) {
	return struct{}{}, nil
}
----
----
