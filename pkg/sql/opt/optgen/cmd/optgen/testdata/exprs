#
# Generate code for relational, scalar, enforcer, and private operators.
#
optgen exprs test.opt
[Relational]
define Project {
    Input       RelExpr
    Projections ProjectionsExpr

    Passthrough ColSet
}

[Scalar, List]
define Projections {
}

[Scalar, ListItem]
define ProjectionsItem {
    Element ScalarExpr

    _ ColPrivate
}

[Private]
define ColPrivate {
    Col    ColumnID
    scalar ScalarProps
}

[Enforcer]
define Sort {
}
----
----
// Code generated by optgen; [omitted]

package memo

import (
	"fmt"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/sql/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
)

type ProjectExpr struct {
	Input       RelExpr
	Projections ProjectionsExpr
	Passthrough opt.ColSet

	grp  exprGroup
	next RelExpr
}

var _ RelExpr = &ProjectExpr{}

func (e *ProjectExpr) Op() opt.Operator {
	return opt.ProjectOp
}

func (e *ProjectExpr) ChildCount() int {
	return 2
}

func (e *ProjectExpr) Child(nth int) opt.Expr {
	switch nth {
	case 0:
		return e.Input
	case 1:
		return &e.Projections
	}
	panic("child index out of range")
}

func (e *ProjectExpr) Private() interface{} {
	return &e.Passthrough
}

func (e *ProjectExpr) String() string {
	f := MakeExprFmtCtx(ExprFmtHideQualifications, e.Memo())
	f.FormatExpr(e)
	return f.Buffer.String()
}

func (e *ProjectExpr) SetChild(nth int, child opt.Expr) {
	switch nth {
	case 0:
		e.Input = child.(RelExpr)
		return
	case 1:
		e.Projections = *child.(*ProjectionsExpr)
		return
	}
	panic("child index out of range")
}

func (e *ProjectExpr) Memo() *Memo {
	return e.grp.memo()
}

func (e *ProjectExpr) Relational() *props.Relational {
	return e.grp.relational()
}

func (e *ProjectExpr) FirstExpr() RelExpr {
	return e.grp.firstExpr()
}

func (e *ProjectExpr) NextExpr() RelExpr {
	return e.next
}

func (e *ProjectExpr) Physical() *props.Physical {
	return e.grp.physical()
}

func (e *ProjectExpr) Cost() Cost {
	return e.grp.cost()
}

func (e *ProjectExpr) group() exprGroup {
	return e.grp
}

func (e *ProjectExpr) setNext(member RelExpr) {
	if e.next != nil {
		panic(fmt.Sprintf("expression already has its next defined: %s", e))
	}
	e.next = member
}

func (e *ProjectExpr) setGroup(member RelExpr) {
	if e.grp != nil {
		panic(fmt.Sprintf("expression is already in a group: %s", e))
	}
	e.grp = member.group()
	LastGroupMember(member).setNext(e)
}

type projectGroup struct {
	mem   *Memo
	rel   props.Relational
	phys  *props.Physical
	cst   Cost
	first ProjectExpr
}

var _ exprGroup = &projectGroup{}

func (g *projectGroup) memo() *Memo {
	return g.mem
}

func (g *projectGroup) relational() *props.Relational {
	return &g.rel
}

func (g *projectGroup) physical() *props.Physical {
	return g.phys
}

func (g *projectGroup) firstExpr() RelExpr {
	return &g.first
}

func (g *projectGroup) cost() Cost {
	return g.cst
}

func (g *projectGroup) setBestProps(physical *props.Physical, cost Cost) {
	g.phys = physical
	g.cst = cost
}

type ProjectionsExpr []ProjectionsItem

var EmptyProjectionsExpr = ProjectionsExpr{}

var _ opt.ScalarExpr = &ProjectionsExpr{}

func (e *ProjectionsExpr) Op() opt.Operator {
	return opt.ProjectionsOp
}

func (e *ProjectionsExpr) ChildCount() int {
	return len(*e)
}

func (e *ProjectionsExpr) Child(nth int) opt.Expr {
	return &(*e)[nth]
}

func (e *ProjectionsExpr) Private() interface{} {
	return nil
}

func (e *ProjectionsExpr) String() string {
	f := MakeExprFmtCtx(ExprFmtHideQualifications, nil)
	f.FormatExpr(e)
	return f.Buffer.String()
}

func (e *ProjectionsExpr) SetChild(nth int, child opt.Expr) {
	(*e)[nth] = *child.(*ProjectionsItem)
}

func (e *ProjectionsExpr) DataType() types.T {
	return types.Any
}

type ProjectionsItem struct {
	Element opt.ScalarExpr
	ColPrivate

	Typ types.T
}

var _ opt.ScalarExpr = &ProjectionsItem{}

func (e *ProjectionsItem) Op() opt.Operator {
	return opt.ProjectionsItemOp
}

func (e *ProjectionsItem) ChildCount() int {
	return 1
}

func (e *ProjectionsItem) Child(nth int) opt.Expr {
	switch nth {
	case 0:
		return e.Element
	}
	panic("child index out of range")
}

func (e *ProjectionsItem) Private() interface{} {
	return &e.ColPrivate
}

func (e *ProjectionsItem) String() string {
	f := MakeExprFmtCtx(ExprFmtHideQualifications, nil)
	f.FormatExpr(e)
	return f.Buffer.String()
}

func (e *ProjectionsItem) SetChild(nth int, child opt.Expr) {
	switch nth {
	case 0:
		e.Element = child.(opt.ScalarExpr)
		return
	}
	panic("child index out of range")
}

func (e *ProjectionsItem) DataType() types.T {
	return e.Typ
}

func (e *ProjectionsItem) ScalarProps(mem *Memo) *props.Scalar {
	if !e.scalar.Populated {
		mem.logPropsBuilder.buildProjectionsItemProps(e, &e.scalar)
	}
	return &e.scalar
}

type ColPrivate struct {
	Col    opt.ColumnID
	scalar props.Scalar
}

type SortExpr struct {
	Input RelExpr
	phys  *props.Physical
	cst   Cost
}

func (e *SortExpr) Op() opt.Operator {
	return opt.SortOp
}

func (e *SortExpr) ChildCount() int {
	return 1
}

func (e *SortExpr) Child(nth int) opt.Expr {
	if nth == 0 {
		return e.Input
	}
	panic("child index out of range")
}

func (e *SortExpr) Private() interface{} {
	return nil
}

func (e *SortExpr) String() string {
	f := MakeExprFmtCtx(ExprFmtHideQualifications, e.Memo())
	f.FormatExpr(e)
	return f.Buffer.String()
}

func (e *SortExpr) SetChild(nth int, child opt.Expr) {
	if nth == 0 {
		e.Input = child.(RelExpr)
		return
	}
	panic("child index out of range")
}

func (e *SortExpr) Memo() *Memo {
	return e.Input.Memo()
}

func (e *SortExpr) Relational() *props.Relational {
	return e.Input.Relational()
}

func (e *SortExpr) FirstExpr() RelExpr {
	return e.Input.FirstExpr()
}

func (e *SortExpr) NextExpr() RelExpr {
	return nil
}

func (e *SortExpr) Physical() *props.Physical {
	return e.phys
}

func (e *SortExpr) Cost() Cost {
	return e.cst
}

func (e *SortExpr) group() exprGroup {
	return e.Input.group()
}

func (e *SortExpr) setNext(member RelExpr) {
	panic("setNext cannot be called on enforcers")
}

func (e *SortExpr) setGroup(member exprGroup) {
	panic("setGroup cannot be called on enforcers")
}

func (m *Memo) MemoizeProject(
	input RelExpr,
	projections ProjectionsExpr,
	passthrough opt.ColSet,
) *ProjectExpr {
	const size = int64(unsafe.Sizeof(projectGroup{}))
	grp := &projectGroup{mem: m, first: ProjectExpr{
		Input:       input,
		Projections: projections,
		Passthrough: passthrough,
	}}
	e := &grp.first
	e.grp = grp
	interned := m.interner.InternProject(e)
	if interned == e {
		m.logPropsBuilder.buildProjectProps(e, &grp.rel)
		m.memEstimate += size
		m.checkExpr(e)
	}
	return interned
}

func (m *Memo) AddProjectToGroup(e *ProjectExpr, grp RelExpr) *ProjectExpr {
	const size = int64(unsafe.Sizeof(ProjectExpr{}))
	interned := m.interner.InternProject(e)
	if interned == e {
		e.setGroup(grp)
		m.memEstimate += size
		m.checkExpr(e)
	} else if interned.group() != grp.group() {
		panic(fmt.Sprintf("%s expression cannot be added to multiple groups: %s", e.Op(), e))
	}
	return interned
}

func (in *interner) InternExpr(e opt.Expr) opt.Expr {
	switch t := e.(type) {
	case *ProjectExpr:
		return in.InternProject(t)
	case *ProjectionsExpr:
		return in.InternProjections(t)
	case *ProjectionsItem:
		return in.InternProjectionsItem(t)
	default:
		panic(fmt.Sprintf("unhandled op: %s", e.Op()))
	}
}

func (in *interner) InternProject(val *ProjectExpr) *ProjectExpr {
	in.hasher.Init()
	in.hasher.HashOperator(opt.ProjectOp)
	in.hasher.HashRelExpr(val.Input)
	in.hasher.HashProjectionsExpr(val.Projections)
	in.hasher.HashColSet(val.Passthrough)

	in.cache.Start(in.hasher.hash)
	for in.cache.Next() {
		if existing, ok := in.cache.Item().(*ProjectExpr); ok {
			if in.hasher.IsRelExprEqual(val.Input, existing.Input) &&
				in.hasher.IsProjectionsExprEqual(val.Projections, existing.Projections) &&
				in.hasher.IsColSetEqual(val.Passthrough, existing.Passthrough) {
				return existing
			}
		}
	}

	in.cache.Add(val)
	return val
}

func (in *interner) InternProjections(val *ProjectionsExpr) *ProjectionsExpr {
	in.hasher.Init()
	in.hasher.HashOperator(opt.ProjectionsOp)
	in.hasher.HashProjectionsExpr(*val)

	in.cache.Start(in.hasher.hash)
	for in.cache.Next() {
		if existing, ok := in.cache.Item().(*ProjectionsExpr); ok {
			if in.hasher.IsProjectionsExprEqual(*val, *existing) {
				return existing
			}
		}
	}

	in.cache.Add(val)
	return val
}

func (in *interner) InternProjectionsItem(val *ProjectionsItem) *ProjectionsItem {
	in.hasher.Init()
	in.hasher.HashOperator(opt.ProjectionsItemOp)
	in.hasher.HashScalarExpr(val.Element)
	in.hasher.HashColumnID(val.Col)

	in.cache.Start(in.hasher.hash)
	for in.cache.Next() {
		if existing, ok := in.cache.Item().(*ProjectionsItem); ok {
			if in.hasher.IsScalarExprEqual(val.Element, existing.Element) &&
				in.hasher.IsColumnIDEqual(val.Col, existing.Col) {
				return existing
			}
		}
	}

	in.cache.Add(val)
	return val
}

func (b *logicalPropsBuilder) buildProps(e RelExpr, rel *props.Relational) {
	switch t := e.(type) {
	case *ProjectExpr:
		b.buildProjectProps(t, rel)
	default:
		panic(fmt.Sprintf("unhandled type: %s", t.Op()))
	}
}
----
----
