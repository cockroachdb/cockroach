#
# Generate code for op that has Expr, ExprList, and private fields.
#
optgen exprs test.opt
define FuncCall {
    Name Expr
    Args ExprList
    Def  FuncDef
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ChildCount returns the number of expressions that are inputs to this
// parent expression.
func (ev ExprView) ChildCount() int {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.FuncCallOp:
		funcCallExpr := (*funcCallExpr)(ev.mem.lookupExpr(ev.loc))
		return 1 + int(funcCallExpr.args().Length)

	default:
		panic("invalid op")
	}

}

// ChildGroup returns the memo group containing the nth child of this parent
// expression.
func (ev ExprView) ChildGroup(n int) opt.GroupID {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.FuncCallOp:
		funcCallExpr := (*funcCallExpr)(ev.mem.lookupExpr(ev.loc))

		switch n {
		case 0:
			return funcCallExpr.name()
		default:
			list := ev.mem.lookupList(funcCallExpr.args())
			return list[n-1]
		}

	default:
		panic("invalid op")
	}

}

type privateLookupFunc func(ev ExprView) opt.PrivateID

var privateLookup = [...]privateLookupFunc{
	// UnknownOp
	func(ev ExprView) opt.PrivateID {
		panic("op type not initialized")
	},

	// FuncCallOp
	func(ev ExprView) opt.PrivateID {
		funcCallExpr := (*funcCallExpr)(ev.mem.lookupExpr(ev.loc))
		return funcCallExpr.def()
	},
}

type funcCallExpr memoExpr

func makeFuncCallExpr(name opt.GroupID, args opt.ListID, def opt.PrivateID) funcCallExpr {
	return funcCallExpr{op: opt.FuncCallOp, state: exprState{uint32(name), args.Offset, args.Length, uint32(def)}}
}

func (e *funcCallExpr) name() opt.GroupID {
	return opt.GroupID(e.state[0])
}

func (e *funcCallExpr) args() opt.ListID {
	return opt.ListID{Offset: e.state[1], Length: e.state[2]}
}

func (e *funcCallExpr) def() opt.PrivateID {
	return opt.PrivateID(e.state[3])
}

func (e *funcCallExpr) fingerprint() fingerprint {
	return fingerprint(*e)
}

func (m *memoExpr) asFuncCall() *funcCallExpr {
	if m.op != opt.FuncCallOp {
		return nil
	}
	return (*funcCallExpr)(m)
}
----
----

#
# Generate code for enforcer op.
#
optgen exprs test.opt
[Enforcer]
define Sort {
    Input Expr
}
----
----
// Code generated by optgen; [omitted]

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
)

// ChildCount returns the number of expressions that are inputs to this
// parent expression.
func (ev ExprView) ChildCount() int {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.SortOp:
		return 1

	default:
		panic("invalid op")
	}

}

// ChildGroup returns the memo group containing the nth child of this parent
// expression.
func (ev ExprView) ChildGroup(n int) opt.GroupID {
	switch ev.op {
	case opt.UnknownOp:
		panic("opt type not initialized")

	case opt.SortOp:
		if n == 0 {
			return ev.loc.group
		}

		panic("child index out of range")

	default:
		panic("invalid op")
	}

}

type privateLookupFunc func(ev ExprView) opt.PrivateID

var privateLookup = [...]privateLookupFunc{
	// UnknownOp
	func(ev ExprView) opt.PrivateID {
		panic("op type not initialized")
	},

	// SortOp
	func(ev ExprView) opt.PrivateID {
		return 0
	},
}

var isEnforcerLookup = [...]bool{
	false, // UnknownOp

	true, // SortOp
}

func (ev ExprView) IsEnforcer() bool {
	return isEnforcerLookup[ev.op]
}

func (me *memoExpr) isEnforcer() bool {
	return isEnforcerLookup[me.op]
}
----
----
