optgen execplangist test.opt
# Scan returns a node that represents a scan of the given index on
# the given table.
define Scan {
    Table cat.Table
    Index cat.Index
    Params exec.ScanParams
    ReqOrdering exec.OutputOrdering
}

define Filter {
    Input exec.Node
    Filter tree.TypedExpr
    ReqOrdering exec.OutputOrdering
}

define HashJoin {
    JoinType descpb.JoinType
    Left exec.Node
    Right exec.Node
    LeftEqCols []exec.NodeColumnOrdinal
    RightEqCols []exec.NodeColumnOrdinal
    LeftEqColsAreKey bool
    RightEqColsAreKey bool
    ExtraOnCond tree.TypedExpr
}
----
----
// Code generated by optgen; [omitted]

package explain

import (
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/colinfo"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	"github.com/cockroachdb/cockroach/pkg/sql/inverted"
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/cat"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/exec"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

func (f *PlanGistFactory) ConstructScan(
	table cat.Table,
	index cat.Index,
	params exec.ScanParams,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	f.encodeOperator(scanOp)
	f.encodeDataSource(table.ID(), table.Name())
	f.encodeDataSource(index.ID(), index.Name())
	f.encodeScanParams(params)
	node, err := f.wrappedFactory.ConstructScan(
		table,
		index,
		params,
		reqOrdering,
	)
	return node, err
}

func (f *PlanGistFactory) ConstructFilter(
	input exec.Node,
	filter tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	f.encodeOperator(filterOp)
	node, err := f.wrappedFactory.ConstructFilter(
		input,
		filter,
		reqOrdering,
	)
	return node, err
}

func (f *PlanGistFactory) ConstructHashJoin(
	joinType descpb.JoinType,
	left exec.Node,
	right exec.Node,
	leftEqCols []exec.NodeColumnOrdinal,
	rightEqCols []exec.NodeColumnOrdinal,
	leftEqColsAreKey bool,
	rightEqColsAreKey bool,
	extraOnCond tree.TypedExpr,
) (exec.Node, error) {
	f.encodeOperator(hashJoinOp)
	f.encodeByte(byte(joinType))
	f.encodeNodeColumnOrdinals(leftEqCols)
	f.encodeNodeColumnOrdinals(rightEqCols)
	f.encodeBool(leftEqColsAreKey)
	f.encodeBool(rightEqColsAreKey)
	node, err := f.wrappedFactory.ConstructHashJoin(
		joinType,
		left,
		right,
		leftEqCols,
		rightEqCols,
		leftEqColsAreKey,
		rightEqColsAreKey,
		extraOnCond,
	)
	return node, err
}

func (d *planGistDecoder) decodeOperatorBody(op execOperator) (*Node, error) {
	var _n *Node
	var reqOrdering exec.OutputOrdering
	var err error
	var tbl cat.Table
	switch op {
	case scanOp:
		var args scanArgs
		args.Table = d.decodeTable()
		tbl = args.Table
		args.Index = d.decodeIndex(tbl)
		args.Params = d.decodeScanParams()
		_n, err = newNode(op, &args, reqOrdering)
	case filterOp:
		var args filterArgs
		args.Input = d.popChild()
		_n, err = newNode(op, &args, reqOrdering, args.Input)
	case hashJoinOp:
		var args hashJoinArgs
		args.JoinType = d.decodeJoinType()
		args.LeftEqCols = d.decodeNodeColumnOrdinals()
		args.RightEqCols = d.decodeNodeColumnOrdinals()
		args.LeftEqColsAreKey = d.decodeBool()
		args.RightEqColsAreKey = d.decodeBool()
		args.Right = d.popChild()
		args.Left = d.popChild()
		_n, err = newNode(op, &args, reqOrdering, args.Left, args.Right)
	default:
		return nil, errors.Newf("invalid op: %d", op)
	}
	return _n, err
}
----
----
