# LogicTest: opt

# ------------------------------------------------------------------------------
# Basic filter combinations.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE a (x INT PRIMARY KEY, y INT);

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1
----
scan  ·      ·          (x, y)  ·
·     table  a@primary  ·       ·
·     spans  /2-        ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM a WHERE y > 10
----
scan  ·       ·          (x, y)  ·
·     table   a@primary  ·       ·
·     spans   ALL        ·       ·
·     filter  y > 10     ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1 AND x < 3
----
scan  ·      ·          (x, y)  ·
·     table  a@primary  ·       ·
·     spans  /2-/2/#    ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1 AND y < 30
----
scan  ·       ·          (x, y)  ·
·     table   a@primary  ·       ·
·     spans   /2-        ·       ·
·     filter  y < 30     ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x + 1 FROM a
----
render     ·         ·          ("x + 1")  ·
 │         render 0  x + 1      ·          ·
 └── scan  ·         ·          (x)        ·
·          table     a@primary  ·          ·
·          spans     ALL        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x, x + 1, y, y + 1, x + y FROM a
----
render     ·         ·          (x, "x + 1", y, "y + 1", "x + y")  ·
 │         render 0  x          ·                                  ·
 │         render 1  x + 1      ·                                  ·
 │         render 2  y          ·                                  ·
 │         render 3  y + 1      ·                                  ·
 │         render 4  x + y      ·                                  ·
 └── scan  ·         ·          (x, y)                             ·
·          table     a@primary  ·                                  ·
·          spans     ALL        ·                                  ·

query TTTTT
EXPLAIN (VERBOSE) SELECT u * v + v FROM (SELECT x + 3, y + 10 FROM a) AS foo(u, v)
----
render          ·         ·                                ("(u * v) + v")      ·
 │              render 0  "y + 10" + ("x + 3" * "y + 10")  ·                    ·
 └── render     ·         ·                                ("x + 3", "y + 10")  ·
      │         render 0  x + 3                            ·                    ·
      │         render 1  y + 10                           ·                    ·
      └── scan  ·         ·                                (x, y)               ·
·               table     a@primary                        ·                    ·
·               spans     ALL                              ·                    ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x, x, y, x FROM a
----
render     ·         ·          (x, x, y, x)  ·
 │         render 0  x          ·             ·
 │         render 1  x          ·             ·
 │         render 2  y          ·             ·
 │         render 3  x          ·             ·
 └── scan  ·         ·          (x, y)        ·
·          table     a@primary  ·             ·
·          spans     ALL        ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x + 1, x + y FROM a WHERE x + y > 20
----
render     ·         ·             ("x + 1", "x + y")  ·
 │         render 0  x + 1         ·                   ·
 │         render 1  x + y         ·                   ·
 └── scan  ·         ·             (x, y)              ·
·          table     a@primary     ·                   ·
·          spans     ALL           ·                   ·
·          filter    (x + y) > 20  ·                   ·

# ------------------------------------------------------------------------------
# Test with a hidden column.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE b (x INT, y INT);

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM b
----
scan  ·      ·          (x, y)  ·
·     table  b@primary  ·       ·
·     spans  ALL        ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x, y, rowid FROM b WHERE rowid > 0
----
scan  ·      ·          (x, y, rowid[hidden])  ·
·     table  b@primary  ·                      ·
·     spans  /1-        ·                      ·

# ------------------------------------------------------------------------------
# String inequality filter.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE c (n INT PRIMARY KEY, str STRING, INDEX str(str DESC));

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM c WHERE str >= 'moo'
----
scan  ·      ·                  (n, str)  ·
·     table  c@str              ·         ·
·     spans  -/"moo"/PrefixEnd  ·         ·

# ------------------------------------------------------------------------------
# "*" must expand to zero columns if there are zero columns to select.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE nocols(x INT); ALTER TABLE nocols DROP COLUMN x

query TTTTT
EXPLAIN (VERBOSE) SELECT 1, * FROM nocols
----
render     ·         ·               ("1")  ·
 │         render 0  1               ·      ·
 └── scan  ·         ·               ()     ·
·          table     nocols@primary  ·      ·
·          spans     ALL             ·      ·

# ------------------------------------------------------------------------------
# Ensure that index is used when indexed column has collation.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE coll (
  a STRING COLLATE da,
  b INT,
  c BOOL,
  PRIMARY KEY (a, b),
  INDEX (b, a) STORING (c)
)

query TTTTT
EXPLAIN (TYPES) SELECT a, b FROM coll ORDER BY a, b
----
scan  ·      ·             (a collatedstring{da}, b int)  +a,+b
·     table  coll@primary  ·                              ·
·     spans  ALL           ·                              ·

query TTTTT
EXPLAIN (TYPES) SELECT b, a FROM coll ORDER BY b, a
----
render     ·         ·                        (b int, a collatedstring{da})  ·
 │         render 0  (b)[int]                 ·                              ·
 │         render 1  (a)[collatedstring{da}]  ·                              ·
 └── scan  ·         ·                        (a collatedstring{da}, b int)  +b,+a
·          table     coll@coll_b_a_idx        ·                              ·
·          spans     ALL                      ·                              ·

# ------------------------------------------------------------------------------
# Ensure correct index is used when indexed column is computed.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE computed (
  k INT PRIMARY KEY,
  a JSON,
  b TEXT AS (a->>'q') STORED,
  INDEX (b) STORING (k)
)

query TTTTT
EXPLAIN (TYPES) SELECT b FROM computed ORDER BY b
----
scan  ·      ·                        (b string)  +b
·     table  computed@computed_b_idx  ·           ·
·     spans  ALL                      ·           ·

# ------------------------------------------------------------------------------
# Ensure that Select filter probes expected date/time key/values that are in
# different column families.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dt (
  a TIMESTAMP PRIMARY KEY,
  b DATE,
  c INTERVAL,
  UNIQUE (b),
  UNIQUE (c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c)
)

statement ok
INSERT INTO dt VALUES
  ('2015-08-30 03:34:45.34567', '2015-08-30', '34h2s'),
  ('2015-08-25 04:45:45.53453', '2015-08-25', '2h45m2s234ms'),
  ('2015-08-29 23:10:09.98763', '2015-08-29', '234h45m2s234ms')

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT * FROM dt WHERE a = '2015-08-25 06:45:45.53453+02:00'::timestamp]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /dt/primary/'2015-08-25 04:45:45.53453+00:00' -> NULL
fetched: /dt/primary/'2015-08-25 04:45:45.53453+00:00'/b -> '2015-08-25'
fetched: /dt/primary/'2015-08-25 04:45:45.53453+00:00'/c -> '2h45m2s234ms'
output row: ['2015-08-25 04:45:45.53453+00:00' '2015-08-25' '2h45m2s234ms']

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT b FROM dt WHERE b < '2015-08-29'::date]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /dt/dt_b_key/'2015-08-25' -> /'2015-08-25 04:45:45.53453+00:00'
output row: ['2015-08-25']

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT c FROM dt WHERE c < '234h45m2s234ms'::interval]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /dt/dt_c_key/'2h45m2s234ms' -> /'2015-08-25 04:45:45.53453+00:00'
output row: ['2h45m2s234ms']
fetched: /dt/dt_c_key/'34h2s' -> /'2015-08-30 03:34:45.34567+00:00'
output row: ['34h2s']

# ------------------------------------------------------------------------------
# Ensure that special decimal values result in correct scan spans.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dec (d decimal, v decimal(3, 1), primary key (d, v))

query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec WHERE d IS NaN and v IS NaN
----
scan  ·      ·                    (d decimal, v decimal)  ·
·     table  dec@primary          ·                       ·
·     spans  /NaN/NaN-/NaN/NaN/#  ·                       ·

# The NaN suffix is decimalNaNDesc, not decimalNaN(Asc).
query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec WHERE d = 'Infinity' and v = 'Infinity'
----
scan  ·      ·                                        (d decimal, v decimal)  ·
·     table  dec@primary                              ·                       ·
·     spans  /Infinity/Infinity-/Infinity/Infinity/#  ·                       ·

query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec WHERE d = '-Infinity' and v = '-Infinity'
----
scan  ·      ·                                            (d decimal, v decimal)  ·
·     table  dec@primary                                  ·                       ·
·     spans  /-Infinity/-Infinity-/-Infinity/-Infinity/#  ·                       ·

# ------------------------------------------------------------------------------
# Verify that lookups for Decimal NaN use indices when possible:
# - `WHERE d IS NaN` should perform a point lookup.
# - `WHERE d = 'NaN'` should also perform a point lookup.
# - `WHERE isnan(d)` is a function so it can't perform a point lookup.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dec2 (d decimal null, index (d))

query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE d IS NaN
----
scan  ·      ·                (d decimal)  ·
·     table  dec2@dec2_d_idx  ·            ·
·     spans  /NaN-/-Infinity  ·            ·

query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE d = 'NaN'
----
scan  ·      ·                (d decimal)  ·
·     table  dec2@dec2_d_idx  ·            ·
·     spans  /NaN-/-Infinity  ·            ·

query TTTTT
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE isnan(d)
----
scan  ·       ·                            (d decimal)  ·
·     table   dec2@primary                 ·            ·
·     spans   ALL                          ·            ·
·     filter  (isnan((d)[decimal]))[bool]  ·            ·

# ------------------------------------------------------------------------------
# Verify that lookups for Float NaN use indices when possible:
# - `WHERE f IS NaN` should perform a point lookup.
# - `WHERE f = 'NaN'` should also perform a point lookup.
# - `WHERE isnan(f)` is a function so it can't perform a point lookup.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE flt (f float null, unique index (f))

query TTTTT
EXPLAIN (TYPES) SELECT * FROM flt WHERE f IS NaN
----
scan  ·      ·                    (f float)  ·
·     table  flt@flt_f_key        ·          ·
·     spans  /NaN-/NaN/PrefixEnd  ·          ·

query TTTTT
EXPLAIN (TYPES) SELECT * FROM flt WHERE f = 'NaN'
----
scan  ·      ·                    (f float)  ·
·     table  flt@flt_f_key        ·          ·
·     spans  /NaN-/NaN/PrefixEnd  ·          ·

query TTTTT
EXPLAIN (TYPES) SELECT * FROM flt WHERE isnan(f)
----
scan  ·       ·                          (f float)  ·
·     table   flt@primary                ·          ·
·     spans   ALL                        ·          ·
·     filter  (isnan((f)[float]))[bool]  ·          ·

# ------------------------------------------------------------------------------
# ANY, ALL tests.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE abc (a INT, b INT, C INT)

statement ok
INSERT INTO abc VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)

query III
SELECT * FROM abc WHERE a = ANY(SELECT a FROM abc WHERE b = 10)
----
1 10 100

query III
SELECT * FROM abc WHERE a < ANY(SELECT a FROM abc WHERE b = 30) ORDER BY a
----
1 10 100
2 20 200

query III
SELECT * FROM abc WHERE a > ANY(SELECT a FROM abc WHERE b = 30)
----

query III
SELECT * FROM abc WHERE a < ALL(SELECT b FROM abc) ORDER BY a
----
1 10 100
2 20 200
3 30 300

query III
SELECT * FROM abc WHERE a < ALL(SELECT a FROM abc WHERE a >= 2)
----
1 10 100

query III
SELECT * FROM abc WHERE a < ALL(SELECT a FROM abc)
----

# ------------------------------------------------------------------------------
# IN tests.
# ------------------------------------------------------------------------------
# Regression tests for #22670.
query B
SELECT 1 IN (1, 2)
----
true

query B
SELECT NULL IN (1, 2)
----
NULL

query B
SELECT 1 IN (1, NULL)
----
true

query B
SELECT 1 IN (NULL, 2)
----
NULL

query B
SELECT (1, NULL) IN ((1, 1))
----
NULL

query B
SELECT (2, NULL) IN ((1, 1))
----
false

query B
SELECT (1, 1) IN ((1, NULL))
----
NULL

query B
SELECT (1, 1) IN ((2, NULL))
----
false

# Tests with a tuple coming from a subquery.
query B
SELECT NULL::int IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

query B
SELECT (1, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (2, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL::int, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL::int, 2) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL::int, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT NULL::int NOT IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

query B
SELECT (1, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (2, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL::int, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL::int, 2) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL::int, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

# Tests with an empty IN tuple.
query B
SELECT NULL::int IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
false

query B
SELECT (1, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL::int, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL::int, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT NULL::int NOT IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
true

query B
SELECT (1, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL::int, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL::int, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true
