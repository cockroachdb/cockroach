# LogicTest: local

# Prepare a trace to be inspected below.

# TODO(yuzefovich): clean up the tracing in the vectorized engine and remove
# adjustment of vectorize mode (#55821).
statement ok
SET vectorize=off; SET tracing = on; BEGIN; SELECT 1; COMMIT; SELECT 2; SET tracing = off; RESET vectorize

# Inspect the trace: we exclude messages containing newlines as these
# may contain non-deterministic txn object descriptions.
# This also checks that the span column properly reports separate
# SQL transactions.
# We replace the command position because the values depend on exactly
# how many commands we ran in the session.
query ITT
SELECT
  span, regexp_replace(message, 'pos:[0-9]*', 'pos:?'), operation
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%SPAN START%' OR message LIKE '%pos%executing%';
----
0   === SPAN START: session recording ===                session recording
1   === SPAN START: exec stmt ===                        exec stmt
1   [NoTxn pos:?] executing ExecStmt: BEGIN TRANSACTION  exec stmt
2   === SPAN START: sql txn ===                          sql txn
3   === SPAN START: exec stmt ===                        exec stmt
3   [Open pos:?] executing ExecStmt: SELECT 1            exec stmt
4   === SPAN START: consuming rows ===                   consuming rows
5   === SPAN START: flow ===                             flow
6   === SPAN START: exec stmt ===                        exec stmt
6   [Open pos:?] executing ExecStmt: COMMIT TRANSACTION  exec stmt
7   === SPAN START: exec stmt ===                        exec stmt
7   [NoTxn pos:?] executing ExecStmt: SELECT 2           exec stmt
8   === SPAN START: sql txn ===                          sql txn
9   === SPAN START: exec stmt ===                        exec stmt
9   [Open pos:?] executing ExecStmt: SELECT 2            exec stmt
10  === SPAN START: consuming rows ===                   consuming rows
11  === SPAN START: flow ===                             flow
12  === SPAN START: exec stmt ===                        exec stmt
12  [NoTxn pos:?] executing ExecStmt: SET TRACING = off  exec stmt

# ------------------------------------------------------------------------------
# Numeric References Tests.
# These are put at the beginning of the file to ensure the numeric table
# reference is 53 (the numeric reference of the first table).
# If the numbering scheme in cockroach changes, this test will break.
# These tests replicate the tests at sql/table_ref_test.go. The reason
# for duplication is to include tests within the opt testing framework
# TODO(madhavsuresh): get the numeric reference ID in a less brittle fashion
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE num_ref (a INT PRIMARY KEY, xx INT, b INT, c INT, INDEX bc (b,c))

statement ok
CREATE TABLE num_ref_hidden (a INT, b INT)

statement ok
ALTER TABLE num_ref RENAME COLUMN b TO d

statement ok
ALTER TABLE num_ref RENAME COLUMN a TO p

statement ok
ALTER TABLE num_ref DROP COLUMN xx

query T
EXPLAIN (VERBOSE) SELECT * FROM [53 AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (p, d, c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(1,4) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (p, c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(1,3,4) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (p, d, c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4,3,1) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (c, d, p)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4,3,1) AS num_ref_alias(col1,col2,col3)]
----
distribution: local
vectorized: true
·
• scan
  columns: (col1, col2, col3)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4,3,1) AS num_ref_alias]@bc
----
distribution: local
vectorized: true
·
• scan
  columns: (c, d, p)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4) AS num_ref_alias]@bc
----
distribution: local
vectorized: true
·
• scan
  columns: (c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(3) AS num_ref_alias]@bc
----
distribution: local
vectorized: true
·
• scan
  columns: (d)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(1) AS num_ref_alias]@bc
----
distribution: local
vectorized: true
·
• scan
  columns: (p)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(1) AS num_ref_alias]@[1]
----
distribution: local
vectorized: true
·
• scan
  columns: (p)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(1) AS num_ref_alias]@[2]
----
distribution: local
vectorized: true
·
• scan
  columns: (p)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(3) AS num_ref_alias]@[1]
----
distribution: local
vectorized: true
·
• scan
  columns: (d)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(3) AS num_ref_alias]@[2]
----
distribution: local
vectorized: true
·
• scan
  columns: (d)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4) AS num_ref_alias]@[1]
----
distribution: local
vectorized: true
·
• scan
  columns: (c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [53(4) AS num_ref_alias]@[2]
----
distribution: local
vectorized: true
·
• scan
  columns: (c)
  estimated row count: 1,000 (missing stats)
  table: num_ref@bc
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [54(1,3) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (a)
  estimated row count: 1,000 (missing stats)
  table: num_ref_hidden@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM [54(3) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: ()
  estimated row count: 1,000 (missing stats)
  table: num_ref_hidden@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT rowid FROM [54(3) AS num_ref_alias]
----
distribution: local
vectorized: true
·
• scan
  columns: (rowid)
  estimated row count: 1,000 (missing stats)
  table: num_ref_hidden@primary
  spans: FULL SCAN

query error pq: \[666\(1\) AS num_ref_alias\]: relation \"\[666\]\" does not exist
EXPLAIN (VERBOSE) SELECT * FROM [666(1) AS num_ref_alias]

query error pq: column \[666\] does not exist
EXPLAIN (VERBOSE) SELECT * FROM [53(666) AS num_ref_alias]

query error pq: column \[2\] does not exist
EXPLAIN (VERBOSE) SELECT * FROM [53(2) AS num_ref_alias]

query error pq: an explicit list of column IDs must include at least one column
EXPLAIN (VERBOSE) SELECT * FROM [53() AS num_ref_alias]

query error pq: an explicit list of column IDs must include at least one column
EXPLAIN (VERBOSE) SELECT 1 FROM [53() as num_ref_alias]

statement ok
DROP TABLE num_ref

query error pq: \[53\(1\) AS num_ref_alias\]: descriptor is being dropped
EXPLAIN (VERBOSE) SELECT * FROM [53(1) AS num_ref_alias]

# ------------------------------------------------------------------------------
# Basic filter combinations.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE a (x INT PRIMARY KEY, y INT, FAMILY (x, y));

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1
----
distribution: local
vectorized: true
·
• scan
  columns: (x, y)
  estimated row count: 333 (missing stats)
  table: a@primary
  spans: /2-

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE y > 10
----
distribution: local
vectorized: true
·
• filter
│ columns: (x, y)
│ estimated row count: 333 (missing stats)
│ filter: y > 10
│
└── • scan
      columns: (x, y)
      estimated row count: 1,000 (missing stats)
      table: a@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1 AND x < 3
----
distribution: local
vectorized: true
·
• scan
  columns: (x, y)
  estimated row count: 1 (missing stats)
  table: a@primary
  spans: /2/0

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE x > 1 AND y < 30
----
distribution: local
vectorized: true
·
• filter
│ columns: (x, y)
│ estimated row count: 311 (missing stats)
│ filter: y < 30
│
└── • scan
      columns: (x, y)
      estimated row count: 333 (missing stats)
      table: a@primary
      spans: /2-

query T
EXPLAIN (VERBOSE) SELECT x + 1 AS r FROM a
----
distribution: local
vectorized: true
·
• render
│ columns: (r)
│ estimated row count: 1,000 (missing stats)
│ render r: x + 1
│
└── • scan
      columns: (x)
      estimated row count: 1,000 (missing stats)
      table: a@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT x AS a, x + 1 AS b, y, y + 1 AS c, x + y AS d FROM a
----
distribution: local
vectorized: true
·
• render
│ columns: (a, b, y, c, d)
│ estimated row count: 1,000 (missing stats)
│ render b: x + 1
│ render c: y + 1
│ render d: x + y
│ render x: x
│ render y: y
│
└── • scan
      columns: (x, y)
      estimated row count: 1,000 (missing stats)
      table: a@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT u * v + v AS r FROM (SELECT x + 3, y + 10 FROM a) AS foo(u, v)
----
distribution: local
vectorized: true
·
• render
│ columns: (r)
│ estimated row count: 1,000 (missing stats)
│ render r: "?column?" + ("?column?" * "?column?")
│
└── • render
    │ columns: ("?column?", "?column?")
    │ estimated row count: 1,000 (missing stats)
    │ render ?column?: x + 3
    │ render ?column?: y + 10
    │
    └── • scan
          columns: (x, y)
          estimated row count: 1,000 (missing stats)
          table: a@primary
          spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT x, x, y, x FROM a
----
distribution: local
vectorized: true
·
• project
│ columns: (x, x, y, x)
│
└── • scan
      columns: (x, y)
      estimated row count: 1,000 (missing stats)
      table: a@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT x + 1 AS a, x + y AS b FROM a WHERE x + y > 20
----
distribution: local
vectorized: true
·
• render
│ columns: (a, b)
│ estimated row count: 333 (missing stats)
│ render a: x + 1
│ render b: x + y
│
└── • filter
    │ columns: (x, y)
    │ estimated row count: 333 (missing stats)
    │ filter: (x + y) > 20
    │
    └── • scan
          columns: (x, y)
          estimated row count: 1,000 (missing stats)
          table: a@primary
          spans: FULL SCAN

statement ok
DROP TABLE a

# ------------------------------------------------------------------------------
# Test with a hidden column.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE b (x INT, y INT);

query T
EXPLAIN (VERBOSE) SELECT * FROM b
----
distribution: local
vectorized: true
·
• scan
  columns: (x, y)
  estimated row count: 1,000 (missing stats)
  table: b@primary
  spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT x, y, rowid FROM b WHERE rowid > 0
----
distribution: local
vectorized: true
·
• scan
  columns: (x, y, rowid)
  estimated row count: 333 (missing stats)
  table: b@primary
  spans: /1-

statement ok
DROP TABLE b

# ------------------------------------------------------------------------------
# Test with storing columns.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT,
  INDEX b_idx (b) STORING (c, d),
  UNIQUE INDEX c_idx (c) STORING (b, d),
  FAMILY (a, b, c, d)
)

query TTBITTBB colnames
SHOW INDEXES FROM t
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
t           b_idx       true        1             b            ASC        false    false
t           b_idx       true        2             c            N/A        true     false
t           b_idx       true        3             d            N/A        true     false
t           b_idx       true        4             a            ASC        false    true
t           c_idx       false       1             c            ASC        false    false
t           c_idx       false       2             b            N/A        true     false
t           c_idx       false       3             d            N/A        true     false
t           c_idx       false       4             a            ASC        false    true
t           primary     false       1             a            ASC        false    false

statement ok
INSERT INTO t VALUES (1, 2, 3, 4)

statement ok
SET tracing = on,kv,results; SELECT * FROM t@b_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/b_idx/2/1/c/d -> /3/4
output row: [1 2 3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@c_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/c_idx/3/b/d -> /2/4
output row: [1 2 3 4]

# Test index backfill for UNIQUE and non-UNIQUE indexes with STORING columns.

statement ok
CREATE INDEX d_idx ON t (d) STORING (b)

statement ok
SET tracing = on,kv,results; SELECT a, b, d FROM t@d_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/d_idx/4/1/b -> /2
output row: [1 2 4]

statement ok
CREATE UNIQUE INDEX a_idx ON t (a) STORING (b)

statement ok
SET tracing = on,kv,results; SELECT a, b FROM t@a_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/a_idx/1/b -> /2
output row: [1 2]

# Test that unspecified storing values are treated like NULL values.
statement ok
INSERT INTO t (a) VALUES (2)

statement ok
INSERT INTO t VALUES (3)

statement ok
SET tracing = on,kv,results; SELECT * FROM t@b_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/b_idx/NULL/2 -> NULL
fetched: /t/b_idx/NULL/3 -> NULL
fetched: /t/b_idx/2/1/c/d -> /3/4
output row: [2 NULL NULL NULL]
output row: [3 NULL NULL NULL]
output row: [1 2 3 4]

# Regression test for #14601.

statement ok
CREATE TABLE t14601 (a STRING, b BOOL)

statement ok
CREATE INDEX i14601 ON t14601 (a) STORING (b)

query T
EXPLAIN SELECT a FROM t14601 ORDER BY a
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t14601@i14601
  spans: FULL SCAN

# Updates were broken too.

statement ok
CREATE TABLE t14601a (
  a STRING,
  b BOOL,
  c INT,
  FAMILY f1 (a),
  FAMILY f2 (b),
  FAMILY f3 (c)
)

statement ok
CREATE INDEX i14601a ON t14601a (a) STORING (b, c)

query T
EXPLAIN SELECT a, b FROM t14601a ORDER BY a
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t14601a@i14601a
  spans: FULL SCAN

statement ok
DROP index i14601a

statement ok
CREATE UNIQUE INDEX i14601a ON t14601a (a) STORING (b)

query T
EXPLAIN SELECT a, b FROM t14601a ORDER BY a
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t14601a@i14601a
  spans: FULL SCAN

statement ok
DROP TABLE t; DROP TABLE t14601; DROP TABLE t14601a

# ------------------------------------------------------------------------------
# String inequality filter.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE c (n INT PRIMARY KEY, str STRING, INDEX str(str DESC));

query T
EXPLAIN (VERBOSE) SELECT * FROM c WHERE str >= 'moo'
----
distribution: local
vectorized: true
·
• scan
  columns: (n, str)
  estimated row count: 333 (missing stats)
  table: c@str
  spans: -/"moo"/PrefixEnd

statement ok
DROP TABLE c

# ------------------------------------------------------------------------------
# "*" must expand to zero columns if there are zero columns to select.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE nocols(x INT); ALTER TABLE nocols DROP COLUMN x

query T
EXPLAIN (VERBOSE) SELECT 1 AS a, * FROM nocols
----
distribution: local
vectorized: true
·
• render
│ columns: (a)
│ estimated row count: 1,000 (missing stats)
│ render a: 1
│
└── • scan
      columns: ()
      estimated row count: 1,000 (missing stats)
      table: nocols@primary
      spans: FULL SCAN

statement ok
DROP TABLE nocols

# ------------------------------------------------------------------------------
# Ensure that index is used when indexed column has collation.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE coll (
  a STRING COLLATE da,
  b INT,
  c BOOL,
  PRIMARY KEY (a, b),
  INDEX (b, a) STORING (c)
)

query T
EXPLAIN (TYPES) SELECT a, b FROM coll ORDER BY a, b
----
distribution: local
vectorized: true
·
• scan
  columns: (a collatedstring{da}, b int)
  ordering: +a,+b
  estimated row count: 1,000 (missing stats)
  table: coll@primary
  spans: FULL SCAN

query T
EXPLAIN (TYPES) SELECT b, a FROM coll ORDER BY b, a
----
distribution: local
vectorized: true
·
• scan
  columns: (b int, a collatedstring{da})
  ordering: +b,+a
  estimated row count: 1,000 (missing stats)
  table: coll@coll_b_a_idx
  spans: FULL SCAN

statement ok
DROP TABLE coll

# ------------------------------------------------------------------------------
# Ensure correct index is used when indexed column is computed.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE computed (
  k INT PRIMARY KEY,
  a JSON,
  b TEXT AS (a->>'q') STORED,
  INDEX (b)
)

query T
EXPLAIN (TYPES) SELECT b FROM computed ORDER BY b
----
distribution: local
vectorized: true
·
• scan
  columns: (b string)
  ordering: +b
  estimated row count: 1,000 (missing stats)
  table: computed@computed_b_idx
  spans: FULL SCAN

statement ok
DROP TABLE computed

# ------------------------------------------------------------------------------
# Ensure that Select filter probes expected date/time key/values that are in
# different column families.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dt (
  a TIMESTAMP PRIMARY KEY,
  b DATE,
  c INTERVAL,
  UNIQUE (b),
  UNIQUE (c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c)
)

statement ok
INSERT INTO dt VALUES
  ('2015-08-30 03:34:45.34567', '2015-08-30', '34h2s'),
  ('2015-08-25 04:45:45.53453', '2015-08-25', '2h45m2s234ms'),
  ('2015-08-29 23:10:09.98763', '2015-08-29', '234h45m2s234ms')

statement ok
SET tracing = on,kv,results; SELECT * FROM dt WHERE a = '2015-08-25 04:45:45.53453+02:00'::timestamp; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /dt/primary/'2015-08-25 04:45:45.53453' -> NULL
fetched: /dt/primary/'2015-08-25 04:45:45.53453'/b -> '2015-08-25'
fetched: /dt/primary/'2015-08-25 04:45:45.53453'/c -> '02:45:02.234'
output row: ['2015-08-25 04:45:45.53453' '2015-08-25' '02:45:02.234']

statement ok
SET tracing = on,kv,results; SELECT b FROM dt WHERE b < '2015-08-29'::date; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /dt/dt_b_key/'2015-08-25' -> /'2015-08-25 04:45:45.53453'
output row: ['2015-08-25']

statement ok
SET tracing = on,kv,results; SELECT c FROM dt WHERE c < '234h45m2s234ms'::interval; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /dt/dt_c_key/'02:45:02.234' -> /'2015-08-25 04:45:45.53453'
fetched: /dt/dt_c_key/'34:00:02' -> /'2015-08-30 03:34:45.34567'
output row: ['02:45:02.234']
output row: ['34:00:02']

statement ok
DROP TABLE dt

# ------------------------------------------------------------------------------
# Ensure that decimal values result in correct scan spans.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dec (d decimal, v decimal(3, 1), primary key (d, v), family(d, v))

query T
EXPLAIN (TYPES) SELECT * FROM dec WHERE d IS NaN and v IS NaN
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal, v decimal)
  estimated row count: 1 (missing stats)
  table: dec@primary
  spans: /NaN/NaN/0

# Test again with separate column families.

statement ok
CREATE TABLE decfam (d decimal, v decimal(3, 1), primary key (d, v), family(d), family(v))

query T
EXPLAIN (TYPES) SELECT * FROM decfam WHERE d IS NaN and v IS NaN
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal, v decimal)
  estimated row count: 1 (missing stats)
  table: decfam@primary
  spans: /NaN/NaN-/NaN/NaN/#

# The NaN suffix is decimalNaNDesc, not decimalNaN(Asc).
query T
EXPLAIN (TYPES) SELECT * FROM dec WHERE d = 'Infinity' and v = 'Infinity'
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal, v decimal)
  estimated row count: 1 (missing stats)
  table: dec@primary
  spans: /Infinity/Infinity/0

query T
EXPLAIN (TYPES) SELECT * FROM dec WHERE d = '-Infinity' and v = '-Infinity'
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal, v decimal)
  estimated row count: 1 (missing stats)
  table: dec@primary
  spans: /-Infinity/-Infinity/0

statement ok
DROP TABLE dec

# Test composite encoding of DECIMAL type in indexes.
statement ok
CREATE TABLE c (
  a INT PRIMARY KEY,
  b DECIMAL(2,2),
  INDEX b_idx (b)
)

statement ok
INSERT INTO c VALUES(1, 0.4)

# Test that unspecifying b is like specifying NULL.
statement ok
INSERT INTO c (a) VALUES(2)

statement ok
INSERT INTO c VALUES(3)

statement ok
SET tracing = on,kv,results; SELECT * FROM c@b_idx; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /c/b_idx/NULL/2 -> NULL
fetched: /c/b_idx/NULL/3 -> NULL
fetched: /c/b_idx/0.4/1/b -> /0.40
output row: [2 NULL]
output row: [3 NULL]
output row: [1 0.40]

# ------------------------------------------------------------------------------
# Verify that lookups for Decimal NaN use indices when possible:
# - `WHERE d IS NaN` should perform a point lookup.
# - `WHERE d = 'NaN'` should also perform a point lookup.
# - `WHERE isnan(d)` is a function so it can't perform a point lookup.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE dec2 (d decimal null, index (d))

query T
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE d IS NaN
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal)
  estimated row count: 10 (missing stats)
  table: dec2@dec2_d_idx
  spans: /NaN-/-Infinity

query T
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE d = 'NaN'
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal)
  estimated row count: 10 (missing stats)
  table: dec2@dec2_d_idx
  spans: /NaN-/-Infinity

query T
EXPLAIN (TYPES) SELECT * FROM dec2 WHERE isnan(d)
----
distribution: local
vectorized: true
·
• filter
│ columns: (d decimal)
│ estimated row count: 330 (missing stats)
│ filter: (isnan((d)[decimal]))[bool]
│
└── • scan
      columns: (d decimal)
      estimated row count: 1,000 (missing stats)
      table: dec2@primary
      spans: FULL SCAN

statement ok
DROP TABLE dec2

# ------------------------------------------------------------------------------
# Verify that lookups for Float NaN use indices when possible:
# - `WHERE f IS NaN` should perform a point lookup.
# - `WHERE f = 'NaN'` should also perform a point lookup.
# - `WHERE isnan(f)` is a function so it can't perform a point lookup.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE flt (f float null, unique index (f))

query T
EXPLAIN (TYPES) SELECT * FROM flt WHERE f IS NaN
----
distribution: local
vectorized: true
·
• scan
  columns: (f float)
  estimated row count: 1 (missing stats)
  table: flt@flt_f_key
  spans: /NaN-/NaN/PrefixEnd

query T
EXPLAIN (TYPES) SELECT * FROM flt WHERE f = 'NaN'
----
distribution: local
vectorized: true
·
• scan
  columns: (f float)
  estimated row count: 1 (missing stats)
  table: flt@flt_f_key
  spans: /NaN-/NaN/PrefixEnd

query T
EXPLAIN (TYPES) SELECT * FROM flt WHERE isnan(f)
----
distribution: local
vectorized: true
·
• filter
│ columns: (f float)
│ estimated row count: 330 (missing stats)
│ filter: (isnan((f)[float]))[bool]
│
└── • scan
      columns: (f float)
      estimated row count: 1,000 (missing stats)
      table: flt@primary
      spans: FULL SCAN

statement ok
DROP TABLE flt

# ------------------------------------------------------------------------------
# Verify we create the correct spans for negative numbers with extra
# operations.
# ------------------------------------------------------------------------------

statement ok
CREATE TABLE num (
  i int null,
  unique index (i),
  f float null,
  unique index (f),
  d decimal null,
  unique index (d),
  n interval null,
  unique index (n)
)

query T
EXPLAIN (TYPES) SELECT i FROM num WHERE i = -1:::INT
----
distribution: local
vectorized: true
·
• scan
  columns: (i int)
  estimated row count: 1 (missing stats)
  table: num@num_i_key
  spans: /-1-/0

query T
EXPLAIN (TYPES) SELECT f FROM num WHERE f = -1:::FLOAT
----
distribution: local
vectorized: true
·
• scan
  columns: (f float)
  estimated row count: 1 (missing stats)
  table: num@num_f_key
  spans: /-1-/-1/PrefixEnd

query T
EXPLAIN (TYPES) SELECT d FROM num WHERE d = -1:::DECIMAL
----
distribution: local
vectorized: true
·
• scan
  columns: (d decimal)
  estimated row count: 1 (missing stats)
  table: num@num_d_key
  spans: /-1-/-1/PrefixEnd

query T
EXPLAIN (TYPES) SELECT n FROM num WHERE n = -'1h':::INTERVAL
----
distribution: local
vectorized: true
·
• scan
  columns: (n interval)
  estimated row count: 1 (missing stats)
  table: num@num_n_key
  spans: /-01:00:00-/1 day -25:00:00

statement ok
DROP TABLE num

# ------------------------------------------------------------------------------
# ANY, ALL tests.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE abc (a INT, b INT, c INT)

statement ok
INSERT INTO abc VALUES (1, 10, 100), (2, 20, 200), (3, 30, 300)

query III
SELECT * FROM abc WHERE a = ANY(SELECT a FROM abc WHERE b = 10)
----
1 10 100

query III
SELECT * FROM abc WHERE a < ANY(SELECT a FROM abc WHERE b = 30) ORDER BY a
----
1 10 100
2 20 200

query III
SELECT * FROM abc WHERE a > ANY(SELECT a FROM abc WHERE b = 30)
----

query III
SELECT * FROM abc WHERE a < ALL(SELECT b FROM abc) ORDER BY a
----
1 10 100
2 20 200
3 30 300

query III
SELECT * FROM abc WHERE a < ALL(SELECT a FROM abc WHERE a >= 2)
----
1 10 100

query III
SELECT * FROM abc WHERE a < ALL(SELECT a FROM abc)
----

statement ok
DROP TABLE abc

# ------------------------------------------------------------------------------
# IN tests.
# ------------------------------------------------------------------------------
# Regression tests for #22670.
query B
SELECT 1 IN (1, 2)
----
true

query B
SELECT NULL IN (1, 2)
----
NULL

query B
SELECT 1 IN (1, NULL)
----
true

query B
SELECT 1 IN (NULL, 2)
----
NULL

query B
SELECT (1, NULL) IN ((1, 1))
----
NULL

query B
SELECT (2, NULL) IN ((1, 1))
----
false

query B
SELECT (1, 1) IN ((1, NULL))
----
NULL

query B
SELECT (1, 1) IN ((2, NULL))
----
false

# Tests with a tuple coming from a subquery.
query B
SELECT NULL::int IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

query B
SELECT (1, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (2, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL::int, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL::int, 2) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
false

query B
SELECT (NULL::int, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT NULL::int NOT IN (SELECT * FROM (VALUES (1)) AS t(a))
----
NULL

query B
SELECT (1, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (2, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL::int, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

query B
SELECT (NULL::int, 2) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
true

query B
SELECT (NULL::int, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b))
----
NULL

# Tests with an empty IN tuple.
query B
SELECT NULL::int IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
false

query B
SELECT (1, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL::int, 1) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT (NULL::int, NULL::int) IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
false

query B
SELECT NULL::int NOT IN (SELECT * FROM (VALUES (1)) AS t(a) WHERE a > 1)
----
true

query B
SELECT (1, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL::int, 1) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

query B
SELECT (NULL::int, NULL::int) NOT IN (SELECT * FROM (VALUES (1, 1)) AS t(a, b) WHERE a > 1)
----
true

statement ok
CREATE TABLE abcd (a INT, b INT, c INT, d INT, PRIMARY KEY (a, b))

# Ensure that (non-top-level) render nodes get populated with the correct ordering.
query T
EXPLAIN (VERBOSE) SELECT a + x FROM (SELECT a, b + c AS x FROM abcd) ORDER BY a
----
distribution: local
vectorized: true
·
• project
│ columns: ("?column?")
│
└── • render
    │ columns: ("?column?", a)
    │ ordering: +a
    │ estimated row count: 1,000 (missing stats)
    │ render ?column?: a + (b + c)
    │ render a: a
    │
    └── • scan
          columns: (a, b, c)
          ordering: +a
          estimated row count: 1,000 (missing stats)
          table: abcd@primary
          spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT a + x FROM (SELECT a, b, a + b + c AS x FROM abcd) ORDER BY b
----
distribution: local
vectorized: true
·
• project
│ columns: ("?column?")
│
└── • sort
    │ columns: ("?column?", b)
    │ ordering: +b
    │ estimated row count: 1,000 (missing stats)
    │ order: +b
    │
    └── • render
        │ columns: ("?column?", b)
        │ estimated row count: 1,000 (missing stats)
        │ render ?column?: a + (c + (a + b))
        │ render b: b
        │
        └── • scan
              columns: (a, b, c)
              estimated row count: 1,000 (missing stats)
              table: abcd@primary
              spans: FULL SCAN


query T
EXPLAIN (VERBOSE) SELECT a + x FROM (SELECT a, b, a + b + c AS x FROM abcd) ORDER BY a DESC, b DESC
----
distribution: local
vectorized: true
·
• project
│ columns: ("?column?")
│
└── • render
    │ columns: ("?column?", a, b)
    │ ordering: -a,-b
    │ estimated row count: 1,000 (missing stats)
    │ render ?column?: a + (c + (a + b))
    │ render a: a
    │ render b: b
    │
    └── • revscan
          columns: (a, b, c)
          ordering: -a,-b
          estimated row count: 1,000 (missing stats)
          table: abcd@primary
          spans: FULL SCAN

# Ensure that filter nodes (and filtered scan nodes) get populated with the correct ordering.
query T
EXPLAIN (VERBOSE) SELECT * FROM abcd WHERE a > b ORDER BY a
----
distribution: local
vectorized: true
·
• filter
│ columns: (a, b, c, d)
│ ordering: +a
│ estimated row count: 333 (missing stats)
│ filter: a > b
│
└── • scan
      columns: (a, b, c, d)
      ordering: +a
      estimated row count: 1,000 (missing stats)
      table: abcd@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM abcd WHERE a > b ORDER BY a DESC, b DESC
----
distribution: local
vectorized: true
·
• sort
│ columns: (a, b, c, d)
│ ordering: -a,-b
│ estimated row count: 333 (missing stats)
│ order: -a,-b
│
└── • filter
    │ columns: (a, b, c, d)
    │ estimated row count: 333 (missing stats)
    │ filter: a > b
    │
    └── • scan
          columns: (a, b, c, d)
          estimated row count: 1,000 (missing stats)
          table: abcd@primary
          spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM (SELECT a, b FROM abcd LIMIT 10) WHERE a > b ORDER BY a
----
distribution: local
vectorized: true
·
• filter
│ columns: (a, b)
│ ordering: +a
│ estimated row count: 3 (missing stats)
│ filter: a > b
│
└── • scan
      columns: (a, b)
      ordering: +a
      estimated row count: 10 (missing stats)
      table: abcd@primary
      spans: LIMITED SCAN
      limit: 10

query T
EXPLAIN (VERBOSE) SELECT * FROM (SELECT a, a+b+c AS x FROM (SELECT * FROM abcd LIMIT 10)) WHERE x > 100 ORDER BY a
----
distribution: local
vectorized: true
·
• render
│ columns: (a, x)
│ ordering: +a
│ estimated row count: 3 (missing stats)
│ render x: c + (a + b)
│ render a: a
│
└── • filter
    │ columns: (a, b, c)
    │ ordering: +a
    │ estimated row count: 3 (missing stats)
    │ filter: (c + (a + b)) > 100
    │
    └── • scan
          columns: (a, b, c)
          ordering: +a
          estimated row count: 10 (missing stats)
          table: abcd@primary
          spans: LIMITED SCAN
          limit: 10

statement ok
CREATE TABLE xyz (x INT, y INT, z INT, INDEX(x,y,z))

# Verify the scan is configured with the correct ordering +x,+y,+z (#31882).
query T
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM xyz LIMIT 10) WHERE y = 1 ORDER BY x, y, z
----
distribution: local
vectorized: true
·
• filter
│ columns: (x, y, z)
│ ordering: +x,+z
│ estimated row count: 1 (missing stats)
│ filter: y = 1
│
└── • scan
      columns: (x, y, z)
      ordering: +x,+y,+z
      estimated row count: 10 (missing stats)
      table: xyz@xyz_x_y_z_idx
      spans: LIMITED SCAN
      limit: 10

# ------------------------------------------------------
# Verify that multi-span point lookups are parallelized.
# ------------------------------------------------------
statement ok
CREATE TABLE a (a INT PRIMARY KEY, item STRING, price FLOAT, FAMILY (a, item, price), UNIQUE INDEX item (item), UNIQUE INDEX p (price))

statement ok
CREATE TABLE b (a INT, b INT, c INT NULL, d INT NULL, PRIMARY KEY (a, b), FAMILY (a, b, c, d))

# No parallel line printed out for single-span selects.
query T
EXPLAIN SELECT * FROM a WHERE a = 10
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/10 - /10]

query T
EXPLAIN SELECT * FROM a WHERE a = 10 OR a = 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/10 - /10] [/20 - /20]

query T
EXPLAIN SELECT * FROM a WHERE a IN (10, 20)
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/10 - /10] [/20 - /20]

# Verify that consolidated point spans are still parallelized.
query T
EXPLAIN SELECT * FROM a WHERE a in (10, 11)
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/10 - /11]

query T
EXPLAIN SELECT * FROM a WHERE a > 10 AND a < 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/11 - /19]

# This ticks all the boxes for parallelization apart from the fact that there
# is no end key in the span.
query T
EXPLAIN SELECT * FROM a WHERE a > 10
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/11 - ]

# Test non-int types.

# Point queries on non-int types are parallel.
query T
EXPLAIN SELECT price FROM a WHERE item IN ('sock', 'ball')
----
distribution: local
vectorized: true
·
• index join
│ table: a@primary
│
└── • scan
      missing stats
      table: a@item
      spans: [/'ball' - /'ball'] [/'sock' - /'sock']

# Range queries on non-int types are not parallel due to unbounded number of
# results.
query T
EXPLAIN SELECT item FROM a WHERE price > 5 AND price < 10 OR price > 20 AND price < 40
----
distribution: local
vectorized: true
·
• index join
│ table: a@primary
│
└── • scan
      missing stats
      table: a@p
      spans: [/5.000000000000001 - /9.999999999999998] [/20.000000000000004 - /39.99999999999999]

query T
EXPLAIN SELECT * FROM b WHERE (a = 10 AND b = 10) OR (a = 20 AND b = 20)
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@primary
  spans: [/10/10 - /10/10] [/20/20 - /20/20]

# This one isn't parallelizable because it's not a point lookup - only part of
# the primary key is specified.
query T
EXPLAIN SELECT * FROM b WHERE a = 10 OR a = 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@primary
  spans: [/10 - /10] [/20 - /20]

# This one isn't parallelizable because it has a LIMIT clause.
query T
EXPLAIN SELECT * FROM a WHERE a = 10 OR a = 20 LIMIT 1
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: a@primary
  spans: [/10 - /10] [/20 - /20]
  limit: 1

statement ok
CREATE INDEX on b(b) STORING (c)

# This one isn't parallelizable because its index isn't unique.
query T
EXPLAIN SELECT b FROM b WHERE b = 10 OR b = 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_b_idx
  spans: [/10 - /10] [/20 - /20]

statement ok
CREATE UNIQUE INDEX on b(c)

# If the index has nullable values, parallelize only when the spans do not
# specify any nulls.
query T
EXPLAIN SELECT c FROM b WHERE c = 10 OR c = 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_c_key
  spans: [/10 - /10] [/20 - /20]

query T
EXPLAIN SELECT c FROM b WHERE c = 10 OR c < 2
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_c_key
  spans: (/NULL - /1] [/10 - /10]

statement ok
CREATE UNIQUE INDEX on b(d DESC)

# This scan is not parallelizable because the second span has a null in its end
# key.
query T
EXPLAIN SELECT d FROM b WHERE d = 10 OR d < 2
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_d_key
  spans: [/10 - /10] [/1 - /NULL)

statement ok
CREATE UNIQUE INDEX ON b(c, d)

# This scan is not parallelizable because although the second column is
# constrained, the first column is null.
query T
EXPLAIN SELECT d FROM b WHERE c = 10 AND d = 10 OR c IS NULL AND d > 0 AND d < 2
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_c_d_key
  spans: [/NULL/1 - /NULL/1] [/10/10 - /10/10]

statement ok
DROP INDEX b_b_idx

statement ok
CREATE UNIQUE INDEX on b(b) STORING (c)

# This one is parallelizable because its index is unique and non-null.
query T
EXPLAIN SELECT b FROM b WHERE b = 10 OR b = 20
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: b@b_b_key
  spans: [/10 - /10] [/20 - /20]

statement ok
ALTER TABLE a SPLIT AT VALUES(5)

# Run a select to prime the range cache to simplify the trace below.
statement ok
SELECT * FROM a

# Make sure that the scan actually gets parallelized.
statement ok
SET tracing = on; SELECT * FROM a WHERE a = 0 OR a = 10; SET tracing = off

# The span "sending partial batch" means that the scan was parallelized.
# If this test is failing and doesn't have that span, it means that the scanNode
# was improperly configured to add a limit to the ScanRequest batch.
# See #30943 for more details.
query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE 'querying next range at /Table/74/1%' OR
      message = '=== SPAN START: kv.DistSender: sending partial batch ==='
----
querying next range at /Table/74/1/0/0
querying next range at /Table/74/1/10/0

# Test for 42202 -- ensure filters can get pushed down through project-set.
statement ok
CREATE TABLE e (x INT PRIMARY KEY, y INT, z STRING);
CREATE TABLE s (x INT PRIMARY KEY, y INT, z INT)

query T
EXPLAIN SELECT e.z, s.z, n FROM e, s, generate_series(0, s.z, 1000) as n WHERE e.y = s.y ORDER BY s.z LIMIT 10
----
distribution: local
vectorized: true
·
• limit
│ count: 10
│
└── • sort
    │ order: +z
    │
    └── • project set
        │
        └── • hash join
            │ equality: (y) = (y)
            │
            ├── • scan
            │     missing stats
            │     table: e@primary
            │     spans: FULL SCAN
            │
            └── • scan
                  missing stats
                  table: s@primary
                  spans: FULL SCAN
