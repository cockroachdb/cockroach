# LogicTest: local

subtest DeleteCascade_Basic
### Basic Delete Cascade
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
)

statement ok
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
)

statement ok
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
)

statement ok
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES b1 ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
)

statement ok
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES b1 ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
)

statement ok
CREATE TABLE c3 (
  id STRING PRIMARY KEY REFERENCES b2 ON DELETE CASCADE
)

statement ok
INSERT INTO a VALUES ('a-pk1');
INSERT INTO b1 VALUES ('b1-pk1', 'a-pk1'), ('b1-pk2', 'a-pk1');
INSERT INTO b2 VALUES ('b2-pk1', 'a-pk1'), ('b2-pk2', 'a-pk1');
INSERT INTO c1 VALUES
  ('c1-pk1-b1-pk1', 'b1-pk1')
 ,('c1-pk2-b1-pk1', 'b1-pk1')
 ,('c1-pk3-b1-pk2', 'b1-pk2')
 ,('c1-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c2 VALUES
  ('c2-pk1-b1-pk1', 'b1-pk1')
 ,('c2-pk2-b1-pk1', 'b1-pk1')
 ,('c2-pk3-b1-pk2', 'b1-pk2')
 ,('c2-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c3 VALUES ('b2-pk1'), ('b2-pk2');

statement ok
SET tracing = on,kv,results; DELETE FROM a WHERE id = 'a-pk1'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%'
----
Del /Table/53/1/"a-pk1"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/54/2/"a-pk1"/"b1-pk1"/0
Del /Table/54/1/"b1-pk1"/0
Del /Table/54/2/"a-pk1"/"b1-pk2"/0
Del /Table/54/1/"b1-pk2"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/55/2/"a-pk1"/"b2-pk1"/0
Del /Table/55/1/"b2-pk1"/0
Del /Table/55/2/"a-pk1"/"b2-pk2"/0
Del /Table/55/1/"b2-pk2"/0
executing cascade for constraint fk_delete_cascade_ref_b1
Del /Table/56/2/"b1-pk1"/"c1-pk1-b1-pk1"/0
Del /Table/56/1/"c1-pk1-b1-pk1"/0
Del /Table/56/2/"b1-pk1"/"c1-pk2-b1-pk1"/0
Del /Table/56/1/"c1-pk2-b1-pk1"/0
Del /Table/56/2/"b1-pk2"/"c1-pk3-b1-pk2"/0
Del /Table/56/1/"c1-pk3-b1-pk2"/0
Del /Table/56/2/"b1-pk2"/"c1-pk4-b1-pk2"/0
Del /Table/56/1/"c1-pk4-b1-pk2"/0
executing cascade for constraint fk_delete_cascade_ref_b1
Del /Table/57/2/"b1-pk1"/"c2-pk1-b1-pk1"/0
Del /Table/57/1/"c2-pk1-b1-pk1"/0
Del /Table/57/2/"b1-pk1"/"c2-pk2-b1-pk1"/0
Del /Table/57/1/"c2-pk2-b1-pk1"/0
Del /Table/57/2/"b1-pk2"/"c2-pk3-b1-pk2"/0
Del /Table/57/1/"c2-pk3-b1-pk2"/0
Del /Table/57/2/"b1-pk2"/"c2-pk4-b1-pk2"/0
Del /Table/57/1/"c2-pk4-b1-pk2"/0
executing cascade for constraint fk_id_ref_b2
Del /Table/58/1/"b2-pk1"/0
Del /Table/58/1/"b2-pk2"/0

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

subtest UpdateCascade_Basic
### Basic Update Cascade
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);

statement ok
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  update_cascade STRING NOT NULL UNIQUE REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);

statement ok
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  update_cascade STRING NOT NULL UNIQUE REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);

statement ok
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  update_cascade STRING NOT NULL REFERENCES b1 (update_cascade) ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);

statement ok
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  update_cascade STRING NOT NULL REFERENCES b1 (update_cascade) ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);

statement ok
CREATE TABLE c3 (
  id STRING PRIMARY KEY REFERENCES b2(update_cascade) ON UPDATE CASCADE
);

statement ok
INSERT INTO a VALUES ('original');
INSERT INTO b1 VALUES ('b1-pk1', 'original');
INSERT INTO b2 VALUES ('b2-pk1', 'original');
INSERT INTO c1 VALUES
  ('c1-pk1', 'original')
 ,('c1-pk2', 'original')
 ,('c1-pk3', 'original')
 ,('c1-pk4', 'original')
;
INSERT INTO c2 VALUES
  ('c2-pk1', 'original')
 ,('c2-pk2', 'original')
 ,('c2-pk3', 'original')
 ,('c2-pk4', 'original')
;
INSERT INTO c3 VALUES ('original');

# ON UPDATE CASCADE
statement ok
UPDATE a SET id = 'updated' WHERE id = 'original';

statement ok
SET tracing = on,kv,results; UPDATE a SET id = 'updated2' WHERE id = 'updated'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%' OR message LIKE 'CPut%'
----
Del /Table/59/1/"updated"/0
CPut /Table/59/1/"updated2"/0 -> /TUPLE/
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/60/2/"updated"/0
CPut /Table/60/2/"updated2"/0 -> /BYTES/0x1262312d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/61/2/"updated"/0
CPut /Table/61/2/"updated2"/0 -> /BYTES/0x1262322d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_cascade_ref_b1
Del /Table/62/2/"updated"/"c1-pk1"/0
CPut /Table/62/2/"updated2"/"c1-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/62/2/"updated"/"c1-pk2"/0
CPut /Table/62/2/"updated2"/"c1-pk2"/0 -> /BYTES/ (expecting does not exist)
Del /Table/62/2/"updated"/"c1-pk3"/0
CPut /Table/62/2/"updated2"/"c1-pk3"/0 -> /BYTES/ (expecting does not exist)
Del /Table/62/2/"updated"/"c1-pk4"/0
CPut /Table/62/2/"updated2"/"c1-pk4"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_cascade_ref_b1
Del /Table/63/2/"updated"/"c2-pk1"/0
CPut /Table/63/2/"updated2"/"c2-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/63/2/"updated"/"c2-pk2"/0
CPut /Table/63/2/"updated2"/"c2-pk2"/0 -> /BYTES/ (expecting does not exist)
Del /Table/63/2/"updated"/"c2-pk3"/0
CPut /Table/63/2/"updated2"/"c2-pk3"/0 -> /BYTES/ (expecting does not exist)
Del /Table/63/2/"updated"/"c2-pk4"/0
CPut /Table/63/2/"updated2"/"c2-pk4"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_id_ref_b2
Del /Table/64/1/"updated"/0
CPut /Table/64/1/"updated2"/0 -> /TUPLE/

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

subtest DeleteSetNull_Basic1
### Basic Delete Set Null
#        a
#      // \\
#    / |  |  \
#   b1 b2 b3 b4

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES a ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES a ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);
CREATE TABLE b3 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES a ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);
CREATE TABLE b4 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES a ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);

statement ok
INSERT INTO a VALUES ('delete_me'), ('untouched');
INSERT INTO b1 VALUES ('b1-pk1', 'untouched'), ('b1-pk2', 'untouched');
INSERT INTO b2 VALUES ('b2-pk1', 'untouched'), ('b2-pk2', 'delete_me');
INSERT INTO b3 VALUES ('b3-pk1', 'delete_me'), ('b3-pk2', 'untouched');
INSERT INTO b4 VALUES ('b4-pk1', 'delete_me'), ('b4-pk2', 'delete_me');

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; DELETE FROM a WHERE id = 'delete_me'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%'
----
Del /Table/65/1/"delete_me"/0
executing cascade for constraint fk_delete_set_null_ref_a
executing cascade for constraint fk_delete_set_null_ref_a
Del /Table/67/2/"delete_me"/"b2-pk2"/0
executing cascade for constraint fk_delete_set_null_ref_a
Del /Table/68/2/"delete_me"/"b3-pk1"/0
executing cascade for constraint fk_delete_set_null_ref_a
Del /Table/69/2/"delete_me"/"b4-pk1"/0
Del /Table/69/2/"delete_me"/"b4-pk2"/0

# Clean up after the test.
statement ok
DROP TABLE b4, b3, b2, b1, a;

subtest DeleteSetNull_Basic2
### Basic Delete Set Null
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
);
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES b1 ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES b1 ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);
CREATE TABLE c3 (
  id STRING PRIMARY KEY,
  delete_set_null STRING REFERENCES b2 ON DELETE SET NULL,
  FAMILY (id, delete_set_null)
);

statement ok
INSERT INTO a VALUES ('a-pk1');
INSERT INTO b1 VALUES ('b1-pk1', 'a-pk1'), ('b1-pk2', 'a-pk1');
INSERT INTO b2 VALUES ('b2-pk1', 'a-pk1'), ('b2-pk2', 'a-pk1');
INSERT INTO c1 VALUES
  ('c1-pk1-b1-pk1', 'b1-pk1')
 ,('c1-pk2-b1-pk1', 'b1-pk1')
 ,('c1-pk3-b1-pk2', 'b1-pk2')
 ,('c1-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c2 VALUES
  ('c2-pk1-b1-pk1', 'b1-pk1')
 ,('c2-pk2-b1-pk1', 'b1-pk1')
 ,('c2-pk3-b1-pk2', 'b1-pk2')
 ,('c2-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c3 VALUES
  ('c3-pk1-b2-pk1', 'b2-pk1')
 ,('c3-pk2-b2-pk1', 'b2-pk1')
 ,('c3-pk3-b2-pk2', 'b2-pk2')
 ,('c3-pk4-b2-pk2', 'b2-pk2')
;

statement ok
SET tracing = on,kv,results; DELETE FROM a WHERE id = 'a-pk1'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%'
----
Del /Table/70/1/"a-pk1"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/71/2/"a-pk1"/"b1-pk1"/0
Del /Table/71/1/"b1-pk1"/0
Del /Table/71/2/"a-pk1"/"b1-pk2"/0
Del /Table/71/1/"b1-pk2"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/72/2/"a-pk1"/"b2-pk1"/0
Del /Table/72/1/"b2-pk1"/0
Del /Table/72/2/"a-pk1"/"b2-pk2"/0
Del /Table/72/1/"b2-pk2"/0
executing cascade for constraint fk_delete_set_null_ref_b1
Del /Table/73/2/"b1-pk1"/"c1-pk1-b1-pk1"/0
Del /Table/73/2/"b1-pk1"/"c1-pk2-b1-pk1"/0
Del /Table/73/2/"b1-pk2"/"c1-pk3-b1-pk2"/0
Del /Table/73/2/"b1-pk2"/"c1-pk4-b1-pk2"/0
executing cascade for constraint fk_delete_set_null_ref_b1
Del /Table/74/2/"b1-pk1"/"c2-pk1-b1-pk1"/0
Del /Table/74/2/"b1-pk1"/"c2-pk2-b1-pk1"/0
Del /Table/74/2/"b1-pk2"/"c2-pk3-b1-pk2"/0
Del /Table/74/2/"b1-pk2"/"c2-pk4-b1-pk2"/0
executing cascade for constraint fk_delete_set_null_ref_b2
Del /Table/75/2/"b2-pk1"/"c3-pk1-b2-pk1"/0
Del /Table/75/2/"b2-pk1"/"c3-pk2-b2-pk1"/0
Del /Table/75/2/"b2-pk2"/"c3-pk3-b2-pk2"/0
Del /Table/75/2/"b2-pk2"/"c3-pk4-b2-pk2"/0

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

subtest UpdateSetNull_Basic1
### Basic Update Set Null
#        a
#      // \\
#    / |  |  \
#   b1 b2 b3 b4

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES a ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES a ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);
CREATE TABLE b3 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES a ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);
CREATE TABLE b4 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES a ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);

statement ok
INSERT INTO a VALUES ('original'), ('untouched');
INSERT INTO b1 VALUES ('b1-pk1', 'untouched'), ('b1-pk2', 'untouched');
INSERT INTO b2 VALUES ('b2-pk1', 'untouched'), ('b2-pk2', 'original');
INSERT INTO b3 VALUES ('b3-pk1', 'original'), ('b3-pk2', 'untouched');
INSERT INTO b3 VALUES ('b4-pk1', 'original'), ('b4-pk2', 'original');

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; UPDATE a SET id = 'updated' WHERE id = 'original'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%' OR message LIKE 'CPut%'
----
Del /Table/76/1/"original"/0
CPut /Table/76/1/"updated"/0 -> /TUPLE/
executing cascade for constraint fk_update_set_null_ref_a
executing cascade for constraint fk_update_set_null_ref_a
Del /Table/78/2/"original"/"b2-pk2"/0
CPut /Table/78/2/NULL/"b2-pk2"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_a
Del /Table/79/2/"original"/"b3-pk1"/0
CPut /Table/79/2/NULL/"b3-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/79/2/"original"/"b4-pk1"/0
CPut /Table/79/2/NULL/"b4-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/79/2/"original"/"b4-pk2"/0
CPut /Table/79/2/NULL/"b4-pk2"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_a

# Clean up after the test.
statement ok
DROP TABLE b4, b3, b2, b1, a;

subtest UpdateSetNull_Basic2
### Basic Update Set Null
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  update_cascade STRING UNIQUE NOT NULL REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  update_cascade STRING UNIQUE NOT NULL REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES b1(update_cascade) ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES b1(update_cascade) ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);
CREATE TABLE c3 (
  id STRING PRIMARY KEY,
  update_set_null STRING REFERENCES b2(update_cascade) ON UPDATE SET NULL,
  FAMILY (id, update_set_null)
);

statement ok
INSERT INTO a VALUES ('original'), ('untouched');
INSERT INTO b1 VALUES ('b1-pk1', 'original'), ('b1-pk2', 'untouched');
INSERT INTO b2 VALUES ('b2-pk1', 'original'), ('b2-pk2', 'untouched');
INSERT INTO c1 VALUES
  ('c1-pk1-b1-pk1', 'original')
 ,('c1-pk2-b1-pk1', 'original')
 ,('c1-pk3-b1-pk2', 'untouched')
 ,('c1-pk4-b1-pk2', 'untouched')
;
INSERT INTO c2 VALUES
  ('c2-pk1-b1-pk1', 'original')
 ,('c2-pk2-b1-pk1', 'original')
 ,('c2-pk3-b1-pk2', 'untouched')
 ,('c2-pk4-b1-pk2', 'untouched')
;
INSERT INTO c3 VALUES
  ('c3-pk1-b2-pk1', 'original')
 ,('c3-pk2-b2-pk1', 'original')
 ,('c3-pk3-b2-pk2', 'untouched')
 ,('c3-pk4-b2-pk2', 'untouched')
;

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; UPDATE a SET id = 'updated' WHERE id = 'original'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%' OR message LIKE 'CPut%'
----
Del /Table/81/1/"original"/0
CPut /Table/81/1/"updated"/0 -> /TUPLE/
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/82/2/"original"/0
CPut /Table/82/2/"updated"/0 -> /BYTES/0x1262312d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/83/2/"original"/0
CPut /Table/83/2/"updated"/0 -> /BYTES/0x1262322d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b1
Del /Table/84/2/"original"/"c1-pk1-b1-pk1"/0
CPut /Table/84/2/NULL/"c1-pk1-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/84/2/"original"/"c1-pk2-b1-pk1"/0
CPut /Table/84/2/NULL/"c1-pk2-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b1
Del /Table/85/2/"original"/"c2-pk1-b1-pk1"/0
CPut /Table/85/2/NULL/"c2-pk1-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/85/2/"original"/"c2-pk2-b1-pk1"/0
CPut /Table/85/2/NULL/"c2-pk2-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b2
Del /Table/86/2/"original"/"c3-pk1-b2-pk1"/0
CPut /Table/86/2/NULL/"c3-pk1-b2-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/86/2/"original"/"c3-pk2-b2-pk1"/0
CPut /Table/86/2/NULL/"c3-pk2-b2-pk1"/0 -> /BYTES/ (expecting does not exist)

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

##############

subtest DeleteSetDefault_Basic1
### Basic Delete Set Default
#        a
#      // \\
#    / |  |  \
#   b1 b2 b3 b4

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b1-default' REFERENCES a ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b2-default' REFERENCES a ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);
CREATE TABLE b3 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b3-default' REFERENCES a ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);
CREATE TABLE b4 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b4-default' REFERENCES a ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);

statement ok
INSERT INTO a VALUES ('delete_me'), ('untouched'), ('b2-default'), ('b3-default'), ('b4-default');
INSERT INTO b1 VALUES ('b1-pk1', 'untouched'), ('b1-pk2', 'untouched');
INSERT INTO b2 VALUES ('b2-pk1', 'untouched'), ('b2-pk2', 'delete_me');
INSERT INTO b3 VALUES ('b3-pk1', 'delete_me'), ('b3-pk2', 'untouched');
INSERT INTO b4 VALUES ('b4-pk1', 'delete_me'), ('b4-pk2', 'delete_me');

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; DELETE FROM a WHERE id = 'delete_me'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%'
----
Del /Table/87/1/"delete_me"/0
executing cascade for constraint fk_delete_set_default_ref_a
executing cascade for constraint fk_delete_set_default_ref_a
Del /Table/89/2/"delete_me"/"b2-pk2"/0
executing cascade for constraint fk_delete_set_default_ref_a
Del /Table/90/2/"delete_me"/"b3-pk1"/0
executing cascade for constraint fk_delete_set_default_ref_a
Del /Table/91/2/"delete_me"/"b4-pk1"/0
Del /Table/91/2/"delete_me"/"b4-pk2"/0

# Clean up after the test.
statement ok
DROP TABLE b4, b3, b2, b1, a;

subtest DeleteSetDefault_Basic2
### Basic Delete Set Null via an ON DELETE CASCADE
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  delete_cascade STRING NOT NULL REFERENCES a ON DELETE CASCADE,
  FAMILY (id, delete_cascade)
);
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b1-default' REFERENCES b1 ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b1-default' REFERENCES b1 ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);
CREATE TABLE c3 (
  id STRING PRIMARY KEY,
  delete_set_default STRING DEFAULT 'b2-default' REFERENCES b2 ON DELETE SET DEFAULT,
  FAMILY (id, delete_set_default)
);

statement ok
INSERT INTO a VALUES ('a-pk1'), ('a-default');
INSERT INTO b1 VALUES ('b1-pk1', 'a-pk1'), ('b1-pk2', 'a-pk1'), ('b1-default', 'a-default');
INSERT INTO b2 VALUES ('b2-pk1', 'a-pk1'), ('b2-pk2', 'a-pk1'), ('b2-default', 'a-default');
INSERT INTO c1 VALUES
  ('c1-pk1-b1-pk1', 'b1-pk1')
 ,('c1-pk2-b1-pk1', 'b1-pk1')
 ,('c1-pk3-b1-pk2', 'b1-pk2')
 ,('c1-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c2 VALUES
  ('c2-pk1-b1-pk1', 'b1-pk1')
 ,('c2-pk2-b1-pk1', 'b1-pk1')
 ,('c2-pk3-b1-pk2', 'b1-pk2')
 ,('c2-pk4-b1-pk2', 'b1-pk2')
;
INSERT INTO c3 VALUES
  ('c3-pk1-b2-pk1', 'b2-pk1')
 ,('c3-pk2-b2-pk1', 'b2-pk1')
 ,('c3-pk3-b2-pk2', 'b2-pk2')
 ,('c3-pk4-b2-pk2', 'b2-pk2')
;

statement ok
SET tracing = on,kv,results; DELETE FROM a WHERE id = 'a-pk1'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%'
----
Del /Table/92/1/"a-pk1"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/93/2/"a-pk1"/"b1-pk1"/0
Del /Table/93/1/"b1-pk1"/0
Del /Table/93/2/"a-pk1"/"b1-pk2"/0
Del /Table/93/1/"b1-pk2"/0
executing cascade for constraint fk_delete_cascade_ref_a
Del /Table/94/2/"a-pk1"/"b2-pk1"/0
Del /Table/94/1/"b2-pk1"/0
Del /Table/94/2/"a-pk1"/"b2-pk2"/0
Del /Table/94/1/"b2-pk2"/0
executing cascade for constraint fk_delete_set_default_ref_b1
Del /Table/95/2/"b1-pk1"/"c1-pk1-b1-pk1"/0
Del /Table/95/2/"b1-pk1"/"c1-pk2-b1-pk1"/0
Del /Table/95/2/"b1-pk2"/"c1-pk3-b1-pk2"/0
Del /Table/95/2/"b1-pk2"/"c1-pk4-b1-pk2"/0
executing cascade for constraint fk_delete_set_default_ref_b1
Del /Table/96/2/"b1-pk1"/"c2-pk1-b1-pk1"/0
Del /Table/96/2/"b1-pk1"/"c2-pk2-b1-pk1"/0
Del /Table/96/2/"b1-pk2"/"c2-pk3-b1-pk2"/0
Del /Table/96/2/"b1-pk2"/"c2-pk4-b1-pk2"/0
executing cascade for constraint fk_delete_set_default_ref_b2
Del /Table/97/2/"b2-pk1"/"c3-pk1-b2-pk1"/0
Del /Table/97/2/"b2-pk1"/"c3-pk2-b2-pk1"/0
Del /Table/97/2/"b2-pk2"/"c3-pk3-b2-pk2"/0
Del /Table/97/2/"b2-pk2"/"c3-pk4-b2-pk2"/0

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

subtest UpdateSetDefault_Basic1
### Basic Update Set Default
#        a
#      // \\
#    / |  |  \
#   b1 b2 b3 b4

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b1-default' REFERENCES a ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b2-default' REFERENCES a ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);
CREATE TABLE b3 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b3-default' REFERENCES a ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);
CREATE TABLE b4 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b4-default' REFERENCES a ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);

statement ok
INSERT INTO a VALUES ('original'), ('untouched'), ('b1-default'), ('b2-default'), ('b3-default'), ('b4-default');
INSERT INTO b1 VALUES ('b1-pk1', 'untouched'), ('b1-pk2', 'untouched');
INSERT INTO b2 VALUES ('b2-pk1', 'untouched'), ('b2-pk2', 'original');
INSERT INTO b3 VALUES ('b3-pk1', 'original'), ('b3-pk2', 'untouched');
INSERT INTO b3 VALUES ('b4-pk1', 'original'), ('b4-pk2', 'original');

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; UPDATE a SET id = 'updated' WHERE id = 'original'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%' OR message LIKE 'CPut%'
----
Del /Table/98/1/"original"/0
CPut /Table/98/1/"updated"/0 -> /TUPLE/
executing cascade for constraint fk_update_set_null_ref_a
executing cascade for constraint fk_update_set_null_ref_a
Del /Table/100/2/"original"/"b2-pk2"/0
CPut /Table/100/2/"b2-default"/"b2-pk2"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_a
Del /Table/101/2/"original"/"b3-pk1"/0
CPut /Table/101/2/"b3-default"/"b3-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/101/2/"original"/"b4-pk1"/0
CPut /Table/101/2/"b3-default"/"b4-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/101/2/"original"/"b4-pk2"/0
CPut /Table/101/2/"b3-default"/"b4-pk2"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_a

# Clean up after the test.
statement ok
DROP TABLE b4, b3, b2, b1, a;

subtest UpdateSetDefault_Basic2
### Basic UPDATE SET DEFAULT via an UPDATE CASCADE
#     a
#    / \
#   b1 b2
#  / \   \
# c1  c2  c3

statement ok
CREATE TABLE a (
  id STRING PRIMARY KEY
);
CREATE TABLE b1 (
  id STRING PRIMARY KEY,
  update_cascade STRING UNIQUE NOT NULL REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);
CREATE TABLE b2 (
  id STRING PRIMARY KEY,
  update_cascade STRING UNIQUE NOT NULL REFERENCES a ON UPDATE CASCADE,
  FAMILY (id, update_cascade)
);
CREATE TABLE c1 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b1-default' REFERENCES b1(update_cascade) ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);
CREATE TABLE c2 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b1-default' REFERENCES b1(update_cascade) ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);
CREATE TABLE c3 (
  id STRING PRIMARY KEY,
  update_set_null STRING DEFAULT 'b2-default' REFERENCES b2(update_cascade) ON UPDATE SET DEFAULT,
  FAMILY (id, update_set_null)
);

statement ok
INSERT INTO a VALUES ('original'), ('untouched'), ('b1-default'), ('b2-default');
INSERT INTO b1 VALUES ('b1-pk1', 'original'), ('b1-pk2', 'untouched'), ('b1-default', 'b1-default');
INSERT INTO b2 VALUES ('b2-pk1', 'original'), ('b2-pk2', 'untouched'), ('b2-default', 'b2-default');
INSERT INTO c1 VALUES
  ('c1-pk1-b1-pk1', 'original')
 ,('c1-pk2-b1-pk1', 'original')
 ,('c1-pk3-b1-pk2', 'untouched')
 ,('c1-pk4-b1-pk2', 'untouched')
;
INSERT INTO c2 VALUES
  ('c2-pk1-b1-pk1', 'original')
 ,('c2-pk2-b1-pk1', 'original')
 ,('c2-pk3-b1-pk2', 'untouched')
 ,('c2-pk4-b1-pk2', 'untouched')
;
INSERT INTO c3 VALUES
  ('c3-pk1-b2-pk1', 'original')
 ,('c3-pk2-b2-pk1', 'original')
 ,('c3-pk3-b2-pk2', 'untouched')
 ,('c3-pk4-b2-pk2', 'untouched')
;

# Ensure that show trace adds a cascade message for each of the tables that is
# cascaded into.
statement ok
SET tracing = on,kv,results; UPDATE a SET id = 'updated' WHERE id = 'original'; SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%executing cascade %' OR message LIKE 'Del%' OR message LIKE 'CPut%'
----
Del /Table/103/1/"original"/0
CPut /Table/103/1/"updated"/0 -> /TUPLE/
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/104/2/"original"/0
CPut /Table/104/2/"updated"/0 -> /BYTES/0x1262312d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_cascade_ref_a
Del /Table/105/2/"original"/0
CPut /Table/105/2/"updated"/0 -> /BYTES/0x1262322d706b310001 (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b1
Del /Table/106/2/"original"/"c1-pk1-b1-pk1"/0
CPut /Table/106/2/"b1-default"/"c1-pk1-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/106/2/"original"/"c1-pk2-b1-pk1"/0
CPut /Table/106/2/"b1-default"/"c1-pk2-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b1
Del /Table/107/2/"original"/"c2-pk1-b1-pk1"/0
CPut /Table/107/2/"b1-default"/"c2-pk1-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/107/2/"original"/"c2-pk2-b1-pk1"/0
CPut /Table/107/2/"b1-default"/"c2-pk2-b1-pk1"/0 -> /BYTES/ (expecting does not exist)
executing cascade for constraint fk_update_set_null_ref_b2
Del /Table/108/2/"original"/"c3-pk1-b2-pk1"/0
CPut /Table/108/2/"b2-default"/"c3-pk1-b2-pk1"/0 -> /BYTES/ (expecting does not exist)
Del /Table/108/2/"original"/"c3-pk2-b2-pk1"/0
CPut /Table/108/2/"b2-default"/"c3-pk2-b2-pk1"/0 -> /BYTES/ (expecting does not exist)

# Clean up after the test.
statement ok
DROP TABLE c3, c2, c1, b2, b1, a;

# Regression for #46094.

statement ok
CREATE TABLE parent (x INT PRIMARY KEY);
CREATE TABLE child1 (
  id INT PRIMARY KEY,
  x INT REFERENCES parent (x) ON DELETE CASCADE,
  FAMILY (id, x)
);
CREATE TABLE child2 (
  id INT PRIMARY KEY,
  x INT REFERENCES parent (x) ON DELETE SET NULL,
  FAMILY (id, x)
);
INSERT INTO parent VALUES (1), (2);
INSERT INTO child1 VALUES (1, 1), (2, 1);
INSERT INTO child2 VALUES (1, 1), (2, 1)

# Here we ensure that after the cascaded deletes we don't need
# to perform additional and unneeded FKScan operations after
# cascade deleting or setting null to referencing rows.
query T kvtrace(Del,FKScan)
DELETE FROM parent WHERE x = 1
----
Del /Table/109/1/1/0
Del /Table/110/2/1/1/0
Del /Table/110/1/1/0
Del /Table/110/2/1/2/0
Del /Table/110/1/2/0
Del /Table/111/2/1/1/0
Del /Table/111/2/1/2/0
