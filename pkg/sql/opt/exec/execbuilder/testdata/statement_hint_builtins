# LogicTest: local
# cluster-opt: disable-mvcc-range-tombstones-for-point-deletes

# Speed up the rangefeed.
user host-cluster-root

statement ok
SET CLUSTER SETTING kv.closed_timestamp.target_duration = '50ms';

statement ok
SET CLUSTER SETTING kv.closed_timestamp.side_transport_interval = '50ms';

statement ok
SET CLUSTER SETTING kv.rangefeed.closed_timestamp_refresh_interval = '50ms';

user root

statement ok
CREATE TABLE xy (x INT PRIMARY KEY, y INT, INDEX (y));

statement ok
CREATE TABLE ab (a INT PRIMARY KEY, b INT, INDEX (b));

statement ok
INSERT INTO xy VALUES (10, 10)

statement ok
INSERT INTO ab VALUES (10, 10)

statement ok
CREATE TABLE abc (a INT PRIMARY KEY, b INT, c INT, INDEX (b))

# Try some simple hint rewrites. First, add an index hint.

query T
EXPLAIN SELECT a FROM abc WHERE a = 10
----
distribution: local
·
• scan
  missing stats
  table: abc@abc_pkey
  spans: [/10 - /10]

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a FROM abc WHERE a = _',
  'SELECT a FROM abc@abc_b_idx WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT a FROM abc WHERE a = 5

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints

query T
EXPLAIN SELECT a FROM abc WHERE a = 10
----
distribution: local
statement hints count: 1
·
• filter
│ filter: a = 10
│
└── • scan
      missing stats
      table: abc@abc_b_idx
      spans: FULL SCAN

query T
EXPLAIN ANALYZE SELECT a FROM abc WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• filter
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ filter: a = 10
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 0
      actual row count: 0
      missing stats
      table: abc@abc_b_idx
      spans: FULL SCAN

# Try injecting a join hint.

query T
EXPLAIN SELECT a, x FROM abc JOIN xy ON y = b WHERE a = 10
----
distribution: local
·
• lookup join
│ table: xy@xy_y_idx
│ equality: (b) = (y)
│
└── • scan
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a, x FROM abc JOIN xy ON y = b WHERE a = _',
  'SELECT a, x FROM abc INNER HASH JOIN xy ON y = b WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT a, x FROM abc JOIN xy ON y = b WHERE a = 5

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints

query T
EXPLAIN SELECT a, x FROM abc JOIN xy ON y = b WHERE a = 10
----
distribution: local
statement hints count: 1
·
• hash join
│ equality: (b) = (y)
│ left cols are key
│
├── • scan
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

query T
EXPLAIN ANALYZE SELECT a, x FROM abc JOIN xy ON y = b WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
rows decoded from KV: 1 (8 B, 2 KVs, 1 gRPC calls)
regions: <hidden>
·
• hash join
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ equality: (b) = (y)
│ left cols are key
│
├── • scan
│     sql nodes: <hidden>
│     kv nodes: <hidden>
│     regions: <hidden>
│     KV time: 0µs
│     KV rows decoded: 0
│     actual row count: 0
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 1
      actual row count: 1
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

# Try removing a hint.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a FROM abc@abc_pkey WHERE b = _',
  'SELECT a FROM abc WHERE b = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT a FROM abc@abc_pkey WHERE b = 5

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints

query T
EXPLAIN SELECT a FROM abc@abc_pkey WHERE b = 10
----
distribution: local
statement hints count: 1
·
• scan
  missing stats
  table: abc@abc_b_idx
  spans: [/10 - /10]

query T
EXPLAIN ANALYZE SELECT a FROM abc@abc_pkey WHERE b = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• scan
  sql nodes: <hidden>
  kv nodes: <hidden>
  regions: <hidden>
  KV time: 0µs
  KV rows decoded: 0
  actual row count: 0
  missing stats
  table: abc@abc_b_idx
  spans: [/10 - /10]

# Check that we do not use an invalid injected index hint.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a + _ FROM abc WHERE a = _',
  'SELECT a + _ FROM abc@foo WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT a + 1 FROM abc WHERE a = 5

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints
planning with injected hints failed with: index "foo" not found
falling back to planning without injected hints

query T
EXPLAIN SELECT a + 1 FROM abc WHERE a = 10
----
distribution: local
statement hints count: 1
·
• render
│
└── • scan
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

query T
EXPLAIN ANALYZE SELECT a + 1 FROM abc WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• render
│ execution time: 0µs
│ actual row count: 0
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 0
      actual row count: 0
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

# Check that we do not use an unsatisfiable injected hint.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT c FROM xy JOIN abc ON c = y WHERE x = _',
  'SELECT c FROM xy INNER LOOKUP JOIN abc ON c = y WHERE x = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT c FROM xy JOIN abc ON c = y WHERE x = 5

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints
planning with injected hints failed with: could not produce a query plan conforming to the LOOKUP JOIN hint
falling back to planning without injected hints

query T
EXPLAIN SELECT c FROM xy JOIN abc ON c = y WHERE x = 10
----
distribution: local
statement hints count: 1
·
• hash join
│ equality: (c) = (y)
│ right cols are key
│
├── • scan
│     missing stats
│     table: abc@abc_pkey
│     spans: FULL SCAN
│
└── • scan
      missing stats
      table: xy@xy_pkey
      spans: [/10 - /10]

query T
EXPLAIN ANALYZE SELECT c FROM xy JOIN abc ON c = y WHERE x = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
statement hints count: 1
rows decoded from KV: 1 (8 B, 2 KVs, 1 gRPC calls)
regions: <hidden>
·
• hash join
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ equality: (c) = (y)
│ right cols are key
│
├── • scan
│     sql nodes: <hidden>
│     kv nodes: <hidden>
│     regions: <hidden>
│     KV time: 0µs
│     KV rows decoded: 0
│     actual row count: 0
│     missing stats
│     table: abc@abc_pkey
│     spans: FULL SCAN
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 1
      actual row count: 1
      missing stats
      table: xy@xy_pkey
      spans: [/10 - /10]

# Try a prepared statement with an injected hint.

let $hint_p1
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT c FROM abc WHERE b > _',
  'SELECT c FROM abc@{NO_INDEX_JOIN} WHERE b > _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
PREPARE p1 AS SELECT c FROM abc WHERE b > $1

statement ok
EXECUTE p1 (5)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
injected hints from external statement hint x
trying preparing with injected hints
trying planning with injected hints

query T
EXPLAIN ANALYZE EXECUTE p1 (5)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• filter
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ filter: b > 5
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 0
      actual row count: 0
      missing stats
      table: abc@abc_pkey
      spans: FULL SCAN

# Try injecting a hint between prepare and execute.

statement ok
SET tracing = on

statement ok
PREPARE p2 AS SELECT c + 1 FROM abc WHERE b > $1

statement ok
SET tracing = off

query empty
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT c + _ FROM abc WHERE b > _',
  'SELECT c + _ FROM abc@{FORCE_INDEX=abc_pkey,DESC} WHERE b > _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
EXECUTE p2 (5)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints

query T
EXPLAIN ANALYZE EXECUTE p2 (5)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• render
│ execution time: 0µs
│ actual row count: 0
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: b > 5
    │
    └── • revscan
          sql nodes: <hidden>
          kv nodes: <hidden>
          regions: <hidden>
          KV time: 0µs
          KV rows decoded: 0
          actual row count: 0
          missing stats
          table: abc@abc_pkey
          spans: FULL SCAN

# Try removing an injected hint between prepare and execute.

# (Re-use p1.)
statement count 1
DELETE FROM system.statement_hints WHERE row_id = $hint_p1

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
EXECUTE p1 (6)

statement ok
SET tracing = off

query empty
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'

query T
EXPLAIN ANALYZE EXECUTE p1 (6)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
regions: <hidden>
·
• filter
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ filter: b > 6
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 0
      actual row count: 0
      missing stats
      table: abc@abc_pkey
      spans: FULL SCAN

# Check that we do not use an invalid index hint injected into a prepared
# statement.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT sum(a) FROM abc WHERE c = _',
  'SELECT sum(a) FROM abc@abc_foo WHERE c = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
PREPARE p3 AS SELECT sum(a) FROM abc WHERE c = $1

statement ok
EXECUTE p3 (5)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
injected hints from external statement hint x
trying preparing with injected hints
preparing with injected hints failed with: index "abc_foo" not found
falling back to preparing without injected hints
trying planning with injected hints
planning with injected hints failed with: index "abc_foo" not found
falling back to planning without injected hints

query T
EXPLAIN ANALYZE EXECUTE p3 (5)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• group (scalar)
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 1
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: c = 5
    │
    └── • scan
          sql nodes: <hidden>
          kv nodes: <hidden>
          regions: <hidden>
          KV time: 0µs
          KV rows decoded: 0
          actual row count: 0
          missing stats
          table: abc@abc_pkey
          spans: FULL SCAN

# Check that we do not use an unsatisfiable hint injected into a prepared
# statement.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT max(a) FROM abc WHERE (b = _) AND (c = _)',
  'SELECT max(a) FROM abc@{FORCE_ZIGZAG} WHERE (b = _) AND (c = _)'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
PREPARE p4 AS SELECT max(a) FROM abc WHERE b = $1 AND c = $2

statement ok
EXECUTE p4 (5, 6)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
injected hints from external statement hint x
trying preparing with injected hints
trying planning with injected hints
planning with injected hints failed with: could not produce a query plan conforming to the FORCE_ZIGZAG hint
falling back to planning without injected hints

query T
EXPLAIN ANALYZE EXECUTE p4 (5, 6)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• group (scalar)
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 1
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: c = 6
    │
    └── • index join (streamer)
        │ sql nodes: <hidden>
        │ regions: <hidden>
        │ KV time: 0µs
        │ KV rows decoded: 0
        │ actual row count: 0
        │ table: abc@abc_pkey
        │
        └── • scan
              sql nodes: <hidden>
              kv nodes: <hidden>
              regions: <hidden>
              KV time: 0µs
              KV rows decoded: 0
              actual row count: 0
              missing stats
              table: abc@abc_b_idx
              spans: [/5 - /5]

# Check that we can inject hints into generic query plans.

statement ok
SET plan_cache_mode = force_generic_plan

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a * _ FROM abc WHERE b > _',
  'SELECT a * _ FROM abc@abc_pkey WHERE b > _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
PREPARE p5 AS SELECT a * 2 FROM abc WHERE b > $1

statement ok
EXECUTE p5 (5)

statement ok
EXECUTE p5 (6)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%' OR message LIKE '%(generic)%'
----
injected hints from external statement hint x
injected hints from external statement hint x
trying preparing with injected hints
trying planning with injected hints
optimizing (generic)
trying planning with injected hints

query T
EXPLAIN ANALYZE EXECUTE p5 (6)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, reused
statement hints count: 1
regions: <hidden>
·
• render
│ execution time: 0µs
│ actual row count: 0
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: b > 6
    │
    └── • scan
          sql nodes: <hidden>
          kv nodes: <hidden>
          regions: <hidden>
          KV time: 0µs
          KV rows decoded: 0
          actual row count: 0
          missing stats
          table: abc@abc_pkey
          spans: FULL SCAN

# Check that we can inject hints when using plan_cache_mode=auto.

statement ok
SET plan_cache_mode = auto

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT a - b FROM abc WHERE b = _',
  'SELECT a - b FROM abc@abc_pkey WHERE b = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
PREPARE p6 AS SELECT a - b FROM abc WHERE b = $1

statement ok
EXECUTE p6 (5)

statement ok
EXECUTE p6 (6)

statement ok
EXECUTE p6 (7)

statement ok
EXECUTE p6 (8)

statement ok
EXECUTE p6 (9)

statement ok
EXECUTE p6 (10)

statement ok
EXECUTE p6 (11)

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%' OR message LIKE '%(generic)%'
----
injected hints from external statement hint x
injected hints from external statement hint x
trying preparing with injected hints
trying planning with injected hints
trying planning with injected hints
trying planning with injected hints
trying planning with injected hints
trying planning with injected hints
trying planning with injected hints
optimizing (generic)
trying planning with injected hints

query T
EXPLAIN ANALYZE EXECUTE p6 (11)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, reused
statement hints count: 1
regions: <hidden>
·
• render
│ execution time: 0µs
│ actual row count: 0
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: b = 11
    │
    └── • scan
          sql nodes: <hidden>
          kv nodes: <hidden>
          regions: <hidden>
          KV time: 0µs
          KV rows decoded: 0
          actual row count: 0
          missing stats
          table: abc@abc_pkey
          spans: FULL SCAN

statement ok
RESET plan_cache_mode

statement ok
DEALLOCATE ALL

# If there are multiple hint injections for the same fingerprint, we should
# always pick the newest one.

query T
EXPLAIN SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
distribution: local
·
• lookup join
│ table: xy@xy_pkey
│ equality: (b) = (x)
│ equality cols are key
│
└── • scan
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT y FROM abc JOIN xy ON x = b WHERE a = _',
  'SELECT y FROM abc INNER HASH JOIN xy ON x = b WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

query T
EXPLAIN SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
distribution: local
statement hints count: 1
·
• hash join
│ equality: (b) = (x)
│ left cols are key
│ right cols are key
│
├── • scan
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

query T
EXPLAIN ANALYZE SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
rows decoded from KV: 1 (8 B, 2 KVs, 1 gRPC calls)
regions: <hidden>
·
• hash join
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ equality: (b) = (x)
│ left cols are key
│ right cols are key
│
├── • scan
│     sql nodes: <hidden>
│     kv nodes: <hidden>
│     regions: <hidden>
│     KV time: 0µs
│     KV rows decoded: 0
│     actual row count: 0
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 1
      actual row count: 1
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT y FROM abc JOIN xy ON x = b WHERE a = _',
  'SELECT y FROM abc@abc_b_idx JOIN xy ON x = b WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

query T
EXPLAIN SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
distribution: local
statement hints count: 1
·
• lookup join
│ table: xy@xy_pkey
│ equality: (b) = (x)
│ equality cols are key
│
└── • filter
    │ filter: a = 10
    │
    └── • scan
          missing stats
          table: abc@abc_b_idx
          spans: FULL SCAN

query T
EXPLAIN ANALYZE SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
statement hints count: 1
regions: <hidden>
·
• lookup join (streamer)
│ sql nodes: <hidden>
│ regions: <hidden>
│ KV time: 0µs
│ KV rows decoded: 0
│ execution time: 0µs
│ actual row count: 0
│ table: xy@xy_pkey
│ equality: (b) = (x)
│ equality cols are key
│
└── • filter
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 0
    │ filter: a = 10
    │
    └── • scan
          sql nodes: <hidden>
          kv nodes: <hidden>
          regions: <hidden>
          KV time: 0µs
          KV rows decoded: 0
          actual row count: 0
          missing stats
          table: abc@abc_b_idx
          spans: FULL SCAN

# Even if the newest hint rewrite doesn't work for some reason, we should
# still only consider that newest hint rewrite.

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT y FROM abc JOIN xy ON x = b WHERE a = _',
  'SELECT y FROM abc JOIN xy@xy_z_idx ON x = b WHERE a = _'
)

statement ok
SELECT crdb_internal.await_statement_hints_cache()

statement ok
SET tracing = on

statement ok
SELECT y FROM abc JOIN xy ON x = b WHERE a = 10

statement ok
SET tracing = off

query T
SELECT regexp_replace(split_part(message, ': SELECT', 1), E'\\d+', 'x')
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%injected hints%'
----
injected hints from external statement hint x
trying planning with injected hints
planning with injected hints failed with: index "xy_z_idx" not found
falling back to planning without injected hints

query T
EXPLAIN SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
distribution: local
statement hints count: 1
·
• lookup join
│ table: xy@xy_pkey
│ equality: (b) = (x)
│ equality cols are key
│
└── • scan
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

query T
EXPLAIN ANALYZE SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
statement hints count: 1
regions: <hidden>
·
• lookup join (streamer)
│ sql nodes: <hidden>
│ regions: <hidden>
│ KV time: 0µs
│ KV rows decoded: 0
│ execution time: 0µs
│ actual row count: 0
│ table: xy@xy_pkey
│ equality: (b) = (x)
│ equality cols are key
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 0
      actual row count: 0
      missing stats
      table: abc@abc_pkey
      spans: [/10 - /10]

# If there are multiple hint rewrites for the same fingerprint added in the
# same transaction, we should pick the last one added.

statement ok
BEGIN

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT y FROM abc JOIN xy ON x = b WHERE a = _',
  'SELECT y FROM abc JOIN xy@xy_y_idx ON x = b WHERE a = _'
)

statement ok
SELECT information_schema.crdb_rewrite_inline_hints(
  'SELECT y FROM abc JOIN xy ON x = b WHERE a = _',
  'SELECT y FROM abc INNER MERGE JOIN xy ON x = b WHERE a = _'
)

statement ok
COMMIT

statement ok
SELECT crdb_internal.await_statement_hints_cache()

query T
EXPLAIN SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
distribution: local
statement hints count: 1
·
• merge join
│ equality: (b) = (x)
│ left cols are key
│ right cols are key
│
├── • scan
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

query T
EXPLAIN ANALYZE SELECT y FROM abc JOIN xy ON x = b WHERE a = 10
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
statement hints count: 1
rows decoded from KV: 1 (8 B, 2 KVs, 1 gRPC calls)
regions: <hidden>
·
• merge join
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ equality: (b) = (x)
│ left cols are key
│ right cols are key
│
├── • scan
│     sql nodes: <hidden>
│     kv nodes: <hidden>
│     regions: <hidden>
│     KV time: 0µs
│     KV rows decoded: 0
│     actual row count: 0
│     missing stats
│     table: abc@abc_pkey
│     spans: [/10 - /10]
│
└── • scan
      sql nodes: <hidden>
      kv nodes: <hidden>
      regions: <hidden>
      KV time: 0µs
      KV rows decoded: 1
      actual row count: 1
      missing stats
      table: xy@xy_pkey
      spans: FULL SCAN

# Test error handling for information_schema.crdb_rewrite_inline_hints.

statement error pq: could not parse statement fingerprint as a single SQL statement
SELECT information_schema.crdb_rewrite_inline_hints('', '')

statement error pq: could not parse hint donor statement as a single SQL statement
SELECT information_schema.crdb_rewrite_inline_hints('SELECT 1', 'SELECT 2; SELECT 3')

# Test privilege checks for information_schema.crdb_rewrite_inline_hints.

user testuser

statement error user testuser does not have REPAIRCLUSTER system privilege
SELECT information_schema.crdb_rewrite_inline_hints('SELECT _', 'SELECT _')

user root

statement ok
GRANT SYSTEM REPAIRCLUSTER TO testuser

user testuser

statement ok
SELECT information_schema.crdb_rewrite_inline_hints('SELECT _', 'SELECT _')

user root

# Test for #160308, in which ROWS FROM is added to the fingerprint.

query T noticetrace
SELECT crdb_internal.inject_hint(
  'SELECT * FROM abc JOIN (SELECT i FROM generate_series(_, _) g(i)) ON b = i',
  'SELECT * FROM abc INNER MERGE JOIN (SELECT i FROM generate_series(_, _) g(i)) ON b = i'
)
----
NOTICE: statement fingerprint changed to: SELECT * FROM abc JOIN (SELECT i FROM ROWS FROM (generate_series(_, _)) AS g (i)) ON b = i
NOTICE: hint donor statement changed to: SELECT * FROM abc INNER MERGE JOIN (SELECT i FROM ROWS FROM (generate_series(_, _)) AS g (i)) ON b = i

query TT
SELECT fingerprint, hint_type
FROM [SHOW STATEMENT HINTS FOR 'SELECT * FROM abc JOIN (SELECT i FROM ROWS FROM (generate_series(_, _)) AS g (i)) ON b = i']
----
SELECT * FROM abc JOIN (SELECT i FROM ROWS FROM (generate_series(_, _)) AS g (i)) ON b = i  rewrite_inline_hints

statement ok
SELECT crdb_internal.await_statement_hints_cache()

query T
EXPLAIN
SELECT * FROM abc
JOIN (SELECT i FROM generate_series(1, 1) g(i))
ON b = i
----
distribution: local
statement hints count: 1
·
• merge join
│ equality: (b) = (generate_series)
│
├── • sort
│   │ order: +b
│   │
│   └── • scan
│         missing stats
│         table: abc@abc_pkey
│         spans: FULL SCAN
│
└── • sort
    │ estimated row count: 10
    │ order: +generate_series
    │
    └── • project set
        │ estimated row count: 10
        │
        └── • emptyrow

query T
EXPLAIN ANALYZE
SELECT * FROM abc
JOIN (SELECT i FROM generate_series(1, 1) g(i))
ON b = i
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: custom
statement hints count: 1
regions: <hidden>
·
• merge join
│ sql nodes: <hidden>
│ regions: <hidden>
│ execution time: 0µs
│ actual row count: 0
│ equality: (b) = (generate_series)
│
├── • sort
│   │ sql nodes: <hidden>
│   │ regions: <hidden>
│   │ execution time: 0µs
│   │ actual row count: 0
│   │ order: +b
│   │
│   └── • scan
│         sql nodes: <hidden>
│         kv nodes: <hidden>
│         regions: <hidden>
│         KV time: 0µs
│         KV rows decoded: 0
│         actual row count: 0
│         missing stats
│         table: abc@abc_pkey
│         spans: FULL SCAN
│
└── • sort
    │ sql nodes: <hidden>
    │ regions: <hidden>
    │ execution time: 0µs
    │ actual row count: 1
    │ estimated row count: 10
    │ order: +generate_series
    │
    └── • project set
        │ sql nodes: <hidden>
        │ regions: <hidden>
        │ execution time: 0µs
        │ actual row count: 1
        │ estimated row count: 10
        │
        └── • emptyrow
              sql nodes: <hidden>
              regions: <hidden>
              execution time: 0µs
              actual row count: 1

# Test the sql.query.with_statement_hints.count metric.

query B
SELECT value > 0
FROM crdb_internal.node_metrics
WHERE name = 'sql.query.with_statement_hints.count'
----
true

let $initial_hints_count
SELECT value::int
FROM crdb_internal.node_metrics
WHERE name = 'sql.query.with_statement_hints.count'

statement ok
SELECT y FROM abc JOIN xy ON x = b WHERE a = 10

query B
SELECT value::int > $initial_hints_count
FROM crdb_internal.node_metrics
WHERE name = 'sql.query.with_statement_hints.count'
----
true
