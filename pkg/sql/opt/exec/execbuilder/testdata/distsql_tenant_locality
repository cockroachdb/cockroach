# LogicTest: 3node-tenant-multiregion

# Create a table on the secondary tenant.
statement ok
CREATE TABLE t (k INT PRIMARY KEY, v INT, FAMILY (k, v))

# Split the ranges in the table.
statement ok
ALTER TABLE t SPLIT AT SELECT generate_series(1, 6)

# Relocate ranges in the admin tenant so that
# - [1-2) and [2-3) are on node 2
# - [3-4) and [4-5) are on node 3
# - [5-6) and [6-7) are on node 1.
user host-cluster-root

statement ok
ALTER RANGE RELOCATE LEASE TO 2 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%1';
ALTER RANGE RELOCATE LEASE TO 2 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%2';
ALTER RANGE RELOCATE LEASE TO 3 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%3';
ALTER RANGE RELOCATE LEASE TO 3 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%4';
ALTER RANGE RELOCATE LEASE TO 1 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%5';
ALTER RANGE RELOCATE LEASE TO 1 FOR SELECT range_id FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%6';

# Check range lease holders in the admin tenant.
query TI rowsort,retry
SELECT start_pretty, lease_holder FROM crdb_internal.ranges WHERE start_pretty LIKE '%Tenant%Table%/1/%'
----
/Tenant/10/Table/10002/1/1  2
/Tenant/10/Table/10002/1/2  2
/Tenant/10/Table/10002/1/3  3
/Tenant/10/Table/10002/1/4  3
/Tenant/10/Table/10002/1/5  1
/Tenant/10/Table/10002/1/6  1

user root

# Populate the range cache.
statement ok
SELECT * FROM t

# Check sql instance locality in the secondary tenant.
query IT
SELECT id, locality FROM system.sql_instances WHERE locality IS NOT NULL ORDER BY id
----
1  {"Tiers": "region=test"}
2  {"Tiers": "region=test1"}
3  {"Tiers": "region=test2"}

# Ensure that we plan TableReaders in the regions according to the leaseholder
# of each range, namely we want
# - TableReader on SQL Instance 2 to scan Span /106/1/1/0
# - TableReader on SQL Instance 3 to scan Span /106/1/3/0
# - TableReader on SQL Instance 1 to scan Span /106/1/5/0.
query T
EXPLAIN (DISTSQL) SELECT * FROM t WHERE k IN (1, 3, 5)
----
distribution: full
vectorized: true
·
• scan
  missing stats
  table: t@t_pkey
  spans: [/1 - /1] [/3 - /3] [/5 - /5]
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJycklFv0zAQgN_5FdY9MeQqdsJe_ARag4jUdaOpBBKqJhPfStQ0DrbDmKr8d2QXWBuyqY0fKp3v-t2XO-_A_qhAQPrldvY-m5PX0yxf5p9mFyRPZ-nVkrwhHxY318SRzx_TRUo2xBdxShJKLi-AQq0VzuUWLYivwIFCDBQSWFFojC7QWm18ahcKM_ULBKNQ1k3r_PWKQqENgtiBK12FIGApv1W4QKnQRJ6l0MmyCnj3zt01G3wECle6are1FWRDyU-gkDfSRxFnjMURjy4jBquOgm7dUyvr5BpB8AO3bAoi7ugzek9Wba2NQoPqyGjVDXzAXE90EyW9wmGVuKeSHKnw0yfFRk-KnzEpdqQXn67HR-slZ-jxZxc5oLdA2-ja4kl7Yr1OE-43j2qN-2didWsKvDW6CLX78CaAwoVC6_ZZvg-yOqS472BQbv-9w0MSf5H09ojEDkmsT4rHOv1HSsaSwsTuK_1wVyoQwP6cycDP3wP-D3Jt_dry7_ohYJePjR_6vawsUriWG5yiQ7Mt69K6sgDhTItd9-p3AAAA__9j7IkE

# Ensure that a single scan that touches multiple ranges is represented by a
# single span after physical planning. We expect to only have a single
# TableReader on node 3.
query T
EXPLAIN (DISTSQL) SELECT * FROM t WHERE k >= 3 AND k < 5
----
distribution: full
vectorized: true
·
• scan
  missing stats
  table: t@t_pkey
  spans: [/3 - /4]
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJyMUe9r2zAQ_b6_QrxPzVCwlNAvgsFK4zFDmnaxYYPNFM2-ZsY_5EnyuhL8vw_ba5aWLet9ELp3d-89nfZw3ysohJ9u1hfRhp2tojiJP6xnLA7X4WXCXrN32-sr5tnH9-E2ZGcl-9IJsaQ3bDljF5vVAcnY-Qwcjclpo2tyUJ8hwbFEytFak5Fzxg7wfmyK8p9QgqNo2s4PcMqRGUtQe_jCVwSFjZmbNhhYcvK6qMa2nsN0_s-Q83pHUIsjlWgFJXt-JCRPCyX6a0Vb0jnZQDyRg3_rb9uSHsBxaaqubpxiJWc_wBG3esgCKYRYBDJYzg_Xc_zLp3zmUzzx-Z-FbMm1pnH0oo2IZ0pz2acclO9o-gVnOpvRjTXZ2Dul1yPRCOTk_FRdTEnUPJact6Trg_1jJnmSSZxiSjnuKnN_W-RQEL9j_pfjMTAM6J0bVhR_M_cjbfLQDg-805Ujjitd0oo82bpoCueLDMrbjvr-1a8AAAD__2vy7YU=

# Ensure that a query with a LIMIT is planned on the instance that is the
# "leaseholder" of the first range touched by the scan. We expect to only have a
# single TableReader on node 2.
query T
EXPLAIN (DISTSQL) SELECT * FROM t WHERE k >= 1 LIMIT 10
----
distribution: full
vectorized: true
·
• scan
  missing stats
  table: t@t_pkey
  spans: [/1 - ]
  limit: 10
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJyMUV2L1DAUffdXhPOkkqFJfQsIyk7FQmd2nRYUdFhie3cM0zY1SV2Xof9d2u7q7KDj3oeQ-3XOyckB_nsNheTTVfY2XbPnyzQv8g_ZC5YnWXJRsJfs3eZyxQL7-D7ZJGzPvvRCvKLXTLIsXaUFkwIcra1orRvyUJ8hwRFjy9E5W5L31o3lwzSUVj-hBIdpuz6M5S1HaR1BHRBMqAkKa7uwXTSiVBS0qaexgcP24c-SD3pHUPERS7qEkgM_IpLniQr9taYN6YpcJB7RIbwJ192e7sBxYeu-ab1ie85-gCPv9JhFUggRRzKSi_trDI7MNCaMnvxLsDwRLB4J_o8zG_KdbT09yRpxwrSQw5aDqh3N3-Ft70q6cracZuf0cgKaChX5MHfjOUnbh5YPjnTzW_4xkjyLJM4hbTluant7bSooiPtY_OV4CIwLeudHi_Jv9naCLe668YE3uvbEsdJ7WlIg15jW-GBKqOB6GoZnvwIAAP__as3t0Q==


# Regression test for #93887 - don't panic when generating index recommendations
# with a mix of local and remote partitions.
statement ok
CREATE TABLE t93887 (x INT PRIMARY KEY, y INT) PARTITION BY LIST (x) (
    PARTITION p1 VALUES IN (1),
    PARTITION p2 VALUES IN (2),
    PARTITION p3 VALUES IN (3)
)

statement ok
ALTER PARTITION p1 OF TABLE t93887 CONFIGURE ZONE USING constraints='[+region=test]';
ALTER PARTITION p2 OF TABLE t93887 CONFIGURE ZONE USING constraints='[+region=test1]';
ALTER PARTITION p3 OF TABLE t93887 CONFIGURE ZONE USING constraints='[+region=test2]'

statement ok
SET index_recommendations_enabled = true;

query T retry
EXPLAIN SELECT * FROM t93887 WHERE y = 1
----
distribution: local
vectorized: true
·
• filter
│ filter: y = 1
│
└── • scan
      missing stats
      table: t93887@t93887_pkey
      spans: FULL SCAN
·
index recommendations: 1
1. type: index creation
   SQL command: CREATE INDEX ON test.public.t93887 (y);

statement ok
RESET index_recommendations_enabled;
