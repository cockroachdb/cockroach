# LogicTest: local

# ------------------------------------------------------------------------------
# Test index selection for deeply interleaved tables.
# These tests are in their own file because table IDs appear in EXPLAIN output.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE level1 (
  k1 INT,
  PRIMARY KEY (k1)
)

statement ok
CREATE TABLE level2 (
  k1 INT,
  PRIMARY KEY (k1),
  CONSTRAINT fk1 FOREIGN KEY (k1) REFERENCES level1
) INTERLEAVE IN PARENT level1 (k1)

statement ok
CREATE TABLE level3 (
  k1 INT,
  k2 INT,
  k3 INT,
  PRIMARY KEY (k1, k2, k3),
  CONSTRAINT fk2 FOREIGN KEY (k1) REFERENCES level2
) INTERLEAVE IN PARENT level2 (k1)

statement ok
CREATE TABLE level4 (
  k1 INT,
  k2 INT,
  k3 INT,
  FAMILY (k1, k2, k3),
  PRIMARY KEY (k1, k2, k3),
  CONSTRAINT fk3 FOREIGN KEY (k1, k2, k3) REFERENCES level3
) INTERLEAVE IN PARENT level3 (k1, k2, k3)

query T
EXPLAIN SELECT * FROM level4
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: level4@primary
  spans: FULL SCAN

# The span below ends at the end of the first index of table 53, and is not
# constraining the value of k2 or k3. This is confusing on first glance because
# the second interleave in the hierarchy doesn't contain any new primary key
# columns on top of the first interleave.
query T
SELECT info FROM [
  EXPLAIN (VERBOSE) SELECT * FROM level4 WHERE k1 > 1 AND k1 < 3
] WHERE info LIKE '%spans%'
----
  spans: /2/#/54/1/#/55/1-/2/#/54/1/#/55/2

query T
SELECT info FROM [
  EXPLAIN (VERBOSE) SELECT * FROM level4 WHERE k1 = 2 AND k2 > 10 AND k2 < 30
] WHERE info LIKE '%spans%'
----
  spans: /2/#/54/1/#/55/1/11-/2/#/54/1/#/55/1/30

query T
SELECT info FROM [
  EXPLAIN (VERBOSE) SELECT * FROM level4 WHERE k1 = 2 AND k2 = 20 AND k3 > 100 AND k3 < 300
] WHERE info LIKE '%spans%'
----
  spans: /2/#/54/1/#/55/1/20/101/#/56/1-/2/#/54/1/#/55/1/20/299/#/56/1/#

query T
SELECT info FROM [
  EXPLAIN (VERBOSE) SELECT * FROM level4 WHERE k1 = 2 AND k2 = 20 AND k3 = 200
] WHERE info LIKE '%spans%'
----
  spans: /2/#/54/1/#/55/1/20/200/#/56/1/0

# ------------------------------------------------------------------------------
# Trace of interleaved fetches from interesting interleaved hierarchy.
# ------------------------------------------------------------------------------
# Grandparent table
statement ok
CREATE TABLE p2 (i INT PRIMARY KEY, s STRING)

# Two tables interleaved at the same level
statement ok
CREATE TABLE p1_0 (
  i INT,
  s1 STRING,
  s2 STRING,
  d DECIMAL,
  PRIMARY KEY (i, s1),
  FAMILY (i, s1, s2),
  FAMILY (d)
) INTERLEAVE IN PARENT p2 (i)

statement ok
CREATE TABLE p1_1 (
  i INT PRIMARY KEY,
  s1 STRING,
  s2 STRING,
  d DECIMAL
) INTERLEAVE IN PARENT p2 (i)

# Two level deep interleave
statement ok
CREATE TABLE p0 (
  i INT,
  s1 STRING,
  s2 STRING,
  d DECIMAL,
  PRIMARY KEY (i, s1, s2)
) INTERLEAVE IN PARENT p1_0 (i, s1)

statement ok
INSERT INTO p2 VALUES (2, '2'), (3, '3'), (5, '5'), (7, '7')

statement ok
INSERT INTO p1_0 VALUES (2, '2', '2.01', 2), (3, '3', '3.01', 3), (5, '5', NULL, NULL)

statement ok
INSERT INTO p1_1 VALUES (2, '2', '2.11', 2), (3, '3', '3.11', 3)

statement ok
INSERT INTO p0 VALUES (2, '2', '2.0', 2), (3, '3', '3.0', 3), (5, '5', '5.0', 5)

statement ok
SET tracing = on,kv,results; SELECT * FROM p1_0; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /p1_0/primary/2/'2'/s2 -> /'2.01'
fetched: /p1_0/primary/2/'2'/d -> 2
fetched: /p1_0/primary/3/'3'/s2 -> /'3.01'
fetched: /p1_0/primary/3/'3'/d -> 3
fetched: /p1_0/primary/5/'5' -> NULL
output row: [2 '2' '2.01' 2]
output row: [3 '3' '3.01' 3]
output row: [5 '5' NULL NULL]

# ------------------------------------------------------------------------------
# Test interleaved delete fast path.
# ------------------------------------------------------------------------------
subtest InterleavedDeleteFastPath

statement ok
CREATE TABLE a (
    a_id INT PRIMARY KEY
);

statement ok
CREATE TABLE b(
    b_id INT,
    a_id INT,
    FOREIGN KEY (a_id) REFERENCES a(a_id) ON UPDATE CASCADE ON DELETE CASCADE,
    PRIMARY KEY(a_id, b_id),
    FAMILY "primary" (a_id, b_id)
) INTERLEAVE IN PARENT a(a_id)

statement ok
CREATE TABLE c(
    c_id INT,
    a_id INT,
    b_id INT,
    FOREIGN KEY (a_id, b_id) REFERENCES b(a_id, b_id) ON UPDATE CASCADE ON DELETE CASCADE,
    PRIMARY KEY(a_id, b_id, c_id),
    FAMILY "primary" (a_id, b_id, c_id)
) INTERLEAVE IN PARENT b(a_id, b_id)

statement ok
INSERT INTO a SELECT generate_series(1,10);
INSERT INTO b(a_id, b_id) SELECT generate_series(1,10), 1

statement ok
DELETE FROM a WHERE a_id <= 2

query I
SELECT count(*) from a
----
8

query I
SELECT count(*) from b
----
8

query I colnames
SELECT * from a order by a_id
----
a_id
3
4
5
6
7
8
9
10

query II colnames
SELECT * from b order by a_id, b_id
----
b_id  a_id
1     3
1     4
1     5
1     6
1     7
1     8
1     9
1     10

statement ok
INSERT INTO b(a_id, b_id) select a.a_id, 2 from a;
INSERT INTO c(a_id, b_id, c_id) select a.a_id, b.b_id, 1 from a, b where a.a_id = b.a_id

query III colnames
SELECT * from c order by a_id, b_id, c_id
----
c_id  a_id  b_id
1     3     1
1     3     2
1     4     1
1     4     2
1     5     1
1     5     2
1     6     1
1     6     2
1     7     1
1     7     2
1     8     1
1     8     2
1     9     1
1     9     2
1     10    1
1     10    2

statement ok
SET TRACING = on,kv,results; DELETE FROM a where a_id <= 7 and a_id >= 5; SET tracing = off

# Only look at traces from SQL land.
query T
SELECT message FROM [SHOW KV TRACE FOR SESSION]
WHERE operation='batch flow coordinator' OR operation='exec stmt'
----
DelRange /Table/61/1/5 - /Table/61/1/7/NULL
fast path completed
rows affected: 3

query II colnames
select * from b order by a_id, b_id
----
b_id  a_id
1     3
2     3
1     4
2     4
1     8
2     8
1     9
2     9
1     10
2     10

query III colnames
select * from c order by a_id, b_id, c_id
----
c_id  a_id  b_id
1     3     1
1     3     2
1     4     1
1     4     2
1     8     1
1     8     2
1     9     1
1     9     2
1     10    1
1     10    2

statement ok
SET TRACING = on,kv,results; DELETE FROM a; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION]
WHERE operation='batch flow coordinator' OR operation='exec stmt'
----
DelRange /Table/61/1 - /Table/61/3
fast path completed
rows affected: 5

query II colnames
select * from b order by a_id, b_id
----
b_id  a_id

query III colnames
select * from c order by a_id, b_id, c_id
----
c_id  a_id  b_id

statement ok
DROP TABLE c; DROP TABLE b; DROP TABLE a

statement ok
CREATE TABLE table0 (c0 INT, PRIMARY KEY (c0));
CREATE TABLE table1 (c0 INT, c1 INT, PRIMARY KEY (c0, c1)) INTERLEAVE IN PARENT table0 (c0);
CREATE TABLE table2 (c0 INT, c1 INT, c2 INT, PRIMARY KEY (c0, c1, c2)) INTERLEAVE IN PARENT table1 (c0, c1);
INSERT INTO table0 SELECT i FROM generate_series(1, 10) AS i;
INSERT INTO table1 SELECT (i-1)//10+1, i FROM generate_series(1, 100) AS i;
INSERT INTO table2 SELECT (i-1)//100+1, (i-1)//10+1, i FROM generate_series(1, 1000) AS i;

query T
EXPLAIN SELECT count(*) FROM table1 INNER MERGE JOIN table2 USING(c0, c1) WHERE c1 >= 25 AND c1 < 75
----
distribution: local
vectorized: true
·
• group (scalar)
│
└── • merge join
    │ equality: (c0, c1) = (c0, c1)
    │ left cols are key
    │
    ├── • filter
    │   │ filter: (c1 >= 25) AND (c1 < 75)
    │   │
    │   └── • scan
    │         missing stats
    │         table: table1@primary
    │         spans: FULL SCAN
    │
    └── • filter
        │ filter: (c1 >= 25) AND (c1 < 75)
        │
        └── • scan
              missing stats
              table: table2@primary
              spans: FULL SCAN
