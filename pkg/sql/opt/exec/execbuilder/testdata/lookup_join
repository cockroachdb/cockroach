# LogicTest: 5node

statement ok
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, c))

statement ok
CREATE TABLE def (d INT, e INT, f INT, PRIMARY KEY (f, e))

# Set up the statistics as if the first table is much smaller than the second.
# This will make lookup join into the second table be the best plan.
statement ok
ALTER TABLE abc INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE def INJECT STATISTICS '[
  {
    "columns": ["f"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b
----
tree         field        description  columns             ordering
·            distributed  true         ·                   ·
·            vectorized   true         ·                   ·
lookup-join  ·            ·            (a, b, c, d, e, f)  ·
 │           table        def@primary  ·                   ·
 │           type         inner        ·                   ·
 │           equality     (b) = (f)    ·                   ·
 └── scan    ·            ·            (a, b, c)           ·
·            table        abc@primary  ·                   ·
·            spans        FULL SCAN    ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b AND e = c
----
tree         field                  description      columns             ordering
·            distributed            true             ·                   ·
·            vectorized             true             ·                   ·
lookup-join  ·                      ·                (a, b, c, d, e, f)  ·
 │           table                  def@primary      ·                   ·
 │           type                   inner            ·                   ·
 │           equality               (b, c) = (f, e)  ·                   ·
 │           equality cols are key  ·                ·                   ·
 │           parallel               ·                ·                   ·
 └── scan    ·                      ·                (a, b, c)           ·
·            table                  abc@primary      ·                   ·
·            spans                  FULL SCAN        ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b WHERE a > 1 AND e > 1
----
tree         field        description  columns             ordering
·            distributed  true         ·                   ·
·            vectorized   true         ·                   ·
lookup-join  ·            ·            (a, b, c, d, e, f)  ·
 │           table        def@primary  ·                   ·
 │           type         inner        ·                   ·
 │           equality     (b) = (f)    ·                   ·
 │           pred         @5 > 1       ·                   ·
 └── scan    ·            ·            (a, b, c)           ·
·            table        abc@primary  ·                   ·
·            spans        /2-          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = a WHERE f > 1
----
tree         field        description  columns             ordering
·            distributed  true         ·                   ·
·            vectorized   true         ·                   ·
lookup-join  ·            ·            (a, b, c, d, e, f)  ·
 │           table        def@primary  ·                   ·
 │           type         inner        ·                   ·
 │           equality     (a) = (f)    ·                   ·
 │           pred         @6 > 1       ·                   ·
 └── scan    ·            ·            (a, b, c)           ·
·            table        abc@primary  ·                   ·
·            spans        /2-          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b WHERE a >= e
----
tree         field        description  columns             ordering
·            distributed  true         ·                   ·
·            vectorized   true         ·                   ·
lookup-join  ·            ·            (a, b, c, d, e, f)  ·
 │           table        def@primary  ·                   ·
 │           type         inner        ·                   ·
 │           equality     (b) = (f)    ·                   ·
 │           pred         @1 >= @5     ·                   ·
 └── scan    ·            ·            (a, b, c)           ·
·            table        abc@primary  ·                   ·
·            spans        FULL SCAN    ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b AND a >= e
----
tree         field        description  columns             ordering
·            distributed  true         ·                   ·
·            vectorized   true         ·                   ·
lookup-join  ·            ·            (a, b, c, d, e, f)  ·
 │           table        def@primary  ·                   ·
 │           type         inner        ·                   ·
 │           equality     (b) = (f)    ·                   ·
 │           pred         @1 >= @5     ·                   ·
 └── scan    ·            ·            (a, b, c)           ·
·            table        abc@primary  ·                   ·
·            spans        FULL SCAN    ·                   ·

# Verify a distsql plan.
statement ok
CREATE TABLE data (a INT, b INT, c INT, d INT, PRIMARY KEY (a, b, c, d))

# Split into ten parts.
statement ok
ALTER TABLE data SPLIT AT SELECT i FROM generate_series(1, 9) AS g(i)

statement ok
ALTER TABLE data INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100000,
    "distinct_count": 100000
  }
]'

# Relocate the ten parts to the five nodes.
statement ok
ALTER TABLE data EXPERIMENTAL_RELOCATE
  SELECT ARRAY[i%5+1], i FROM generate_series(0, 9) AS g(i)

# Verify data placement.
query TTTI colnames,rowsort
SELECT start_key, end_key, replicas, lease_holder from [SHOW RANGES FROM TABLE data]
----
start_key  end_key  replicas  lease_holder
NULL       /1       {1}       1
/1         /2       {2}       2
/2         /3       {3}       3
/3         /4       {4}       4
/4         /5       {5}       5
/5         /6       {1}       1
/6         /7       {2}       2
/7         /8       {3}       3
/8         /9       {4}       4
/9         NULL     {5}       5

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM data WHERE c = 1) AS l NATURAL JOIN data AS r
----
·                 distributed            true                         ·                         ·
·                 vectorized             true                         ·                         ·
render            ·                      ·                            (a, b, c, d)              ·
 │                render 0               a                            ·                         ·
 │                render 1               b                            ·                         ·
 │                render 2               c                            ·                         ·
 │                render 3               d                            ·                         ·
 └── lookup-join  ·                      ·                            (a, b, c, d, a, b, c, d)  ·
      │           table                  data@primary                 ·                         ·
      │           type                   inner                        ·                         ·
      │           equality               (a, b, c, d) = (a, b, c, d)  ·                         ·
      │           equality cols are key  ·                            ·                         ·
      │           parallel               ·                            ·                         ·
      └── scan    ·                      ·                            (a, b, c, d)              ·
·                 table                  data@primary                 ·                         ·
·                 spans                  FULL SCAN                    ·                         ·
·                 filter                 c = 1                        ·                         ·

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT * FROM (SELECT * FROM data WHERE c = 1) AS l NATURAL JOIN data AS r]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzElNFq2zAUhu_3FIdz1Q4ZR7bTpoKBw5Yyl8zp4owNii-8-NB5cy1PlmEj5N2H40KTkMqGhOxSyvn5v3zHaIXV7xwFRpPp5P0CapXD7Xz2CR4m3-6n4yCEiw9BtIg-Ty_heeRtO3Cxe0wTncDXj5P5BJbwDvgljCPIIRwvvszHU7ibBWE7M45AxciwkCmFyRNVKB6QI0MHGbrI0EOGQ4wZlkouqaqkakZWm0CQ_kExYJgVZa2b65jhUipCsUKd6ZxQ4CL5ntOckpSUPUCGKekkyzc1DYBfquwpUX-RYVQmRSXAsjkkRQocpP5BChneZrkmJcB3m78ihAjCxQjjNUNZ65fmSiePhIKvWX-6O5kVz3BDI9xUyl91CT9lVoAsBPic-Q7zXeY3gma13r16Dc55Fe6FqS6kSklRugMUrw_gh9KSpc0He5OHu92dbt5_bbzP2mxu2c4JF9fBt7W4q_Mvzukvz-klz7Fs94TyOvi25F2fX57bX57bS55r2d4J5XXwbckbnV-e11-e10ueZ9nDE8rr4NuSd_N_39sDcHOqSllU1Os1HTTvMaWP1D7elazVku6VXG5q2uNsk9tcpFTp9lfeHoKi_akB3A5zY9jZCfP9sGNu7qh2jWnPHPaO4R4aw1fm5qtjmq-N4ZG5eXRM8415V4OOz8T8ke13x-s3_wIAAP__GbBJ9Q==

statement ok
CREATE TABLE books (title STRING, edition INT, shelf INT, PRIMARY KEY (title, edition))

statement ok
CREATE TABLE books2 (title STRING, edition INT, shelf INT, PRIMARY KEY (title, edition))

statement ok
ALTER TABLE books INJECT STATISTICS '[
  {
    "columns": ["title"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE books2 INJECT STATISTICS '[
  {
    "columns": ["title"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 1000
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT DISTINCT b1.title FROM books as b1 JOIN books2 as b2 ON b1.title = b2.title WHERE b1.shelf <> b2.shelf
----
tree                   field        description        columns                       ordering
·                      distributed  true               ·                             ·
·                      vectorized   true               ·                             ·
distinct               ·            ·                  (title)                       ·
 │                     distinct on  title              ·                             ·
 │                     order key    title              ·                             ·
 └── render            ·            ·                  (title)                       +title
      │                render 0     title              ·                             ·
      └── lookup-join  ·            ·                  (title, shelf, title, shelf)  +title
           │           table        books2@primary     ·                             ·
           │           type         inner              ·                             ·
           │           equality     (title) = (title)  ·                             ·
           │           pred         @2 != @4           ·                             ·
           └── scan    ·            ·                  (title, shelf)                +title
·                      table        books@primary      ·                             ·
·                      spans        FULL SCAN          ·                             ·

statement ok
CREATE TABLE authors (name STRING, book STRING)

statement ok
ALTER TABLE authors INJECT STATISTICS '[
  {
    "columns": ["name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT DISTINCT authors.name FROM books AS b1, books2 AS b2, authors WHERE b1.title = b2.title AND authors.book = b1.title AND b1.shelf <> b2.shelf
----
tree                      field        description        columns                                   ordering
·                         distributed  true               ·                                         ·
·                         vectorized   false              ·                                         ·
distinct                  ·            ·                  (name)                                    ·
 │                        distinct on  name               ·                                         ·
 └── render               ·            ·                  (name)                                    ·
      │                   render 0     name               ·                                         ·
      └── lookup-join     ·            ·                  (name, book, title, shelf, title, shelf)  ·
           │              table        books2@primary     ·                                         ·
           │              type         inner              ·                                         ·
           │              equality     (title) = (title)  ·                                         ·
           │              pred         @4 != @6           ·                                         ·
           └── hash-join  ·            ·                  (name, book, title, shelf)                ·
                │         type         inner              ·                                         ·
                │         equality     (book) = (title)   ·                                         ·
                ├── scan  ·            ·                  (name, book)                              ·
                │         table        authors@primary    ·                                         ·
                │         spans        FULL SCAN          ·                                         ·
                └── scan  ·            ·                  (title, shelf)                            ·
·                         table        books@primary      ·                                         ·
·                         spans        FULL SCAN          ·                                         ·

# Verify data placement.
query TTTI colnames
SELECT start_key, end_key, replicas, lease_holder from [SHOW RANGES FROM TABLE books]
----
start_key  end_key  replicas  lease_holder
NULL       NULL     {5}       5

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT DISTINCT authors.name FROM books AS b1, books2 AS b2, authors WHERE b1.title = b2.title AND authors.book = b1.title AND b1.shelf <> b2.shelf]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyck1Fv2jAQx9_3KW73lEhuwUnopEiVggpTmVjoAGmTKh4ScoWswc5sR9qE-O5TEioIKmHszee73_l_f9tb1L8y9HE2HA8f5lCoDD5PJ1_hefjjadwfhWANRrP57NvYhn1JGY_ChzlEhVlLpW9FtKEaiqV81dCfQcxZHThV5LC3Yvj-OJwOwbJifmtSkxHcQ-zUSxv64QCst7YlX2b3hfY-HfNbvabsBT5WZLW2F8hQyITCaEMa_WfkyLCHC4a5kkvSWqpye1sVjZLf6HcZpiIvTLm9YLiUitDfYnUU-hjKG5l3esgwIROlWVW2YygLc4C0iVaE_t2OHTXm7Y3nUZzRlKKEVKfbaI_7wYNcpZtI_UGGszwS2ocbZDgpjA8BZ4GD53Tw_9XBmzqqi7ugwj2rwjmr4nB4IaRKSFFy6u_lkndGeYz0-otMBamO05wkoxdjBY59r9LV2lgBtxtOssBlgXd2EvcaP0sBezvdd-x0jvwcS_la5PBTpgKk8CEogUkIgVe-6eDTQeNZad410gapNqlYmo7XFNbSv9fof-GvTEnnUmj6p8_SLW-QkhXVL0LLQi3pSclldUwdTiqu2khImzp7VwcjUadKgccwb4XdBsxPYecK2DmF3VbYa5fttcK9drjXCndP4MXuw98AAAD__wJn6Uo=

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT a.name FROM authors AS a JOIN books2 AS b2 ON a.book = b2.title ORDER BY a.name
----
tree                 field        description       columns              ordering
·                    distributed  true              ·                    ·
·                    vectorized   false             ·                    ·
render               ·            ·                 (name)               +name
 │                   render 0     name              ·                    ·
 └── lookup-join     ·            ·                 (name, book, title)  +name
      │              table        books2@primary    ·                    ·
      │              type         inner             ·                    ·
      │              equality     (book) = (title)  ·                    ·
      └── sort       ·            ·                 (name, book)         +name
           │         order        +name             ·                    ·
           └── scan  ·            ·                 (name, book)         ·
·                    table        authors@primary   ·                    ·
·                    spans        FULL SCAN         ·                    ·

# Cross joins should not be planned as lookup joins.
query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM books CROSS JOIN books2
----
tree             field        description     columns                                         ordering
·                distributed  true            ·                                               ·
·                vectorized   false           ·                                               ·
render           ·            ·               (title, edition, shelf, title, edition, shelf)  ·
 │               render 0     title           ·                                               ·
 │               render 1     edition         ·                                               ·
 │               render 2     shelf           ·                                               ·
 │               render 3     title           ·                                               ·
 │               render 4     edition         ·                                               ·
 │               render 5     shelf           ·                                               ·
 └── cross-join  ·            ·               (title, edition, shelf, title, edition, shelf)  ·
      │          type         cross           ·                                               ·
      ├── scan   ·            ·               (title, edition, shelf)                         ·
      │          table        books2@primary  ·                                               ·
      │          spans        FULL SCAN       ·                                               ·
      └── scan   ·            ·               (title, edition, shelf)                         ·
·                table        books@primary   ·                                               ·
·                spans        FULL SCAN       ·                                               ·

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT * FROM authors INNER JOIN books2 ON books2.edition = 1 WHERE books2.title = authors.book]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyUkd9r1EAQx9_9K4Z5Upm2l5wVWShENGLKmdTcgULJQ3o71LXpTtzdgHLc_y5J7vBOuGjfMj8-33yS2aD_0aDCZbpI362gcw18KItPcJt-vVm8zXJ4_j5brpafFy9gt_JyXKi78E2chyzP0xKuiyyHO5EHH0OxfzpnbYIRC1cQwZePaZnuB8GEhuFqH3LetysktKI5rx_Zo7rFCAkvsSJsnazZe3F9ezMsZfonqhmhsW0X-nZFuBbHqDY4hKPCXM6kvYiRUHOoTTOsbQmlC38gH-p7RjXf0kFwNB28qu8aLrnW7C5mR_G4-6Ckdeaxdr-QcNnW1is4Q8KSrWanIFJKZfnqDUESESQxnrKKnmJ1LcbupKJjqfGnHzgtRB66Fr6LsSBWQTKnpGeKLihIYurrV5RcUvL6pFt85PaPU5TsW7Ge_-sWs21FyPqex3N76dyab5ysh9eMZTFwQ0OzD-N0PhaZHUe94CEcTcLxNBxPwrO_4Gr77HcAAAD__0XeE20=

####################################
#  LOOKUP JOIN ON SECONDARY INDEX  #
####################################

statement ok
CREATE TABLE small (a INT PRIMARY KEY, b INT, c INT, d INT)

statement ok
CREATE TABLE large (a INT, b INT, c INT, d INT, PRIMARY KEY (a, b), INDEX bc (b) STORING (c))

statement ok
ALTER TABLE small SPLIT AT SELECT i FROM generate_series(1, 9) AS g(i)

statement ok
ALTER TABLE small EXPERIMENTAL_RELOCATE
  SELECT ARRAY[i%5+1], i FROM generate_series(0, 9) AS g(i)

statement ok
INSERT INTO small SELECT x, 2*x, 3*x, 4*x FROM
  generate_series(1, 10) AS a(x)

statement ok
ALTER TABLE small INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE large INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'

# Lookup join on covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.a, large.c FROM small JOIN large ON small.a = large.b
----
·                 distributed  true           ·          ·
·                 vectorized   true           ·          ·
render            ·            ·              (a, c)     ·
 │                render 0     a              ·          ·
 │                render 1     c              ·          ·
 └── lookup-join  ·            ·              (a, b, c)  ·
      │           table        large@bc       ·          ·
      │           type         inner          ·          ·
      │           equality     (a) = (b)      ·          ·
      └── scan    ·            ·              (a)        ·
·                 table        small@primary  ·          ·
·                 spans        FULL SCAN      ·          ·

# Lookup join on non-covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.a, large.d FROM small JOIN large ON small.a = large.b
----
·                      distributed            true             ·             ·
·                      vectorized             true             ·             ·
render                 ·                      ·                (a, d)        ·
 │                     render 0               a                ·             ·
 │                     render 1               d                ·             ·
 └── lookup-join       ·                      ·                (a, a, b, d)  ·
      │                table                  large@primary    ·             ·
      │                type                   inner            ·             ·
      │                equality               (a, b) = (a, b)  ·             ·
      │                equality cols are key  ·                ·             ·
      │                parallel               ·                ·             ·
      └── lookup-join  ·                      ·                (a, a, b)     ·
           │           table                  large@bc         ·             ·
           │           type                   inner            ·             ·
           │           equality               (a) = (b)        ·             ·
           └── scan    ·                      ·                (a)           ·
·                      table                  small@primary    ·             ·
·                      spans                  FULL SCAN        ·             ·

############################
#  LEFT OUTER LOOKUP JOIN  #
############################

# Left join against primary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.b, large.a FROM small LEFT JOIN large ON small.b = large.a
----
·            distributed  true           ·       ·
·            vectorized   true           ·       ·
lookup-join  ·            ·              (b, a)  ·
 │           table        large@primary  ·       ·
 │           type         left outer     ·       ·
 │           equality     (b) = (a)      ·       ·
 └── scan    ·            ·              (b)     ·
·            table        small@primary  ·       ·
·            spans        FULL SCAN      ·       ·

# Left join should preserve input order.
query TTTTT
EXPLAIN (VERBOSE) SELECT t1.a, t2.b FROM small t1 LEFT JOIN large t2 ON t1.a = t2.a AND t2.b % 6 = 0 ORDER BY t1.a
----
·                 distributed  true           ·          ·
·                 vectorized   true           ·          ·
render            ·            ·              (a, b)     +a
 │                render 0     a              ·          ·
 │                render 1     b              ·          ·
 └── lookup-join  ·            ·              (a, a, b)  +a
      │           table        large@primary  ·          ·
      │           type         left outer     ·          ·
      │           equality     (a) = (a)      ·          ·
      │           pred         (@3 % 6) = 0   ·          ·
      └── scan    ·            ·              (a)        +a
·                 table        small@primary  ·          ·
·                 spans        FULL SCAN      ·          ·

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT t1.a, t2.b FROM small t1 LEFT JOIN large t2 ON t1.a = t2.a AND t2.b % 6 = 0 ORDER BY t1.a]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlV9r2zwUxu_fT3E48ELClDqynTQVFNKtKaRkdud4sFF8ocai8-ZanizDSsl3H5YLdcpiG3yTu-jPk-c5vyN8XrD4nSLD7Wqz-hRCqVK4CfzPcL_6dre5Wnswul5vw-2XzRher2h6xglo--yhvlk88TSFqy1oCpvVTQi3_tqDlKtHYXZt8D0YVSq4rGR8DFfeNYxG5i_-h_kYLmE6Bj-4XgXw8bsxiJBgJmPh8SdRILtHigRtJOggQRcJzjAimCu5E0UhVXXlxQjW8R9kU4JJlpe62o4I7qQSyF5QJzoVyDDkD6kIBI-FsqZIMBaaJ6mxMcUsc5U8cfWMBLc5zwoGE4sCz2KgIPUPoZCgX2oGS4rRnqAs9ZtZofmjQEb3pH-gW5lkr3lmh3nC51ywGqv_NVwFBi4SNHgbOTdS_ipz-CmTDGRmkhGsuC-dCjFjbO2FC0P69fdbDWTpHC3DPlrGW3qpYqFEfBh8ST9gtP9HrZ6cyNyih9yP2TsH9rR_W2mvtlp0YtmDGtsRqdHY-Sk31u5P1u5H1p5YziCyHZEaZM9PmazTn6zTj6wzsdxBZDsiNcguTpms25-s24-sO7Fmg8h2RGqQvThlsh3TKhBFLrNC9PqCT6sZIOJHUc-MQpZqJ-6U3BmbeukbndmIRaHrU1ov1ll9VAVsimmr2D4Q0_diu925w9ppVbvtYndI7lmreN7uPB_ifN4qXrQ7L4Y4X7T3atrxTNof2XvvaP_f3wAAAP__d9J4OQ==

# Left join against covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.c FROM small LEFT JOIN large ON small.c = large.b
----
·                 distributed  true           ·          ·
·                 vectorized   true           ·          ·
render            ·            ·              (c, c)     ·
 │                render 0     c              ·          ·
 │                render 1     c              ·          ·
 └── lookup-join  ·            ·              (c, b, c)  ·
      │           table        large@bc       ·          ·
      │           type         left outer     ·          ·
      │           equality     (c) = (b)      ·          ·
      └── scan    ·            ·              (c)        ·
·                 table        small@primary  ·          ·
·                 spans        FULL SCAN      ·          ·

# Left join against non-covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.d FROM small LEFT JOIN large ON small.c = large.b
----
·                      distributed            true             ·             ·
·                      vectorized             true             ·             ·
render                 ·                      ·                (c, d)        ·
 │                     render 0               c                ·             ·
 │                     render 1               d                ·             ·
 └── lookup-join       ·                      ·                (c, a, b, d)  ·
      │                table                  large@primary    ·             ·
      │                type                   left outer       ·             ·
      │                equality               (a, b) = (a, b)  ·             ·
      │                equality cols are key  ·                ·             ·
      │                parallel               ·                ·             ·
      └── lookup-join  ·                      ·                (c, a, b)     ·
           │           table                  large@bc         ·             ·
           │           type                   left outer       ·             ·
           │           equality               (c) = (b)        ·             ·
           └── scan    ·                      ·                (c)           ·
·                      table                  small@primary    ·             ·
·                      spans                  FULL SCAN        ·             ·

# Left join with ON filter on covering index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.c FROM small LEFT JOIN large ON small.c = large.b AND large.c < 20
----
·                 distributed  true           ·          ·
·                 vectorized   true           ·          ·
render            ·            ·              (c, c)     ·
 │                render 0     c              ·          ·
 │                render 1     c              ·          ·
 └── lookup-join  ·            ·              (c, b, c)  ·
      │           table        large@bc       ·          ·
      │           type         left outer     ·          ·
      │           equality     (c) = (b)      ·          ·
      │           pred         @3 < 20        ·          ·
      └── scan    ·            ·              (c)        ·
·                 table        small@primary  ·          ·
·                 spans        FULL SCAN      ·          ·

# Left join with ON filter on non-covering index
# TODO(radu): this doesn't use lookup join yet, the current rules don't cover
# left join with ON condition on columns that are not covered by the index.
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.d FROM small LEFT JOIN large ON small.c = large.b AND large.d < 30
----
·               distributed  true           ·          ·
·               vectorized   false          ·          ·
render          ·            ·              (c, d)     ·
 │              render 0     c              ·          ·
 │              render 1     d              ·          ·
 └── hash-join  ·            ·              (b, d, c)  ·
      │         type         right outer    ·          ·
      │         equality     (b) = (c)      ·          ·
      ├── scan  ·            ·              (b, d)     ·
      │         table        large@primary  ·          ·
      │         spans        FULL SCAN      ·          ·
      │         filter       d < 30         ·          ·
      └── scan  ·            ·              (c)        ·
·               table        small@primary  ·          ·
·               spans        FULL SCAN      ·          ·

###########################################################
#  LOOKUP JOINS ON IMPLICIT INDEX KEY COLUMNS             #
#  https://github.com/cockroachdb/cockroach/issues/31777  #
###########################################################
statement ok
CREATE TABLE t (a INT, b INT, c INT, d INT, e INT)

statement ok
CREATE TABLE u (a INT, b INT, c INT, d INT, e INT, PRIMARY KEY (a DESC, b, c))

# Test index with all primary key columns implicit.
statement ok
CREATE INDEX idx ON u (d)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a WHERE t.e = 5
----
·                 distributed  true             ·                ·
·                 vectorized   true             ·                ·
render            ·            ·                (a)              ·
 │                render 0     a                ·                ·
 └── lookup-join  ·            ·                (a, d, e, a, d)  ·
      │           table        u@idx            ·                ·
      │           type         inner            ·                ·
      │           equality     (d, a) = (d, a)  ·                ·
      └── scan    ·            ·                (a, d, e)        ·
·                 table        t@primary        ·                ·
·                 spans        FULL SCAN        ·                ·
·                 filter       e = 5            ·                ·

# Test unique version of same index. (Lookup join should not use column a.)
statement ok
DROP INDEX u@idx

statement ok
CREATE UNIQUE INDEX idx ON u (d)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a WHERE t.e = 5
----
·                 distributed            true       ·                ·
·                 vectorized             true       ·                ·
render            ·                      ·          (a)              ·
 │                render 0               a          ·                ·
 └── lookup-join  ·                      ·          (a, d, e, a, d)  ·
      │           table                  u@idx      ·                ·
      │           type                   inner      ·                ·
      │           equality               (d) = (d)  ·                ·
      │           equality cols are key  ·          ·                ·
      │           parallel               ·          ·                ·
      │           pred                   @1 = @4    ·                ·
      └── scan    ·                      ·          (a, d, e)        ·
·                 table                  t@primary  ·                ·
·                 spans                  FULL SCAN  ·                ·
·                 filter                 e = 5      ·                ·

# Test index with first primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx CASCADE

statement ok
CREATE INDEX idx ON u (d, a)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.b = u.b WHERE t.e = 5
----
·                 distributed  true                   ·                      ·
·                 vectorized   true                   ·                      ·
render            ·            ·                      (a)                    ·
 │                render 0     a                      ·                      ·
 └── lookup-join  ·            ·                      (a, b, d, e, a, b, d)  ·
      │           table        u@idx                  ·                      ·
      │           type         inner                  ·                      ·
      │           equality     (d, a, b) = (d, a, b)  ·                      ·
      └── scan    ·            ·                      (a, b, d, e)           ·
·                 table        t@primary              ·                      ·
·                 spans        FULL SCAN              ·                      ·
·                 filter       e = 5                  ·                      ·

# Test index with middle primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx

statement ok
CREATE INDEX idx ON u (d, b)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.b = u.b WHERE t.e = 5
----
·                 distributed  true                   ·                      ·
·                 vectorized   true                   ·                      ·
render            ·            ·                      (a)                    ·
 │                render 0     a                      ·                      ·
 └── lookup-join  ·            ·                      (a, b, d, e, a, b, d)  ·
      │           table        u@idx                  ·                      ·
      │           type         inner                  ·                      ·
      │           equality     (d, b, a) = (d, b, a)  ·                      ·
      └── scan    ·            ·                      (a, b, d, e)           ·
·                 table        t@primary              ·                      ·
·                 spans        FULL SCAN              ·                      ·
·                 filter       e = 5                  ·                      ·

# Test index with last primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx

statement ok
CREATE INDEX idx ON u (d, c)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.d = u.d WHERE t.e = 5
----
·                 distributed  true       ·                ·
·                 vectorized   true       ·                ·
render            ·            ·          (a)              ·
 │                render 0     a          ·                ·
 └── lookup-join  ·            ·          (a, d, e, a, d)  ·
      │           table        u@idx      ·                ·
      │           type         inner      ·                ·
      │           equality     (d) = (d)  ·                ·
      │           pred         @1 = @4    ·                ·
      └── scan    ·            ·          (a, d, e)        ·
·                 table        t@primary  ·                ·
·                 spans        FULL SCAN  ·                ·
·                 filter       e = 5      ·                ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def JOIN abc ON a=f ORDER BY a
----
·                 distributed  true         ·                   ·
·                 vectorized   true         ·                   ·
render            ·            ·            (d, e, f, a, b, c)  ·
 │                render 0     d            ·                   ·
 │                render 1     e            ·                   ·
 │                render 2     f            ·                   ·
 │                render 3     a            ·                   ·
 │                render 4     b            ·                   ·
 │                render 5     c            ·                   ·
 └── lookup-join  ·            ·            (a, b, c, d, e, f)  +a
      │           table        def@primary  ·                   ·
      │           type         inner        ·                   ·
      │           equality     (a) = (f)    ·                   ·
      └── scan    ·            ·            (a, b, c)           +a
·                 table        abc@primary  ·                   ·
·                 spans        FULL SCAN    ·                   ·

# Test that we don't get a lookup join if we force a merge join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def INNER MERGE JOIN abc ON a=f ORDER BY a
----
·           distributed     true         ·                   ·
·           vectorized      false        ·                   ·
merge-join  ·               ·            (d, e, f, a, b, c)  +f
 │          type            inner        ·                   ·
 │          equality        (f) = (a)    ·                   ·
 │          mergeJoinOrder  +"(f=a)"     ·                   ·
 ├── scan   ·               ·            (d, e, f)           +f
 │          table           def@primary  ·                   ·
 │          spans           FULL SCAN    ·                   ·
 └── scan   ·               ·            (a, b, c)           +a
·           table           abc@primary  ·                   ·
·           spans           FULL SCAN    ·                   ·

# Test that we don't get a lookup join if we force a hash join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def INNER HASH JOIN abc ON a=f ORDER BY a
----
·               distributed  true         ·                   ·
·               vectorized   false        ·                   ·
sort            ·            ·            (d, e, f, a, b, c)  +f
 │              order        +f           ·                   ·
 └── hash-join  ·            ·            (d, e, f, a, b, c)  ·
      │         type         inner        ·                   ·
      │         equality     (f) = (a)    ·                   ·
      ├── scan  ·            ·            (d, e, f)           ·
      │         table        def@primary  ·                   ·
      │         spans        FULL SCAN    ·                   ·
      └── scan  ·            ·            (a, b, c)           ·
·               table        abc@primary  ·                   ·
·               spans        FULL SCAN    ·                   ·

# Test lookup semi and anti join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f)
----
·            distributed  true         ·          ·
·            vectorized   true         ·          ·
lookup-join  ·            ·            (a, b, c)  ·
 │           table        def@primary  ·          ·
 │           type         semi         ·          ·
 │           equality     (a) = (f)    ·          ·
 └── scan    ·            ·            (a, b, c)  ·
·            table        abc@primary  ·          ·
·            spans        FULL SCAN    ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f)
----
·            distributed  true         ·          ·
·            vectorized   true         ·          ·
lookup-join  ·            ·            (a, b, c)  ·
 │           table        def@primary  ·          ·
 │           type         anti         ·          ·
 │           equality     (a) = (f)    ·          ·
 └── scan    ·            ·            (a, b, c)  ·
·            table        abc@primary  ·          ·
·            spans        FULL SCAN    ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
·            distributed            true             ·          ·
·            vectorized             true             ·          ·
lookup-join  ·                      ·                (a, b, c)  ·
 │           table                  def@primary      ·          ·
 │           type                   semi             ·          ·
 │           equality               (a, c) = (f, e)  ·          ·
 │           equality cols are key  ·                ·          ·
 │           parallel               ·                ·          ·
 └── scan    ·                      ·                (a, b, c)  ·
·            table                  abc@primary      ·          ·
·            spans                  FULL SCAN        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
·            distributed            true             ·          ·
·            vectorized             true             ·          ·
lookup-join  ·                      ·                (a, b, c)  ·
 │           table                  def@primary      ·          ·
 │           type                   anti             ·          ·
 │           equality               (a, c) = (f, e)  ·          ·
 │           equality cols are key  ·                ·          ·
 │           parallel               ·                ·          ·
 └── scan    ·                      ·                (a, b, c)  ·
·            table                  abc@primary      ·          ·
·            spans                  FULL SCAN        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND d+b>1)
----
·            distributed  true           ·          ·
·            vectorized   true           ·          ·
lookup-join  ·            ·              (a, b, c)  ·
 │           table        def@primary    ·          ·
 │           type         semi           ·          ·
 │           equality     (a) = (f)      ·          ·
 │           pred         (@4 + @2) > 1  ·          ·
 └── scan    ·            ·              (a, b, c)  ·
·            table        abc@primary    ·          ·
·            spans        FULL SCAN      ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f AND d+b>1)
----
·            distributed  true           ·          ·
·            vectorized   true           ·          ·
lookup-join  ·            ·              (a, b, c)  ·
 │           table        def@primary    ·          ·
 │           type         anti           ·          ·
 │           equality     (a) = (f)      ·          ·
 │           pred         (@4 + @2) > 1  ·          ·
 └── scan    ·            ·              (a, b, c)  ·
·            table        abc@primary    ·          ·
·            spans        FULL SCAN      ·          ·

query T
SELECT url FROM [ EXPLAIN (DISTSQL)
  SELECT a,b from small WHERE EXISTS (SELECT a FROM data WHERE small.a=data.a) ORDER BY a
]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlF9vmzAUxd_3Ka7uU6uZEgPpH6RJ2VaqUaVJRyKtU8WDG6yOjWBmG2lVlO8-AZlKqhYs8ZA9Yp-j8-Nc625Q_c7Qx0UwDT4voZQZXEXzG7gP7m6nH8MZHF2Gi-Xi6_QYdhJG4KHRqDXLMvj2JYgCCO4qGRz9EzWKhGm2E9TiEwYf6sMTdgzz6DKI4NN3YDESzEXCZ2zNFfr3SJGggwRdJOghwTHGBAspVlwpISvJpjaEyR_0RwTTvCh1dRwTXAnJ0d-gTnXG0ccle8h4xFnCpT1CggnXLM3qmJppUsh0zeQTElwULFc-WDYFlidAQegfXCLBeal9mFAycTDeEhSlfs5Tmj1y9OmWmDNdizTfIY33kZZPBfdhGlwtYRHchHA9D2eVgmnWAp0K8ass4KdIcxB5hWYG6bwJ-cwmZMIlT_axJvQ9xttX_mQmLFHYdL_Yt-LdvXhqPjdqNDebWrYzdHI9VK3JnR5uco55dY5ZdY5lu0Or66FqVXd2uOpc8-pcs-pcy_aGVtdD1aru_HDVeebVeWbVeZY9HlpdD1Wruov_Y9W-AhlxVYhccaMtOqr2ME8eebO3lSjlit9Ksapjms957asPEq50c0ubjzBvrirAtpl2mp09M31pdrqTe6LdTrfXbfaGcI87zafdyadDks86zefdyedDki-6ZzXqeSbdj-xldrx99zcAAP__MnFS0w==

query T
SELECT url FROM [ EXPLAIN (DISTSQL)
  SELECT a,b from small WHERE a+b<20 AND EXISTS (SELECT a FROM data WHERE small.a=data.a AND small.b+data.c>15) ORDER BY a
]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlVFro04Uxd__n-JynwyZVEdNmw78we7WspbUdJPAdunmYaJD113ruKPClpLvvqgpNWWrLoGQR69zPOf-jjDPmP2KkeHCnbofl1CoGK7msxu4d-9upxeeD9qlt1guPk8HsD3CCazrM9kjj2P48smdu6BpHIawHsC3wjCsAExjABf-Jbh3pRy0F3GtDHnOX4TVV044_F9NT3it07bzNQzrebD9tAA6HgxgNr905_DhK_AVEkxkKHz-KDJk90iRoIkELSRoI8ExrgimSgYiy6QqjzxXAi_8jcwgGCVpkZfjFcFAKoHsGfMojwUyXPJ1LOaCh0LpBhIMRc6juLKp8jmpih65ekKCi5QnGYORToEnIVCQ-XehkOBVFOdCMdAcCkNwzAYjxpjnLydIcFbkDBxKHBNXG4KyyF9DZTl_EMjohvQPfi2jZJt7vJt7-ZQKBlP3agkL98aD65nnlyd4zhvbTKX8WaTwQ0YJyKSMVob0QXPMcolxo41_WsJ8d4nX7FKFQolwN7ZDh7ja_GVTX45kqtPddt6zt3bsaf_yaa_ydTrSzYPU3xG9Uf_p8dZv9udv9uNvjnTrIPw7ojf4nx0vf6s_f6sff2uk2wfh3xG9wX9yvPzt_vztfvztkT4-CP-O6A3-58fLv-MOnYsslUkmet0sRnk3ifBB1HdZJgsViFslg8qmfpxVumoQiiyv39L6wUvqV2XAppi2is0dMX0rNtudO6ytVrXdLrb3yT1uFZ-2O5_u43zWKp60O0_2cT5v78ro-E3af7K33qvNf38CAAD__4jwslA=

# Regression test for #35950: Make sure that lookup joins use a batch limit.

statement ok
CREATE TABLE a (a INT, b INT, PRIMARY KEY (a, b))

statement ok
CREATE TABLE b (a INT PRIMARY KEY)

# We insert over 10k rows, which is the currently configured batch limit.

statement ok
INSERT INTO a SELECT 1, g FROM generate_series(1,11000) g

statement ok
INSERT INTO b VALUES(1)

query TTT
EXPLAIN SELECT count(*) FROM (SELECT * FROM b NATURAL INNER LOOKUP JOIN a)
----
·                      distributed  true
·                      vectorized   true
group                  ·            ·
 │                     aggregate 0  count_rows()
 │                     scalar       ·
 └── render            ·            ·
      └── lookup-join  ·            ·
           │           table        a@primary
           │           type         inner
           │           equality     (a) = (a)
           └── scan    ·            ·
·                      table        b@primary
·                      spans        FULL SCAN

statement ok
SET tracing = on

query I
SELECT count(*) FROM (SELECT * FROM b NATURAL INNER LOOKUP JOIN a)
----
11000

statement ok
SET tracing = off

let $lookupTableID
SELECT 'a'::regclass::oid

# Now assert that we get more than 1 separate batch request into the lookup
# table, since the first one wouldn't have returned all of the results.

query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message LIKE 'Scan /Table/$lookupTableID%'
----
Scan /Table/63/1/{1-2}
Scan /Table/63/1/{1/10001/0-2}


# Regression test for #40562.

statement ok
CREATE TABLE public.region
(
    r_regionkey int PRIMARY KEY,
    r_name char(25) NOT NULL,
    r_comment varchar(152)
)

statement ok
ALTER TABLE public.region INJECT STATISTICS '[
  {
    "columns": ["r_regionkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 5,
    "distinct_count": 5
  },
  {
    "columns": ["r_name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 5,
    "distinct_count": 5
  },
  {
    "columns": ["r_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 5,
    "distinct_count": 5
  }
]'

statement ok
CREATE TABLE public.nation
(
    n_nationkey int PRIMARY KEY,
    n_name char(25) NOT NULL,
    n_regionkey int NOT NULL,
    n_comment varchar(152),
    INDEX n_rk (n_regionkey ASC),
    CONSTRAINT nation_fkey_region FOREIGN KEY (n_regionkey) references public.region (r_regionkey)
)

statement ok
ALTER TABLE public.nation INJECT STATISTICS '[
  {
    "columns": ["n_nationkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 25,
    "distinct_count": 25
  },
  {
    "columns": ["n_name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 25,
    "distinct_count": 25
  },
  {
    "columns": ["n_regionkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 25,
    "distinct_count": 5
  },
  {
    "columns": ["n_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 25,
    "distinct_count": 25
  }
]'

statement ok
CREATE TABLE public.supplier
(
    s_suppkey int PRIMARY KEY,
    s_name char(25) NOT NULL,
    s_address varchar(40) NOT NULL,
    s_nationkey int NOT NULL,
    s_phone char(15) NOT NULL,
    s_acctbal float NOT NULL,
    s_comment varchar(101) NOT NULL,
    INDEX s_nk (s_nationkey ASC),
    CONSTRAINT supplier_fkey_nation FOREIGN KEY (s_nationkey) references public.nation (n_nationkey)
)

statement ok
ALTER TABLE public.supplier INJECT STATISTICS '[
  {
    "columns": ["s_suppkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["s_name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["s_address"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["s_nationkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 25
  },
  {
    "columns": ["s_phone"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["s_acctbal"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  },
  {
    "columns": ["s_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'

statement ok
CREATE TABLE public.part
(
    p_partkey int PRIMARY KEY,
    p_name varchar(55) NOT NULL,
    p_mfgr char(25) NOT NULL,
    p_brand char(10) NOT NULL,
    p_type varchar(25) NOT NULL,
    p_size int NOT NULL,
    p_container char(10) NOT NULL,
    p_retailprice float NOT NULL,
    p_comment varchar(23) NOT NULL
)

statement ok
ALTER TABLE public.part INJECT STATISTICS '[
  {
    "columns": ["p_partkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 200000
  },
  {
    "columns": ["p_name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 200000
  },
  {
    "columns": ["p_mfgr"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 5
  },
  {
    "columns": ["p_brand"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 25
  },
  {
    "columns": ["p_type"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 150
  },
  {
    "columns": ["p_size"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 50
  },
  {
    "columns": ["p_container"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 40
  },
  {
    "columns": ["p_retailprice"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 20000
  },
  {
    "columns": ["p_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 200000,
    "distinct_count": 130000
  }
]'

statement ok
CREATE TABLE public.partsupp
(
    ps_partkey int NOT NULL,
    ps_suppkey int NOT NULL,
    ps_availqty int NOT NULL,
    ps_supplycost float NOT NULL,
    ps_comment varchar(199) NOT NULL,
    PRIMARY KEY (ps_partkey, ps_suppkey),
    INDEX ps_sk (ps_suppkey ASC),
    CONSTRAINT partsupp_fkey_part FOREIGN KEY (ps_partkey) references public.part (p_partkey),
    CONSTRAINT partsupp_fkey_supplier FOREIGN KEY (ps_suppkey) references public.supplier (s_suppkey)
)

statement ok
ALTER TABLE public.partsupp INJECT STATISTICS '[
  {
    "columns": ["ps_partkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 800000,
    "distinct_count": 200000
  },
  {
    "columns": ["ps_suppkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 800000,
    "distinct_count": 10000
  },
  {
    "columns": ["ps_availqty"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 800000,
    "distinct_count": 10000
  },
  {
    "columns": ["ps_supplycost"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 800000,
    "distinct_count": 100000
  },
  {
    "columns": ["ps_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 800000,
    "distinct_count": 800000
  }
]'

statement ok
CREATE TABLE public.customer
(
    c_custkey int PRIMARY KEY,
    c_name varchar(25) NOT NULL,
    c_address varchar(40) NOT NULL,
    c_nationkey int NOT NULL NOT NULL,
    c_phone char(15) NOT NULL,
    c_acctbal float NOT NULL,
    c_mktsegment char(10) NOT NULL,
    c_comment varchar(117) NOT NULL,
    INDEX c_nk (c_nationkey ASC),
    CONSTRAINT customer_fkey_nation FOREIGN KEY (c_nationkey) references public.nation (n_nationkey)
)

statement ok
ALTER TABLE public.customer INJECT STATISTICS '[
  {
    "columns": ["c_custkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  },
  {
    "columns": ["c_name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  },
  {
    "columns": ["c_address"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  },
  {
    "columns": ["c_nationkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 25
  },
  {
    "columns": ["c_phone"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  },
  {
    "columns": ["c_acctbal"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  },
  {
    "columns": ["c_mktsegment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 5
  },
  {
    "columns": ["c_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 150000,
    "distinct_count": 150000
  }
]'

statement ok
CREATE TABLE public.orders
(
    o_orderkey int PRIMARY KEY,
    o_custkey int NOT NULL,
    o_orderstatus char(1) NOT NULL,
    o_totalprice float NOT NULL,
    o_orderdate date NOT NULL,
    o_orderpriority char(15) NOT NULL,
    o_clerk char(15) NOT NULL,
    o_shippriority int NOT NULL,
    o_comment varchar(79) NOT NULL,
    INDEX o_ck (o_custkey ASC),
    INDEX o_od (o_orderdate ASC),
    CONSTRAINT orders_fkey_customer FOREIGN KEY (o_custkey) references public.customer (c_custkey)
)

statement ok
ALTER TABLE public.orders INJECT STATISTICS '[
  {
    "columns": ["o_orderkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 1500000
  },
  {
    "columns": ["o_custkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 100000
  },
  {
    "columns": ["o_orderstatus"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 3
  },
  {
    "columns": ["o_totalprice"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 1500000
  },
  {
    "columns": ["o_orderdate"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 2500
  },
  {
    "columns": ["o_orderpriority"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 5
  },
  {
    "columns": ["o_clerk"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 1000
  },
  {
    "columns": ["o_shippriority"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 1
  },
  {
    "columns": ["o_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1500000,
    "distinct_count": 1500000
  }
]'

statement ok
CREATE TABLE public.lineitem
(
    l_orderkey int NOT NULL,
    l_partkey int NOT NULL,
    l_suppkey int NOT NULL,
    l_linenumber int NOT NULL,
    l_quantity float NOT NULL,
    l_extendedprice float NOT NULL,
    l_discount float NOT NULL,
    l_tax float NOT NULL,
    l_returnflag char(1) NOT NULL,
    l_linestatus char(1) NOT NULL,
    l_shipdate date NOT NULL,
    l_commitdate date NOT NULL,
    l_receiptdate date NOT NULL,
    l_shipinstruct char(25) NOT NULL,
    l_shipmode char(10) NOT NULL,
    l_comment varchar(44) NOT NULL,
    PRIMARY KEY (l_orderkey, l_linenumber),
    INDEX l_ok (l_orderkey ASC),
    INDEX l_pk (l_partkey ASC),
    INDEX l_sk (l_suppkey ASC),
    INDEX l_sd (l_shipdate ASC),
    INDEX l_cd (l_commitdate ASC),
    INDEX l_rd (l_receiptdate ASC),
    INDEX l_pk_sk (l_partkey ASC, l_suppkey ASC),
    INDEX l_sk_pk (l_suppkey ASC, l_partkey ASC),
    CONSTRAINT lineitem_fkey_orders FOREIGN KEY (l_orderkey) references public.orders (o_orderkey),
    CONSTRAINT lineitem_fkey_part FOREIGN KEY (l_partkey) references public.part (p_partkey),
    CONSTRAINT lineitem_fkey_supplier FOREIGN KEY (l_suppkey) references public.supplier (s_suppkey)
)

statement ok
ALTER TABLE public.lineitem INJECT STATISTICS '[
  {
    "columns": ["l_orderkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 1500000
  },
  {
    "columns": ["l_partkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 200000
  },
  {
    "columns": ["l_suppkey"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 10000
  },
  {
    "columns": ["l_linenumber"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 7
  },
  {
    "columns": ["l_quantity"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 50
  },
  {
    "columns": ["l_extendedprice"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 1000000
  },
  {
    "columns": ["l_discount"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 11
  },
  {
    "columns": ["l_tax"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 9
  },
  {
    "columns": ["l_returnflag"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 3
  },
  {
    "columns": ["l_linestatus"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 2
  },
  {
    "columns": ["l_shipdate"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 2500
  },
  {
    "columns": ["l_commitdate"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 2500
  },
  {
    "columns": ["l_receiptdate"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 2500
  },
  {
    "columns": ["l_shipinstruct"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 4
  },
  {
    "columns": ["l_shipmode"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 7
  },
  {
    "columns": ["l_comment"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 6001215,
    "distinct_count": 4500000
  }
]'

query TTT
EXPLAIN SELECT s_name, count(*) AS numwait
    FROM supplier, lineitem AS l1, orders, nation
   WHERE s_suppkey = l1.l_suppkey
     AND o_orderkey = l1.l_orderkey
     AND o_orderstatus = 'F'
     AND l1.l_receiptdate > l1.l_commitdate
     AND EXISTS(
            SELECT *
              FROM lineitem AS l2
             WHERE l2.l_orderkey = l1.l_orderkey
               AND l2.l_suppkey != l1.l_suppkey
         )
     AND NOT EXISTS(
                SELECT *
                  FROM lineitem AS l3
                 WHERE l3.l_orderkey = l1.l_orderkey
                   AND l3.l_receiptdate > l3.l_commitdate
             )
     AND s_nationkey = n_nationkey
     AND n_name = 'SAUDI ARABIA'
GROUP BY s_name
ORDER BY numwait DESC, s_name
   LIMIT 100;
----
·                                                   distributed            true
·                                                   vectorized             false
limit                                               ·                      ·
 │                                                  count                  100
 └── sort                                           ·                      ·
      │                                             order                  -numwait,+s_name
      └── group                                     ·                      ·
           │                                        aggregate 0            s_name
           │                                        aggregate 1            count_rows()
           │                                        group by               s_name
           └── render                               ·                      ·
                └── lookup-join                     ·                      ·
                     │                              table                  orders@primary
                     │                              type                   inner
                     │                              equality               (l_orderkey) = (o_orderkey)
                     │                              equality cols are key  ·
                     │                              parallel               ·
                     │                              pred                   @11 = 'F'
                     └── lookup-join                ·                      ·
                          │                         table                  nation@primary
                          │                         type                   inner
                          │                         equality               (s_nationkey) = (n_nationkey)
                          │                         equality cols are key  ·
                          │                         parallel               ·
                          │                         pred                   @9 = 'SAUDI ARABIA'
                          └── lookup-join           ·                      ·
                               │                    table                  supplier@primary
                               │                    type                   inner
                               │                    equality               (l_suppkey) = (s_suppkey)
                               │                    equality cols are key  ·
                               │                    parallel               ·
                               └── lookup-join      ·                      ·
                                    │               table                  lineitem@primary
                                    │               type                   semi
                                    │               equality               (l_orderkey) = (l_orderkey)
                                    │               pred                   @6 != @2
                                    └── merge-join  ·                      ·
                                         │          type                   anti
                                         │          equality               (l_orderkey) = (l_orderkey)
                                         │          mergeJoinOrder         +"(l_orderkey=l_orderkey)"
                                         ├── scan   ·                      ·
                                         │          table                  lineitem@primary
                                         │          spans                  FULL SCAN
                                         │          filter                 l_receiptdate > l_commitdate
                                         └── scan   ·                      ·
·                                                   table                  lineitem@primary
·                                                   spans                  FULL SCAN
·                                                   filter                 l_receiptdate > l_commitdate
