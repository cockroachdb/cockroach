# LogicTest: 5node-dist-opt

statement ok
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY (a, c))

statement ok
CREATE TABLE def (d INT, e INT, f INT, PRIMARY KEY (f, e))

# Set up the statistics as if the first table is much smaller than the second.
# This will make lookup join into the second table be the best plan.
statement ok
ALTER TABLE abc INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE def INJECT STATISTICS '[
  {
    "columns": ["f"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b
----
tree         field     description  columns             ordering
lookup-join  ·         ·            (a, b, c, d, e, f)  ·
 │           table     def@primary  ·                   ·
 │           type      inner        ·                   ·
 │           equality  (b) = (f)    ·                   ·
 └── scan    ·         ·            (a, b, c)           ·
·            table     abc@primary  ·                   ·
·            spans     ALL          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b AND e = c
----
tree         field                  description      columns             ordering
lookup-join  ·                      ·                (a, b, c, d, e, f)  ·
 │           table                  def@primary      ·                   ·
 │           type                   inner            ·                   ·
 │           equality               (b, c) = (f, e)  ·                   ·
 │           equality cols are key  ·                ·                   ·
 └── scan    ·                      ·                (a, b, c)           ·
·            table                  abc@primary      ·                   ·
·            spans                  ALL              ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b WHERE a > 1 AND e > 1
----
tree         field     description  columns             ordering
lookup-join  ·         ·            (a, b, c, d, e, f)  ·
 │           table     def@primary  ·                   ·
 │           type      inner        ·                   ·
 │           equality  (b) = (f)    ·                   ·
 │           pred      @5 > 1       ·                   ·
 └── scan    ·         ·            (a, b, c)           ·
·            table     abc@primary  ·                   ·
·            spans     /2-          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = a WHERE f > 1
----
tree         field     description  columns             ordering
lookup-join  ·         ·            (a, b, c, d, e, f)  ·
 │           table     def@primary  ·                   ·
 │           type      inner        ·                   ·
 │           equality  (a) = (f)    ·                   ·
 │           pred      @6 > 1       ·                   ·
 └── scan    ·         ·            (a, b, c)           ·
·            table     abc@primary  ·                   ·
·            spans     /2-          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b WHERE a >= e
----
tree         field     description  columns             ordering
lookup-join  ·         ·            (a, b, c, d, e, f)  ·
 │           table     def@primary  ·                   ·
 │           type      inner        ·                   ·
 │           equality  (b) = (f)    ·                   ·
 │           pred      @1 >= @5     ·                   ·
 └── scan    ·         ·            (a, b, c)           ·
·            table     abc@primary  ·                   ·
·            spans     ALL          ·                   ·

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM abc JOIN def ON f = b AND a >= e
----
tree         field     description  columns             ordering
lookup-join  ·         ·            (a, b, c, d, e, f)  ·
 │           table     def@primary  ·                   ·
 │           type      inner        ·                   ·
 │           equality  (b) = (f)    ·                   ·
 │           pred      @1 >= @5     ·                   ·
 └── scan    ·         ·            (a, b, c)           ·
·            table     abc@primary  ·                   ·
·            spans     ALL          ·                   ·

# Verify a distsql plan.
statement ok
CREATE TABLE data (a INT, b INT, c INT, d INT, PRIMARY KEY (a, b, c, d))

# Split into ten parts.
statement ok
ALTER TABLE data SPLIT AT SELECT i FROM generate_series(1, 9) AS g(i)

# Relocate the ten parts to the five nodes.
statement ok
ALTER TABLE data EXPERIMENTAL_RELOCATE
  SELECT ARRAY[i%5+1], i FROM generate_series(0, 9) AS g(i)

# Verify data placement.
query TTTI colnames,rowsort
SELECT start_key, end_key, replicas, lease_holder from [SHOW EXPERIMENTAL_RANGES FROM TABLE data]
----
start_key  end_key  replicas  lease_holder
NULL       /1       {1}       1
/1         /2       {2}       2
/2         /3       {3}       3
/3         /4       {4}       4
/4         /5       {5}       5
/5         /6       {1}       1
/6         /7       {2}       2
/7         /8       {3}       3
/8         /9       {4}       4
/9         NULL     {5}       5

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM data WHERE c = 1) AS l NATURAL JOIN data AS r
----
render            ·                      ·                            (a, b, c, d)              ·
 │                render 0               a                            ·                         ·
 │                render 1               b                            ·                         ·
 │                render 2               c                            ·                         ·
 │                render 3               d                            ·                         ·
 └── lookup-join  ·                      ·                            (a, b, c, d, a, b, c, d)  ·
      │           table                  data@primary                 ·                         ·
      │           type                   inner                        ·                         ·
      │           equality               (a, b, c, d) = (a, b, c, d)  ·                         ·
      │           equality cols are key  ·                            ·                         ·
      └── scan    ·                      ·                            (a, b, c, d)              ·
·                 table                  data@primary                 ·                         ·
·                 spans                  ALL                          ·                         ·
·                 filter                 c = 1                        ·                         ·

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT * FROM (SELECT * FROM data WHERE c = 1) AS l NATURAL JOIN data AS r]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzElEFr2zAUx-_7FOKdZWxJTpoKBj4NMkY6ut6GD1r06LylkpFk2Cj57sPxoE5IZEFMerSsP_8fvyfeKxircaNe0IP8DgwocKAggEIJFBZQU2id3aL31vVXhsBa_wFZUGhM24X-uKawtQ5BvkJowg5BwpP6scNHVBpdXgAFjUE1u0NN65oX5f5WWgUFFL61ynhJspwRZTRhxIaf6IDCp2YX0ElSCfKRMCnlevO0gnpPwXbhrdkH9Ywg2Z6m0322jfkPt4jCfbH2d9eSX7YxxBpJKkYrTitBq17QQxeOjy7B8Ytwb0ydsU6jQ30EVO_P4G9sZtucFSc3z3eLo26WPjaWMracZTmfcXATfKPBLW8_OJ4ujyfJ41kuZpQ3wTeSd3d7eSJdnkiSJ7K8nFHeBN9I3ur28sp0eWWSvDLLFzPKm-Abybt_3317Bu4RfWuNx6RtWvT7GPUzDsvb285t8auz20PN8PlwyB0ONPow_GXDx9oMv3rAcZhFw_wozE7DPN48US2i6TIeLq_hXkTDy3jz8prmu2h4FW9eXdN8H59VMfFM4o_stLvef_gXAAD__0eIKhg=

statement ok
CREATE TABLE books (title STRING, edition INT, shelf INT, PRIMARY KEY (title, edition))

statement ok
CREATE TABLE books2 (title STRING, edition INT, shelf INT, PRIMARY KEY (title, edition))

statement ok
ALTER TABLE books INJECT STATISTICS '[
  {
    "columns": ["title"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE books2 INJECT STATISTICS '[
  {
    "columns": ["title"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 1000
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT DISTINCT b1.title FROM books as b1 JOIN books2 as b2 ON b1.title = b2.title WHERE b1.shelf <> b2.shelf
----
tree                   field        description        columns                       ordering
distinct               ·            ·                  (title)                       weak-key(title); +title
 │                     distinct on  title              ·                             ·
 │                     order key    title              ·                             ·
 └── render            ·            ·                  (title)                       +title
      │                render 0     title              ·                             ·
      └── lookup-join  ·            ·                  (title, shelf, title, shelf)  +title
           │           table        books2@primary     ·                             ·
           │           type         inner              ·                             ·
           │           equality     (title) = (title)  ·                             ·
           │           pred         @2 != @4           ·                             ·
           └── scan    ·            ·                  (title, shelf)                +title
·                      table        books@primary      ·                             ·
·                      spans        ALL                ·                             ·

statement ok
CREATE TABLE authors (name STRING, book STRING)

statement ok
ALTER TABLE authors INJECT STATISTICS '[
  {
    "columns": ["name"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT DISTINCT authors.name FROM books AS b1, books2 AS b2, authors WHERE b1.title = b2.title AND authors.book = b1.title AND b1.shelf <> b2.shelf
----
tree                        field        description        columns                                   ordering
distinct                    ·            ·                  (name)                                    weak-key(name)
 │                          distinct on  name               ·                                         ·
 └── render                 ·            ·                  (name)                                    ·
      │                     render 0     name               ·                                         ·
      └── hash-join         ·            ·                  (title, shelf, title, shelf, name, book)  ·
           │                type         inner              ·                                         ·
           │                equality     (title) = (book)   ·                                         ·
           ├── lookup-join  ·            ·                  (title, shelf, title, shelf)              ·
           │    │           table        books2@primary     ·                                         ·
           │    │           type         inner              ·                                         ·
           │    │           equality     (title) = (title)  ·                                         ·
           │    │           pred         @2 != @4           ·                                         ·
           │    └── scan    ·            ·                  (title, shelf)                            ·
           │                table        books@primary      ·                                         ·
           │                spans        ALL                ·                                         ·
           └── scan         ·            ·                  (name, book)                              ·
·                           table        authors@primary    ·                                         ·
·                           spans        ALL                ·                                         ·

# Verify data placement.
query TTTI colnames
SELECT start_key, end_key, replicas, lease_holder from [SHOW EXPERIMENTAL_RANGES FROM TABLE books]
----
start_key  end_key  replicas  lease_holder
NULL       NULL     {5}       5

# TODO(radu): this doesn't seem to be a lookup join, but it should be.

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT DISTINCT authors.name FROM books AS b1, books2 AS b2, authors WHERE b1.title = b2.title AND authors.book = b1.title AND b1.shelf <> b2.shelf]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyck89q3DAQh-99CndOCSjYku0cDAEdemhK2ZS0t7IHxZruqnE0RpKhJey7F9mlWZu10s1Rf76Zb362nsGSxo16Qg_Nd-DAoIYtg95Ri96Ti9vTpVv9C5qCgbH9EOL2lkFLDqF5hmBCh9DAhq6oz2tgoDEo043XDgxoCC-QD2qH0Fwf2FFhni78TT10eI9Ko8uLWXnonXlS7rd8IHr0wOBrr6xvsitgcDeEJpOcyRLWLPg5Fp_I2L8SPCEhgMFnosehz36SsRnZaBF9NpkU2fubTNbHdoLJksl61VG8NSlxWlINYR-_7OmsxKpHuerx0n6w5DQ61Mt_4PUrJ4b5qPw-ho4uL-ezdPgjXEh-eePMbh8upLj8N8N6kNU5QX4wPhjbhryad5Z8tX49q__KW7lH35P1-F-PpYjpoN7hlLanwbX4xVE7tpmWdyM3bmj0YTq9nha3djqKgscwT8IiDYskXM1gvoTLM2CxhKskXKe16yRcLODt4d2fAAAA__8CwK1z

query TTTTT colnames
EXPLAIN (VERBOSE) SELECT a.name FROM authors AS a JOIN books2 AS b2 ON a.book = b2.title ORDER BY a.name
----
tree                 field     description       columns              ordering
render               ·         ·                 (name)               +name
 │                   render 0  name              ·                    ·
 └── lookup-join     ·         ·                 (name, book, title)  +name
      │              table     books2@primary    ·                    ·
      │              type      inner             ·                    ·
      │              equality  (book) = (title)  ·                    ·
      └── sort       ·         ·                 (name, book)         +name
           │         order     +name             ·                    ·
           └── scan  ·         ·                 (name, book)         ·
·                    table     authors@primary   ·                    ·
·                    spans     ALL               ·                    ·

# Cross joins should not be planned as lookup joins.
query TTTTT colnames
EXPLAIN (VERBOSE) SELECT * FROM books CROSS JOIN books2
----
tree            field     description     columns                                         ordering
render          ·         ·               (title, edition, shelf, title, edition, shelf)  ·
 │              render 0  title           ·                                               ·
 │              render 1  edition         ·                                               ·
 │              render 2  shelf           ·                                               ·
 │              render 3  title           ·                                               ·
 │              render 4  edition         ·                                               ·
 │              render 5  shelf           ·                                               ·
 └── hash-join  ·         ·               (title, edition, shelf, title, edition, shelf)  ·
      │         type      cross           ·                                               ·
      ├── scan  ·         ·               (title, edition, shelf)                         ·
      │         table     books2@primary  ·                                               ·
      │         spans     ALL             ·                                               ·
      └── scan  ·         ·               (title, edition, shelf)                         ·
·               table     books@primary   ·                                               ·
·               spans     ALL             ·                                               ·


query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT * FROM authors INNER JOIN books2 ON books2.edition = 1 WHERE books2.title = authors.book]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyUkU9LMzEQh-_vpwhzntLN9q1ITrlWpJXam-wh3Qx1bZsJSRaUst9dsivYil31OH-eyUN-J3BsaWmOFEE9gQSEOVQIPnBNMXLI7WFpYV9BFQiN823K7Qqh5kCgTpCadCBQsOQJ-2kJCJaSaQ79WofAbfqEYjI7AjXr8OywHD-8MdsDrclYCtPi4jz40BxNeNOmTc_ZF-HRGxeVmADCmpyloIRUSi2Wm1sUWqLQJVyzkn-xuuPGfUjJ76W2zPuY_-Oeed968cKNE-yU0DPUmVm1SQldYq7_o56jvrnqVl64_RDFmqJnF-lXWRRdhUB2R0PckdtQ00Pgun9mKFc91zcsxTRMZ0OxcMMoC57DchQux-FyFC6-wFX37z0AAP__kSzobw==

####################################
#  LOOKUP JOIN ON SECONDARY INDEX  #
####################################

statement ok
CREATE TABLE small (a INT PRIMARY KEY, b INT, c INT, d INT)

statement ok
CREATE TABLE large (a INT, b INT, c INT, d INT, PRIMARY KEY (a, b), INDEX bc (b) STORING (c))

statement ok
ALTER TABLE small SPLIT AT SELECT i FROM generate_series(1, 9) AS g(i)

statement ok
ALTER TABLE small EXPERIMENTAL_RELOCATE
  SELECT ARRAY[i%5+1], i FROM generate_series(0, 9) AS g(i)

statement ok
INSERT INTO small SELECT x, 2*x, 3*x, 4*x FROM
  generate_series(1, 10) AS a(x)

statement ok
ALTER TABLE small INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 100,
    "distinct_count": 100
  }
]'

statement ok
ALTER TABLE large INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 10000,
    "distinct_count": 10000
  }
]'

# Lookup join on covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.a, large.c FROM small JOIN large ON small.a = large.b
----
render            ·         ·              (a, c)     ·
 │                render 0  a              ·          ·
 │                render 1  c              ·          ·
 └── lookup-join  ·         ·              (a, b, c)  ·
      │           table     large@bc       ·          ·
      │           type      inner          ·          ·
      │           equality  (a) = (b)      ·          ·
      └── scan    ·         ·              (a)        ·
·                 table     small@primary  ·          ·
·                 spans     ALL            ·          ·

# Lookup join on non-covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.a, large.d FROM small JOIN large ON small.a = large.b
----
render                 ·                      ·                (a, d)        ·
 │                     render 0               a                ·             ·
 │                     render 1               d                ·             ·
 └── lookup-join       ·                      ·                (a, a, b, d)  ·
      │                table                  large@primary    ·             ·
      │                type                   inner            ·             ·
      │                equality               (a, b) = (a, b)  ·             ·
      │                equality cols are key  ·                ·             ·
      └── lookup-join  ·                      ·                (a, a, b)     ·
           │           table                  large@bc         ·             ·
           │           type                   inner            ·             ·
           │           equality               (a) = (b)        ·             ·
           └── scan    ·                      ·                (a)           ·
·                      table                  small@primary    ·             ·
·                      spans                  ALL              ·             ·

############################
#  LEFT OUTER LOOKUP JOIN  #
############################

# Left join against primary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.b, large.a FROM small LEFT JOIN large ON small.b = large.a
----
lookup-join  ·         ·              (b, a)  ·
 │           table     large@primary  ·       ·
 │           type      left outer     ·       ·
 │           equality  (b) = (a)      ·       ·
 └── scan    ·         ·              (b)     ·
·            table     small@primary  ·       ·
·            spans     ALL            ·       ·

# Left join should preserve input order.
query TTTTT
EXPLAIN (VERBOSE) SELECT t1.a, t2.b FROM small t1 LEFT JOIN large t2 ON t1.a = t2.a AND t2.b % 6 = 0 ORDER BY t1.a
----
render            ·         ·              (a, b)     +a
 │                render 0  a              ·          ·
 │                render 1  b              ·          ·
 └── lookup-join  ·         ·              (a, a, b)  +a
      │           table     large@primary  ·          ·
      │           type      left outer     ·          ·
      │           equality  (a) = (a)      ·          ·
      │           pred      (@3 % 6) = 0   ·          ·
      └── scan    ·         ·              (a)        +a
·                 table     small@primary  ·          ·
·                 spans     ALL            ·          ·

query T
SELECT url FROM [EXPLAIN (DISTSQL) SELECT t1.a, t2.b FROM small t1 LEFT JOIN large t2 ON t1.a = t2.a AND t2.b % 6 = 0 ORDER BY t1.a]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlcGK2zwUhff_U4gLP7RUxpbtZDKCgjdTyDDYJXVXxQs1vqRuHctIMnQY8u4l9tDYQyMLvMkuknI4535HWC_QyBJTcUQN_BswoBAChQgoxEBhBQWFVsk9ai3V-S-DYFv-Bh5QqJq2M-ftgsJeKgT-AqYyNQKHXHyvcYeiROUHQKFEI6q6t2lVdRTqOdFHUddA4UsrGs2J5zMimpIwIs0PVEAh6wwnCYPiREF25mKmjTggcHai7oEeZdW85llN8-TPLXLy9PApJ9nX_GFHHrNtCvRvzlqoAwKFJyl_dS35KauGyKZPRiFLybskIv-TNed8m-ab9-QjCV5_X2agSXR1jPDqGJf0UpWosJwGT9gHKE7_mDWVnmx9NuV-zT6a2DP3WplTrT7z_HBRsTORRsWub7nY0J1s6EY29PxoEdmZSCOyd7dMNnInG7mRjTw_XkR2JtKI7OaWycbuZGM3srHnrxaRnYk0Int_y2RnXqsd6lY2Gp2-4MH5DcDygMOboWWn9vhZyX1vMyyzXtdvlKjNcMqGxbYZjs4Bx2JmFYcTMXsrDu3OM9aRVR3bxfGS3CureG13Xi9xvrOKN3bnzRLne3tXwcw1sV-yt97F6b8_AQAA___pW1AI

# Left join against covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.c FROM small LEFT JOIN large ON small.c = large.b
----
render            ·         ·              (c, c)     ·
 │                render 0  c              ·          ·
 │                render 1  c              ·          ·
 └── lookup-join  ·         ·              (c, b, c)  ·
      │           table     large@bc       ·          ·
      │           type      left outer     ·          ·
      │           equality  (c) = (b)      ·          ·
      └── scan    ·         ·              (c)        ·
·                 table     small@primary  ·          ·
·                 spans     ALL            ·          ·

# Left join against non-covering secondary index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.d FROM small LEFT JOIN large ON small.c = large.b
----
render                 ·                      ·                (c, d)        ·
 │                     render 0               c                ·             ·
 │                     render 1               d                ·             ·
 └── lookup-join       ·                      ·                (c, a, b, d)  ·
      │                table                  large@primary    ·             ·
      │                type                   left outer       ·             ·
      │                equality               (a, b) = (a, b)  ·             ·
      │                equality cols are key  ·                ·             ·
      └── lookup-join  ·                      ·                (c, a, b)     ·
           │           table                  large@bc         ·             ·
           │           type                   left outer       ·             ·
           │           equality               (c) = (b)        ·             ·
           └── scan    ·                      ·                (c)           ·
·                      table                  small@primary    ·             ·
·                      spans                  ALL              ·             ·

# Left join with ON filter on covering index
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.c FROM small LEFT JOIN large ON small.c = large.b AND large.c < 20
----
render            ·         ·              (c, c)     ·
 │                render 0  c              ·          ·
 │                render 1  c              ·          ·
 └── lookup-join  ·         ·              (c, b, c)  ·
      │           table     large@bc       ·          ·
      │           type      left outer     ·          ·
      │           equality  (c) = (b)      ·          ·
      │           pred      @3 < 20        ·          ·
      └── scan    ·         ·              (c)        ·
·                 table     small@primary  ·          ·
·                 spans     ALL            ·          ·

# Left join with ON filter on non-covering index
# TODO(radu): this doesn't use lookup join yet, the current rules don't cover
# left join with ON condition on columns that are not covered by the index.
query TTTTT
EXPLAIN (VERBOSE) SELECT small.c, large.d FROM small LEFT JOIN large ON small.c = large.b AND large.d < 30
----
render          ·         ·              (c, d)     ·
 │              render 0  c              ·          ·
 │              render 1  d              ·          ·
 └── hash-join  ·         ·              (b, d, c)  ·
      │         type      right outer    ·          ·
      │         equality  (b) = (c)      ·          ·
      ├── scan  ·         ·              (b, d)     ·
      │         table     large@primary  ·          ·
      │         spans     ALL            ·          ·
      │         filter    d < 30         ·          ·
      └── scan  ·         ·              (c)        ·
·               table     small@primary  ·          ·
·               spans     ALL            ·          ·

###########################################################
#  LOOKUP JOINS ON IMPLICIT INDEX KEY COLUMNS             #
#  https://github.com/cockroachdb/cockroach/issues/31777  #
###########################################################
statement ok
CREATE TABLE t (a INT, b INT, c INT, d INT, e INT)

statement ok
CREATE TABLE u (a INT, b INT, c INT, d INT, e INT, PRIMARY KEY (a DESC, b, c))

# Test index with all primary key columns implicit.
statement ok
CREATE INDEX idx ON u (d)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a WHERE t.e = 5
----
render            ·         ·                (a)              ·
 │                render 0  a                ·                ·
 └── lookup-join  ·         ·                (a, d, e, a, d)  ·
      │           table     u@idx            ·                ·
      │           type      inner            ·                ·
      │           equality  (d, a) = (d, a)  ·                ·
      └── scan    ·         ·                (a, d, e)        ·
·                 table     t@primary        ·                ·
·                 spans     ALL              ·                ·
·                 filter    e = 5            ·                ·

# Test unique version of same index. (Lookup join should not use column a.)
statement ok
DROP INDEX u@idx

statement ok
CREATE UNIQUE INDEX idx ON u (d)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a WHERE t.e = 5
----
render            ·         ·          (a)              ·
 │                render 0  a          ·                ·
 └── lookup-join  ·         ·          (a, d, e, a, d)  ·
      │           table     u@idx      ·                ·
      │           type      inner      ·                ·
      │           equality  (d) = (d)  ·                ·
      │           pred      @1 = @4    ·                ·
      └── scan    ·         ·          (a, d, e)        ·
·                 table     t@primary  ·                ·
·                 spans     ALL        ·                ·
·                 filter    e = 5      ·                ·

# Test index with first primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx CASCADE

statement ok
CREATE INDEX idx ON u (d, a)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.b = u.b WHERE t.e = 5
----
render            ·         ·                      (a)                    ·
 │                render 0  a                      ·                      ·
 └── lookup-join  ·         ·                      (a, b, d, e, a, b, d)  ·
      │           table     u@idx                  ·                      ·
      │           type      inner                  ·                      ·
      │           equality  (d, a, b) = (d, a, b)  ·                      ·
      └── scan    ·         ·                      (a, b, d, e)           ·
·                 table     t@primary              ·                      ·
·                 spans     ALL                    ·                      ·
·                 filter    e = 5                  ·                      ·

# Test index with middle primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx

statement ok
CREATE INDEX idx ON u (d, b)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.b = u.b WHERE t.e = 5
----
render            ·         ·                      (a)                    ·
 │                render 0  a                      ·                      ·
 └── lookup-join  ·         ·                      (a, b, d, e, a, b, d)  ·
      │           table     u@idx                  ·                      ·
      │           type      inner                  ·                      ·
      │           equality  (d, b, a) = (d, b, a)  ·                      ·
      └── scan    ·         ·                      (a, b, d, e)           ·
·                 table     t@primary              ·                      ·
·                 spans     ALL                    ·                      ·
·                 filter    e = 5                  ·                      ·

# Test index with last primary key column explicit and the rest implicit.
statement ok
DROP INDEX u@idx

statement ok
CREATE INDEX idx ON u (d, c)

query TTTTT
EXPLAIN (VERBOSE) SELECT u.a FROM t JOIN u ON t.d = u.d AND t.a = u.a AND t.d = u.d WHERE t.e = 5
----
render            ·         ·          (a)              ·
 │                render 0  a          ·                ·
 └── lookup-join  ·         ·          (a, d, e, a, d)  ·
      │           table     u@idx      ·                ·
      │           type      inner      ·                ·
      │           equality  (d) = (d)  ·                ·
      │           pred      @1 = @4    ·                ·
      └── scan    ·         ·          (a, d, e)        ·
·                 table     t@primary  ·                ·
·                 spans     ALL        ·                ·
·                 filter    e = 5      ·                ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def JOIN abc ON a=f ORDER BY a
----
render            ·         ·            (d, e, f, a, b, c)  ·
 │                render 0  d            ·                   ·
 │                render 1  e            ·                   ·
 │                render 2  f            ·                   ·
 │                render 3  a            ·                   ·
 │                render 4  b            ·                   ·
 │                render 5  c            ·                   ·
 └── lookup-join  ·         ·            (a, b, c, d, e, f)  +a
      │           table     def@primary  ·                   ·
      │           type      inner        ·                   ·
      │           equality  (a) = (f)    ·                   ·
      └── scan    ·         ·            (a, b, c)           +a
·                 table     abc@primary  ·                   ·
·                 spans     ALL          ·                   ·

# Test that we don't get a lookup join if we force a merge join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def INNER MERGE JOIN abc ON a=f ORDER BY a
----
merge-join  ·               ·            (d, e, f, a, b, c)  +f
 │          type            inner        ·                   ·
 │          equality        (f) = (a)    ·                   ·
 │          mergeJoinOrder  +"(f=a)"     ·                   ·
 ├── scan   ·               ·            (d, e, f)           +f
 │          table           def@primary  ·                   ·
 │          spans           ALL          ·                   ·
 └── scan   ·               ·            (a, b, c)           +a
·           table           abc@primary  ·                   ·
·           spans           ALL          ·                   ·

# Test that we don't get a lookup join if we force a hash join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM def INNER HASH JOIN abc ON a=f ORDER BY a
----
sort            ·         ·            (d, e, f, a, b, c)  +f
 │              order     +f           ·                   ·
 └── hash-join  ·         ·            (d, e, f, a, b, c)  ·
      │         type      inner        ·                   ·
      │         equality  (f) = (a)    ·                   ·
      ├── scan  ·         ·            (d, e, f)           ·
      │         table     def@primary  ·                   ·
      │         spans     ALL          ·                   ·
      └── scan  ·         ·            (a, b, c)           ·
·               table     abc@primary  ·                   ·
·               spans     ALL          ·                   ·

# Test lookup semi and anti join.
query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f)
----
render            ·         ·            (a, b, c)  ·
 │                render 0  a            ·          ·
 │                render 1  b            ·          ·
 │                render 2  c            ·          ·
 └── lookup-join  ·         ·            (a, b, c)  ·
      │           table     def@primary  ·          ·
      │           type      semi         ·          ·
      │           equality  (a) = (f)    ·          ·
      └── scan    ·         ·            (a, b, c)  ·
·                 table     abc@primary  ·          ·
·                 spans     ALL          ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f)
----
render            ·         ·            (a, b, c)  ·
 │                render 0  a            ·          ·
 │                render 1  b            ·          ·
 │                render 2  c            ·          ·
 └── lookup-join  ·         ·            (a, b, c)  ·
      │           table     def@primary  ·          ·
      │           type      anti         ·          ·
      │           equality  (a) = (f)    ·          ·
      └── scan    ·         ·            (a, b, c)  ·
·                 table     abc@primary  ·          ·
·                 spans     ALL          ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
render            ·                      ·                (a, b, c)  ·
 │                render 0               a                ·          ·
 │                render 1               b                ·          ·
 │                render 2               c                ·          ·
 └── lookup-join  ·                      ·                (a, b, c)  ·
      │           table                  def@primary      ·          ·
      │           type                   semi             ·          ·
      │           equality               (a, c) = (f, e)  ·          ·
      │           equality cols are key  ·                ·          ·
      └── scan    ·                      ·                (a, b, c)  ·
·                 table                  abc@primary      ·          ·
·                 spans                  ALL              ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f AND c=e)
----
render            ·                      ·                (a, b, c)  ·
 │                render 0               a                ·          ·
 │                render 1               b                ·          ·
 │                render 2               c                ·          ·
 └── lookup-join  ·                      ·                (a, b, c)  ·
      │           table                  def@primary      ·          ·
      │           type                   anti             ·          ·
      │           equality               (a, c) = (f, e)  ·          ·
      │           equality cols are key  ·                ·          ·
      └── scan    ·                      ·                (a, b, c)  ·
·                 table                  abc@primary      ·          ·
·                 spans                  ALL              ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE EXISTS (SELECT * FROM def WHERE a=f AND d+b>1)
----
render            ·         ·              (a, b, c)  ·
 │                render 0  a              ·          ·
 │                render 1  b              ·          ·
 │                render 2  c              ·          ·
 └── lookup-join  ·         ·              (a, b, c)  ·
      │           table     def@primary    ·          ·
      │           type      semi           ·          ·
      │           equality  (a) = (f)      ·          ·
      │           pred      (@4 + @2) > 1  ·          ·
      └── scan    ·         ·              (a, b, c)  ·
·                 table     abc@primary    ·          ·
·                 spans     ALL            ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * from abc WHERE NOT EXISTS (SELECT * FROM def WHERE a=f AND d+b>1)
----
render            ·         ·              (a, b, c)  ·
 │                render 0  a              ·          ·
 │                render 1  b              ·          ·
 │                render 2  c              ·          ·
 └── lookup-join  ·         ·              (a, b, c)  ·
      │           table     def@primary    ·          ·
      │           type      anti           ·          ·
      │           equality  (a) = (f)      ·          ·
      │           pred      (@4 + @2) > 1  ·          ·
      └── scan    ·         ·              (a, b, c)  ·
·                 table     abc@primary    ·          ·
·                 spans     ALL            ·          ·

query T
SELECT url FROM [ EXPLAIN (DISTSQL)
  SELECT a,b from small WHERE EXISTS (SELECT a FROM data WHERE small.a=data.a) ORDER BY a
]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlEFr2zAUx-_7FOJdJ-NIdtLUp1w6SOmS0eY2ctCiR-fN0TOSDCsl3304HqtdWlngQ3q0lD__X35PvGcwpHGjjuig-A4COEjgkAGHHDjMYc-htnRA58i2P-kCa_0HihmH0tSNb4_3HA5kEYpn8KWvEArYqR8V3qPSaNMZcNDoVVmda2pbHpV9Wrmjqirg8FAr4wqWpIIpo5lg5H-iBQ7bxhdsJfhKwv7EgRr_0ue8ekQoxInHM91Saf4hzYdIu6caC3Z382XHHm6-rtntdr0B_p9UK6-Awx3R76Zmv6g0jEyLFgcp34V8YSOr0aIeYq3EZ9if3vgnG0qoTsVQ7Hv12aBexM9NRM0tFUkqp05uhKo3ucXlJifj1ck4dTJJs6nqRqh66q4upy6LV5fFqcuSNJ-qboSqp255OXV5vLo8Tl2epPOp6kaoeuquP8aqfQPyHl1NxmHUFp21exj1I3Z721FjD_jN0uFc031uz7nzgUbnu1vRfaxNd9UC9sMiGJaDsHgdluHmkeosmM7D4XwK9zwYXoSbF1Oar4LhZbh5OaX5Ojyr2cgzCT-y193706e_AQAA__8Shyy4

query T
SELECT url FROM [ EXPLAIN (DISTSQL)
  SELECT a,b from small WHERE a+b<20 AND EXISTS (SELECT a FROM data WHERE small.a=data.a AND small.b+data.c>15) ORDER BY a
]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMlVFr2z4Uxd__n0Lcp_6pjC3ZTlM9-aWFlC4Zbd62PGjRpfPmWEaSYaXkuw_HZbXLKmsEQh4t-XDO_R3BfYFaK1zKHVoQX4ABBQ4UUqCQAYUcNhQao7dorTbdL71goX6BSCiUddO67nhDYasNgngBV7oKQcBafqvwAaVCEydAQaGTZXWwaUy5k-a5sDtZVUDhsZG1FSSKGZG1Ioxo9x0NULgtK4dGkIuCkUtS8P_J1zZJ0i3hiRBisVzPgcKqdYIUjBYcNnsKunVvoayTTwiC7Wl48Dtd1q-583Hu9XODgtzf3K7J482nBblbLZZA_4yjpJNA4V7rn21DfuiyJrruonUhl-Si4N0Q-esQSFj-T0PwD4d4y66NQoNqHLtgl7DZ_2XSpY50E7NxOx_ZpyN7Fl4-Cyo_ZlHMT1L_RPRB_bPzrZ-H8-dh_HkUpyfhPxF9wP_qfPmn4fzTMP5pFGcn4T8RfcB_fr78s3D-WRj_LIrzk_CfiD7gf32-_Cd26APaRtcWgzZL0u0mVE_Y7zKrW7PFz0ZvDzb95-qgOxwotK6_Zf3Hou6vuoBDMfOK-UjM3ou533nCOvWqM784OyZ37hXP_M6zY5yvvOK533l-jPO1v6tk4pn4H9l7783-v98BAAD__0_IfTU=

# Regression test for #35950: Make sure that lookup joins use a batch limit.

statement ok
CREATE TABLE a (a INT, b INT, PRIMARY KEY (a, b))

statement ok
CREATE TABLE b (a INT PRIMARY KEY)

# We insert over 10k rows, which is the currently configured batch limit.

statement ok
INSERT INTO a SELECT 1, g FROM generate_series(1,11000) g

statement ok
INSERT INTO b VALUES(1)

query TTT
EXPLAIN SELECT count(*) FROM (SELECT * FROM b NATURAL INNER LOOKUP JOIN a)
----
group                  ·            ·
 │                     aggregate 0  count_rows()
 │                     scalar       ·
 └── render            ·            ·
      └── lookup-join  ·            ·
           │           table        a@primary
           │           type         inner
           │           equality     (a) = (a)
           └── scan    ·            ·
·                      table        b@primary
·                      spans        ALL

statement ok
SET tracing = on

query I
SELECT count(*) FROM (SELECT * FROM b NATURAL INNER LOOKUP JOIN a)
----
11000

statement ok
SET tracing = off

let $lookupTableID
SELECT 'a'::regclass::oid

# Now assert that we get more than 1 separate batch request into the lookup
# table, since the first one wouldn't have returned all of the results.

query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message LIKE 'Scan /Table/$lookupTableID%'
----
Scan /Table/63/1/{1-2}
Scan /Table/63/1/{1/10001/0-2}
