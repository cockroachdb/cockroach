# LogicTest: local

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  FAMILY (k, a)
);
INSERT INTO t VALUES (1, 1), (2, 2), (3, 3), (4, 1), (5, 1);

statement ok
CREATE FUNCTION one() RETURNS INT LANGUAGE SQL AS 'SELECT 1';

query T
EXPLAIN SELECT one()
----
distribution: local
vectorized: true
·
• values
  size: 1 column, 1 row

query T
EXPLAIN SELECT * FROM t WHERE a = one()
----
distribution: local
vectorized: true
·
• filter
│ filter: a = one()
│
└── • scan
      missing stats
      table: t@t_pkey
      spans: FULL SCAN

statement ok
CREATE FUNCTION fetch_one_then_two() RETURNS INT LANGUAGE SQL AS $$
  SELECT a FROM t WHERE k = 1;
  SELECT a FROM t WHERE k = 2;
$$

# This test shows evidence of the execution of multiple statements within a UDF.
# The trace includes the two point lookups made by the UDF.
query T kvtrace
SELECT fetch_one_then_two()
----
Scan /Table/106/1/1/0
Scan /Table/106/1/2/0

# This test shows that six point lookups are performed - two for each invocation
# of the UDF.
query T kvtrace
SELECT i FROM (VALUES (1), (2), (3)) AS v(i) WHERE i = fetch_one_then_two()
----
Scan /Table/106/1/1/0
Scan /Table/106/1/2/0
Scan /Table/106/1/1/0
Scan /Table/106/1/2/0
Scan /Table/106/1/1/0
Scan /Table/106/1/2/0

statement ok
CREATE FUNCTION fetch_a_of_1(i INT) RETURNS INT CALLED ON NULL INPUT LANGUAGE SQL AS $$
  SELECT a FROM t WHERE k = 1
$$

statement ok
CREATE FUNCTION fetch_a_of_1_strict(i INT) RETURNS INT RETURNS NULL ON NULL INPUT LANGUAGE SQL AS $$
  SELECT a FROM t WHERE k = 1
$$

statement ok
CREATE FUNCTION fetch_a_of_2_strict(i INT, j INT) RETURNS INT STRICT LANGUAGE SQL AS $$
  SELECT a FROM t WHERE k = 2
$$

# When the function is CALLED ON NULL INPUT then it should be evaluated
# regardless of whether or not any of its inputs are NULL. The trace proves that
# the function is evaluated. It shows the scan performed by the statement in the
# function body.
query T kvtrace
SELECT fetch_a_of_1(NULL::INT)
----
Scan /Table/106/1/1/0

# When the function RETURNS NULL ON NULL INPUT or STRICT then it should not be
# evaluated if any of its inputs are NULL. The empty traces prove that the
# function is not evaluated. No scan is performed for the statement in the
# function body.
query T kvtrace
SELECT fetch_a_of_1_strict(NULL::INT)
----

query T kvtrace
SELECT fetch_a_of_2_strict(1, NULL::INT)
----


subtest subqueries

statement ok
CREATE TABLE sub1 (a INT);
CREATE TABLE sub2 (a INT);
CREATE TABLE sub3 (a INT);

statement ok
CREATE FUNCTION sub_fn() RETURNS INT LANGUAGE SQL AS 'SELECT a FROM sub1 WHERE a = (SELECT max(a) FROM sub2)'

# A query with a subquery and a subquery inside a UDF.
query T
EXPLAIN (VERBOSE) SELECT * FROM sub3 WHERE sub_fn() = 3 AND (SELECT max(a) FROM sub2) = a
----
distribution: local
vectorized: true
·
• root
│ columns: (a)
│
├── • filter
│   │ columns: (a)
│   │ estimated row count: 110 (missing stats)
│   │ filter: (sub_fn() = 3) AND (a = @S1)
│   │
│   └── • scan
│         columns: (a)
│         estimated row count: 1,000 (missing stats)
│         table: sub3@sub3_pkey
│         spans: FULL SCAN
│
└── • subquery
    │ id: @S1
    │ original sql: (SELECT max(a) FROM sub2)
    │ exec mode: one row
    │
    └── • group (scalar)
        │ columns: (max)
        │ estimated row count: 1 (missing stats)
        │ aggregate 0: max(a)
        │
        └── • scan
              columns: (a)
              estimated row count: 1,000 (missing stats)
              table: sub2@sub2_pkey
              spans: FULL SCAN


subtest regressions

# Regression test for #93210. Do not plan unnecessary assignment casts on the
# return values of UDFs.
statement ok
CREATE TABLE t93210 (
  a INT PRIMARY KEY
);
CREATE FUNCTION fn93210() RETURNS INT VOLATILE LANGUAGE SQL AS 'SELECT a FROM t93210';

# The query plan should have no assignment cast expressions.
query T
EXPLAIN (OPT, TYPES)
SELECT fn93210()
----
values
 ├── columns: fn93210:4(int)
 ├── cardinality: [1 - 1]
 ├── volatile
 ├── stats: [rows=1]
 ├── cost: 0.02
 ├── key: ()
 ├── fd: ()-->(4)
 ├── distribution: test
 ├── prune: (4)
 └── tuple [type=tuple{int}]
      └── udf: fn93210 [type=int]
           └── body
                └── limit
                     ├── columns: a:1(int!null)
                     ├── cardinality: [0 - 1]
                     ├── stats: [rows=1]
                     ├── key: ()
                     ├── fd: ()-->(1)
                     ├── distribution: test
                     ├── scan t93210
                     │    ├── columns: a:1(int!null)
                     │    ├── stats: [rows=1000]
                     │    └── key: (1)
                     └── const: 1 [type=int]

# Regression test for #88259. Arguments to UDFs should be formatted correctly in
# EXPLAIN output.
statement ok
CREATE FUNCTION f88259(a INT, b INT) RETURNS INT LANGUAGE SQL VOLATILE STRICT AS $$
  SELECT a + b
$$

query T
EXPLAIN (VERBOSE) SELECT f88259(333, 444)
----
distribution: local
vectorized: true
·
• values
  columns: (f88259)
  size: 1 column, 1 row
  row 0, expr 0: f88259(333, 444)
