# LogicTest: local

statement ok
CREATE TABLE ab (a INT PRIMARY KEY, b INT); INSERT INTO ab (a, b) VALUES (1, 10)

## Table index change: Add/remove index that query depends on, and ensure that
## the plan is recomputed each time.
statement ok
PREPARE change_index AS SELECT * FROM [EXPLAIN SELECT * FROM ab WHERE b=10]

query T nosort
EXECUTE change_index
----
distribution: local
·
• filter
│ filter: b = 10
│
└── • scan
      missing stats
      table: ab@ab_pkey
      spans: FULL SCAN

statement ok
CREATE INDEX bindex ON ab (b)

query T nosort
EXECUTE change_index
----
distribution: local
·
• scan
  missing stats
  table: ab@bindex
  spans: [/10 - /10]

statement ok
DROP INDEX bindex

query T nosort
EXECUTE change_index
----
distribution: local
·
• filter
│ filter: b = 10
│
└── • scan
      missing stats
      table: ab@ab_pkey
      spans: FULL SCAN

## Statistics change: Create statistics and ensure that the plan is recalculated.
statement ok
CREATE TABLE cd (c INT PRIMARY KEY, d INT)

statement ok
PREPARE change_stats AS SELECT * FROM [EXPLAIN SELECT * FROM ab JOIN cd ON a=c]

query T nosort
EXECUTE change_stats
----
distribution: local
·
• merge join
│ equality: (a) = (c)
│ left cols are key
│ right cols are key
│
├── • scan
│     missing stats
│     table: ab@ab_pkey
│     spans: FULL SCAN
│
└── • scan
      missing stats
      table: cd@cd_pkey
      spans: FULL SCAN

statement ok
CREATE STATISTICS s FROM ab

# Now that the optimizer knows table ab has one row (and it assumes a much
# higher number of rows for cd), it should choose lookup join.
# We allow retry because stat cache invalidation happens asynchronously.
query T retry,nosort
EXECUTE change_stats
----
distribution: local
·
• lookup join
│ table: cd@cd_pkey
│ equality: (a) = (c)
│ equality cols are key
│
└── • scan
      estimated row count: 1 (100% of the table; stats collected <hidden> ago)
      table: ab@ab_pkey
      spans: FULL SCAN

# Verify the plan of a very simple query which should be using the placeholder
# fast path.
statement ok
PREPARE pklookup AS SELECT b FROM ab WHERE a = $1

query T
EXPLAIN ANALYZE EXECUTE pklookup(1)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, reused
rows decoded from KV: 1 (8 B, 2 KVs, 1 gRPC calls)
regions: <hidden>
·
• scan
  sql nodes: <hidden>
  kv nodes: <hidden>
  regions: <hidden>
  KV time: 0µs
  KV rows decoded: 1
  actual row count: 1
  estimated row count: 1
  table: ab@ab_pkey
  spans: [/1 - /1]

query T
EXPLAIN ANALYZE EXECUTE pklookup(2)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, reused
regions: <hidden>
·
• scan
  sql nodes: <hidden>
  kv nodes: <hidden>
  regions: <hidden>
  KV time: 0µs
  KV rows decoded: 0
  actual row count: 0
  estimated row count: 1
  table: ab@ab_pkey
  spans: [/2 - /2]

# Regression test for #161978. Identity computed columns (where the
# computed expression is just another column) should work correctly with
# generic plans and lookup joins.
statement ok
SET plan_cache_mode = force_generic_plan

statement ok
CREATE TABLE t161978 (
  x INT NOT NULL,
  y INT NOT NULL,
  y_identity INT AS (y) STORED NOT NULL,
  INDEX t_y (y_identity, x)
)

statement ok
PREPARE p161978 AS SELECT t0.y
FROM t161978@t_y t0
WHERE t0.x = $1::INT AND y = $2::INT

# This query was failing with "cannot map variable 2 to an indexed var" before
# the fix. The issue was that identity column (y_identity) weren't properly
# replaced with the placeholder `$2` when generating the projection.
query T
EXPLAIN ANALYZE EXECUTE p161978(1, 20)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
regions: <hidden>
·
• lookup join
│ sql nodes: <hidden>
│ regions: <hidden>
│ KV time: 0µs
│ KV rows decoded: 0
│ execution time: 0µs
│ actual row count: 0
│ table: t161978@t161978_pkey
│ equality: (rowid) = (rowid)
│ equality cols are key
│ pred: y = "$2"
│
└── • lookup join
    │ sql nodes: <hidden>
    │ kv nodes: <hidden>
    │ regions: <hidden>
    │ KV time: 0µs
    │ KV rows decoded: 0
    │ execution time: 0µs
    │ actual row count: 0
    │ table: t161978@t_y
    │ equality: (y_identity_eq, $1) = (y_identity, x)
    │
    └── • render
        │
        └── • values
              sql nodes: <hidden>
              regions: <hidden>
              execution time: 0µs
              actual row count: 1
              size: 2 columns, 1 row

# Also test with a non-identity virtual column to ensure it still works.
statement ok
CREATE TABLE t161978_nonidentity (
  x INT NOT NULL,
  y INT NOT NULL,
  y_notidentity INT AS (y + 13) VIRTUAL NOT NULL,
  INDEX t_y (y_notidentity, x)
)

statement ok
PREPARE p161978_nonidentity AS SELECT t0.y
  FROM t161978_nonidentity@t_y t0
  WHERE t0.x = $1::INT AND y = $2::INT

query T
EXPLAIN ANALYZE EXECUTE p161978_nonidentity(1, 20)
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
plan type: generic, re-optimized
regions: <hidden>
·
• lookup join
│ sql nodes: <hidden>
│ regions: <hidden>
│ KV time: 0µs
│ KV rows decoded: 0
│ execution time: 0µs
│ actual row count: 0
│ table: t161978_nonidentity@t161978_nonidentity_pkey
│ equality: (rowid) = (rowid)
│ equality cols are key
│ pred: y = "$2"
│
└── • lookup join
    │ sql nodes: <hidden>
    │ kv nodes: <hidden>
    │ regions: <hidden>
    │ KV time: 0µs
    │ KV rows decoded: 0
    │ execution time: 0µs
    │ actual row count: 0
    │ table: t161978_nonidentity@t_y
    │ equality: (y_notidentity_eq, $1) = (y_notidentity, x)
    │
    └── • render
        │ execution time: 0µs
        │ actual row count: 1
        │
        └── • values
              sql nodes: <hidden>
              regions: <hidden>
              execution time: 0µs
              actual row count: 1
              size: 2 columns, 1 row

statement ok
RESET plan_cache_mode

subtest prepare-enum-update

statement ok
CREATE TYPE enum132105 AS ENUM ('hi');

statement ok
PREPARE p132105_hi AS SELECT $1::enum132105 = 'hi';

statement ok
ALTER TYPE enum132105 ADD VALUE 'hello';

query B
EXECUTE p132105_hi('hi');
----
true

statement ok
ALTER TYPE enum132105 RENAME VALUE 'hi' to 'aloha';

# Note, here our behavior differs from postgres -- pg would return true.
statement error invalid input value for enum enum132105: "hi"
EXECUTE p132105_hi('aloha');

# Test if we change the value back.
statement ok
ALTER TYPE enum132105 RENAME VALUE 'aloha' to 'hi';

statement error invalid input value for enum enum132105: "aloha"
EXECUTE p132105_hi('aloha');

query B
EXECUTE p132105_hi('hi');
----
true

statement ok
PREPARE p132105_hello AS SELECT $1::enum132105 = 'hello';

query B
EXECUTE p132105_hello('hello');
----
true

statement ok
ALTER TYPE enum132105 DROP VALUE 'hello';

statement error invalid input value for enum enum132105: "hello"
EXECUTE p132105_hello('hello');

# Test with implicit casting to udt.
statement ok
CREATE TABLE t132105 (enumcol enum132105);

statement ok
PREPARE p132105count AS SELECT count(*) FROM t132105 WHERE enumcol = 'hi';

statement ok
INSERT INTO t132105 VALUES ('hi'), ('hi')

query I
EXECUTE p132105count;
----
2

statement ok
ALTER TYPE enum132105 RENAME VALUE 'hi' to 'ciao';

# Note that here our behavior is different from pg -- pg would return 2.
statement error invalid input value for enum enum132105: "hi"
EXECUTE p132105count;

subtest end
