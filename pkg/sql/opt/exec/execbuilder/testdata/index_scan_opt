# LogicTest: 5node

# This family of test validates an optimization for scanning indexes via
# crdb_internal.scan which will modify these queries to use DistSQL processing.
subtest query-indexes

statement ok
CREATE TABLE q1(val int primary key, n varchar(25));

let $q_id
SELECT id FROM system.namespace WHERE name = 'q1';


statement ok
INSERT INTO q1 VALUES (1, 'cat'),(2, 'cow'),(3, 'mouse'),(4, 'lion'),(5, 'tiger'),(6, 'wolf');

query T
EXPLAIN SELECT * FROM crdb_internal.scan(crdb_internal.table_span($q_id));
----
distribution: local
vectorized: false
·
• kv scan
  span: /Table/10{6-7}

query T
EXPLAIN ANALYZE SELECT *  FROM crdb_internal.scan(crdb_internal.index_span($q_id,2));
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
maximum memory usage: <hidden>
network usage: <hidden>
·
• kv scan
  span: /Table/106/{2-3}

query T
EXPLAIN SELECT * FROM crdb_internal.scan(crdb_internal.table_span($q_id));
----
distribution: local
vectorized: false
·
• kv scan
  span: /Table/10{6-7}


statement ok
PREPARE Q1 AS SELECT * FROM crdb_internal.scan(crdb_internal.table_span($1));

query T
EXPLAIN ANALYZE EXECUTE Q1($q_id);
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
maximum memory usage: <hidden>
network usage: <hidden>
·
• kv scan
  span: /Table/10{6-7}

statement ok
PREPARE Q2 AS SELECT * FROM crdb_internal.scan(crdb_internal.index_span($1, $2));

query T
EXPLAIN ANALYZE EXECUTE Q2($q_id, $q_id);
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
maximum memory usage: <hidden>
network usage: <hidden>
·
• kv scan
  span: /Table/106/10{6-7}
