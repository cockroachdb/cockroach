# LogicTest: local

# ------------------------------------------------------------------------------
# Uncorrelated subqueries.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE abc (a INT PRIMARY KEY, b INT, c INT)

query T
EXPLAIN ALTER TABLE abc SPLIT AT VALUES ((SELECT 42))
----
distribution: local
vectorized: true
·
• root
│
├── • split
│   │
│   └── • values
│         size: 1 column, 1 row
│
└── • subquery
    │ id: @S1
    │ original sql: (SELECT 42)
    │ exec mode: one row
    │
    └── • values
          size: 1 column, 1 row

statement ok
ALTER TABLE abc SPLIT AT VALUES ((SELECT 1))

query T
EXPLAIN SELECT EXISTS (SELECT a FROM abc)
----
distribution: local
vectorized: true
·
• root
│
├── • values
│     size: 1 column, 1 row
│
└── • subquery
    │ id: @S1
    │ original sql: EXISTS (SELECT a FROM abc)
    │ exec mode: exists
    │
    └── • scan
          missing stats
          table: abc@primary
          spans: LIMITED SCAN
          limit: 1

query T
EXPLAIN (VERBOSE) SELECT * FROM abc WHERE a = (SELECT max(a) FROM abc WHERE EXISTS(SELECT * FROM abc WHERE c=a+3))
----
distribution: local
vectorized: true
·
• root
│ columns: (a, b, c)
│
├── • filter
│   │ columns: (a, b, c)
│   │ estimated row count: 333 (missing stats)
│   │ filter: a = @S2
│   │
│   └── • scan
│         columns: (a, b, c)
│         estimated row count: 1,000 (missing stats)
│         table: abc@primary
│         spans: FULL SCAN
│
├── • subquery
│   │ id: @S1
│   │ original sql: EXISTS (SELECT * FROM abc WHERE c = (a + 3))
│   │ exec mode: exists
│   │
│   └── • limit
│       │ columns: (a, b, c)
│       │ estimated row count: 1 (missing stats)
│       │ count: 1
│       │
│       └── • filter
│           │ columns: (a, b, c)
│           │ estimated row count: 330 (missing stats)
│           │ filter: c = (a + 3)
│           │
│           └── • scan
│                 columns: (a, b, c)
│                 estimated row count: 1,000 (missing stats)
│                 table: abc@primary
│                 spans: FULL SCAN
│
└── • subquery
    │ id: @S2
    │ original sql: (SELECT max(a) FROM abc WHERE EXISTS (SELECT * FROM abc WHERE c = (a + 3)))
    │ exec mode: one row
    │
    └── • group (scalar)
        │ columns: (any_not_null)
        │ estimated row count: 1 (missing stats)
        │ aggregate 0: any_not_null(a)
        │
        └── • limit
            │ columns: (a)
            │ estimated row count: 1 (missing stats)
            │ count: 1
            │
            └── • filter
                │ columns: (a)
                │ ordering: -a
                │ estimated row count: 333 (missing stats)
                │ filter: @S1
                │
                └── • revscan
                      columns: (a)
                      ordering: -a
                      estimated row count: 1,000 (missing stats)
                      table: abc@primary
                      spans: FULL SCAN

# IN expression transformed into semi-join.
query T
EXPLAIN (VERBOSE) SELECT a FROM abc WHERE a IN (SELECT a FROM abc WHERE b < 0)
----
distribution: local
vectorized: true
·
• merge join (semi)
│ columns: (a)
│ estimated row count: 333 (missing stats)
│ equality: (a) = (a)
│ left cols are key
│ right cols are key
│ merge ordering: +"(a=a)"
│
├── • scan
│     columns: (a)
│     ordering: +a
│     estimated row count: 1,000 (missing stats)
│     table: abc@primary
│     spans: FULL SCAN
│
└── • filter
    │ columns: (a, b)
    │ ordering: +a
    │ estimated row count: 333 (missing stats)
    │ filter: b < 0
    │
    └── • scan
          columns: (a, b)
          ordering: +a
          estimated row count: 1,000 (missing stats)
          table: abc@primary
          spans: FULL SCAN

query T
EXPLAIN SELECT * FROM (SELECT * FROM (VALUES (1, 8, 8), (3, 1, 1), (2, 4, 4)) AS moo (moo1, moo2, moo3) ORDER BY moo2) as foo (foo1) ORDER BY foo1
----
distribution: local
vectorized: true
·
• sort
│ estimated row count: 3
│ order: +foo1
│
└── • values
      size: 3 columns, 3 rows

# the subquery's plan must be visible in EXPLAIN
query T
EXPLAIN VALUES (1), ((SELECT 2))
----
distribution: local
vectorized: true
·
• root
│
├── • values
│     size: 1 column, 2 rows
│
└── • subquery
    │ id: @S1
    │ original sql: (SELECT 2)
    │ exec mode: one row
    │
    └── • values
          size: 1 column, 1 row

# This test checks that the double sub-query plan expansion caused by a
# sub-expression being shared by two or more plan nodes does not
# error out.
statement ok
CREATE TABLE tab4(col0 INTEGER, col1 FLOAT, col3 INTEGER, col4 FLOAT)

statement ok
CREATE INDEX idx_tab4_0 ON tab4 (col4,col0)

query T
EXPLAIN (VERBOSE)
SELECT col0
FROM tab4
WHERE
    (col0 <= 0 AND col4 <= 5.38)
    OR (col4 IN (SELECT col1 FROM tab4 WHERE col1 > 8.27))
    AND (col3 <= 5 AND (col3 BETWEEN 7 AND 9))
----
distribution: local
vectorized: true
·
• project
│ columns: (col0)
│ estimated row count: 311 (missing stats)
│
└── • project
    │ columns: (col0, col3, col4)
    │ estimated row count: 311 (missing stats)
    │
    └── • render
        │ columns: (col0, col3, col4, rowid)
        │ estimated row count: 311 (missing stats)
        │ render col0: col0
        │ render col3: col3
        │ render col4: col4
        │ render rowid: rowid
        │
        └── • filter
            │ columns: (col0, col3, col4, rowid)
            │ estimated row count: 311 (missing stats)
            │ filter: (col0 <= 0) AND (col4 <= 5.38)
            │
            └── • scan
                  columns: (col0, col3, col4, rowid)
                  estimated row count: 1,000 (missing stats)
                  table: tab4@primary
                  spans: FULL SCAN

# ------------------------------------------------------------------------------
# Correlated subqueries.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE a (x INT PRIMARY KEY, y INT);
CREATE TABLE b (x INT PRIMARY KEY, z INT);

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE EXISTS(SELECT * FROM b WHERE a.x=b.x)
----
distribution: local
vectorized: true
·
• merge join (semi)
│ columns: (x, y)
│ estimated row count: 1,000 (missing stats)
│ equality: (x) = (x)
│ left cols are key
│ right cols are key
│ merge ordering: +"(x=x)"
│
├── • scan
│     columns: (x, y)
│     ordering: +x
│     estimated row count: 1,000 (missing stats)
│     table: a@primary
│     spans: FULL SCAN
│
└── • scan
      columns: (x)
      ordering: +x
      estimated row count: 1,000 (missing stats)
      table: b@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE EXISTS(SELECT * FROM b WHERE b.x-1 = a.x)
----
distribution: local
vectorized: true
·
• hash join (semi)
│ columns: (x, y)
│ estimated row count: 1,000 (missing stats)
│ equality: (x) = (column9)
│ left cols are key
│
├── • scan
│     columns: (x, y)
│     estimated row count: 1,000 (missing stats)
│     table: a@primary
│     spans: FULL SCAN
│
└── • render
    │ columns: (column9)
    │ estimated row count: 1,000 (missing stats)
    │ render column9: x - 1
    │
    └── • scan
          columns: (x)
          estimated row count: 1,000 (missing stats)
          table: b@primary
          spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM b WHERE b.x = a.x)
----
distribution: local
vectorized: true
·
• merge join (anti)
│ columns: (x, y)
│ estimated row count: 0 (missing stats)
│ equality: (x) = (x)
│ left cols are key
│ right cols are key
│ merge ordering: +"(x=x)"
│
├── • scan
│     columns: (x, y)
│     ordering: +x
│     estimated row count: 1,000 (missing stats)
│     table: a@primary
│     spans: FULL SCAN
│
└── • scan
      columns: (x)
      ordering: +x
      estimated row count: 1,000 (missing stats)
      table: b@primary
      spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT * FROM b WHERE NOT EXISTS(SELECT * FROM a WHERE x-1 = b.x)
----
distribution: local
vectorized: true
·
• hash join (anti)
│ columns: (x, z)
│ estimated row count: 0 (missing stats)
│ equality: (x) = (column9)
│ left cols are key
│
├── • scan
│     columns: (x, z)
│     estimated row count: 1,000 (missing stats)
│     table: b@primary
│     spans: FULL SCAN
│
└── • render
    │ columns: (column9)
    │ estimated row count: 1,000 (missing stats)
    │ render column9: x - 1
    │
    └── • scan
          columns: (x)
          estimated row count: 1,000 (missing stats)
          table: a@primary
          spans: FULL SCAN

query T
EXPLAIN (VERBOSE) SELECT ARRAY(SELECT x FROM b)
----
distribution: local
vectorized: true
·
• root
│ columns: ("array")
│
├── • values
│     columns: ("array")
│     size: 1 column, 1 row
│     row 0, expr 0: ARRAY @S1
│
└── • subquery
    │ id: @S1
    │ original sql: (SELECT x FROM b)
    │ exec mode: all rows
    │
    └── • scan
          columns: (x)
          estimated row count: 1,000 (missing stats)
          table: b@primary
          spans: FULL SCAN

# Case where the plan has an apply join.
query T
EXPLAIN(verbose) SELECT * FROM abc WHERE EXISTS(SELECT * FROM (VALUES (a), (b)) WHERE column1=a)
----
distribution: local
vectorized: true
·
• apply join (semi)
│ columns: (a, b, c)
│ estimated row count: 2 (missing stats)
│ pred: column1 = a
│
└── • scan
      columns: (a, b, c)
      estimated row count: 1,000 (missing stats)
      table: abc@primary
      spans: FULL SCAN
