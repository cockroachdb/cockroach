# LogicTest: 5node

# This test file makes sure that experimental DistSQL planning actually plans
# processors and other components correctly. In order to make the output
# deterministic we place the data manually.

statement ok
CREATE TABLE kv (k INT PRIMARY KEY, v INT, FAMILY (k, v));
INSERT INTO kv SELECT i, i FROM generate_series(1,5) AS g(i);
CREATE TABLE kw (k INT PRIMARY KEY, w INT, FAMILY (k, w));
INSERT INTO kw SELECT i, i FROM generate_series(1,5) AS g(i)

# Split into 5 parts, each row from each table goes to one node.
statement ok
ALTER TABLE kv SPLIT AT SELECT i FROM generate_series(1,5) AS g(i);
ALTER TABLE kw SPLIT AT SELECT i FROM generate_series(1,5) AS g(i);
ALTER TABLE kv EXPERIMENTAL_RELOCATE SELECT ARRAY[i], i FROM generate_series(1, 5) as g(i);
ALTER TABLE kw EXPERIMENTAL_RELOCATE SELECT ARRAY[i], i FROM generate_series(1, 5) as g(i)

# Verify data placement.
query TTTI colnames,rowsort
SELECT start_key, end_key, replicas, lease_holder from [SHOW RANGES FROM TABLE kv WITH DETAILS]
ORDER BY 1
----
start_key           end_key                 replicas  lease_holder
<before:/Table/62>  …/1/1                   {1}       1
…/1/1               …/1/2                   {1}       1
…/1/2               …/1/3                   {2}       2
…/1/3               …/1/4                   {3}       3
…/1/4               …/1/5                   {4}       4
…/1/5               <after:/Table/107/1/1>  {5}       5

# Verify data placement.
query TTTI colnames,rowsort
SELECT start_key, end_key, replicas, lease_holder from [SHOW RANGES FROM TABLE kw WITH DETAILS]
----
start_key                end_key       replicas  lease_holder
<before:/Table/106/1/5>  …/1/1         {5}       5
…/1/1                    …/1/2         {1}       1
…/1/2                    …/1/3         {2}       2
…/1/3                    …/1/4         {3}       3
…/1/4                    …/1/5         {4}       4
…/1/5                    <after:/Max>  {5}       5

statement ok
SET experimental_distsql_planning = always

query T
EXPLAIN (DISTSQL) SELECT * FROM kv
----
distribution: full
vectorized: true
·
• scan
  missing stats
  table: kv@kv_pkey
  spans: FULL SCAN
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJyck1FvmzAQgN_3K9A9bZMtsDFdw9OmJpMipWmX5GHSFFUOvmQIgplN0lUR_30ymdaC0orxeNz5u0_H3QnsrxximHy_n32Zzr334-lytfw2--AtJ7PJzcr76H1d3N162REIFFrhXO7RQvwDGBDgQCAEAgIIRLAmUBqdoLXauJJT82CqfkMcEEiL8lC5z2sCiTYI8QmqtMoRYljJTY4LlAqNHwABhZVM86ZNdvycHR_KDJ-AwI3OD_vCxl5GPCe0LKWLqM9hXRPQh-q5h63kDiFmL6SmY4iDmrzi9axzKLRRaFC1VNb1BfO5prr0o07hZRXeUYlaKqz_iNj_j8jn1A97D4m1zHh_Mz7ALKS-6G3GW2Zhf7NwgJmgftTbLGyZif5mYoBZRHt7iVcX_oLXAm2pC4u99jnodKLMXQiqHZ7PyeqDSfDe6KSpPYd3Daj5oNBW5yw7B9OiSTHXwaDc_7vXlyT2JumqRQreJPGhTqxLCoeSeJckhpLCLikaShLuL25z_fiQKoiBJdur640UFD9FggqZXFMpR0j5ZoTBFhO1CUbgHsiddau0_KkfG-zqqXSLsJW5RQK3MsMxVmj2aZHaKk3-Zur63Z8AAAD__w7JHFU=

# Note that we want to test DistSQL physical planning and the obvious choice
# would be to use EXPLAIN (DISTSQL). However, this explain variant doesn't have
# a textual mode which is easier to verify, so we use EXPLAIN (VEC) instead.
# TODO(yuzefovich): consider adding textual mode to EXPLAIN (DISTSQL) and
# using it here.
# TODO(yuzefovich): figure out how we would display plans that have distributed
# stages followed by local ones followed by distributed stages.

# An example of partially distributed plan (due to DOid type that is not
# supported by DistSQL).

query T
EXPLAIN (VEC) SELECT * FROM kv WHERE k::REGCLASS IS NOT NULL
----
│
├ Node 1
│ └ *colexec.isNullSelOp
│   └ *colexecbase.castNativeToDatumOp
│     └ *colexec.ParallelUnorderedSynchronizer
│       ├ *colfetcher.ColBatchScan
│       ├ *colrpc.Inbox
│       ├ *colrpc.Inbox
│       ├ *colrpc.Inbox
│       └ *colrpc.Inbox
├ Node 2
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 3
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 4
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
└ Node 5
  └ *colrpc.Outbox
    └ *colfetcher.ColBatchScan

# Check that the plan is local when experimental DistSQL planning is disabled.
statement ok
SET experimental_distsql_planning = off

query T
EXPLAIN (VEC) SELECT * FROM kv WHERE k::REGCLASS IS NOT NULL
----
│
└ Node 1
  └ *colexec.isNullSelOp
    └ *colexecbase.castNativeToDatumOp
      └ *colfetcher.ColBatchScan

statement ok
SET experimental_distsql_planning = always

# Check that plan is partially distributed (due to DOid type in a render
# expression which is not supported by DistSQL).
query T
EXPLAIN (VEC) SELECT k::REGCLASS FROM kv
----
│
├ Node 1
│ └ *colexecbase.castNativeToDatumOp
│   └ *colexec.ParallelUnorderedSynchronizer
│     ├ *colfetcher.ColBatchScan
│     ├ *colrpc.Inbox
│     ├ *colrpc.Inbox
│     ├ *colrpc.Inbox
│     └ *colrpc.Inbox
├ Node 2
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 3
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 4
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
└ Node 5
  └ *colrpc.Outbox
    └ *colfetcher.ColBatchScan

# Disable the partially distributed plans and check that a local plan is
# produced instead.
statement ok
SET disable_partially_distributed_plans = true

# TODO(yuzefovich): for some reason the plan below is not local, figure it out.
query T
EXPLAIN (VEC) SELECT k::REGCLASS FROM kv
----
│
├ Node 1
│ └ *colexecbase.castNativeToDatumOp
│   └ *colexec.ParallelUnorderedSynchronizer
│     ├ *colfetcher.ColBatchScan
│     ├ *colrpc.Inbox
│     ├ *colrpc.Inbox
│     ├ *colrpc.Inbox
│     └ *colrpc.Inbox
├ Node 2
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 3
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
├ Node 4
│ └ *colrpc.Outbox
│   └ *colfetcher.ColBatchScan
└ Node 5
  └ *colrpc.Outbox
    └ *colfetcher.ColBatchScan

statement ok
SET disable_partially_distributed_plans = false
