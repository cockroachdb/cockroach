# LogicTest: local

statement ok
CREATE TABLE partialindexes (
    a INT PRIMARY KEY,
    b INT,
    c STRING,
    FAMILY (a, b, c),
    INDEX(b) WHERE b > 0,
    INDEX(c) WHERE a > b AND c = 'foo'
)

# Matches no partial index.
query T kvtrace
INSERT INTO partialindexes VALUES(0, -1, 'bar')
----
CPut /Table/53/1/0/0 -> /TUPLE/2:2:Int/-1/1:3:Bytes/bar

# Matches the first partial index.
query T kvtrace
INSERT INTO partialindexes VALUES(1, 1, 'foo')
----
CPut /Table/53/1/1/0 -> /TUPLE/2:2:Int/1/1:3:Bytes/foo
InitPut /Table/53/2/1/1/0 -> /BYTES/

# Matches both partial indexes.
query T kvtrace
INSERT INTO partialindexes VALUES(2, 1, 'foo')
----
CPut /Table/53/1/2/0 -> /TUPLE/2:2:Int/1/1:3:Bytes/foo
InitPut /Table/53/2/1/2/0 -> /BYTES/
InitPut /Table/53/3/"foo"/2/0 -> /BYTES/

# Test that only keys that were present in the partial indexes get deleted.
query T kvtrace
DELETE FROM partialindexes
----
Scan /Table/53/{1-2}
Del /Table/53/1/0/0
Del /Table/53/2/1/1/0
Del /Table/53/1/1/0
Del /Table/53/2/1/2/0
Del /Table/53/3/"foo"/2/0
Del /Table/53/1/2/0

# Same as the first set of tests, with upserts.
query T kvtrace
UPSERT INTO partialindexes VALUES(0, -1, 'bar')
----
Scan /Table/53/1/0{-/#}
CPut /Table/53/1/0/0 -> /TUPLE/2:2:Int/-1/1:3:Bytes/bar

query T kvtrace
UPSERT INTO partialindexes VALUES(1, 1, 'foo')
----
Scan /Table/53/1/1{-/#}
CPut /Table/53/1/1/0 -> /TUPLE/2:2:Int/1/1:3:Bytes/foo
InitPut /Table/53/2/1/1/0 -> /BYTES/

query T kvtrace
UPSERT INTO partialindexes VALUES(2, 1, 'foo')
----
Scan /Table/53/1/2{-/#}
CPut /Table/53/1/2/0 -> /TUPLE/2:2:Int/1/1:3:Bytes/foo
InitPut /Table/53/2/1/2/0 -> /BYTES/
InitPut /Table/53/3/"foo"/2/0 -> /BYTES/

# Update some rows with UPSERT.
# TODO(jordan): this is currently wrong, the old value of the UPSERT shouldn't
# get deleted from the index.
query T kvtrace
UPSERT INTO partialindexes VALUES(0, -1, 'foo')
----
Scan /Table/53/1/0{-/#}
Put /Table/53/1/0/0 -> /TUPLE/2:2:Int/-1/1:3:Bytes/foo
Del /Table/53/3/"bar"/0/0
CPut /Table/53/3/"foo"/0/0 -> /BYTES/ (expecting does not exist)

# Check that editing a row that wasn't present in the partial index adds it
# to the partial index when appropriate.
# TODO(jordan): this is currently not the case, and this test is wrong.
query T kvtrace
UPDATE partialindexes SET b = 1 WHERE a = 0
----
Scan /Table/53/1/0{-/#}
Put /Table/53/1/0/0 -> /TUPLE/2:2:Int/1/1:3:Bytes/foo
Del /Table/53/2/-1/0/0
CPut /Table/53/2/1/0/0 -> /BYTES/ (expecting does not exist)

# Check that editing a row that was present in the partial index removes it
# from the partial index when appropriate.
# TODO(jordan): this is currently not the case, and this test is wrong.
query T kvtrace
UPDATE partialindexes SET b = -1 WHERE a = 0
----
Scan /Table/53/1/0{-/#}
Put /Table/53/1/0/0 -> /TUPLE/2:2:Int/-1/1:3:Bytes/foo
Del /Table/53/2/1/0/0
CPut /Table/53/2/-1/0/0 -> /BYTES/ (expecting does not exist)
