# LogicTest: opt

statement ok
CREATE TABLE kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)

query TTTTT
EXPLAIN (TYPES) SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(false), XOR_AGG(b'\x01') FROM kv
----
group           ·             ·                   (min int, max int, count int, sum_int int, avg decimal, sum decimal, stddev decimal, variance decimal, bool_and bool, bool_or bool, xor_agg bytes)  ·
 │              aggregate 0   min(column5)        ·                                                                                                                                                   ·
 │              aggregate 1   max(column5)        ·                                                                                                                                                   ·
 │              aggregate 2   count(column5)      ·                                                                                                                                                   ·
 │              aggregate 3   sum_int(column5)    ·                                                                                                                                                   ·
 │              aggregate 4   avg(column5)        ·                                                                                                                                                   ·
 │              aggregate 5   sum(column5)        ·                                                                                                                                                   ·
 │              aggregate 6   stddev(column5)     ·                                                                                                                                                   ·
 │              aggregate 7   variance(column5)   ·                                                                                                                                                   ·
 │              aggregate 8   bool_and(column14)  ·                                                                                                                                                   ·
 │              aggregate 9   bool_or(column16)   ·                                                                                                                                                   ·
 │              aggregate 10  xor_agg(column18)   ·                                                                                                                                                   ·
 └── render     ·             ·                   (column5 int, column14 bool, column16 bool, column18 bytes)                                                                                         ·
      │         render 0      (1)[int]            ·                                                                                                                                                   ·
      │         render 1      (true)[bool]        ·                                                                                                                                                   ·
      │         render 2      (false)[bool]       ·                                                                                                                                                   ·
      │         render 3      ('\x01')[bytes]     ·                                                                                                                                                   ·
      └── scan  ·             ·                   ()                                                                                                                                                  ·
·               table         kv@primary          ·                                                                                                                                                   ·
·               spans         ALL                 ·                                                                                                                                                   ·

query TTTTT
EXPLAIN (TYPES) SELECT MIN(v), MAX(v), COUNT(v), SUM_INT(1), AVG(v), SUM(v), STDDEV(v), VARIANCE(v), BOOL_AND(v = 1), BOOL_AND(v = 1), XOR_AGG(s::bytes) FROM kv
----
render               ·            ·                            (min int, max int, count int, sum_int int, avg decimal, sum decimal, stddev decimal, variance decimal, bool_and bool, bool_and bool, xor_agg bytes)  ·
 │                   render 0     (agg0)[int]                  ·                                                                                                                                                    ·
 │                   render 1     (agg1)[int]                  ·                                                                                                                                                    ·
 │                   render 2     (agg2)[int]                  ·                                                                                                                                                    ·
 │                   render 3     (agg3)[int]                  ·                                                                                                                                                    ·
 │                   render 4     (agg4)[decimal]              ·                                                                                                                                                    ·
 │                   render 5     (agg5)[decimal]              ·                                                                                                                                                    ·
 │                   render 6     (agg6)[decimal]              ·                                                                                                                                                    ·
 │                   render 7     (agg7)[decimal]              ·                                                                                                                                                    ·
 │                   render 8     (agg8)[bool]                 ·                                                                                                                                                    ·
 │                   render 9     (agg8)[bool]                 ·                                                                                                                                                    ·
 │                   render 10    (agg9)[bytes]                ·                                                                                                                                                    ·
 └── group           ·            ·                            (agg0 int, agg1 int, agg2 int, agg3 int, agg4 decimal, agg5 decimal, agg6 decimal, agg7 decimal, agg8 bool, agg9 bytes)                              ·
      │              aggregate 0  min(kv.v)                    ·                                                                                                                                                    ·
      │              aggregate 1  max(kv.v)                    ·                                                                                                                                                    ·
      │              aggregate 2  count(kv.v)                  ·                                                                                                                                                    ·
      │              aggregate 3  sum_int(column8)             ·                                                                                                                                                    ·
      │              aggregate 4  avg(kv.v)                    ·                                                                                                                                                    ·
      │              aggregate 5  sum(kv.v)                    ·                                                                                                                                                    ·
      │              aggregate 6  stddev(kv.v)                 ·                                                                                                                                                    ·
      │              aggregate 7  variance(kv.v)               ·                                                                                                                                                    ·
      │              aggregate 8  bool_and(column14)           ·                                                                                                                                                    ·
      │              aggregate 9  xor_agg(column16)            ·                                                                                                                                                    ·
      └── render     ·            ·                            (column8 int, column14 bool, column16 bytes, "kv.v" int)                                                                                             ·
           │         render 0     (1)[int]                     ·                                                                                                                                                    ·
           │         render 1     ((v)[int] = (1)[int])[bool]  ·                                                                                                                                                    ·
           │         render 2     ((s)[string]::BYTES)[bytes]  ·                                                                                                                                                    ·
           │         render 3     (v)[int]                     ·                                                                                                                                                    ·
           └── scan  ·            ·                            (v int, s string)                                                                                                                                    ·
·                    table        kv@primary                   ·                                                                                                                                                    ·
·                    spans        ALL                          ·                                                                                                                                                    ·

# Aggregate functions trigger aggregation and computation when there is no source.
query TTTTT
EXPLAIN (TYPES) SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
render                   ·             ·                                 (min int, count int, max int, sum_int int, "avg(1)::FLOAT" float, sum decimal, stddev decimal, variance decimal, bool_and bool, bool_or bool, to_hex string)  ·
 │                       render 0      (agg0)[int]                       ·                                                                                                                                                             ·
 │                       render 1      (agg1)[int]                       ·                                                                                                                                                             ·
 │                       render 2      (agg2)[int]                       ·                                                                                                                                                             ·
 │                       render 3      (agg3)[int]                       ·                                                                                                                                                             ·
 │                       render 4      ((agg4)[decimal]::FLOAT)[float]   ·                                                                                                                                                             ·
 │                       render 5      (agg5)[decimal]                   ·                                                                                                                                                             ·
 │                       render 6      (agg6)[decimal]                   ·                                                                                                                                                             ·
 │                       render 7      (agg7)[decimal]                   ·                                                                                                                                                             ·
 │                       render 8      (agg8)[bool]                      ·                                                                                                                                                             ·
 │                       render 9      (agg9)[bool]                      ·                                                                                                                                                             ·
 │                       render 10     (to_hex((agg10)[bytes]))[string]  ·                                                                                                                                                             ·
 └── group               ·             ·                                 (agg0 int, agg1 int, agg2 int, agg3 int, agg4 decimal, agg5 decimal, agg6 decimal, agg7 decimal, agg8 bool, agg9 bool, agg10 bytes)                           ·
      │                  aggregate 0   min(column1)                      ·                                                                                                                                                             ·
      │                  aggregate 1   count(column1)                    ·                                                                                                                                                             ·
      │                  aggregate 2   max(column1)                      ·                                                                                                                                                             ·
      │                  aggregate 3   sum_int(column1)                  ·                                                                                                                                                             ·
      │                  aggregate 4   avg(column1)                      ·                                                                                                                                                             ·
      │                  aggregate 5   sum(column1)                      ·                                                                                                                                                             ·
      │                  aggregate 6   stddev(column1)                   ·                                                                                                                                                             ·
      │                  aggregate 7   variance(column1)                 ·                                                                                                                                                             ·
      │                  aggregate 8   bool_and(column11)                ·                                                                                                                                                             ·
      │                  aggregate 9   bool_or(column11)                 ·                                                                                                                                                             ·
      │                  aggregate 10  xor_agg(column14)                 ·                                                                                                                                                             ·
      └── render         ·             ·                                 (column1 int, column11 bool, column14 bytes)                                                                                                                  ·
           │             render 0      (1)[int]                          ·                                                                                                                                                             ·
           │             render 1      (true)[bool]                      ·                                                                                                                                                             ·
           │             render 2      ('\x01')[bytes]                   ·                                                                                                                                                             ·
           └── emptyrow  ·             ·                                 ()                                                                                                                                                            ·

query TTTTT
EXPLAIN (TYPES) SELECT COUNT(*), k FROM kv GROUP BY 2
----
render          ·            ·             (count int, k int)  ·
 │              render 0     (agg0)[int]   ·                   ·
 │              render 1     (k)[int]      ·                   ·
 └── group      ·            ·             (k int, agg0 int)   ·
      │         aggregate 0  k             ·                   ·
      │         aggregate 1  count_rows()  ·                   ·
      │         group by     @1            ·                   ·
      └── scan  ·            ·             (k int)             ·
·               table        kv@primary    ·                   ·
·               spans        ALL           ·                   ·

# Selecting and grouping on a more complex expression works.
query TTTTT
EXPLAIN (TYPES) SELECT COUNT(*), k+v FROM kv GROUP BY k+v
----
render               ·            ·                           (count int, "k + v" int)  ·
 │                   render 0     (agg0)[int]                 ·                         ·
 │                   render 1     (column5)[int]              ·                         ·
 └── group           ·            ·                           (column5 int, agg0 int)   ·
      │              aggregate 0  column5                     ·                         ·
      │              aggregate 1  count_rows()                ·                         ·
      │              group by     @1                          ·                         ·
      └── render     ·            ·                           (column5 int)             ·
           │         render 0     ((k)[int] + (v)[int])[int]  ·                         ·
           └── scan  ·            ·                           (k int, v int)            ·
·                    table        kv@primary                  ·                         ·
·                    spans        ALL                         ·                         ·

# Selecting a more complex expression, made up of things which are each grouped, works.
query TTTTT
EXPLAIN (TYPES) SELECT COUNT(*), k+v FROM kv GROUP BY k, v
----
render          ·            ·                           (count int, "k + v" int)  ·
 │              render 0     (agg0)[int]                 ·                         ·
 │              render 1     ((k)[int] + (v)[int])[int]  ·                         ·
 └── group      ·            ·                           (k int, v int, agg0 int)  ·
      │         aggregate 0  k                           ·                         ·
      │         aggregate 1  v                           ·                         ·
      │         aggregate 2  count_rows()                ·                         ·
      │         group by     @1-@2                       ·                         ·
      └── scan  ·            ·                           (k int, v int)            ·
·               table        kv@primary                  ·                         ·
·               spans        ALL                         ·                         ·

query TTTTT
EXPLAIN (TYPES) SELECT COUNT(k) FROM kv
----
group      ·            ·           (count int)  ·
 │         aggregate 0  count(k)    ·            ·
 └── scan  ·            ·           (k int)      ·
·          table        kv@primary  ·            ·
·          spans        ALL         ·            ·

query TTTTT
EXPLAIN (TYPES) SELECT COUNT(k), SUM(k), MAX(k) FROM kv
----
group      ·            ·           (count int, sum decimal, max int)  ·
 │         aggregate 0  count(k)    ·                                  ·
 │         aggregate 1  sum(k)      ·                                  ·
 │         aggregate 2  max(k)      ·                                  ·
 └── scan  ·            ·           (k int)                            ·
·          table        kv@primary  ·                                  ·
·          spans        ALL         ·                                  ·

query TTTTT
EXPLAIN (VERBOSE) SELECT COUNT(DISTINCT a.*) FROM kv a, kv b
----
group                ·            ·                             (count)                                                       ·
 │                   aggregate 0  count(DISTINCT (k, v, w, s))  ·                                                             ·
 └── render          ·            ·                             ("(k, v, w, s)")                                              ·
      │              render 0     (a.k, a.v, a.w, a.s)          ·                                                             ·
      └── join       ·            ·                             (k, v, w, s, k[omitted], v[omitted], w[omitted], s[omitted])  ·
           │         type         cross                         ·                                                             ·
           ├── scan  ·            ·                             (k, v, w, s)                                                  k!=NULL; key(k)
           │         table        kv@primary                    ·                                                             ·
           │         spans        ALL                           ·                                                             ·
           └── scan  ·            ·                             (k[omitted], v[omitted], w[omitted], s[omitted])              k!=NULL; key(k)
·                    table        kv@primary                    ·                                                             ·
·                    spans        ALL                           ·                                                             ·

query TTT
SELECT "Tree", "Field", "Description" FROM [
EXPLAIN (VERBOSE) SELECT MIN(b.k) FROM kv a, kv b GROUP BY a.*
]
----
render               ·            ·
 │                   render 0     agg0
 └── group           ·            ·
      │              aggregate 0  k
      │              aggregate 1  v
      │              aggregate 2  w
      │              aggregate 3  s
      │              aggregate 4  min(k)
      │              group by     @1-@4
      └── join       ·            ·
           │         type         cross
           ├── scan  ·            ·
           │         table        kv@primary
           │         spans        ALL
           └── scan  ·            ·
·                    table        kv@primary
·                    spans        ALL

query TTT
SELECT "Tree", "Field", "Description" FROM [
EXPLAIN (VERBOSE) SELECT MIN(b.k) FROM kv a, kv b GROUP BY (1, (a.*))
]
----
render                    ·            ·
 │                        render 0     agg0
 └── group                ·            ·
      │                   aggregate 0  kv.k
      │                   aggregate 1  kv.v
      │                   aggregate 2  kv.w
      │                   aggregate 3  kv.s
      │                   aggregate 4  column9
      │                   aggregate 5  min(kv.k)
      │                   group by     @2,@3,@4,@5,@1
      └── render          ·            ·
           │              render 0     1
           │              render 1     k
           │              render 2     v
           │              render 3     w
           │              render 4     s
           │              render 5     k
           └── join       ·            ·
                │         type         cross
                ├── scan  ·            ·
                │         table        kv@primary
                │         spans        ALL
                └── scan  ·            ·
·                         table        kv@primary
·                         spans        ALL

# A useful optimization: naked tuple expansion in GROUP BY clause.
query TTT
SELECT "Tree", "Field", "Description" FROM [
EXPLAIN (VERBOSE) SELECT MIN(b.k) FROM kv a, kv b GROUP BY (a.*)
]
----
render               ·            ·
 │                   render 0     agg0
 └── group           ·            ·
      │              aggregate 0  k
      │              aggregate 1  v
      │              aggregate 2  w
      │              aggregate 3  s
      │              aggregate 4  min(k)
      │              group by     @1-@4
      └── join       ·            ·
           │         type         cross
           ├── scan  ·            ·
           │         table        kv@primary
           │         spans        ALL
           └── scan  ·            ·
·                    table        kv@primary
·                    spans        ALL

# Show reuse of renders expression inside an expansion.
query TTT
SELECT "Tree", "Field", "Description" FROM [
EXPLAIN (VERBOSE) SELECT a.k FROM kv a, kv b GROUP BY a.*
]
----
render               ·            ·
 │                   render 0     k
 └── group           ·            ·
      │              aggregate 0  k
      │              aggregate 1  v
      │              aggregate 2  w
      │              aggregate 3  s
      │              group by     @1-@4
      └── join       ·            ·
           │         type         cross
           ├── scan  ·            ·
           │         table        kv@primary
           │         spans        ALL
           └── scan  ·            ·
·                    table        kv@primary
·                    spans        ALL

statement ok
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)

query TTTTT
EXPLAIN (TYPES) SELECT MIN(a) FROM abc
----
group      ·            ·            (min string)  ·
 │         aggregate 0  min(a)       ·             ·
 └── scan  ·            ·            (a string)    ·
·          table        abc@primary  ·             ·
·          spans        ALL          ·             ·

statement ok
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)

statement ok
INSERT INTO xyz VALUES (1, 2, 3.0), (4, 5, 6.0), (7, NULL, 8.0)

query TTTTT
EXPLAIN (TYPES) SELECT MIN(x) FROM xyz
----
group      ·            ·            (min int)  ·
 │         aggregate 0  min(x)       ·          ·
 └── scan  ·            ·            (x int)    ·
·          table        xyz@primary  ·          ·
·          spans        ALL          ·          ·

# TODO(radu): we don't yet optimize this by scanning one entry from the xy index.
query TTTTT
EXPLAIN (TYPES) SELECT MIN(x) FROM xyz WHERE x in (0, 4, 7)
----
group      ·            ·                        (min int)  ·
 │         aggregate 0  min(x)                   ·          ·
 └── scan  ·            ·                        (x int)    ·
·          table        xyz@primary              ·          ·
·          spans        /0-/0/# /4-/4/# /7-/7/#  ·          ·

# TODO(radu): we don't yet optimize MIN/MAX by scanning one entry from the xy index.
query TTTTT
EXPLAIN (TYPES) SELECT MAX(x) FROM xyz
----
group      ·            ·            (max int)  ·
 │         aggregate 0  max(x)       ·          ·
 └── scan  ·            ·            (x int)    ·
·          table        xyz@primary  ·          ·
·          spans        ALL          ·          ·

query TTTTT
EXPLAIN (TYPES) SELECT MIN(y) FROM xyz WHERE x = 1
----
group      ·            ·            (min int)       ·
 │         aggregate 0  min(y)       ·               ·
 └── scan  ·            ·            (x int, y int)  ·
·          table        xyz@primary  ·               ·
·          spans        /1-/1/#      ·               ·

query TTTTT
EXPLAIN (TYPES) SELECT MAX(y) FROM xyz WHERE x = 1
----
group      ·            ·            (max int)       ·
 │         aggregate 0  max(y)       ·               ·
 └── scan  ·            ·            (x int, y int)  ·
·          table        xyz@primary  ·               ·
·          spans        /1-/1/#      ·               ·

query TTTTT
EXPLAIN (TYPES) SELECT MIN(y) FROM xyz WHERE x = 7
----
group      ·            ·            (min int)       ·
 │         aggregate 0  min(y)       ·               ·
 └── scan  ·            ·            (x int, y int)  ·
·          table        xyz@primary  ·               ·
·          spans        /7-/7/#      ·               ·

query TTTTT
EXPLAIN (TYPES) SELECT MAX(y) FROM xyz WHERE x = 7
----
group      ·            ·            (max int)       ·
 │         aggregate 0  max(y)       ·               ·
 └── scan  ·            ·            (x int, y int)  ·
·          table        xyz@primary  ·               ·
·          spans        /7-/7/#      ·               ·

query TTTTT
EXPLAIN (TYPES) SELECT MIN(x) FROM xyz WHERE (y, z) = (2, 3.0)
----
group      ·            ·          (min int)                ·
 │         aggregate 0  min(x)     ·                        ·
 └── scan  ·            ·          (x int, y int, z float)  ·
·          table        xyz@zyx    ·                        ·
·          spans        /3/2-/3/3  ·                        ·

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT MIN(x) FROM xyz WHERE (y, z) = (2, 3.0)]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /xyz/zyx/3.0/2/1 -> NULL
output row: [1]

query TTTTT
EXPLAIN (TYPES) SELECT MAX(x) FROM xyz WHERE (z, y) = (3.0, 2)
----
group      ·            ·          (max int)                ·
 │         aggregate 0  max(x)     ·                        ·
 └── scan  ·            ·          (x int, y int, z float)  ·
·          table        xyz@zyx    ·                        ·
·          spans        /3/2-/3/3  ·                        ·

# VARIANCE/STDDEV

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT VARIANCE(x), VARIANCE(y::decimal), round(VARIANCE(z), 14) FROM xyz]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /xyz/primary/1 -> NULL
fetched: /xyz/primary/1/y -> 2
fetched: /xyz/primary/1/z -> 3.0
fetched: /xyz/primary/4 -> NULL
fetched: /xyz/primary/4/y -> 5
fetched: /xyz/primary/4/z -> 6.0
fetched: /xyz/primary/7 -> NULL
fetched: /xyz/primary/7/z -> 8.0
output row: [9 4.5 6.33333333333333]

query TTTTT
EXPLAIN (TYPES) SELECT VARIANCE(x) FROM xyz WHERE x = 1
----
group      ·            ·            (variance decimal)  ·
 │         aggregate 0  variance(x)  ·                   ·
 └── scan  ·            ·            (x int)             ·
·          table        xyz@primary  ·                   ·
·          spans        /1-/1/#      ·                   ·

## Tests for the single-row optimization.
statement ok
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)

statement ok
INSERT INTO ab VALUES
  (1, 10),
  (2, 20),
  (3, 30),
  (4, 40),
  (5, 50)

# TODO(radu): we don't support the single-row optimization yet.
#exec nodist
#EXPLAIN (EXPRS) SELECT MIN(a) FROM abc
#----
#group           ·            ·
# │              aggregate 0  min(a)
# └── render     ·            ·
#      │         render 0     a
#      └── scan  ·            ·
#·               table        abc@primary
#·               spans        ALL
#·               limit        1
#
## Verify we only buffer one row.
#exec
#SELECT message FROM [SHOW KV TRACE FOR SELECT MIN(a) FROM ab]
# WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
#----
#fetched: /ab/primary/1 -> NULL
#fetched: /ab/primary/1/b -> 10
#output row: [1]
#
#exec nodist
#EXPLAIN (EXPRS) SELECT MAX(a) FROM abc
#----
#group              ·            ·
# │                 aggregate 0  max(a)
# └── render        ·            ·
#      │            render 0     a
#      └── revscan  ·            ·
#·                  table        abc@primary
#·                  spans        ALL
#·                  limit        1
#
## Verify we only buffer one row.
#exec
#SELECT message FROM [SHOW KV TRACE FOR SELECT MAX(a) FROM ab]
# WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
#----
#fetched: /ab/primary/5/b -> 50
#fetched: /ab/primary/5 -> NULL
#output row: [5]

query TTTTT
EXPLAIN (TYPES) SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k)
----
sort            ·            ·           (v int, count int)  +count
 │              order        +count      ·                   ·
 └── group      ·            ·           (v int, count int)  ·
      │         aggregate 0  v           ·                   ·
      │         aggregate 1  count(k)    ·                   ·
      │         group by     @2          ·                   ·
      └── scan  ·            ·           (k int, v int)      ·
·               table        kv@primary  ·                   ·
·               spans        ALL         ·                   ·

query TTTTT
EXPLAIN (TYPES) SELECT v, COUNT(*) FROM kv GROUP BY v ORDER BY COUNT(*)
----
sort            ·            ·             (v int, count int)  +count
 │              order        +count        ·                   ·
 └── group      ·            ·             (v int, count int)  ·
      │         aggregate 0  v             ·                   ·
      │         aggregate 1  count_rows()  ·                   ·
      │         group by     @1            ·                   ·
      └── scan  ·            ·             (v int)             ·
·               table        kv@primary    ·                   ·
·               spans        ALL           ·                   ·

query TTTTT
EXPLAIN (TYPES) SELECT v, COUNT(1) FROM kv GROUP BY v ORDER BY COUNT(1)
----
sort                 ·            ·               (v int, count int)         +count
 │                   order        +count          ·                          ·
 └── group           ·            ·               (v int, count int)         ·
      │              aggregate 0  kv.v            ·                          ·
      │              aggregate 1  count(column5)  ·                          ·
      │              group by     @2              ·                          ·
      └── render     ·            ·               (column5 int, "kv.v" int)  ·
           │         render 0     (1)[int]        ·                          ·
           │         render 1     (v)[int]        ·                          ·
           └── scan  ·            ·               (v int)                    ·
·                    table        kv@primary      ·                          ·
·                    spans        ALL             ·                          ·

# TODO(radu): we don't propagate filters yet.
## Check that filters propagate through no-op aggregation.
#exec nodist
#EXPLAIN(EXPRS) SELECT * FROM (SELECT v, COUNT(1) FROM kv GROUP BY v) WHERE v > 10
#----
#group           ·            ·
# │              aggregate 0  v
# │              aggregate 1  count(1)
# │              group by     @1
# └── render     ·            ·
#      │         render 0     v
#      │         render 1     1
#      └── scan  ·            ·
#·               table        kv@primary
#·               spans        ALL
#·               filter       v > 10

# TODO(radu): FILTER not yet supported.
## Verify that FILTER works.
#
#exec-raw
#CREATE TABLE filter_test (
#  k INT,
#  v INT,
#  mark BOOL
#)
#----
#
## Check that filter expressions are only rendered once.
#exec nodist
#EXPLAIN (EXPRS) SELECT COUNT(*) FILTER (WHERE k>5), MAX(k>5) FILTER(WHERE k>5) FROM filter_test GROUP BY v
#----
#group           ·            ·
# │              aggregate 0  count_rows() FILTER (WHERE k > 5)
# │              aggregate 1  max(k > 5) FILTER (WHERE k > 5)
# │              group by     @1
# └── render     ·            ·
#      │         render 0     v
#      │         render 1     k > 5
#      └── scan  ·            ·
#·               table        filter_test@primary
#·               spans        ALL
#
#exec nodist
#EXPLAIN (TYPES) SELECT COUNT(*) FILTER (WHERE k > 5) FROM filter_test GROUP BY v
#----
#group           0  group   ·            ·                                  (count int)                                                    ·
# │              0  ·       aggregate 0  count_rows() FILTER (WHERE k > 5)  ·                                                              ·
# │              0  ·       group by     @1                                 ·                                                              ·
# └── render     1  render  ·            ·                                  (v int, "k > 5" bool)                                          ·
#      │         1  ·       render 0     (v)[int]                           ·                                                              ·
#      │         1  ·       render 1     ((k)[int] > (5)[int])[bool]        ·                                                              ·
#      └── scan  2  scan    ·            ·                                  (k int, v int, mark[omitted] bool, rowid[hidden,omitted] int)  rowid!=NULL; key(rowid)
#·               2  ·       table        filter_test@primary                ·                                                              ·
#·               2  ·       spans        ALL                                ·                                                              ·

# Tests with * inside GROUP BY.
query TTTTT
EXPLAIN (TYPES) SELECT 1 FROM kv GROUP BY kv.*;
----
render     ·         ·           ("1" int)  ·
 │         render 0  (1)[int]    ·          ·
 └── scan  ·         ·           ()         ·
·          table     kv@primary  ·          ·
·          spans     ALL         ·          ·

query TTTTT
EXPLAIN (TYPES) SELECT SUM(abc.d) FROM kv JOIN abc ON kv.k >= abc.d GROUP BY kv.*;
----
render               ·            ·                                 (sum decimal)                                  ·
 │                   render 0     (agg0)[decimal]                   ·                                              ·
 └── group           ·            ·                                 (k int, v int, w int, s string, agg0 decimal)  ·
      │              aggregate 0  k                                 ·                                              ·
      │              aggregate 1  v                                 ·                                              ·
      │              aggregate 2  w                                 ·                                              ·
      │              aggregate 3  s                                 ·                                              ·
      │              aggregate 4  sum(d)                            ·                                              ·
      │              group by     @1-@4                             ·                                              ·
      └── join       ·            ·                                 (k int, v int, w int, s string, d decimal)     ·
           │         type         inner                             ·                                              ·
           │         pred         ((k)[int] >= (d)[decimal])[bool]  ·                                              ·
           ├── scan  ·            ·                                 (k int, v int, w int, s string)                ·
           │         table        kv@primary                        ·                                              ·
           │         spans        ALL                               ·                                              ·
           └── scan  ·            ·                                 (d decimal)                                    ·
·                    table        abc@primary                       ·                                              ·
·                    spans        ALL                               ·                                              ·

# TODO(radu): single-row optimization not yet supported.
## opt_test is used for tests around the single-row optimization for MIN/MAX.
#exec-raw
#CREATE TABLE opt_test (k INT PRIMARY KEY, v INT, INDEX v(v))
#----
#
## Verify that we correctly add the v IS NOT NULL constraint (which restricts the span).
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT MIN(v) FROM opt_test
#----
#group           0  group   ·            ·                       (min)            ·
# │              0  ·       aggregate 0  min(v)                  ·                ·
# └── render     1  render  ·            ·                       (v)              v!=NULL; +v
#      │         1  ·       render 0     test.public.opt_test.v  ·                ·
#      └── scan  2  scan    ·            ·                       (k[omitted], v)  k!=NULL; v!=NULL; key(k,v); +v
#·               2  ·       table        opt_test@v              ·                ·
#·               2  ·       spans        /!NULL-                 ·                ·
#·               2  ·       limit        1                       ·                ·
#
## Repeat test when there is an existing filter.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT MIN(v) FROM opt_test WHERE k <> 4
#----
#group           0  group   ·            ·                       (min)   ·
# │              0  ·       aggregate 0  min(v)                  ·       ·
# └── render     1  render  ·            ·                       (v)     v!=NULL; +v
#      │         1  ·       render 0     test.public.opt_test.v  ·       ·
#      └── scan  2  scan    ·            ·                       (k, v)  k!=NULL; v!=NULL; key(k,v); +v
#·               2  ·       table        opt_test@v              ·       ·
#·               2  ·       spans        /!NULL-                 ·       ·
#·               2  ·       filter       k != 4                  ·       ·
#
## Check the optimization when the argument is non-trivial. The renderNode can't
## present an ordering on v+1 so the optimization is not applied, but the IS NOT
## NULL filter should be added.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT MIN(v+1) FROM opt_test WHERE k <> 4
#----
#group           0  group   ·            ·                           (min)            ·
# │              0  ·       aggregate 0  min(v + 1)                  ·                ·
# └── render     1  render  ·            ·                           ("v + 1")        ·
#      │         1  ·       render 0     test.public.opt_test.v + 1  ·                ·
#      └── scan  2  scan    ·            ·                           (k[omitted], v)  k!=NULL; v!=NULL; key(k)
#·               2  ·       table        opt_test@primary            ·                ·
#·               2  ·       spans        -/3/# /5-                   ·                ·
#·               2  ·       filter       (v + 1) IS NOT NULL         ·                ·
#
## Verify that we don't use the optimization if there is a GROUP BY.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT MIN(v) FROM opt_test GROUP BY k
#----
#group      0  group  ·            ·                 (min)   ·
# │         0  ·      aggregate 0  min(v)            ·       ·
# │         0  ·      group by     @1                ·       ·
# └── scan  1  scan   ·            ·                 (k, v)  k!=NULL; key(k)
#·          1  ·      table        opt_test@primary  ·       ·
#·          1  ·      spans        ALL               ·       ·

statement ok
CREATE TABLE xy(x STRING, y STRING);

# TODO(radu): this requires tuples but they are not yet supported in
# distsql (#15938).
query TTTTT
EXPLAIN (TYPES) SELECT (b, a) FROM ab GROUP BY (b, a)
----
render     ·         ·                                        ("(b, a)" tuple{int, int})  ·
 │         render 0  (((b)[int], (a)[int]))[tuple{int, int}]  ·                           ·
 └── scan  ·         ·                                        (a int, b int)              ·
·          table     ab@primary                               ·                           ·
·          spans     ALL                                      ·                           ·

query TTTTT
EXPLAIN (TYPES) SELECT MIN(y), (b, a) FROM ab, xy GROUP BY (x, (a, b))
----
render               ·            ·                                        (min string, "(b, a)" tuple{int, int})  ·
 │                   render 0     (agg0)[string]                           ·                                       ·
 │                   render 1     (((b)[int], (a)[int]))[tuple{int, int}]  ·                                       ·
 └── group           ·            ·                                        (a int, b int, x string, agg0 string)   ·
      │              aggregate 0  a                                        ·                                       ·
      │              aggregate 1  b                                        ·                                       ·
      │              aggregate 2  x                                        ·                                       ·
      │              aggregate 3  min(y)                                   ·                                       ·
      │              group by     @1-@3                                    ·                                       ·
      └── join       ·            ·                                        (a int, b int, x string, y string)      ·
           │         type         cross                                    ·                                       ·
           ├── scan  ·            ·                                        (a int, b int)                          ·
           │         table        ab@primary                               ·                                       ·
           │         spans        ALL                                      ·                                       ·
           └── scan  ·            ·                                        (x string, y string)                    ·
·                    table        xy@primary                               ·                                       ·
·                    spans        ALL                                      ·                                       ·

# Test that ordering on GROUP BY columns is maintained.
# TODO(radu): Derive GROUP BY ordering in physicalPropsBuilder.
#exec-raw
#CREATE TABLE group_ord (
#  x INT PRIMARY KEY,
#  y INT,
#  z INT,
#  INDEX foo(z)
#)
#----
#
## The ordering is on all the GROUP BY columns, and isn't preserved after the
## aggregation.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT x, max(y) FROM group_ord GROUP BY x
#----
#group      ·            ·                  (x, max)  ·
# │         aggregate 0  x                  ·         ·
# │         aggregate 1  max(y)             ·         ·
# │         group by     @1                 ·         ·
# └── scan  ·            ·                  (x, y)    ·
#·          table        group_ord@primary  ·         ·
#·          spans        ALL                ·         ·
#
## The ordering is on all the GROUP BY columns, and is preserved after the
## aggregation.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT x, max(y) FROM group_ord GROUP BY x ORDER BY x
#----
#sort            ·            ·                  (x, max)  +x
# │              order        +x                 ·         ·
# └── group      ·            ·                  (x, max)  ·
#      │         aggregate 0  x                  ·         ·
#      │         aggregate 1  max(y)             ·         ·
#      │         group by     @1                 ·         ·
#      └── scan  ·            ·                  (x, y)    ·
#·               table        group_ord@primary  ·         ·
#·               spans        ALL                ·         ·
#
## The ordering is on some of the GROUP BY columns, and isn't preserved after
## the aggregation.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT z, x, max(y) FROM group_ord GROUP BY x, z
#----
#render          ·            ·                  (z, x, max)   ·
# │              render 0     z                  ·             ·
# │              render 1     x                  ·             ·
# │              render 2     agg0               ·             ·
# └── group      ·            ·                  (x, z, agg0)  ·
#      │         aggregate 0  x                  ·             ·
#      │         aggregate 1  z                  ·             ·
#      │         aggregate 2  max(y)             ·             ·
#      │         group by     @1,@3              ·             ·
#      └── scan  ·            ·                  (x, y, z)     ·
#·               table        group_ord@primary  ·             ·
#·               spans        ALL                ·             ·
#
## The ordering is on some of the GROUP BY columns, and is preserved after
## the aggregation.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT z, x, max(y) FROM group_ord GROUP BY x, z ORDER BY x
#----
#render               ·            ·                  (z, x, max)   ·
# │                   render 0     z                  ·             ·
# │                   render 1     x                  ·             ·
# │                   render 2     agg0               ·             ·
# └── sort            ·            ·                  (x, z, agg0)  +x
#      │              order        +x                 ·             ·
#      └── group      ·            ·                  (x, z, agg0)  ·
#           │         aggregate 0  x                  ·             ·
#           │         aggregate 1  z                  ·             ·
#           │         aggregate 2  max(y)             ·             ·
#           │         group by     @1,@3              ·             ·
#           └── scan  ·            ·                  (x, y, z)     ·
#·                    table        group_ord@primary  ·             ·
#·                    spans        ALL                ·             ·
#
## If the underlying ordering isn't from the primary index, it needs to be hinted
## for now.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT z, max(y) FROM group_ord@foo GROUP BY z
#----
#group      ·            ·                  (z, max)  ·
# │         aggregate 0  z                  ·         ·
# │         aggregate 1  max(y)             ·         ·
# │         group by     @2                 ·         ·
# └── scan  ·            ·                  (y, z)    ·
#·          table        group_ord@primary  ·         ·
#·          spans        ALL                ·         ·
#
## Test that a merge join is used on two aggregate subqueries with orderings on
## the GROUP BY columns. Note that an ORDER BY is not necessary on the
## subqueries.
#exec hide-colnames nodist
#EXPLAIN (TYPES) SELECT * FROM (SELECT x, max(y) FROM group_ord GROUP BY x) JOIN (SELECT z, min(y) FROM group_ord@foo GROUP BY z) ON x = z
#----
#join            ·            ·                  (x, max, z, min)  ·
# │              type         inner              ·                 ·
# │              equality     (x) = (z)          ·                 ·
# ├── group      ·            ·                  (x, agg0)         ·
# │    │         aggregate 0  x                  ·                 ·
# │    │         aggregate 1  max(y)             ·                 ·
# │    │         group by     @1                 ·                 ·
# │    └── scan  ·            ·                  (x, y)            ·
# │              table        group_ord@primary  ·                 ·
# │              spans        ALL                ·                 ·
# └── group      ·            ·                  (z, agg0)         ·
#      │         aggregate 0  z                  ·                 ·
#      │         aggregate 1  min(y)             ·                 ·
#      │         group by     @2                 ·                 ·
#      └── scan  ·            ·                  (y, z)            ·
#·               table        group_ord@primary  ·                 ·
#·               spans        ALL                ·                 ·

# Regression test for #25533 (crash when propagating filter through GROUP BY).
query TTTTT
EXPLAIN (TYPES) SELECT 1 FROM kv GROUP BY v, w::DECIMAL HAVING w::DECIMAL > 1;
----
render                    ·            ·                                          ("1" int)                      ·
 │                        render 0     (1)[int]                                   ·                              ·
 └── group                ·            ·                                          ("kv.v" int, column5 decimal)  ·
      │                   aggregate 0  kv.v                                       ·                              ·
      │                   aggregate 1  column5                                    ·                              ·
      │                   group by     @2,@1                                      ·                              ·
      └── filter          ·            ·                                          (column5 decimal, "kv.v" int)  ·
           │              filter       ((column5)[decimal] > (1)[decimal])[bool]  ·                              ·
           └── render     ·            ·                                          (column5 decimal, "kv.v" int)  ·
                │         render 0     ((w)[int]::DECIMAL)[decimal]               ·                              ·
                │         render 1     (v)[int]                                   ·                              ·
                └── scan  ·            ·                                          (v int, w int)                 ·
·                         table        kv@primary                                 ·                              ·
·                         spans        ALL                                        ·                              ·

statement ok
CREATE TABLE foo(a INT, b CHAR)

# Check that GROUP BY picks up column ordinals.
query TTTTT
EXPLAIN (VERBOSE) SELECT min(a) AS m FROM foo GROUP BY @1
----
render               ·            ·            (m)                 ·
 │                   render 0     agg0         ·                   ·
 └── group           ·            ·            (column4, agg0)     ·
      │              aggregate 0  column4      ·                   ·
      │              aggregate 1  min(foo.a)   ·                   ·
      │              group by     @1           ·                   ·
      └── render     ·            ·            (column4, "foo.a")  ·
           │         render 0     a            ·                   ·
           │         render 1     a            ·                   ·
           └── scan  ·            ·            (a)                 ·
·                    table        foo@primary  ·                   ·
·                    spans        ALL          ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT min(a) AS m FROM foo GROUP BY @2
----
render               ·            ·            (m)                 ·
 │                   render 0     agg0         ·                   ·
 └── group           ·            ·            (column4, agg0)     ·
      │              aggregate 0  column4      ·                   ·
      │              aggregate 1  min(foo.a)   ·                   ·
      │              group by     @1           ·                   ·
      └── render     ·            ·            (column4, "foo.a")  ·
           │         render 0     b            ·                   ·
           │         render 1     a            ·                   ·
           └── scan  ·            ·            (a, b)              ·
·                    table        foo@primary  ·                   ·
·                    spans        ALL          ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT ARRAY_AGG(v) FROM (SELECT * FROM kv ORDER BY v)
----
group           ·            ·             (array_agg)  ·
 │              aggregate 0  array_agg(v)  ·            ·
 └── sort       ·            ·             (v)          +v
      │         order        +v            ·            ·
      └── scan  ·            ·             (v)          ·
·               table        kv@primary    ·            ·
·               spans        ALL           ·            ·

query TTTTT
EXPLAIN (VERBOSE) SELECT k FROM kv ORDER BY s
----
render          ·         ·           (k)     ·
 │              render 0  k           ·       ·
 └── sort       ·         ·           (k, s)  +s
      │         order     +s          ·       ·
      └── scan  ·         ·           (k, s)  ·
·               table     kv@primary  ·       ·
·               spans     ALL         ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT CONCAT_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
----
group      ·            ·              (concat_agg)  ·
 │         aggregate 0  concat_agg(s)  ·             ·
 └── scan  ·            ·              (k, s)        +k
·          table        kv@primary     ·             ·
·          spans        ALL            ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT ARRAY_AGG(k) FROM (SELECT k FROM kv ORDER BY s)
----
group           ·            ·             (array_agg)  ·
 │              aggregate 0  array_agg(k)  ·            ·
 └── sort       ·            ·             (k, s)       +s
      │         order        +s            ·            ·
      └── scan  ·            ·             (k, s)       ·
·               table        kv@primary    ·            ·
·               spans        ALL           ·            ·
