# tests adapted from logictest -- aggregate

exec-raw
CREATE TABLE kv (
  k INT PRIMARY KEY,
  v INT,
  w INT,
  s STRING
)
----

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(false), XOR_AGG(b'\x01') FROM kv
----
group           ·             ·                   (column6, column7, column8, column9, column10, column11, column12, column13, column15, column17, column19)  ·
 │              aggregate 0   min(column5)        ·                                                                                                           ·
 │              aggregate 1   max(column5)        ·                                                                                                           ·
 │              aggregate 2   count(column5)      ·                                                                                                           ·
 │              aggregate 3   sum_int(column5)    ·                                                                                                           ·
 │              aggregate 4   avg(column5)        ·                                                                                                           ·
 │              aggregate 5   sum(column5)        ·                                                                                                           ·
 │              aggregate 6   stddev(column5)     ·                                                                                                           ·
 │              aggregate 7   variance(column5)   ·                                                                                                           ·
 │              aggregate 8   bool_and(column14)  ·                                                                                                           ·
 │              aggregate 9   bool_or(column16)   ·                                                                                                           ·
 │              aggregate 10  xor_agg(column18)   ·                                                                                                           ·
 └── render     ·             ·                   (column5, column14, column16, column18)                                                                     ·
      │         render 0      1                   ·                                                                                                           ·
      │         render 1      true                ·                                                                                                           ·
      │         render 2      false               ·                                                                                                           ·
      │         render 3      '\x01'              ·                                                                                                           ·
      └── scan  ·             ·                   ()                                                                                                          ·
·               table         kv@primary          ·                                                                                                           ·
·               spans         ALL                 ·                                                                                                           ·

exec
SELECT MIN(1), MAX(1), COUNT(1), SUM_INT(1), AVG(1), SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(false), XOR_AGG(b'\x01') FROM kv
----
column6:int  column7:int  column8:int  column9:int  column10:decimal  column11:decimal  column12:decimal  column13:decimal  column15:bool  column17:bool  column19:bytes
NULL         NULL         0            NULL         NULL              NULL              NULL              NULL              NULL           NULL           NULL

# Aggregate functions return NULL if there are no rows.
exec
SELECT ARRAY_AGG(1) FROM kv
----
column6:int[]
NULL

exec
SELECT JSON_AGG(1) FROM kv
----
column6:jsonb
NULL

exec
SELECT JSONB_AGG(1) FROM kv
----
column6:jsonb
NULL

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(v), MAX(v), COUNT(v), SUM_INT(1), AVG(v), SUM(v), STDDEV(v), VARIANCE(v), BOOL_AND(v = 1), BOOL_AND(v = 1), XOR_AGG(s::bytes) FROM kv
----
render               ·            ·                   (column5, column6, column7, column9, column10, column11, column12, column13, column15, column15, column17)  ·
 │                   render 0     agg0                ·                                                                                                           ·
 │                   render 1     agg1                ·                                                                                                           ·
 │                   render 2     agg2                ·                                                                                                           ·
 │                   render 3     agg3                ·                                                                                                           ·
 │                   render 4     agg4                ·                                                                                                           ·
 │                   render 5     agg5                ·                                                                                                           ·
 │                   render 6     agg6                ·                                                                                                           ·
 │                   render 7     agg7                ·                                                                                                           ·
 │                   render 8     agg8                ·                                                                                                           ·
 │                   render 9     agg8                ·                                                                                                           ·
 │                   render 10    agg9                ·                                                                                                           ·
 └── group           ·            ·                   (agg0, agg1, agg2, agg3, agg4, agg5, agg6, agg7, agg8, agg9)                                                ·
      │              aggregate 0  min(kv.v)           ·                                                                                                           ·
      │              aggregate 1  max(kv.v)           ·                                                                                                           ·
      │              aggregate 2  count(kv.v)         ·                                                                                                           ·
      │              aggregate 3  sum_int(column8)    ·                                                                                                           ·
      │              aggregate 4  avg(kv.v)           ·                                                                                                           ·
      │              aggregate 5  sum(kv.v)           ·                                                                                                           ·
      │              aggregate 6  stddev(kv.v)        ·                                                                                                           ·
      │              aggregate 7  variance(kv.v)      ·                                                                                                           ·
      │              aggregate 8  bool_and(column14)  ·                                                                                                           ·
      │              aggregate 9  xor_agg(column16)   ·                                                                                                           ·
      └── render     ·            ·                   (column8, column14, column16, "kv.v")                                                                       ·
           │         render 0     1                   ·                                                                                                           ·
           │         render 1     v = 1               ·                                                                                                           ·
           │         render 2     s::BYTES            ·                                                                                                           ·
           │         render 3     v                   ·                                                                                                           ·
           └── scan  ·            ·                   (v, s)                                                                                                      ·
·                    table        kv@primary          ·                                                                                                           ·
·                    spans        ALL                 ·                                                                                                           ·

exec
SELECT MIN(v), MAX(v), COUNT(v), SUM_INT(1), AVG(v), SUM(v), STDDEV(v), VARIANCE(v), BOOL_AND(v = 1), BOOL_AND(v = 1), XOR_AGG(s::bytes) FROM kv
----
column5:int  column6:int  column7:int  column9:int  column10:decimal  column11:decimal  column12:decimal  column13:decimal  column15:bool  column15:bool  column17:bytes
NULL         NULL         0            NULL         NULL              NULL              NULL              NULL              NULL           NULL           NULL

exec
SELECT ARRAY_AGG(v) FROM kv
----
column5:int[]
NULL

exec
SELECT JSON_AGG(v) FROM kv
----
column5:jsonb
NULL

exec
SELECT JSONB_AGG(v) FROM kv
----
column5:jsonb
NULL

# Aggregate functions trigger aggregation and computation when there is no source.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
render                 ·             ·                   (column2, column3, column4, column5, column7, column8, column9, column10, column12, column13, column16)  ·
 │                     render 0      agg0                ·                                                                                                        ·
 │                     render 1      agg1                ·                                                                                                        ·
 │                     render 2      agg2                ·                                                                                                        ·
 │                     render 3      agg3                ·                                                                                                        ·
 │                     render 4      agg4::FLOAT         ·                                                                                                        ·
 │                     render 5      agg5                ·                                                                                                        ·
 │                     render 6      agg6                ·                                                                                                        ·
 │                     render 7      agg7                ·                                                                                                        ·
 │                     render 8      agg8                ·                                                                                                        ·
 │                     render 9      agg9                ·                                                                                                        ·
 │                     render 10     to_hex(agg10)       ·                                                                                                        ·
 └── group             ·             ·                   (agg0, agg1, agg2, agg3, agg4, agg5, agg6, agg7, agg8, agg9, agg10)                                      ·
      │                aggregate 0   min(column1)        ·                                                                                                        ·
      │                aggregate 1   count(column1)      ·                                                                                                        ·
      │                aggregate 2   max(column1)        ·                                                                                                        ·
      │                aggregate 3   sum_int(column1)    ·                                                                                                        ·
      │                aggregate 4   avg(column1)        ·                                                                                                        ·
      │                aggregate 5   sum(column1)        ·                                                                                                        ·
      │                aggregate 6   stddev(column1)     ·                                                                                                        ·
      │                aggregate 7   variance(column1)   ·                                                                                                        ·
      │                aggregate 8   bool_and(column11)  ·                                                                                                        ·
      │                aggregate 9   bool_or(column11)   ·                                                                                                        ·
      │                aggregate 10  xor_agg(column14)   ·                                                                                                        ·
      └── render       ·             ·                   (column1, column11, column14)                                                                            ·
           │           render 0      1                   ·                                                                                                        ·
           │           render 1      true                ·                                                                                                        ·
           │           render 2      '\x01'              ·                                                                                                        ·
           └── values  ·             ·                   ()                                                                                                       ·
·                      size          0 columns, 1 row    ·                                                                                                        ·

exec
SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
column2:int  column3:int  column4:int  column5:int  column7:float  column8:decimal  column9:decimal  column10:decimal  column12:bool  column13:bool  column16:string
1            1            1            1            1.0            1                NULL             NULL              true           true           01

# Aggregate functions triggers aggregation and computation when there is no source.
exec
SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1), VARIANCE(1), BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01'))
----
column2:int  column3:int  column4:int  column5:int  column7:float  column8:decimal  column9:decimal  column10:decimal  column12:bool  column13:bool  column16:string
1            1            1            1            1.0            1                NULL             NULL              true           true           01

# Aggregate functions triggers aggregation and computation when there is no source.
exec
SELECT ARRAY_AGG(1)
----
column2:int[]
ARRAY[1]

exec
SELECT JSON_AGG(1)
----
column2:jsonb
'[1]'

exec
SELECT JSONB_AGG(1)
----
column2:jsonb
'[1]'

# Some aggregate functions are not normalized to NULL when given a NULL
# argument.
exec
SELECT COUNT(NULL)
----
column2:int
0

exec
SELECT JSON_AGG(NULL)
----
column2:jsonb
'[null]'

exec
SELECT JSONB_AGG(NULL)
----
column2:jsonb
'[null]'

# With an explicit cast, this works as expected.
# TODO(radu): investigate distsql issue (relate to the input type)
exec nodist
SELECT ARRAY_AGG(NULL::TEXT)
----
column2:string[]
ARRAY[NULL]

# TODO(radu): Selecting from series not supported yet.
## Check that COALESCE using aggregate results over an empty table
## work properly.
#exec
#SELECT COALESCE(MAX(1), 0) FROM generate_series(1,0)
#----
#0
#
#exec
#SELECT COUNT_ROWS() FROM generate_series(1,100)
#----
#100
#
## Same, using arithmetic on COUNT.
#exec
#SELECT 1 + COUNT(*) FROM generate_series(1,0)
#----
#1

# Same, using an empty table.
# The following test *must* occur before the first INSERT to the tables,
# so that it can observe an empty table.
exec
SELECT COUNT(*), COALESCE(MAX(k), 1) FROM kv
----
column5:int  column7:int
0            1

# TODO(radu): Subqueries not implemented yet.
## Same, using a subquery. (#12705)
#exec
#SELECT (SELECT COALESCE(MAX(1), 0) FROM generate_series(1,0))
#----
#0

exec-raw
INSERT INTO kv VALUES
(1, 2, 3, 'a'),
(3, 4, 5, 'a'),
(5, NULL, 5, NULL),
(6, 2, 3, 'b'),
(7, 2, 2, 'b'),
(8, 4, 2, 'A')
----

# Aggregate functions triggers aggregation and computation for every row even when applied to a constant.
# NB: The XOR result is 00 because \x01 is XOR'd an even number of times.
exec
SELECT MIN(1), COUNT(1), MAX(1), SUM_INT(1), AVG(1)::float, SUM(1), STDDEV(1), VARIANCE(1)::float, BOOL_AND(true), BOOL_OR(true), TO_HEX(XOR_AGG(b'\x01')) FROM kv
----
column6:int  column7:int  column8:int  column9:int  column11:float  column12:decimal  column13:decimal  column15:float  column17:bool  column18:bool  column21:string
1            6            1            6            1.0             6                 0                 0.0             true           true           00

# Aggregate functions triggers aggregation and computation for every row even when applied to a constant.
exec
SELECT ARRAY_AGG(1) FROM kv
----
column6:int[]
ARRAY[1,1,1,1,1,1]

exec
SELECT JSON_AGG(1) FROM kv
----
column6:jsonb
'[1, 1, 1, 1, 1, 1]'

exec
SELECT JSONB_AGG(1) FROM kv
----
column6:jsonb
'[1, 1, 1, 1, 1, 1]'

# Even with no aggregate functions, grouping occurs in the presence of GROUP BY.
exec rowsort
SELECT 1 FROM kv GROUP BY v
----
column5:int
1
1
1

# Presence of HAVING triggers aggregation, reducing results to one row (even without GROUP BY).
exec
SELECT 3 FROM kv HAVING TRUE
----
column5:int
3

exec rowsort
SELECT COUNT(*), k FROM kv GROUP BY k
----
column5:int  k:int
1            1
1            3
1            5
1            6
1            7
1            8

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT COUNT(*), k FROM kv GROUP BY 2
----
render          ·            ·             (column5, k)  ·
 │              render 0     agg0          ·             ·
 │              render 1     k             ·             ·
 └── group      ·            ·             (k, agg0)     ·
      │         aggregate 0  k             ·             ·
      │         aggregate 1  count_rows()  ·             ·
      │         group by     @1            ·             ·
      └── scan  ·            ·             (k)           ·
·               table        kv@primary    ·             ·
·               spans        ALL           ·             ·

# GROUP BY specified using column index works.
exec rowsort
SELECT COUNT(*), k FROM kv GROUP BY 2
----
column5:int  k:int
1            1
1            3
1            5
1            6
1            7
1            8

# Grouping by more than one column works.
exec rowsort
SELECT v, COUNT(*), w FROM kv GROUP BY v, w
----
v:int  column5:int  w:int
NULL   1            5
2      1            2
2      2            3
4      1            2
4      1            5

# Grouping by more than one column using column numbers works.
exec rowsort
SELECT v, COUNT(*), w FROM kv GROUP BY 1, 3
----
v:int  column5:int  w:int
NULL   1            5
2      1            2
2      2            3
4      1            2
4      1            5

# Selecting and grouping on a function expression works.
exec rowsort
SELECT COUNT(*), UPPER(s) FROM kv GROUP BY UPPER(s)
----
column6:int  column5:string
1            NULL
2            B
3            A

# Selecting and grouping on a constant works.
exec
SELECT COUNT(*) FROM kv GROUP BY 1+2
----
column6:int
6

exec
SELECT COUNT(*) FROM kv GROUP BY length('abc')
----
column6:int
6

# Selecting a function of something which is grouped works.
exec rowsort
SELECT COUNT(*), UPPER(s) FROM kv GROUP BY s
----
column5:int  column6:string
1            NULL
1            A
2            A
2            B

# Selecting and grouping on a more complex expression works.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT COUNT(*), k+v FROM kv GROUP BY k+v
----
render               ·            ·             (column6, column5)  ·
 │                   render 0     agg0          ·                   ·
 │                   render 1     column5       ·                   ·
 └── group           ·            ·             (column5, agg0)     ·
      │              aggregate 0  column5       ·                   ·
      │              aggregate 1  count_rows()  ·                   ·
      │              group by     @1            ·                   ·
      └── render     ·            ·             (column5)           ·
           │         render 0     k + v         ·                   ·
           └── scan  ·            ·             (k, v)              ·
·                    table        kv@primary    ·                   ·
·                    spans        ALL           ·                   ·

exec rowsort
SELECT COUNT(*), k+v FROM kv GROUP BY k+v
----
column6:int  column5:int
1            NULL
1            3
1            7
1            8
1            9
1            12

# Selecting a more complex expression, made up of things which are each grouped, works.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT COUNT(*), k+v FROM kv GROUP BY k, v
----
render          ·            ·             (column5, column6)  ·
 │              render 0     agg0          ·                   ·
 │              render 1     k + v         ·                   ·
 └── group      ·            ·             (k, v, agg0)        ·
      │         aggregate 0  k             ·                   ·
      │         aggregate 1  v             ·                   ·
      │         aggregate 2  count_rows()  ·                   ·
      │         group by     @1-@2         ·                   ·
      └── scan  ·            ·             (k, v)              ·
·               table        kv@primary    ·                   ·
·               spans        ALL           ·                   ·

exec rowsort
SELECT COUNT(*), k+v FROM kv GROUP BY k, v
----
column5:int  column6:int
1            NULL
1            3
1            7
1            8
1            9
1            12

# Test case from #2761.
exec rowsort
SELECT count(kv.k) AS count_1, kv.v + kv.w AS lx FROM kv GROUP BY kv.v + kv.w
----
count_1:int  lx:int
1            NULL
1            4
1            6
1            9
2            5

exec rowsort
SELECT s, COUNT(*) FROM kv GROUP BY s HAVING COUNT(*) > 1
----
s:string  column5:int
a         2
b         2

#TODO(radu): DISTINCT not supported yet.
#exec rowsort
#SELECT UPPER(s), COUNT(DISTINCT s), COUNT(DISTINCT UPPER(s)) FROM kv GROUP BY UPPER(s) HAVING COUNT(DISTINCT s) > 1
#----
#column5:string  column6:int  column8:int
#A               3            3
#B               2            2

exec rowsort
SELECT MAX(k), MIN(v) FROM kv HAVING MIN(v) > 2
----
column6:int  column5:int

exec rowsort
SELECT MAX(k), MIN(v) FROM kv HAVING MAX(v) > 2
----
column6:int  column7:int
8            2

exec
SELECT COUNT(*)
----
column1:int
1

exec
SELECT COUNT(k) FROM kv
----
column5:int
6

exec
SELECT COUNT(1)
----
column2:int
1

exec
SELECT COUNT(1) FROM kv
----
column6:int
6

# TODO(radu): ORDER BY not implemented yet.
#exec
#SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v
#----
#NULL 1
#2 3
#4 2
#
#exec
#SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v DESC
#----
#4 2
#2 3
#NULL 1
#
#exec
#SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k) DESC
#----
#2 3
#4 2
#NULL 1
#
#exec
#SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY v-COUNT(k)
#----
#NULL 1
#2 3
#4 2
#
#exec
#SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY 1 DESC
#----
#4 2
#2 3
#NULL 1

# TODO(radu): column names should be "count".
exec
SELECT COUNT(*), COUNT(k), COUNT(kv.v) FROM kv
----
column5:int  column6:int  column7:int
6            6            5

# TODO(radu): this requires tuples but they are not yet supported in
# distsql (#15938).
exec nodist
SELECT COUNT(kv.*) FROM kv
----
column6:int
6

# TODO(radu): DISTINCT not supported yet.
#exec
#SELECT COUNT(DISTINCT k), COUNT(DISTINCT v), COUNT(DISTINCT (v)) FROM kv
#----
#6 2 2
#
#exec rowsort
#SELECT UPPER(s), COUNT(DISTINCT k), COUNT(DISTINCT v), COUNT(DISTINCT (v)) FROM kv GROUP BY UPPER(s)
#----
#A    3 2 2
#B    2 1 1
#NULL 1 0 0
#
#

# TODO(radu): these queries require tuples but they are not yet supported in
# distsql (#15938).
exec nodist
SELECT COUNT((k, v)) FROM kv
----
column6:int
6

# TODO(radu): DISTINCT not supported yet.
#exec nodist
#SELECT COUNT(DISTINCT (k, v)) FROM kv
#----
#column6:int
#6

#exec nodist
#SELECT COUNT(DISTINCT (k, (v))) FROM kv
#----
#column6:int
#6

exec nodist
SELECT COUNT((k, v)) FROM kv LIMIT 1
----
column6:int
6

exec nodist
SELECT COUNT((k, v)) FROM kv OFFSET 1
----
column6:int

exec
SELECT COUNT(k)+COUNT(kv.v) FROM kv
----
column7:int
11

exec nodist
SELECT COUNT(NULL::int), COUNT((NULL, NULL))
----
column2:int  column4:int
0            1

exec
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM kv
----
column5:int  column6:int  column7:int  column8:int
1            8            2            4

# Even if no input rows match, we expect a row (of nulls).
exec
SELECT MIN(k), MAX(k), MIN(v), MAX(v) FROM kv WHERE k > 8
----
column5:int  column6:int  column7:int  column8:int
NULL         NULL         NULL         NULL

# TODO(justin): we don't yet respect the inner ORDER BY
#exec
#SELECT ARRAY_AGG(k), ARRAY_AGG(s) FROM (SELECT k, s FROM kv ORDER BY k)
#----
#column5:int[]       column6:string[]
#ARRAY[1,3,5,6,7,8]  ARRAY['a','a',NULL,'b','b','A']

exec
SELECT array_agg(s) FROM kv WHERE s IS NULL
----
column5:string[]
ARRAY[NULL]

exec
SELECT JSON_AGG(s) FROM kv WHERE s IS NULL
----
column5:jsonb
'[null]'

exec
SELECT JSONB_AGG(s) FROM kv WHERE s IS NULL
----
column5:jsonb
'[null]'

exec
SELECT AVG(k), AVG(v), SUM(k), SUM(v) FROM kv
----
column5:decimal  column6:decimal  column7:decimal  column8:decimal
5                2.8              30               14

exec
SELECT AVG(k::decimal), AVG(v::decimal), SUM(k::decimal), SUM(v::decimal) FROM kv
----
column6:decimal  column8:decimal  column9:decimal  column10:decimal
5                2.8              30               14

#exec
#SELECT AVG(DISTINCT k), AVG(DISTINCT v), SUM(DISTINCT k), SUM(DISTINCT v) FROM kv
#----
#5 3 30 6

exec
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv
----
column7:decimal
14.0

# Verify things work with distsql when some of the nodes emit no results in the
# local stage.
exec
SELECT AVG(k) * 2.0 + MAX(v)::DECIMAL FROM kv WHERE w*2 = k
----
column7:decimal
14.0

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT COUNT(k) FROM kv
----
group      ·            ·           (column5)  ·
 │         aggregate 0  count(k)    ·          ·
 └── scan  ·            ·           (k)        ·
·          table        kv@primary  ·          ·
·          spans        ALL         ·          ·

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT COUNT(k), SUM(k), MAX(k) FROM kv
----
group      ·            ·           (column5, column6, column7)  ·
 │         aggregate 0  count(k)    ·                            ·
 │         aggregate 1  sum(k)      ·                            ·
 │         aggregate 2  max(k)      ·                            ·
 └── scan  ·            ·           (k)                          ·
·          table        kv@primary  ·                            ·
·          spans        ALL         ·                            ·

exec-raw
CREATE TABLE abc (
  a CHAR PRIMARY KEY,
  b FLOAT,
  c BOOLEAN,
  d DECIMAL
)
----

exec-raw
INSERT INTO abc VALUES ('one', 1.5, true, 5::decimal), ('two', 2.0, false, 1.1::decimal)
----

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(a) FROM abc
----
group      ·            ·            (column5)  ·
 │         aggregate 0  min(a)       ·          ·
 └── scan  ·            ·            (a)        ·
·          table        abc@primary  ·          ·
·          spans        ALL          ·          ·

exec
SELECT MIN(a), MIN(b), MIN(c), MIN(d) FROM abc
----
column5:string  column6:float  column7:bool  column8:decimal
one             1.5            false         1.1

exec
SELECT MAX(a), MAX(b), MAX(c), MAX(d) FROM abc
----
column5:string  column6:float  column7:bool  column8:decimal
two             2.0            true          5

exec
SELECT AVG(b), SUM(b), AVG(d), SUM(d) FROM abc
----
column5:float  column6:float  column7:decimal  column8:decimal
1.75           3.5            3.05             6.1

# Verify summing of intervals
exec-raw
CREATE TABLE intervals (
  a INTERVAL PRIMARY KEY
)
----

exec-raw
INSERT INTO intervals VALUES (INTERVAL '1 year 2 months 3 days 4 seconds'), (INTERVAL '2 year 3 months 4 days 5 seconds'), (INTERVAL '10000ms')
----

exec
SELECT SUM(a) FROM intervals
----
column2:interval
'3y5mon7d19s'

exec-raw
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z FLOAT,
  INDEX xy (x, y),
  INDEX zyx (z, y, x),
  FAMILY (x),
  FAMILY (y),
  FAMILY (z)
)
----

exec-raw
INSERT INTO xyz VALUES (1, 2, 3.0), (4, 5, 6.0), (7, NULL, 8.0)
----

exec
SELECT MIN(x) FROM xyz
----
column4:int
1

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(x) FROM xyz
----
group      ·            ·            (column4)  ·
 │         aggregate 0  min(x)       ·          ·
 └── scan  ·            ·            (x)        ·
·          table        xyz@primary  ·          ·
·          spans        ALL          ·          ·

exec
SELECT MIN(x) FROM xyz WHERE x in (0, 4, 7)
----
column4:int
4

# TODO(radu): we don't yet optimize this by scanning one entry from the xy index.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(x) FROM xyz WHERE x in (0, 4, 7)
----
group      ·            ·                        (column4)  ·
 │         aggregate 0  min(x)                   ·          ·
 └── scan  ·            ·                        (x)        ·
·          table        xyz@primary              ·          ·
·          spans        /0-/0/# /4-/4/# /7-/7/#  ·          ·

exec
SELECT MAX(x) FROM xyz
----
column4:int
7

# TODO(radu): we don't yet optimize MIN/MAX by scanning one entry from the xy index.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MAX(x) FROM xyz
----
group      ·            ·            (column4)  ·
 │         aggregate 0  max(x)       ·          ·
 └── scan  ·            ·            (x)        ·
·          table        xyz@primary  ·          ·
·          spans        ALL          ·          ·

exec
SELECT MIN(y) FROM xyz WHERE x = 1
----
column4:int
2

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(y) FROM xyz WHERE x = 1
----
group      ·            ·            (column4)  ·
 │         aggregate 0  min(y)       ·          ·
 └── scan  ·            ·            (x, y)     ·
·          table        xyz@primary  ·          ·
·          spans        /1-/1/#      ·          ·

exec
SELECT MAX(y) FROM xyz WHERE x = 1
----
column4:int
2

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MAX(y) FROM xyz WHERE x = 1
----
group      ·            ·            (column4)  ·
 │         aggregate 0  max(y)       ·          ·
 └── scan  ·            ·            (x, y)     ·
·          table        xyz@primary  ·          ·
·          spans        /1-/1/#      ·          ·

exec
SELECT MIN(y) FROM xyz WHERE x = 7
----
column4:int
NULL

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(y) FROM xyz WHERE x = 7
----
group      ·            ·            (column4)  ·
 │         aggregate 0  min(y)       ·          ·
 └── scan  ·            ·            (x, y)     ·
·          table        xyz@primary  ·          ·
·          spans        /7-/7/#      ·          ·

exec
SELECT MAX(y) FROM xyz WHERE x = 7
----
column4:int
NULL

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MAX(y) FROM xyz WHERE x = 7
----
group      ·            ·            (column4)  ·
 │         aggregate 0  max(y)       ·          ·
 └── scan  ·            ·            (x, y)     ·
·          table        xyz@primary  ·          ·
·          spans        /7-/7/#      ·          ·

exec
SELECT MIN(x) FROM xyz WHERE (y, z) = (2, 3.0)
----
column4:int
1

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(x) FROM xyz WHERE (y, z) = (2, 3.0)
----
group      ·            ·          (column4)  ·
 │         aggregate 0  min(x)     ·          ·
 └── scan  ·            ·          (x, y, z)  ·
·          table        xyz@zyx    ·          ·
·          spans        /3/2-/3/3  ·          ·

exec
SELECT MAX(x) FROM xyz WHERE (z, y) = (3.0, 2)
----
column4:int
1

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MAX(x) FROM xyz WHERE (z, y) = (3.0, 2)
----
group      ·            ·          (column4)  ·
 │         aggregate 0  max(x)     ·          ·
 └── scan  ·            ·          (x, y, z)  ·
·          table        xyz@zyx    ·          ·
·          spans        /3/2-/3/3  ·          ·

# VARIANCE/STDDEV

exec
SELECT VARIANCE(x), VARIANCE(y::decimal), round(VARIANCE(z), 14) FROM xyz
----
column4:decimal  column6:decimal  column8:float
9                4.5              6.33333333333333

exec
SELECT VARIANCE(x) FROM xyz WHERE x = 10
----
column4:decimal
NULL

exec
SELECT VARIANCE(x) FROM xyz WHERE x = 1
----
column4:decimal
NULL

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT VARIANCE(x) FROM xyz WHERE x = 1
----
group      ·            ·            (column4)  ·
 │         aggregate 0  variance(x)  ·          ·
 └── scan  ·            ·            (x)        ·
·          table        xyz@primary  ·          ·
·          spans        /1-/1/#      ·          ·

exec
SELECT STDDEV(x), STDDEV(y::decimal), round(STDDEV(z), 14) FROM xyz
----
column4:decimal  column6:decimal        column8:float
3                2.1213203435596425732  2.51661147842358

exec
SELECT STDDEV(x) FROM xyz WHERE x = 1
----
column4:decimal
NULL

exec
SELECT AVG(1::int)::float, AVG(2::float)::float, AVG(3::decimal)::float
----
column3:float  column6:float  column9:float
1.0            2.0            3.0

exec
SELECT COUNT(2::int), COUNT(3::float), COUNT(4::decimal)
----
column2:int  column4:int  column6:int
1            1            1

exec
SELECT SUM(1::int), SUM(2::float), SUM(3::decimal)
----
column2:decimal  column4:float  column6:decimal
1                2.0            3

exec
SELECT VARIANCE(1::int), VARIANCE(1::float), VARIANCE(1::decimal)
----
column2:decimal  column4:float  column6:decimal
NULL             NULL           NULL

exec
SELECT STDDEV(1::int), STDDEV(1::float), STDDEV(1::decimal)
----
column2:decimal  column4:float  column6:decimal
NULL             NULL           NULL

# TODO(radu): subqueries not supported yet.
## Ensure subqueries don't trigger aggregation.
#exec
#SELECT x > (SELECT avg(0)) FROM xyz LIMIT 1
#----
#true

exec-raw
CREATE TABLE bools (b BOOL)
----

exec
SELECT BOOL_AND(b), BOOL_OR(b) FROM bools
----
column3:bool  column4:bool
NULL          NULL

exec-raw
INSERT INTO bools VALUES (true), (true), (true)
----

exec
SELECT BOOL_AND(b), BOOL_OR(b) FROM bools
----
column3:bool  column4:bool
true          true

exec-raw
INSERT INTO bools VALUES (false), (false)
----

exec
SELECT BOOL_AND(b), BOOL_OR(b) FROM bools
----
column3:bool  column4:bool
false         true

exec-raw
DELETE FROM bools WHERE b
----

exec
SELECT BOOL_AND(b), BOOL_OR(b) FROM bools
----
column3:bool  column4:bool
false         false

# TODO(justin): we don't yet respect the inner ORDER BY
#exec
#SELECT CONCAT_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
#----
#column5:string
#aabbA
#
#exec
#SELECT JSON_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
#----
#column5:jsonb
#'["a", "a", null, "b", "b", "A"]'
#
#exec
#SELECT JSONB_AGG(s) FROM (SELECT s FROM kv ORDER BY k)
#----
#column5:jsonb
#'["a", "a", null, "b", "b", "A"]'

## Tests for the single-row optimization.
exec-raw
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)
----

exec-raw
INSERT INTO ab VALUES
  (1, 10),
  (2, 20),
  (3, 30),
  (4, 40),
  (5, 50)
----

# TODO(radu): we don't support the single-row optimization yet.
#exec nodist
#EXPLAIN (EXPRS) SELECT MIN(a) FROM abc
#----
#group           ·            ·
# │              aggregate 0  min(a)
# └── render     ·            ·
#      │         render 0     a
#      └── scan  ·            ·
#·               table        abc@primary
#·               spans        ALL
#·               limit        1
#
## Verify we only buffer one row.
#exec
#SELECT message FROM [SHOW KV TRACE FOR SELECT MIN(a) FROM ab]
# WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
#----
#fetched: /ab/primary/1 -> NULL
#fetched: /ab/primary/1/b -> 10
#output row: [1]
#
#exec nodist
#EXPLAIN (EXPRS) SELECT MAX(a) FROM abc
#----
#group              ·            ·
# │                 aggregate 0  max(a)
# └── render        ·            ·
#      │            render 0     a
#      └── revscan  ·            ·
#·                  table        abc@primary
#·                  spans        ALL
#·                  limit        1
#
## Verify we only buffer one row.
#exec
#SELECT message FROM [SHOW KV TRACE FOR SELECT MAX(a) FROM ab]
# WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
#----
#fetched: /ab/primary/5/b -> 50
#fetched: /ab/primary/5 -> NULL
#output row: [5]

# TODO(radu): ORDER BY not supported yet.
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT v, COUNT(k) FROM kv GROUP BY v ORDER BY COUNT(k)
#----
#sort                 ·            ·
# │                   order        +count
# └── group           ·            ·
#      │              aggregate 0  v
#      │              aggregate 1  count(k)
#      │              group by     @1
#      └── render     ·            ·
#           │         render 0     v
#           │         render 1     k
#           └── scan  ·            ·
#·                    table        kv@primary
#·                    spans        ALL
#
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) #SELECT v, COUNT(*) FROM kv GROUP BY v ORDER BY COUNT(*)
#----
#sort                 ·            ·
# │                   order        +count
# └── group           ·            ·
#      │              aggregate 0  v
#      │              aggregate 1  count_rows()
#      │              group by     @1
#      └── render     ·            ·
#           │         render 0     v
#           └── scan  ·            ·
#·                    table        kv@primary
#·                    spans        ALL
#
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT v, COUNT(1) FROM kv GROUP BY v ORDER BY COUNT(1)
#----
#sort                 ·            ·
# │                   order        +count
# └── group           ·            ·
#      │              aggregate 0  v
#      │              aggregate 1  count(1)
#      │              group by     @1
#      └── render     ·            ·
#           │         render 0     v
#           │         render 1     1
#           └── scan  ·            ·
#·                    table        kv@primary
#·                    spans        ALL

# TODO(radu): we don't propagate filters yet.
## Check that filters propagate through no-op aggregation.
#exec nodist
#EXPLAIN(EXPRS) SELECT * FROM (SELECT v, COUNT(1) FROM kv GROUP BY v) WHERE v > 10
#----
#group           ·            ·
# │              aggregate 0  v
# │              aggregate 1  count(1)
# │              group by     @1
# └── render     ·            ·
#      │         render 0     v
#      │         render 1     1
#      └── scan  ·            ·
#·               table        kv@primary
#·               spans        ALL
#·               filter       v > 10

# TODO(radu): FILTER not yet supported.
## Verify that FILTER works.
#
#exec-raw
#CREATE TABLE filter_test (
#  k INT,
#  v INT,
#  mark BOOL
#)
#----
#
#exec-raw
#INSERT INTO filter_test VALUES
#(1, 2, false),
#(3, 4, true),
#(5, NULL, true),
#(6, 2, true),
#(7, 2, true),
#(8, 4, true),
#(NULL, 4, true)
#----
#
## FILTER should eliminate some results.
#exec rowsort
#SELECT v, COUNT(*) FILTER (WHERE k > 5) FROM filter_test GROUP BY v
#----
#2 2
#4 1
#NULL 0
#
## Test multiple filters
#exec rowsort
#SELECT v, mark, COUNT(*) FILTER (WHERE k > 5), COUNT(*), MAX(k) FILTER (WHERE k < 8) FROM filter_test GROUP BY v, mark
#----
#2 false 0 1 1
#2 true 2 2 7
#4 true 1 3 3
#NULL true 0 1 5
#
## Check that filter expressions are only rendered once.
#exec nodist
#EXPLAIN (EXPRS) SELECT COUNT(*) FILTER (WHERE k>5), MAX(k>5) FILTER(WHERE k>5) FROM filter_test GROUP BY v
#----
#group           ·            ·
# │              aggregate 0  count_rows() FILTER (WHERE k > 5)
# │              aggregate 1  max(k > 5) FILTER (WHERE k > 5)
# │              group by     @1
# └── render     ·            ·
#      │         render 0     v
#      │         render 1     k > 5
#      └── scan  ·            ·
#·               table        filter_test@primary
#·               spans        ALL
#
#exec nodist
#EXPLAIN (TYPES) SELECT COUNT(*) FILTER (WHERE k > 5) FROM filter_test GROUP BY v
#----
#group           0  group   ·            ·                                  (count int)                                                    ·
# │              0  ·       aggregate 0  count_rows() FILTER (WHERE k > 5)  ·                                                              ·
# │              0  ·       group by     @1                                 ·                                                              ·
# └── render     1  render  ·            ·                                  (v int, "k > 5" bool)                                          ·
#      │         1  ·       render 0     (v)[int]                           ·                                                              ·
#      │         1  ·       render 1     ((k)[int] > (5)[int])[bool]        ·                                                              ·
#      └── scan  2  scan    ·            ·                                  (k int, v int, mark[omitted] bool, rowid[hidden,omitted] int)  rowid!=NULL; key(rowid)
#·               2  ·       table        filter_test@primary                ·                                                              ·
#·               2  ·       spans        ALL                                ·                                                              ·

# Tests with * inside GROUP BY.
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT 1 FROM kv GROUP BY kv.*;
----
render     ·         ·           (column5)  ·
 │         render 0  1           ·          ·
 └── scan  ·         ·           ()         ·
·          table     kv@primary  ·          ·
·          spans     ALL         ·          ·

exec
SELECT 1 FROM kv GROUP BY kv.*;
----
column5:int
1
1
1
1
1
1

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT SUM(abc.d) FROM kv JOIN abc ON kv.k >= abc.d GROUP BY kv.*;
----
render               ·            ·            (column9)           ·
 │                   render 0     agg0         ·                   ·
 └── group           ·            ·            (k, v, w, s, agg0)  ·
      │              aggregate 0  k            ·                   ·
      │              aggregate 1  v            ·                   ·
      │              aggregate 2  w            ·                   ·
      │              aggregate 3  s            ·                   ·
      │              aggregate 4  sum(d)       ·                   ·
      │              group by     @1-@4        ·                   ·
      └── join       ·            ·            (k, v, w, s, d)     ·
           │         type         inner        ·                   ·
           │         pred         k >= d       ·                   ·
           ├── scan  ·            ·            (k, v, w, s)        ·
           │         table        kv@primary   ·                   ·
           │         spans        ALL          ·                   ·
           └── scan  ·            ·            (d)                 ·
·                    table        abc@primary  ·                   ·
·                    spans        ALL          ·                   ·

exec rowsort
SELECT SUM(abc.d) FROM kv JOIN abc ON kv.k >= abc.d GROUP BY kv.*;
----
column9:decimal
1.1
6.1
6.1
6.1
6.1

# TODO(radu): single-row optimization not yet supported.
## opt_test is used for tests around the single-row optimization for MIN/MAX.
#exec-raw
#CREATE TABLE opt_test (k INT PRIMARY KEY, v INT, INDEX v(v))
#----
#
#exec-raw
#INSERT INTO opt_test VALUES (1, NULL), (2, 10), (3, NULL), (4, 5)
#----
#
## Verify that we correctly add the v IS NOT NULL constraint (which restricts the span).
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT MIN(v) FROM opt_test
#----
#group           0  group   ·            ·                       (min)            ·
# │              0  ·       aggregate 0  min(v)                  ·                ·
# └── render     1  render  ·            ·                       (v)              v!=NULL; +v
#      │         1  ·       render 0     test.public.opt_test.v  ·                ·
#      └── scan  2  scan    ·            ·                       (k[omitted], v)  k!=NULL; v!=NULL; key(k,v); +v
#·               2  ·       table        opt_test@v              ·                ·
#·               2  ·       spans        /!NULL-                 ·                ·
#·               2  ·       limit        1                       ·                ·
#
## Without the "v IS NOT NULL" constraint, this result would incorrectly be NULL.
#exec
#SELECT MIN(v) FROM opt_test
#----
#5
#
## Cross-check against a query without this optimization.
#exec
#SELECT MIN(v) FROM opt_test@primary
#----
#5
#
## Repeat test when there is an existing filter.
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT MIN(v) FROM opt_test WHERE k <> 4
#----
#group           0  group   ·            ·                       (min)   ·
# │              0  ·       aggregate 0  min(v)                  ·       ·
# └── render     1  render  ·            ·                       (v)     v!=NULL; +v
#      │         1  ·       render 0     test.public.opt_test.v  ·       ·
#      └── scan  2  scan    ·            ·                       (k, v)  k!=NULL; v!=NULL; key(k,v); +v
#·               2  ·       table        opt_test@v              ·       ·
#·               2  ·       spans        /!NULL-                 ·       ·
#·               2  ·       filter       k != 4                  ·       ·
#
#exec
#SELECT MIN(v) FROM opt_test WHERE k <> 4
#----
#10
#
## Check the optimization when the argument is non-trivial. The renderNode can't
## present an ordering on v+1 so the optimization is not applied, but the IS NOT
## NULL filter should be added.
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT MIN(v+1) FROM opt_test WHERE k <> 4
#----
#group           0  group   ·            ·                           (min)            ·
# │              0  ·       aggregate 0  min(v + 1)                  ·                ·
# └── render     1  render  ·            ·                           ("v + 1")        ·
#      │         1  ·       render 0     test.public.opt_test.v + 1  ·                ·
#      └── scan  2  scan    ·            ·                           (k[omitted], v)  k!=NULL; v!=NULL; key(k)
#·               2  ·       table        opt_test@primary            ·                ·
#·               2  ·       spans        -/3/# /5-                   ·                ·
#·               2  ·       filter       (v + 1) IS NOT NULL         ·                ·
#
## Verify that we don't use the optimization if there is a GROUP BY.
#exec hide-colnames nodist
#EXPLAIN (VERBOSE) SELECT MIN(v) FROM opt_test GROUP BY k
#----
#group      0  group  ·            ·                 (min)   ·
# │         0  ·      aggregate 0  min(v)            ·       ·
# │         0  ·      group by     @1                ·       ·
# └── scan  1  scan   ·            ·                 (k, v)  k!=NULL; key(k)
#·          1  ·      table        opt_test@primary  ·       ·
#·          1  ·      spans        ALL               ·       ·
#
#exec rowsort
#SELECT MIN(v) FROM opt_test GROUP BY k
#----
#NULL
#NULL
#5
#10
#
#exec rowsort
#SELECT MAX(v) FROM opt_test GROUP BY k
#----
#NULL
#NULL
#5
#10

exec-raw
CREATE TABLE xor_bytes (a bytes, b int, c int)
----

exec-raw
INSERT INTO xor_bytes VALUES
  (b'\x01\x01', 1, 3),
  (b'\x02\x01', 1, 1),
  (b'\x04\x01', 2, -5),
  (b'\x08\x01', 2, -1),
  (b'\x10\x01', 2, 0)
----

exec
SELECT TO_HEX(XOR_AGG(a)), XOR_AGG(c) FROM xor_bytes
----
column6:string  column7:int
1f01            6

# TODO(radu): ORDER BY not supported.
#exec
#SELECT TO_HEX(XOR_AGG(a)), b, XOR_AGG(c) FROM xor_bytes GROUP BY b ORDER BY b
#----
#0300  1   2
#1c01  2   4

exec
SELECT MAX(true), MIN(true)
----
column2:bool  column3:bool
true          true

exec-raw
DELETE FROM ab;
INSERT INTO ab(a,b) VALUES (1,2), (3,4);
CREATE TABLE xy(x STRING, y STRING);
INSERT INTO xy(x, y) VALUES ('a', 'b'), ('c', 'd')
----

# Grouping and rendering tuples.
exec rowsort nodist
SELECT (b, a) FROM ab GROUP BY (b, a)
----
column3:tuple{int, int}
(2, 1)
(4, 3)

# TODO(radu): this requires tuples but they are not yet supported in
# distsql (#15938).
exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT (b, a) FROM ab GROUP BY (b, a)
----
render     ·         ·           (column3)  ·
 │         render 0  (b, a)      ·          ·
 └── scan  ·         ·           (a, b)     ·
·          table     ab@primary  ·          ·
·          spans     ALL         ·          ·

# TODO(radu): this requires tuples but they are not yet supported in
# distsql (#15938).
exec rowsort nodist
SELECT MIN(y), (b, a) FROM ab, xy GROUP BY (x, (a, b))
----
column6:string  column7:tuple{int, int}
b               (2, 1)
b               (4, 3)
d               (2, 1)
d               (4, 3)

exec hide-colnames nodist
EXPLAIN (VERBOSE) SELECT MIN(y), (b, a) FROM ab, xy GROUP BY (x, (a, b))
----
render               ·            ·           (column6, column7)  ·
 │                   render 0     agg0        ·                   ·
 │                   render 1     (b, a)      ·                   ·
 └── group           ·            ·           (a, b, x, agg0)     ·
      │              aggregate 0  a           ·                   ·
      │              aggregate 1  b           ·                   ·
      │              aggregate 2  x           ·                   ·
      │              aggregate 3  min(y)      ·                   ·
      │              group by     @1-@3       ·                   ·
      └── join       ·            ·           (a, b, x, y)        ·
           │         type         cross       ·                   ·
           ├── scan  ·            ·           (a, b)              ·
           │         table        ab@primary  ·                   ·
           │         spans        ALL         ·                   ·
           └── scan  ·            ·           (x, y)              ·
·                    table        xy@primary  ·                   ·
·                    spans        ALL         ·                   ·
