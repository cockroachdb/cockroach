# LogicTest: local

statement ok
CREATE TABLE a (
  a INT PRIMARY KEY,
  b TEXT,
  FAMILY (a,b),
  INVERTED INDEX(b gin_trgm_ops)
)

query T
EXPLAIN SELECT * FROM a WHERE b LIKE '%foo%'
----
distribution: local
vectorized: true
·
• filter
│ filter: b LIKE '%foo%'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • scan
          missing stats
          table: a@a_b_idx
          spans: 1 span

query T
EXPLAIN SELECT * FROM a WHERE b ILIKE '%foo%'
----
distribution: local
vectorized: true
·
• filter
│ filter: b ILIKE '%foo%'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • scan
          missing stats
          table: a@a_b_idx
          spans: 1 span

query T
EXPLAIN SELECT * FROM a WHERE b LIKE '%foo%' OR b ILIKE '%bar%'
----
distribution: local
vectorized: true
·
• filter
│ filter: (b LIKE '%foo%') OR (b ILIKE '%bar%')
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 2
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 2 spans

query T
EXPLAIN SELECT * FROM a WHERE b LIKE '%foo%' OR b ILIKE '%bar%'
----
distribution: local
vectorized: true
·
• filter
│ filter: (b LIKE '%foo%') OR (b ILIKE '%bar%')
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 2
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 2 spans

query T
EXPLAIN SELECT * FROM a WHERE b LIKE '%foo%zoo%'
----
distribution: local
vectorized: true
·
• filter
│ filter: b LIKE '%foo%zoo%'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 2
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 2 spans

# Test that trigram index can't support searches with fewer than 3 characters.
query T
EXPLAIN SELECT * FROM a WHERE b LIKE '%fo'
----
distribution: local
vectorized: true
·
• filter
│ filter: b LIKE '%fo'
│
└── • scan
      missing stats
      table: a@a_pkey
      spans: FULL SCAN

# Test that trigram indexes can't support searches with no constant args.
# columns.
query T
EXPLAIN SELECT * FROM a WHERE b LIKE b
----
distribution: local
vectorized: true
·
• filter
│ filter: b LIKE b
│
└── • scan
      missing stats
      table: a@a_pkey
      spans: FULL SCAN

# Test that trigram indexes accelerate the % operator.
query T
EXPLAIN SELECT * FROM a WHERE b % 'foo'
----
distribution: local
vectorized: true
·
• filter
│ filter: b % 'foo'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • scan
          missing stats
          table: a@a_b_idx
          spans: 1 span

# Test that trigram indexes accelerate the % operator with an OR if the
# constant has more than one trigram.
query T
EXPLAIN SELECT * FROM a WHERE b % 'foob'
----
distribution: local
vectorized: true
·
• filter
│ filter: b % 'foob'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 2
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 2 spans

# Test that trigram indexes can't accelerate the % operator if there are fewer
# than 3 characters in the constant.
query T
EXPLAIN SELECT * FROM a WHERE b % 'fo'
----
distribution: local
vectorized: true
·
• filter
│ filter: b % 'fo'
│
└── • scan
      missing stats
      table: a@a_pkey
      spans: FULL SCAN

# Test that trigram indexes can accelerate the % operator in reverse order.
query T
EXPLAIN SELECT * FROM a WHERE 'blah' % b
----
distribution: local
vectorized: true
·
• filter
│ filter: 'blah' % b
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 2
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 2 spans

# Test that trigram indexes can't accelerate the % operator with no constant
# columns.
query T
EXPLAIN SELECT * FROM a WHERE b % b
----
distribution: local
vectorized: true
·
• filter
│ filter: b % b
│
└── • scan
      missing stats
      table: a@a_pkey
      spans: FULL SCAN


# Test that trigram indexes can accelerate the equality operator.
query T
EXPLAIN SELECT * FROM a WHERE b = 'foobar'
----
distribution: local
vectorized: true
·
• filter
│ filter: b = 'foobar'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • inverted filter
        │ inverted column: b_inverted_key
        │ num spans: 4
        │
        └── • scan
              missing stats
              table: a@a_b_idx
              spans: 4 spans

query T
EXPLAIN SELECT * FROM a WHERE b = 'foo'
----
distribution: local
vectorized: true
·
• filter
│ filter: b = 'foo'
│
└── • index join
    │ table: a@a_pkey
    │
    └── • scan
          missing stats
          table: a@a_b_idx
          spans: 1 span

# Ensure that it's okay to perform an inverted filter on a table with a trigram
# inverted index that only has a forward statistic collected on the inverted
# column.

statement ok
CREATE TABLE b (a) AS SELECT encode(set_byte('foobar ',1,g), 'escape') || g::text FROM generate_series(1,1000) g(g)

statement ok
ANALYZE b

statement ok
CREATE INVERTED INDEX ON b(a gin_trgm_ops)

query T
EXPLAIN SELECT * FROM b WHERE a LIKE '%foo%'
----
distribution: local
vectorized: true
·
• filter
│ estimated row count: 333
│ filter: a LIKE '%foo%'
│
└── • scan
      estimated row count: 1,000 (100% of the table; stats collected <hidden> ago)
      table: b@b_pkey
      spans: FULL SCAN

# Ensure that scans still work after we re-analyze.

statement ok
ANALYZE b

query T
EXPLAIN SELECT * FROM b WHERE a LIKE '%foo%'
----
distribution: local
vectorized: true
·
• filter
│ estimated row count: 333
│ filter: a LIKE '%foo%'
│
└── • index join
    │ estimated row count: 10
    │ table: b@b_pkey
    │
    └── • scan
          estimated row count: 10 (1.0% of the table; stats collected <hidden> ago)
          table: b@b_a_idx
          spans: 1 span

statement ok
CREATE INDEX on b(a);
ANALYZE b

query T
EXPLAIN SELECT * FROM b WHERE a LIKE '%foo%'
----
distribution: local
vectorized: true
·
• filter
│ estimated row count: 333
│ filter: a LIKE '%foo%'
│
└── • index join
    │ estimated row count: 0
    │ table: b@b_pkey
    │
    └── • scan
          estimated row count: 0 (<0.01% of the table; stats collected <hidden> ago)
          table: b@b_a_idx
          spans: 1 span

query T
EXPLAIN SELECT * FROM b WHERE a = 'foobar 367'
----
distribution: local
vectorized: true
·
• scan
  estimated row count: 1 (0.10% of the table; stats collected <hidden> ago)
  table: b@b_a_idx1
  spans: [/'foobar 367' - /'foobar 367']
