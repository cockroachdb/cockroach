# LogicTest: local

statement ok
CREATE TABLE t (
  a INT,
  b VARCHAR,
  c INT,
  d VARCHAR,
  PRIMARY KEY (a, b),
  INDEX bc (b, c),
  INDEX dc (d, c),
  INDEX a_desc (a DESC),
  FAMILY (a, b),
  FAMILY (c),
  FAMILY (d)
)

statement ok
INSERT INTO t VALUES
  (1, 'one', 11, 'foo'),
  (2, 'two', 22, 'bar'),
  (3, 'three', 33, 'blah')

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a IN (1, 3); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/3/'three' -> NULL
fetched: /t/primary/3/'three'/c -> 33
fetched: /t/primary/3/'three'/d -> 'blah'
output row: [1 'one' 11 'foo']
output row: [3 'three' 33 'blah']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE d = 'foo' OR d = 'bar'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [2 'two' 22 'bar']
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE (d, c) IN (('foo', 11), ('bar', 22)); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [2 'two' 22 'bar']
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE (d, c) = ('foo', 11); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a < 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a <= (1 + 1); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
output row: [1 'one' 11 'foo']
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT a, b FROM t WHERE b > 't'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/bc/'three'/33/3 -> NULL
fetched: /t/bc/'two'/22/2 -> NULL
output row: [3 'three']
output row: [2 'two']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE d < ('b' || 'l'); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE c = 22; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
fetched: /t/primary/3/'three' -> NULL
fetched: /t/primary/3/'three'/c -> 33
fetched: /t/primary/3/'three'/d -> 'blah'
output row: [2 'two' 22 'bar']

# Use the descending index
statement ok
SET tracing = on,kv,results; SELECT a FROM t ORDER BY a DESC; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/a_desc/3/'three' -> NULL
fetched: /t/a_desc/2/'two' -> NULL
fetched: /t/a_desc/1/'one' -> NULL
output row: [3]
output row: [2]
output row: [1]

# Use the descending index with multiple spans.
statement ok
SET tracing = on,kv,results; SELECT a FROM t WHERE a in (2, 3) ORDER BY a DESC; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/a_desc/3/'three' -> NULL
fetched: /t/a_desc/2/'two' -> NULL
output row: [3]
output row: [2]

# Index selection occurs in direct join operands too.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM t x JOIN t y USING(b) WHERE x.b = '3'
----
·                     distribution    local                ·                         ·
·                     vectorized      true                 ·                         ·
render                ·               ·                    (b, a, c, d, a, c, d)     ·
 │                    render 0        b                    ·                         ·
 │                    render 1        a                    ·                         ·
 │                    render 2        c                    ·                         ·
 │                    render 3        d                    ·                         ·
 │                    render 4        a                    ·                         ·
 │                    render 5        c                    ·                         ·
 │                    render 6        d                    ·                         ·
 └── merge-join       ·               ·                    (a, b, c, d, a, b, c, d)  ·
      │               type            inner                ·                         ·
      │               equality        (b) = (b)            ·                         ·
      │               mergeJoinOrder  +"(b=b)"             ·                         ·
      ├── index-join  ·               ·                    (a, b, c, d)              ·
      │    │          table           t@primary            ·                         ·
      │    │          key columns     a, b                 ·                         ·
      │    └── scan   ·               ·                    (a, b, c)                 ·
      │               table           t@bc                 ·                         ·
      │               spans           /"3"-/"3"/PrefixEnd  ·                         ·
      └── index-join  ·               ·                    (a, b, c, d)              ·
           │          table           t@primary            ·                         ·
           │          key columns     a, b                 ·                         ·
           └── scan   ·               ·                    (a, b, c)                 ·
·                     table           t@bc                 ·                         ·
·                     spans           /"3"-/"3"/PrefixEnd  ·                         ·

statement ok
TRUNCATE TABLE t

statement ok
INSERT INTO t VALUES
  (1, 'a', NULL, NULL),
  (1, 'b', NULL, NULL),
  (1, 'c', NULL, NULL)

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 1 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'c' -> NULL
output row: [1 'c' NULL NULL]

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a > 0 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'c' -> NULL
output row: [1 'c' NULL NULL]

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a > 1 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----

query TTT
EXPLAIN SELECT * FROM t WHERE a > 1 AND a < 2
----
·       distribution  local
·       vectorized    true
norows  ·             ·

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 1 AND 'a' < b AND 'c' > b; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'b' -> NULL
output row: [1 'b' NULL NULL]

statement ok
DROP TABLE t

statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  INDEX ab (a, b)
)

statement ok
INSERT INTO t VALUES (1, 2), (3, 4), (5, 6)

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a >= 3 AND a < 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a BETWEEN 3 AND 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a BETWEEN 3 AND 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 2 OR a < 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 3 OR a <= 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a <= 3 OR a < 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a > 3 OR a >= 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a >= 3 OR a > 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a = 3 OR a = 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 3 OR a > 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [1 2]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a + 1 = 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

query TTT
EXPLAIN SELECT * FROM t WHERE a = 1 AND false
----
·       distribution  local
·       vectorized    true
norows  ·             ·

query TTT
EXPLAIN SELECT * FROM t WHERE a = 1 AND NULL
----
·       distribution  local
·       vectorized    true
norows  ·             ·

query TTT
EXPLAIN SELECT * FROM t WHERE a = NULL AND a != NULL
----
·       distribution  local
·       vectorized    true
norows  ·             ·

# Make sure that mixed type comparison operations are not used
# for selecting indexes.

statement ok
DROP TABLE t

statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  INDEX b_desc (b DESC),
  INDEX bc (b, c)
)

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1
----
·          distribution  local      ·       ·
·          vectorized    true       ·       ·
render     ·             ·          (a)     ·
 │         render 0      a          ·       ·
 └── scan  ·             ·          (a, c)  ·
·          table         t@primary  ·       ·
·          spans         FULL SCAN  ·       ·
·          filter        c > 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c < 1 AND b < 5
----
·          distribution  local        ·          ·
·          vectorized    true         ·          ·
render     ·             ·            (a)        ·
 │         render 0      a            ·          ·
 └── scan  ·             ·            (a, b, c)  ·
·          table         t@bc         ·          ·
·          spans         /!NULL-/4/1  ·          ·
·          filter        c < 1        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1.0
----
·          distribution  local      ·       ·
·          vectorized    true       ·       ·
render     ·             ·          (a)     ·
 │         render 0      a          ·       ·
 └── scan  ·             ·          (a, c)  ·
·          table         t@primary  ·       ·
·          spans         FULL SCAN  ·       ·
·          filter        c > 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c < 1.0
----
·          distribution  local      ·       ·
·          vectorized    true       ·       ·
render     ·             ·          (a)     ·
 │         render 0      a          ·       ·
 └── scan  ·             ·          (a, c)  ·
·          table         t@primary  ·       ·
·          spans         FULL SCAN  ·       ·
·          filter        c < 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1.0 AND b < 5
----
·          distribution  local      ·          ·
·          vectorized    true       ·          ·
render     ·             ·          (a)        ·
 │         render 0      a          ·          ·
 └── scan  ·             ·          (a, b, c)  ·
·          table         t@bc       ·          ·
·          spans         /!NULL-/5  ·          ·
·          filter        c > 1      ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE b < 5.0 AND c < 1
----
·          distribution  local        ·          ·
·          vectorized    true         ·          ·
render     ·             ·            (a)        ·
 │         render 0      a            ·          ·
 └── scan  ·             ·            (a, b, c)  ·
·          table         t@bc         ·          ·
·          spans         /!NULL-/4/1  ·          ·
·          filter        c < 1        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5, 1)
----
·          distribution  local      ·          ·
·          vectorized    true       ·          ·
render     ·             ·          (a)        ·
 │         render 0      a          ·          ·
 └── scan  ·             ·          (a, b, c)  ·
·          table         t@bc       ·          ·
·          spans         /5/1-/5/2  ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5.0, 1)
----
·          distribution  local      ·          ·
·          vectorized    true       ·          ·
render     ·             ·          (a)        ·
 │         render 0      a          ·          ·
 └── scan  ·             ·          (a, b, c)  ·
·          table         t@bc       ·          ·
·          spans         /5/1-/5/2  ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5.1, 1)
----
·          distribution  local                  ·          ·
·          vectorized    true                   ·          ·
render     ·             ·                      (a)        ·
 │         render 0      a                      ·          ·
 └── scan  ·             ·                      (a, b, c)  ·
·          table         t@bc                   ·          ·
·          spans         /!NULL-                ·          ·
·          filter        (b = 5.1) AND (c = 1)  ·          ·

# Note the span is reversed because of #20203.
query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE b IN (5.0, 1)
----
·          distribution  local        ·       ·
·          vectorized    true         ·       ·
render     ·             ·            (a)     ·
 │         render 0      a            ·       ·
 └── scan  ·             ·            (a, b)  ·
·          table         t@b_desc     ·       ·
·          spans         /5-/4 /1-/0  ·       ·

statement ok
CREATE TABLE abcd (
  a INT,
  b INT,
  c INT,
  d INT,
  INDEX adb (a, d, b),
  INDEX abcd (a, b, c, d)
)

# Verify that we prefer the index where more columns are constrained, even if it
# has more keys per row.
query TTTTT
EXPLAIN (VERBOSE) SELECT b FROM abcd WHERE (a, b) = (1, 4)
----
·          distribution  local      ·       ·
·          vectorized    true       ·       ·
render     ·             ·          (b)     ·
 │         render 0      b          ·       ·
 └── scan  ·             ·          (a, b)  ·
·          table         abcd@abcd  ·       ·
·          spans         /1/4-/1/5  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT b FROM abcd WHERE (a, b) IN ((1, 4), (2, 9))
----
·          distribution  local                 ·       ·
·          vectorized    true                  ·       ·
render     ·             ·                     (b)     ·
 │         render 0      b                     ·       ·
 └── scan  ·             ·                     (a, b)  ·
·          table         abcd@abcd             ·       ·
·          spans         /1/4-/1/5 /2/9-/2/10  ·       ·

statement ok
CREATE TABLE ab (
  s STRING,
  i INT
);

query TTTTT
EXPLAIN (VERBOSE) SELECT i, s FROM ab WHERE (i, s) < (1, 'c')
----
·          distribution  local              ·       ·
·          vectorized    true               ·       ·
render     ·             ·                  (i, s)  ·
 │         render 0      i                  ·       ·
 │         render 1      s                  ·       ·
 └── scan  ·             ·                  (s, i)  ·
·          table         ab@primary         ·       ·
·          spans         FULL SCAN          ·       ·
·          filter        (i, s) < (1, 'c')  ·       ·

statement ok
CREATE INDEX baz ON ab (i, s)

query TTTTT
EXPLAIN (VERBOSE) SELECT i, s FROM ab@baz WHERE (i, s) < (1, 'c')
----
·          distribution  local              ·       ·
·          vectorized    true               ·       ·
render     ·             ·                  (i, s)  ·
 │         render 0      i                  ·       ·
 │         render 1      s                  ·       ·
 └── scan  ·             ·                  (s, i)  ·
·          table         ab@baz             ·       ·
·          spans         /!NULL-/1/"c"      ·       ·
·          filter        (i, s) < (1, 'c')  ·       ·

# Check that primary key definitions can indicate index ordering,
# and this information is subsequently used during index selection
# and span generation. #13882
query TTBITTBB
CREATE TABLE abz(a INT, b INT, c INT, PRIMARY KEY (a DESC, b ASC), UNIQUE(c DESC, b ASC)); SHOW INDEX FROM abz
----
abz  primary      false  1  a  DESC  false  false
abz  primary      false  2  b  ASC   false  false
abz  abz_c_b_key  false  1  c  DESC  false  false
abz  abz_c_b_key  false  2  b  ASC   false  false
abz  abz_c_b_key  false  3  a  ASC   false  true

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM abz ORDER BY a DESC LIMIT 1
----
·     distribution  local         ·    ·
·     vectorized    true          ·    ·
scan  ·             ·             (a)  ·
·     table         abz@primary   ·    ·
·     spans         LIMITED SCAN  ·    ·
·     limit         1             ·    ·

query TTTTT
EXPLAIN (VERBOSE) SELECT c FROM abz ORDER BY c DESC LIMIT 1
----
·     distribution  local            ·    ·
·     vectorized    true             ·    ·
scan  ·             ·                (c)  ·
·     table         abz@abz_c_b_key  ·    ·
·     spans         LIMITED SCAN     ·    ·
·     limit         1                ·    ·

# Issue #14426: verify we don't have an internal filter that contains "a IN ()"
# (which causes an error in DistSQL due to expression serialization).
statement ok
CREATE TABLE tab0(
  k INT PRIMARY KEY,
  a INT,
  b INT
)

query TTTTT
EXPLAIN (VERBOSE) SELECT k FROM tab0 WHERE (a IN (6) AND a > 6) OR b >= 4
----
·          distribution  local                                  ·          ·
·          vectorized    true                                   ·          ·
render     ·             ·                                      (k)        ·
 │         render 0      k                                      ·          ·
 └── scan  ·             ·                                      (k, a, b)  ·
·          table         tab0@primary                           ·          ·
·          spans         FULL SCAN                              ·          ·
·          filter        ((a IN (6,)) AND (a > 6)) OR (b >= 4)  ·          ·

# Check that no extraneous rows are fetched due to excessive batching (#15910)
# The test is composed of three parts: populate a table, check
# that the problematic plan is properly derived from the test query,
# then test the results.

statement ok
CREATE TABLE test2 (id BIGSERIAL PRIMARY KEY, k TEXT UNIQUE, v INT DEFAULT 42);
INSERT INTO test2(k)
     VALUES ('001'),('002'),('003'),('004'),('005'),('006'),('007'),('008'),('009'),('010'),
            ('011'),('012'),('013'),('014'),('015'),('016'),('017'),('018'),('019'),('020'),
            ('021'),('022'),('023'),('024'),('025'),('026'),('027'),('028'),('029'),('030')

# Plan check:
# The query is using an index-join and the limit is propagated to the scan.

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM test2 WHERE k <= '100' ORDER BY k DESC LIMIT 20
----
·             distribution  local                    ·           ·
·             vectorized    true                     ·           ·
index-join    ·             ·                        (id, k, v)  -k
 │            table         test2@primary            ·           ·
 │            key columns   id                       ·           ·
 └── revscan  ·             ·                        (id, k)     -k
·             table         test2@test2_k_key        ·           ·
·             spans         /!NULL-/"100"/PrefixEnd  ·           ·
·             limit         20                       ·           ·

# The result output of this test requires that vectorized execution
# is not used, so it has been moved to select_index_vectorize_off.


# Regression test for #20035.
statement ok
CREATE TABLE favorites (
  id INT NOT NULL DEFAULT unique_rowid(),
  resource_type STRING(30) NOT NULL,
  resource_key STRING(255) NOT NULL,
  device_group STRING(30) NOT NULL,
  customerid INT NOT NULL,
  jurisdiction STRING(2) NOT NULL,
  brand STRING(255) NOT NULL,
  created_ts TIMESTAMP NULL,
  guid_id STRING(100) NOT NULL,
  locale STRING(10) NOT NULL DEFAULT NULL,
  CONSTRAINT "primary" PRIMARY KEY (id ASC),
  UNIQUE INDEX favorites_idx (resource_type ASC, device_group ASC, resource_key ASC, customerid ASC),
  INDEX favorites_guid_idx (guid_id ASC),
  INDEX favorites_glob_fav_idx (resource_type ASC, device_group ASC, jurisdiction ASC, brand ASC, locale ASC, resource_key ASC),
  FAMILY "primary" (id, resource_type, resource_key, device_group, customerid, jurisdiction, brand, created_ts, guid_id, locale)
)

statement ok
INSERT INTO favorites (customerid, guid_id, resource_type, device_group, jurisdiction, brand, locale, resource_key)
  VALUES (1, '1', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'tp'),
         (2, '2', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts'),
         (3, '3', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts1'),
         (4, '4', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts2'),
         (5, '5', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts3'),
         (6, '6', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts4')

query TTT
EXPLAIN SELECT
  resource_key,
  count(resource_key) total
FROM favorites f1
WHERE f1.jurisdiction   = 'MT'
AND   f1.brand          = 'xxx'
AND   f1.resource_type  = 'GAME'
AND   f1.device_group   = 'web'
AND   f1.locale         = 'en_GB'
AND   f1.resource_key IN ('ts', 'ts2', 'ts3')
GROUP BY resource_key
ORDER BY total DESC
----
·                    distribution  local
·                    vectorized    true
sort                 ·             ·
 │                   order         -total
 └── group           ·             ·
      │              aggregate 0   resource_key
      │              aggregate 1   count_rows()
      │              group by      resource_key
      └── render     ·             ·
           └── scan  ·             ·
·                    table         favorites@favorites_glob_fav_idx
·                    spans         /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts"/PrefixEnd /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts2"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts2"/PrefixEnd /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts3"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts3"/PrefixEnd

query TI rowsort
SELECT
  resource_key,
  count(resource_key) total
FROM favorites f1
WHERE f1.jurisdiction   = 'MT'
AND   f1.brand          = 'xxx'
AND   f1.resource_type  = 'GAME'
AND   f1.device_group   = 'web'
AND   f1.locale         = 'en_GB'
AND   f1.resource_key IN ('ts', 'ts2', 'ts3')
GROUP BY resource_key
ORDER BY total DESC
----
ts  1
ts2 1
ts3 1

# Regression tests for #20362 (IS NULL handling).
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL AND b > 5
----
·     distribution  local           ·             ·
·     vectorized    true            ·             ·
scan  ·             ·               (a, b, c, d)  ·
·     table         abcd@abcd       ·             ·
·     spans         /NULL/6-/!NULL  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL AND b < 5
----
·     distribution  local                ·             ·
·     vectorized    true                 ·             ·
scan  ·             ·                    (a, b, c, d)  ·
·     table         abcd@abcd            ·             ·
·     spans         /NULL/!NULL-/NULL/5  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL ORDER BY b
----
·     distribution  local         ·             ·
·     vectorized    true          ·             ·
scan  ·             ·             (a, b, c, d)  +b
·     table         abcd@abcd     ·             ·
·     spans         /NULL-/!NULL  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a = 1 AND b IS NULL AND c > 0 AND c < 10 ORDER BY c
----
·     distribution  local                 ·             ·
·     vectorized    true                  ·             ·
scan  ·             ·                     (a, b, c, d)  +c
·     table         abcd@abcd             ·             ·
·     spans         /1/NULL/1-/1/NULL/10  ·             ·

# Regression test for #3548: verify we create constraints on implicit columns
# when they are part of the key (non-unique index).
statement ok
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY(a,b), INDEX(c))

query TTTTT
EXPLAIN (VERBOSE) SELECT c FROM abc WHERE c = 1 and a = 3
----
·          distribution  local          ·       ·
·          vectorized    true           ·       ·
render     ·             ·              (c)     ·
 │         render 0      c              ·       ·
 └── scan  ·             ·              (a, c)  ·
·          table         abc@abc_c_idx  ·       ·
·          spans         /1/3-/1/4      ·       ·

# Verify we don't create constraints on implicit columns when they may be part
# of the key (unique index on nullable column).
statement ok
CREATE TABLE def (d INT, e INT, f INT, PRIMARY KEY(d,e), UNIQUE INDEX(f))

query TTTTT
EXPLAIN (VERBOSE) SELECT f FROM def WHERE f = 1 and d = 3
----
·          distribution  local          ·       ·
·          vectorized    true           ·       ·
render     ·             ·              (f)     ·
 │         render 0      f              ·       ·
 └── scan  ·             ·              (d, f)  ·
·          table         def@def_f_key  ·       ·
·          spans         /1-/2          ·       ·
·          filter        d = 3          ·       ·

statement ok
DROP TABLE def

# Verify we don't create constraints on implicit columns when they are not part
# of the key (unique index on not-null column).
statement ok
CREATE TABLE def (d INT, e INT, f INT NOT NULL, PRIMARY KEY(d,e), UNIQUE INDEX(f))

query TTTTT
EXPLAIN (VERBOSE) SELECT f FROM def WHERE f = 1 and d = 3
----
·          distribution  local          ·       ·
·          vectorized    true           ·       ·
render     ·             ·              (f)     ·
 │         render 0      f              ·       ·
 └── scan  ·             ·              (d, f)  ·
·          table         def@def_f_key  ·       ·
·          spans         /1-/2          ·       ·
·          filter        d = 3          ·       ·

# Regression test for #20504.
query TTTTT
EXPLAIN (VERBOSE) SELECT a, b FROM abc WHERE (a, b) BETWEEN (1, 2) AND (3, 4)
----
·     distribution  local        ·       ·
·     vectorized    true         ·       ·
scan  ·             ·            (a, b)  ·
·     table         abc@primary  ·       ·
·     spans         /1/2-/3/4/#  ·       ·

# Regression test for #21831.
statement ok
CREATE TABLE str (k INT PRIMARY KEY, v STRING, INDEX(v))

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v LIKE 'ABC%'
----
·     distribution  local          ·       ·
·     vectorized    true           ·       ·
scan  ·             ·              (k, v)  ·
·     table         str@str_v_idx  ·       ·
·     spans         /"ABC"-/"ABD"  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v LIKE 'ABC%Z'
----
·     distribution  local           ·       ·
·     vectorized    true            ·       ·
scan  ·             ·               (k, v)  ·
·     table         str@str_v_idx   ·       ·
·     spans         /"ABC"-/"ABD"   ·       ·
·     filter        v LIKE 'ABC%Z'  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v SIMILAR TO 'ABC_*'
----
·     distribution  local                 ·       ·
·     vectorized    true                  ·       ·
scan  ·             ·                     (k, v)  ·
·     table         str@str_v_idx         ·       ·
·     spans         /"ABC"-/"ABD"         ·       ·
·     filter        v SIMILAR TO 'ABC_*'  ·       ·

# Test that we generate spans for IS (NOT) DISTINCT FROM.
statement ok
CREATE TABLE xy (x INT, y INT, INDEX (y))

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS NOT DISTINCT FROM NULL
----
·           distribution  local         ·                   ·
·           vectorized    true          ·                   ·
index-join  ·             ·             (x, y)              ·
 │          table         xy@primary    ·                   ·
 │          key columns   rowid         ·                   ·
 └── scan   ·             ·             (y, rowid[hidden])  ·
·           table         xy@xy_y_idx   ·                   ·
·           spans         /NULL-/!NULL  ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS NOT DISTINCT FROM 4
----
·           distribution  local        ·                   ·
·           vectorized    true         ·                   ·
index-join  ·             ·            (x, y)              ·
 │          table         xy@primary   ·                   ·
 │          key columns   rowid        ·                   ·
 └── scan   ·             ·            (y, rowid[hidden])  ·
·           table         xy@xy_y_idx  ·                   ·
·           spans         /4-/5        ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x FROM xy WHERE y > 0 AND y < 2 ORDER BY y
----
·                distribution  local        ·                   ·
·                vectorized    true         ·                   ·
render           ·             ·            (x)                 ·
 │               render 0      x            ·                   ·
 └── index-join  ·             ·            (x, y)              ·
      │          table         xy@primary   ·                   ·
      │          key columns   rowid        ·                   ·
      └── scan   ·             ·            (y, rowid[hidden])  ·
·                table         xy@xy_y_idx  ·                   ·
·                spans         /1-/2        ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS DISTINCT FROM NULL
----
·     distribution  local          ·       ·
·     vectorized    true           ·       ·
scan  ·             ·              (x, y)  ·
·     table         xy@primary     ·       ·
·     spans         FULL SCAN      ·       ·
·     filter        y IS NOT NULL  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS DISTINCT FROM 4
----
·     distribution  local                 ·       ·
·     vectorized    true                  ·       ·
scan  ·             ·                     (x, y)  ·
·     table         xy@primary            ·       ·
·     spans         FULL SCAN             ·       ·
·     filter        y IS DISTINCT FROM 4  ·       ·

# Regression tests for #22670.
statement ok
CREATE INDEX xy_idx ON xy (x, y)

statement ok
INSERT INTO xy VALUES (NULL, NULL), (1, NULL), (NULL, 1), (1, 1)

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE x IN (NULL, 1, 2)
----
·     distribution  local      ·       ·
·     vectorized    true       ·       ·
scan  ·             ·          (x, y)  ·
·     table         xy@xy_idx  ·       ·
·     spans         /1-/3      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE (x, y) IN ((NULL, NULL), (1, NULL), (NULL, 1), (1, 1), (1, 2))
----
·     distribution  local      ·       ·
·     vectorized    true       ·       ·
scan  ·             ·          (x, y)  ·
·     table         xy@xy_idx  ·       ·
·     spans         /1/1-/1/3  ·       ·

# ------------------------------------------------------------------------------
# Non-covering index
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE noncover (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT,
  INDEX b (b),
  UNIQUE INDEX c (c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c),
  FAMILY (d)
)

statement ok
INSERT INTO noncover VALUES (1, 2, 3, 4), (5, 6, 7, 8)

query TTT
EXPLAIN SELECT * FROM noncover WHERE b = 2
----
·           distribution  local
·           vectorized    true
index-join  ·             ·
 │          table         noncover@primary
 │          key columns   a
 └── scan   ·             ·
·           table         noncover@b
·           spans         /2-/3

statement ok
SET tracing = on,kv,results; SELECT * FROM noncover WHERE b = 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /noncover/b/2/1 -> NULL
fetched: /noncover/primary/1 -> NULL
fetched: /noncover/primary/1/b -> 2
fetched: /noncover/primary/1/c -> 3
fetched: /noncover/primary/1/d -> 4
output row: [1 2 3 4]

query TTT
EXPLAIN SELECT * FROM noncover WHERE c = 6
----
·           distribution  local
·           vectorized    true
index-join  ·             ·
 │          table         noncover@primary
 │          key columns   a
 └── scan   ·             ·
·           table         noncover@c
·           spans         /6-/7

statement ok
SET tracing = on,kv,results; SELECT * FROM noncover WHERE c = 7; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /noncover/c/7 -> /5
fetched: /noncover/primary/5 -> NULL
fetched: /noncover/primary/5/b -> 6
fetched: /noncover/primary/5/c -> 7
fetched: /noncover/primary/5/d -> 8
output row: [5 6 7 8]

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 ORDER BY c DESC
----
·          distribution  local             ·             ·
·          vectorized    true              ·             ·
sort       ·             ·                 (a, b, c, d)  -c
 │         order         -c                ·             ·
 └── scan  ·             ·                 (a, b, c, d)  ·
·          table         noncover@primary  ·             ·
·          spans         FULL SCAN         ·             ·
·          filter        c > 0             ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 ORDER BY c
----
·          distribution  local             ·             ·
·          vectorized    true              ·             ·
sort       ·             ·                 (a, b, c, d)  +c
 │         order         +c                ·             ·
 └── scan  ·             ·                 (a, b, c, d)  ·
·          table         noncover@primary  ·             ·
·          spans         FULL SCAN         ·             ·
·          filter        c > 0             ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 AND d = 8
----
·     distribution  local                ·             ·
·     vectorized    true                 ·             ·
scan  ·             ·                    (a, b, c, d)  ·
·     table         noncover@primary     ·             ·
·     spans         FULL SCAN            ·             ·
·     filter        (c > 0) AND (d = 8)  ·             ·

# The following testcases verify that when we have a small limit, we prefer an
# order-matching index.

query TTT
EXPLAIN SELECT * FROM noncover ORDER BY c
----
·          distribution  local
·          vectorized    true
sort       ·             ·
 │         order         +c
 └── scan  ·             ·
·          table         noncover@primary
·          spans         FULL SCAN

query TTT
EXPLAIN SELECT * FROM noncover ORDER BY c LIMIT 5
----
·           distribution  local
·           vectorized    true
index-join  ·             ·
 │          table         noncover@primary
 │          key columns   a
 └── scan   ·             ·
·           table         noncover@c
·           spans         LIMITED SCAN
·           limit         5

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c OFFSET 5
]
----
·               distribution  local
·               vectorized    true
limit           ·             ·
 │              offset        5
 └── sort       ·             ·
      │         order         +c
      └── scan  ·             ·
·               table         noncover@primary
·               spans         FULL SCAN

# TODO(radu): need to prefer the order-matching index when OFFSET is present.
query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c LIMIT 5 OFFSET 5
]
----
·                distribution  local
·                vectorized    true
limit            ·             ·
 │               offset        5
 └── index-join  ·             ·
      │          table         noncover@primary
      │          key columns   a
      └── scan   ·             ·
·                table         noncover@c
·                spans         LIMITED SCAN
·                limit         10

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c LIMIT 1000000
]
----
·               distribution  local
·               vectorized    true
limit           ·             ·
 │              count         1000000
 └── sort       ·             ·
      │         order         +c
      └── scan  ·             ·
·               table         noncover@primary
·               spans         FULL SCAN

# ------------------------------------------------------------------------------
# These tests verify that while we are joining an index with the table, we
# evaluate what parts of the filter we can using the columns in the index
# to avoid unnecessary lookups in the table.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE t2 (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  s STRING,
  INDEX bc (b, c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c),
  FAMILY (s)
)

statement ok
INSERT INTO t2 VALUES
  (1, 1, 1, '11'),
  (2, 1, 2, '12'),
  (3, 1, 3, '13'),
  (4, 2, 1, '21'),
  (5, 2, 2, '22'),
  (6, 2, 3, '23'),
  (7, 3, 1, '31'),
  (8, 3, 2, '32'),
  (9, 3, 3, '33')

# Pretend we have 10x more rows in the database than we really do.
statement ok
ALTER TABLE t2 INJECT STATISTICS '[
  {
    "columns": ["b"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 90,
    "distinct_count": 30
  }
]'

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM t2 WHERE b = 2 AND c % 2 = 0
]
----
·           distribution  local
·           vectorized    true
index-join  ·             ·
 │          table         t2@primary
 │          key columns   a
 └── scan   ·             ·
·           table         t2@bc
·           spans         /2-/3
·           filter        (c % 2) = 0

# We do NOT look up the table row for '21' and '23'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c % 2 = 0; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/2/5 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/5 -> NULL
fetched: /t2/primary/5/b -> 2
fetched: /t2/primary/5/c -> 2
fetched: /t2/primary/5/s -> '22'
output row: [5 2 2 '22']

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM t2 WHERE b = 2 AND c != b
]
----
·           distribution  local
·           vectorized    true
index-join  ·             ·
 │          table         t2@primary
 │          key columns   a
 └── scan   ·             ·
·           table         t2@bc
·           spans         /2/!NULL-/2/2 /2/3-/3

# We do NOT look up the table row for '22'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c != b; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
output row: [4 2 1 '21']
output row: [6 2 3 '23']

# We do NOT look up the table row for '22'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c != b AND s <> '21'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
output row: [6 2 3 '23']

# We only look up the table rows where c = b+1 or a > b+4: '23', '32', '33'.
# TODO(justin): we need to push the filter into the index scan.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b > 1 AND ((c = b+1 AND s != '23') OR (a > b+4 AND s != '32')); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/primary/1 -> NULL
fetched: /t2/primary/1/b -> 1
fetched: /t2/primary/1/c -> 1
fetched: /t2/primary/1/s -> '11'
fetched: /t2/primary/2 -> NULL
fetched: /t2/primary/2/b -> 1
fetched: /t2/primary/2/c -> 2
fetched: /t2/primary/2/s -> '12'
fetched: /t2/primary/3 -> NULL
fetched: /t2/primary/3/b -> 1
fetched: /t2/primary/3/c -> 3
fetched: /t2/primary/3/s -> '13'
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/5 -> NULL
fetched: /t2/primary/5/b -> 2
fetched: /t2/primary/5/c -> 2
fetched: /t2/primary/5/s -> '22'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
fetched: /t2/primary/7 -> NULL
fetched: /t2/primary/7/b -> 3
fetched: /t2/primary/7/c -> 1
fetched: /t2/primary/7/s -> '31'
fetched: /t2/primary/8 -> NULL
fetched: /t2/primary/8/b -> 3
fetched: /t2/primary/8/c -> 2
fetched: /t2/primary/8/s -> '32'
fetched: /t2/primary/9 -> NULL
fetched: /t2/primary/9/b -> 3
fetched: /t2/primary/9/c -> 3
fetched: /t2/primary/9/s -> '33'
output row: [9 3 3 '33']

# Check that splitting of the expression filter does not mistakenly
# bring non-indexed columns (s) under the index scanNode. (#12582)
# To test this we need an expression containing non-indexed
# columns that disappears during range simplification.
query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t2 WHERE b = 2 OR ((b BETWEEN 2 AND 1) AND ((s != 'a') OR (s = 'a')))
----
·                distribution  local       ·          ·
·                vectorized    true        ·          ·
render           ·             ·           (a)        ·
 │               render 0      a           ·          ·
 └── index-join  ·             ·           (a, b, s)  ·
      │          table         t2@primary  ·          ·
      │          key columns   a           ·          ·
      └── scan   ·             ·           (a, b)     ·
·                table         t2@bc       ·          ·
·                spans         /2-/3       ·          ·

statement ok
CREATE TABLE t3 (k INT PRIMARY KEY, v INT, w INT, INDEX v(v))

query TTTTT
EXPLAIN (VERBOSE) SELECT w FROM t3 WHERE v > 0 AND v < 10 ORDER BY v
----
·                distribution  local       ·       ·
·                vectorized    true        ·       ·
render           ·             ·           (w)     ·
 │               render 0      w           ·       ·
 └── index-join  ·             ·           (v, w)  +v
      │          table         t3@primary  ·       ·
      │          key columns   k           ·       ·
      └── scan   ·             ·           (k, v)  +v
·                table         t3@v        ·       ·
·                spans         /1-/10      ·       ·

# ------------------------------------------------------------------------------
# These tests are for the point lookup optimization: for single row lookups on
# a table with multiple column families, we only scan the relevant column
# families. Note that this applies to SELECTs and UPDATEs but not DELETEs, since
# we need to ensure that we delete across all column families.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE t4 (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  PRIMARY KEY (a, b),
  FAMILY (a, b),
  FAMILY (c),
  FAMILY (d),
  FAMILY (e)
)

statement ok
INSERT INTO t4 VALUES (10, 20, 30, 40, 50)

# Point lookup on c does not touch the d or e families.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10 and b = 20
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /10/20/0-/10/20/1/2

statement ok
SET tracing = on,kv,results; SELECT c FROM t4 WHERE a = 10 and b = 20; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t4/primary/10/20 -> NULL
fetched: /t4/primary/10/20/c -> 30
output row: [30]

# Point lookup on d does not touch the c or e families.
query TTT
EXPLAIN SELECT d FROM t4 WHERE a = 10 and b = 20
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /10/20/0-/10/20/1 /10/20/2/1-/10/20/2/2
·          parallel      ·

statement ok
SET tracing = on,kv,results; SELECT d FROM t4 WHERE a = 10 and b = 20; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t4/primary/10/20 -> NULL
fetched: /t4/primary/10/20/d -> 40
output row: [40]

# Point lookup on both d and e uses a single span for the two adjacent column
# families.
query TTT
EXPLAIN SELECT d, e FROM t4 WHERE a = 10 and b = 20
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /10/20/0-/10/20/1 /10/20/2/1-/10/20/3/2
·          parallel      ·

# Optimization should also be applied for updates.
query TTT
EXPLAIN UPDATE t4 SET c = 30 WHERE a = 10 and b = 20
----
·                    distribution      local
·                    vectorized        false
count                ·                 ·
 └── update          ·                 ·
      │              table             t4
      │              set               c
      │              strategy          updater
      │              auto commit       ·
      └── render     ·                 ·
           └── scan  ·                 ·
·                    table             t4@primary
·                    spans             /10/20/0-/10/20/1/2
·                    locking strength  for update

# Optimization should not be applied for deletes.
query TTT
EXPLAIN DELETE FROM t4 WHERE a = 10 and b = 20
----
·             distribution  local
·             vectorized    false
delete range  ·             ·
·             from          t4
·             auto commit   ·
·             spans         /10/20-/10/20/#

# Optimization should not be applied for non point lookups.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10 and b >= 20 and b < 22
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /10/20-/10/21/#
·          parallel      ·

# Optimization should not be applied for partial primary key filter.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /10-/11

# Regression test for #40890: a point lookup on a single column family of a
# table should still work properly in the face of a constraint disjunction.
query TTT
EXPLAIN SELECT a FROM t4 WHERE a in (1, 5) and b in (1, 5)
----
·          distribution  local
·          vectorized    true
render     ·             ·
 └── scan  ·             ·
·          table         t4@primary
·          spans         /1/1/0-/1/1/1 /1/5/0-/1/5/1 /5/1/0-/5/1/1 /5/5/0-/5/5/1
·          parallel      ·
