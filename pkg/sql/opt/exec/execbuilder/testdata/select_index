# LogicTest: local

statement ok
CREATE TABLE t (
  a INT,
  b VARCHAR,
  c INT,
  d VARCHAR,
  PRIMARY KEY (a, b),
  INDEX bc (b, c),
  INDEX dc (d, c),
  INDEX a_desc (a DESC),
  FAMILY (a, b),
  FAMILY (c),
  FAMILY (d)
)

statement ok
INSERT INTO t VALUES
  (1, 'one', 11, 'foo'),
  (2, 'two', 22, 'bar'),
  (3, 'three', 33, 'blah')

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a IN (1, 3); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/3/'three' -> NULL
fetched: /t/primary/3/'three'/c -> 33
fetched: /t/primary/3/'three'/d -> 'blah'
output row: [1 'one' 11 'foo']
output row: [3 'three' 33 'blah']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE d = 'foo' OR d = 'bar'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [2 'two' 22 'bar']
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE (d, c) IN (('foo', 11), ('bar', 22)); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [2 'two' 22 'bar']
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE (d, c) = ('foo', 11); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'foo'/11/1/'one' -> NULL
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a < 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
output row: [1 'one' 11 'foo']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a <= (1 + 1); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
output row: [1 'one' 11 'foo']
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT a, b FROM t WHERE b > 't'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/bc/'three'/33/3 -> NULL
fetched: /t/bc/'two'/22/2 -> NULL
output row: [3 'three']
output row: [2 'two']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE d < ('b' || 'l'); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/dc/'bar'/22/2/'two' -> NULL
output row: [2 'two' 22 'bar']

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE c = 22; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'one' -> NULL
fetched: /t/primary/1/'one'/c -> 11
fetched: /t/primary/1/'one'/d -> 'foo'
fetched: /t/primary/2/'two' -> NULL
fetched: /t/primary/2/'two'/c -> 22
fetched: /t/primary/2/'two'/d -> 'bar'
fetched: /t/primary/3/'three' -> NULL
fetched: /t/primary/3/'three'/c -> 33
fetched: /t/primary/3/'three'/d -> 'blah'
output row: [2 'two' 22 'bar']

# Use the descending index
statement ok
SET tracing = on,kv,results; SELECT a FROM t ORDER BY a DESC; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/a_desc/3/'three' -> NULL
fetched: /t/a_desc/2/'two' -> NULL
fetched: /t/a_desc/1/'one' -> NULL
output row: [3]
output row: [2]
output row: [1]

# Use the descending index with multiple spans.
statement ok
SET tracing = on,kv,results; SELECT a FROM t WHERE a in (2, 3) ORDER BY a DESC; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/a_desc/3/'three' -> NULL
fetched: /t/a_desc/2/'two' -> NULL
output row: [3]
output row: [2]

# Index selection occurs in direct join operands too.
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM t x JOIN t y USING(b) WHERE x.b = '3'
----
·                     distributed     false                ·                         ·
·                     vectorized      false                ·                         ·
render                ·               ·                    (b, a, c, d, a, c, d)     ·
 │                    render 0        b                    ·                         ·
 │                    render 1        a                    ·                         ·
 │                    render 2        c                    ·                         ·
 │                    render 3        d                    ·                         ·
 │                    render 4        a                    ·                         ·
 │                    render 5        c                    ·                         ·
 │                    render 6        d                    ·                         ·
 └── merge-join       ·               ·                    (a, b, c, d, a, b, c, d)  ·
      │               type            inner                ·                         ·
      │               equality        (b) = (b)            ·                         ·
      │               mergeJoinOrder  +"(b=b)"             ·                         ·
      ├── index-join  ·               ·                    (a, b, c, d)              ·
      │    │          table           t@primary            ·                         ·
      │    │          key columns     a, b                 ·                         ·
      │    └── scan   ·               ·                    (a, b, c)                 ·
      │               table           t@bc                 ·                         ·
      │               spans           /"3"-/"3"/PrefixEnd  ·                         ·
      └── index-join  ·               ·                    (a, b, c, d)              ·
           │          table           t@primary            ·                         ·
           │          key columns     a, b                 ·                         ·
           └── scan   ·               ·                    (a, b, c)                 ·
·                     table           t@bc                 ·                         ·
·                     spans           /"3"-/"3"/PrefixEnd  ·                         ·

statement ok
TRUNCATE TABLE t

statement ok
INSERT INTO t VALUES
  (1, 'a', NULL, NULL),
  (1, 'b', NULL, NULL),
  (1, 'c', NULL, NULL)

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 1 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'c' -> NULL
output row: [1 'c' NULL NULL]

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a > 0 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'c' -> NULL
output row: [1 'c' NULL NULL]

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a > 1 AND b > 'b'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----

query TTT
EXPLAIN SELECT * FROM t WHERE a > 1 AND a < 2
----
·       distributed  false
·       vectorized   false
norows  ·            ·

statement ok
SET tracing = on,kv,results; SELECT * FROM t WHERE a = 1 AND 'a' < b AND 'c' > b; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/primary/1/'b' -> NULL
output row: [1 'b' NULL NULL]

statement ok
DROP TABLE t

statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  INDEX ab (a, b)
)

statement ok
INSERT INTO t VALUES (1, 2), (3, 4), (5, 6)

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a >= 3 AND a < 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a BETWEEN 3 AND 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a BETWEEN 3 AND 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 2 OR a < 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 3 OR a <= 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a <= 3 OR a < 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/3/4 -> NULL
output row: [1 2]
output row: [3 4]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a > 3 OR a >= 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a >= 3 OR a > 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a = 3 OR a = 5; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [3 4]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a < 3 OR a > 3; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/1/2 -> NULL
fetched: /t/ab/5/6 -> NULL
output row: [1 2]
output row: [5 6]

statement ok
SET tracing = on,kv,results; SELECT * FROM t@ab WHERE a + 1 = 4; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t/ab/3/4 -> NULL
output row: [3 4]

query TTT
EXPLAIN SELECT * FROM t WHERE a = 1 AND false
----
·       distributed  false
·       vectorized   false
norows  ·            ·

query TTT
EXPLAIN SELECT * FROM t WHERE a = 1 AND NULL
----
·       distributed  false
·       vectorized   false
norows  ·            ·

query TTT
EXPLAIN SELECT * FROM t WHERE a = NULL AND a != NULL
----
·       distributed  false
·       vectorized   false
norows  ·            ·

# Make sure that mixed type comparison operations are not used
# for selecting indexes.

statement ok
DROP TABLE t

statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  INDEX b_desc (b DESC),
  INDEX bc (b, c)
)

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1
----
·          distributed  false      ·       ·
·          vectorized   true       ·       ·
render     ·            ·          (a)     ·
 │         render 0     a          ·       ·
 └── scan  ·            ·          (a, c)  ·
·          table        t@primary  ·       ·
·          spans        ALL        ·       ·
·          filter       c > 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c < 1 AND b < 5
----
·          distributed  false        ·          ·
·          vectorized   true         ·          ·
render     ·            ·            (a)        ·
 │         render 0     a            ·          ·
 └── scan  ·            ·            (a, b, c)  ·
·          table        t@bc         ·          ·
·          spans        /!NULL-/4/1  ·          ·
·          filter       c < 1        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1.0
----
·          distributed  false      ·       ·
·          vectorized   true       ·       ·
render     ·            ·          (a)     ·
 │         render 0     a          ·       ·
 └── scan  ·            ·          (a, c)  ·
·          table        t@primary  ·       ·
·          spans        ALL        ·       ·
·          filter       c > 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c < 1.0
----
·          distributed  false      ·       ·
·          vectorized   true       ·       ·
render     ·            ·          (a)     ·
 │         render 0     a          ·       ·
 └── scan  ·            ·          (a, c)  ·
·          table        t@primary  ·       ·
·          spans        ALL        ·       ·
·          filter       c < 1      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE c > 1.0 AND b < 5
----
·          distributed  false      ·          ·
·          vectorized   true       ·          ·
render     ·            ·          (a)        ·
 │         render 0     a          ·          ·
 └── scan  ·            ·          (a, b, c)  ·
·          table        t@bc       ·          ·
·          spans        /!NULL-/5  ·          ·
·          filter       c > 1      ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE b < 5.0 AND c < 1
----
·          distributed  false        ·          ·
·          vectorized   true         ·          ·
render     ·            ·            (a)        ·
 │         render 0     a            ·          ·
 └── scan  ·            ·            (a, b, c)  ·
·          table        t@bc         ·          ·
·          spans        /!NULL-/4/1  ·          ·
·          filter       c < 1        ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5, 1)
----
·          distributed  false      ·          ·
·          vectorized   true       ·          ·
render     ·            ·          (a)        ·
 │         render 0     a          ·          ·
 └── scan  ·            ·          (a, b, c)  ·
·          table        t@bc       ·          ·
·          spans        /5/1-/5/2  ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5.0, 1)
----
·          distributed  false      ·          ·
·          vectorized   true       ·          ·
render     ·            ·          (a)        ·
 │         render 0     a          ·          ·
 └── scan  ·            ·          (a, b, c)  ·
·          table        t@bc       ·          ·
·          spans        /5/1-/5/2  ·          ·

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE (b, c) = (5.1, 1)
----
·          distributed  false                  ·          ·
·          vectorized   true                   ·          ·
render     ·            ·                      (a)        ·
 │         render 0     a                      ·          ·
 └── scan  ·            ·                      (a, b, c)  ·
·          table        t@bc                   ·          ·
·          spans        /!NULL-                ·          ·
·          filter       (b = 5.1) AND (c = 1)  ·          ·

# Note the span is reversed because of #20203.
query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t WHERE b IN (5.0, 1)
----
·          distributed  false        ·       ·
·          vectorized   true         ·       ·
render     ·            ·            (a)     ·
 │         render 0     a            ·       ·
 └── scan  ·            ·            (a, b)  ·
·          table        t@b_desc     ·       ·
·          spans        /5-/4 /1-/0  ·       ·

statement ok
CREATE TABLE abcd (
  a INT,
  b INT,
  c INT,
  d INT,
  INDEX adb (a, d, b),
  INDEX abcd (a, b, c, d)
)

# Verify that we prefer the index where more columns are constrained, even if it
# has more keys per row.
query TTTTT
EXPLAIN (VERBOSE) SELECT b FROM abcd WHERE (a, b) = (1, 4)
----
·          distributed  false      ·       ·
·          vectorized   true       ·       ·
render     ·            ·          (b)     ·
 │         render 0     b          ·       ·
 └── scan  ·            ·          (a, b)  ·
·          table        abcd@abcd  ·       ·
·          spans        /1/4-/1/5  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT b FROM abcd WHERE (a, b) IN ((1, 4), (2, 9))
----
·          distributed  false                 ·       ·
·          vectorized   true                  ·       ·
render     ·            ·                     (b)     ·
 │         render 0     b                     ·       ·
 └── scan  ·            ·                     (a, b)  ·
·          table        abcd@abcd             ·       ·
·          spans        /1/4-/1/5 /2/9-/2/10  ·       ·

statement ok
CREATE TABLE ab (
  s STRING,
  i INT
);

query TTTTT
EXPLAIN (VERBOSE) SELECT i, s FROM ab WHERE (i, s) < (1, 'c')
----
·          distributed  false              ·       ·
·          vectorized   false              ·       ·
render     ·            ·                  (i, s)  ·
 │         render 0     i                  ·       ·
 │         render 1     s                  ·       ·
 └── scan  ·            ·                  (s, i)  ·
·          table        ab@primary         ·       ·
·          spans        ALL                ·       ·
·          filter       (i, s) < (1, 'c')  ·       ·

statement ok
CREATE INDEX baz ON ab (i, s)

query TTTTT
EXPLAIN (VERBOSE) SELECT i, s FROM ab@baz WHERE (i, s) < (1, 'c')
----
·          distributed  false              ·       ·
·          vectorized   false              ·       ·
render     ·            ·                  (i, s)  ·
 │         render 0     i                  ·       ·
 │         render 1     s                  ·       ·
 └── scan  ·            ·                  (s, i)  ·
·          table        ab@baz             ·       ·
·          spans        /!NULL-/1/"c"      ·       ·
·          filter       (i, s) < (1, 'c')  ·       ·

# Check that primary key definitions can indicate index ordering,
# and this information is subsequently used during index selection
# and span generation. #13882
query TTBITTBB
CREATE TABLE abz(a INT, b INT, c INT, PRIMARY KEY (a DESC, b ASC), UNIQUE(c DESC, b ASC)); SHOW INDEX FROM abz
----
abz  primary      false  1  a  DESC  false  false
abz  primary      false  2  b  ASC   false  false
abz  abz_c_b_key  false  1  c  DESC  false  false
abz  abz_c_b_key  false  2  b  ASC   false  false
abz  abz_c_b_key  false  3  a  ASC   false  true

query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM abz ORDER BY a DESC LIMIT 1
----
·     distributed  false        ·    ·
·     vectorized   true         ·    ·
scan  ·            ·            (a)  ·
·     table        abz@primary  ·    ·
·     spans        ALL          ·    ·
·     limit        1            ·    ·

query TTTTT
EXPLAIN (VERBOSE) SELECT c FROM abz ORDER BY c DESC LIMIT 1
----
·     distributed  false            ·    ·
·     vectorized   true             ·    ·
scan  ·            ·                (c)  ·
·     table        abz@abz_c_b_key  ·    ·
·     spans        ALL              ·    ·
·     limit        1                ·    ·

# Issue #14426: verify we don't have an internal filter that contains "a IN ()"
# (which causes an error in DistSQL due to expression serialization).
statement ok
CREATE TABLE tab0(
  k INT PRIMARY KEY,
  a INT,
  b INT
)

query TTTTT
EXPLAIN (VERBOSE) SELECT k FROM tab0 WHERE (a IN (6) AND a > 6) OR b >= 4
----
·          distributed  false                                  ·          ·
·          vectorized   true                                   ·          ·
render     ·            ·                                      (k)        ·
 │         render 0     k                                      ·          ·
 └── scan  ·            ·                                      (k, a, b)  ·
·          table        tab0@primary                           ·          ·
·          spans        ALL                                    ·          ·
·          filter       ((a IN (6,)) AND (a > 6)) OR (b >= 4)  ·          ·

# Check that no extraneous rows are fetched due to excessive batching (#15910)
# The test is composed of three parts: populate a table, check
# that the problematic plan is properly derived from the test query,
# then test the results.

statement ok
CREATE TABLE test2 (id BIGSERIAL PRIMARY KEY, k TEXT UNIQUE, v INT DEFAULT 42);
INSERT INTO test2(k)
     VALUES ('001'),('002'),('003'),('004'),('005'),('006'),('007'),('008'),('009'),('010'),
            ('011'),('012'),('013'),('014'),('015'),('016'),('017'),('018'),('019'),('020'),
            ('021'),('022'),('023'),('024'),('025'),('026'),('027'),('028'),('029'),('030')

# Plan check:
# The query is using an index-join and the limit is propagated to the scan.

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM test2 WHERE k <= '100' ORDER BY k DESC LIMIT 20
----
·             distributed  false                    ·           ·
·             vectorized   true                     ·           ·
index-join    ·            ·                        (id, k, v)  -k
 │            table        test2@primary            ·           ·
 │            key columns  id                       ·           ·
 └── revscan  ·            ·                        (id, k)     -k
·             table        test2@test2_k_key        ·           ·
·             spans        /!NULL-/"100"/PrefixEnd  ·           ·
·             limit        20                       ·           ·

# The result output of this test requires that vectorized execution
# is not used, so it has been moved to select_index_vectorize_off.


# Regression test for #20035.
statement ok
CREATE TABLE favorites (
  id INT NOT NULL DEFAULT unique_rowid(),
  resource_type STRING(30) NOT NULL,
  resource_key STRING(255) NOT NULL,
  device_group STRING(30) NOT NULL,
  customerid INT NOT NULL,
  jurisdiction STRING(2) NOT NULL,
  brand STRING(255) NOT NULL,
  created_ts TIMESTAMP NULL,
  guid_id STRING(100) NOT NULL,
  locale STRING(10) NOT NULL DEFAULT NULL,
  CONSTRAINT "primary" PRIMARY KEY (id ASC),
  UNIQUE INDEX favorites_idx (resource_type ASC, device_group ASC, resource_key ASC, customerid ASC),
  INDEX favorites_guid_idx (guid_id ASC),
  INDEX favorites_glob_fav_idx (resource_type ASC, device_group ASC, jurisdiction ASC, brand ASC, locale ASC, resource_key ASC),
  FAMILY "primary" (id, resource_type, resource_key, device_group, customerid, jurisdiction, brand, created_ts, guid_id, locale)
)

statement ok
INSERT INTO favorites (customerid, guid_id, resource_type, device_group, jurisdiction, brand, locale, resource_key)
  VALUES (1, '1', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'tp'),
         (2, '2', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts'),
         (3, '3', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts1'),
         (4, '4', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts2'),
         (5, '5', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts3'),
         (6, '6', 'GAME', 'web', 'MT', 'xxx', 'en_GB', 'ts4')

query TTT
EXPLAIN SELECT
  resource_key,
  count(resource_key) total
FROM favorites f1
WHERE f1.jurisdiction   = 'MT'
AND   f1.brand          = 'xxx'
AND   f1.resource_type  = 'GAME'
AND   f1.device_group   = 'web'
AND   f1.locale         = 'en_GB'
AND   f1.resource_key IN ('ts', 'ts2', 'ts3')
GROUP BY resource_key
ORDER BY total DESC
----
·                    distributed  false
·                    vectorized   false
sort                 ·            ·
 │                   order        -total
 └── group           ·            ·
      │              aggregate 0  resource_key
      │              aggregate 1  count(resource_key)
      │              group by     resource_key
      └── render     ·            ·
           └── scan  ·            ·
·                    table        favorites@favorites_glob_fav_idx
·                    spans        /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts"/PrefixEnd /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts2"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts2"/PrefixEnd /"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts3"-/"GAME"/"web"/"MT"/"xxx"/"en_GB"/"ts3"/PrefixEnd

query TI rowsort
SELECT
  resource_key,
  count(resource_key) total
FROM favorites f1
WHERE f1.jurisdiction   = 'MT'
AND   f1.brand          = 'xxx'
AND   f1.resource_type  = 'GAME'
AND   f1.device_group   = 'web'
AND   f1.locale         = 'en_GB'
AND   f1.resource_key IN ('ts', 'ts2', 'ts3')
GROUP BY resource_key
ORDER BY total DESC
----
ts  1
ts2 1
ts3 1

# Regression tests for #20362 (IS NULL handling).
query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL AND b > 5
----
·     distributed  false           ·             ·
·     vectorized   true            ·             ·
scan  ·            ·               (a, b, c, d)  ·
·     table        abcd@abcd       ·             ·
·     spans        /NULL/6-/!NULL  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL AND b < 5
----
·     distributed  false                ·             ·
·     vectorized   true                 ·             ·
scan  ·            ·                    (a, b, c, d)  ·
·     table        abcd@abcd            ·             ·
·     spans        /NULL/!NULL-/NULL/5  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a IS NULL ORDER BY b
----
·     distributed  false         ·             ·
·     vectorized   true          ·             ·
scan  ·            ·             (a, b, c, d)  +b
·     table        abcd@abcd     ·             ·
·     spans        /NULL-/!NULL  ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM abcd@abcd WHERE a = 1 AND b IS NULL AND c > 0 AND c < 10 ORDER BY c
----
·     distributed  false                 ·             ·
·     vectorized   true                  ·             ·
scan  ·            ·                     (a, b, c, d)  +c
·     table        abcd@abcd             ·             ·
·     spans        /1/NULL/1-/1/NULL/10  ·             ·

# Regression test for #3548: verify we create constraints on implicit columns
# when they are part of the key (non-unique index).
statement ok
CREATE TABLE abc (a INT, b INT, c INT, PRIMARY KEY(a,b), INDEX(c))

query TTTTT
EXPLAIN (VERBOSE) SELECT c FROM abc WHERE c = 1 and a = 3
----
·          distributed  false          ·       ·
·          vectorized   true           ·       ·
render     ·            ·              (c)     ·
 │         render 0     c              ·       ·
 └── scan  ·            ·              (a, c)  ·
·          table        abc@abc_c_idx  ·       ·
·          spans        /1/3-/1/4      ·       ·

# Verify we don't create constraints on implicit columns when they may be part
# of the key (unique index on nullable column).
statement ok
CREATE TABLE def (d INT, e INT, f INT, PRIMARY KEY(d,e), UNIQUE INDEX(f))

query TTTTT
EXPLAIN (VERBOSE) SELECT f FROM def WHERE f = 1 and d = 3
----
·          distributed  false          ·       ·
·          vectorized   true           ·       ·
render     ·            ·              (f)     ·
 │         render 0     f              ·       ·
 └── scan  ·            ·              (d, f)  ·
·          table        def@def_f_key  ·       ·
·          spans        /1-/2          ·       ·
·          filter       d = 3          ·       ·

statement ok
DROP TABLE def

# Verify we don't create constraints on implicit columns when they are not part
# of the key (unique index on not-null column).
statement ok
CREATE TABLE def (d INT, e INT, f INT NOT NULL, PRIMARY KEY(d,e), UNIQUE INDEX(f))

query TTTTT
EXPLAIN (VERBOSE) SELECT f FROM def WHERE f = 1 and d = 3
----
·          distributed  false          ·       ·
·          vectorized   true           ·       ·
render     ·            ·              (f)     ·
 │         render 0     f              ·       ·
 └── scan  ·            ·              (d, f)  ·
·          table        def@def_f_key  ·       ·
·          spans        /1-/2          ·       ·
·          filter       d = 3          ·       ·

# Regression test for #20504.
query TTTTT
EXPLAIN (VERBOSE) SELECT a, b FROM abc WHERE (a, b) BETWEEN (1, 2) AND (3, 4)
----
·     distributed  false        ·       ·
·     vectorized   true         ·       ·
scan  ·            ·            (a, b)  ·
·     table        abc@primary  ·       ·
·     spans        /1/2-/3/4/#  ·       ·

# Regression test for #21831.
statement ok
CREATE TABLE str (k INT PRIMARY KEY, v STRING, INDEX(v))

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v LIKE 'ABC%'
----
·     distributed  false          ·       ·
·     vectorized   true           ·       ·
scan  ·            ·              (k, v)  ·
·     table        str@str_v_idx  ·       ·
·     spans        /"ABC"-/"ABD"  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v LIKE 'ABC%Z'
----
·     distributed  false           ·       ·
·     vectorized   true            ·       ·
scan  ·            ·               (k, v)  ·
·     table        str@str_v_idx   ·       ·
·     spans        /"ABC"-/"ABD"   ·       ·
·     filter       v LIKE 'ABC%Z'  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT k, v FROM str WHERE v SIMILAR TO 'ABC_*'
----
·     distributed  false                 ·       ·
·     vectorized   false                 ·       ·
scan  ·            ·                     (k, v)  ·
·     table        str@str_v_idx         ·       ·
·     spans        /"ABC"-/"ABD"         ·       ·
·     filter       v SIMILAR TO 'ABC_*'  ·       ·

# Test that we generate spans for IS (NOT) DISTINCT FROM.
statement ok
CREATE TABLE xy (x INT, y INT, INDEX (y))

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS NOT DISTINCT FROM NULL
----
·           distributed  false         ·                   ·
·           vectorized   true          ·                   ·
index-join  ·            ·             (x, y)              ·
 │          table        xy@primary    ·                   ·
 │          key columns  rowid         ·                   ·
 └── scan   ·            ·             (y, rowid[hidden])  ·
·           table        xy@xy_y_idx   ·                   ·
·           spans        /NULL-/!NULL  ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS NOT DISTINCT FROM 4
----
·           distributed  false        ·                   ·
·           vectorized   true         ·                   ·
index-join  ·            ·            (x, y)              ·
 │          table        xy@primary   ·                   ·
 │          key columns  rowid        ·                   ·
 └── scan   ·            ·            (y, rowid[hidden])  ·
·           table        xy@xy_y_idx  ·                   ·
·           spans        /4-/5        ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT x FROM xy WHERE y > 0 AND y < 2 ORDER BY y
----
·                distributed  false        ·                   ·
·                vectorized   true         ·                   ·
render           ·            ·            (x)                 ·
 │               render 0     x            ·                   ·
 └── index-join  ·            ·            (x, y)              ·
      │          table        xy@primary   ·                   ·
      │          key columns  rowid        ·                   ·
      └── scan   ·            ·            (y, rowid[hidden])  ·
·                table        xy@xy_y_idx  ·                   ·
·                spans        /1-/2        ·                   ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS DISTINCT FROM NULL
----
·     distributed  false          ·       ·
·     vectorized   false          ·       ·
scan  ·            ·              (x, y)  ·
·     table        xy@primary     ·       ·
·     spans        ALL            ·       ·
·     filter       y IS NOT NULL  ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE y IS DISTINCT FROM 4
----
·     distributed  false                 ·       ·
·     vectorized   false                 ·       ·
scan  ·            ·                     (x, y)  ·
·     table        xy@primary            ·       ·
·     spans        ALL                   ·       ·
·     filter       y IS DISTINCT FROM 4  ·       ·

# Regression tests for #22670.
statement ok
CREATE INDEX xy_idx ON xy (x, y)

statement ok
INSERT INTO xy VALUES (NULL, NULL), (1, NULL), (NULL, 1), (1, 1)

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE x IN (NULL, 1, 2)
----
·     distributed  false      ·       ·
·     vectorized   true       ·       ·
scan  ·            ·          (x, y)  ·
·     table        xy@xy_idx  ·       ·
·     spans        /1-/3      ·       ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM xy WHERE (x, y) IN ((NULL, NULL), (1, NULL), (NULL, 1), (1, 1), (1, 2))
----
·     distributed  false      ·       ·
·     vectorized   true       ·       ·
scan  ·            ·          (x, y)  ·
·     table        xy@xy_idx  ·       ·
·     spans        /1/1-/1/3  ·       ·

# ------------------------------------------------------------------------------
# Non-covering index
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE noncover (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT,
  INDEX b (b),
  UNIQUE INDEX c (c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c),
  FAMILY (d)
)

statement ok
INSERT INTO noncover VALUES (1, 2, 3, 4), (5, 6, 7, 8)

query TTT
EXPLAIN SELECT * FROM noncover WHERE b = 2
----
·           distributed  false
·           vectorized   true
index-join  ·            ·
 │          table        noncover@primary
 │          key columns  a
 └── scan   ·            ·
·           table        noncover@b
·           spans        /2-/3

statement ok
SET tracing = on,kv,results; SELECT * FROM noncover WHERE b = 2; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /noncover/b/2/1 -> NULL
fetched: /noncover/primary/1 -> NULL
fetched: /noncover/primary/1/b -> 2
fetched: /noncover/primary/1/c -> 3
fetched: /noncover/primary/1/d -> 4
output row: [1 2 3 4]

query TTT
EXPLAIN SELECT * FROM noncover WHERE c = 6
----
·           distributed  false
·           vectorized   true
index-join  ·            ·
 │          table        noncover@primary
 │          key columns  a
 └── scan   ·            ·
·           table        noncover@c
·           spans        /6-/7

statement ok
SET tracing = on,kv,results; SELECT * FROM noncover WHERE c = 7; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /noncover/c/7 -> /5
fetched: /noncover/primary/5 -> NULL
fetched: /noncover/primary/5/b -> 6
fetched: /noncover/primary/5/c -> 7
fetched: /noncover/primary/5/d -> 8
output row: [5 6 7 8]

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 ORDER BY c DESC
----
·          distributed  false             ·             ·
·          vectorized   false             ·             ·
sort       ·            ·                 (a, b, c, d)  -c
 │         order        -c                ·             ·
 └── scan  ·            ·                 (a, b, c, d)  ·
·          table        noncover@primary  ·             ·
·          spans        ALL               ·             ·
·          filter       c > 0             ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 ORDER BY c
----
·          distributed  false             ·             ·
·          vectorized   false             ·             ·
sort       ·            ·                 (a, b, c, d)  +c
 │         order        +c                ·             ·
 └── scan  ·            ·                 (a, b, c, d)  ·
·          table        noncover@primary  ·             ·
·          spans        ALL               ·             ·
·          filter       c > 0             ·             ·

query TTTTT
EXPLAIN (VERBOSE) SELECT * FROM noncover WHERE c > 0 AND d = 8
----
·     distributed  false                ·             ·
·     vectorized   true                 ·             ·
scan  ·            ·                    (a, b, c, d)  ·
·     table        noncover@primary     ·             ·
·     spans        ALL                  ·             ·
·     filter       (c > 0) AND (d = 8)  ·             ·

# The following testcases verify that when we have a small limit, we prefer an
# order-matching index.

query TTT
EXPLAIN SELECT * FROM noncover ORDER BY c
----
·          distributed  false
·          vectorized   false
sort       ·            ·
 │         order        +c
 └── scan  ·            ·
·          table        noncover@primary
·          spans        ALL

query TTT
EXPLAIN SELECT * FROM noncover ORDER BY c LIMIT 5
----
·           distributed  false
·           vectorized   true
index-join  ·            ·
 │          table        noncover@primary
 │          key columns  a
 └── scan   ·            ·
·           table        noncover@c
·           spans        ALL
·           limit        5

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c OFFSET 5
]
----
·               distributed  false
·               vectorized   false
limit           ·            ·
 │              offset       5
 └── sort       ·            ·
      │         order        +c
      └── scan  ·            ·
·               table        noncover@primary
·               spans        ALL

# TODO(radu): need to prefer the order-matching index when OFFSET is present.
query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c LIMIT 5 OFFSET 5
]
----
·                distributed  false
·                vectorized   true
limit            ·            ·
 │               offset       5
 └── index-join  ·            ·
      │          table        noncover@primary
      │          key columns  a
      └── scan   ·            ·
·                table        noncover@c
·                spans        ALL
·                limit        10

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM noncover ORDER BY c LIMIT 1000000
]
----
·               distributed  false
·               vectorized   false
limit           ·            ·
 │              count        1000000
 └── sort       ·            ·
      │         order        +c
      └── scan  ·            ·
·               table        noncover@primary
·               spans        ALL

# ------------------------------------------------------------------------------
# These tests verify that while we are joining an index with the table, we
# evaluate what parts of the filter we can using the columns in the index
# to avoid unnecessary lookups in the table.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE t2 (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  s STRING,
  INDEX bc (b, c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c),
  FAMILY (s)
)

statement ok
INSERT INTO t2 VALUES
  (1, 1, 1, '11'),
  (2, 1, 2, '12'),
  (3, 1, 3, '13'),
  (4, 2, 1, '21'),
  (5, 2, 2, '22'),
  (6, 2, 3, '23'),
  (7, 3, 1, '31'),
  (8, 3, 2, '32'),
  (9, 3, 3, '33')

# Pretend we have 10x more rows in the database than we really do.
statement ok
ALTER TABLE t2 INJECT STATISTICS '[
  {
    "columns": ["b"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 90,
    "distinct_count": 30
  }
]'

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM t2 WHERE b = 2 AND c % 2 = 0
]
----
·           distributed  false
·           vectorized   false
index-join  ·            ·
 │          table        t2@primary
 │          key columns  a
 └── scan   ·            ·
·           table        t2@bc
·           spans        /2-/3
·           filter       (c % 2) = 0

# We do NOT look up the table row for '21' and '23'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c % 2 = 0; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/2/5 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/5 -> NULL
fetched: /t2/primary/5/b -> 2
fetched: /t2/primary/5/c -> 2
fetched: /t2/primary/5/s -> '22'
output row: [5 2 2 '22']

query TTT
SELECT tree, field, description FROM [
EXPLAIN (VERBOSE) SELECT * FROM t2 WHERE b = 2 AND c != b
]
----
·           distributed  false
·           vectorized   true
index-join  ·            ·
 │          table        t2@primary
 │          key columns  a
 └── scan   ·            ·
·           table        t2@bc
·           spans        /2/!NULL-/3
·           filter       c != b

# We do NOT look up the table row for '22'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c != b; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/2/5 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
output row: [4 2 1 '21']
output row: [6 2 3 '23']

# We do NOT look up the table row for '22'.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b = 2 AND c != b AND s <> '21'; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/bc/2/1/4 -> NULL
fetched: /t2/bc/2/2/5 -> NULL
fetched: /t2/bc/2/3/6 -> NULL
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
output row: [6 2 3 '23']

# We only look up the table rows where c = b+1 or a > b+4: '23', '32', '33'.
# TODO(justin): we need to push the filter into the index scan.
statement ok
SET tracing = on,kv,results; SELECT * FROM t2 WHERE b > 1 AND ((c = b+1 AND s != '23') OR (a > b+4 AND s != '32')); SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t2/primary/1 -> NULL
fetched: /t2/primary/1/b -> 1
fetched: /t2/primary/1/c -> 1
fetched: /t2/primary/1/s -> '11'
fetched: /t2/primary/2 -> NULL
fetched: /t2/primary/2/b -> 1
fetched: /t2/primary/2/c -> 2
fetched: /t2/primary/2/s -> '12'
fetched: /t2/primary/3 -> NULL
fetched: /t2/primary/3/b -> 1
fetched: /t2/primary/3/c -> 3
fetched: /t2/primary/3/s -> '13'
fetched: /t2/primary/4 -> NULL
fetched: /t2/primary/4/b -> 2
fetched: /t2/primary/4/c -> 1
fetched: /t2/primary/4/s -> '21'
fetched: /t2/primary/5 -> NULL
fetched: /t2/primary/5/b -> 2
fetched: /t2/primary/5/c -> 2
fetched: /t2/primary/5/s -> '22'
fetched: /t2/primary/6 -> NULL
fetched: /t2/primary/6/b -> 2
fetched: /t2/primary/6/c -> 3
fetched: /t2/primary/6/s -> '23'
fetched: /t2/primary/7 -> NULL
fetched: /t2/primary/7/b -> 3
fetched: /t2/primary/7/c -> 1
fetched: /t2/primary/7/s -> '31'
fetched: /t2/primary/8 -> NULL
fetched: /t2/primary/8/b -> 3
fetched: /t2/primary/8/c -> 2
fetched: /t2/primary/8/s -> '32'
fetched: /t2/primary/9 -> NULL
fetched: /t2/primary/9/b -> 3
fetched: /t2/primary/9/c -> 3
fetched: /t2/primary/9/s -> '33'
output row: [9 3 3 '33']

# Check that splitting of the expression filter does not mistakenly
# bring non-indexed columns (s) under the index scanNode. (#12582)
# To test this we need an expression containing non-indexed
# columns that disappears during range simplification.
query TTTTT
EXPLAIN (VERBOSE) SELECT a FROM t2 WHERE b = 2 OR ((b BETWEEN 2 AND 1) AND ((s != 'a') OR (s = 'a')))
----
·                distributed  false       ·          ·
·                vectorized   true        ·          ·
render           ·            ·           (a)        ·
 │               render 0     a           ·          ·
 └── index-join  ·            ·           (a, b, s)  ·
      │          table        t2@primary  ·          ·
      │          key columns  a           ·          ·
      └── scan   ·            ·           (a, b)     ·
·                table        t2@bc       ·          ·
·                spans        /2-/3       ·          ·

statement ok
CREATE TABLE t3 (k INT PRIMARY KEY, v INT, w INT, INDEX v(v))

query TTTTT
EXPLAIN (VERBOSE) SELECT w FROM t3 WHERE v > 0 AND v < 10 ORDER BY v
----
·                distributed  false       ·       ·
·                vectorized   true        ·       ·
render           ·            ·           (w)     ·
 │               render 0     w           ·       ·
 └── index-join  ·            ·           (v, w)  +v
      │          table        t3@primary  ·       ·
      │          key columns  k           ·       ·
      └── scan   ·            ·           (k, v)  +v
·                table        t3@v        ·       ·
·                spans        /1-/10      ·       ·

# ------------------------------------------------------------------------------
# These tests are for the point lookup optimization: for single row lookups on
# a table with multiple column families, we only scan the relevant column
# families. Note that this applies to SELECTs and UPDATEs but not DELETEs, since
# we need to ensure that we delete across all column families.
# ------------------------------------------------------------------------------
statement ok
CREATE TABLE t4 (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  PRIMARY KEY (a, b),
  FAMILY (a, b),
  FAMILY (c),
  FAMILY (d),
  FAMILY (e)
)

statement ok
INSERT INTO t4 VALUES (10, 20, 30, 40, 50)

# Point lookup on c does not touch the d or e families.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10 and b = 20
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /10/20/0-/10/20/1/2

statement ok
SET tracing = on,kv,results; SELECT c FROM t4 WHERE a = 10 and b = 20; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t4/primary/10/20 -> NULL
fetched: /t4/primary/10/20/c -> 30
output row: [30]

# Point lookup on d does not touch the c or e families.
query TTT
EXPLAIN SELECT d FROM t4 WHERE a = 10 and b = 20
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /10/20/0-/10/20/1 /10/20/2/1-/10/20/2/2
·          parallel     ·

statement ok
SET tracing = on,kv,results; SELECT d FROM t4 WHERE a = 10 and b = 20; SET tracing = off

query T
SELECT message FROM [SHOW KV TRACE FOR SESSION] WITH ORDINALITY
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
 ORDER BY message LIKE 'fetched:%' DESC, ordinality ASC
----
fetched: /t4/primary/10/20 -> NULL
fetched: /t4/primary/10/20/d -> 40
output row: [40]

# Point lookup on both d and e uses a single span for the two adjacent column
# families.
query TTT
EXPLAIN SELECT d, e FROM t4 WHERE a = 10 and b = 20
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /10/20/0-/10/20/1 /10/20/2/1-/10/20/3/2
·          parallel     ·

# Optimization should also be applied for updates.
query TTT
EXPLAIN UPDATE t4 SET c = 30 WHERE a = 10 and b = 20
----
·                    distributed  false
·                    vectorized   false
count                ·            ·
 └── update          ·            ·
      │              table        t4
      │              set          c
      │              strategy     updater
      └── render     ·            ·
           └── scan  ·            ·
·                    table        t4@primary
·                    spans        /10/20/0-/10/20/1/2

# Optimization should not be applied for deletes.
query TTT
EXPLAIN DELETE FROM t4 WHERE a = 10 and b = 20
----
·             distributed  false
·             vectorized   false
delete range  ·            ·
·             from         t4
·             spans        /10/20-/10/20/#

# Optimization should not be applied for non point lookups.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10 and b >= 20 and b < 22
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /10/20-/10/21/#
·          parallel     ·

# Optimization should not be applied for partial primary key filter.
query TTT
EXPLAIN SELECT c FROM t4 WHERE a = 10
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /10-/11

# Regression test for #40890: a point lookup on a single column family of a
# table should still work properly in the face of a constraint disjunction.
query TTT
EXPLAIN SELECT a FROM t4 WHERE a in (1, 5) and b in (1, 5)
----
·          distributed  false
·          vectorized   true
render     ·            ·
 └── scan  ·            ·
·          table        t4@primary
·          spans        /1/1/0-/1/1/1 /1/5/0-/1/5/1 /5/1/0-/5/1/1 /5/5/0-/5/5/1
·          parallel     ·
