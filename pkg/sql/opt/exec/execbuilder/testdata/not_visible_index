# LogicTest: local

# This file will exercise these dimensions of not visible index feature:
# - Check show create table
# - Check system descriptors
# - Check show indexes
# - Check some basic test cases using EXPLAIN 

# - When dropping an index is not equivalent to marking an index as invisible,
#   we should log a notice message.
#   - Whenever a unique invisible index is created in CREATE INDEX or CREATE TABLE
#   - Whenever an invisible index is created on a child table in CREATE INDEX or CREATE TABLE
#   - Whenever a new foreign key constraint is added to a table with invisible index
#   - Whenever they are using force index with invisible index

statement ok
CREATE TABLE t1 (k INT PRIMARY KEY, v INT, i INT, INDEX idx_v_visible(v) VISIBLE, INDEX idx_i_invisible(i) NOT VISIBLE)

statement ok
CREATE INDEX idx_v_invisible ON t1(v) NOT VISIBLE

# Test SHOW CREATE TABLE
query T
SELECT create_statement FROM [SHOW CREATE TABLE t1]
----
CREATE TABLE public.t1 (
   k INT8 NOT NULL,
   v INT8 NULL,
   i INT8 NULL,
   CONSTRAINT t1_pkey PRIMARY KEY (k ASC),
   INDEX idx_v_visible (v ASC),
   INDEX idx_i_invisible (i ASC) NOT VISIBLE,
   INDEX idx_v_invisible (v ASC) NOT VISIBLE,
   FAMILY fam_0_v (v),
   FAMILY fam_1_i_k (i, k)
)

# Test SHOW INDEX, SHOW INDEXES, SHOW KEYS FROM TABLE 
query TTB
SELECT index_name, column_name, visible FROM [SHOW INDEX FROM t1] ORDER BY index_name, seq_in_index
----
idx_i_invisible  i  false
idx_i_invisible  k  false
idx_v_invisible  v  false
idx_v_invisible  k  false
idx_v_visible    v  true
idx_v_visible    k  true
t1_pkey          k  true
t1_pkey          v  true
t1_pkey          i  true

query TTB
SELECT index_name, column_name, visible  FROM [SHOW INDEXES FROM t1] ORDER BY index_name, seq_in_index
----
idx_i_invisible  i  false
idx_i_invisible  k  false
idx_v_invisible  v  false
idx_v_invisible  k  false
idx_v_visible    v  true
idx_v_visible    k  true
t1_pkey          k  true
t1_pkey          v  true
t1_pkey          i  true

query TTB
SELECT index_name, column_name, visible  FROM [SHOW KEYS FROM t1] ORDER BY index_name, seq_in_index
----
idx_i_invisible  i  false
idx_i_invisible  k  false
idx_v_invisible  v  false
idx_v_invisible  k  false
idx_v_visible    v  true
idx_v_visible    k  true
t1_pkey          k  true
t1_pkey          v  true
t1_pkey          i  true

# Check System Descriptor
query TTBITTBBB colnames
SELECT * FROM [SHOW INDEX FROM system.descriptor]
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit  visible
descriptor  primary     false       1             id           ASC        false    false     true
descriptor  primary     false       2             descriptor   N/A        true     false     true

query TT
SELECT cols.desc->>'name', cols.desc->>'notVisible' FROM (
  SELECT json_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'indexes'
  ) AS desc FROM system.descriptor WHERE id = 't1'::REGCLASS
) AS cols
----
idx_v_visible    NULL
idx_i_invisible  true
idx_v_invisible  true

# Check crdb_internal.table_indexes
query TB colnames
SELECT index_name, is_visible FROM crdb_internal.table_indexes ORDER BY index_id
----
index_name       is_visible
t1_pkey          true
idx_v_visible    true
idx_i_invisible  false
idx_v_invisible  false

# Check information_schema.statistics 
query TTT colnames
SELECT index_name, column_name, is_visible  FROM information_schema.statistics ORDER BY index_name, seq_in_index
----
index_name       column_name  is_visible
idx_i_invisible  i            NO
idx_i_invisible  k            NO
idx_v_invisible  v            NO
idx_v_invisible  k            NO
idx_v_visible    v            YES
idx_v_visible    k            YES
t1_pkey          k            YES
t1_pkey          v            YES
t1_pkey          i            YES

statement ok
DROP INDEX idx_v_visible;

statement ok
DROP INDEX idx_i_invisible;

statement ok
DROP INDEX idx_v_invisible;

statement ok
DROP TABLE t1;

# Test SHOW INDEX, SHOW INDEXES, SHOW KEYS FROM DATABASE
statement ok
CREATE DATABASE db;

statement ok
CREATE TABLE db.t1 (k INT PRIMARY KEY, v INT, i INT, INDEX idx_v_visible(v) VISIBLE, INDEX idx_i_invisible(i) NOT VISIBLE)

statement ok
CREATE TABLE db.t2 (k INT PRIMARY KEY, v INT, i INT, INDEX idx_v_visible(v) VISIBLE, INDEX idx_i_invisible(i) NOT VISIBLE)

statement ok
CREATE INDEX idx_v_invisible ON db.t1(v) NOT VISIBLE

statement ok
CREATE UNIQUE INDEX unique_idx_v_invisible ON db.t2(v) NOT VISIBLE

query TTTB
SELECT table_name, index_name, column_name, visible FROM [SHOW INDEX FROM DATABASE db] ORDER BY table_name, index_name, seq_in_index
----
t1  idx_i_invisible         i  false
t1  idx_i_invisible         k  false
t1  idx_v_invisible         v  false
t1  idx_v_invisible         k  false
t1  idx_v_visible           v  true
t1  idx_v_visible           k  true
t1  t1_pkey                 k  true
t1  t1_pkey                 v  true
t1  t1_pkey                 i  true
t2  idx_i_invisible         i  false
t2  idx_i_invisible         k  false
t2  idx_v_visible           v  true
t2  idx_v_visible           k  true
t2  t2_pkey                 k  true
t2  t2_pkey                 v  true
t2  t2_pkey                 i  true
t2  unique_idx_v_invisible  v  false
t2  unique_idx_v_invisible  k  false

query TTTB
SELECT table_name, index_name, column_name, visible  FROM [SHOW INDEXES FROM DATABASE db] ORDER BY table_name, index_name, seq_in_index
----
t1  idx_i_invisible         i  false
t1  idx_i_invisible         k  false
t1  idx_v_invisible         v  false
t1  idx_v_invisible         k  false
t1  idx_v_visible           v  true
t1  idx_v_visible           k  true
t1  t1_pkey                 k  true
t1  t1_pkey                 v  true
t1  t1_pkey                 i  true
t2  idx_i_invisible         i  false
t2  idx_i_invisible         k  false
t2  idx_v_visible           v  true
t2  idx_v_visible           k  true
t2  t2_pkey                 k  true
t2  t2_pkey                 v  true
t2  t2_pkey                 i  true
t2  unique_idx_v_invisible  v  false
t2  unique_idx_v_invisible  k  false

query TTTB
SELECT table_name, index_name, column_name, visible  FROM [SHOW KEYS FROM DATABASE db] ORDER BY table_name, index_name, seq_in_index
----
t1  idx_i_invisible         i  false
t1  idx_i_invisible         k  false
t1  idx_v_invisible         v  false
t1  idx_v_invisible         k  false
t1  idx_v_visible           v  true
t1  idx_v_visible           k  true
t1  t1_pkey                 k  true
t1  t1_pkey                 v  true
t1  t1_pkey                 i  true
t2  idx_i_invisible         i  false
t2  idx_i_invisible         k  false
t2  idx_v_visible           v  true
t2  idx_v_visible           k  true
t2  t2_pkey                 k  true
t2  t2_pkey                 v  true
t2  t2_pkey                 i  true
t2  unique_idx_v_invisible  v  false
t2  unique_idx_v_invisible  k  false

statement ok
DROP DATABASE db;

# The following tests check for not visible index feature using EXPLAIN. 

####################################################################
# Invisible index is ignored during normal SELECT, UPDATE, DELETE. #
####################################################################
statement ok
CREATE TABLE t1 (k INT PRIMARY KEY, v INT, INDEX idx_v_visible(v) VISIBLE)

# idx_v_visible is selected if it is visible.
query T
EXPLAIN SELECT * FROM t1 WHERE v = 2
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t1@idx_v_visible
  spans: [/2 - /2]

statement ok
DROP INDEX t1@idx_v_visible

statement ok
CREATE INDEX idx_v_invisible ON t1(v) NOT VISIBLE

# After making idx_v_invisible invisible, SELECT ignores idx_v_invisible.
query T
EXPLAIN SELECT v FROM t1 WHERE v = 2
----
distribution: local
vectorized: true
·
• filter
│ filter: v = 2
│
└── • scan
      missing stats
      table: t1@t1_pkey
      spans: FULL SCAN

# More SELECT ignores idx_v_invisible.
query T
EXPLAIN SELECT DISTINCT ON (v) t1 FROM t1
----
distribution: local
vectorized: true
·
• distinct
│ distinct on: v
│
└── • render
    │
    └── • scan
          missing stats
          table: t1@t1_pkey
          spans: FULL SCAN

# idx_v_invisible is ignored for normal UPDATE.
query T
EXPLAIN UPDATE t1 SET k = 1 WHERE v > 0
----
distribution: local
vectorized: true
·
• update
│ table: t1
│ set: k
│ auto commit
│
└── • render
    │
    └── • filter
        │ filter: v > 0
        │
        └── • scan
              missing stats
              table: t1@t1_pkey
              spans: FULL SCAN

# idx_v_invisible is ignored for normal DELETE.
query T
EXPLAIN DELETE FROM t1 WHERE v > 0
----
distribution: local
vectorized: true
·
• delete
│ from: t1
│ auto commit
│
└── • filter
    │ filter: v > 0
    │
    └── • scan
          missing stats
          table: t1@t1_pkey
          spans: FULL SCAN

##################################################################################
# Check Force Index, Force Partial Index, Inverted Index, Partial Inverted Index #
##################################################################################
# Force index is still in effect, and idx_v_invisible is used.
query T
EXPLAIN SELECT v FROM t1@idx_v_invisible WHERE v = 2
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t1@idx_v_invisible
  spans: [/2 - /2]

statement ok
DROP INDEX t1@idx_v_invisible

statement ok
CREATE INDEX idx_v_invisible ON t1(v) WHERE v > 0

# Partial force index is still in effect, and idx_v_invisible is used when query filter implies predicate.
query T
EXPLAIN SELECT * FROM t1 WHERE v > 10;
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t1@idx_v_invisible (partial index)
  spans: [/11 - ]

# Partial force index is still in effect, and idx_v_invisible is used when query filter implies predicate.
query T
EXPLAIN SELECT * FROM t1@{FORCE_INDEX=idx_v_invisible} WHERE v > 10;
----
distribution: local
vectorized: true
·
• scan
  missing stats
  table: t1@idx_v_invisible (partial index)
  spans: [/11 - ]

# Partial force index is still in effect, and idx_v_invisible is not used if query filter does not imply predicate.
statement error pgcode 42809 index "idx_v_invisible" is a partial index that does not contain all the rows needed to execute this query
EXPLAIN SELECT * FROM t1@{FORCE_INDEX=idx_v_invisible} WHERE v < 0;

statement ok
DROP TABLE t1

########################################################################################
# Invisible index is still used to check for uniqueness. INSERT...ON CONFLICT, UPSERT. #
########################################################################################
statement ok
CREATE TABLE t1 (k INT PRIMARY KEY, v INT)

statement ok
CREATE UNIQUE INDEX idx_v_unique_invisible ON t1(v) NOT VISIBLE

# idx_v_unique_invisible is ignored under normal condition.
query T
EXPLAIN SELECT * FROM t1 WHERE v > 0
----
distribution: local
vectorized: true
·
• filter
│ filter: v > 0
│
└── • scan
      missing stats
      table: t1@t1_pkey
      spans: FULL SCAN

# idx_v_unique_invisible is used to check uniqueness. 
query T
EXPLAIN INSERT INTO t1 VALUES (1, 2) ON CONFLICT DO NOTHING
----
distribution: local
vectorized: true
·
• insert
│ into: t1(k, v)
│ auto commit
│ arbiter indexes: t1_pkey, idx_v_unique_invisible
│
└── • lookup join (anti)
    │ table: t1@idx_v_unique_invisible
    │ equality: (column2) = (v)
    │ equality cols are key
    │
    └── • cross join (anti)
        │
        ├── • values
        │     size: 2 columns, 1 row
        │
        └── • scan
              missing stats
              table: t1@t1_pkey
              spans: [/1 - /1]

# idx_v_unique_invisible is used to check uniqueness. 
query T
EXPLAIN INSERT INTO t1 VALUES (1, 2) ON CONFLICT(v) DO UPDATE SET k = t1.v
----
distribution: local
vectorized: true
·
• upsert
│ into: t1(k, v)
│ auto commit
│ arbiter indexes: idx_v_unique_invisible
│
└── • render
    │
    └── • cross join (left outer)
        │
        ├── • values
        │     size: 2 columns, 1 row
        │
        └── • scan
              missing stats
              table: t1@idx_v_unique_invisible
              spans: [/2 - /2]
              locking strength: for update

# UPSERT uses primary index to check uniqueness, so idx_v_unique_invisible is not useful.
query T
EXPLAIN UPSERT INTO t1(k, v) VALUES (1, 2)
----
distribution: local
vectorized: true
·
• upsert
│ into: t1(k, v)
│ auto commit
│ arbiter indexes: t1_pkey
│
└── • cross join (left outer)
    │
    ├── • values
    │     size: 2 columns, 1 row
    │
    └── • scan
          missing stats
          table: t1@t1_pkey
          spans: [/1 - /1]
          locking strength: for update

statement ok
DROP TABLE t1

###########################################################################################
# Invisible index is still used to check for FK constraint. 
# - When parent deletes or update 
# - When child inserts, upserts, or update
###########################################################################################
statement ok
CREATE TABLE parent (p INT PRIMARY KEY)

statement ok
CREATE TABLE child (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p), INDEX c_idx_invisible (p) NOT VISIBLE)

# Part 1: When parent deletes or update, invisible indexes on the child table will be used.
# c_idx_invisible is invisible when no FK is involved (delete on a child table requires no FK check). 
query T
EXPLAIN DELETE FROM child WHERE p = 4
----
distribution: local
vectorized: true
·
• delete
│ from: child
│ auto commit
│
└── • filter
    │ filter: p = 4
    │
    └── • scan
          missing stats
          table: child@child_pkey
          spans: FULL SCAN

# c_idx_invisible is used to perform constraint-check (delete on a parent table requires FK check).
query T
EXPLAIN DELETE FROM parent where p = 2
----
distribution: local
vectorized: true
·
• root
│
├── • delete
│   │ from: parent
│   │
│   └── • buffer
│       │ label: buffer 1
│       │
│       └── • scan
│             missing stats
│             table: parent@parent_pkey
│             spans: [/2 - /2]
│
└── • constraint-check
    │
    └── • error if rows
        │
        └── • lookup join (semi)
            │ table: child@c_idx_invisible
            │ equality: (p) = (p)
            │
            └── • scan buffer
                  label: buffer 1

# c_idx_invisible is used to perform constraint-check (update on a parent table requires FK check).
query T
EXPLAIN UPDATE parent SET p = p+1
----
distribution: local
vectorized: true
·
• root
│
├── • update
│   │ table: parent
│   │ set: p
│   │
│   └── • buffer
│       │ label: buffer 1
│       │
│       └── • render
│           │
│           └── • scan
│                 missing stats
│                 table: parent@parent_pkey
│                 spans: FULL SCAN
│                 locking strength: for update
│
└── • constraint-check
    │
    └── • error if rows
        │
        └── • hash join
            │ equality: (p) = (p)
            │ left cols are key
            │ right cols are key
            │
            ├── • except all
            │   │
            │   ├── • scan buffer
            │   │     label: buffer 1
            │   │
            │   └── • scan buffer
            │         label: buffer 1
            │
            └── • distinct
                │ distinct on: p
                │ order key: p
                │
                └── • scan
                      missing stats
                      table: child@c_idx_invisible
                      spans: FULL SCAN

statement ok
DROP TABLE child

statement ok
DROP TABLE parent

# Part 2: When child insert, upsert, update, invisible indexes on the parent table will be used.
statement ok
CREATE TABLE parent (p INT PRIMARY KEY, other INT)

statement ok
CREATE UNIQUE INDEX u_idx_invisible ON parent(other) NOT VISIBLE

statement ok
CREATE TABLE child (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(other))

# u_idx_invisible is invisible when no FK check is involved (select on a table requires no FK check).
query T
EXPLAIN SELECT * FROM parent WHERE other > 0
----
distribution: local
vectorized: true
·
• filter
│ filter: other > 0
│
└── • scan
      missing stats
      table: parent@parent_pkey
      spans: FULL SCAN

# u_idx_invisible is used for FK check (insert on a child table requires FK check).
query T
EXPLAIN INSERT INTO child VALUES (200, 1)
----
distribution: local
vectorized: true
·
• insert fast path
  into: child(c, p)
  auto commit
  FK check: parent@u_idx_invisible
  size: 2 columns, 1 row

# u_idx_invisible is used for FK check (upsert on a child table requires FK check).
query T
EXPLAIN UPSERT INTO child VALUES (200, 1)
----
distribution: local
vectorized: true
·
• root
│
├── • upsert
│   │ into: child(c, p)
│   │
│   └── • buffer
│       │ label: buffer 1
│       │
│       └── • values
│             size: 2 columns, 1 row
│
└── • constraint-check
    │
    └── • error if rows
        │
        └── • lookup join (anti)
            │ table: parent@u_idx_invisible
            │ equality: (column2) = (other)
            │ equality cols are key
            │
            └── • scan buffer
                  label: buffer 1

statement ok
DROP TABLE child

statement ok
DROP TABLE parent

###################################################################################################
# Invisible index is still used to check for FK constraint with ON CASCADE, SET DEFAULT, SET NULL.
# - When parent deletes or update 
# - Since EXPLAIN does not show here. We will check the scan flag output under `opt` testdata to confirm.
###################################################################################################
statement ok
CREATE TABLE parent (p INT PRIMARY KEY)

statement ok
CREATE TABLE child_delete (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p) ON DELETE CASCADE, INDEX c_delete_idx_invisible (p) NOT VISIBLE)

statement ok
CREATE TABLE child_update (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p) ON UPDATE CASCADE, INDEX c_update_idx_invisible (p) NOT VISIBLE)

query TTB
SELECT index_name, column_name, visible FROM [SHOW INDEX FROM parent] ORDER BY index_name, seq_in_index
----
parent_pkey  p  true

query TTB
SELECT index_name, column_name, visible FROM [SHOW INDEX FROM child_delete] ORDER BY index_name, seq_in_index
----
c_delete_idx_invisible  p  false
c_delete_idx_invisible  c  false
child_delete_pkey       c  true
child_delete_pkey       p  true

query TTB
SELECT index_name, column_name, visible FROM [SHOW INDEX FROM child_update] ORDER BY index_name, seq_in_index
----
c_update_idx_invisible  p  false
c_update_idx_invisible  c  false
child_update_pkey       c  true
child_update_pkey       p  true

# c_update_idx_invisible is used for constraint check (delete on a parent table requires FK check).
query T
EXPLAIN DELETE FROM parent where p = 2
----
distribution: local
vectorized: true
·
• root
│
├── • delete
│   │ from: parent
│   │
│   └── • buffer
│       │ label: buffer 1
│       │
│       └── • scan
│             missing stats
│             table: parent@parent_pkey
│             spans: [/2 - /2]
│
├── • fk-cascade
│     fk: child_delete_p_fkey
│     input: buffer 1
│
└── • constraint-check
    │
    └── • error if rows
        │
        └── • lookup join (semi)
            │ table: child_update@c_update_idx_invisible
            │ equality: (p) = (p)
            │
            └── • scan buffer
                  label: buffer 1

# c_delete_idx_invisible is used for constraint check (update on a parent table requires FK check).
query T
EXPLAIN UPDATE parent SET p = p+1
----
distribution: local
vectorized: true
·
• root
│
├── • update
│   │ table: parent
│   │ set: p
│   │
│   └── • buffer
│       │ label: buffer 1
│       │
│       └── • render
│           │
│           └── • scan
│                 missing stats
│                 table: parent@parent_pkey
│                 spans: FULL SCAN
│                 locking strength: for update
│
├── • fk-cascade
│     fk: child_update_p_fkey
│     input: buffer 1
│
└── • constraint-check
    │
    └── • error if rows
        │
        └── • hash join
            │ equality: (p) = (p)
            │ left cols are key
            │ right cols are key
            │
            ├── • except all
            │   │
            │   ├── • scan buffer
            │   │     label: buffer 1
            │   │
            │   └── • scan buffer
            │         label: buffer 1
            │
            └── • distinct
                │ distinct on: p
                │ order key: p
                │
                └── • scan
                      missing stats
                      table: child_delete@c_delete_idx_invisible
                      spans: FULL SCAN

statement ok
DROP TABLE child_delete

statement ok
DROP TABLE child_update

statement ok
DROP TABLE parent

############################################################################
# We should log notices 
# when dropping an index might be different from marking an index invisible
# - Invisible unique indexes are created  
# - Invisible indexes are created in a child table 
# - Invisible indexes are used with Force Index
############################################################################
# Creating an invisble secondary index in CREATE TABLE does not log warning if it is not in a child table.
query T noticetrace
CREATE TABLE t1 (p INT PRIMARY KEY, INDEX idx_invisible (p) NOT VISIBLE)
----

# Creating an invisble secondary index in CREATE INDEX does not log warning.
query T noticetrace
CREATE INDEX t1_idx_invisible_unique ON t1(p) NOT VISIBLE
----

# Creating an invisble unique index in CREATE INDEX does log warning.
query T noticetrace
CREATE UNIQUE INDEX t1_idx_invisible ON t1(p) NOT VISIBLE
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Creating an invisble unique index in CREATE TABLE does log warning.
# TODO (wenyihu6): try to find workaround to test for creating invisible unique indexes in CREATE TABLE 
# (confirmed that the following statement works on a cluster)
# query T noticetrace
# CREATE TABLE t2 (p INT PRIMARY KEY, UNIQUE INDEX c_idx_invisible (p) NOT VISIBLE)
# ----

# Creating an invisble unique index in CREATE TABLE does log warning.
# (Confirmed that the following statement works on a cluster and only prints once.)
# query T noticetrace
# CREATE TABLE t3 (p INT PRIMARY KEY, UNIQUE INDEX c_idx_invisible1 (p) NOT VISIBLE, UNIQUE INDEX c_idx_invisible2 (p) NOT VISIBLE)
# ----

statement ok
DROP TABLE t1

############################################################################
# Creating an invisble secondary index in CREATE TABLE does not log warning if it is not in a child table.
query T noticetrace
CREATE TABLE parent (p INT PRIMARY KEY, INDEX p_idx_invisible_1 (p) NOT VISIBLE)
----

# Creating an invisible index in a child table does log warning and only once.
query T noticetrace
CREATE TABLE child (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p), INDEX c_idx1_invisible (p) NOT VISIBLE, INDEX c_idx2_invisible (p) NOT VISIBLE)
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Creating an invisible index in a child table does log warning.
query T noticetrace
CREATE INDEX c_idx3_invisible ON child(p) NOT VISIBLE
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Creating a unique invisible index in a child table does log warning and only once.
query T noticetrace
CREATE UNIQUE INDEX c_idx_invisible_unique ON child(p) NOT VISIBLE
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Creating an invisble secondary index in a parent table still does not log warning.
query T noticetrace
CREATE INDEX p_idx_invisible_2 ON parent(p) NOT VISIBLE
----

statement ok
DROP TABLE child

statement ok
DROP TABLE parent

############################################################################
query T noticetrace
CREATE TABLE parent (p INT PRIMARY KEY)
----

query T noticetrace
CREATE TABLE child (c INT PRIMARY KEY)
----

# Adding a FK constraint to a table without invisible indexes does not log warning.
query T noticetrace
ALTER TABLE child ADD CONSTRAINT p_fk_1 FOREIGN KEY (c) REFERENCES parent(p);
----

# Adding invisible indexes to a child table logs warning.
query T noticetrace
CREATE INDEX c_idx_invisible_2 ON child(c) NOT VISIBLE
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Adding a FK constraint to a table with invisible indexes should log warning.
query T noticetrace
ALTER TABLE child ADD CONSTRAINT p_fk_2 FOREIGN KEY (c) REFERENCES parent(p);
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Adding multiple FK constraints in a table with invisible indexes should log only once. 
query T noticetrace
ALTER TABLE child ADD CONSTRAINT fk1 FOREIGN KEY (c) REFERENCES parent(p), ADD CONSTRAINT fk2 FOREIGN KEY (c) REFERENCES child(c);
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Having multiple FK constraints in CREATE TABLE with invisible indexes should log only once.
query T noticetrace
CREATE TABLE child2 (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p) ON DELETE CASCADE, h INT NOT NULL REFERENCES child(c) ON DELETE CASCADE, INDEX c1_idx_invisible (p) NOT VISIBLE)
----
NOTICE: invisible indexes may still be used for unique or foreign key constraint check, so the query plan may be different from dropping the index completely.

# Having FK constraints and multiple unique invisible indexes in CREATE TABLE should log only once.
# (Confirmed that the following statement works on a cluster and only prints once.)
# query T noticetrace
# CREATE TABLE child3 (c INT PRIMARY KEY, p INT NOT NULL REFERENCES parent(p) ON DELETE CASCADE, h INT NOT NULL REFERENCES child(c) ON DELETE CASCADE, UNIQUE INDEX c1_idx_invisible (p) NOT VISIBLE)
# ----

# 6. Force index with invisible index should also throw a notice
