exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING)
----
TABLE a
 ├── k int not null
 ├── i int
 ├── f float
 ├── s string
 └── INDEX primary
      └── k int not null

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----
TABLE xy
 ├── x int not null
 ├── y int
 └── INDEX primary
      └── x int not null

# --------------------------------------------------
# PruneProjectCols
# --------------------------------------------------

# Discard some of columns.
opt
SELECT k FROM (SELECT k, i+1 FROM a) a
----
scan a
 └── columns: k:1(int!null)

# Discard all columns.
opt
SELECT 1 r FROM (SELECT i+1, k FROM a) a
----
project
 ├── columns: r:6(int!null)
 ├── scan a
 └── projections
      └── const: 1 [type=int]

# Use column values within computed column.
opt
SELECT k+i AS r FROM (SELECT i, k, s || 'foo' FROM a) a
----
project
 ├── columns: r:6(int)
 ├── scan a
 │    └── columns: k:1(int!null) i:2(int)
 └── projections [outer=(1,2)]
      └── a.k + a.i [type=int, outer=(1,2)]

# Discard non-computed columns and keep computed column.
opt
SELECT l, k FROM (SELECT length(s) l, * FROM a) a
----
project
 ├── columns: l:5(int) k:1(int!null)
 ├── scan a
 │    └── columns: k:1(int!null) s:4(string)
 └── projections [outer=(1,4)]
      └── length(a.s) [type=int, outer=(4)]

# Compute column based on another computed column.
opt
SELECT l*l AS r, k FROM (SELECT k, length(s) l, i FROM a) a
----
project
 ├── columns: r:6(int) k:1(int!null)
 ├── project
 │    ├── columns: l:5(int) k:1(int!null)
 │    ├── scan a
 │    │    └── columns: k:1(int!null) s:4(string)
 │    └── projections [outer=(1,4)]
 │         └── length(a.s) [type=int, outer=(4)]
 └── projections [outer=(1,5)]
      └── l * l [type=int, outer=(5)]

# --------------------------------------------------
# PruneScanCols
# --------------------------------------------------

# Project subset of columns.
opt
SELECT k FROM a
----
scan a
 └── columns: k:1(int!null)

# Project subset of columns, some used in computed columns.
opt
SELECT k, k+1 AS r, i+1 AS s FROM a
----
project
 ├── columns: k:1(int!null) r:5(int) s:6(int)
 ├── scan a
 │    └── columns: k:1(int!null) i:2(int)
 └── projections [outer=(1,2)]
      ├── a.k + 1 [type=int, outer=(1)]
      └── a.i + 1 [type=int, outer=(2)]

# Use columns only in computed columns.
opt
SELECT k+i AS r FROM a
----
project
 ├── columns: r:5(int)
 ├── scan a
 │    └── columns: k:1(int!null) i:2(int)
 └── projections [outer=(1,2)]
      └── a.k + a.i [type=int, outer=(1,2)]

# Use no scan columns.
opt
SELECT 1 r FROM a
----
project
 ├── columns: r:5(int!null)
 ├── scan a
 └── projections
      └── const: 1 [type=int]

# --------------------------------------------------
# PruneSelectCols
# --------------------------------------------------

# Columns used only by projection or filter, but not both.
opt
SELECT k FROM a WHERE i<5
----
project
 ├── columns: k:1(int!null)
 └── select
      ├── columns: k:1(int!null) i:2(int!null)
      ├── scan a
      │    └── columns: k:1(int!null) i:2(int)
      └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
           └── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# Columns used by both projection and filter.
opt
SELECT k, i FROM a WHERE k=1 AND i<5
----
select
 ├── columns: k:1(int!null) i:2(int!null)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int)
 │    └── constraint: /1: [/1 - /1]
 └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      └── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# No needed select columns.
opt
SELECT 1 r FROM a WHERE $1<'2000-01-01T02:00:00'::timestamp
----
project
 ├── columns: r:5(int!null)
 ├── select
 │    ├── scan a
 │    └── filters [type=bool]
 │         └── $1 < '2000-01-01 02:00:00+00:00' [type=bool]
 └── projections
      └── const: 1 [type=int]

# Select columns used in computed columns.
opt
SELECT i-1 AS r, k*k AS t FROM a WHERE k+1<5 AND s||'o'='foo'
----
project
 ├── columns: r:5(int) t:6(int)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    ├── scan a
 │    │    └── columns: k:1(int!null) i:2(int) s:4(string)
 │    └── filters [type=bool, outer=(1,4), constraints=(/1: (/NULL - ])]
 │         ├── a.k < (5 - 1) [type=bool, outer=(1), constraints=(/1: (/NULL - ])]
 │         └── (a.s || 'o') = 'foo' [type=bool, outer=(4)]
 └── projections [outer=(1,2)]
      ├── a.i - 1 [type=int, outer=(2)]
      └── a.k * a.k [type=int, outer=(1)]

# Select nested in select.
opt
SELECT i FROM (SELECT k, i, s, f/2.0 f FROM a WHERE k = 5) a2 WHERE i::float = f
----
project
 ├── columns: i:2(int)
 └── select
      ├── columns: i:2(int) f:5(float!null)
      ├── project
      │    ├── columns: f:5(float) i:2(int)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int) a.f:3(float)
      │    │    └── constraint: /1: [/5 - /5]
      │    └── projections [outer=(2,3)]
      │         └── a.f / 2.0 [type=float, outer=(3)]
      └── filters [type=bool, outer=(2,5), constraints=(/5: (/NULL - ])]
           └── f = a.i::FLOAT [type=bool, outer=(2,5), constraints=(/5: (/NULL - ])]

# Detect PruneSelectCols and PushSelectIntoProject dependency cycle.
opt
SELECT f, f+1.1 AS r FROM (SELECT f, k FROM a GROUP BY f, k HAVING sum(k)=100) a
----
project
 ├── columns: f:3(float) r:6(float)
 ├── select
 │    ├── columns: k:1(int!null) f:3(float) column5:5(decimal!null)
 │    ├── group-by
 │    │    ├── columns: k:1(int!null) f:3(float) column5:5(decimal)
 │    │    ├── grouping columns: k:1(int!null) f:3(float)
 │    │    ├── scan a
 │    │    │    └── columns: k:1(int!null) f:3(float)
 │    │    └── aggregations [outer=(1)]
 │    │         └── sum [type=decimal, outer=(1)]
 │    │              └── variable: a.k [type=int, outer=(1)]
 │    └── filters [type=bool, outer=(5), constraints=(/5: [/100 - /100]; tight)]
 │         └── column5 = 100 [type=bool, outer=(5), constraints=(/5: [/100 - /100]; tight)]
 └── projections [outer=(3)]
      └── a.f + 1.1 [type=float, outer=(3)]

# --------------------------------------------------
# PruneLimitCols
# --------------------------------------------------

# The projection on top of Limit should trickle down and we shouldn't scan f.
opt
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i LIMIT 10)
----
project
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 10]
 └── limit
      ├── columns: k:1(int!null) i:2(int)
      ├── cardinality: [0 - 10]
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── ordering: +2
      │    └── scan a
      │         └── columns: k:1(int!null) i:2(int)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY k, i LIMIT 10)
----
project
 ├── columns: s:4(string)
 ├── cardinality: [0 - 10]
 └── scan a
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      └── limit: 10

# We should scan k, i, s.
opt
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY k, i LIMIT 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 ├── cardinality: [0 - 10]
 └── scan a
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      └── limit: 10

# Project uses subset of Limit columns, but no additional Project should be
# introduced to tree, because it can't be pushed down to Scan.
opt
SELECT f, f*2.0 AS r FROM (SELECT f, s FROM a GROUP BY f, s LIMIT 5) a
----
project
 ├── columns: f:3(float) r:5(float)
 ├── cardinality: [0 - 5]
 ├── limit
 │    ├── columns: f:3(float) s:4(string)
 │    ├── cardinality: [0 - 5]
 │    ├── group-by
 │    │    ├── columns: f:3(float) s:4(string)
 │    │    ├── grouping columns: f:3(float) s:4(string)
 │    │    └── scan a
 │    │         └── columns: f:3(float) s:4(string)
 │    └── const: 5 [type=int]
 └── projections [outer=(3)]
      └── a.f * 2.0 [type=float, outer=(3)]

# --------------------------------------------------
# PruneOffsetCols
# --------------------------------------------------

opt
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i OFFSET 10)
----
project
 ├── columns: k:1(int!null)
 └── offset
      ├── columns: k:1(int!null) i:2(int)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── ordering: +2
      │    └── scan a
      │         └── columns: k:1(int!null) i:2(int)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY k, i OFFSET 10)
----
project
 ├── columns: s:4(string)
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    └── ordering: +1,+2
      └── const: 10 [type=int]

# We should scan k, i, s.
opt
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY k, i OFFSET 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    └── ordering: +1,+2
      └── const: 10 [type=int]

# Project uses subset of Offset columns, but no additional Project should be
# introduced to tree, because it can't be pushed down past Explain.
opt
SELECT "Tree", "Columns"
FROM
(
    SELECT *
    FROM [ EXPLAIN (VERBOSE) SELECT * FROM a ]
    ORDER BY "Tree"
    OFFSET 1
)
----
project
 ├── columns: Tree:5(string) Columns:10(string)
 └── offset
      ├── columns: Tree:5(string) Level:6(int) Type:7(string) Field:8(string) Description:9(string) Columns:10(string) Ordering:11(string)
      ├── sort
      │    ├── columns: Tree:5(string) Level:6(int) Type:7(string) Field:8(string) Description:9(string) Columns:10(string) Ordering:11(string)
      │    ├── ordering: +5
      │    └── explain
      │         ├── columns: Tree:5(string) Level:6(int) Type:7(string) Field:8(string) Description:9(string) Columns:10(string) Ordering:11(string)
      │         └── scan a
      │              └── columns: k:1(int!null) i:2(int) f:3(float) s:4(string)
      └── const: 1 [type=int]

# --------------------------------------------------
# PruneLimitCols + PruneOffsetCols
# --------------------------------------------------

opt
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i LIMIT 10 OFFSET 10)
----
project
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 10]
 └── limit
      ├── columns: k:1(int!null) i:2(int)
      ├── cardinality: [0 - 10]
      ├── offset
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── ordering: +2
      │    ├── sort
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── ordering: +2
      │    │    └── scan a
      │    │         └── columns: k:1(int!null) i:2(int)
      │    └── const: 10 [type=int]
      └── const: 10 [type=int]

# We should scan k, i, s.
opt
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY k, i LIMIT 10 OFFSET 10)
----
project
 ├── columns: s:4(string)
 ├── cardinality: [0 - 10]
 └── limit
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── cardinality: [0 - 10]
      ├── offset
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── ordering: +1,+2
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │    └── ordering: +1,+2
      │    └── const: 10 [type=int]
      └── const: 10 [type=int]

# We should scan k, i, s.
opt
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY k, i LIMIT 10 OFFSET 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 ├── cardinality: [0 - 10]
 └── limit
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── cardinality: [0 - 10]
      ├── offset
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── ordering: +1,+2
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │    └── ordering: +1,+2
      │    └── const: 10 [type=int]
      └── const: 10 [type=int]

# Project filter offset/limit columns, but can't push all the way down to scan.
opt
SELECT f, f*2.0 AS r FROM (SELECT f, s FROM a GROUP BY f, s OFFSET 5 LIMIT 5) a
----
project
 ├── columns: f:3(float) r:5(float)
 ├── cardinality: [0 - 5]
 ├── limit
 │    ├── columns: f:3(float) s:4(string)
 │    ├── cardinality: [0 - 5]
 │    ├── offset
 │    │    ├── columns: f:3(float) s:4(string)
 │    │    ├── group-by
 │    │    │    ├── columns: f:3(float) s:4(string)
 │    │    │    ├── grouping columns: f:3(float) s:4(string)
 │    │    │    └── scan a
 │    │    │         └── columns: f:3(float) s:4(string)
 │    │    └── const: 5 [type=int]
 │    └── const: 5 [type=int]
 └── projections [outer=(3)]
      └── a.f * 2.0 [type=float, outer=(3)]

# --------------------------------------------------
# PruneJoinLeftCols
# --------------------------------------------------

# Columns used only by projection or on condition, but not both.
opt
SELECT a.i, xy.* FROM a INNER JOIN xy ON a.k=xy.x
----
project
 ├── columns: i:2(int) x:5(int!null) y:6(int)
 └── inner-join
      ├── columns: k:1(int!null) i:2(int) x:5(int!null) y:6(int)
      ├── scan a
      │    └── columns: k:1(int!null) i:2(int)
      ├── scan xy
      │    └── columns: x:5(int!null) y:6(int)
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

# Columns used by both projection and on condition, left join.
opt
SELECT a.k, a.i, xy.* FROM a LEFT JOIN xy ON a.k=xy.x AND a.i<5
----
left-join
 ├── columns: k:1(int!null) i:2(int) x:5(int) y:6(int)
 ├── scan a
 │    └── columns: k:1(int!null) i:2(int)
 ├── scan xy
 │    └── columns: x:5(int!null) y:6(int)
 └── filters [type=bool, outer=(1,2,5), constraints=(/1: (/NULL - ]; /2: (/NULL - /4]; /5: (/NULL - ])]
      ├── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
      └── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# Columns only used by on condition, right join
opt
SELECT xy.* FROM a RIGHT JOIN xy ON a.k=xy.x
----
project
 ├── columns: x:5(int!null) y:6(int)
 └── right-join
      ├── columns: k:1(int) x:5(int!null) y:6(int)
      ├── scan a
      │    └── columns: k:1(int!null)
      ├── scan xy
      │    └── columns: x:5(int!null) y:6(int)
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

# Columns needed only by projection, full join.
opt
SELECT a.k+1 AS r, xy.* FROM a FULL JOIN xy ON True
----
project
 ├── columns: r:7(int) x:5(int) y:6(int)
 ├── full-join
 │    ├── columns: k:1(int) x:5(int) y:6(int)
 │    ├── scan a
 │    │    └── columns: k:1(int!null)
 │    ├── scan xy
 │    │    └── columns: x:5(int!null) y:6(int)
 │    └── true [type=bool]
 └── projections [outer=(1,5,6)]
      └── a.k + 1 [type=int, outer=(1)]

# No columns needed from left side of join.
opt
SELECT xy.* FROM a, xy
----
inner-join
 ├── columns: x:5(int!null) y:6(int)
 ├── scan a
 ├── scan xy
 │    └── columns: x:5(int!null) y:6(int)
 └── true [type=bool]

# Computed columns.
opt
SELECT a.k+1 AS r, a.i/2 AS s, xy.* FROM a INNER JOIN xy ON a.k*a.k=xy.x AND a.s||'o'='foo'
----
project
 ├── columns: r:7(int) s:8(decimal) x:5(int!null) y:6(int)
 ├── inner-join
 │    ├── columns: k:1(int!null) i:2(int) a.s:4(string) x:5(int!null) y:6(int)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) a.s:4(string)
 │    │    ├── scan a
 │    │    │    └── columns: k:1(int!null) i:2(int) a.s:4(string)
 │    │    └── filters [type=bool, outer=(4)]
 │    │         └── (a.s || 'o') = 'foo' [type=bool, outer=(4)]
 │    ├── scan xy
 │    │    └── columns: x:5(int!null) y:6(int)
 │    └── filters [type=bool, outer=(1,5), constraints=(/5: (/NULL - ])]
 │         └── xy.x = (a.k * a.k) [type=bool, outer=(1,5), constraints=(/5: (/NULL - ])]
 └── projections [outer=(1,2,5,6)]
      ├── a.k + 1 [type=int, outer=(1)]
      └── a.i / 2 [type=decimal, outer=(2)]

# Join that is nested in another join.
opt
SELECT a.k, xy.*
FROM
(
    SELECT * FROM a INNER JOIN xy ON a.k=xy.x
) a
INNER JOIN xy
ON a.i < xy.y
----
project
 ├── columns: k:1(int!null) x:7(int!null) y:8(int)
 └── inner-join
      ├── columns: k:1(int!null) i:2(int) xy.x:5(int!null) xy.x:7(int!null) xy.y:8(int)
      ├── inner-join
      │    ├── columns: k:1(int!null) i:2(int) xy.x:5(int!null)
      │    ├── scan a
      │    │    └── columns: k:1(int!null) i:2(int)
      │    ├── scan xy
      │    │    └── columns: xy.x:5(int!null)
      │    └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
      │         └── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
      ├── scan xy
      │    └── columns: xy.x:7(int!null) xy.y:8(int)
      └── filters [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]
           └── a.i < xy.y [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# --------------------------------------------------
# PruneJoinRightCols
# --------------------------------------------------

# Columns used only by projection or on condition, but not both.
opt
SELECT xy.*, a.i FROM xy INNER JOIN a ON xy.x=a.k
----
project
 ├── columns: x:1(int!null) y:2(int) i:4(int)
 └── inner-join
      ├── columns: x:1(int!null) y:2(int) k:3(int!null) i:4(int)
      ├── scan xy
      │    └── columns: x:1(int!null) y:2(int)
      ├── scan a
      │    └── columns: k:3(int!null) i:4(int)
      └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
           └── xy.x = a.k [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]

# Columns used by both projection and on condition, left join.
opt
SELECT xy.*, a.k, a.i FROM xy LEFT JOIN a ON xy.x=a.k AND a.i<xy.x
----
left-join
 ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int)
 ├── scan xy
 │    └── columns: x:1(int!null) y:2(int)
 ├── scan a
 │    └── columns: k:3(int!null) i:4(int)
 └── filters [type=bool, outer=(1,3,4), constraints=(/1: (/NULL - ]; /3: (/NULL - ]; /4: (/NULL - ])]
      ├── xy.x = a.k [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
      └── a.i < xy.x [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ])]

# Columns only used by on condition, right join
opt
SELECT xy.* FROM xy RIGHT JOIN a ON xy.x=a.k
----
project
 ├── columns: x:1(int) y:2(int)
 └── right-join
      ├── columns: x:1(int) y:2(int) k:3(int!null)
      ├── scan xy
      │    └── columns: x:1(int!null) y:2(int)
      ├── scan a
      │    └── columns: k:3(int!null)
      └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
           └── xy.x = a.k [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]

# Columns needed only by projection, full join.
opt
SELECT xy.*, a.k+1 AS r FROM xy FULL JOIN a ON True
----
project
 ├── columns: x:1(int) y:2(int) r:7(int)
 ├── full-join
 │    ├── columns: x:1(int) y:2(int) k:3(int)
 │    ├── scan xy
 │    │    └── columns: x:1(int!null) y:2(int)
 │    ├── scan a
 │    │    └── columns: k:3(int!null)
 │    └── true [type=bool]
 └── projections [outer=(1-3)]
      └── a.k + 1 [type=int, outer=(3)]

# No columns needed from right side of join.
opt
SELECT xy.* FROM xy, a
----
inner-join
 ├── columns: x:1(int!null) y:2(int)
 ├── scan xy
 │    └── columns: x:1(int!null) y:2(int)
 ├── scan a
 └── true [type=bool]

# Computed columns.
opt
SELECT xy.*, a.k+1 AS r, a.i/2 AS s FROM xy INNER JOIN a ON xy.x=a.k*a.k AND a.s||'o'='foo'
----
project
 ├── columns: x:1(int!null) y:2(int) r:7(int) s:8(decimal)
 ├── inner-join
 │    ├── columns: x:1(int!null) y:2(int) k:3(int!null) i:4(int) a.s:6(string)
 │    ├── scan xy
 │    │    └── columns: x:1(int!null) y:2(int)
 │    ├── select
 │    │    ├── columns: k:3(int!null) i:4(int) a.s:6(string)
 │    │    ├── scan a
 │    │    │    └── columns: k:3(int!null) i:4(int) a.s:6(string)
 │    │    └── filters [type=bool, outer=(6)]
 │    │         └── (a.s || 'o') = 'foo' [type=bool, outer=(6)]
 │    └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ])]
 │         └── xy.x = (a.k * a.k) [type=bool, outer=(1,3), constraints=(/1: (/NULL - ])]
 └── projections [outer=(1-4)]
      ├── a.k + 1 [type=int, outer=(3)]
      └── a.i / 2 [type=decimal, outer=(4)]

# Join that is nested in another join.
opt
SELECT a.k, xy.*
FROM xy
INNER JOIN
(
    SELECT * FROM a INNER JOIN xy ON a.k=xy.x
) a
ON a.y < xy.y
----
project
 ├── columns: k:3(int!null) x:1(int!null) y:2(int)
 └── inner-join
      ├── columns: xy.x:1(int!null) xy.y:2(int) k:3(int!null) xy.x:7(int!null) xy.y:8(int)
      ├── scan xy
      │    └── columns: xy.x:1(int!null) xy.y:2(int)
      ├── inner-join
      │    ├── columns: k:3(int!null) xy.x:7(int!null) xy.y:8(int)
      │    ├── scan a
      │    │    └── columns: k:3(int!null)
      │    ├── scan xy
      │    │    └── columns: xy.x:7(int!null) xy.y:8(int)
      │    └── filters [type=bool, outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ])]
      │         └── a.k = xy.x [type=bool, outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ])]
      └── filters [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]
           └── xy.y < xy.y [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# --------------------------------------------------
# PruneJoinLeftCols + PruneJoinRightCols
# --------------------------------------------------

# Columns not needed by either side of join.
opt
SELECT 1 r FROM a,xy
----
project
 ├── columns: r:7(int!null)
 ├── inner-join
 │    ├── scan a
 │    ├── scan xy
 │    └── true [type=bool]
 └── projections
      └── const: 1 [type=int]

# Subset of columns needed by each side of join.
opt
SELECT a.k, xy.x, a.k+xy.x AS r FROM a LEFT JOIN xy ON a.k=xy.x
----
project
 ├── columns: k:1(int!null) x:5(int) r:7(int)
 ├── left-join
 │    ├── columns: k:1(int!null) x:5(int)
 │    ├── scan a
 │    │    └── columns: k:1(int!null)
 │    ├── scan xy
 │    │    └── columns: x:5(int!null)
 │    └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
 │         └── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
 └── projections [outer=(1,5)]
      └── a.k + xy.x [type=int, outer=(1,5)]

# --------------------------------------------------
# PruneAggCols
# --------------------------------------------------

# Discard all aggregates.
opt
SELECT s FROM (SELECT s, sum(i), min(s||'foo') FROM a GROUP BY s) a
----
group-by
 ├── columns: s:4(string)
 ├── grouping columns: s:4(string)
 └── scan a
      └── columns: s:4(string)

# Discard subset of aggregates.
opt
SELECT s, sumi FROM (SELECT sum(i) sumi, s, min(s||'foo') FROM a GROUP BY s) a
----
group-by
 ├── columns: s:4(string) sumi:5(decimal)
 ├── grouping columns: s:4(string)
 ├── scan a
 │    └── columns: i:2(int) s:4(string)
 └── aggregations [outer=(2)]
      └── sum [type=decimal, outer=(2)]
           └── variable: a.i [type=int, outer=(2)]

# No aggregates to discard.
opt
SELECT 1 r FROM (SELECT s FROM a GROUP BY s) a
----
project
 ├── columns: r:5(int!null)
 ├── group-by
 │    ├── columns: s:4(string)
 │    ├── grouping columns: s:4(string)
 │    └── scan a
 │         └── columns: s:4(string)
 └── projections
      └── const: 1 [type=int]

# --------------------------------------------------
# PruneGroupByCols
# --------------------------------------------------

# Columns used by grouping or aggregation, but not both.
opt
SELECT s, sum(i) FROM a GROUP BY s
----
group-by
 ├── columns: s:4(string) sum:5(decimal)
 ├── grouping columns: s:4(string)
 ├── scan a
 │    └── columns: i:2(int) s:4(string)
 └── aggregations [outer=(2)]
      └── sum [type=decimal, outer=(2)]
           └── variable: a.i [type=int, outer=(2)]

# Columns used by both grouping and aggregation.
opt
SELECT avg(s::int+i), s, i FROM a GROUP BY s, i
----
group-by
 ├── columns: avg:6(decimal) s:4(string) i:2(int)
 ├── grouping columns: i:2(int) s:4(string)
 ├── project
 │    ├── columns: column5:5(int) i:2(int) s:4(string)
 │    ├── scan a
 │    │    └── columns: i:2(int) s:4(string)
 │    └── projections [outer=(2,4)]
 │         └── a.i + a.s::INT [type=int, outer=(2,4)]
 └── aggregations [outer=(5)]
      └── avg [type=decimal, outer=(5)]
           └── variable: column5 [type=int, outer=(5)]

# Columns used only by aggregation, no grouping columns.
opt
SELECT min(i), max(k), max(k) FROM a
----
group-by
 ├── columns: min:5(int) max:6(int) max:6(int)
 ├── cardinality: [1 - 1]
 ├── scan a
 │    └── columns: k:1(int!null) i:2(int)
 └── aggregations [outer=(1,2)]
      ├── min [type=int, outer=(2)]
      │    └── variable: a.i [type=int, outer=(2)]
      └── max [type=int, outer=(1)]
           └── variable: a.k [type=int, outer=(1)]

# Columns used only by groupings, no aggregation columns.
opt
SELECT s, i+1 AS r FROM a GROUP BY i, s
----
project
 ├── columns: s:4(string) r:5(int)
 ├── group-by
 │    ├── columns: i:2(int) s:4(string)
 │    ├── grouping columns: i:2(int) s:4(string)
 │    └── scan a
 │         └── columns: i:2(int) s:4(string)
 └── projections [outer=(2,4)]
      └── a.i + 1 [type=int, outer=(2)]

# Groupby a groupby.
opt
SELECT min(sm), i FROM (SELECT s, i, sum(k) sm, avg(k) av FROM a GROUP BY i, s) a GROUP BY i
----
group-by
 ├── columns: min:7(decimal) i:2(int)
 ├── grouping columns: i:2(int)
 ├── group-by
 │    ├── columns: i:2(int) s:4(string) sm:5(decimal)
 │    ├── grouping columns: i:2(int) s:4(string)
 │    ├── scan a
 │    │    └── columns: k:1(int!null) i:2(int) s:4(string)
 │    └── aggregations [outer=(1)]
 │         └── sum [type=decimal, outer=(1)]
 │              └── variable: a.k [type=int, outer=(1)]
 └── aggregations [outer=(5)]
      └── min [type=decimal, outer=(5)]
           └── variable: sm [type=decimal, outer=(5)]

# --------------------------------------------------
# PruneValueCols
# --------------------------------------------------

# Discard all but first Values column.
opt
SELECT column1 FROM (VALUES (1, 2), (3, 4)) a
----
values
 ├── columns: column1:1(int)
 ├── cardinality: [2 - 2]
 ├── (1) [type=tuple{int}]
 └── (3) [type=tuple{int}]

# Discard all but middle Values column.
opt
SELECT column2 FROM (VALUES (1, 2, 3), (4, 5, 6)) a
----
values
 ├── columns: column2:2(int)
 ├── cardinality: [2 - 2]
 ├── (2) [type=tuple{int}]
 └── (5) [type=tuple{int}]

# Discard all but last Values column.
opt
SELECT column3 FROM (VALUES ('foo', 'bar', 'baz'), ('apple', 'banana', 'cherry')) a
----
values
 ├── columns: column3:3(string)
 ├── cardinality: [2 - 2]
 ├── ('baz') [type=tuple{string}]
 └── ('cherry') [type=tuple{string}]

# Discard all Values columns.
opt
SELECT 1 r FROM (VALUES ('foo', 'bar', 'baz'), ('apple', 'banana', 'cherry')) a
----
project
 ├── columns: r:4(int!null)
 ├── cardinality: [2 - 2]
 ├── values
 │    ├── cardinality: [2 - 2]
 │    ├── tuple [type=tuple{}]
 │    └── tuple [type=tuple{}]
 └── projections
      └── const: 1 [type=int]

# --------------------------------------------------
# Prune - multiple combined operators
# --------------------------------------------------

opt
SELECT a.k, xy.y FROM a INNER JOIN xy ON a.k=xy.x WHERE a.i < 5
----
project
 ├── columns: k:1(int!null) y:6(int)
 └── inner-join
      ├── columns: k:1(int!null) i:2(int!null) x:5(int!null) y:6(int)
      ├── select
      │    ├── columns: k:1(int!null) i:2(int!null)
      │    ├── scan a
      │    │    └── columns: k:1(int!null) i:2(int)
      │    └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      │         └── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      ├── scan xy
      │    └── columns: x:5(int!null) y:6(int)
      └── filters [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]
           └── a.k = xy.x [type=bool, outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ])]

opt
SELECT k FROM (SELECT k, min(s) FROM a GROUP BY k HAVING sum(i) > 5)
----
project
 ├── columns: k:1(int!null)
 └── select
      ├── columns: k:1(int!null) column5:5(decimal!null)
      ├── group-by
      │    ├── columns: k:1(int!null) column5:5(decimal)
      │    ├── grouping columns: k:1(int!null)
      │    ├── scan a
      │    │    └── columns: k:1(int!null) i:2(int)
      │    └── aggregations [outer=(2)]
      │         └── sum [type=decimal, outer=(2)]
      │              └── variable: a.i [type=int, outer=(2)]
      └── filters [type=bool, outer=(5), constraints=(/5: (/5 - ]; tight)]
           └── column5 > 5 [type=bool, outer=(5), constraints=(/5: (/5 - ]; tight)]

# --------------------------------------------------
# PruneRowNumberCols
# --------------------------------------------------
opt
SELECT i, s FROM a WITH ORDINALITY
----
project
 ├── columns: i:2(int) s:4(string)
 └── row-number
      ├── columns: i:2(int) s:4(string) ordinality:5(int!null)
      └── scan a
           └── columns: i:2(int) s:4(string)

# With order by.
opt
SELECT i, s FROM (SELECT * FROM a ORDER BY f) WITH ORDINALITY
----
project
 ├── columns: i:2(int) s:4(string)
 └── row-number
      ├── columns: i:2(int) f:3(float) s:4(string) ordinality:5(int!null)
      └── sort
           ├── columns: i:2(int) f:3(float) s:4(string)
           ├── ordering: +3
           └── scan a
                └── columns: i:2(int) f:3(float) s:4(string)
