exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE abcde (
    a INT PRIMARY KEY,
    b INT,
    c INT,
    d INT,
    e INT,
    UNIQUE INDEX bc (b, c)
)
----

exec-ddl
CREATE TABLE mutation (
    a INT PRIMARY KEY,
    b INT,
    c INT,
    "d:write-only" INT,
    "e:delete-only" INT,
    UNIQUE INDEX "idx1:write-only" (b, d),
    INDEX "idx2:delete-only" (e)
)
----

exec-ddl
CREATE TABLE family (
    a INT PRIMARY KEY,
    b INT,
    c INT,
    d INT,
    e INT,
    FAMILY (a, b),
    FAMILY (c, d),
    FAMILY (e),
    INDEX (d)
)
----

# --------------------------------------------------
# PruneProjectCols
# --------------------------------------------------

# Discard some of columns.
opt expect=PruneProjectCols
SELECT k1*2 FROM (SELECT k+1 AS k1, i+1 FROM a) a
----
project
 ├── columns: "?column?":7(int)
 ├── scan a
 │    ├── columns: k:1(int!null)
 │    └── key: (1)
 └── projections
      └── (k + 1) * 2 [type=int, outer=(1)]

# Use column values within computed column.
opt expect=PruneProjectCols
SELECT k+length(s) AS r FROM (SELECT i, k, s || 'foo' AS s FROM a) a
----
project
 ├── columns: r:6(int)
 ├── scan a
 │    ├── columns: k:1(int!null) a.s:4(string)
 │    ├── key: (1)
 │    └── fd: (1)-->(4)
 └── projections
      └── k + length(a.s || 'foo') [type=int, outer=(1,4)]

# Discard non-computed columns and keep computed column.
opt expect=PruneProjectCols
SELECT l, l*2, k FROM (SELECT length(s) l, * FROM a) a
----
project
 ├── columns: l:5(int) "?column?":6(int) k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(5), (5)-->(6)
 ├── project
 │    ├── columns: l:5(int) k:1(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) s:4(string)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(4)
 │    └── projections
 │         └── length(s) [type=int, outer=(4)]
 └── projections
      └── l * 2 [type=int, outer=(5)]

# Compute column based on another computed column.
opt expect=PruneProjectCols
SELECT l*l AS r, k FROM (SELECT k, length(s) l, i FROM a) a
----
project
 ├── columns: r:6(int) k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(6)
 ├── project
 │    ├── columns: l:5(int) k:1(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) s:4(string)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(4)
 │    └── projections
 │         └── length(s) [type=int, outer=(4)]
 └── projections
      └── l * l [type=int, outer=(5)]

# --------------------------------------------------
# PruneScanCols
# --------------------------------------------------

# Project subset of columns.
opt expect=PruneScanCols
SELECT k FROM a
----
scan a
 ├── columns: k:1(int!null)
 └── key: (1)

# Project subset of columns, some used in computed columns.
opt expect=PruneScanCols
SELECT k, k+1 AS r, i+1 AS s FROM a
----
project
 ├── columns: k:1(int!null) r:5(int) s:6(int)
 ├── key: (1)
 ├── fd: (1)-->(5,6)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      ├── k + 1 [type=int, outer=(1)]
      └── i + 1 [type=int, outer=(2)]

# Use columns only in computed columns.
opt expect=PruneScanCols
SELECT k+i AS r FROM a
----
project
 ├── columns: r:5(int)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      └── k + i [type=int, outer=(1,2)]

# Use no scan columns.
opt expect=PruneScanCols
SELECT 1 r FROM a
----
project
 ├── columns: r:5(int!null)
 ├── fd: ()-->(5)
 ├── scan a
 └── projections
      └── const: 1 [type=int]

# --------------------------------------------------
# PruneSelectCols
# --------------------------------------------------

# Columns used only by projection or filter, but not both.
opt expect=PruneSelectCols
SELECT k FROM a WHERE i<5
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) i:2(int!null)
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# Columns used by both projection and filter.
opt expect=PruneSelectCols
SELECT k, i FROM a WHERE k=1 AND i<5
----
select
 ├── columns: k:1(int!null) i:2(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── constraint: /1: [/1 - /1]
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    └── fd: ()-->(1,2)
 └── filters
      └── i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# No needed select columns.
opt expect=PruneSelectCols
SELECT 1 r FROM a WHERE $1<'2000-01-01T02:00:00'::timestamp
----
project
 ├── columns: r:5(int!null)
 ├── has-placeholder
 ├── fd: ()-->(5)
 ├── select
 │    ├── has-placeholder
 │    ├── scan a
 │    └── filters
 │         └── $1 < '2000-01-01 02:00:00+00:00' [type=bool]
 └── projections
      └── const: 1 [type=int]

# Select columns used in computed columns.
opt expect=PruneSelectCols
SELECT i-1 AS r, k*k AS t FROM a WHERE k+1<5 AND s||'o'='foo'
----
project
 ├── columns: r:5(int) t:6(int)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,4)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    │    ├── constraint: /1: [ - /3]
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2,4)
 │    └── filters
 │         └── (s || 'o') = 'foo' [type=bool, outer=(4)]
 └── projections
      ├── i - 1 [type=int, outer=(2)]
      └── k * k [type=int, outer=(1)]

# Select nested in select.
opt expect=PruneSelectCols
SELECT i FROM (SELECT k, i, s, f/2.0 f FROM a WHERE k = 5) a2 WHERE i::float = f
----
project
 ├── columns: i:2(int)
 ├── cardinality: [0 - 1]
 ├── side-effects
 ├── key: ()
 ├── fd: ()-->(2)
 └── select
      ├── columns: i:2(int) f:5(float!null)
      ├── cardinality: [0 - 1]
      ├── side-effects
      ├── key: ()
      ├── fd: ()-->(2,5)
      ├── project
      │    ├── columns: f:5(float) i:2(int)
      │    ├── cardinality: [0 - 1]
      │    ├── side-effects
      │    ├── key: ()
      │    ├── fd: ()-->(2,5)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int) a.f:3(float)
      │    │    ├── constraint: /1: [/5 - /5]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(1-3)
      │    └── projections
      │         └── a.f / 2.0 [type=float, outer=(3), side-effects]
      └── filters
           └── f = i::FLOAT8 [type=bool, outer=(2,5), constraints=(/5: (/NULL - ])]

# Detect PruneSelectCols and PushSelectIntoProject dependency cycle.
opt
SELECT f, f+1.1 AS r FROM (SELECT f, k FROM a GROUP BY f, k HAVING sum(k)=100) a
----
project
 ├── columns: f:3(float) r:6(float)
 ├── select
 │    ├── columns: k:1(int!null) f:3(float) sum:5(decimal!null)
 │    ├── key: (1)
 │    ├── fd: ()-->(5), (1)-->(3)
 │    ├── group-by
 │    │    ├── columns: k:1(int!null) f:3(float) sum:5(decimal)
 │    │    ├── grouping columns: k:1(int!null)
 │    │    ├── internal-ordering: +1
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(3,5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) f:3(float)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(3)
 │    │    │    └── ordering: +1
 │    │    └── aggregations
 │    │         ├── sum [type=decimal, outer=(1)]
 │    │         │    └── variable: k [type=int]
 │    │         └── const-agg [type=float, outer=(3)]
 │    │              └── variable: f [type=float]
 │    └── filters
 │         └── sum = 100 [type=bool, outer=(5), constraints=(/5: [/100 - /100]; tight), fd=()-->(5)]
 └── projections
      └── f + 1.1 [type=float, outer=(3)]

# --------------------------------------------------
# PruneLimitCols
# --------------------------------------------------

opt expect=PruneLimitCols
SELECT i FROM (SELECT i, s FROM a LIMIT 1)
----
scan a
 ├── columns: i:2(int)
 ├── limit: 1
 ├── key: ()
 └── fd: ()-->(2)

# The projection on top of Limit should trickle down and we shouldn't scan f.
opt expect=PruneLimitCols
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i LIMIT 10)
----
project
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 10]
 ├── key: (1)
 └── limit
      ├── columns: k:1(int!null) i:2(int)
      ├── internal-ordering: +2
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── ordering: +2
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int)
      │         ├── key: (1)
      │         └── fd: (1)-->(2)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=PruneLimitCols
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY i, k LIMIT 10)
----
project
 ├── columns: s:4(string)
 ├── cardinality: [0 - 10]
 └── limit
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │         ├── key: (1)
      │         └── fd: (1)-->(2,4)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=PruneLimitCols
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY i, k LIMIT 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── limit
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │         ├── key: (1)
      │         └── fd: (1)-->(2,4)
      └── const: 10 [type=int]

# Project uses subset of Limit columns, but no additional Project should be
# introduced to tree, because it can't be pushed down to Scan.
opt
SELECT f, f*2.0 AS r FROM (SELECT f, s FROM a GROUP BY f, s LIMIT 5) a
----
project
 ├── columns: f:3(float) r:5(float)
 ├── cardinality: [0 - 5]
 ├── limit
 │    ├── columns: f:3(float) s:4(string)
 │    ├── cardinality: [0 - 5]
 │    ├── key: (3,4)
 │    ├── distinct-on
 │    │    ├── columns: f:3(float) s:4(string)
 │    │    ├── grouping columns: f:3(float) s:4(string)
 │    │    ├── key: (3,4)
 │    │    └── scan a
 │    │         └── columns: f:3(float) s:4(string)
 │    └── const: 5 [type=int]
 └── projections
      └── f * 2.0 [type=float, outer=(3)]

# --------------------------------------------------
# PruneOffsetCols
# --------------------------------------------------

opt expect=PruneOffsetCols
SELECT f FROM (SELECT * FROM a OFFSET 1)
----
offset
 ├── columns: f:3(float)
 ├── scan a
 │    └── columns: f:3(float)
 └── const: 1 [type=int]

opt expect=PruneOffsetCols
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i OFFSET 10)
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── offset
      ├── columns: k:1(int!null) i:2(int)
      ├── internal-ordering: +2
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── ordering: +2
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int)
      │         ├── key: (1)
      │         └── fd: (1)-->(2)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=PruneOffsetCols
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY i, k OFFSET 10)
----
project
 ├── columns: s:4(string)
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │         ├── key: (1)
      │         └── fd: (1)-->(2,4)
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=PruneOffsetCols
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY i, k OFFSET 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── sort
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    └── scan a
      │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │         ├── key: (1)
      │         └── fd: (1)-->(2,4)
      └── const: 10 [type=int]

# Project uses subset of Offset columns, but no additional Project should be
# introduced to tree, because it can't be pushed down past Explain.
opt
SELECT tree, columns
FROM
(
    SELECT *
    FROM [ EXPLAIN (VERBOSE) SELECT * FROM a ]
    ORDER BY tree
    OFFSET 1
)
----
project
 ├── columns: tree:5(string) columns:10(string)
 └── offset
      ├── columns: tree:5(string) level:6(int) node_type:7(string) field:8(string) description:9(string) columns:10(string) ordering:11(string)
      ├── internal-ordering: +5
      ├── sort
      │    ├── columns: tree:5(string) level:6(int) node_type:7(string) field:8(string) description:9(string) columns:10(string) ordering:11(string)
      │    ├── ordering: +5
      │    └── explain
      │         ├── columns: tree:5(string) level:6(int) node_type:7(string) field:8(string) description:9(string) columns:10(string) ordering:11(string)
      │         ├── mode: verbose
      │         └── scan a
      │              ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string)
      │              ├── key: (1)
      │              └── fd: (1)-->(2-4)
      └── const: 1 [type=int]

# --------------------------------------------------
# PruneLimitCols + PruneOffsetCols
# --------------------------------------------------

opt expect=(PruneLimitCols,PruneOffsetCols)
SELECT k FROM (SELECT k, i, f FROM a ORDER BY i LIMIT 10 OFFSET 10)
----
project
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 10]
 ├── key: (1)
 └── offset
      ├── columns: k:1(int!null) i:2(int)
      ├── internal-ordering: +2
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── limit
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── internal-ordering: +2
      │    ├── cardinality: [0 - 20]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── ordering: +2
      │    ├── sort
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    ├── ordering: +2
      │    │    └── scan a
      │    │         ├── columns: k:1(int!null) i:2(int)
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── const: 20 [type=int]
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=(PruneLimitCols,PruneOffsetCols)
SELECT s FROM (SELECT k, i, f, s FROM a ORDER BY i, k LIMIT 10 OFFSET 10)
----
project
 ├── columns: s:4(string)
 ├── cardinality: [0 - 10]
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── limit
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── internal-ordering: +2,+1
      │    ├── cardinality: [0 - 20]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    ├── sort
      │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,4)
      │    │    ├── ordering: +2,+1
      │    │    └── scan a
      │    │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2,4)
      │    └── const: 20 [type=int]
      └── const: 10 [type=int]

# We should scan k, i, s.
opt expect=(PruneLimitCols,PruneOffsetCols)
SELECT k, s FROM (SELECT k, i, f, s FROM a ORDER BY i, k LIMIT 10 OFFSET 10)
----
project
 ├── columns: k:1(int!null) s:4(string)
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── offset
      ├── columns: k:1(int!null) i:2(int) s:4(string)
      ├── internal-ordering: +2,+1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2,4)
      ├── limit
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── internal-ordering: +2,+1
      │    ├── cardinality: [0 - 20]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── ordering: +2,+1
      │    ├── sort
      │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,4)
      │    │    ├── ordering: +2,+1
      │    │    └── scan a
      │    │         ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2,4)
      │    └── const: 20 [type=int]
      └── const: 10 [type=int]

# Project filter offset/limit columns, but can't push all the way down to scan.
opt
SELECT f, f*2.0 AS r FROM (SELECT f, s FROM a GROUP BY f, s OFFSET 5 LIMIT 5) a
----
project
 ├── columns: f:3(float) r:5(float)
 ├── cardinality: [0 - 5]
 ├── offset
 │    ├── columns: f:3(float) s:4(string)
 │    ├── cardinality: [0 - 5]
 │    ├── key: (3,4)
 │    ├── limit
 │    │    ├── columns: f:3(float) s:4(string)
 │    │    ├── cardinality: [0 - 10]
 │    │    ├── key: (3,4)
 │    │    ├── distinct-on
 │    │    │    ├── columns: f:3(float) s:4(string)
 │    │    │    ├── grouping columns: f:3(float) s:4(string)
 │    │    │    ├── key: (3,4)
 │    │    │    └── scan a
 │    │    │         └── columns: f:3(float) s:4(string)
 │    │    └── const: 10 [type=int]
 │    └── const: 5 [type=int]
 └── projections
      └── f * 2.0 [type=float, outer=(3)]

# --------------------------------------------------
# PruneJoinLeftCols
# --------------------------------------------------

# Columns used only by projection or on condition, but not both.
opt expect=PruneJoinLeftCols
SELECT a.i, xy.* FROM a INNER JOIN xy ON a.k=xy.x
----
project
 ├── columns: i:2(int) x:5(int!null) y:6(int)
 ├── key: (5)
 ├── fd: (5)-->(2,6)
 └── inner-join (merge)
      ├── columns: k:1(int!null) i:2(int) x:5(int!null) y:6(int)
      ├── left ordering: +1
      ├── right ordering: +5
      ├── key: (5)
      ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      ├── scan xy
      │    ├── columns: x:5(int!null) y:6(int)
      │    ├── key: (5)
      │    ├── fd: (5)-->(6)
      │    └── ordering: +5
      └── filters (true)

# Columns used by both projection and on condition, left join.
opt expect=PruneJoinLeftCols
SELECT a.k, a.i, xy.* FROM a LEFT JOIN xy ON a.k=xy.x AND a.i<5
----
left-join (merge)
 ├── columns: k:1(int!null) i:2(int) x:5(int) y:6(int)
 ├── left ordering: +1
 ├── right ordering: +5
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 ├── scan xy
 │    ├── columns: x:5(int!null) y:6(int)
 │    ├── key: (5)
 │    ├── fd: (5)-->(6)
 │    └── ordering: +5
 └── filters
      └── i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

# Columns only used by on condition, right join
opt expect=PruneJoinLeftCols
SELECT xy.* FROM a RIGHT JOIN xy ON a.k=xy.x
----
project
 ├── columns: x:5(int!null) y:6(int)
 ├── fd: (5)-->(6)
 └── right-join (merge)
      ├── columns: k:1(int) x:5(int!null) y:6(int)
      ├── left ordering: +1
      ├── right ordering: +5
      ├── key: (1,5)
      ├── fd: (5)-->(6)
      ├── scan a
      │    ├── columns: k:1(int!null)
      │    ├── key: (1)
      │    └── ordering: +1
      ├── scan xy
      │    ├── columns: x:5(int!null) y:6(int)
      │    ├── key: (5)
      │    ├── fd: (5)-->(6)
      │    └── ordering: +5
      └── filters (true)

# Columns needed only by projection, full join.
opt expect=PruneJoinLeftCols
SELECT a.k+1 AS r, xy.* FROM a FULL JOIN xy ON True
----
project
 ├── columns: r:7(int) x:5(int) y:6(int)
 ├── fd: (5)-->(6)
 ├── full-join (hash)
 │    ├── columns: k:1(int) x:5(int) y:6(int)
 │    ├── key: (1,5)
 │    ├── fd: (5)-->(6)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null)
 │    │    └── key: (1)
 │    ├── scan xy
 │    │    ├── columns: x:5(int!null) y:6(int)
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters (true)
 └── projections
      └── k + 1 [type=int, outer=(1)]

# No columns needed from left side of join.
opt expect=PruneJoinLeftCols
SELECT xy.* FROM a, xy
----
inner-join (hash)
 ├── columns: x:5(int!null) y:6(int)
 ├── fd: (5)-->(6)
 ├── scan a
 ├── scan xy
 │    ├── columns: x:5(int!null) y:6(int)
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters (true)

# Computed columns.
opt expect=PruneJoinLeftCols
SELECT a.k+1 AS r, a.i/2 AS s, xy.* FROM a INNER JOIN xy ON a.k*a.k=xy.x AND a.s||'o'='foo'
----
project
 ├── columns: r:8(int) s:9(decimal) x:5(int!null) y:6(int)
 ├── side-effects
 ├── fd: (5)-->(6)
 ├── inner-join (hash)
 │    ├── columns: k:1(int!null) i:2(int) x:5(int!null) y:6(int) column7:7(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,7), (5)-->(6), (5)==(7), (7)==(5)
 │    ├── scan xy
 │    │    ├── columns: x:5(int!null) y:6(int)
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    ├── project
 │    │    ├── columns: column7:7(int) k:1(int!null) i:2(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,7)
 │    │    ├── select
 │    │    │    ├── columns: k:1(int!null) i:2(int) a.s:4(string)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2,4)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1(int!null) i:2(int) a.s:4(string)
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2,4)
 │    │    │    └── filters
 │    │    │         └── (a.s || 'o') = 'foo' [type=bool, outer=(4)]
 │    │    └── projections
 │    │         └── k * k [type=int, outer=(1)]
 │    └── filters
 │         └── column7 = x [type=bool, outer=(5,7), constraints=(/5: (/NULL - ]; /7: (/NULL - ]), fd=(5)==(7), (7)==(5)]
 └── projections
      ├── k + 1 [type=int, outer=(1)]
      └── i / 2 [type=decimal, outer=(2), side-effects]

# Join that is nested in another join.
opt expect=PruneJoinLeftCols
SELECT a.k, xy.*
FROM
(
    SELECT * FROM a INNER JOIN xy ON a.k=xy.x
) a
INNER JOIN xy
ON a.i < xy.y
----
project
 ├── columns: k:1(int!null) x:7(int!null) y:8(int!null)
 ├── key: (1,7)
 ├── fd: (7)-->(8)
 └── inner-join (hash)
      ├── columns: k:1(int!null) i:2(int!null) x:5(int!null) x:7(int!null) y:8(int!null)
      ├── key: (5,7)
      ├── fd: (1)-->(2), (1)==(5), (5)==(1), (7)-->(8)
      ├── inner-join (merge)
      │    ├── columns: k:1(int!null) i:2(int) x:5(int!null)
      │    ├── left ordering: +1
      │    ├── right ordering: +5
      │    ├── key: (5)
      │    ├── fd: (1)-->(2), (1)==(5), (5)==(1)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    └── ordering: +1
      │    ├── scan xy
      │    │    ├── columns: x:5(int!null)
      │    │    ├── key: (5)
      │    │    └── ordering: +5
      │    └── filters (true)
      ├── scan xy
      │    ├── columns: x:7(int!null) y:8(int)
      │    ├── key: (7)
      │    └── fd: (7)-->(8)
      └── filters
           └── i < y [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# ApplyJoin operator.
opt expect=PruneJoinLeftCols
SELECT k, i
FROM a
WHERE (SELECT k+1 AS r FROM xy WHERE y=k) = 1
----
project
 ├── columns: k:1(int!null) i:2(int)
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── inner-join-apply
      ├── columns: k:1(int!null) i:2(int) r:7(int)
      ├── key: (1)
      ├── fd: ()-->(7), (1)-->(2)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── max1-row
      │    ├── columns: r:7(int)
      │    ├── outer: (1)
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(7)
      │    └── project
      │         ├── columns: r:7(int)
      │         ├── outer: (1)
      │         ├── fd: ()-->(7)
      │         ├── select
      │         │    ├── columns: y:6(int!null)
      │         │    ├── outer: (1)
      │         │    ├── fd: ()-->(6)
      │         │    ├── scan xy
      │         │    │    └── columns: y:6(int)
      │         │    └── filters
      │         │         └── y = k [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │         └── projections
      │              └── k + 1 [type=int, outer=(1)]
      └── filters
           └── r = 1 [type=bool, outer=(7), constraints=(/7: [/1 - /1]; tight), fd=()-->(7)]

# SemiJoin operator.
opt expect=PruneJoinLeftCols
SELECT a.i
FROM a
WHERE
    EXISTS(SELECT * FROM xy WHERE a.k=xy.x) AND
    EXISTS(SELECT * FROM xy WHERE a.k=xy.x)
----
project
 ├── columns: i:2(int)
 └── semi-join (merge)
      ├── columns: k:1(int!null) i:2(int)
      ├── left ordering: +1
      ├── right ordering: +5
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── semi-join (merge)
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── left ordering: +1
      │    ├── right ordering: +7
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── ordering: +1
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    └── ordering: +1
      │    ├── scan xy
      │    │    ├── columns: x:7(int!null)
      │    │    ├── key: (7)
      │    │    └── ordering: +7
      │    └── filters (true)
      ├── scan xy
      │    ├── columns: x:5(int!null)
      │    ├── key: (5)
      │    └── ordering: +5
      └── filters (true)

# AntiJoin operator.
opt expect=PruneJoinLeftCols
SELECT a.i
FROM a
WHERE
    NOT EXISTS(SELECT * FROM xy WHERE a.k=xy.x) AND
    NOT EXISTS(SELECT * FROM xy WHERE a.k=xy.x)
----
project
 ├── columns: i:2(int)
 └── anti-join (lookup xy)
      ├── columns: k:1(int!null) i:2(int)
      ├── key columns: [1] = [5]
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── anti-join (merge)
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── left ordering: +1
      │    ├── right ordering: +7
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    └── ordering: +1
      │    ├── scan xy
      │    │    ├── columns: x:7(int!null)
      │    │    ├── key: (7)
      │    │    └── ordering: +7
      │    └── filters (true)
      └── filters (true)

# --------------------------------------------------
# PruneJoinRightCols
# --------------------------------------------------

# Columns used only by projection or on condition, but not both.
opt expect=PruneJoinRightCols
SELECT xy.*, a.i FROM xy INNER JOIN a ON xy.x=a.k
----
project
 ├── columns: x:1(int!null) y:2(int) i:4(int)
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 └── inner-join (merge)
      ├── columns: x:1(int!null) y:2(int) k:3(int!null) i:4(int)
      ├── left ordering: +1
      ├── right ordering: +3
      ├── key: (3)
      ├── fd: (1)-->(2), (3)-->(4), (1)==(3), (3)==(1)
      ├── scan xy
      │    ├── columns: x:1(int!null) y:2(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      ├── scan a
      │    ├── columns: k:3(int!null) i:4(int)
      │    ├── key: (3)
      │    ├── fd: (3)-->(4)
      │    └── ordering: +3
      └── filters (true)

# Columns used by both projection and on condition, left join.
opt expect=PruneJoinRightCols
SELECT xy.*, a.k, a.i FROM xy LEFT JOIN a ON xy.x=a.k AND a.i<xy.x
----
left-join (merge)
 ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int)
 ├── left ordering: +1
 ├── right ordering: +3
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4)
 ├── scan xy
 │    ├── columns: x:1(int!null) y:2(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 ├── select
 │    ├── columns: k:3(int!null) i:4(int!null)
 │    ├── key: (3)
 │    ├── fd: (3)-->(4)
 │    ├── ordering: +3
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4)
 │    │    └── ordering: +3
 │    └── filters
 │         └── i < k [type=bool, outer=(3,4), constraints=(/3: (/NULL - ]; /4: (/NULL - ])]
 └── filters (true)

# Columns only used by on condition, right join
opt expect=PruneJoinRightCols
SELECT xy.* FROM xy RIGHT JOIN a ON xy.x=a.k
----
project
 ├── columns: x:1(int) y:2(int)
 ├── fd: (1)-->(2)
 └── right-join (merge)
      ├── columns: x:1(int) y:2(int) k:3(int!null)
      ├── left ordering: +1
      ├── right ordering: +3
      ├── key: (1,3)
      ├── fd: (1)-->(2)
      ├── scan xy
      │    ├── columns: x:1(int!null) y:2(int)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    └── ordering: +1
      ├── scan a
      │    ├── columns: k:3(int!null)
      │    ├── key: (3)
      │    └── ordering: +3
      └── filters (true)

# Columns needed only by projection, full join.
opt expect=PruneJoinRightCols
SELECT xy.*, a.k+1 AS r FROM xy FULL JOIN a ON True
----
project
 ├── columns: x:1(int) y:2(int) r:7(int)
 ├── fd: (1)-->(2)
 ├── full-join (hash)
 │    ├── columns: x:1(int) y:2(int) k:3(int)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan a
 │    │    ├── columns: k:3(int!null)
 │    │    └── key: (3)
 │    └── filters (true)
 └── projections
      └── k + 1 [type=int, outer=(3)]

# No columns needed from right side of join.
opt expect=PruneJoinRightCols
SELECT xy.* FROM xy, a
----
inner-join (hash)
 ├── columns: x:1(int!null) y:2(int)
 ├── fd: (1)-->(2)
 ├── scan xy
 │    ├── columns: x:1(int!null) y:2(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── scan a
 └── filters (true)

# Computed columns.
opt expect=PruneJoinRightCols
SELECT xy.*, a.k+1 AS r, a.i/2 AS s FROM xy INNER JOIN a ON xy.x=a.k*a.k AND a.s||'o'='foo'
----
project
 ├── columns: x:1(int!null) y:2(int) r:8(int) s:9(decimal)
 ├── side-effects
 ├── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: x:1(int!null) y:2(int) k:3(int!null) i:4(int) column7:7(int!null)
 │    ├── key: (3)
 │    ├── fd: (1)-->(2), (3)-->(4,7), (1)==(7), (7)==(1)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── project
 │    │    ├── columns: column7:7(int) k:3(int!null) i:4(int)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4,7)
 │    │    ├── select
 │    │    │    ├── columns: k:3(int!null) i:4(int) a.s:6(string)
 │    │    │    ├── key: (3)
 │    │    │    ├── fd: (3)-->(4,6)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:3(int!null) i:4(int) a.s:6(string)
 │    │    │    │    ├── key: (3)
 │    │    │    │    └── fd: (3)-->(4,6)
 │    │    │    └── filters
 │    │    │         └── (a.s || 'o') = 'foo' [type=bool, outer=(6)]
 │    │    └── projections
 │    │         └── k * k [type=int, outer=(3)]
 │    └── filters
 │         └── x = column7 [type=bool, outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 └── projections
      ├── k + 1 [type=int, outer=(3)]
      └── i / 2 [type=decimal, outer=(4), side-effects]

# Join that is nested in another join.
opt expect=PruneJoinRightCols
SELECT a.k, xy.*
FROM xy
INNER JOIN
(
    SELECT * FROM a INNER JOIN xy ON a.k=xy.x
) a
ON a.y < xy.y
----
project
 ├── columns: k:3(int!null) x:1(int!null) y:2(int!null)
 ├── key: (1,3)
 ├── fd: (1)-->(2)
 └── inner-join (hash)
      ├── columns: x:1(int!null) y:2(int!null) k:3(int!null) x:7(int!null) y:8(int!null)
      ├── key: (1,7)
      ├── fd: (1)-->(2), (7)-->(8), (3)==(7), (7)==(3)
      ├── scan xy
      │    ├── columns: x:1(int!null) y:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── inner-join (merge)
      │    ├── columns: k:3(int!null) x:7(int!null) y:8(int)
      │    ├── left ordering: +3
      │    ├── right ordering: +7
      │    ├── key: (7)
      │    ├── fd: (7)-->(8), (3)==(7), (7)==(3)
      │    ├── scan a
      │    │    ├── columns: k:3(int!null)
      │    │    ├── key: (3)
      │    │    └── ordering: +3
      │    ├── scan xy
      │    │    ├── columns: x:7(int!null) y:8(int)
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(8)
      │    │    └── ordering: +7
      │    └── filters (true)
      └── filters
           └── y < y [type=bool, outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# --------------------------------------------------
# PruneJoinLeftCols + PruneJoinRightCols
# --------------------------------------------------

# Columns not needed by either side of join.
opt expect=(PruneJoinLeftCols,PruneJoinRightCols)
SELECT 1 r FROM a,xy
----
project
 ├── columns: r:7(int!null)
 ├── fd: ()-->(7)
 ├── inner-join (hash)
 │    ├── scan a
 │    ├── scan xy
 │    └── filters (true)
 └── projections
      └── const: 1 [type=int]

# Subset of columns needed by each side of join.
opt expect=(PruneJoinLeftCols,PruneJoinRightCols)
SELECT a.k, xy.x, a.k+xy.x AS r FROM a LEFT JOIN xy ON a.k=xy.x
----
project
 ├── columns: k:1(int!null) x:5(int) r:7(int)
 ├── key: (1,5)
 ├── fd: (1,5)-->(7)
 ├── left-join (merge)
 │    ├── columns: k:1(int!null) x:5(int)
 │    ├── left ordering: +1
 │    ├── right ordering: +5
 │    ├── key: (1,5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null)
 │    │    ├── key: (1)
 │    │    └── ordering: +1
 │    ├── scan xy
 │    │    ├── columns: x:5(int!null)
 │    │    ├── key: (5)
 │    │    └── ordering: +5
 │    └── filters (true)
 └── projections
      └── k + x [type=int, outer=(1,5)]

# --------------------------------------------------
# PruneAggCols
# --------------------------------------------------

# Discard all aggregates.
opt expect=PruneAggCols
SELECT s FROM (SELECT s, sum(i), min(s||'foo') FROM a GROUP BY s) a
----
distinct-on
 ├── columns: s:4(string)
 ├── grouping columns: s:4(string)
 ├── key: (4)
 └── scan a
      └── columns: s:4(string)

# Discard subset of aggregates.
opt expect=PruneAggCols
SELECT s, sumi FROM (SELECT sum(i) sumi, s, min(s||'foo') FROM a GROUP BY s) a
----
group-by
 ├── columns: s:4(string) sumi:5(decimal)
 ├── grouping columns: s:4(string)
 ├── key: (4)
 ├── fd: (4)-->(5)
 ├── scan a
 │    └── columns: i:2(int) s:4(string)
 └── aggregations
      └── sum [type=decimal, outer=(2)]
           └── variable: i [type=int]

# No aggregates to discard.
opt expect-not=PruneAggCols
SELECT 1 r FROM (SELECT s FROM a GROUP BY s) a
----
project
 ├── columns: r:5(int!null)
 ├── fd: ()-->(5)
 ├── distinct-on
 │    ├── columns: s:4(string)
 │    ├── grouping columns: s:4(string)
 │    ├── key: (4)
 │    └── scan a
 │         └── columns: s:4(string)
 └── projections
      └── const: 1 [type=int]

# Scalar GroupBy case.
opt expect=PruneAggCols
SELECT sumi FROM (SELECT sum(i) sumi, min(s||'foo') FROM a) a
----
scalar-group-by
 ├── columns: sumi:5(decimal)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5)
 ├── project
 │    ├── columns: column6:6(string) i:2(int)
 │    ├── scan a
 │    │    └── columns: i:2(int) s:4(string)
 │    └── projections
 │         └── s || 'foo' [type=string, outer=(4)]
 └── aggregations
      └── sum [type=decimal, outer=(2)]
           └── variable: i [type=int]

opt expect=PruneAggCols
SELECT f FROM (SELECT DISTINCT ON (i) f, s FROM a)
----
project
 ├── columns: f:3(float)
 └── distinct-on
      ├── columns: i:2(int) f:3(float)
      ├── grouping columns: i:2(int)
      ├── key: (2)
      ├── fd: (2)-->(3)
      ├── scan a
      │    └── columns: i:2(int) f:3(float)
      └── aggregations
           └── first-agg [type=float, outer=(3)]
                └── variable: f [type=float]

# Columns used only by aggregation, no grouping columns.
opt expect=PruneAggCols
SELECT min(i), max(k), max(k) FROM a ORDER BY max(f)
----
scalar-group-by
 ├── columns: min:5(int) max:6(int) max:6(int)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(5,6)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3)
 └── aggregations
      ├── min [type=int, outer=(2)]
      │    └── variable: i [type=int]
      └── max [type=int, outer=(1)]
           └── variable: k [type=int]

# --------------------------------------------------
# PruneGroupByCols
# --------------------------------------------------

# Columns used by grouping or aggregation, but not both should not be pruned.
opt expect=PruneGroupByCols
SELECT s, sum(i) FROM a GROUP BY s, s||'foo'
----
group-by
 ├── columns: s:4(string) sum:5(decimal)
 ├── grouping columns: s:4(string)
 ├── key: (4)
 ├── fd: (4)-->(5)
 ├── scan a
 │    └── columns: i:2(int) s:4(string)
 └── aggregations
      └── sum [type=decimal, outer=(2)]
           └── variable: i [type=int]

# Columns used by both grouping and aggregation should not be pruned.
opt expect=PruneGroupByCols
SELECT avg(s::int+i), s, i FROM a GROUP BY s, i, i+1
----
group-by
 ├── columns: avg:6(decimal) s:4(string) i:2(int)
 ├── grouping columns: i:2(int) s:4(string)
 ├── key: (2,4)
 ├── fd: (2,4)-->(6)
 ├── project
 │    ├── columns: column5:5(int) i:2(int) s:4(string)
 │    ├── fd: (2,4)-->(5)
 │    ├── scan a
 │    │    └── columns: i:2(int) s:4(string)
 │    └── projections
 │         └── i + s::INT8 [type=int, outer=(2,4)]
 └── aggregations
      └── avg [type=decimal, outer=(5)]
           └── variable: column5 [type=int]

# Columns used only by groupings, no aggregation columns.
opt expect=PruneGroupByCols
SELECT s, i+1 AS r FROM a GROUP BY i, s, s||'foo'
----
project
 ├── columns: s:4(string) r:6(int)
 ├── distinct-on
 │    ├── columns: i:2(int) s:4(string)
 │    ├── grouping columns: i:2(int) s:4(string)
 │    ├── key: (2,4)
 │    └── scan a
 │         └── columns: i:2(int) s:4(string)
 └── projections
      └── i + 1 [type=int, outer=(2)]

# Groupby a groupby.
opt expect=PruneGroupByCols
SELECT min(sm), i FROM (SELECT s, i, sum(k) sm, avg(k) av FROM a GROUP BY i, s) a GROUP BY i, i+1
----
group-by
 ├── columns: min:7(decimal) i:2(int)
 ├── grouping columns: i:2(int)
 ├── key: (2)
 ├── fd: (2)-->(7)
 ├── group-by
 │    ├── columns: i:2(int) s:4(string) sum:5(decimal)
 │    ├── grouping columns: i:2(int) s:4(string)
 │    ├── key: (2,4)
 │    ├── fd: (2,4)-->(5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2,4)
 │    └── aggregations
 │         └── sum [type=decimal, outer=(1)]
 │              └── variable: k [type=int]
 └── aggregations
      └── min [type=decimal, outer=(5)]
           └── variable: sum [type=decimal]

# Distinct (GroupBy operator with no aggregates).
opt expect=PruneGroupByCols
SELECT DISTINCT ON (s, s||'foo') s, f FROM a
----
distinct-on
 ├── columns: s:4(string) f:3(float)
 ├── grouping columns: s:4(string)
 ├── key: (4)
 ├── fd: (4)-->(3)
 ├── scan a
 │    └── columns: f:3(float) s:4(string)
 └── aggregations
      └── first-agg [type=float, outer=(3)]
           └── variable: f [type=float]

# --------------------------------------------------
# PruneValuesCols
# --------------------------------------------------

# Discard all but first Values column.
opt expect=PruneValuesCols
SELECT column1 FROM (VALUES (1, 2), (3, 4)) a
----
values
 ├── columns: column1:1(int!null)
 ├── cardinality: [2 - 2]
 ├── (1,) [type=tuple{int}]
 └── (3,) [type=tuple{int}]

# Discard all but middle Values column.
opt expect=PruneValuesCols
SELECT column2 FROM (VALUES (1, 2, 3), (4, 5, 6)) a
----
values
 ├── columns: column2:2(int!null)
 ├── cardinality: [2 - 2]
 ├── (2,) [type=tuple{int}]
 └── (5,) [type=tuple{int}]

# Discard all but last Values column.
opt expect=PruneValuesCols
SELECT column3 FROM (VALUES ('foo', 'bar', 'baz'), ('apple', 'banana', 'cherry')) a
----
values
 ├── columns: column3:3(string!null)
 ├── cardinality: [2 - 2]
 ├── ('baz',) [type=tuple{string}]
 └── ('cherry',) [type=tuple{string}]

# Discard all Values columns.
opt expect=PruneValuesCols
SELECT 1 r FROM (VALUES ('foo', 'bar', 'baz'), ('apple', 'banana', 'cherry')) a
----
project
 ├── columns: r:4(int!null)
 ├── cardinality: [2 - 2]
 ├── fd: ()-->(4)
 ├── values
 │    ├── cardinality: [2 - 2]
 │    ├── tuple [type=tuple]
 │    └── tuple [type=tuple]
 └── projections
      └── const: 1 [type=int]

# --------------------------------------------------
# Prune - multiple combined operators
# --------------------------------------------------

opt
SELECT a.k, xy.y FROM a INNER JOIN xy ON a.k=xy.x WHERE a.i < 5
----
project
 ├── columns: k:1(int!null) y:6(int)
 ├── key: (1)
 ├── fd: (1)-->(6)
 └── inner-join (merge)
      ├── columns: k:1(int!null) i:2(int!null) x:5(int!null) y:6(int)
      ├── left ordering: +1
      ├── right ordering: +5
      ├── key: (5)
      ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
      ├── select
      │    ├── columns: k:1(int!null) i:2(int!null)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── ordering: +1
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    └── ordering: +1
      │    └── filters
      │         └── i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      ├── scan xy
      │    ├── columns: x:5(int!null) y:6(int)
      │    ├── key: (5)
      │    ├── fd: (5)-->(6)
      │    └── ordering: +5
      └── filters (true)

opt
SELECT k FROM (SELECT k, min(s) FROM a GROUP BY k HAVING sum(i) > 5)
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) sum:6(decimal!null)
      ├── key: (1)
      ├── fd: (1)-->(6)
      ├── group-by
      │    ├── columns: k:1(int!null) sum:6(decimal)
      │    ├── grouping columns: k:1(int!null)
      │    ├── internal-ordering: +1
      │    ├── key: (1)
      │    ├── fd: (1)-->(6)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    └── ordering: +1
      │    └── aggregations
      │         └── sum [type=decimal, outer=(2)]
      │              └── variable: i [type=int]
      └── filters
           └── sum > 5 [type=bool, outer=(6), constraints=(/6: (/5 - ]; tight)]

# --------------------------------------------------
# PruneOrdinalityCols
# --------------------------------------------------
opt expect=PruneOrdinalityCols
SELECT i, s FROM a WITH ORDINALITY
----
project
 ├── columns: i:2(int) s:4(string)
 └── ordinality
      ├── columns: i:2(int) s:4(string) ordinality:5(int!null)
      ├── key: (5)
      ├── fd: (5)-->(2,4)
      └── scan a
           └── columns: i:2(int) s:4(string)

# With order by.
opt expect=PruneOrdinalityCols
SELECT i, s FROM (SELECT * FROM a ORDER BY f) WITH ORDINALITY
----
project
 ├── columns: i:2(int) s:4(string)
 └── ordinality
      ├── columns: i:2(int) f:3(float) s:4(string) ordinality:5(int!null)
      ├── key: (5)
      ├── fd: (5)-->(2-4)
      └── sort
           ├── columns: i:2(int) f:3(float) s:4(string)
           ├── ordering: +3
           └── scan a
                └── columns: i:2(int) f:3(float) s:4(string)

# --------------------------------------------------
# PruneExplainCols
# --------------------------------------------------
opt expect=PruneExplainCols
EXPLAIN SELECT a FROM abcde WHERE b=1 AND c IS NOT NULL ORDER BY c, d
----
explain
 ├── columns: tree:6(string) field:7(string) description:8(string)
 └── project
      ├── columns: a:1(int!null)  [hidden: c:3(int!null)]
      ├── key: (1)
      ├── fd: (1)-->(3), (3)-->(1)
      ├── ordering: +3
      └── scan abcde@bc
           ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
           ├── constraint: /2/3: (/1/NULL - /1]
           ├── key: (1)
           ├── fd: ()-->(2), (1)-->(3), (3)-->(1)
           └── ordering: +3 opt(2) [actual: +3]

# --------------------------------------------------
# PruneProjectSetCols
# --------------------------------------------------
opt expect=PruneProjectSetCols
SELECT a, b, generate_series(c, 10) FROM abcde
----
project
 ├── columns: a:1(int!null) b:2(int) generate_series:6(int)
 ├── side-effects
 ├── fd: (1)-->(2)
 └── project-set
      ├── columns: a:1(int!null) b:2(int) c:3(int) generate_series:6(int)
      ├── side-effects
      ├── fd: (1)-->(2,3), (2,3)~~>(1)
      ├── scan abcde@bc
      │    ├── columns: a:1(int!null) b:2(int) c:3(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (2,3)~~>(1)
      └── zip
           └── function: generate_series [type=int, outer=(3), side-effects]
                ├── variable: c [type=int]
                └── const: 10 [type=int]

opt expect=PruneProjectSetCols
SELECT k FROM a WHERE EXISTS(SELECT * FROM ROWS FROM (generate_series(i, k), length(s)))
----
distinct-on
 ├── columns: k:1(int!null)
 ├── grouping columns: k:1(int!null)
 ├── side-effects
 ├── key: (1)
 └── project-set
      ├── columns: k:1(int!null) i:2(int) s:4(string) generate_series:5(int) length:6(int)
      ├── side-effects
      ├── fd: (1)-->(2,4)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int) s:4(string)
      │    ├── key: (1)
      │    └── fd: (1)-->(2,4)
      └── zip
           ├── function: generate_series [type=int, outer=(1,2), side-effects]
           │    ├── variable: i [type=int]
           │    └── variable: k [type=int]
           └── function: length [type=int, outer=(4)]
                └── variable: s [type=string]

# --------------------------------------------------
# PruneWindowInputCols
# --------------------------------------------------

norm expect=PruneWindowInputCols
SELECT rank() OVER () FROM a
----
window partition=()
 ├── columns: rank:5(int)
 ├── scan a
 └── windows
      └── rank [type=int]

norm expect=PruneWindowInputCols
SELECT ntile(1) OVER () FROM a
----
project
 ├── columns: ntile:5(int)
 └── window partition=()
      ├── columns: ntile:5(int) ntile_1_arg1:6(int!null)
      ├── fd: ()-->(6)
      ├── project
      │    ├── columns: ntile_1_arg1:6(int!null)
      │    ├── fd: ()-->(6)
      │    ├── scan a
      │    └── projections
      │         └── const: 1 [type=int]
      └── windows
           └── ntile [type=int, outer=(6)]
                └── variable: ntile_1_arg1 [type=int]

norm expect=PruneWindowInputCols format=show-all
SELECT ntile(i) OVER () FROM a
----
project
 ├── columns: ntile:5(int)
 ├── stats: [rows=1000]
 ├── cost: 1060.04
 ├── prune: (5)
 └── window partition=()
      ├── columns: t.public.a.i:2(int) ntile:5(int)
      ├── stats: [rows=1000]
      ├── cost: 1050.03
      ├── prune: (5)
      ├── scan t.public.a
      │    ├── columns: t.public.a.i:2(int)
      │    ├── stats: [rows=1000]
      │    ├── cost: 1050.02
      │    └── prune: (2)
      └── windows
           └── ntile [type=int, outer=(2)]
                └── variable: t.public.a.i [type=int]

# Ensure filter cols don't get pruned.
norm
SELECT
    avg(i) FILTER (WHERE true) OVER (),
    avg(i) FILTER (WHERE false) OVER ()
FROM a
----
project
 ├── columns: avg:5(decimal) avg:6(decimal)
 └── window partition=()
      ├── columns: i:2(int) avg:5(decimal) avg:6(decimal) avg_1_filter:7(bool!null) avg_2_filter:8(bool!null)
      ├── fd: ()-->(7,8)
      ├── project
      │    ├── columns: avg_1_filter:7(bool!null) avg_2_filter:8(bool!null) i:2(int)
      │    ├── fd: ()-->(7,8)
      │    ├── scan a
      │    │    └── columns: i:2(int)
      │    └── projections
      │         ├── true [type=bool]
      │         └── false [type=bool]
      └── windows
           ├── agg-filter [type=decimal, outer=(2,7)]
           │    ├── avg [type=decimal]
           │    │    └── variable: i [type=int]
           │    └── variable: avg_1_filter [type=bool]
           └── agg-filter [type=decimal, outer=(2,8)]
                ├── avg [type=decimal]
                │    └── variable: i [type=int]
                └── variable: avg_2_filter [type=bool]

# --------------------------------------------------
# PruneWindowOutputCols
# --------------------------------------------------

norm expect=PruneWindowOutputCols
SELECT x FROM (SELECT ntile(1) OVER () AS x, ntile(2) OVER () FROM a)
----
project
 ├── columns: x:5(int)
 └── window partition=()
      ├── columns: ntile:5(int) ntile_1_arg1:7(int!null)
      ├── fd: ()-->(7)
      ├── project
      │    ├── columns: ntile_1_arg1:7(int!null)
      │    ├── fd: ()-->(7)
      │    ├── scan a
      │    └── projections
      │         └── const: 1 [type=int]
      └── windows
           └── ntile [type=int, outer=(7)]
                └── variable: ntile_1_arg1 [type=int]

norm expect=(PruneWindowOutputCols,EliminateWindow)
SELECT 1 FROM (SELECT ntile(1) OVER () FROM a)
----
project
 ├── columns: "?column?":7(int!null)
 ├── fd: ()-->(7)
 ├── scan a
 └── projections
      └── const: 1 [type=int]

norm expect=(PruneWindowOutputCols,EliminateWindow)
SELECT 1 FROM (SELECT x FROM (SELECT ntile(1) OVER () AS x, ntile(2) OVER () FROM a))
----
project
 ├── columns: "?column?":9(int!null)
 ├── fd: ()-->(9)
 ├── scan a
 └── projections
      └── const: 1 [type=int]

norm expect-not=PruneWindowOutputCols
SELECT round(avg(k) OVER (PARTITION BY f ORDER BY s)) FROM a ORDER BY 1
----
sort
 ├── columns: round:6(decimal)
 ├── ordering: +6
 └── project
      ├── columns: round:6(decimal)
      ├── window partition=(3) ordering=+4 opt(3)
      │    ├── columns: k:1(int!null) f:3(float) s:4(string) avg:5(decimal)
      │    ├── key: (1)
      │    ├── fd: (1)-->(3,4)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) f:3(float) s:4(string)
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(3,4)
      │    └── windows
      │         └── avg [type=decimal, outer=(1)]
      │              └── variable: k [type=int]
      └── projections
           └── round(avg) [type=decimal, outer=(5)]

norm expect=(PruneWindowInputCols,PruneWindowOutputCols) format=show-all
SELECT x FROM (SELECT ntile(i) OVER () x, ntile(f::int) OVER () y FROM a)
----
project
 ├── columns: x:5(int)
 ├── stats: [rows=1000]
 ├── cost: 1060.04
 ├── prune: (5)
 └── window partition=()
      ├── columns: t.public.a.i:2(int) ntile:5(int)
      ├── stats: [rows=1000]
      ├── cost: 1050.03
      ├── prune: (5)
      ├── scan t.public.a
      │    ├── columns: t.public.a.i:2(int)
      │    ├── stats: [rows=1000]
      │    ├── cost: 1050.02
      │    └── prune: (2)
      └── windows
           └── ntile [type=int, outer=(2)]
                └── variable: t.public.a.i [type=int]


# --------------------------------------------------
# PruneMutationFetchCols + PruneMutationInputCols
# --------------------------------------------------

# Prune all but the key column.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
DELETE FROM a
----
delete a
 ├── columns: <none>
 ├── fetch columns: k:5(int)
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── scan a
      ├── columns: k:5(int!null)
      └── key: (5)

# Prune when computed ordering column is present.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
DELETE FROM a WHERE i > 0 ORDER BY i*2 LIMIT 10
----
delete a
 ├── columns: <none>
 ├── fetch columns: k:5(int)
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── limit
      ├── columns: k:5(int!null) column9:9(int)
      ├── internal-ordering: +9
      ├── cardinality: [0 - 10]
      ├── key: (5)
      ├── fd: (5)-->(9)
      ├── sort
      │    ├── columns: k:5(int!null) column9:9(int)
      │    ├── key: (5)
      │    ├── fd: (5)-->(9)
      │    ├── ordering: +9
      │    └── project
      │         ├── columns: column9:9(int) k:5(int!null)
      │         ├── key: (5)
      │         ├── fd: (5)-->(9)
      │         ├── select
      │         │    ├── columns: k:5(int!null) i:6(int!null)
      │         │    ├── key: (5)
      │         │    ├── fd: (5)-->(6)
      │         │    ├── scan a
      │         │    │    ├── columns: k:5(int!null) i:6(int)
      │         │    │    ├── key: (5)
      │         │    │    └── fd: (5)-->(6)
      │         │    └── filters
      │         │         └── i > 0 [type=bool, outer=(6), constraints=(/6: [/1 - ]; tight)]
      │         └── projections
      │              └── i * 2 [type=int, outer=(6)]
      └── const: 10 [type=int]

# Prune when a secondary index is present on the table.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
DELETE FROM abcde WHERE a > 0
----
delete abcde
 ├── columns: <none>
 ├── fetch columns: a:6(int) b:7(int) c:8(int)
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── scan abcde
      ├── columns: a:6(int!null) b:7(int) c:8(int)
      ├── constraint: /6: [/1 - ]
      ├── key: (6)
      └── fd: (6)-->(7,8), (7,8)~~>(6)

# Prune when mutation columns/indexes exist.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
DELETE FROM mutation
----
delete mutation
 ├── columns: <none>
 ├── fetch columns: a:6(int) b:7(int) d:9(int) e:10(int)
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── scan mutation
      ├── columns: a:6(int!null) b:7(int) d:9(int) e:10(int)
      ├── key: (6)
      └── fd: (6)-->(7,9,10)

opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
DELETE FROM a RETURNING k, s
----
delete a
 ├── columns: k:1(int!null) s:4(string)
 ├── fetch columns: k:5(int) s:8(string)
 ├── side-effects, mutations
 ├── key: (1)
 ├── fd: (1)-->(4)
 └── scan a
      ├── columns: k:5(int!null) s:8(string)
      ├── key: (5)
      └── fd: (5)-->(8)

# Prune secondary family column not needed for the update.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
UPDATE family SET b=c WHERE a > 100
----
update "family"
 ├── columns: <none>
 ├── fetch columns: a:6(int) b:7(int)
 ├── update-mapping:
 │    └──  c:8 => b:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── scan "family"
      ├── columns: a:6(int!null) b:7(int) c:8(int)
      ├── constraint: /6: [/101 - ]
      ├── key: (6)
      └── fd: (6)-->(7,8)

# Do not prune when key column is updated.
opt expect-not=(PruneMutationFetchCols,PruneMutationInputCols)
UPDATE family SET a=a+1 WHERE a > 100
----
update "family"
 ├── columns: <none>
 ├── fetch columns: a:6(int) b:7(int) c:8(int) d:9(int) e:10(int)
 ├── update-mapping:
 │    └──  column11:11 => a:1
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: column11:11(int) a:6(int!null) b:7(int) c:8(int) d:9(int) e:10(int)
      ├── key: (6)
      ├── fd: (6)-->(7-11)
      ├── scan "family"
      │    ├── columns: a:6(int!null) b:7(int) c:8(int) d:9(int) e:10(int)
      │    ├── constraint: /6: [/101 - ]
      │    ├── key: (6)
      │    └── fd: (6)-->(7-10)
      └── projections
           └── a + 1 [type=int, outer=(6)]

# Do not prune columns that must be returned.
opt expect=(PruneMutationFetchCols, PruneMutationReturnCols)
UPDATE family SET c=c+1 RETURNING b
----
project
 ├── columns: b:2(int)
 ├── side-effects, mutations
 └── update "family"
      ├── columns: a:1(int!null) b:2(int)
      ├── fetch columns: a:6(int) b:7(int) c:8(int) d:9(int)
      ├── update-mapping:
      │    └──  column11:11 => c:3
      ├── side-effects, mutations
      ├── key: (1)
      ├── fd: (1)-->(2)
      └── project
           ├── columns: column11:11(int) a:6(int!null) b:7(int) c:8(int) d:9(int)
           ├── key: (6)
           ├── fd: (6)-->(7-9), (8)-->(11)
           ├── scan "family"
           │    ├── columns: a:6(int!null) b:7(int) c:8(int) d:9(int)
           │    ├── key: (6)
           │    └── fd: (6)-->(7-9)
           └── projections
                └── c + 1 [type=int, outer=(8)]

# Prune unused upsert columns.
opt expect=PruneMutationInputCols
INSERT INTO a (k, s) VALUES (1, 'foo') ON CONFLICT (k) DO UPDATE SET i=a.i+1
----
upsert a
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: k:9(int) i:10(int) f:11(float) s:12(string)
 ├── insert-mapping:
 │    ├──  column1:5 => k:1
 │    ├──  column7:7 => i:2
 │    ├──  column8:8 => f:3
 │    └──  column2:6 => s:4
 ├── update-mapping:
 │    └──  upsert_i:15 => i:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_i:15(int) column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float) k:9(int) i:10(int) f:11(float) s:12(string)
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(5-12,15)
      ├── left-join (hash)
      │    ├── columns: column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float) k:9(int) i:10(int) f:11(float) s:12(string)
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(5-12)
      │    ├── values
      │    │    ├── columns: column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(5-8)
      │    │    └── (1, 'foo', NULL, NULL) [type=tuple{int, string, int, float}]
      │    ├── scan a
      │    │    ├── columns: k:9(int!null) i:10(int) f:11(float) s:12(string)
      │    │    ├── constraint: /9: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(9-12)
      │    └── filters (true)
      └── projections
           └── CASE WHEN k IS NULL THEN column7 ELSE i + 1 END [type=int, outer=(7,9,10)]

# Prune update columns replaced by upsert columns.
# TODO(andyk): Need to also prune output columns.
opt expect=PruneMutationInputCols expect-not=PruneMutationFetchCols
INSERT INTO a (k, s) VALUES (1, 'foo') ON CONFLICT (k) DO UPDATE SET i=a.i+1 RETURNING *
----
upsert a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string)
 ├── canary column: 9
 ├── fetch columns: k:9(int) i:10(int) f:11(float) s:12(string)
 ├── insert-mapping:
 │    ├──  column1:5 => k:1
 │    ├──  column7:7 => i:2
 │    ├──  column8:8 => f:3
 │    └──  column2:6 => s:4
 ├── update-mapping:
 │    └──  upsert_i:15 => i:2
 ├── return-mapping:
 │    ├──  upsert_k:14 => k:1
 │    ├──  upsert_i:15 => i:2
 │    ├──  upsert_f:16 => f:3
 │    └──  upsert_s:17 => s:4
 ├── cardinality: [1 - 1]
 ├── side-effects, mutations
 ├── key: ()
 ├── fd: ()-->(1-4)
 └── project
      ├── columns: upsert_k:14(int) upsert_i:15(int) upsert_f:16(float) upsert_s:17(string) column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float) k:9(int) i:10(int) f:11(float) s:12(string)
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(5-12,14-17)
      ├── left-join (hash)
      │    ├── columns: column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float) k:9(int) i:10(int) f:11(float) s:12(string)
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(5-12)
      │    ├── values
      │    │    ├── columns: column1:5(int!null) column2:6(string!null) column7:7(int) column8:8(float)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(5-8)
      │    │    └── (1, 'foo', NULL, NULL) [type=tuple{int, string, int, float}]
      │    ├── scan a
      │    │    ├── columns: k:9(int!null) i:10(int) f:11(float) s:12(string)
      │    │    ├── constraint: /9: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(9-12)
      │    └── filters (true)
      └── projections
           ├── CASE WHEN k IS NULL THEN column1 ELSE k END [type=int, outer=(5,9)]
           ├── CASE WHEN k IS NULL THEN column7 ELSE i + 1 END [type=int, outer=(7,9,10)]
           ├── CASE WHEN k IS NULL THEN column8 ELSE f END [type=float, outer=(8,9,11)]
           └── CASE WHEN k IS NULL THEN column2 ELSE s END [type=string, outer=(6,9,12)]

# Prune column in column family that is not updated.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
UPSERT INTO family (a, b) VALUES (1, 2)
----
upsert "family"
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: a:9(int) b:10(int)
 ├── insert-mapping:
 │    ├──  column1:6 => a:1
 │    ├──  column2:7 => b:2
 │    ├──  column8:8 => c:3
 │    ├──  column8:8 => d:4
 │    └──  column8:8 => e:5
 ├── update-mapping:
 │    └──  column2:7 => b:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── left-join (hash)
      ├── columns: column1:6(int!null) column2:7(int!null) column8:8(int) a:9(int) b:10(int)
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-10)
      ├── values
      │    ├── columns: column1:6(int!null) column2:7(int!null) column8:8(int)
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    └── (1, 2, NULL) [type=tuple{int, int, int}]
      ├── scan "family"
      │    ├── columns: a:9(int!null) b:10(int)
      │    ├── constraint: /9: [/1 - /1]
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    └── fd: ()-->(9,10)
      └── filters (true)

opt
INSERT INTO family VALUES (1, 2, 3, 4, 5) ON CONFLICT (a) DO UPDATE SET c = 10 RETURNING e
----
project
 ├── columns: e:5(int)
 ├── cardinality: [1 - 1]
 ├── side-effects, mutations
 ├── key: ()
 ├── fd: ()-->(5)
 └── upsert "family"
      ├── columns: a:1(int!null) e:5(int)
      ├── canary column: 11
      ├── fetch columns: a:11(int) c:13(int) d:14(int) e:15(int)
      ├── insert-mapping:
      │    ├──  column1:6 => a:1
      │    ├──  column2:7 => b:2
      │    ├──  column3:8 => c:3
      │    ├──  column4:9 => d:4
      │    └──  column5:10 => e:5
      ├── update-mapping:
      │    └──  upsert_c:19 => c:3
      ├── return-mapping:
      │    ├──  upsert_a:17 => a:1
      │    └──  upsert_e:21 => e:5
      ├── cardinality: [1 - 1]
      ├── side-effects, mutations
      ├── key: ()
      ├── fd: ()-->(1,5)
      └── project
           ├── columns: upsert_a:17(int) upsert_c:19(int) upsert_e:21(int) column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column5:10(int!null) a:11(int) c:13(int) d:14(int) e:15(int)
           ├── cardinality: [1 - 1]
           ├── key: ()
           ├── fd: ()-->(6-11,13-15,17,19,21)
           ├── left-join (hash)
           │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column5:10(int!null) a:11(int) c:13(int) d:14(int) e:15(int)
           │    ├── cardinality: [1 - 1]
           │    ├── key: ()
           │    ├── fd: ()-->(6-11,13-15)
           │    ├── values
           │    │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column5:10(int!null)
           │    │    ├── cardinality: [1 - 1]
           │    │    ├── key: ()
           │    │    ├── fd: ()-->(6-10)
           │    │    └── (1, 2, 3, 4, 5) [type=tuple{int, int, int, int, int}]
           │    ├── scan "family"
           │    │    ├── columns: a:11(int!null) c:13(int) d:14(int) e:15(int)
           │    │    ├── constraint: /11: [/1 - /1]
           │    │    ├── cardinality: [0 - 1]
           │    │    ├── key: ()
           │    │    └── fd: ()-->(11,13-15)
           │    └── filters (true)
           └── projections
                ├── CASE WHEN a IS NULL THEN column1 ELSE a END [type=int, outer=(6,11)]
                ├── CASE WHEN a IS NULL THEN column3 ELSE 10 END [type=int, outer=(8,11)]
                └── CASE WHEN a IS NULL THEN column5 ELSE e END [type=int, outer=(10,11,15)]

# Do not prune column in same secondary family as updated column. But prune
# non-key column in primary family.
opt expect=(PruneMutationFetchCols,PruneMutationInputCols)
INSERT INTO family VALUES (1, 2, 3, 4) ON CONFLICT (a) DO UPDATE SET d=10
----
upsert "family"
 ├── columns: <none>
 ├── canary column: 11
 ├── fetch columns: a:11(int) c:13(int) d:14(int)
 ├── insert-mapping:
 │    ├──  column1:6 => a:1
 │    ├──  column2:7 => b:2
 │    ├──  column3:8 => c:3
 │    ├──  column4:9 => d:4
 │    └──  column10:10 => e:5
 ├── update-mapping:
 │    └──  upsert_d:20 => d:4
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_d:20(int) column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column10:10(int) a:11(int) c:13(int) d:14(int)
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-11,13,14,20)
      ├── left-join (hash)
      │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column10:10(int) a:11(int) c:13(int) d:14(int)
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6-11,13,14)
      │    ├── values
      │    │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column4:9(int!null) column10:10(int)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6-10)
      │    │    └── (1, 2, 3, 4, NULL) [type=tuple{int, int, int, int, int}]
      │    ├── scan "family"
      │    │    ├── columns: a:11(int!null) c:13(int) d:14(int)
      │    │    ├── constraint: /11: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(11,13,14)
      │    └── filters (true)
      └── projections
           └── CASE WHEN a IS NULL THEN column4 ELSE 10 END [type=int, outer=(9,11)]

# Prune upsert columns when mutation columns/indexes exist.
opt expect=(PruneMutationInputCols)
INSERT INTO mutation VALUES (1, 2, 3) ON CONFLICT (a) DO UPDATE SET b=10
----
upsert mutation
 ├── columns: <none>
 ├── canary column: 10
 ├── fetch columns: a:10(int) b:11(int) c:12(int) d:13(int) e:14(int)
 ├── insert-mapping:
 │    ├──  column1:6 => a:1
 │    ├──  column2:7 => b:2
 │    ├──  column3:8 => c:3
 │    └──  column9:9 => d:4
 ├── update-mapping:
 │    └──  upsert_b:17 => b:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_b:17(int) column1:6(int!null) column2:7(int!null) column3:8(int!null) column9:9(int) a:10(int) b:11(int) c:12(int) d:13(int) e:14(int)
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-14,17)
      ├── left-join (hash)
      │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column9:9(int) a:10(int) b:11(int) c:12(int) d:13(int) e:14(int)
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6-14)
      │    ├── values
      │    │    ├── columns: column1:6(int!null) column2:7(int!null) column3:8(int!null) column9:9(int)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6-9)
      │    │    └── (1, 2, 3, NULL) [type=tuple{int, int, int, int}]
      │    ├── scan mutation
      │    │    ├── columns: a:10(int!null) b:11(int) c:12(int) d:13(int) e:14(int)
      │    │    ├── constraint: /10: [/1 - /1]
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    └── fd: ()-->(10-14)
      │    └── filters (true)
      └── projections
           └── CASE WHEN a IS NULL THEN column2 ELSE 10 END [type=int, outer=(7,10)]

# ------------------------------------------------------------------------------
# PruneMutationReturnCols
# ------------------------------------------------------------------------------

# Create a table with multiple column families the mutations can take advantage of.
exec-ddl
CREATE TABLE returning_test (
    a INT,
    b INT,
    c STRING,
    d INT,
    e INT,
    f INT,
    g INT,
    FAMILY (a),
    FAMILY (b),
    FAMILY (c),
    FAMILY (d, e, f, g),
    UNIQUE (a)
)
----

# Fetch all the columns for the RETURN expression.
opt
UPDATE returning_test SET a = a + 1 RETURNING *
----
project
 ├── columns: a:1(int) b:2(int) c:3(string) d:4(int) e:5(int) f:6(int) g:7(int)
 ├── side-effects, mutations
 └── update returning_test
      ├── columns: a:1(int) b:2(int) c:3(string) d:4(int) e:5(int) f:6(int) g:7(int) rowid:8(int!null)
      ├── fetch columns: a:9(int) b:10(int) c:11(string) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int)
      ├── update-mapping:
      │    └──  column17:17 => a:1
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1-7)
      └── project
           ├── columns: column17:17(int) a:9(int) b:10(int) c:11(string) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9-15), (9)~~>(10-16), (9)-->(17)
           ├── scan returning_test
           │    ├── columns: a:9(int) b:10(int) c:11(string) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9-15), (9)~~>(10-16)
           └── projections
                └── a + 1 [type=int, outer=(9)]


# Fetch all the columns in the (d, e, f, g) family as d is being set.
opt
UPDATE returning_test SET d = a + d RETURNING a, d
----
project
 ├── columns: a:1(int) d:4(int)
 ├── side-effects, mutations
 ├── lax-key: (1,4)
 ├── fd: (1)~~>(4)
 └── update returning_test
      ├── columns: a:1(int) d:4(int) rowid:8(int!null)
      ├── fetch columns: a:9(int) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int)
      ├── update-mapping:
      │    └──  column17:17 => d:4
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1,4), (1)~~>(4,8)
      └── project
           ├── columns: column17:17(int) a:9(int) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9,12-15), (9)~~>(12-16), (9,12)-->(17)
           ├── scan returning_test
           │    ├── columns: a:9(int) d:12(int) e:13(int) f:14(int) g:15(int) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9,12-15), (9)~~>(12-16)
           └── projections
                └── a + d [type=int, outer=(9,12)]

# Fetch only whats being updated (not the (d, e, f, g) family).
opt
UPDATE returning_test SET a = a + d RETURNING a
----
project
 ├── columns: a:1(int)
 ├── side-effects, mutations
 └── update returning_test
      ├── columns: a:1(int) rowid:8(int!null)
      ├── fetch columns: a:9(int) rowid:16(int)
      ├── update-mapping:
      │    └──  column17:17 => a:1
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1)
      └── project
           ├── columns: column17:17(int) a:9(int) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9,17), (9)~~>(16,17)
           ├── scan returning_test
           │    ├── columns: a:9(int) d:12(int) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9,12), (9)~~>(12,16)
           └── projections
                └── a + d [type=int, outer=(9,12)]

# We only fetch the minimal set of columns which is (a, b, c, rowid).
opt
UPDATE returning_test SET (b, a) = (a, a + b) RETURNING a, b, c
----
project
 ├── columns: a:1(int) b:2(int) c:3(string)
 ├── side-effects, mutations
 ├── lax-key: (1-3)
 ├── fd: (2)~~>(1,3)
 └── update returning_test
      ├── columns: a:1(int) b:2(int) c:3(string) rowid:8(int!null)
      ├── fetch columns: a:9(int) b:10(int) c:11(string) rowid:16(int)
      ├── update-mapping:
      │    ├──  column17:17 => a:1
      │    └──  a:9 => b:2
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1-3), (2)~~>(1,3,8)
      └── project
           ├── columns: column17:17(int) a:9(int) b:10(int) c:11(string) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9-11), (9)~~>(10,11,16), (9,10)-->(17)
           ├── scan returning_test
           │    ├── columns: a:9(int) b:10(int) c:11(string) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9-11), (9)~~>(10,11,16)
           └── projections
                └── a + b [type=int, outer=(9,10)]


# We apply the PruneMutationReturnCols rule multiple times, to get
# the minimal set of columns which is (a, rowid). Notice how c and b
# are pruned away.
opt
SELECT a FROM [SELECT a, b FROM [UPDATE returning_test SET a = a + 1 RETURNING a, b, c]]
----
project
 ├── columns: a:1(int)
 ├── side-effects, mutations
 └── update returning_test
      ├── columns: a:1(int) rowid:8(int!null)
      ├── fetch columns: a:9(int) rowid:16(int)
      ├── update-mapping:
      │    └──  column17:17 => a:1
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1)
      └── project
           ├── columns: column17:17(int) a:9(int) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9), (9)~~>(16), (9)-->(17)
           ├── scan returning_test@secondary
           │    ├── columns: a:9(int) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9), (9)~~>(16)
           └── projections
                └── a + 1 [type=int, outer=(9)]

# We derive the prune cols for the mutation appropriately so we
# can prune away columns even when the mutation is not under a
# projection. Another rule will fire to add the appropriate
# projection when this happens.
opt
SELECT a FROM [SELECT a, b FROM [UPDATE returning_test SET a = a + 1 RETURNING a, b, c] WHERE a > 1]
----
project
 ├── columns: a:1(int!null)
 ├── side-effects, mutations
 └── select
      ├── columns: a:1(int!null) rowid:8(int!null)
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1)
      ├── update returning_test
      │    ├── columns: a:1(int) rowid:8(int!null)
      │    ├── fetch columns: a:9(int) rowid:16(int)
      │    ├── update-mapping:
      │    │    └──  column17:17 => a:1
      │    ├── side-effects, mutations
      │    ├── key: (8)
      │    ├── fd: (8)-->(1)
      │    └── project
      │         ├── columns: column17:17(int) a:9(int) rowid:16(int!null)
      │         ├── key: (16)
      │         ├── fd: (16)-->(9), (9)~~>(16), (9)-->(17)
      │         ├── scan returning_test@secondary
      │         │    ├── columns: a:9(int) rowid:16(int!null)
      │         │    ├── key: (16)
      │         │    └── fd: (16)-->(9), (9)~~>(16)
      │         └── projections
      │              └── a + 1 [type=int, outer=(9)]
      └── filters
           └── a > 1 [type=bool, outer=(1), constraints=(/1: [/2 - ]; tight)]

opt
SELECT
    *
FROM
    [SELECT a, b FROM returning_test] AS x
    JOIN [SELECT a, b FROM [UPDATE returning_test SET a = a + 1 RETURNING a, b, c] WHERE a > 1]
            AS y ON true
----
project
 ├── columns: a:1(int) b:2(int) a:9(int!null) b:10(int)
 ├── side-effects, mutations
 ├── fd: (1)~~>(2)
 └── inner-join (hash)
      ├── columns: x.a:1(int) x.b:2(int) returning_test.a:9(int!null) returning_test.b:10(int) returning_test.rowid:16(int!null)
      ├── side-effects, mutations
      ├── lax-key: (1,2,16)
      ├── fd: (1)~~>(2), (16)-->(9,10)
      ├── scan x
      │    ├── columns: x.a:1(int) x.b:2(int)
      │    ├── lax-key: (1,2)
      │    └── fd: (1)~~>(2)
      ├── select
      │    ├── columns: returning_test.a:9(int!null) returning_test.b:10(int) returning_test.rowid:16(int!null)
      │    ├── side-effects, mutations
      │    ├── key: (16)
      │    ├── fd: (16)-->(9,10)
      │    ├── update returning_test
      │    │    ├── columns: returning_test.a:9(int) returning_test.b:10(int) returning_test.rowid:16(int!null)
      │    │    ├── fetch columns: returning_test.a:17(int) returning_test.b:18(int) returning_test.rowid:24(int)
      │    │    ├── update-mapping:
      │    │    │    └──  column25:25 => returning_test.a:9
      │    │    ├── side-effects, mutations
      │    │    ├── key: (16)
      │    │    ├── fd: (16)-->(9,10)
      │    │    └── project
      │    │         ├── columns: column25:25(int) returning_test.a:17(int) returning_test.b:18(int) returning_test.rowid:24(int!null)
      │    │         ├── key: (24)
      │    │         ├── fd: (24)-->(17,18), (17)~~>(18,24), (17)-->(25)
      │    │         ├── scan returning_test
      │    │         │    ├── columns: returning_test.a:17(int) returning_test.b:18(int) returning_test.rowid:24(int!null)
      │    │         │    ├── key: (24)
      │    │         │    └── fd: (24)-->(17,18), (17)~~>(18,24)
      │    │         └── projections
      │    │              └── returning_test.a + 1 [type=int, outer=(17)]
      │    └── filters
      │         └── returning_test.a > 1 [type=bool, outer=(9), constraints=(/9: [/2 - ]; tight)]
      └── filters (true)

# Check if the rule works as desired for other mutations.
opt
INSERT INTO returning_test VALUES (1, 2, 'c') ON CONFLICT (a) DO UPDATE SET a = excluded.a + returning_test.a RETURNING a, b, c
----
project
 ├── columns: a:1(int) b:2(int) c:3(string)
 ├── cardinality: [1 - 1]
 ├── side-effects, mutations
 ├── key: ()
 ├── fd: ()-->(1-3)
 └── upsert returning_test
      ├── columns: a:1(int) b:2(int) c:3(string) rowid:8(int!null)
      ├── canary column: 21
      ├── fetch columns: a:14(int) b:15(int) c:16(string) rowid:21(int)
      ├── insert-mapping:
      │    ├──  column1:9 => a:1
      │    ├──  column2:10 => b:2
      │    ├──  column3:11 => c:3
      │    ├──  column12:12 => d:4
      │    ├──  column12:12 => e:5
      │    ├──  column12:12 => f:6
      │    ├──  column12:12 => g:7
      │    └──  column13:13 => rowid:8
      ├── update-mapping:
      │    └──  upsert_a:23 => a:1
      ├── return-mapping:
      │    ├──  upsert_a:23 => a:1
      │    ├──  upsert_b:24 => b:2
      │    ├──  upsert_c:25 => c:3
      │    └──  upsert_rowid:30 => rowid:8
      ├── cardinality: [1 - 1]
      ├── side-effects, mutations
      ├── key: ()
      ├── fd: ()-->(1-3,8)
      └── project
           ├── columns: upsert_a:23(int) upsert_b:24(int) upsert_c:25(string) upsert_rowid:30(int) column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int) a:14(int) b:15(int) c:16(string) rowid:21(int)
           ├── cardinality: [1 - 1]
           ├── side-effects
           ├── key: ()
           ├── fd: ()-->(9-16,21,23-25,30)
           ├── left-join (hash)
           │    ├── columns: column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int) a:14(int) b:15(int) c:16(string) rowid:21(int)
           │    ├── cardinality: [1 - 1]
           │    ├── side-effects
           │    ├── key: ()
           │    ├── fd: ()-->(9-16,21)
           │    ├── values
           │    │    ├── columns: column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int)
           │    │    ├── cardinality: [1 - 1]
           │    │    ├── side-effects
           │    │    ├── key: ()
           │    │    ├── fd: ()-->(9-13)
           │    │    └── (1, 2, 'c', CAST(NULL AS INT8), unique_rowid()) [type=tuple{int, int, string, int, int}]
           │    ├── index-join returning_test
           │    │    ├── columns: a:14(int!null) b:15(int) c:16(string) rowid:21(int!null)
           │    │    ├── cardinality: [0 - 1]
           │    │    ├── key: ()
           │    │    ├── fd: ()-->(14-16,21)
           │    │    └── scan returning_test@secondary
           │    │         ├── columns: a:14(int!null) rowid:21(int!null)
           │    │         ├── constraint: /14: [/1 - /1]
           │    │         ├── cardinality: [0 - 1]
           │    │         ├── key: ()
           │    │         └── fd: ()-->(14,21)
           │    └── filters (true)
           └── projections
                ├── CASE WHEN rowid IS NULL THEN column1 ELSE column1 + a END [type=int, outer=(9,14,21)]
                ├── CASE WHEN rowid IS NULL THEN column2 ELSE b END [type=int, outer=(10,15,21)]
                ├── CASE WHEN rowid IS NULL THEN column3 ELSE c END [type=string, outer=(11,16,21)]
                └── CASE WHEN rowid IS NULL THEN column13 ELSE rowid END [type=int, outer=(13,21)]

opt
DELETE FROM returning_test WHERE a < b + d RETURNING a, b, d
----
project
 ├── columns: a:1(int!null) b:2(int) d:4(int)
 ├── side-effects, mutations
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 └── delete returning_test
      ├── columns: a:1(int!null) b:2(int) d:4(int) rowid:8(int!null)
      ├── fetch columns: a:9(int) b:10(int) d:12(int) rowid:16(int)
      ├── side-effects, mutations
      ├── key: (8)
      ├── fd: (8)-->(1,2,4), (1)-->(2,4,8)
      └── select
           ├── columns: a:9(int!null) b:10(int) d:12(int) rowid:16(int!null)
           ├── key: (16)
           ├── fd: (16)-->(9,10,12), (9)-->(10,12,16)
           ├── scan returning_test
           │    ├── columns: a:9(int) b:10(int) d:12(int) rowid:16(int!null)
           │    ├── key: (16)
           │    └── fd: (16)-->(9,10,12), (9)~~>(10,12,16)
           └── filters
                └── a < (b + d) [type=bool, outer=(9,10,12), constraints=(/9: (/NULL - ])]

opt
UPSERT INTO returning_test (a, b, c) VALUES (1, 2, 'c') RETURNING a, b, c, d
----
project
 ├── columns: a:1(int!null) b:2(int!null) c:3(string!null) d:4(int)
 ├── cardinality: [1 - ]
 ├── side-effects, mutations
 ├── fd: ()-->(1-3)
 └── upsert returning_test
      ├── columns: a:1(int!null) b:2(int!null) c:3(string!null) d:4(int) rowid:8(int!null)
      ├── canary column: 21
      ├── fetch columns: a:14(int) b:15(int) c:16(string) d:17(int) rowid:21(int)
      ├── insert-mapping:
      │    ├──  column1:9 => a:1
      │    ├──  column2:10 => b:2
      │    ├──  column3:11 => c:3
      │    ├──  column12:12 => d:4
      │    ├──  column12:12 => e:5
      │    ├──  column12:12 => f:6
      │    ├──  column12:12 => g:7
      │    └──  column13:13 => rowid:8
      ├── update-mapping:
      │    ├──  column1:9 => a:1
      │    ├──  column2:10 => b:2
      │    └──  column3:11 => c:3
      ├── return-mapping:
      │    ├──  column1:9 => a:1
      │    ├──  column2:10 => b:2
      │    ├──  column3:11 => c:3
      │    ├──  upsert_d:22 => d:4
      │    └──  upsert_rowid:26 => rowid:8
      ├── cardinality: [1 - ]
      ├── side-effects, mutations
      ├── fd: ()-->(1-3)
      └── project
           ├── columns: upsert_d:22(int) upsert_rowid:26(int) column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int) a:14(int) b:15(int) c:16(string) d:17(int) rowid:21(int)
           ├── cardinality: [1 - ]
           ├── side-effects
           ├── key: (21)
           ├── fd: ()-->(9-13), (21)-->(14-17), (14)~~>(15-17,21), (17,21)-->(22), (21)-->(26)
           ├── left-join (lookup returning_test)
           │    ├── columns: column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int) a:14(int) b:15(int) c:16(string) d:17(int) rowid:21(int)
           │    ├── key columns: [13] = [21]
           │    ├── cardinality: [1 - ]
           │    ├── side-effects
           │    ├── key: (21)
           │    ├── fd: ()-->(9-13), (21)-->(14-17), (14)~~>(15-17,21)
           │    ├── values
           │    │    ├── columns: column1:9(int!null) column2:10(int!null) column3:11(string!null) column12:12(int) column13:13(int)
           │    │    ├── cardinality: [1 - 1]
           │    │    ├── side-effects
           │    │    ├── key: ()
           │    │    ├── fd: ()-->(9-13)
           │    │    └── (1, 2, 'c', CAST(NULL AS INT8), unique_rowid()) [type=tuple{int, int, string, int, int}]
           │    └── filters (true)
           └── projections
                ├── CASE WHEN rowid IS NULL THEN column12 ELSE d END [type=int, outer=(12,17,21)]
                └── CASE WHEN rowid IS NULL THEN column13 ELSE rowid END [type=int, outer=(13,21)]

# Make sure the passthrough columns of an UPDATE ... FROM query are pruned.
opt
UPDATE abcde
SET
  b=family.b, c = family.c
FROM
  family
WHERE
  abcde.a=family.a
RETURNING
  abcde.a, family.b, family.c
----
update abcde
 ├── columns: a:1(int!null) b:12(int) c:13(int)
 ├── fetch columns: abcde.a:6(int) abcde.b:7(int) abcde.c:8(int) abcde.d:9(int) abcde.e:10(int)
 ├── update-mapping:
 │    ├──  "family".b:12 => abcde.b:2
 │    └──  "family".c:13 => abcde.c:3
 ├── side-effects, mutations
 ├── key: (1)
 ├── fd: (1)-->(12,13)
 └── inner-join (merge)
      ├── columns: abcde.a:6(int!null) abcde.b:7(int) abcde.c:8(int) abcde.d:9(int) abcde.e:10(int) "family".a:11(int!null) "family".b:12(int) "family".c:13(int)
      ├── left ordering: +6
      ├── right ordering: +11
      ├── key: (11)
      ├── fd: (6)-->(7-10), (7,8)~~>(6,9,10), (11)-->(12,13), (6)==(11), (11)==(6)
      ├── scan abcde
      │    ├── columns: abcde.a:6(int!null) abcde.b:7(int) abcde.c:8(int) abcde.d:9(int) abcde.e:10(int)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7-10), (7,8)~~>(6,9,10)
      │    └── ordering: +6
      ├── scan "family"
      │    ├── columns: "family".a:11(int!null) "family".b:12(int) "family".c:13(int)
      │    ├── key: (11)
      │    ├── fd: (11)-->(12,13)
      │    └── ordering: +11
      └── filters (true)

# --------------------------------------------------
# PruneSemiAntiJoinRightCols
# --------------------------------------------------

# We should only see the `a` column scanned for family.
opt expect=PruneSemiAntiJoinRightCols
SELECT a, b, c FROM abcde WHERE EXISTS (SELECT * FROM family WHERE abcde.a=family.a)
----
semi-join (hash)
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null) abcde.b:2(int) abcde.c:3(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan "family"@secondary
 │    ├── columns: "family".a:6(int!null)
 │    └── key: (6)
 └── filters
      └── abcde.a = "family".a [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# We should see the `a`, `b` and `c` columns scanned for family.
opt expect=PruneSemiAntiJoinRightCols
SELECT a, b, c FROM abcde WHERE EXISTS (SELECT * FROM family WHERE abcde.a=family.a AND abcde.b > family.b + family.c)
----
semi-join (hash)
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null) abcde.b:2(int) abcde.c:3(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan "family"
 │    ├── columns: "family".a:6(int!null) "family".b:7(int) "family".c:8(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7,8)
 └── filters
      ├── abcde.a = "family".a [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── abcde.b > ("family".b + "family".c) [type=bool, outer=(2,7,8), constraints=(/2: (/NULL - ])]

opt expect=PruneSemiAntiJoinRightCols
SELECT a, b, c FROM abcde WHERE NOT EXISTS (SELECT * FROM family WHERE abcde.a=family.a)
----
anti-join (hash)
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null) abcde.b:2(int) abcde.c:3(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan "family"@secondary
 │    ├── columns: "family".a:6(int!null)
 │    └── key: (6)
 └── filters
      └── abcde.a = "family".a [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Test using multi-level nesting so we don't decorrelate the semi-join.
opt expect=PruneSemiAntiJoinRightCols
SELECT
    a, b, c
FROM
    abcde
WHERE
    EXISTS(
        SELECT
            *
        FROM
            "family"
        WHERE
            abcde.a = "family".a AND EXISTS(SELECT * FROM a WHERE abcde.a = a.k)
    )
----
semi-join-apply
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null) abcde.b:2(int) abcde.c:3(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── semi-join (hash)
 │    ├── columns: "family".a:6(int!null)
 │    ├── outer: (1)
 │    ├── key: (6)
 │    ├── scan "family"@secondary
 │    │    ├── columns: "family".a:6(int!null)
 │    │    └── key: (6)
 │    ├── scan a
 │    │    ├── columns: k:11(int!null)
 │    │    └── key: (11)
 │    └── filters
 │         └── abcde.a = k [type=bool, outer=(1,11), constraints=(/1: (/NULL - ]; /11: (/NULL - ]), fd=(1)==(11), (11)==(1)]
 └── filters
      └── abcde.a = "family".a [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Test using multi-level nesting so we don't decorrelate the anti-join.
opt expect=PruneSemiAntiJoinRightCols
SELECT
    a, b, c
FROM
    abcde
WHERE
    NOT EXISTS(
        SELECT
            *
        FROM
            "family"
        WHERE
            abcde.a = "family".a AND EXISTS(SELECT * FROM a WHERE abcde.a = a.k)
    )
----
anti-join-apply
 ├── columns: a:1(int!null) b:2(int) c:3(int)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null) abcde.b:2(int) abcde.c:3(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 ├── semi-join (hash)
 │    ├── columns: "family".a:6(int!null)
 │    ├── outer: (1)
 │    ├── key: (6)
 │    ├── scan "family"@secondary
 │    │    ├── columns: "family".a:6(int!null)
 │    │    └── key: (6)
 │    ├── scan a
 │    │    ├── columns: k:11(int!null)
 │    │    └── key: (11)
 │    └── filters
 │         └── abcde.a = k [type=bool, outer=(1,11), constraints=(/1: (/NULL - ]; /11: (/NULL - ]), fd=(1)==(11), (11)==(1)]
 └── filters
      └── abcde.a = "family".a [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

opt disable=InlineWith expect=PruneWithScanCols
WITH foo AS (SELECT * FROM a)
  SELECT i FROM foo
----
with &1 (foo)
 ├── columns: i:6(int)
 ├── scan a
 │    ├── columns: a.k:1(int!null) a.i:2(int) a.f:3(float) a.s:4(string)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── with-scan &1 (foo)
      ├── columns: i:6(int)
      └── mapping:
           └──  a.i:2(int) => i:6(int)

opt disable=InlineWith format=show-all expect=PruneWithCols
WITH foo AS (SELECT * FROM a)
  SELECT i FROM (SELECT i, 1 AS y FROM foo) ORDER BY y
----
with &1 (foo)
 ├── columns: i:6(int)
 ├── stats: [rows=1000]
 ├── cost: 1080.04
 ├── prune: (6)
 ├── scan t.public.a
 │    ├── columns: t.public.a.k:1(int!null) t.public.a.i:2(int) t.public.a.f:3(float) t.public.a.s:4(string)
 │    ├── stats: [rows=1000]
 │    ├── cost: 1080.02
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── prune: (1-4)
 │    └── interesting orderings: (+1)
 └── with-scan &1 (foo)
      ├── columns: i:6(int)
      ├── mapping:
      │    └──  t.public.a.i:2(int) => i:6(int)
      ├── stats: [rows=1000]
      ├── cost: 0.01
      ├── prune: (6)
      └── cte-uses: map[1:1]

# --------------------------------------------------
# PruneUnionAllCols
# --------------------------------------------------

opt expect=PruneUnionAllCols
SELECT a FROM (
  SELECT a, b FROM abcde
  UNION ALL
  SELECT * FROM xy
)
----
union-all
 ├── columns: a:8(int!null)
 ├── left columns: abcde.a:1(int)
 ├── right columns: x:6(int)
 ├── scan abcde@bc
 │    ├── columns: abcde.a:1(int!null)
 │    └── key: (1)
 └── scan xy
      ├── columns: x:6(int!null)
      └── key: (6)

opt expect=PruneUnionAllCols
SELECT count(*) FROM (
  SELECT a, b FROM abcde
  UNION ALL
  SELECT * FROM xy
)
----
scalar-group-by
 ├── columns: count:10(int)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(10)
 ├── union-all
 │    ├── scan abcde@bc
 │    └── scan xy
 └── aggregations
      └── count-rows [type=int]

opt expect=PruneUnionAllCols
SELECT 1 FROM a INNER JOIN (SELECT a, b FROM abcde UNION ALL SELECT * from xy) AS b ON a.i=b.b
----
project
 ├── columns: "?column?":14(int!null)
 ├── fd: ()-->(14)
 ├── inner-join (hash)
 │    ├── columns: i:2(int!null) b:13(int!null)
 │    ├── fd: (2)==(13), (13)==(2)
 │    ├── union-all
 │    │    ├── columns: b:13(int)
 │    │    ├── left columns: abcde.b:6(int)
 │    │    ├── right columns: y:11(int)
 │    │    ├── scan abcde@bc
 │    │    │    └── columns: abcde.b:6(int)
 │    │    └── scan xy
 │    │         └── columns: y:11(int)
 │    ├── scan a
 │    │    └── columns: i:2(int)
 │    └── filters
 │         └── i = b [type=bool, outer=(2,13), constraints=(/2: (/NULL - ]; /13: (/NULL - ]), fd=(2)==(13), (13)==(2)]
 └── projections
      └── const: 1 [type=int]

# Test that even when one side of the UnionAll input has a greater
# number of prunable columns than the other (neither the top-level
# Project nor the UnionAll need any input columns, but the right-hand
# Scan has a filter and cannot prune column x), a Project is added to
# ensure that both inputs to the UnionAll have the same number of
# columns.
opt expect=PruneUnionAllCols
SELECT 1 FROM (
  SELECT a, b FROM abcde
  UNION ALL
  SELECT * from xy WHERE x=1
)
----
project
 ├── columns: "?column?":10(int!null)
 ├── fd: ()-->(10)
 ├── union-all
 │    ├── scan abcde@bc
 │    └── project
 │         ├── cardinality: [0 - 1]
 │         ├── key: ()
 │         └── scan xy
 │              ├── columns: x:6(int!null)
 │              ├── constraint: /6: [/1 - /1]
 │              ├── cardinality: [0 - 1]
 │              ├── key: ()
 │              └── fd: ()-->(6)
 └── projections
      └── const: 1 [type=int]
