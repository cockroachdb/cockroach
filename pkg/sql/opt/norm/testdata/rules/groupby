exec-ddl
CREATE TABLE a
(
    k INT PRIMARY KEY,
    i INT NOT NULL,
    f FLOAT,
    s STRING NOT NULL,
    j JSON,
    UNIQUE INDEX si_idx (s DESC, i) STORING (j),
    UNIQUE INDEX fi_idx (f, i)
)
----

exec-ddl
CREATE TABLE xy
(
    x INT PRIMARY KEY,
    y INT
)
----

exec-ddl
CREATE TABLE abc
(
    a INT,
    b INT,
    c INT,
    PRIMARY KEY (a,b,c)
)
----

exec-ddl
CREATE TABLE uvwz
(
    u INT NOT NULL,
    v INT NOT NULL,
    w INT NOT NULL,
    z INT NOT NULL,

    UNIQUE INDEX (u,v),
    UNIQUE INDEX (v,w)
)
----

exec-ddl
CREATE TABLE s (
    s STRING PRIMARY KEY
)
----

exec-ddl
CREATE TABLE nullablecols (
    c1 INT,
    c2 INT,
    c3 INT,
    UNIQUE (c1),
    UNIQUE (c2,c3)
)
----

# --------------------------------------------------
# ConvertGroupByToDistinct
# --------------------------------------------------
norm expect=ConvertGroupByToDistinct
SELECT s, f FROM a GROUP BY s, f
----
distinct-on
 ├── columns: s:4(string!null) f:3(float)
 ├── grouping columns: f:3(float) s:4(string!null)
 ├── key: (3,4)
 └── scan a
      └── columns: f:3(float) s:4(string!null)

# Group by not converted to DistinctOn because it has an aggregation.
norm expect-not=ConvertGroupByToDistinct
SELECT s, f, sum(f) FROM a GROUP BY s, f
----
group-by
 ├── columns: s:4(string!null) f:3(float) sum:6(float)
 ├── grouping columns: f:3(float) s:4(string!null)
 ├── key: (3,4)
 ├── fd: (3,4)-->(6)
 ├── scan a
 │    └── columns: f:3(float) s:4(string!null)
 └── aggregations
      └── sum [type=float, outer=(3)]
           └── variable: f [type=float]


# --------------------------------------------------
# EliminateDistinct
# --------------------------------------------------
norm expect=EliminateDistinct
SELECT DISTINCT k FROM a
----
scan a
 ├── columns: k:1(int!null)
 └── key: (1)

norm expect=EliminateDistinct
SELECT DISTINCT s, i FROM a
----
scan a
 ├── columns: s:4(string!null) i:2(int!null)
 └── key: (2,4)

norm expect=EliminateDistinct
SELECT DISTINCT ON (s, i) k, i, f FROM a
----
scan a
 ├── columns: k:1(int!null) i:2(int!null) f:3(float)
 ├── key: (1)
 └── fd: (1)-->(2,3), (2,3)~~>(1)

# Strict superset of key.
norm expect=EliminateDistinct
SELECT DISTINCT s, i, f FROM a
----
scan a
 ├── columns: s:4(string!null) i:2(int!null) f:3(float)
 ├── key: (2,4)
 └── fd: (2,4)-->(3), (2,3)~~>(4)

# Distinct not eliminated because columns aren't superset of any weak key.
norm expect-not=EliminateDistinct
SELECT DISTINCT i FROM a
----
distinct-on
 ├── columns: i:2(int!null)
 ├── grouping columns: i:2(int!null)
 ├── key: (2)
 └── scan a
      └── columns: i:2(int!null)

# Distinct not eliminated despite a unique index on (f, i) because f is nullable.
norm expect-not=EliminateDistinct
SELECT DISTINCT f, i FROM a
----
distinct-on
 ├── columns: f:3(float) i:2(int!null)
 ├── grouping columns: i:2(int!null) f:3(float)
 ├── key: (2,3)
 └── scan a
      ├── columns: i:2(int!null) f:3(float)
      └── lax-key: (2,3)

# Regression test for #40295. Ensure that the DistinctOn is replaced with a
# Project operator to keep the correct number of output columns.
exec-ddl
CREATE TABLE table0 (col0 REGTYPE);
----

exec-ddl
CREATE TABLE table1 (col0 REGCLASS, col1 REGTYPE, col2 INT4);
----

norm expect=EliminateDistinct
SELECT
  (
    SELECT
      t1.col2
    FROM
      table1 AS t1
    JOIN table0 AS t0 ON
        t1.col1 = t0.col0
        AND t1.col0 = t0.col0
    GROUP BY
      t1.col2
    HAVING
      NULL
  );
----
values
 ├── columns: col2:7(int4)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7)
 └── tuple [type=tuple{int4}]
      └── subquery [type=int4]
           └── values
                ├── columns: t1.col2:3(int4!null)
                ├── cardinality: [0 - 0]
                ├── key: ()
                └── fd: ()-->(3)

# --------------------------------------------------
# EliminateGroupByProject
# --------------------------------------------------
norm expect=EliminateGroupByProject
SELECT min(s) FROM (SELECT i, s FROM (SELECT * FROM a UNION SELECT * FROM a)) GROUP BY i
----
project
 ├── columns: min:16(string!null)
 └── group-by
      ├── columns: i:12(int!null) min:16(string!null)
      ├── grouping columns: i:12(int!null)
      ├── key: (12)
      ├── fd: (12)-->(16)
      ├── union
      │    ├── columns: k:11(int!null) i:12(int!null) f:13(float) s:14(string!null) j:15(jsonb)
      │    ├── left columns: a.k:1(int) a.i:2(int) a.f:3(float) a.s:4(string) a.j:5(jsonb)
      │    ├── right columns: a.k:6(int) a.i:7(int) a.f:8(float) a.s:9(string) a.j:10(jsonb)
      │    ├── key: (11-15)
      │    ├── scan a
      │    │    ├── columns: a.k:1(int!null) a.i:2(int!null) a.f:3(float) a.s:4(string!null) a.j:5(jsonb)
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2-5), (2,4)-->(1,3,5), (2,3)~~>(1,4,5)
      │    └── scan a
      │         ├── columns: a.k:6(int!null) a.i:7(int!null) a.f:8(float) a.s:9(string!null) a.j:10(jsonb)
      │         ├── key: (6)
      │         └── fd: (6)-->(7-10), (7,9)-->(6,8,10), (7,8)~~>(6,9,10)
      └── aggregations
           └── min [type=string, outer=(14)]
                └── variable: s [type=string]

# ScalarGroupBy case.
norm expect=EliminateGroupByProject
SELECT min(s) FROM (SELECT i, s FROM (SELECT * FROM a UNION SELECT * FROM a))
----
scalar-group-by
 ├── columns: min:16(string)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(16)
 ├── union
 │    ├── columns: k:11(int!null) i:12(int!null) f:13(float) s:14(string!null) j:15(jsonb)
 │    ├── left columns: a.k:1(int) a.i:2(int) a.f:3(float) a.s:4(string) a.j:5(jsonb)
 │    ├── right columns: a.k:6(int) a.i:7(int) a.f:8(float) a.s:9(string) a.j:10(jsonb)
 │    ├── key: (11-15)
 │    ├── scan a
 │    │    ├── columns: a.k:1(int!null) a.i:2(int!null) a.f:3(float) a.s:4(string!null) a.j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5), (2,4)-->(1,3,5), (2,3)~~>(1,4,5)
 │    └── scan a
 │         ├── columns: a.k:6(int!null) a.i:7(int!null) a.f:8(float) a.s:9(string!null) a.j:10(jsonb)
 │         ├── key: (6)
 │         └── fd: (6)-->(7-10), (7,9)-->(6,8,10), (7,8)~~>(6,9,10)
 └── aggregations
      └── min [type=string, outer=(14)]
           └── variable: s [type=string]

# DistinctOn case.
norm expect=EliminateGroupByProject
SELECT DISTINCT ON (i) s FROM (SELECT i, s, f FROM (SELECT * FROM a UNION SELECT * FROM a))
----
distinct-on
 ├── columns: s:14(string!null)  [hidden: i:12(int!null)]
 ├── grouping columns: i:12(int!null)
 ├── key: (12)
 ├── fd: (12)-->(14)
 ├── union
 │    ├── columns: k:11(int!null) i:12(int!null) f:13(float) s:14(string!null) j:15(jsonb)
 │    ├── left columns: a.k:1(int) a.i:2(int) a.f:3(float) a.s:4(string) a.j:5(jsonb)
 │    ├── right columns: a.k:6(int) a.i:7(int) a.f:8(float) a.s:9(string) a.j:10(jsonb)
 │    ├── key: (11-15)
 │    ├── scan a
 │    │    ├── columns: a.k:1(int!null) a.i:2(int!null) a.f:3(float) a.s:4(string!null) a.j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5), (2,4)-->(1,3,5), (2,3)~~>(1,4,5)
 │    └── scan a
 │         ├── columns: a.k:6(int!null) a.i:7(int!null) a.f:8(float) a.s:9(string!null) a.j:10(jsonb)
 │         ├── key: (6)
 │         └── fd: (6)-->(7-10), (7,9)-->(6,8,10), (7,8)~~>(6,9,10)
 └── aggregations
      └── first-agg [type=string, outer=(14)]
           └── variable: s [type=string]

# UpsertDistinctOn case.
norm expect=EliminateGroupByProject
INSERT INTO nullablecols (rowid, c1, c2, c3)
SELECT i, i, i, i FROM (SELECT * FROM a WHERE EXISTS(SELECT * FROM a) AND k>0)
ON CONFLICT (c1) DO UPDATE SET c3=1
----
upsert nullablecols
 ├── columns: <none>
 ├── canary column: 18
 ├── fetch columns: c1:15(int) c2:16(int) c3:17(int) rowid:18(int)
 ├── insert-mapping:
 │    ├──  i:6 => c1:1
 │    ├──  i:6 => c2:2
 │    ├──  i:6 => c3:3
 │    └──  i:6 => rowid:4
 ├── update-mapping:
 │    └──  upsert_c3:22 => c3:3
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_c3:22(int!null) i:6(int!null) c1:15(int) c2:16(int) c3:17(int) rowid:18(int)
      ├── key: (6,18)
      ├── fd: (18)-->(15-17), (15)~~>(16-18), (16,17)~~>(15,18), (6,18)-->(22)
      ├── left-join (hash)
      │    ├── columns: i:6(int!null) c1:15(int) c2:16(int) c3:17(int) rowid:18(int)
      │    ├── key: (6,18)
      │    ├── fd: (18)-->(15-17), (15)~~>(16-18), (16,17)~~>(15,18)
      │    ├── upsert-distinct-on
      │    │    ├── columns: i:6(int!null)
      │    │    ├── grouping columns: i:6(int!null)
      │    │    ├── key: (6)
      │    │    └── select
      │    │         ├── columns: k:5(int!null) i:6(int!null)
      │    │         ├── key: (5)
      │    │         ├── fd: (5)-->(6)
      │    │         ├── scan a
      │    │         │    ├── columns: k:5(int!null) i:6(int!null)
      │    │         │    ├── key: (5)
      │    │         │    └── fd: (5)-->(6)
      │    │         └── filters
      │    │              ├── exists [type=bool, subquery]
      │    │              │    └── limit
      │    │              │         ├── columns: k:10(int!null) i:11(int!null) f:12(float) s:13(string!null) j:14(jsonb)
      │    │              │         ├── cardinality: [0 - 1]
      │    │              │         ├── key: ()
      │    │              │         ├── fd: ()-->(10-14)
      │    │              │         ├── scan a
      │    │              │         │    ├── columns: k:10(int!null) i:11(int!null) f:12(float) s:13(string!null) j:14(jsonb)
      │    │              │         │    ├── key: (10)
      │    │              │         │    ├── fd: (10)-->(11-14), (11,13)-->(10,12,14), (11,12)~~>(10,13,14)
      │    │              │         │    └── limit hint: 1.00
      │    │              │         └── const: 1 [type=int]
      │    │              └── k > 0 [type=bool, outer=(5), constraints=(/5: [/1 - ]; tight)]
      │    ├── scan nullablecols
      │    │    ├── columns: c1:15(int) c2:16(int) c3:17(int) rowid:18(int!null)
      │    │    ├── key: (18)
      │    │    └── fd: (18)-->(15-17), (15)~~>(16-18), (16,17)~~>(15,18)
      │    └── filters
      │         └── i = c1 [type=bool, outer=(6,15), constraints=(/6: (/NULL - ]; /15: (/NULL - ]), fd=(6)==(15), (15)==(6)]
      └── projections
           └── CASE WHEN rowid IS NULL THEN i ELSE 1 END [type=int, outer=(6,18)]

# Don't eliminate project if it computes extra column(s).
norm expect-not=EliminateGroupByProject
SELECT min(s) FROM (SELECT i+1 AS i2, s FROM a) GROUP BY i2
----
project
 ├── columns: min:7(string!null)
 └── group-by
      ├── columns: i2:6(int!null) min:7(string!null)
      ├── grouping columns: i2:6(int!null)
      ├── key: (6)
      ├── fd: (6)-->(7)
      ├── project
      │    ├── columns: i2:6(int!null) s:4(string!null)
      │    ├── scan a
      │    │    ├── columns: i:2(int!null) s:4(string!null)
      │    │    └── key: (2,4)
      │    └── projections
      │         └── i + 1 [type=int, outer=(2)]
      └── aggregations
           └── min [type=string, outer=(4)]
                └── variable: s [type=string]

# --------------------------------------------------
# ReduceGroupingCols
# --------------------------------------------------
norm expect=ReduceGroupingCols
SELECT k, min(i), f, s FROM a GROUP BY s, f, k
----
group-by
 ├── columns: k:1(int!null) min:6(int!null) f:3(float) s:4(string!null)
 ├── grouping columns: k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(3,4,6)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)
 └── aggregations
      ├── min [type=int, outer=(2)]
      │    └── variable: i [type=int]
      ├── const-agg [type=float, outer=(3)]
      │    └── variable: f [type=float]
      └── const-agg [type=string, outer=(4)]
           └── variable: s [type=string]

norm expect=ReduceGroupingCols
SELECT k, sum(DISTINCT i), f, s FROM a, xy GROUP BY s, f, k
----
group-by
 ├── columns: k:1(int!null) sum:8(decimal!null) f:3(float) s:4(string!null)
 ├── grouping columns: k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(3,4,8)
 ├── inner-join (cross)
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null)
 │    ├── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4), (2,4)-->(1,3), (2,3)~~>(1,4)
 │    ├── scan xy
 │    └── filters (true)
 └── aggregations
      ├── agg-distinct [type=decimal, outer=(2)]
      │    └── sum [type=decimal]
      │         └── variable: i [type=int]
      ├── const-agg [type=float, outer=(3)]
      │    └── variable: f [type=float]
      └── const-agg [type=string, outer=(4)]
           └── variable: s [type=string]

# Eliminated columns are not part of projection.
norm expect=ReduceGroupingCols
SELECT min(f) FROM a GROUP BY i, s, k
----
project
 ├── columns: min:6(float)
 └── group-by
      ├── columns: i:2(int!null) s:4(string!null) min:6(float)
      ├── grouping columns: i:2(int!null) s:4(string!null)
      ├── key: (2,4)
      ├── fd: (2,4)-->(6)
      ├── scan a
      │    ├── columns: i:2(int!null) f:3(float) s:4(string!null)
      │    ├── key: (2,4)
      │    └── fd: (2,4)-->(3), (2,3)~~>(4)
      └── aggregations
           └── min [type=float, outer=(3)]
                └── variable: f [type=float]

# All grouping columns eliminated.
norm expect=ReduceGroupingCols
SELECT sum(f), i FROM a GROUP BY k, i, f HAVING k=1
----
group-by
 ├── columns: sum:6(float) i:2(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2,6)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-3)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 │    └── filters
 │         └── k = 1 [type=bool, outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
 └── aggregations
      ├── sum [type=float, outer=(3)]
      │    └── variable: f [type=float]
      └── const-agg [type=int, outer=(2)]
           └── variable: i [type=int]

norm expect=ReduceGroupingCols
SELECT DISTINCT ON (k, f, s) i, f, x FROM a JOIN xy ON i=y
----
distinct-on
 ├── columns: i:2(int!null) f:3(float) x:6(int!null)  [hidden: k:1(int!null)]
 ├── grouping columns: k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2,3,6), (2,3)~~>(1), (6)-->(2)
 ├── inner-join (hash)
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) x:6(int!null) y:7(int!null)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2,3), (2,3)~~>(1), (6)-->(7), (2)==(7), (7)==(2)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2,3), (2,3)~~>(1)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── i = y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 └── aggregations
      ├── first-agg [type=int, outer=(2)]
      │    └── variable: i [type=int]
      ├── first-agg [type=int, outer=(6)]
      │    └── variable: x [type=int]
      └── const-agg [type=float, outer=(3)]
           └── variable: f [type=float]

# --------------------------------------------------
# ReduceNotNullGroupingCols
# --------------------------------------------------

# UpsertDistinctOn should reduce non-nullable constant grouping column.
norm expect=ReduceNotNullGroupingCols
INSERT INTO xy (x)
SELECT y FROM xy WHERE y=0
ON CONFLICT (x) DO UPDATE SET y=1
----
upsert xy
 ├── columns: <none>
 ├── canary column: 6
 ├── fetch columns: x:6(int) y:7(int)
 ├── insert-mapping:
 │    ├──  y:4 => x:1
 │    └──  column5:5 => y:2
 ├── update-mapping:
 │    └──  upsert_y:10 => y:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_y:10(int) y:4(int!null) column5:5(int) x:6(int) y:7(int)
      ├── key: (6)
      ├── fd: ()-->(4,5), (6)-->(7), (6)-->(10)
      ├── left-join (hash)
      │    ├── columns: y:4(int!null) column5:5(int) x:6(int) y:7(int)
      │    ├── key: (6)
      │    ├── fd: ()-->(4,5), (6)-->(7)
      │    ├── max1-row
      │    │    ├── columns: y:4(int!null) column5:5(int)
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(4,5)
      │    │    └── project
      │    │         ├── columns: column5:5(int) y:4(int!null)
      │    │         ├── fd: ()-->(4,5)
      │    │         ├── select
      │    │         │    ├── columns: y:4(int!null)
      │    │         │    ├── fd: ()-->(4)
      │    │         │    ├── scan xy
      │    │         │    │    └── columns: y:4(int)
      │    │         │    └── filters
      │    │         │         └── y = 0 [type=bool, outer=(4), constraints=(/4: [/0 - /0]; tight), fd=()-->(4)]
      │    │         └── projections
      │    │              └── null [type=int]
      │    ├── scan xy
      │    │    ├── columns: x:6(int!null) y:7(int)
      │    │    ├── key: (6)
      │    │    └── fd: (6)-->(7)
      │    └── filters
      │         └── y = x [type=bool, outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]
      └── projections
           └── CASE WHEN x IS NULL THEN column5 ELSE 1 END [type=int, outer=(5,6)]

# UpsertDistinctOn should not reduce nullable constant grouping column.
norm expect-not=ReduceNotNullGroupingCols
INSERT INTO xy (x)
SELECT y FROM xy WHERE y IS NULL
ON CONFLICT (x) DO UPDATE SET y=1
----
upsert xy
 ├── columns: <none>
 ├── canary column: 6
 ├── fetch columns: x:6(int) y:7(int)
 ├── insert-mapping:
 │    ├──  y:4 => x:1
 │    └──  column5:5 => y:2
 ├── update-mapping:
 │    └──  upsert_y:10 => y:2
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_y:10(int) y:4(int) column5:5(int) x:6(int) y:7(int)
      ├── lax-key: (4,6)
      ├── fd: ()-->(4,5), (6)-->(7), (6)-->(10)
      ├── left-join (hash)
      │    ├── columns: y:4(int) column5:5(int) x:6(int) y:7(int)
      │    ├── lax-key: (4,6)
      │    ├── fd: ()-->(4,5), (6)-->(7)
      │    ├── upsert-distinct-on
      │    │    ├── columns: y:4(int) column5:5(int)
      │    │    ├── grouping columns: y:4(int)
      │    │    ├── lax-key: (4)
      │    │    ├── fd: ()-->(4,5)
      │    │    ├── project
      │    │    │    ├── columns: column5:5(int) y:4(int)
      │    │    │    ├── fd: ()-->(4,5)
      │    │    │    ├── select
      │    │    │    │    ├── columns: y:4(int)
      │    │    │    │    ├── fd: ()-->(4)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    └── columns: y:4(int)
      │    │    │    │    └── filters
      │    │    │    │         └── y IS NULL [type=bool, outer=(4), constraints=(/4: [/NULL - /NULL]; tight), fd=()-->(4)]
      │    │    │    └── projections
      │    │    │         └── null [type=int]
      │    │    └── aggregations
      │    │         └── first-agg [type=int, outer=(5)]
      │    │              └── variable: column5 [type=int]
      │    ├── scan xy
      │    │    ├── columns: x:6(int!null) y:7(int)
      │    │    ├── key: (6)
      │    │    └── fd: (6)-->(7)
      │    └── filters
      │         └── y = x [type=bool, outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]
      └── projections
           └── CASE WHEN x IS NULL THEN column5 ELSE 1 END [type=int, outer=(5,6)]

# Test removal of 2/3 grouping columns.
norm expect=ReduceNotNullGroupingCols
INSERT INTO abc (a, b, c)
SELECT 1, b, 2 FROM abc
ON CONFLICT (a, b, c) DO UPDATE SET a=1
----
upsert abc
 ├── columns: <none>
 ├── canary column: 9
 ├── fetch columns: a:9(int) b:10(int) c:11(int)
 ├── insert-mapping:
 │    ├──  "?column?":7 => a:1
 │    ├──  b:5 => b:2
 │    └──  "?column?":8 => c:3
 ├── update-mapping:
 │    └──  "?column?":7 => a:1
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── left-join (hash)
      ├── columns: b:5(int!null) "?column?":7(int!null) "?column?":8(int!null) a:9(int) b:10(int) c:11(int)
      ├── key: (5,9-11)
      ├── fd: ()-->(7,8)
      ├── upsert-distinct-on
      │    ├── columns: b:5(int!null) "?column?":7(int!null) "?column?":8(int!null)
      │    ├── grouping columns: b:5(int!null)
      │    ├── key: (5)
      │    ├── fd: ()-->(7,8)
      │    ├── project
      │    │    ├── columns: "?column?":7(int!null) "?column?":8(int!null) b:5(int!null)
      │    │    ├── fd: ()-->(7,8)
      │    │    ├── scan abc
      │    │    │    └── columns: b:5(int!null)
      │    │    └── projections
      │    │         ├── const: 1 [type=int]
      │    │         └── const: 2 [type=int]
      │    └── aggregations
      │         ├── const-agg [type=int, outer=(7)]
      │         │    └── variable: ?column? [type=int]
      │         └── const-agg [type=int, outer=(8)]
      │              └── variable: ?column? [type=int]
      ├── scan abc
      │    ├── columns: a:9(int!null) b:10(int!null) c:11(int!null)
      │    └── key: (9-11)
      └── filters
           ├── ?column? = a [type=bool, outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]
           ├── b = b [type=bool, outer=(5,10), constraints=(/5: (/NULL - ]; /10: (/NULL - ]), fd=(5)==(10), (10)==(5)]
           └── ?column? = c [type=bool, outer=(8,11), constraints=(/8: (/NULL - ]; /11: (/NULL - ]), fd=(8)==(11), (11)==(8)]

# Test removal of not-null column, but not nullable column.
norm expect=ReduceNotNullGroupingCols
INSERT INTO abc
SELECT NULL, b, c FROM abc WHERE b=1
ON CONFLICT (a, b, c) DO UPDATE SET c=2
----
upsert abc
 ├── columns: <none>
 ├── canary column: 8
 ├── fetch columns: a:8(int) b:9(int) c:10(int)
 ├── insert-mapping:
 │    ├──  "?column?":7 => a:1
 │    ├──  b:5 => b:2
 │    └──  c:6 => c:3
 ├── update-mapping:
 │    └──  upsert_c:14 => c:3
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_c:14(int!null) b:5(int!null) c:6(int!null) "?column?":7(int) a:8(int) b:9(int) c:10(int)
      ├── lax-key: (6-10)
      ├── fd: ()-->(5,7), (6,8)-->(14)
      ├── left-join (hash)
      │    ├── columns: b:5(int!null) c:6(int!null) "?column?":7(int) a:8(int) b:9(int) c:10(int)
      │    ├── lax-key: (6-10)
      │    ├── fd: ()-->(5,7)
      │    ├── upsert-distinct-on
      │    │    ├── columns: b:5(int!null) c:6(int!null) "?column?":7(int)
      │    │    ├── grouping columns: c:6(int!null) "?column?":7(int)
      │    │    ├── lax-key: (6,7)
      │    │    ├── fd: ()-->(5,7)
      │    │    ├── project
      │    │    │    ├── columns: "?column?":7(int) b:5(int!null) c:6(int!null)
      │    │    │    ├── fd: ()-->(5,7)
      │    │    │    ├── select
      │    │    │    │    ├── columns: b:5(int!null) c:6(int!null)
      │    │    │    │    ├── fd: ()-->(5)
      │    │    │    │    ├── scan abc
      │    │    │    │    │    └── columns: b:5(int!null) c:6(int!null)
      │    │    │    │    └── filters
      │    │    │    │         └── b = 1 [type=bool, outer=(5), constraints=(/5: [/1 - /1]; tight), fd=()-->(5)]
      │    │    │    └── projections
      │    │    │         └── null [type=int]
      │    │    └── aggregations
      │    │         └── const-agg [type=int, outer=(5)]
      │    │              └── variable: b [type=int]
      │    ├── scan abc
      │    │    ├── columns: a:8(int!null) b:9(int!null) c:10(int!null)
      │    │    └── key: (8-10)
      │    └── filters
      │         ├── ?column? = a [type=bool, outer=(7,8), constraints=(/7: (/NULL - ]; /8: (/NULL - ]), fd=(7)==(8), (8)==(7)]
      │         ├── b = b [type=bool, outer=(5,9), constraints=(/5: (/NULL - ]; /9: (/NULL - ]), fd=(5)==(9), (9)==(5)]
      │         └── c = c [type=bool, outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
      └── projections
           └── CASE WHEN a IS NULL THEN c ELSE 2 END [type=int, outer=(6,8)]

# --------------------------------------------------
# EliminateAggDistinctForKeys
# --------------------------------------------------

# ScalarGroupBy with key argument. Only the first aggregation can be
# simplified.
norm expect=EliminateAggDistinctForKeys
SELECT sum(DISTINCT k), sum(DISTINCT i) FROM a
----
scalar-group-by
 ├── columns: sum:6(decimal) sum:7(decimal)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(6,7)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int!null)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── aggregations
      ├── sum [type=decimal, outer=(1)]
      │    └── variable: k [type=int]
      └── agg-distinct [type=decimal, outer=(2)]
           └── sum [type=decimal]
                └── variable: i [type=int]

norm expect=EliminateAggDistinctForKeys
SELECT string_agg(DISTINCT s, ', ') FROM s
----
scalar-group-by
 ├── columns: string_agg:3(string)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(3)
 ├── project
 │    ├── columns: column2:2(string!null) s:1(string!null)
 │    ├── key: (1)
 │    ├── fd: ()-->(2)
 │    ├── scan s
 │    │    ├── columns: s:1(string!null)
 │    │    └── key: (1)
 │    └── projections
 │         └── const: ', ' [type=string]
 └── aggregations
      └── string-agg [type=string, outer=(1,2)]
           ├── variable: s [type=string]
           └── variable: column2 [type=string]

# GroupBy with key argument.
norm expect=EliminateAggDistinctForKeys
SELECT sum(DISTINCT k) FROM a GROUP BY i
----
project
 ├── columns: sum:6(decimal!null)
 └── group-by
      ├── columns: i:2(int!null) sum:6(decimal!null)
      ├── grouping columns: i:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(6)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int!null)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── aggregations
           └── sum [type=decimal, outer=(1)]
                └── variable: k [type=int]

# GroupBy with no key.
norm expect-not=EliminateAggDistinctForKeys
SELECT sum(DISTINCT a) FROM abc GROUP BY b
----
project
 ├── columns: sum:4(decimal!null)
 └── group-by
      ├── columns: b:2(int!null) sum:4(decimal!null)
      ├── grouping columns: b:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(4)
      ├── scan abc
      │    └── columns: a:1(int!null) b:2(int!null)
      └── aggregations
           └── agg-distinct [type=decimal, outer=(1)]
                └── sum [type=decimal]
                     └── variable: a [type=int]

# GroupBy with composite key formed by argument plus grouping columns.
norm expect=EliminateAggDistinctForKeys
SELECT sum(DISTINCT a) FROM abc GROUP BY b, c
----
project
 ├── columns: sum:4(decimal!null)
 └── group-by
      ├── columns: b:2(int!null) c:3(int!null) sum:4(decimal!null)
      ├── grouping columns: b:2(int!null) c:3(int!null)
      ├── key: (2,3)
      ├── fd: (2,3)-->(4)
      ├── scan abc
      │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    └── key: (1-3)
      └── aggregations
           └── sum [type=decimal, outer=(1)]
                └── variable: a [type=int]

# GroupBy with multiple aggregations simplified.
norm expect=EliminateAggDistinctForKeys
SELECT sum(DISTINCT i), avg(DISTINCT f) FROM a GROUP BY k
----
project
 ├── columns: sum:6(decimal!null) avg:7(float)
 └── group-by
      ├── columns: k:1(int!null) sum:6(decimal!null) avg:7(float)
      ├── grouping columns: k:1(int!null)
      ├── key: (1)
      ├── fd: (1)-->(6,7)
      ├── scan a
      │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
      │    ├── key: (1)
      │    └── fd: (1)-->(2,3), (2,3)~~>(1)
      └── aggregations
           ├── sum [type=decimal, outer=(2)]
           │    └── variable: i [type=int]
           └── avg [type=float, outer=(3)]
                └── variable: f [type=float]

# GroupBy where only some aggregations are simplified (the table has
# keys u,v and v,w).
norm expect=EliminateAggDistinctForKeys
SELECT sum(DISTINCT u), stddev(DISTINCT w), avg(DISTINCT z) FROM uvwz GROUP BY v
----
project
 ├── columns: sum:6(decimal!null) stddev:7(decimal!null) avg:8(decimal!null)
 └── group-by
      ├── columns: v:2(int!null) sum:6(decimal!null) stddev:7(decimal!null) avg:8(decimal!null)
      ├── grouping columns: v:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(6-8)
      ├── scan uvwz
      │    ├── columns: u:1(int!null) v:2(int!null) w:3(int!null) z:4(int!null)
      │    ├── key: (2,3)
      │    └── fd: (1,2)-->(3,4), (2,3)-->(1,4)
      └── aggregations
           ├── sum [type=decimal, outer=(1)]
           │    └── variable: u [type=int]
           ├── std-dev [type=decimal, outer=(3)]
           │    └── variable: w [type=int]
           └── agg-distinct [type=decimal, outer=(4)]
                └── avg [type=decimal]
                     └── variable: z [type=int]

# --------------------------------------------------
# EliminateAggFilteredDistinctForKeys
# --------------------------------------------------

# ScalarGroupBy with key argument. Only the first aggregation can be
# simplified.
norm expect=EliminateAggFilteredDistinctForKeys
SELECT sum(DISTINCT k) FILTER (WHERE k > 0), sum(DISTINCT i) FILTER (WHERE i > 0) FROM a
----
scalar-group-by
 ├── columns: sum:7(decimal) sum:9(decimal)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(7,9)
 ├── project
 │    ├── columns: column6:6(bool!null) column8:8(bool!null) k:1(int!null) i:2(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,6), (2)-->(8)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int!null)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── projections
 │         ├── k > 0 [type=bool, outer=(1)]
 │         └── i > 0 [type=bool, outer=(2)]
 └── aggregations
      ├── agg-filter [type=decimal, outer=(1,6)]
      │    ├── sum [type=decimal]
      │    │    └── variable: k [type=int]
      │    └── variable: column6 [type=bool]
      └── agg-filter [type=decimal, outer=(2,8)]
           ├── agg-distinct [type=decimal]
           │    └── sum [type=decimal]
           │         └── variable: i [type=int]
           └── variable: column8 [type=bool]

norm expect=EliminateAggFilteredDistinctForKeys
SELECT string_agg(DISTINCT s, ',') FILTER (WHERE s > 'a') FROM s
----
scalar-group-by
 ├── columns: string_agg:4(string)
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(4)
 ├── project
 │    ├── columns: column2:2(string!null) column3:3(bool!null) s:1(string!null)
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(3)
 │    ├── scan s
 │    │    ├── columns: s:1(string!null)
 │    │    └── key: (1)
 │    └── projections
 │         ├── const: ',' [type=string]
 │         └── s > 'a' [type=bool, outer=(1)]
 └── aggregations
      └── agg-filter [type=string, outer=(1-3)]
           ├── string-agg [type=string]
           │    ├── variable: s [type=string]
           │    └── variable: column2 [type=string]
           └── variable: column3 [type=bool]

# GroupBy with key argument.
norm expect=EliminateAggFilteredDistinctForKeys
SELECT sum(DISTINCT k) FILTER (WHERE f > 0) FROM a GROUP BY i
----
project
 ├── columns: sum:7(decimal)
 └── group-by
      ├── columns: i:2(int!null) sum:7(decimal)
      ├── grouping columns: i:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(7)
      ├── project
      │    ├── columns: column6:6(bool) k:1(int!null) i:2(int!null)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,6)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2,3), (2,3)~~>(1)
      │    └── projections
      │         └── f > 0.0 [type=bool, outer=(3)]
      └── aggregations
           └── agg-filter [type=decimal, outer=(1,6)]
                ├── sum [type=decimal]
                │    └── variable: k [type=int]
                └── variable: column6 [type=bool]

# GroupBy with no key.
norm expect-not=EliminateAggFilteredDistinctForKeys
SELECT sum(DISTINCT a) FILTER (WHERE c > 0) FROM abc GROUP BY b
----
project
 ├── columns: sum:5(decimal)
 └── group-by
      ├── columns: b:2(int!null) sum:5(decimal)
      ├── grouping columns: b:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(5)
      ├── project
      │    ├── columns: column4:4(bool!null) a:1(int!null) b:2(int!null)
      │    ├── scan abc
      │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    │    └── key: (1-3)
      │    └── projections
      │         └── c > 0 [type=bool, outer=(3)]
      └── aggregations
           └── agg-filter [type=decimal, outer=(1,4)]
                ├── agg-distinct [type=decimal]
                │    └── sum [type=decimal]
                │         └── variable: a [type=int]
                └── variable: column4 [type=bool]

# GroupBy with composite key formed by argument plus grouping columns.
norm expect=EliminateAggFilteredDistinctForKeys
SELECT sum(DISTINCT a) FILTER (WHERE c > 0) FROM abc GROUP BY b, c
----
project
 ├── columns: sum:5(decimal)
 └── group-by
      ├── columns: b:2(int!null) c:3(int!null) sum:5(decimal)
      ├── grouping columns: b:2(int!null) c:3(int!null)
      ├── key: (2,3)
      ├── fd: (2,3)-->(5)
      ├── project
      │    ├── columns: column4:4(bool!null) a:1(int!null) b:2(int!null) c:3(int!null)
      │    ├── key: (1-3)
      │    ├── fd: (3)-->(4)
      │    ├── scan abc
      │    │    ├── columns: a:1(int!null) b:2(int!null) c:3(int!null)
      │    │    └── key: (1-3)
      │    └── projections
      │         └── c > 0 [type=bool, outer=(3)]
      └── aggregations
           └── agg-filter [type=decimal, outer=(1,4)]
                ├── sum [type=decimal]
                │    └── variable: a [type=int]
                └── variable: column4 [type=bool]

# GroupBy with multiple aggregations simplified.
norm expect=EliminateAggFilteredDistinctForKeys
SELECT sum(DISTINCT i) FILTER (WHERE f > 0), avg(DISTINCT f) FILTER (WHERE i > 0) FROM a GROUP BY k
----
project
 ├── columns: sum:7(decimal) avg:9(float)
 └── group-by
      ├── columns: k:1(int!null) sum:7(decimal) avg:9(float)
      ├── grouping columns: k:1(int!null)
      ├── key: (1)
      ├── fd: (1)-->(7,9)
      ├── project
      │    ├── columns: column6:6(bool) column8:8(bool!null) k:1(int!null) i:2(int!null) f:3(float)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,3,6), (2,3)~~>(1), (2)-->(8)
      │    ├── scan a
      │    │    ├── columns: k:1(int!null) i:2(int!null) f:3(float)
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2,3), (2,3)~~>(1)
      │    └── projections
      │         ├── f > 0.0 [type=bool, outer=(3)]
      │         └── i > 0 [type=bool, outer=(2)]
      └── aggregations
           ├── agg-filter [type=decimal, outer=(2,6)]
           │    ├── sum [type=decimal]
           │    │    └── variable: i [type=int]
           │    └── variable: column6 [type=bool]
           └── agg-filter [type=float, outer=(3,8)]
                ├── avg [type=float]
                │    └── variable: f [type=float]
                └── variable: column8 [type=bool]

# GroupBy where only some aggregations are simplified (the table has
# keys u,v and v,w).
norm expect=EliminateAggFilteredDistinctForKeys
SELECT
    sum(DISTINCT u) FILTER (WHERE u > 0),
    stddev(DISTINCT w) FILTER (WHERE w > 0),
    avg(DISTINCT z) FILTER (WHERE z > 0)
FROM uvwz
GROUP BY v
----
project
 ├── columns: sum:7(decimal) stddev:9(decimal) avg:11(decimal)
 └── group-by
      ├── columns: v:2(int!null) sum:7(decimal) stddev:9(decimal) avg:11(decimal)
      ├── grouping columns: v:2(int!null)
      ├── key: (2)
      ├── fd: (2)-->(7,9,11)
      ├── project
      │    ├── columns: column6:6(bool!null) column8:8(bool!null) column10:10(bool!null) u:1(int!null) v:2(int!null) w:3(int!null) z:4(int!null)
      │    ├── key: (2,3)
      │    ├── fd: (1,2)-->(3,4), (2,3)-->(1,4), (1)-->(6), (3)-->(8), (4)-->(10)
      │    ├── scan uvwz
      │    │    ├── columns: u:1(int!null) v:2(int!null) w:3(int!null) z:4(int!null)
      │    │    ├── key: (2,3)
      │    │    └── fd: (1,2)-->(3,4), (2,3)-->(1,4)
      │    └── projections
      │         ├── u > 0 [type=bool, outer=(1)]
      │         ├── w > 0 [type=bool, outer=(3)]
      │         └── z > 0 [type=bool, outer=(4)]
      └── aggregations
           ├── agg-filter [type=decimal, outer=(1,6)]
           │    ├── sum [type=decimal]
           │    │    └── variable: u [type=int]
           │    └── variable: column6 [type=bool]
           ├── agg-filter [type=decimal, outer=(3,8)]
           │    ├── std-dev [type=decimal]
           │    │    └── variable: w [type=int]
           │    └── variable: column8 [type=bool]
           └── agg-filter [type=decimal, outer=(4,10)]
                ├── agg-distinct [type=decimal]
                │    └── avg [type=decimal]
                │         └── variable: z [type=int]
                └── variable: column10 [type=bool]

# --------------------------------------------------
# EliminateDistinctOnNoColumns
# --------------------------------------------------

norm expect=EliminateDistinctOnNoColumns
SELECT DISTINCT ON (a) a, b FROM abc WHERE a = 1
----
limit
 ├── columns: a:1(int!null) b:2(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2)
 ├── select
 │    ├── columns: a:1(int!null) b:2(int!null)
 │    ├── fd: ()-->(1)
 │    ├── limit hint: 1.00
 │    ├── scan abc
 │    │    ├── columns: a:1(int!null) b:2(int!null)
 │    │    └── limit hint: 100.00
 │    └── filters
 │         └── a = 1 [type=bool, outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
 └── const: 1 [type=int]

norm expect=EliminateDistinctOnNoColumns
SELECT DISTINCT ON (b) b, c FROM abc WHERE b = 1 ORDER BY b, c
----
limit
 ├── columns: b:2(int!null) c:3(int!null)
 ├── internal-ordering: +3 opt(2)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2,3)
 ├── sort
 │    ├── columns: b:2(int!null) c:3(int!null)
 │    ├── fd: ()-->(2)
 │    ├── ordering: +3 opt(2) [actual: +3]
 │    ├── limit hint: 1.00
 │    └── select
 │         ├── columns: b:2(int!null) c:3(int!null)
 │         ├── fd: ()-->(2)
 │         ├── scan abc
 │         │    └── columns: b:2(int!null) c:3(int!null)
 │         └── filters
 │              └── b = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 └── const: 1 [type=int]

# --------------------------------------------------
# EliminateUpsertDistinctOnNoColumns
# --------------------------------------------------
norm expect=EliminateUpsertDistinctOnNoColumns
INSERT INTO a (k, i, s) SELECT 1, i, 'foo' FROM a WHERE i = 1
ON CONFLICT (s, i) DO UPDATE SET f=1.1
----
upsert a
 ├── columns: <none>
 ├── canary column: 15
 ├── fetch columns: k:15(int) i:16(int) f:17(float) s:18(string) j:19(jsonb)
 ├── insert-mapping:
 │    ├──  "?column?":11 => k:1
 │    ├──  i:7 => i:2
 │    ├──  column13:13 => f:3
 │    ├──  "?column?":12 => s:4
 │    └──  column14:14 => j:5
 ├── update-mapping:
 │    └──  upsert_f:23 => f:3
 ├── cardinality: [0 - 0]
 ├── side-effects, mutations
 └── project
      ├── columns: upsert_f:23(float) i:7(int!null) "?column?":11(int!null) "?column?":12(string!null) column13:13(float) column14:14(jsonb) k:15(int) i:16(int) f:17(float) s:18(string) j:19(jsonb)
      ├── key: (15)
      ├── fd: ()-->(7,11-14), (15)-->(16-19,23), (16,18)-->(15,17,19), (16,17)~~>(15,18,19)
      ├── left-join (hash)
      │    ├── columns: i:7(int!null) "?column?":11(int!null) "?column?":12(string!null) column13:13(float) column14:14(jsonb) k:15(int) i:16(int) f:17(float) s:18(string) j:19(jsonb)
      │    ├── key: (15)
      │    ├── fd: ()-->(7,11-14), (15)-->(16-19), (16,18)-->(15,17,19), (16,17)~~>(15,18,19)
      │    ├── max1-row
      │    │    ├── columns: i:7(int!null) "?column?":11(int!null) "?column?":12(string!null) column13:13(float) column14:14(jsonb)
      │    │    ├── error: "UPSERT or INSERT...ON CONFLICT command cannot affect row a second time"
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(7,11-14)
      │    │    └── project
      │    │         ├── columns: column13:13(float) column14:14(jsonb) "?column?":11(int!null) "?column?":12(string!null) i:7(int!null)
      │    │         ├── fd: ()-->(7,11-14)
      │    │         ├── select
      │    │         │    ├── columns: i:7(int!null)
      │    │         │    ├── fd: ()-->(7)
      │    │         │    ├── scan a
      │    │         │    │    └── columns: i:7(int!null)
      │    │         │    └── filters
      │    │         │         └── i = 1 [type=bool, outer=(7), constraints=(/7: [/1 - /1]; tight), fd=()-->(7)]
      │    │         └── projections
      │    │              ├── null [type=float]
      │    │              ├── null [type=jsonb]
      │    │              ├── const: 1 [type=int]
      │    │              └── const: 'foo' [type=string]
      │    ├── scan a
      │    │    ├── columns: k:15(int!null) i:16(int!null) f:17(float) s:18(string!null) j:19(jsonb)
      │    │    ├── key: (15)
      │    │    └── fd: (15)-->(16-19), (16,18)-->(15,17,19), (16,17)~~>(15,18,19)
      │    └── filters
      │         ├── i = i [type=bool, outer=(7,16), constraints=(/7: (/NULL - ]; /16: (/NULL - ]), fd=(7)==(16), (16)==(7)]
      │         └── ?column? = s [type=bool, outer=(12,18), constraints=(/12: (/NULL - ]; /18: (/NULL - ]), fd=(12)==(18), (18)==(12)]
      └── projections
           └── CASE WHEN k IS NULL THEN column13 ELSE 1.1 END [type=float, outer=(13,15)]
