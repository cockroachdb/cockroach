exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----

# ----------------------------------------------------------
# RejectNullsLeftJoin + RejectNullsRightJoin
# ----------------------------------------------------------

norm expect=RejectNullsRightJoin
SELECT * FROM a FULL JOIN xy ON true WHERE a.k IS NOT NULL
----
left-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 x:6 y:7
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (6)-->(7)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 ├── scan xy
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters (true)

norm expect=RejectNullsLeftJoin
SELECT * FROM a FULL JOIN xy ON true WHERE xy.x > 5
----
left-join (cross)
 ├── columns: k:1 i:2 f:3 s:4 x:6!null y:7
 ├── key: (1,6)
 ├── fd: (6)-->(7), (1)-->(2-4)
 ├── select
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── x:6 > 5 [outer=(6), constraints=(/6: [/6 - ]; tight)]
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters (true)

# Inner-join operator.
norm expect=RejectNullsLeftJoin
SELECT *
FROM (SELECT * FROM a LEFT JOIN uv ON True) AS l
INNER JOIN (SELECT * FROM a LEFT JOIN uv ON True) AS r
ON l.u=1 AND r.v>2
----
inner-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 u:6!null v:7 k:9!null i:10 f:11 s:12 u:14!null v:15!null
 ├── key: (1,9,14)
 ├── fd: ()-->(6,7), (1)-->(2-4), (9)-->(10-12), (14)-->(15)
 ├── inner-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 u:6!null v:7
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: ()-->(6,7), (1)-->(2-4)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── select
 │    │    ├── columns: u:6!null v:7
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(6,7)
 │    │    ├── scan uv
 │    │    │    ├── columns: u:6!null v:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── u:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
 │    └── filters (true)
 ├── inner-join (cross)
 │    ├── columns: k:9!null i:10 f:11 s:12 u:14!null v:15!null
 │    ├── key: (9,14)
 │    ├── fd: (9)-->(10-12), (14)-->(15)
 │    ├── scan a
 │    │    ├── columns: k:9!null i:10 f:11 s:12
 │    │    ├── key: (9)
 │    │    └── fd: (9)-->(10-12)
 │    ├── select
 │    │    ├── columns: u:14!null v:15!null
 │    │    ├── key: (14)
 │    │    ├── fd: (14)-->(15)
 │    │    ├── scan uv
 │    │    │    ├── columns: u:14!null v:15
 │    │    │    ├── key: (14)
 │    │    │    └── fd: (14)-->(15)
 │    │    └── filters
 │    │         └── v:15 > 2 [outer=(15), constraints=(/15: [/3 - ]; tight)]
 │    └── filters (true)
 └── filters (true)

# Left-join operator.
norm expect=RejectNullsLeftJoin
SELECT * FROM a LEFT JOIN xy ON true WHERE xy.x = a.k
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 ├── scan xy
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Full-join operator.
norm expect=RejectNullsLeftJoin
SELECT * FROM a FULL JOIN xy ON true WHERE a.k IS NOT NULL AND xy.x > 5
----
inner-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7
 ├── key: (1,6)
 ├── fd: (6)-->(7), (1)-->(2-4)
 ├── select
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── x:6 > 5 [outer=(6), constraints=(/6: [/6 - ]; tight)]
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2-4)
 └── filters (true)

# Left-join-apply operator.
norm expect=RejectNullsLeftJoin
SELECT * FROM a LEFT JOIN LATERAL (SELECT * FROM (VALUES (i), (i)) v(y)) ON y>10 WHERE i=y
----
inner-join-apply
 ├── columns: k:1!null i:2!null f:3 s:4 y:6
 ├── fd: (1)-->(2-4), (2)==(6), (6)==(2)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    └── filters
 │         └── i:2 > 10 [outer=(2), constraints=(/2: [/11 - ]; tight)]
 ├── values
 │    ├── columns: column1:6
 │    ├── outer: (2)
 │    ├── cardinality: [2 - 2]
 │    ├── (i:2,)
 │    └── (i:2,)
 └── filters
      └── i:2 = column1:6 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]

# Full-join operator.
norm expect=RejectNullsRightJoin
SELECT * FROM a FULL JOIN xy ON true WHERE i IS NOT NULL
----
left-join (cross)
 ├── columns: k:1!null i:2!null f:3 s:4 x:6 y:7
 ├── key: (1,6)
 ├── fd: (1)-->(2-4), (6)-->(7)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    └── filters
 │         └── i:2 IS NOT NULL [outer=(2), constraints=(/2: (/NULL - ]; tight)]
 ├── scan xy
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters (true)

# ----------------------------------------------------------
# RejectNullsGroupBy
# ----------------------------------------------------------

# Single max aggregate function.
norm expect=RejectNullsGroupBy
SELECT max(x)
FROM (SELECT k FROM a)
LEFT JOIN (SELECT x FROM xy)
ON True
GROUP BY k
HAVING max(x)=1
----
project
 ├── columns: max:9!null
 ├── fd: ()-->(9)
 └── select
      ├── columns: k:1!null max:9!null
      ├── key: (1)
      ├── fd: ()-->(9)
      ├── group-by
      │    ├── columns: k:1!null max:9!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null x:6!null
      │    │    ├── key: (1,6)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null
      │    │    │    └── key: (6)
      │    │    └── filters (true)
      │    └── aggregations
      │         └── max [as=max:9, outer=(6)]
      │              └── x:6
      └── filters
           └── max:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# Aggregate function with DISTINCT.
norm expect=RejectNullsGroupBy
SELECT sum(DISTINCT y), max(y)
FROM (SELECT k FROM a)
LEFT JOIN (SELECT y FROM xy)
ON True
GROUP BY k
HAVING sum(DISTINCT y)=1
----
project
 ├── columns: sum:9!null max:10!null
 ├── immutable
 ├── fd: ()-->(9)
 └── select
      ├── columns: k:1!null sum:9!null max:10!null
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(9), (1)-->(10)
      ├── group-by
      │    ├── columns: k:1!null sum:9!null max:10!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9,10)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null y:7!null
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── select
      │    │    │    ├── columns: y:7!null
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:7
      │    │    │    └── filters
      │    │    │         └── y:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── agg-distinct [as=sum:9, outer=(7)]
      │         │    └── sum
      │         │         └── y:7
      │         └── max [as=max:10, outer=(7)]
      │              └── y:7
      └── filters
           └── sum:9 = 1 [outer=(9), immutable, constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# Single max aggregate function without grouping columns.
norm expect=RejectNullsGroupBy
SELECT max(x)
FROM (SELECT k FROM a)
LEFT JOIN (SELECT x FROM xy)
ON True
HAVING max(x)=1
----
select
 ├── columns: max:9!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(9)
 ├── scalar-group-by
 │    ├── columns: max:9
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(9)
 │    ├── inner-join (cross)
 │    │    ├── columns: x:6!null
 │    │    ├── scan a
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null
 │    │    │    └── key: (6)
 │    │    └── filters (true)
 │    └── aggregations
 │         └── max [as=max:9, outer=(6)]
 │              └── x:6
 └── filters
      └── max:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# Multiple aggregate functions on same column.
norm expect=RejectNullsGroupBy
SELECT min(x), max(x)
FROM a
LEFT JOIN xy
ON True
GROUP BY k
HAVING min(x)=1
----
project
 ├── columns: min:9!null max:10!null
 ├── fd: ()-->(9)
 └── select
      ├── columns: k:1!null min:9!null max:10!null
      ├── key: (1)
      ├── fd: ()-->(9), (1)-->(10)
      ├── group-by
      │    ├── columns: k:1!null min:9!null max:10!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9,10)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null x:6!null
      │    │    ├── key: (1,6)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null
      │    │    │    └── key: (6)
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── min [as=min:9, outer=(6)]
      │         │    └── x:6
      │         └── max [as=max:10, outer=(6)]
      │              └── x:6
      └── filters
           └── min:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# Multiple aggregate functions on same column, some with DISTINCT.
norm expect=RejectNullsGroupBy
SELECT sum(DISTINCT y), max(y)
FROM a
LEFT JOIN xy
ON True
GROUP BY k
HAVING max(y)=1
----
project
 ├── columns: sum:9!null max:10!null
 ├── fd: ()-->(10)
 └── select
      ├── columns: k:1!null sum:9!null max:10!null
      ├── key: (1)
      ├── fd: ()-->(10), (1)-->(9)
      ├── group-by
      │    ├── columns: k:1!null sum:9!null max:10!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9,10)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null y:7!null
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── select
      │    │    │    ├── columns: y:7!null
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:7
      │    │    │    └── filters
      │    │    │         └── y:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── agg-distinct [as=sum:9, outer=(7)]
      │         │    └── sum
      │         │         └── y:7
      │         └── max [as=max:10, outer=(7)]
      │              └── y:7
      └── filters
           └── max:10 = 1 [outer=(10), constraints=(/10: [/1 - /1]; tight), fd=()-->(10)]


# Ignore ConstAgg aggregates on other columns.
exprnorm expect=RejectNullsGroupBy
(Root
    (Select
        (ScalarGroupBy
            (LeftJoin
              (Scan [ (Table "xy") (Cols "x,y") ])
              (Scan [ (Table "uv") (Cols "u,v") ])
              [ ]
              [ ]
            )
            [
                (AggregationsItem (Sum (Var "v")) (NewColumn "sum" "int"))
                (AggregationsItem (ConstAgg (Var "u")) (NewColumn "const" "int"))
            ]
            [ ]
        )
        [ (Eq (Var "sum") (Const 10 "int")) ]
    )
    (Presentation "u,v")
    (NoOrdering)
)
----
select
 ├── columns: u:4 v:5  [hidden: sum:7!null const:8]
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(7,8)
 ├── scalar-group-by
 │    ├── columns: sum:7 const:8
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(7,8)
 │    ├── inner-join (cross)
 │    │    ├── columns: u:4!null v:5!null
 │    │    ├── fd: (4)-->(5)
 │    │    ├── scan xy
 │    │    ├── select
 │    │    │    ├── columns: u:4!null v:5!null
 │    │    │    ├── key: (4)
 │    │    │    ├── fd: (4)-->(5)
 │    │    │    ├── scan uv
 │    │    │    │    ├── columns: u:4!null v:5
 │    │    │    │    ├── key: (4)
 │    │    │    │    └── fd: (4)-->(5)
 │    │    │    └── filters
 │    │    │         └── v:5 IS NOT NULL [outer=(5), constraints=(/5: (/NULL - ]; tight)]
 │    │    └── filters (true)
 │    └── aggregations
 │         ├── sum [as=sum:7, outer=(5)]
 │         │    └── v:5
 │         └── const-agg [as=const:8, outer=(4)]
 │              └── u:4
 └── filters
      └── sum:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]

# Don't reject nulls when multiple columns are used.
norm expect-not=RejectNullsGroupBy
SELECT min(x), max(y)
FROM (select k from a)
LEFT JOIN (select x, y from xy)
ON True
GROUP BY k
HAVING min(x)=1
----
project
 ├── columns: min:9!null max:10
 ├── fd: ()-->(9)
 └── select
      ├── columns: k:1!null min:9!null max:10
      ├── key: (1)
      ├── fd: ()-->(9), (1)-->(10)
      ├── group-by
      │    ├── columns: k:1!null min:9 max:10
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9,10)
      │    ├── left-join (cross)
      │    │    ├── columns: k:1!null x:6 y:7
      │    │    ├── key: (1,6)
      │    │    ├── fd: (6)-->(7)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null y:7
      │    │    │    ├── key: (6)
      │    │    │    └── fd: (6)-->(7)
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── min [as=min:9, outer=(6)]
      │         │    └── x:6
      │         └── max [as=max:10, outer=(7)]
      │              └── y:7
      └── filters
           └── min:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# Don't reject column when count function is used (it doesn't return nil when
# input is empty).
norm expect-not=RejectNullsGroupBy
SELECT count(x)
FROM (SELECT k FROM a)
LEFT JOIN (SELECT x FROM xy)
ON True
GROUP BY k
HAVING count(x)=1
----
project
 ├── columns: count:9!null
 ├── fd: ()-->(9)
 └── select
      ├── columns: k:1!null count:9!null
      ├── key: (1)
      ├── fd: ()-->(9)
      ├── group-by
      │    ├── columns: k:1!null count:9!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(9)
      │    ├── left-join (cross)
      │    │    ├── columns: k:1!null x:6
      │    │    ├── key: (1,6)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null
      │    │    │    └── key: (6)
      │    │    └── filters (true)
      │    └── aggregations
      │         └── count [as=count:9, outer=(6)]
      │              └── x:6
      └── filters
           └── count:9 = 1 [outer=(9), constraints=(/9: [/1 - /1]; tight), fd=()-->(9)]

# ConstNotNullAgg rejects nulls (regression test for #28810).
# TODO(andyk): Removal of filter pushdown into apply join inputs means that this
# rule no longer triggers RejectNullsGroupBy. Find another way to decorrelate
# this query.
# opt expect=RejectNullsGroupBy
norm
SELECT 1 FROM a AS ref_0 LEFT JOIN a AS ref_1 ON EXISTS(SELECT 1 FROM a WHERE a.s = ref_0.s)
----
project
 ├── columns: "?column?":20!null
 ├── fd: ()-->(20)
 ├── left-join-apply
 │    ├── columns: ref_0.s:4 exists:19
 │    ├── scan a [as=ref_0]
 │    │    └── columns: ref_0.s:4
 │    ├── project
 │    │    ├── columns: exists:19!null
 │    │    ├── outer: (4)
 │    │    ├── group-by
 │    │    │    ├── columns: ref_1.k:6!null true_agg:18
 │    │    │    ├── grouping columns: ref_1.k:6!null
 │    │    │    ├── outer: (4)
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(18)
 │    │    │    ├── left-join (cross)
 │    │    │    │    ├── columns: ref_1.k:6!null true:17
 │    │    │    │    ├── outer: (4)
 │    │    │    │    ├── scan a [as=ref_1]
 │    │    │    │    │    ├── columns: ref_1.k:6!null
 │    │    │    │    │    └── key: (6)
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: true:17!null
 │    │    │    │    │    ├── outer: (4)
 │    │    │    │    │    ├── fd: ()-->(17)
 │    │    │    │    │    ├── select
 │    │    │    │    │    │    ├── columns: a.s:14!null
 │    │    │    │    │    │    ├── outer: (4)
 │    │    │    │    │    │    ├── fd: ()-->(14)
 │    │    │    │    │    │    ├── scan a
 │    │    │    │    │    │    │    └── columns: a.s:14
 │    │    │    │    │    │    └── filters
 │    │    │    │    │    │         └── a.s:14 = ref_0.s:4 [outer=(4,14), constraints=(/4: (/NULL - ]; /14: (/NULL - ]), fd=(4)==(14), (14)==(4)]
 │    │    │    │    │    └── projections
 │    │    │    │    │         └── true [as=true:17]
 │    │    │    │    └── filters (true)
 │    │    │    └── aggregations
 │    │    │         └── const-not-null-agg [as=true_agg:18, outer=(17)]
 │    │    │              └── true:17
 │    │    └── projections
 │    │         └── true_agg:18 IS NOT NULL [as=exists:19, outer=(18)]
 │    └── filters
 │         └── exists:19 [outer=(19), constraints=(/19: [/true - /true]; tight), fd=()-->(19)]
 └── projections
      └── 1 [as="?column?":20]

# Use with multi-argument aggregate function.
norm expect=RejectNullsGroupBy
SELECT string_agg(s, ',')
FROM (SELECT x FROM xy)
LEFT JOIN (SELECT k, s FROM a)
ON True
GROUP BY k
HAVING string_agg(s, ',')='foo'
----
project
 ├── columns: string_agg:10!null
 ├── fd: ()-->(10)
 └── select
      ├── columns: k:4!null string_agg:10!null
      ├── key: (4)
      ├── fd: ()-->(10)
      ├── group-by
      │    ├── columns: k:4!null string_agg:10!null
      │    ├── grouping columns: k:4!null
      │    ├── key: (4)
      │    ├── fd: (4)-->(10)
      │    ├── project
      │    │    ├── columns: column9:9!null k:4!null s:7!null
      │    │    ├── fd: ()-->(9), (4)-->(7)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: k:4!null s:7!null
      │    │    │    ├── fd: (4)-->(7)
      │    │    │    ├── scan xy
      │    │    │    ├── select
      │    │    │    │    ├── columns: k:4!null s:7!null
      │    │    │    │    ├── key: (4)
      │    │    │    │    ├── fd: (4)-->(7)
      │    │    │    │    ├── scan a
      │    │    │    │    │    ├── columns: k:4!null s:7
      │    │    │    │    │    ├── key: (4)
      │    │    │    │    │    └── fd: (4)-->(7)
      │    │    │    │    └── filters
      │    │    │    │         └── s:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         └── ',' [as=column9:9]
      │    └── aggregations
      │         └── string-agg [as=string_agg:10, outer=(7,9)]
      │              ├── s:7
      │              └── column9:9
      └── filters
           └── string_agg:10 = 'foo' [outer=(10), constraints=(/10: [/'foo' - /'foo']; tight), fd=()-->(10)]

# Don't reject nulls when aggregate argument is a not a Project passthrough
# column.
norm expect-not=RejectNullsGroupBy
SELECT string_agg(s || 'bar', ',')
FROM (SELECT x FROM xy)
LEFT JOIN (SELECT k, s FROM a)
ON True
GROUP BY k
HAVING string_agg(s || 'bar', ',')='foo'
----
project
 ├── columns: string_agg:11!null
 ├── immutable
 ├── fd: ()-->(11)
 └── select
      ├── columns: k:4 string_agg:11!null
      ├── immutable
      ├── key: (4)
      ├── fd: ()-->(11)
      ├── group-by
      │    ├── columns: k:4 string_agg:11
      │    ├── grouping columns: k:4
      │    ├── immutable
      │    ├── key: (4)
      │    ├── fd: (4)-->(11)
      │    ├── project
      │    │    ├── columns: column9:9 column10:10!null k:4
      │    │    ├── immutable
      │    │    ├── fd: ()-->(10), (4)-->(9)
      │    │    ├── left-join (cross)
      │    │    │    ├── columns: k:4 s:7
      │    │    │    ├── fd: (4)-->(7)
      │    │    │    ├── scan xy
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:4!null s:7
      │    │    │    │    ├── key: (4)
      │    │    │    │    └── fd: (4)-->(7)
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         ├── s:7 || 'bar' [as=column9:9, outer=(7), immutable]
      │    │         └── ',' [as=column10:10]
      │    └── aggregations
      │         └── string-agg [as=string_agg:11, outer=(9,10)]
      │              ├── column9:9
      │              └── column10:10
      └── filters
           └── string_agg:11 = 'foo' [outer=(11), constraints=(/11: [/'foo' - /'foo']; tight), fd=()-->(11)]

# Regression test: the not-null filter can't make it all the way down to the
# join that requested it, so ensure that we don't endlessly try to introduce
# them.
exprnorm
(Select
    (ScalarGroupBy
        (InnerJoinApply
          (Scan [ (Table "xy") (Cols "x,y") ])
              (LeftJoinApply
                (Scan [ (Table "uv") (Cols "u,v") ])
                (Select
                    (Values
                      [ (Tuple [ (Plus (Var "x") (Var "u")) ] "tuple{int}" ) ]
                      [ (Cols [ (NewColumn "z" "int") ]) ]
                    )
                    [ (Eq (Var "x") (Const 3 "int")) ]
                )
                [ ]
                [ ]
              )
          [ ]
          [ ]
        )
        [ (AggregationsItem (Sum (Var "z")) (NewColumn "sum" "int")) ]
        [ ]
    )
    [ (Eq (Var "sum") (Const 10 "int")) ]
)
----
select
 ├── columns: sum:8!null
 ├── cardinality: [0 - 1]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(8)
 ├── scalar-group-by
 │    ├── columns: sum:8
 │    ├── cardinality: [1 - 1]
 │    ├── immutable
 │    ├── key: ()
 │    ├── fd: ()-->(8)
 │    ├── inner-join-apply
 │    │    ├── columns: x:1!null u:4!null z:7
 │    │    ├── immutable
 │    │    ├── key: (1,4)
 │    │    ├── fd: (1,4)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null
 │    │    │    └── key: (1)
 │    │    ├── left-join-apply
 │    │    │    ├── columns: u:4!null z:7
 │    │    │    ├── outer: (1)
 │    │    │    ├── immutable
 │    │    │    ├── key: (4)
 │    │    │    ├── fd: (4)-->(7)
 │    │    │    ├── scan uv
 │    │    │    │    ├── columns: u:4!null
 │    │    │    │    └── key: (4)
 │    │    │    ├── values
 │    │    │    │    ├── columns: z:7
 │    │    │    │    ├── outer: (1,4)
 │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    ├── immutable
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(7)
 │    │    │    │    └── (x:1 + u:4,)
 │    │    │    └── filters
 │    │    │         └── x:1 = 3 [outer=(1), constraints=(/1: [/3 - /3]; tight), fd=()-->(1)]
 │    │    └── filters (true)
 │    └── aggregations
 │         └── sum [as=sum:8, outer=(7)]
 │              └── z:7
 └── filters
      └── sum:8 = 10 [outer=(8), constraints=(/8: [/10 - /10]; tight), fd=()-->(8)]

# ----------------------------------------------------------
# RejectNullsUnderJoinLeft + RejectNullsUnderJoinRight
# ----------------------------------------------------------

# InnerJoin case.
norm expect=RejectNullsUnderJoinLeft
SELECT * FROM a
LEFT JOIN xy ON k = x
INNER JOIN uv ON u = y
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null u:9!null v:10
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1), (9)-->(10), (7)==(9), (9)==(7)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── select
 │    │    ├── columns: x:6!null y:7!null
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── y:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 ├── scan uv
 │    ├── columns: u:9!null v:10
 │    ├── key: (9)
 │    └── fd: (9)-->(10)
 └── filters
      └── u:9 = y:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]

# InnerJoin case.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM uv
INNER JOIN
(
  SELECT * FROM a
  LEFT JOIN xy ON k = x
)
ON u = y
----
inner-join (hash)
 ├── columns: u:1!null v:2 k:4!null i:5 f:6 s:7 x:9!null y:10!null
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── key: (9)
 ├── fd: (1)-->(2), (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4), (1)==(10), (10)==(1)
 ├── scan uv
 │    ├── columns: u:1!null v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: k:4!null i:5 f:6 s:7 x:9!null y:10!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (9)
 │    ├── fd: (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4)
 │    ├── scan a
 │    │    ├── columns: k:4!null i:5 f:6 s:7
 │    │    ├── key: (4)
 │    │    └── fd: (4)-->(5-7)
 │    ├── select
 │    │    ├── columns: x:9!null y:10!null
 │    │    ├── key: (9)
 │    │    ├── fd: (9)-->(10)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:9!null y:10
 │    │    │    ├── key: (9)
 │    │    │    └── fd: (9)-->(10)
 │    │    └── filters
 │    │         └── y:10 IS NOT NULL [outer=(10), constraints=(/10: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:4 = x:9 [outer=(4,9), constraints=(/4: (/NULL - ]; /9: (/NULL - ]), fd=(4)==(9), (9)==(4)]
 └── filters
      └── u:1 = y:10 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]

# No-op case because null-rejection is not requested for null-rejected column.
norm expect-not=(RejectNullsUnderJoinLeft, RejectNullsUnderJoinRight)
SELECT * FROM a
INNER JOIN xy ON k = x
INNER JOIN uv ON u = y
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null u:9!null v:10
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1), (9)-->(10), (7)==(9), (9)==(7)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 ├── scan uv
 │    ├── columns: u:9!null v:10
 │    ├── key: (9)
 │    └── fd: (9)-->(10)
 └── filters
      └── u:9 = y:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]

# No-op case because null-rejection is not requested for null-rejected column.
norm expect-not=(RejectNullsUnderJoinLeft, RejectNullsUnderJoinRight)
SELECT * FROM uv
INNER JOIN
(
  SELECT * FROM a
  INNER JOIN xy ON k = x
)
ON u = y
----
inner-join (hash)
 ├── columns: u:1!null v:2 k:4!null i:5 f:6 s:7 x:9!null y:10!null
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── key: (9)
 ├── fd: (1)-->(2), (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4), (1)==(10), (10)==(1)
 ├── scan uv
 │    ├── columns: u:1!null v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: k:4!null i:5 f:6 s:7 x:9!null y:10
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (9)
 │    ├── fd: (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4)
 │    ├── scan a
 │    │    ├── columns: k:4!null i:5 f:6 s:7
 │    │    ├── key: (4)
 │    │    └── fd: (4)-->(5-7)
 │    ├── scan xy
 │    │    ├── columns: x:9!null y:10
 │    │    ├── key: (9)
 │    │    └── fd: (9)-->(10)
 │    └── filters
 │         └── k:4 = x:9 [outer=(4,9), constraints=(/4: (/NULL - ]; /9: (/NULL - ]), fd=(4)==(9), (9)==(4)]
 └── filters
      └── u:1 = y:10 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]

# InnerJoinApply case.
norm expect=RejectNullsUnderJoinLeft disable=ProjectInnerJoinValues
SELECT * FROM a
LEFT JOIN xy ON k = x
INNER JOIN LATERAL (VALUES (x)) f(v) ON v = y
----
inner-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null v:9
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7,9), (1)==(6), (6)==(1), (7)==(9), (9)==(7)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── select
 │    │    ├── columns: x:6!null y:7!null
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── y:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 ├── values
 │    ├── columns: column1:9
 │    ├── outer: (6)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(9)
 │    └── (x:6,)
 └── filters
      └── column1:9 = y:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]

# InnerJoinApply case.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM xy
INNER JOIN LATERAL
(
  SELECT * FROM (VALUES (y)) f(v)
  LEFT JOIN a ON k = v
)
ON x = i
----
inner-join-apply
 ├── columns: x:1!null y:2 v:4!null k:5!null i:6!null f:7 s:8
 ├── key: (1)
 ├── fd: (1)-->(2,4,5,7,8), (4)==(5), (5)==(4), (1)==(6), (6)==(1)
 ├── scan xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: column1:4!null k:5!null i:6!null f:7 s:8
 │    ├── outer: (2)
 │    ├── cardinality: [0 - 1]
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: ()
 │    ├── fd: ()-->(4-8), (5)==(4), (4)==(5)
 │    ├── values
 │    │    ├── columns: column1:4
 │    │    ├── outer: (2)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(4)
 │    │    └── (y:2,)
 │    ├── select
 │    │    ├── columns: k:5!null i:6!null f:7 s:8
 │    │    ├── key: (5)
 │    │    ├── fd: (5)-->(6-8)
 │    │    ├── scan a
 │    │    │    ├── columns: k:5!null i:6 f:7 s:8
 │    │    │    ├── key: (5)
 │    │    │    └── fd: (5)-->(6-8)
 │    │    └── filters
 │    │         └── i:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:5 = column1:4 [outer=(4,5), constraints=(/4: (/NULL - ]; /5: (/NULL - ]), fd=(4)==(5), (5)==(4)]
 └── filters
      └── x:1 = i:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# SemiJoin case.
norm expect=RejectNullsUnderJoinLeft
SELECT * FROM a
LEFT JOIN xy ON k = x
WHERE EXISTS (SELECT * FROM uv WHERE u = y)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── select
 │    │    ├── columns: x:6!null y:7!null
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── y:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 ├── scan uv
 │    ├── columns: u:9!null
 │    └── key: (9)
 └── filters
      └── u:9 = y:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]

# SemiJoinApply case.
norm expect=RejectNullsUnderJoinLeft
SELECT * FROM a
LEFT JOIN xy ON k = x
WHERE EXISTS (SELECT * FROM (VALUES (y)) f(v) WHERE v = x)
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7
 ├── key: (6)
 ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 x:6!null y:7
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2-4), (6)-->(7), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 ├── values
 │    ├── columns: column1:9
 │    ├── outer: (7)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(9)
 │    └── (y:7,)
 └── filters
      └── column1:9 = x:6 [outer=(6,9), constraints=(/6: (/NULL - ]; /9: (/NULL - ]), fd=(6)==(9), (9)==(6)]

# LeftJoin case.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM uv
LEFT JOIN
(
  SELECT * FROM a
  LEFT JOIN xy ON k = x
)
ON u = y
----
left-join (hash)
 ├── columns: u:1!null v:2 k:4 i:5 f:6 s:7 x:9 y:10
 ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 ├── key: (1,9)
 ├── fd: (1)-->(2), (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4)
 ├── scan uv
 │    ├── columns: u:1!null v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: k:4!null i:5 f:6 s:7 x:9!null y:10!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (9)
 │    ├── fd: (4)-->(5-7), (9)-->(10), (4)==(9), (9)==(4)
 │    ├── scan a
 │    │    ├── columns: k:4!null i:5 f:6 s:7
 │    │    ├── key: (4)
 │    │    └── fd: (4)-->(5-7)
 │    ├── select
 │    │    ├── columns: x:9!null y:10!null
 │    │    ├── key: (9)
 │    │    ├── fd: (9)-->(10)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:9!null y:10
 │    │    │    ├── key: (9)
 │    │    │    └── fd: (9)-->(10)
 │    │    └── filters
 │    │         └── y:10 IS NOT NULL [outer=(10), constraints=(/10: (/NULL - ]; tight)]
 │    └── filters
 │         └── k:4 = x:9 [outer=(4,9), constraints=(/4: (/NULL - ]; /9: (/NULL - ]), fd=(4)==(9), (9)==(4)]
 └── filters
      └── u:1 = y:10 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]

# LeftJoinApply case.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM uv
LEFT JOIN LATERAL
(
  SELECT * FROM (VALUES (u)) f(v)
  LEFT JOIN xy ON v = x
)
ON u = y
----
left-join-apply
 ├── columns: u:1!null v:2 v:4 x:5 y:6
 ├── key: (1)
 ├── fd: (1)-->(2,4-6), (4)==(5), (5)==(4)
 ├── scan uv
 │    ├── columns: u:1!null v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── inner-join (hash)
 │    ├── columns: column1:4!null x:5!null y:6!null
 │    ├── outer: (1)
 │    ├── cardinality: [0 - 1]
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: ()
 │    ├── fd: ()-->(4-6), (5)==(4), (4)==(5)
 │    ├── values
 │    │    ├── columns: column1:4
 │    │    ├── outer: (1)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(4)
 │    │    └── (u:1,)
 │    ├── select
 │    │    ├── columns: x:5!null y:6!null
 │    │    ├── key: (5)
 │    │    ├── fd: (5)-->(6)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:5!null y:6
 │    │    │    ├── key: (5)
 │    │    │    └── fd: (5)-->(6)
 │    │    └── filters
 │    │         └── y:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
 │    └── filters
 │         └── column1:4 = x:5 [outer=(4,5), constraints=(/4: (/NULL - ]; /5: (/NULL - ]), fd=(4)==(5), (5)==(4)]
 └── filters
      └── u:1 = y:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

exec-ddl
CREATE TABLE ab (
  a INT,
  b INT,
  c INT,
  INDEX b_idx (b) WHERE b IS NOT NULL,
  INDEX c_idx (c) WHERE c > 0
)
----

# Reject nulls for a scan with an IS NOT NULL partial index predicate expression
# on the right side of a semi-join.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM ab t1 WHERE EXISTS (SELECT * FROM ab t2 WHERE t1.a = t2.b)
----
semi-join (hash)
 ├── columns: a:1 b:2 c:3
 ├── scan ab [as=t1]
 │    ├── columns: t1.a:1 t1.b:2 t1.c:3
 │    └── partial index predicates
 │         ├── b_idx: filters
 │         │    └── t1.b:2 IS NOT NULL [outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │         └── c_idx: filters
 │              └── t1.c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 ├── select
 │    ├── columns: t2.b:7!null
 │    ├── scan ab [as=t2]
 │    │    ├── columns: t2.b:7
 │    │    └── partial index predicates
 │    │         ├── b_idx: filters
 │    │         │    └── t2.b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    │         └── c_idx: filters
 │    │              └── t2.c:8 > 0 [outer=(8), constraints=(/8: [/1 - ]; tight)]
 │    └── filters
 │         └── t2.b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 └── filters
      └── t1.a:1 = t2.b:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Fully optimizing the query shows that a partial index scan is generated
# because the null-reject filters imply the partial index predicate.
opt expect=(RejectNullsUnderJoinRight,GeneratePartialIndexScans)
SELECT * FROM ab t1 WHERE EXISTS (SELECT * FROM ab t2 WHERE t1.a = t2.b)
----
project
 ├── columns: a:1 b:2 c:3
 └── inner-join (hash)
      ├── columns: t1.a:1!null t1.b:2 t1.c:3 t2.b:7!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── fd: (1)==(7), (7)==(1)
      ├── scan ab [as=t1]
      │    ├── columns: t1.a:1 t1.b:2 t1.c:3
      │    └── partial index predicates
      │         ├── b_idx: filters
      │         │    └── t1.b:2 IS NOT NULL [outer=(2), constraints=(/2: (/NULL - ]; tight)]
      │         └── c_idx: filters
      │              └── t1.c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
      ├── distinct-on
      │    ├── columns: t2.b:7!null
      │    ├── grouping columns: t2.b:7!null
      │    ├── internal-ordering: +7
      │    ├── key: (7)
      │    └── scan ab@b_idx,partial [as=t2]
      │         ├── columns: t2.b:7!null
      │         └── ordering: +7
      └── filters
           └── t1.a:1 = t2.b:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Reject nulls for a scan with an IS NOT NULL partial index predicate expression
# on the right side of a anti-join.
norm expect=RejectNullsUnderJoinRight
SELECT * FROM ab t1 WHERE NOT EXISTS (SELECT * FROM ab t2 WHERE t1.a = t2.b)
----
anti-join (hash)
 ├── columns: a:1 b:2 c:3
 ├── scan ab [as=t1]
 │    ├── columns: t1.a:1 t1.b:2 t1.c:3
 │    └── partial index predicates
 │         ├── b_idx: filters
 │         │    └── t1.b:2 IS NOT NULL [outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │         └── c_idx: filters
 │              └── t1.c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 ├── select
 │    ├── columns: t2.b:7!null
 │    ├── scan ab [as=t2]
 │    │    ├── columns: t2.b:7
 │    │    └── partial index predicates
 │    │         ├── b_idx: filters
 │    │         │    └── t2.b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    │         └── c_idx: filters
 │    │              └── t2.c:8 > 0 [outer=(8), constraints=(/8: [/1 - ]; tight)]
 │    └── filters
 │         └── t2.b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 └── filters
      └── t1.a:1 = t2.b:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Fully optimizing the query shows that a partial index scan is generated
# because the null-reject filters imply the partial index predicate.
opt expect=(RejectNullsUnderJoinRight,GeneratePartialIndexScans)
SELECT * FROM ab t1 WHERE NOT EXISTS (SELECT * FROM ab t2 WHERE t1.a = t2.b)
----
anti-join (hash)
 ├── columns: a:1 b:2 c:3
 ├── scan ab [as=t1]
 │    ├── columns: t1.a:1 t1.b:2 t1.c:3
 │    └── partial index predicates
 │         ├── b_idx: filters
 │         │    └── t1.b:2 IS NOT NULL [outer=(2), constraints=(/2: (/NULL - ]; tight)]
 │         └── c_idx: filters
 │              └── t1.c:3 > 0 [outer=(3), constraints=(/3: [/1 - ]; tight)]
 ├── scan ab@b_idx,partial [as=t2]
 │    └── columns: t2.b:7!null
 └── filters
      └── t1.a:1 = t2.b:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# ----------------------------------------------------------
# RejectNullsProject
# ----------------------------------------------------------

# Multiplication case.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT k*x FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p > 5
----
project
 ├── columns: p:9!null
 ├── immutable
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2!null x:6!null y:7!null
 │    ├── immutable
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2), (6)-->(7), (2)==(7), (7)==(2)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         ├── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │         └── (k:1 * x:6) > 5 [outer=(1,6), immutable]
 └── projections
      └── k:1 * x:6 [as="?column?":9, outer=(1,6), immutable]

# Addition case.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT k+x FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p < 5
----
project
 ├── columns: p:9!null
 ├── immutable
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2!null x:6!null y:7!null
 │    ├── immutable
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2), (6)-->(7), (2)==(7), (7)==(2)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         ├── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │         └── (k:1 + x:6) < 5 [outer=(1,6), immutable]
 └── projections
      └── k:1 + x:6 [as="?column?":9, outer=(1,6), immutable]

# Equality case.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT k=x FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p
----
project
 ├── columns: p:9!null
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2!null x:6!null y:7!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (1)-->(2), (6)-->(7), (2)==(7), (7)==(2), (1)==(6), (6)==(1)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:6!null y:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         ├── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── projections
      └── k:1 = x:6 [as="?column?":9, outer=(1,6)]

# LIKE case.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT s LIKE 'blah' FROM xy
  LEFT JOIN a ON i = y
) f(p)
WHERE p
----
select
 ├── columns: p:9!null
 ├── fd: ()-->(9)
 ├── project
 │    ├── columns: "?column?":9!null
 │    ├── inner-join (hash)
 │    │    ├── columns: y:2!null i:5!null s:7!null
 │    │    ├── fd: (2)==(5), (5)==(2)
 │    │    ├── scan xy
 │    │    │    └── columns: y:2
 │    │    ├── select
 │    │    │    ├── columns: i:5 s:7!null
 │    │    │    ├── scan a
 │    │    │    │    └── columns: i:5 s:7
 │    │    │    └── filters
 │    │    │         └── s:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 │    │    └── filters
 │    │         └── i:5 = y:2 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]
 │    └── projections
 │         └── s:7 LIKE 'blah' [as="?column?":9, outer=(7)]
 └── filters
      └── "?column?":9 [outer=(9), constraints=(/9: [/true - /true]; tight), fd=()-->(9)]

# Bit AND case.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT k&x FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p > 5
----
select
 ├── columns: p:9!null
 ├── immutable
 ├── project
 │    ├── columns: "?column?":9!null
 │    ├── immutable
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null i:2!null x:6!null y:7!null
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2), (6)-->(7), (2)==(7), (7)==(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── projections
 │         └── k:1 & x:6 [as="?column?":9, outer=(1,6), immutable]
 └── filters
      └── "?column?":9 > 5 [outer=(9), constraints=(/9: [/6 - ]; tight)]

# Case with multiple-expression projection.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT (k*(3-(4/x))) FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p > 5
----
select
 ├── columns: p:9!null
 ├── immutable
 ├── project
 │    ├── columns: "?column?":9!null
 │    ├── immutable
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null i:2!null x:6!null y:7!null
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2), (6)-->(7), (2)==(7), (7)==(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── projections
 │         └── k:1 * (3 - (4 / x:6)) [as="?column?":9, outer=(1,6), immutable]
 └── filters
      └── "?column?":9 > 5 [outer=(9), immutable, constraints=(/9: (/5 - ]; tight)]

# Case with one projection that transmits NULLs, and one that doesn't.
norm expect=RejectNullsProject
SELECT * FROM
(
  SELECT x*2, (x IS NULL) FROM a
  LEFT JOIN xy ON i = y
) f(p1, p2)
WHERE p1 > 5 AND p2
----
project
 ├── columns: p1:9!null p2:10!null
 ├── immutable
 ├── fd: ()-->(9,10)
 ├── inner-join (hash)
 │    ├── columns: i:2!null x:6!null y:7!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── immutable
 │    ├── fd: ()-->(2,6,7), (2)==(7), (7)==(2)
 │    ├── scan a
 │    │    └── columns: i:2
 │    ├── select
 │    │    ├── columns: x:6!null y:7
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── immutable
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(6,7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         ├── (x:6 * 2) > 5 [outer=(6), immutable]
 │    │         └── x:6 IS NULL [outer=(6), constraints=(/6: [/NULL - /NULL]; tight), fd=()-->(6)]
 │    └── filters
 │         └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 └── projections
      ├── x:6 * 2 [as="?column?":9, outer=(6), immutable]
      └── x:6 IS NULL [as="?column?":10, outer=(6)]

# No-op case because null-rejection is not requested for column k.
norm expect-not=RejectNullsProject
SELECT * FROM
(
  SELECT k*3 FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p > 5
----
project
 ├── columns: p:9!null
 ├── immutable
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:7
 │    ├── immutable
 │    ├── fd: (1)-->(2)
 │    ├── select
 │    │    ├── columns: k:1!null i:2
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    └── filters
 │    │         └── (k:1 * 3) > 5 [outer=(1), immutable]
 │    ├── scan xy
 │    │    └── columns: y:7
 │    └── filters
 │         └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 └── projections
      └── k:1 * 3 [as="?column?":9, outer=(1), immutable]

# No-op case because the projection does not transmit NULLs even though the
# top-level multiplication expression does.
norm expect-not=RejectNullsProject
SELECT * FROM
(
  SELECT (5 * (COALESCE(x, 0))) FROM a
  LEFT JOIN xy ON i = y
) f(p)
WHERE p > 5
----
select
 ├── columns: p:9!null
 ├── immutable
 ├── project
 │    ├── columns: "?column?":9
 │    ├── immutable
 │    ├── left-join (hash)
 │    │    ├── columns: i:2 x:6 y:7
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan a
 │    │    │    └── columns: i:2
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── projections
 │         └── COALESCE(x:6, 0) * 5 [as="?column?":9, outer=(6), immutable]
 └── filters
      └── "?column?":9 > 5 [outer=(9), constraints=(/9: [/6 - ]; tight)]
