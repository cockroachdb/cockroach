exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----

exec-ddl
CREATE TABLE c (a BOOL, b BOOL, c BOOL, d BOOL, e BOOL)
----

exec-ddl
CREATE TABLE e
(
    k INT PRIMARY KEY,
    i INT,
    t TIMESTAMP,
    tz TIMESTAMPTZ,
    d DATE
)
----

# --------------------------------------------------
# SimplifyFilters
# --------------------------------------------------
norm expect=SimplifySelectFilters
SELECT * FROM a WHERE Null
----
values
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1-5)

norm expect=SimplifyJoinFilters
SELECT * FROM a INNER JOIN xy ON NULL
----
values
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb!null) x:6(int!null) y:7(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1-7)

norm expect=SimplifySelectFilters
SELECT * FROM a WHERE i=1 AND Null
----
values
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1-5)

norm expect=SimplifySelectFilters
SELECT * FROM a WHERE k=1 AND (i=2 AND (f=3.5 AND s='foo')) AND true
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── k = 1 [type=bool, outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
      ├── i = 2 [type=bool, outer=(2), constraints=(/2: [/2 - /2]; tight), fd=()-->(2)]
      ├── f = 3.5 [type=bool, outer=(3), constraints=(/3: [/3.5 - /3.5]; tight), fd=()-->(3)]
      └── s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

norm expect=SimplifyJoinFilters
SELECT * FROM a INNER JOIN xy ON (k=x AND i=y) AND true AND (f=3.5 AND s='foo')
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb) x:6(int!null) y:7(int!null)
 ├── key: (6)
 ├── fd: ()-->(3,4), (1)-->(2,5), (6)-->(7), (1)==(6), (6)==(1), (2)==(7), (7)==(2)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: ()-->(3,4), (1)-->(2,5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── f = 3.5 [type=bool, outer=(3), constraints=(/3: [/3.5 - /3.5]; tight), fd=()-->(3)]
 │         └── s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      ├── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── i = y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# --------------------------------------------------
# ConsolidateSelectFilters
# --------------------------------------------------

norm expect=ConsolidateSelectFilters
SELECT * FROM a WHERE i >= 5 AND i < 10 AND i IN (0, 2, 4, 6, 8, 10, 12)
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── ((i >= 5) AND (i < 10)) AND (i IN (0, 2, 4, 6, 8, 10, 12)) [type=bool, outer=(2), constraints=(/2: [/6 - /6] [/8 - /8]; tight)]

norm expect-not=ConsolidateSelectFilters
SELECT * FROM a WHERE k >= 5 AND i < 10
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── k >= 5 [type=bool, outer=(1), constraints=(/1: [/5 - ]; tight)]
      └── i < 10 [type=bool, outer=(2), constraints=(/2: (/NULL - /9]; tight)]

norm expect=ConsolidateSelectFilters
SELECT * FROM c WHERE a AND a=true AND b AND b=c
----
select
 ├── columns: a:1(bool!null) b:2(bool!null) c:3(bool!null) d:4(bool) e:5(bool)
 ├── fd: ()-->(1-3), (2)==(3), (3)==(2)
 ├── scan c
 │    └── columns: a:1(bool) b:2(bool) c:3(bool) d:4(bool) e:5(bool)
 └── filters
      ├── a AND (a = true) [type=bool, outer=(1), constraints=(/1: [/true - /true]; tight), fd=()-->(1)]
      ├── variable: b [type=bool, outer=(2), constraints=(/2: [/true - /true]; tight), fd=()-->(2)]
      └── b = c [type=bool, outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]

norm expect=ConsolidateSelectFilters disable=InlineConstVar
SELECT * FROM a WHERE i IS NOT NULL AND i = 3
AND f > 5 AND f < 15 AND s >= 'bar' AND s <= 'foo'
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (i IS NOT NULL) AND (i = 3) [type=bool, outer=(2), constraints=(/2: [/3 - /3]; tight), fd=()-->(2)]
      ├── (f > 5.0) AND (f < 15.0) [type=bool, outer=(3), constraints=(/3: [/5.000000000000001 - /14.999999999999998]; tight)]
      └── (s >= 'bar') AND (s <= 'foo') [type=bool, outer=(4), constraints=(/4: [/'bar' - /'foo']; tight)]

norm expect=ConsolidateSelectFilters
SELECT * FROM a WHERE i IS NULL AND i IS DISTINCT FROM 5
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── (i IS NULL) AND (i IS DISTINCT FROM 5) [type=bool, outer=(2), constraints=(/2: [/NULL - /NULL]; tight), fd=()-->(2)]

norm expect=ConsolidateSelectFilters disable=InlineConstVar
SELECT * FROM a WHERE s LIKE 'a%' AND s SIMILAR TO 'a_' AND s = 'aa'
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string!null) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (s LIKE 'a%') AND (s = 'aa') [type=bool, outer=(4), constraints=(/4: [/'aa' - /'aa']; tight), fd=()-->(4)]
      └── s SIMILAR TO 'a_' [type=bool, outer=(4), constraints=(/4: [/'a' - /'b'))]

# One of the constraints is not tight, so it should not be consolidated.
norm expect-not=ConsolidateSelectFilters
SELECT k FROM e WHERE d > '2018-07-01' AND d < '2018-07-01'::DATE + '1w1s'::INTERVAL
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) d:5(date!null)
      ├── key: (1)
      ├── fd: (1)-->(5)
      ├── scan e
      │    ├── columns: k:1(int!null) d:5(date)
      │    ├── key: (1)
      │    └── fd: (1)-->(5)
      └── filters
           ├── d > '2018-07-01' [type=bool, outer=(5), constraints=(/5: [/'2018-07-02' - ]; tight)]
           └── d < '2018-07-08 00:00:01+00:00' [type=bool, outer=(5), constraints=(/5: (/NULL - ])]

# Ranges can be merged with other filters to create new ranges.
norm expect=ConsolidateSelectFilters disable=InlineConstVar
SELECT * FROM (SELECT * FROM a WHERE k = 5) AS a, e WHERE a.k = e.k AND a.k > 1 AND e.k < 10
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) k:6(int!null) i:7(int) t:8(timestamp) tz:9(timestamptz) d:10(date)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-10)
 ├── select
 │    ├── columns: a.k:1(int!null) a.i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-5)
 │    ├── scan a
 │    │    ├── columns: a.k:1(int!null) a.i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── ((a.k = 5) AND (a.k > 1)) AND (a.k < 10) [type=bool, outer=(1), constraints=(/1: [/5 - /5]; tight), fd=()-->(1)]
 ├── select
 │    ├── columns: e.k:6(int!null) e.i:7(int) t:8(timestamp) tz:9(timestamptz) d:10(date)
 │    ├── cardinality: [0 - 8]
 │    ├── key: (6)
 │    ├── fd: (6)-->(7-10)
 │    ├── scan e
 │    │    ├── columns: e.k:6(int!null) e.i:7(int) t:8(timestamp) tz:9(timestamptz) d:10(date)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7-10)
 │    └── filters
 │         └── (e.k < 10) AND (e.k > 1) [type=bool, outer=(6), constraints=(/6: [/2 - /9]; tight)]
 └── filters
      └── a.k = e.k [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# The duplicate filter i >= 5 should be eliminated.
norm expect=ConsolidateSelectFilters
SELECT * FROM (SELECT * FROM a WHERE i >= 5 AND i < 10) AS a, xy WHERE i >= 5
----
inner-join (cross)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── (i >= 5) AND (i < 10) [type=bool, outer=(2), constraints=(/2: [/5 - /9]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters (true)

norm expect=ConsolidateSelectFilters
SELECT * FROM (SELECT * FROM a WHERE i < 10 AND i >= 5) AS a, xy WHERE i >= 5
----
inner-join (cross)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── (i < 10) AND (i >= 5) [type=bool, outer=(2), constraints=(/2: [/5 - /9]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters (true)

norm expect=ConsolidateSelectFilters
SELECT * FROM (SELECT * FROM a WHERE i < 10 AND i >= 5 AND i IN (0, 2, 4, 6, 8, 10, 12)) AS a, xy
WHERE i >= 5 AND i < 10
----
inner-join (cross)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── ((i < 10) AND (i >= 5)) AND (i IN (0, 2, 4, 6, 8, 10, 12)) [type=bool, outer=(2), constraints=(/2: [/6 - /6] [/8 - /8]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters (true)

# Regression test for #42035. This test uses the opt directive because the rule
# is triggered during exploration.
opt expect=ConsolidateSelectFilters disable=InlineConstVar
SELECT * FROM
      (VALUES ('x', 'x'), ('y', 'y')) AS vab (a, b)
    JOIN
        (VALUES ('z'), ('u')) AS vc (c)
      JOIN
        (VALUES ('v')) AS vd (d)
      ON c = d
    ON a = d AND b = d
  JOIN
    (VALUES ('w'), ('w')) AS ve (e)
  ON d = e
----
inner-join (hash)
 ├── columns: a:1(string!null) b:2(string!null) c:3(string!null) d:4(string!null) e:5(string!null)
 ├── cardinality: [0 - 8]
 ├── fd: ()-->(1-5), (1)==(2,4,5), (2)==(1,4,5), (4)==(1,2,5), (5)==(1,2,4)
 ├── values
 │    ├── columns: column1:5(string!null)
 │    ├── cardinality: [2 - 2]
 │    ├── ('w',) [type=tuple{string}]
 │    └── ('w',) [type=tuple{string}]
 ├── inner-join (hash)
 │    ├── columns: column1:1(string!null) column2:2(string!null) column1:3(string!null) column1:4(string!null)
 │    ├── cardinality: [0 - 4]
 │    ├── fd: ()-->(1-4), (1)==(2,4), (2)==(1,4), (4)==(1,2)
 │    ├── select
 │    │    ├── columns: column1:1(string!null) column2:2(string!null)
 │    │    ├── cardinality: [0 - 2]
 │    │    ├── fd: (1)==(2), (2)==(1)
 │    │    ├── values
 │    │    │    ├── columns: column1:1(string!null) column2:2(string!null)
 │    │    │    ├── cardinality: [2 - 2]
 │    │    │    ├── ('x', 'x') [type=tuple{string, string}]
 │    │    │    └── ('y', 'y') [type=tuple{string, string}]
 │    │    └── filters
 │    │         └── column1 = column2 [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
 │    ├── inner-join (cross)
 │    │    ├── columns: column1:3(string!null) column1:4(string!null)
 │    │    ├── cardinality: [0 - 2]
 │    │    ├── fd: ()-->(3,4)
 │    │    ├── select
 │    │    │    ├── columns: column1:3(string!null)
 │    │    │    ├── cardinality: [0 - 2]
 │    │    │    ├── fd: ()-->(3)
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:3(string!null)
 │    │    │    │    ├── cardinality: [2 - 2]
 │    │    │    │    ├── ('z',) [type=tuple{string}]
 │    │    │    │    └── ('u',) [type=tuple{string}]
 │    │    │    └── filters
 │    │    │         └── column1 = 'v' [type=bool, outer=(3), constraints=(/3: [/'v' - /'v']; tight), fd=()-->(3)]
 │    │    ├── values
 │    │    │    ├── columns: column1:4(string!null)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(4)
 │    │    │    └── ('v',) [type=tuple{string}]
 │    │    └── filters (true)
 │    └── filters
 │         └── column1 = column1 [type=bool, outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
 └── filters
      └── column1 = column1 [type=bool, outer=(4,5), constraints=(/4: (/NULL - ]; /5: (/NULL - ]), fd=(4)==(5), (5)==(4)]

# --------------------------------------------------
# EliminateSelect
# --------------------------------------------------
norm expect=EliminateSelect
SELECT * FROM a WHERE True
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 └── fd: (1)-->(2-5)

# --------------------------------------------------
# MergeSelects
# --------------------------------------------------
norm expect=MergeSelects
SELECT * FROM (SELECT * FROM a WHERE k=3) WHERE s='foo'
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string!null) j:5(jsonb)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── k = 3 [type=bool, outer=(1), constraints=(/1: [/3 - /3]; tight), fd=()-->(1)]
      └── s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

norm expect=MergeSelects
SELECT * FROM (SELECT * FROM a WHERE i=1) WHERE False
----
values
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1-5)

norm expect=MergeSelects
SELECT * FROM (SELECT * FROM a WHERE i<5) WHERE s='foo'
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      └── s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]

norm expect=MergeSelects
SELECT * FROM (SELECT * FROM a WHERE i>1 AND i<10) WHERE s='foo' OR k=5
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      ├── (i > 1) AND (i < 10) [type=bool, outer=(2), constraints=(/2: [/2 - /9]; tight)]
      └── (s = 'foo') OR (k = 5) [type=bool, outer=(1,4)]

# --------------------------------------------------
# PushSelectIntoProject
# --------------------------------------------------
norm expect=PushSelectIntoProject
SELECT * FROM (SELECT i, i+1 AS r, f FROM a) a WHERE f=10.0
----
project
 ├── columns: i:2(int) r:6(int) f:3(float!null)
 ├── fd: ()-->(3), (2)-->(6)
 ├── select
 │    ├── columns: i:2(int) f:3(float!null)
 │    ├── fd: ()-->(3)
 │    ├── scan a
 │    │    └── columns: i:2(int) f:3(float)
 │    └── filters
 │         └── f = 10.0 [type=bool, outer=(3), constraints=(/3: [/10.0 - /10.0]; tight), fd=()-->(3)]
 └── projections
      └── i + 1 [type=int, outer=(2)]

# Don't push down select if it depends on computed column that can't be inlined.
norm expect-not=PushSelectIntoProject
SELECT * FROM (SELECT i, i/2 div, f FROM a) a WHERE div=2
----
select
 ├── columns: i:2(int) div:6(decimal!null) f:3(float)
 ├── side-effects
 ├── fd: ()-->(6)
 ├── project
 │    ├── columns: div:6(decimal) i:2(int) f:3(float)
 │    ├── side-effects
 │    ├── scan a
 │    │    └── columns: i:2(int) f:3(float)
 │    └── projections
 │         └── i / 2 [type=decimal, outer=(2), side-effects]
 └── filters
      └── div = 2 [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]

# Push down some conjuncts, but not others.
norm expect=PushSelectIntoProject
SELECT * FROM (SELECT i, i/2 div, f FROM a) a WHERE 10.0=f AND 2=div AND i=1
----
select
 ├── columns: i:2(int!null) div:6(decimal!null) f:3(float!null)
 ├── side-effects
 ├── fd: ()-->(2,3,6)
 ├── project
 │    ├── columns: div:6(decimal) i:2(int!null) f:3(float!null)
 │    ├── side-effects
 │    ├── fd: ()-->(2,3)
 │    ├── select
 │    │    ├── columns: i:2(int!null) f:3(float!null)
 │    │    ├── fd: ()-->(2,3)
 │    │    ├── scan a
 │    │    │    └── columns: i:2(int) f:3(float)
 │    │    └── filters
 │    │         ├── f = 10.0 [type=bool, outer=(3), constraints=(/3: [/10.0 - /10.0]; tight), fd=()-->(3)]
 │    │         └── i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 │    └── projections
 │         └── i / 2 [type=decimal, outer=(2), side-effects]
 └── filters
      └── div = 2 [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]

# Detect PushSelectIntoProject and FilterUnusedSelectCols dependency cycle.
norm
SELECT f, f+1.1 AS r FROM (SELECT f, i FROM a GROUP BY f, i HAVING sum(f)=10.0) a
----
project
 ├── columns: f:3(float) r:7(float)
 ├── select
 │    ├── columns: i:2(int) f:3(float) sum:6(float!null)
 │    ├── key: (2,3)
 │    ├── fd: ()-->(6)
 │    ├── group-by
 │    │    ├── columns: i:2(int) f:3(float) sum:6(float)
 │    │    ├── grouping columns: i:2(int) f:3(float)
 │    │    ├── key: (2,3)
 │    │    ├── fd: (2,3)-->(6)
 │    │    ├── scan a
 │    │    │    └── columns: i:2(int) f:3(float)
 │    │    └── aggregations
 │    │         └── sum [type=float, outer=(3)]
 │    │              └── variable: f [type=float]
 │    └── filters
 │         └── sum = 10.0 [type=bool, outer=(6), constraints=(/6: [/10.0 - /10.0]; tight), fd=()-->(6)]
 └── projections
      └── f + 1.1 [type=float, outer=(3)]

# --------------------------------------
# PushSelectCondLeftIntoJoinLeftAndRight
# --------------------------------------

# Only the filters bound by the left side are mapped and pushed down.
norm expect=PushSelectCondLeftIntoJoinLeftAndRight
SELECT * FROM a LEFT JOIN xy ON a.k=xy.x WHERE a.k > 5 AND (xy.x = 6 OR xy.x IS NULL)
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── left-join (hash)
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2-5)
 │    │    └── filters
 │    │         └── k > 5 [type=bool, outer=(1), constraints=(/1: [/6 - ]; tight)]
 │    ├── select
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── x > 5 [type=bool, outer=(6), constraints=(/6: [/6 - ]; tight)]
 │    └── filters
 │         └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── filters
      └── (x = 6) OR (x IS NULL) [type=bool, outer=(6), constraints=(/6: [/NULL - /NULL] [/6 - /6])]

norm expect=PushSelectCondLeftIntoJoinLeftAndRight
SELECT * FROM a WHERE EXISTS (SELECT * FROM xy WHERE a.k=xy.x) AND a.k > 5
----
semi-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── k > 5 [type=bool, outer=(1), constraints=(/1: [/6 - ]; tight)]
 ├── select
 │    ├── columns: x:6(int!null)
 │    ├── key: (6)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null)
 │    │    └── key: (6)
 │    └── filters
 │         └── x > 5 [type=bool, outer=(6), constraints=(/6: [/6 - ]; tight)]
 └── filters
      └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

norm expect=PushSelectCondLeftIntoJoinLeftAndRight
SELECT * FROM a WHERE NOT EXISTS (SELECT * FROM xy WHERE a.k=xy.x) AND a.k > 5
----
anti-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── k > 5 [type=bool, outer=(1), constraints=(/1: [/6 - ]; tight)]
 ├── select
 │    ├── columns: x:6(int!null)
 │    ├── key: (6)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null)
 │    │    └── key: (6)
 │    └── filters
 │         └── x > 5 [type=bool, outer=(6), constraints=(/6: [/6 - ]; tight)]
 └── filters
      └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# PushSelectIntoJoinLeft
# --------------------------------------------------
norm expect=PushSelectIntoJoinLeft
SELECT * FROM a LEFT JOIN xy ON a.k=xy.x WHERE a.f=1.1
----
left-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: ()-->(3), (1)-->(2,4,5), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: ()-->(3), (1)-->(2,4,5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight), fd=()-->(3)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

norm expect=PushSelectIntoJoinLeft
SELECT * FROM a LEFT JOIN xy ON a.k=xy.x
WHERE a.f=1.1 AND (a.i<xy.y OR xy.y IS NULL) AND (a.s='foo' OR a.s='bar')
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: ()-->(3), (1)-->(2,4,5), (6)-->(7)
 ├── left-join (hash)
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: ()-->(3), (1)-->(2,4,5), (6)-->(7)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(3), (1)-->(2,4,5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2-5)
 │    │    └── filters
 │    │         ├── f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight), fd=()-->(3)]
 │    │         └── (s = 'foo') OR (s = 'bar') [type=bool, outer=(4), constraints=(/4: [/'bar' - /'bar'] [/'foo' - /'foo'])]
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── filters
      └── (i < y) OR (y IS NULL) [type=bool, outer=(2,7)]

# Pushdown constant condition.
norm expect=PushSelectIntoJoinLeft
SELECT * FROM a LEFT JOIN xy ON True WHERE a.i=100 AND $1>'2000-01-01T1:00:00'
----
left-join (cross)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── has-placeholder
 ├── key: (1,6)
 ├── fd: ()-->(2), (1)-->(3-5), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── has-placeholder
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(3-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── $1 > '2000-01-01T1:00:00' [type=bool]
 │         └── i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight), fd=()-->(2)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── has-placeholder
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── $1 > '2000-01-01T1:00:00' [type=bool]
 └── filters (true)

# Don't push down conditions in case of RIGHT JOIN.
norm
SELECT * FROM a RIGHT JOIN xy ON a.k=xy.x WHERE a.i=100 OR a.i IS NULL
----
select
 ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (6)-->(7), (1)-->(2-5)
 ├── left-join (hash)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (6)-->(7), (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── filters
      └── (i = 100) OR (i IS NULL) [type=bool, outer=(2), constraints=(/2: [/NULL - /NULL] [/100 - /100])]

# Don't push down conditions in case of FULL JOIN.
norm
SELECT * FROM a FULL JOIN xy ON a.k=xy.x WHERE a.i=100 OR a.i IS NULL
----
select
 ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── full-join (hash)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── filters
      └── (i = 100) OR (i IS NULL) [type=bool, outer=(2), constraints=(/2: [/NULL - /NULL] [/100 - /100])]

# Push into semi-join.
norm expect=PushSelectIntoJoinLeft
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE k=x) AND a.i=0
----
semi-join (hash)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(3-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── i = 0 [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]
 ├── scan xy
 │    ├── columns: x:6(int!null)
 │    └── key: (6)
 └── filters
      └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Push into anti-join.
norm expect=PushSelectIntoJoinLeft
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE k=x) AND a.i=0
----
anti-join (hash)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(3-5)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(3-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── i = 0 [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]
 ├── scan xy
 │    ├── columns: x:6(int!null)
 │    └── key: (6)
 └── filters
      └── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Don't push down conditions in case of LEFT JOIN.
norm
SELECT * FROM xy LEFT JOIN a ON a.k=xy.x WHERE a.i=100 OR a.i IS NULL
----
select
 ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4-7)
 ├── left-join (hash)
 │    ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4-7)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    └── fd: (3)-->(4-7)
 │    └── filters
 │         └── k = x [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 └── filters
      └── (i = 100) OR (i IS NULL) [type=bool, outer=(4), constraints=(/4: [/NULL - /NULL] [/100 - /100])]

# Don't push down conditions in case of FULL JOIN.
norm
SELECT * FROM xy FULL JOIN a ON a.k=xy.x WHERE a.i=100 OR a.i IS NULL
----
select
 ├── columns: x:1(int) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4-7)
 ├── full-join (hash)
 │    ├── columns: x:1(int) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4-7)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    └── fd: (3)-->(4-7)
 │    └── filters
 │         └── k = x [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 └── filters
      └── (i = 100) OR (i IS NULL) [type=bool, outer=(4), constraints=(/4: [/NULL - /NULL] [/100 - /100])]

# --------------------------------------------------
# MergeSelectInnerJoin
# --------------------------------------------------
norm expect=MergeSelectInnerJoin
SELECT * FROM a, xy WHERE a.k=xy.x AND (a.s='foo' OR xy.y<100)
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      ├── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── (s = 'foo') OR (y < 100) [type=bool, outer=(4,7)]

norm expect=MergeSelectInnerJoin
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE (a.s='foo' OR xy.y<100)
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      ├── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── (s = 'foo') OR (y < 100) [type=bool, outer=(4,7)]

norm expect=MergeSelectInnerJoin
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE False
----
values
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb!null) x:6(int!null) y:7(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1-7)

# Don't merge with LEFT JOIN.
norm expect-not=MergeSelectInnerJoin
SELECT * FROM a LEFT JOIN xy ON True WHERE a.k=xy.x OR xy.x IS NULL
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── left-join (cross)
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters (true)
 └── filters
      └── (k = x) OR (x IS NULL) [type=bool, outer=(1,6)]

# Don't merge with RIGHT JOIN.
norm expect-not=MergeSelectInnerJoin
SELECT * FROM a RIGHT JOIN xy ON True WHERE a.k=xy.x OR a.k IS NULL
----
select
 ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (6)-->(7), (1)-->(2-5)
 ├── left-join (cross)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (6)-->(7), (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters (true)
 └── filters
      └── (k = x) OR (k IS NULL) [type=bool, outer=(1,6)]

# Don't merge with FULL JOIN.
norm expect-not=MergeSelectInnerJoin
SELECT * FROM a FULL JOIN xy ON True WHERE a.k=xy.x OR a.k IS NULL OR xy.x IS NULL
----
select
 ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── full-join (cross)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters (true)
 └── filters
      └── ((k = x) OR (k IS NULL)) OR (x IS NULL) [type=bool, outer=(1,6)]

# --------------------------------------------------
# PushSelectIntoJoinLeft + MergeSelectInnerJoin
# --------------------------------------------------
norm
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE a.f=1.1 AND s='foo' AND xy.y=10 AND a.i<xy.y
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb) x:6(int!null) y:7(int!null)
 ├── key: (6)
 ├── fd: ()-->(3,4,7), (1)-->(2,5), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: ()-->(3,4), (1)-->(2,5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight), fd=()-->(3)]
 │         └── s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int!null)
 │    ├── key: (6)
 │    ├── fd: ()-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── y = 10 [type=bool, outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
 └── filters
      ├── k = x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── i < y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

norm
SELECT * FROM a, xy WHERE a.i=100 AND $1>'2000-01-01T1:00:00' AND xy.x=a.k
----
inner-join (hash)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── has-placeholder
 ├── key: (6)
 ├── fd: ()-->(2), (1)-->(3-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── has-placeholder
 │    ├── key: (1)
 │    ├── fd: ()-->(2), (1)-->(3-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── $1 > '2000-01-01T1:00:00' [type=bool]
 │         └── i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight), fd=()-->(2)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── has-placeholder
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── $1 > '2000-01-01T1:00:00' [type=bool]
 └── filters
      └── x = k [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# PushSelectIntoGroupBy
# --------------------------------------------------

# Push down into GroupBy with aggregations.
norm expect=PushSelectIntoGroupBy
SELECT * FROM (SELECT i, count(*) FROM a GROUP BY i) a WHERE i=1
----
group-by
 ├── columns: i:2(int) count:6(int)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2,6)
 ├── select
 │    ├── columns: i:2(int!null)
 │    ├── fd: ()-->(2)
 │    ├── scan a
 │    │    └── columns: i:2(int)
 │    └── filters
 │         └── i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 └── aggregations
      ├── count-rows [type=int]
      └── const-agg [type=int, outer=(2)]
           └── variable: i [type=int]

# Push down into GroupBy with no aggregations.
norm expect=PushSelectIntoGroupBy
SELECT * FROM (SELECT i FROM a GROUP BY i) a WHERE i=1
----
limit
 ├── columns: i:2(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(2)
 ├── select
 │    ├── columns: i:2(int!null)
 │    ├── fd: ()-->(2)
 │    ├── limit hint: 1.00
 │    ├── scan a
 │    │    ├── columns: i:2(int)
 │    │    └── limit hint: 100.00
 │    └── filters
 │         └── i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 └── const: 1 [type=int]

# Push down only conditions that do not depend on aggregations.
norm expect=PushSelectIntoGroupBy
SELECT * FROM (SELECT k, i, max(s) m FROM a GROUP BY k, i) a WHERE i=k AND m='foo'
----
select
 ├── columns: k:1(int!null) i:2(int) m:6(string!null)
 ├── key: (1)
 ├── fd: ()-->(6), (1)==(2), (2)==(1), (1)-->(2)
 ├── group-by
 │    ├── columns: k:1(int!null) i:2(int) max:6(string)
 │    ├── grouping columns: k:1(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)==(2), (2)==(1), (1)-->(2,6)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int!null) s:4(string)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(4), (1)==(2), (2)==(1)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2,4)
 │    │    └── filters
 │    │         └── i = k [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
 │    └── aggregations
 │         ├── max [type=string, outer=(4)]
 │         │    └── variable: s [type=string]
 │         └── const-agg [type=int, outer=(2)]
 │              └── variable: i [type=int]
 └── filters
      └── max = 'foo' [type=bool, outer=(6), constraints=(/6: [/'foo' - /'foo']; tight), fd=()-->(6)]

# DistinctOn case.
norm expect=PushSelectIntoGroupBy
SELECT * FROM (SELECT DISTINCT ON (i, f) i, s, f FROM a) WHERE i>f
----
distinct-on
 ├── columns: i:2(int!null) s:4(string) f:3(float!null)
 ├── grouping columns: i:2(int!null) f:3(float!null)
 ├── key: (2,3)
 ├── fd: (2,3)-->(4)
 ├── select
 │    ├── columns: i:2(int!null) f:3(float!null) s:4(string)
 │    ├── scan a
 │    │    └── columns: i:2(int) f:3(float) s:4(string)
 │    └── filters
 │         └── i > f [type=bool, outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ])]
 └── aggregations
      └── first-agg [type=string, outer=(4)]
           └── variable: s [type=string]

# DistinctOn case with a ConstAgg.
norm expect=PushSelectIntoGroupBy
SELECT * FROM (SELECT DISTINCT ON (k, f, s) k, i, f, x FROM a JOIN xy ON i=y) WHERE k > f
----
distinct-on
 ├── columns: k:1(int!null) i:2(int) f:3(float) x:6(int)
 ├── grouping columns: k:1(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2,3,6), (6)-->(2)
 ├── inner-join (hash)
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) x:6(int!null) y:7(int!null)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2,3), (6)-->(7), (2)==(7), (7)==(2)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float!null)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) f:3(float)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2,3)
 │    │    └── filters
 │    │         └── k > f [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── i = y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 └── aggregations
      ├── first-agg [type=int, outer=(2)]
      │    └── variable: i [type=int]
      ├── first-agg [type=int, outer=(6)]
      │    └── variable: x [type=int]
      └── const-agg [type=float, outer=(3)]
           └── variable: f [type=float]

# Do *not* push down into scalar GroupBy.
norm expect-not=PushSelectIntoGroupBy
SELECT * FROM (SELECT count(*) c FROM a) a WHERE $1<'2000-01-01T10:00:00' AND c=0
----
select
 ├── columns: c:6(int!null)
 ├── cardinality: [0 - 1]
 ├── has-placeholder
 ├── key: ()
 ├── fd: ()-->(6)
 ├── scalar-group-by
 │    ├── columns: count_rows:6(int)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(6)
 │    ├── scan a
 │    └── aggregations
 │         └── count-rows [type=int]
 └── filters
      ├── $1 < '2000-01-01T10:00:00' [type=bool]
      └── count_rows = 0 [type=bool, outer=(6), constraints=(/6: [/0 - /0]; tight), fd=()-->(6)]

# --------------------------------------------------
# RemoveNotNullCondition
# --------------------------------------------------
exec-ddl
CREATE TABLE b (k INT PRIMARY KEY, i INT, f FLOAT, s STRING NOT NULL, j JSON)
----

norm expect=RemoveNotNullCondition
SELECT k FROM b WHERE k IS NOT NULL AND k > 4
----
select
 ├── columns: k:1(int!null)
 ├── key: (1)
 ├── scan b
 │    ├── columns: k:1(int!null)
 │    └── key: (1)
 └── filters
      └── k > 4 [type=bool, outer=(1), constraints=(/1: [/5 - ]; tight)]

norm
SELECT k FROM b WHERE k IS NULL
----
select
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1)
 ├── scan b
 │    ├── columns: k:1(int!null)
 │    └── key: (1)
 └── filters
      └── k IS NULL [type=bool, outer=(1), constraints=(/1: [/NULL - /NULL]; tight), fd=()-->(1)]

norm expect=RemoveNotNullCondition
SELECT k,i FROM b WHERE k IS NOT NULL AND k > 4 AND i < 100 AND i IS NOT NULL
----
select
 ├── columns: k:1(int!null) i:2(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan b
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      ├── (i < 100) AND (i IS NOT NULL) [type=bool, outer=(2), constraints=(/2: (/NULL - /99]; tight)]
      └── k > 4 [type=bool, outer=(1), constraints=(/1: [/5 - ]; tight)]

norm expect=RemoveNotNullCondition
SELECT k,s FROM b WHERE k IS NOT NULL AND s IS NOT NULL
----
scan b
 ├── columns: k:1(int!null) s:4(string!null)
 ├── key: (1)
 └── fd: (1)-->(4)

# RemoveNotNullCondition partially applied
norm expect=RemoveNotNullCondition
SELECT k,s,i FROM b WHERE k IS NOT NULL AND s IS NOT NULL AND i IS NOT NULL
----
select
 ├── columns: k:1(int!null) s:4(string!null) i:2(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan b
 │    ├── columns: k:1(int!null) i:2(int) s:4(string!null)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters
      └── i IS NOT NULL [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]

# RemoveNotNullCondition rule is not applied
norm expect-not=RemoveNotNullCondition
SELECT i FROM b WHERE i IS NOT NULL
----
select
 ├── columns: i:2(int!null)
 ├── scan b
 │    └── columns: i:2(int)
 └── filters
      └── i IS NOT NULL [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]

# RemoveNotNullCondition rule is not applied
norm expect-not=RemoveNotNullCondition
SELECT k FROM b WHERE i+k IS NOT NULL
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) i:2(int)
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan b
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── (i + k) IS NOT NULL [type=bool, outer=(1,2)]

# --------------------------------------------------
# DetectSelectContradiction
# --------------------------------------------------

norm expect=DetectSelectContradiction
SELECT k FROM b WHERE k IN ()
----
values
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1)

norm expect=DetectSelectContradiction
SELECT k FROM b WHERE i=5 AND k IN () AND s='foo'
----
values
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1)

# --------------------------------------------------
# InlineConstVar
# --------------------------------------------------

norm expect=InlineConstVar
SELECT k FROM b WHERE i=5 AND i IN (1, 2, 3, 4, 5)
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) i:2(int!null)
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan b
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── i = 5 [type=bool, outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT k FROM b WHERE i=8 AND 3 = mod(i, 5)
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) i:2(int!null)
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan b
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── i = 8 [type=bool, outer=(2), constraints=(/2: [/8 - /8]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT k FROM b WHERE i=5 AND i IN (1, 2, 3, 4)
----
values
 ├── columns: k:1(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1)

# Case that requires multiple iterations to fully inline.
norm expect=InlineConstVar
SELECT * FROM xy WHERE x=y AND y=4 AND x IN (1, 2, 3, 4)
----
select
 ├── columns: x:1(int!null) y:2(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2)
 ├── scan xy
 │    ├── columns: x:1(int!null) y:2(int)
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      ├── x = 4 [type=bool, outer=(1), constraints=(/1: [/4 - /4]; tight), fd=()-->(1)]
      └── y = 4 [type=bool, outer=(2), constraints=(/2: [/4 - /4]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT * FROM xy WHERE x=y AND y=4 AND x=3
----
values
 ├── columns: x:1(int!null) y:2(int!null)
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1,2)

# Can't inline composite types.
norm expect-not=InlineConstVar
SELECT * FROM (VALUES (0.0), (0.00), (0.000)) AS v (x) WHERE x = 0 AND x::STRING = '0.00';
----
select
 ├── columns: x:1(decimal!null)
 ├── cardinality: [0 - 3]
 ├── fd: ()-->(1)
 ├── values
 │    ├── columns: column1:1(decimal!null)
 │    ├── cardinality: [3 - 3]
 │    ├── (0.0,) [type=tuple{decimal}]
 │    ├── (0.00,) [type=tuple{decimal}]
 │    └── (0.000,) [type=tuple{decimal}]
 └── filters
      ├── column1 = 0 [type=bool, outer=(1), constraints=(/1: [/0 - /0]; tight), fd=()-->(1)]
      └── column1::STRING = '0.00' [type=bool, outer=(1)]

# The rule should trigger, but not inline the composite type.
norm expect=InlineConstVar
SELECT * FROM (VALUES (0.0, 'a'), (0.00, 'b'), (0.000, 'b')) AS v (x, y) WHERE x = 0 AND x::STRING = '0.00' AND y = 'b' AND y IN ('a', 'b');
----
select
 ├── columns: x:1(decimal!null) y:2(string!null)
 ├── cardinality: [0 - 3]
 ├── fd: ()-->(1,2)
 ├── values
 │    ├── columns: column1:1(decimal!null) column2:2(string!null)
 │    ├── cardinality: [3 - 3]
 │    ├── (0.0, 'a') [type=tuple{decimal, string}]
 │    ├── (0.00, 'b') [type=tuple{decimal, string}]
 │    └── (0.000, 'b') [type=tuple{decimal, string}]
 └── filters
      ├── column1 = 0 [type=bool, outer=(1), constraints=(/1: [/0 - /0]; tight), fd=()-->(1)]
      ├── column1::STRING = '0.00' [type=bool, outer=(1)]
      └── column2 = 'b' [type=bool, outer=(2), constraints=(/2: [/'b' - /'b']; tight), fd=()-->(2)]
