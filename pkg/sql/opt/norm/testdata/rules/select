exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----
TABLE a
 ├── k int not null
 ├── i int
 ├── f float
 ├── s string
 ├── j jsonb
 └── INDEX primary
      └── k int not null

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----
TABLE xy
 ├── x int not null
 ├── y int
 └── INDEX primary
      └── x int not null

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----
TABLE uv
 ├── u int not null
 ├── v int
 └── INDEX primary
      └── u int not null

# --------------------------------------------------
# EnsureSelectFiltersAnd
# --------------------------------------------------
opt
SELECT * FROM a WHERE i=5 AND s<'foo'
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5), ()-->(2)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters [type=bool, outer=(2,4), constraints=(/2: [/5 - /5]; /4: (/NULL - /'foo'); tight), fd=()-->(2)]
      ├── a.i = 5 [type=bool, outer=(2), constraints=(/2: [/5 - /5]; tight)]
      └── a.s < 'foo' [type=bool, outer=(4), constraints=(/4: (/NULL - /'foo'); tight)]

# --------------------------------------------------
# EnsureSelectFilters
# --------------------------------------------------
opt
SELECT * FROM a WHERE i<5
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      └── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]

opt
SELECT * FROM a WHERE i<5 OR s='foo'
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters [type=bool, outer=(2,4)]
      └── (a.i < 5) OR (a.s = 'foo') [type=bool, outer=(2,4)]

# Don't use Filters for True or False condition.
opt
SELECT * FROM a WHERE True
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 └── fd: (1)-->(2-5)

opt
SELECT * FROM a WHERE False
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── constraint: /1: contradiction
 ├── key: (1)
 └── fd: (1)-->(2-5)

# --------------------------------------------------
# EliminateSelect
# --------------------------------------------------
opt
SELECT * FROM a WHERE True
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 └── fd: (1)-->(2-5)

# --------------------------------------------------
# MergeSelects
# --------------------------------------------------
opt
SELECT * FROM (SELECT * FROM a WHERE False) WHERE s='foo'
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── constraint: /1: contradiction
 ├── key: (1)
 └── fd: (1)-->(2-5)

opt
SELECT * FROM (SELECT * FROM a WHERE i=1) WHERE False
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── constraint: /1: contradiction
 ├── key: (1)
 └── fd: (1)-->(2-5)

opt
SELECT * FROM (SELECT * FROM a WHERE i=1) WHERE False
----
scan a
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 ├── constraint: /1: contradiction
 ├── key: (1)
 └── fd: (1)-->(2-5)

opt
SELECT * FROM (SELECT * FROM a WHERE i<5) WHERE s='foo'
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string!null) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5), ()-->(4)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters [type=bool, outer=(2,4), constraints=(/2: (/NULL - /4]; /4: [/'foo' - /'foo']; tight), fd=()-->(4)]
      ├── a.i < 5 [type=bool, outer=(2), constraints=(/2: (/NULL - /4]; tight)]
      └── a.s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight)]

opt
SELECT * FROM (SELECT * FROM a WHERE i>1 AND i<10) WHERE s='foo' OR k=5
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters [type=bool, outer=(1,2,4), constraints=(/2: [/2 - /9])]
      ├── a.i > 1 [type=bool, outer=(2), constraints=(/2: [/2 - ]; tight)]
      ├── a.i < 10 [type=bool, outer=(2), constraints=(/2: (/NULL - /9]; tight)]
      └── (a.s = 'foo') OR (a.k = 5) [type=bool, outer=(1,4)]

# --------------------------------------------------
# PushSelectIntoProject
# --------------------------------------------------
opt
SELECT * FROM (SELECT i, i+1 AS r, f FROM a) a WHERE f=10.0
----
project
 ├── columns: i:2(int) r:6(int) f:3(float!null)
 ├── fd: ()-->(3), (2)-->(6)
 ├── select
 │    ├── columns: i:2(int) f:3(float!null)
 │    ├── fd: ()-->(3)
 │    ├── scan a
 │    │    └── columns: i:2(int) f:3(float)
 │    └── filters [type=bool, outer=(3), constraints=(/3: [/10.0 - /10.0]; tight), fd=()-->(3)]
 │         └── a.f = 10.0 [type=bool, outer=(3), constraints=(/3: [/10.0 - /10.0]; tight)]
 └── projections [outer=(2,3)]
      └── a.i + 1 [type=int, outer=(2)]

# Don't push down select if it depends on computed column that can't be inlined.
opt
SELECT * FROM (SELECT i, i/2 div, f FROM a) a WHERE div=2
----
select
 ├── columns: i:2(int) div:6(decimal!null) f:3(float)
 ├── fd: ()-->(6)
 ├── project
 │    ├── columns: div:6(decimal) i:2(int) f:3(float)
 │    ├── fd: (2)-->(6)
 │    ├── scan a
 │    │    └── columns: i:2(int) f:3(float)
 │    └── projections [outer=(2,3)]
 │         └── a.i / 2 [type=decimal, outer=(2)]
 └── filters [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]
      └── div = 2 [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight)]

# Push down some conjuncts, but not others.
opt
SELECT * FROM (SELECT i, i/2 div, f FROM a) a WHERE 10.0=f AND 2=div AND i=1
----
select
 ├── columns: i:2(int!null) div:6(decimal!null) f:3(float!null)
 ├── fd: ()-->(2,3,6)
 ├── project
 │    ├── columns: div:6(decimal) i:2(int!null) f:3(float!null)
 │    ├── fd: ()-->(2,3), (2)-->(6)
 │    ├── select
 │    │    ├── columns: i:2(int!null) f:3(float!null)
 │    │    ├── fd: ()-->(2,3)
 │    │    ├── scan a
 │    │    │    └── columns: i:2(int) f:3(float)
 │    │    └── filters [type=bool, outer=(2,3), constraints=(/2: [/1 - /1]; /3: [/10.0 - /10.0]; tight), fd=()-->(2,3)]
 │    │         ├── a.f = 10.0 [type=bool, outer=(3), constraints=(/3: [/10.0 - /10.0]; tight)]
 │    │         └── a.i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]
 │    └── projections [outer=(2,3)]
 │         └── a.i / 2 [type=decimal, outer=(2)]
 └── filters [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]
      └── div = 2 [type=bool, outer=(6), constraints=(/6: [/2 - /2]; tight)]

# Detect PushSelectIntoProject and FilterUnusedSelectCols dependency cycle.
opt
SELECT f, f+1.1 AS r FROM (SELECT f, i FROM a GROUP BY f, i HAVING sum(f)=10.0) a
----
project
 ├── columns: f:3(float) r:7(float)
 ├── fd: (3)-->(7)
 ├── select
 │    ├── columns: i:2(int) f:3(float) column6:6(float!null)
 │    ├── key: (2,3)
 │    ├── fd: ()-->(6)
 │    ├── group-by
 │    │    ├── columns: i:2(int) f:3(float) column6:6(float)
 │    │    ├── grouping columns: i:2(int) f:3(float)
 │    │    ├── key: (2,3)
 │    │    ├── fd: (2,3)-->(6)
 │    │    ├── scan a
 │    │    │    └── columns: i:2(int) f:3(float)
 │    │    └── aggregations [outer=(3)]
 │    │         └── sum [type=float, outer=(3)]
 │    │              └── variable: a.f [type=float, outer=(3)]
 │    └── filters [type=bool, outer=(6), constraints=(/6: [/10.0 - /10.0]; tight), fd=()-->(6)]
 │         └── column6 = 10.0 [type=bool, outer=(6), constraints=(/6: [/10.0 - /10.0]; tight)]
 └── projections [outer=(3)]
      └── a.f + 1.1 [type=float, outer=(3)]

# ----------------------------------------------------------
# PushSelectIntoJoinLeftAndRight + MapSelectIntoJoinLeft +
#  MapSelectIntoJoinRight + MergeSelectEqualityJoin
# ----------------------------------------------------------

# Can push to both sides with inner join.
opt
SELECT * FROM a INNER JOIN xy ON true WHERE a.k=xy.x AND a.k + xy.y > 5 AND xy.x * a.i = 3
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(1,2)]
 │         └── (a.k * a.i) = 3 [type=bool, outer=(1,2)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── ordering: +6
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── filters [type=bool, outer=(6,7)]
 │         └── (xy.x + xy.y) > 5 [type=bool, outer=(6,7)]
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Can push to both sides with inner join.
opt
SELECT * FROM a, xy WHERE a.k=xy.x AND a.k > 5 AND xy.x IN (3, 7, 10)
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── constraint: /1: [/7 - /7] [/10 - /10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── ordering: +1
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── constraint: /6: [/7 - /7] [/10 - /10]
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE a.k > 5 AND xy.x IN (3, 7, 10)
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── constraint: /1: [/7 - /7] [/10 - /10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── ordering: +1
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── constraint: /6: [/7 - /7] [/10 - /10]
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Multiple equivalent columns.
# TODO(rytaft): We should also infer the equality predicates a.k=a.i and xy.x=xy.y.
opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x AND a.i=xy.x AND a.i=xy.y WHERE a.f + xy.y::FLOAT > 5 AND a.s || xy.x::STRING = 'foo1'
----
inner-join
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int!null)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1,2), (2)==(6,7), (7)==(2)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters [type=bool, outer=(1,3,4)]
 │         ├── (a.f + a.k::FLOAT) > 5.0 [type=bool, outer=(1,3)]
 │         └── (a.s || a.k::STRING) = 'foo1' [type=bool, outer=(1,4)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters [type=bool, outer=(1,2,6,7), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /6: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(6), (6)==(1,2), (2)==(6,7), (7)==(2)]
      ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
      ├── a.i = xy.x [type=bool, outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
      └── a.i = xy.y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

# Left join: Can only push one filter down to left side.
opt
SELECT * FROM a LEFT JOIN xy ON true WHERE a.k=xy.x AND a.k + xy.y > 5 AND xy.x * a.i = 3
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── left-join
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2-5)
 │    │    └── filters [type=bool, outer=(1,2)]
 │    │         └── (a.k * a.i) = 3 [type=bool, outer=(1,2)]
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6,7), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
      └── (a.k + xy.y) > 5 [type=bool, outer=(1,7)]

# Left join: Can push both filters down.
opt
SELECT * FROM a LEFT JOIN xy ON true WHERE a.k=xy.x AND a.k > 5 AND xy.x IN (3, 7, 10)
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── left-join
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── constraint: /1: [/7 - /7] [/10 - /10]
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── constraint: /6: [/7 - /7] [/10 - /10]
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Right join: Can only push one filter down to right side.
opt
SELECT * FROM a RIGHT JOIN xy ON true WHERE a.k=xy.x AND a.k + xy.y > 5 AND xy.x * a.i = 3
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── right-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── select
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters [type=bool, outer=(6,7)]
 │    │         └── (xy.x + xy.y) > 5 [type=bool, outer=(6,7)]
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,2,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
      └── (xy.x * a.i) = 3 [type=bool, outer=(2,6)]

# Right join: Can push both filters down.
opt
SELECT * FROM a RIGHT JOIN xy ON true WHERE a.k=xy.x AND a.k > 5 AND xy.x IN (3, 7, 10)
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── right-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── constraint: /1: [/7 - /7] [/10 - /10]
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── constraint: /6: [/7 - /7] [/10 - /10]
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Full join: Cannot push either filter down.
opt
SELECT * FROM a FULL JOIN xy ON true WHERE a.k=xy.x AND a.k + xy.y > 5 AND xy.x * a.i = 3
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── full-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,2,6,7), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
      ├── (a.k + xy.y) > 5 [type=bool, outer=(1,7)]
      └── (xy.x * a.i) = 3 [type=bool, outer=(2,6)]

# Full join: Can push both filters down.
opt
SELECT * FROM a FULL JOIN xy ON true WHERE a.k=xy.x AND a.k > 5 AND xy.x IN (3, 7, 10)
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── full-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── constraint: /1: [/7 - /7] [/10 - /10]
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── constraint: /6: [/7 - /7] [/10 - /10]
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Works with a non-correlated subquery.
opt
SELECT * FROM a, xy WHERE a.k = xy.x AND xy.x * a.i = (SELECT min(xy.x) FROM xy)
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(1,2)]
 │         └── eq [type=bool, outer=(1,2)]
 │              ├── a.k * a.i [type=int, outer=(1,2)]
 │              └── subquery [type=int]
 │                   └── group-by
 │                        ├── columns: min:10(int)
 │                        ├── cardinality: [1 - 1]
 │                        ├── key: ()
 │                        ├── fd: ()-->(10)
 │                        ├── scan xy
 │                        │    ├── columns: xy.x:8(int!null)
 │                        │    └── key: (8)
 │                        └── aggregations [outer=(8)]
 │                             └── min [type=int, outer=(8)]
 │                                  └── variable: xy.x [type=int, outer=(8)]
 ├── scan xy
 │    ├── columns: xy.x:6(int!null) xy.y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Optimization does not apply with correlated suqueries.
opt
SELECT * FROM a, xy WHERE a.k = xy.x AND xy.x * a.i = (SELECT min(a.k) FROM xy)
----
project
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 └── inner-join-apply
      ├── columns: a.k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) xy.x:6(int!null) xy.y:7(int) min:11(int)
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (6)-->(7,11)
      ├── scan a
      │    ├── columns: a.k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── group-by
      │    ├── columns: xy.x:6(int!null) xy.y:7(int) min:11(int)
      │    ├── grouping columns: xy.x:6(int!null)
      │    ├── outer: (1)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7,11)
      │    ├── left-join
      │    │    ├── columns: xy.x:6(int!null) xy.y:7(int) k:10(int)
      │    │    ├── outer: (1)
      │    │    ├── fd: (6)-->(7), ()~~>(10)
      │    │    ├── scan xy
      │    │    │    ├── columns: xy.x:6(int!null) xy.y:7(int)
      │    │    │    ├── key: (6)
      │    │    │    └── fd: (6)-->(7)
      │    │    ├── project
      │    │    │    ├── columns: k:10(int)
      │    │    │    ├── outer: (1)
      │    │    │    ├── fd: ()-->(10)
      │    │    │    ├── scan xy
      │    │    │    └── projections [outer=(1)]
      │    │    │         └── variable: a.k [type=int, outer=(1)]
      │    │    └── true [type=bool]
      │    └── aggregations [outer=(7,10)]
      │         ├── min [type=int, outer=(10)]
      │         │    └── variable: k [type=int, outer=(10)]
      │         └── any-not-null [type=int, outer=(7)]
      │              └── variable: xy.y [type=int, outer=(7)]
      └── filters [type=bool, outer=(1,2,6,11), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
           └── (xy.x * a.i) = min [type=bool, outer=(2,6,11)]

# Ensure that we do not map filters for types with composite key encoding.
opt
SELECT * FROM (VALUES (1.0)) AS t1(x), (VALUES (1.00)) AS t2(y) WHERE x=y AND x::text = '1.0'
----
inner-join
 ├── columns: x:1(decimal!null) y:2(decimal!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2)
 ├── select
 │    ├── columns: column1:1(decimal)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1)
 │    ├── values
 │    │    ├── columns: column1:1(decimal)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(1)
 │    │    └── (1.0) [type=tuple{decimal}]
 │    └── filters [type=bool, outer=(1)]
 │         └── column1::TEXT = '1.0' [type=bool, outer=(1)]
 ├── values
 │    ├── columns: column1:2(decimal)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(2)
 │    └── (1.00) [type=tuple{decimal}]
 └── filters [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ])]
      └── column1 = column1 [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ])]

# --------------------------------------------------
# PushSelectIntoJoinLeft
# --------------------------------------------------
opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE a.f=1.1
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), ()-->(3), (6)-->(7), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(3)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight), fd=()-->(3)]
 │         └── a.f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

opt
SELECT * FROM a LEFT JOIN xy ON a.k=xy.x WHERE a.f=1.1 AND a.i<xy.y AND (a.s='foo' OR a.s='bar')
----
select
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string) j:5(jsonb) x:6(int) y:7(int!null)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), ()-->(3), (6)-->(7)
 ├── left-join (merge)
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), ()-->(3), (6)-->(7)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5), ()-->(3)
 │    │    ├── ordering: +1
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2-5)
 │    │    │    └── ordering: +1
 │    │    └── filters [type=bool, outer=(3,4), constraints=(/3: [/1.1 - /1.1]), fd=()-->(3)]
 │    │         ├── a.f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight)]
 │    │         └── (a.s = 'foo') OR (a.s = 'bar') [type=bool, outer=(4)]
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +6
 │         └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │              └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 └── filters [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]
      └── a.i < xy.y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

# Pushdown constant condition.
opt
SELECT * FROM a INNER JOIN xy ON True WHERE a.i=100 AND $1>'2000-01-01T1:00:00'
----
inner-join
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), ()-->(2), (6)-->(7)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(2)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters [type=bool, outer=(2), constraints=(/2: [/100 - /100]), fd=()-->(2)]
 │         ├── $1 > '2000-01-01T1:00:00' [type=bool]
 │         └── a.i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters [type=bool]
 │         └── $1 > '2000-01-01T1:00:00' [type=bool]
 └── true [type=bool]

# Don't push down conditions in case of RIGHT JOIN.
opt
SELECT * FROM a RIGHT JOIN xy ON a.k=xy.x WHERE a.i=100
----
select
 ├── columns: k:1(int) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7), ()-->(2)
 ├── right-join (merge)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +6
 │         └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │              └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 └── filters [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight), fd=()-->(2)]
      └── a.i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight)]

# Don't push down conditions in case of FULL JOIN.
opt
SELECT * FROM a FULL JOIN xy ON a.k=xy.x WHERE a.i=100
----
select
 ├── columns: k:1(int) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7), ()-->(2)
 ├── full-join (merge)
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +6
 │         └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │              └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
 └── filters [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight), fd=()-->(2)]
      └── a.i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight)]

# Push into semi-join.
opt
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE k=x) AND a.i=0
----
semi-join (merge)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5), ()-->(2), (1)==(6), (6)==(1) [removed: (6)]
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(2)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]
 │         └── a.i = 0 [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Push into anti-join.
opt
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE k=x) AND a.i=0
----
anti-join (merge)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 ├── key: (1)
 ├── fd: (1)-->(2-5), ()-->(2)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(2)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight), fd=()-->(2)]
 │         └── a.i = 0 [type=bool, outer=(2), constraints=(/2: [/0 - /0]; tight)]
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# --------------------------------------------------
# PushSelectIntoJoinRight
# --------------------------------------------------
opt
SELECT * FROM xy INNER JOIN a ON xy.x=a.k WHERE a.f=1.1
----
inner-join (merge)
 ├── columns: x:1(int!null) y:2(int) k:3(int!null) i:4(int) f:5(float!null) s:6(string) j:7(jsonb)
 ├── key: (3)
 ├── fd: (1)-->(2), (3)-->(4-7), ()-->(5), (1)==(3), (3)==(1)
 ├── scan xy
 │    ├── columns: x:1(int!null) y:2(int)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 ├── select
 │    ├── columns: k:3(int!null) i:4(int) f:5(float!null) s:6(string) j:7(jsonb)
 │    ├── key: (3)
 │    ├── fd: (3)-->(4-7), ()-->(5)
 │    ├── ordering: +3
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4-7)
 │    │    └── ordering: +3
 │    └── filters [type=bool, outer=(5), constraints=(/5: [/1.1 - /1.1]; tight), fd=()-->(5)]
 │         └── a.f = 1.1 [type=bool, outer=(5), constraints=(/5: [/1.1 - /1.1]; tight)]
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +3
      └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
           └── xy.x = a.k [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]

opt
SELECT * FROM xy RIGHT JOIN a ON xy.x=a.k WHERE a.f=1.1 AND a.i<xy.y AND (a.s='foo' OR a.s='bar')
----
select
 ├── columns: x:1(int) y:2(int!null) k:3(int!null) i:4(int!null) f:5(float!null) s:6(string) j:7(jsonb)
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4-7), ()-->(5)
 ├── right-join (merge)
 │    ├── columns: x:1(int) y:2(int) k:3(int!null) i:4(int) f:5(float!null) s:6(string) j:7(jsonb)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4-7), ()-->(5)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── ordering: +1
 │    ├── select
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float!null) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4-7), ()-->(5)
 │    │    ├── ordering: +3
 │    │    ├── scan a
 │    │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    │    ├── key: (3)
 │    │    │    ├── fd: (3)-->(4-7)
 │    │    │    └── ordering: +3
 │    │    └── filters [type=bool, outer=(5,6), constraints=(/5: [/1.1 - /1.1]), fd=()-->(5)]
 │    │         ├── a.f = 1.1 [type=bool, outer=(5), constraints=(/5: [/1.1 - /1.1]; tight)]
 │    │         └── (a.s = 'foo') OR (a.s = 'bar') [type=bool, outer=(6)]
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +3
 │         └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 │              └── xy.x = a.k [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
 └── filters [type=bool, outer=(2,4), constraints=(/2: (/NULL - ]; /4: (/NULL - ])]
      └── a.i < xy.y [type=bool, outer=(2,4), constraints=(/2: (/NULL - ]; /4: (/NULL - ])]

# Don't push down conditions in case of LEFT JOIN.
opt
SELECT * FROM xy LEFT JOIN a ON a.k=xy.x WHERE a.i=100
----
select
 ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int!null) f:5(float) s:6(string) j:7(jsonb)
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4-7), ()-->(4)
 ├── left-join (merge)
 │    ├── columns: x:1(int!null) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4-7)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4-7)
 │    │    └── ordering: +3
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +3
 │         └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(3)==(1), (1)==(3)]
 │              └── a.k = xy.x [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
 └── filters [type=bool, outer=(4), constraints=(/4: [/100 - /100]; tight), fd=()-->(4)]
      └── a.i = 100 [type=bool, outer=(4), constraints=(/4: [/100 - /100]; tight)]

# Don't push down conditions in case of FULL JOIN.
opt
SELECT * FROM xy FULL JOIN a ON a.k=xy.x WHERE a.i=100
----
select
 ├── columns: x:1(int) y:2(int) k:3(int) i:4(int!null) f:5(float) s:6(string) j:7(jsonb)
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4-7), ()-->(4)
 ├── full-join (merge)
 │    ├── columns: x:1(int) y:2(int) k:3(int) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4-7)
 │    ├── scan xy
 │    │    ├── columns: x:1(int!null) y:2(int)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:3(int!null) i:4(int) f:5(float) s:6(string) j:7(jsonb)
 │    │    ├── key: (3)
 │    │    ├── fd: (3)-->(4-7)
 │    │    └── ordering: +3
 │    └── merge-on
 │         ├── left ordering: +1
 │         ├── right ordering: +3
 │         └── filters [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(3)==(1), (1)==(3)]
 │              └── a.k = xy.x [type=bool, outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ])]
 └── filters [type=bool, outer=(4), constraints=(/4: [/100 - /100]; tight), fd=()-->(4)]
      └── a.i = 100 [type=bool, outer=(4), constraints=(/4: [/100 - /100]; tight)]

# --------------------------------------------------
# MergeSelectInnerJoin
# --------------------------------------------------
opt
SELECT * FROM a, xy WHERE a.k=xy.x AND (a.s='foo' OR xy.y<100)
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── ordering: +1
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,4,6,7), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
           └── (a.s = 'foo') OR (xy.y < 100) [type=bool, outer=(4,7)]

opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE (a.s='foo' OR xy.y<100)
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── ordering: +1
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    └── ordering: +6
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,4,6,7), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
           └── (a.s = 'foo') OR (xy.y < 100) [type=bool, outer=(4,7)]

opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE False
----
inner-join
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (6)-->(7)
 ├── scan a
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── false [type=bool]

# Don't merge with LEFT JOIN.
opt
SELECT * FROM a LEFT JOIN xy ON True WHERE a.k=xy.x
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── left-join
 │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Don't merge with RIGHT JOIN.
opt
SELECT * FROM a RIGHT JOIN xy ON True WHERE a.k=xy.x
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── right-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# Don't merge with FULL JOIN.
opt
SELECT * FROM a FULL JOIN xy ON True WHERE a.k=xy.x
----
select
 ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── full-join
 │    ├── columns: k:1(int) i:2(int) f:3(float) s:4(string) j:5(jsonb) x:6(int) y:7(int)
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (6)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── true [type=bool]
 └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      └── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# --------------------------------------------------
# PushSelectIntoJoinLeft + PushSelectIntoJoinRight + MergeSelectInnerJoin
# --------------------------------------------------
opt
SELECT * FROM a INNER JOIN xy ON a.k=xy.x WHERE a.f=1.1 AND s='foo' AND xy.y=10 AND a.i<xy.y
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float!null) s:4(string!null) j:5(jsonb) x:6(int!null) y:7(int!null)
 ├── key: (6)
 ├── fd: (1)-->(2-5), ()-->(3,4), ()-->(7), (1)==(6), (6)==(1)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int) f:3(float!null) s:4(string!null) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(3,4)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(3,4), constraints=(/3: [/1.1 - /1.1]; /4: [/'foo' - /'foo']; tight), fd=()-->(3,4)]
 │         ├── a.f = 1.1 [type=bool, outer=(3), constraints=(/3: [/1.1 - /1.1]; tight)]
 │         └── a.s = 'foo' [type=bool, outer=(4), constraints=(/4: [/'foo' - /'foo']; tight)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int!null)
 │    ├── key: (6)
 │    ├── fd: ()-->(7)
 │    ├── ordering: +6
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── filters [type=bool, outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
 │         └── xy.y = 10 [type=bool, outer=(7), constraints=(/7: [/10 - /10]; tight)]
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,2,6,7), constraints=(/1: (/NULL - ]; /2: (/NULL - ]; /6: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(6), (6)==(1)]
           ├── a.k = xy.x [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]
           └── a.i < xy.y [type=bool, outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

opt
SELECT * FROM a, xy WHERE a.i=100 AND $1>'2000-01-01T1:00:00' AND xy.x=a.k
----
inner-join (merge)
 ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb) x:6(int!null) y:7(int)
 ├── key: (6)
 ├── fd: (1)-->(2-5), ()-->(2), (6)-->(7), (6)==(1), (1)==(6)
 ├── select
 │    ├── columns: k:1(int!null) i:2(int!null) f:3(float) s:4(string) j:5(jsonb)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5), ()-->(2)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1(int!null) i:2(int) f:3(float) s:4(string) j:5(jsonb)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── ordering: +1
 │    └── filters [type=bool, outer=(2), constraints=(/2: [/100 - /100]), fd=()-->(2)]
 │         ├── $1 > '2000-01-01T1:00:00' [type=bool]
 │         └── a.i = 100 [type=bool, outer=(2), constraints=(/2: [/100 - /100]; tight)]
 ├── select
 │    ├── columns: x:6(int!null) y:7(int)
 │    ├── key: (6)
 │    ├── fd: (6)-->(7)
 │    ├── ordering: +6
 │    ├── scan xy
 │    │    ├── columns: x:6(int!null) y:7(int)
 │    │    ├── key: (6)
 │    │    ├── fd: (6)-->(7)
 │    │    └── ordering: +6
 │    └── filters [type=bool]
 │         └── $1 > '2000-01-01T1:00:00' [type=bool]
 └── merge-on
      ├── left ordering: +1
      ├── right ordering: +6
      └── filters [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(6)==(1), (1)==(6)]
           └── xy.x = a.k [type=bool, outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ])]

# --------------------------------------------------
# PushSelectIntoGroupBy
# --------------------------------------------------

# Push down into GroupBy with aggregations.
opt
SELECT * FROM (SELECT i, count(*) FROM a GROUP BY i) a WHERE i=1
----
group-by
 ├── columns: i:2(int!null) count:6(int)
 ├── grouping columns: i:2(int!null)
 ├── key: ()
 ├── fd: ()-->(2,6)
 ├── select
 │    ├── columns: i:2(int!null)
 │    ├── fd: ()-->(2)
 │    ├── scan a
 │    │    └── columns: i:2(int)
 │    └── filters [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 │         └── a.i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]
 └── aggregations
      └── count-rows [type=int]

# Push down into GroupBy with no aggregations.
opt
SELECT * FROM (SELECT i FROM a GROUP BY i) a WHERE i=1
----
group-by
 ├── columns: i:2(int!null)
 ├── grouping columns: i:2(int!null)
 ├── key: ()
 ├── fd: ()-->(2)
 └── select
      ├── columns: i:2(int!null)
      ├── fd: ()-->(2)
      ├── scan a
      │    └── columns: i:2(int)
      └── filters [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
           └── a.i = 1 [type=bool, outer=(2), constraints=(/2: [/1 - /1]; tight)]

# Push down only conditions that do not depend on aggregations.
opt
SELECT * FROM (SELECT k, i, max(s) m FROM a GROUP BY k, i) a WHERE i=k AND m='foo'
----
select
 ├── columns: k:1(int!null) i:2(int!null) m:6(string!null)
 ├── key: (1)
 ├── fd: (1)-->(2), (2)==(1), (1)==(2), (2)-->(1,6), ()-->(6)
 ├── group-by
 │    ├── columns: k:1(int!null) i:2(int!null) m:6(string)
 │    ├── grouping columns: k:1(int!null) i:2(int!null)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2), (2)==(1), (1)==(2), (2)-->(1,6)
 │    ├── select
 │    │    ├── columns: k:1(int!null) i:2(int!null) s:4(string)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,4), (2)==(1), (1)==(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1(int!null) i:2(int) s:4(string)
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2,4)
 │    │    └── filters [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(2)==(1), (1)==(2)]
 │    │         └── a.i = a.k [type=bool, outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ])]
 │    └── aggregations [outer=(4)]
 │         └── max [type=string, outer=(4)]
 │              └── variable: a.s [type=string, outer=(4)]
 └── filters [type=bool, outer=(6), constraints=(/6: [/'foo' - /'foo']; tight), fd=()-->(6)]
      └── m = 'foo' [type=bool, outer=(6), constraints=(/6: [/'foo' - /'foo']; tight)]

# Do *not* push down into scalar GroupBy.
opt
SELECT * FROM (SELECT count(*) c FROM a) a WHERE $1<'2000-01-01T10:00:00' AND c=0
----
select
 ├── columns: c:6(int!null)
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(6)
 ├── group-by
 │    ├── columns: c:6(int)
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(6)
 │    ├── scan a
 │    └── aggregations
 │         └── count-rows [type=int]
 └── filters [type=bool, outer=(6), constraints=(/6: [/0 - /0]), fd=()-->(6)]
      ├── $1 < '2000-01-01T10:00:00' [type=bool]
      └── c = 0 [type=bool, outer=(6), constraints=(/6: [/0 - /0]; tight)]

# --------------------------------------------------
# RemoveNotNullCondition
# --------------------------------------------------
exec-ddl
CREATE TABLE b (k INT PRIMARY KEY, i INT, f FLOAT, s STRING NOT NULL, j JSON)
----
TABLE b
 ├── k int not null
 ├── i int
 ├── f float
 ├── s string not null
 ├── j jsonb
 └── INDEX primary
      └── k int not null

opt
SELECT k FROM b WHERE k IS NOT NULL AND k > 4
----
scan b
 ├── columns: k:1(int!null)
 ├── constraint: /1: [/5 - ]
 └── key: (1)

opt
SELECT k FROM b WHERE k IS NULL
----
scan b
 ├── columns: k:1(int!null)
 ├── constraint: /1: contradiction
 ├── key: ()
 └── fd: ()-->(1)

opt
SELECT k,i FROM b WHERE k IS NOT NULL AND k > 4 AND i < 100 AND i IS NOT NULL
----
select
 ├── columns: k:1(int!null) i:2(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan b
 │    ├── columns: k:1(int!null) i:2(int)
 │    ├── constraint: /1: [/5 - ]
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - /99]; tight)]
      ├── b.i < 100 [type=bool, outer=(2), constraints=(/2: (/NULL - /99]; tight)]
      └── b.i IS NOT NULL [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]

opt
SELECT k,s FROM b WHERE k IS NOT NULL AND s IS NOT NULL
----
scan b
 ├── columns: k:1(int!null) s:4(string!null)
 ├── key: (1)
 └── fd: (1)-->(4)

# RemoveNotNullCondition partially applied
opt
SELECT k,s,i FROM b WHERE k IS NOT NULL AND s IS NOT NULL AND i IS NOT NULL
----
select
 ├── columns: k:1(int!null) s:4(string!null) i:2(int!null)
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── scan b
 │    ├── columns: k:1(int!null) i:2(int) s:4(string!null)
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
      └── b.i IS NOT NULL [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]

# RemoveNotNullCondition rule is not applied
opt
SELECT i FROM b WHERE i IS NOT NULL
----
select
 ├── columns: i:2(int!null)
 ├── scan b
 │    └── columns: i:2(int)
 └── filters [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]
      └── b.i IS NOT NULL [type=bool, outer=(2), constraints=(/2: (/NULL - ]; tight)]

# RemoveNotNullCondition rule is not applied
opt
SELECT k FROM b WHERE i+k IS NOT NULL
----
project
 ├── columns: k:1(int!null)
 ├── key: (1)
 └── select
      ├── columns: k:1(int!null) i:2(int)
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan b
      │    ├── columns: k:1(int!null) i:2(int)
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters [type=bool, outer=(1,2)]
           └── (b.i + b.k) IS NOT NULL [type=bool, outer=(1,2)]
