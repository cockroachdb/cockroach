exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----

exec-ddl
CREATE TABLE b (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE ab (a INT PRIMARY KEY, b INT)
----

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----

exec-ddl
CREATE TABLE kvr_fk(k INT PRIMARY KEY, v INT, r INT NOT NULL REFERENCES uv(u))
----

# --------------------------------------------------
# EliminateLimit
# --------------------------------------------------
norm expect=EliminateLimit
SELECT * FROM (SELECT * FROM a LIMIT 99) LIMIT 100
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 99]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── limit hint: 99.00
 └── 99

norm expect=EliminateLimit
SELECT * FROM (SELECT * FROM a LIMIT 100) LIMIT 100
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 100]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── limit hint: 100.00
 └── 100

# Don't eliminate the outer limit if it's less than the inner (the limit is
# instead removed by FoldLimits).
norm expect-not=EliminateLimit
SELECT * FROM (SELECT * FROM a LIMIT 100) LIMIT 99
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 99]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── limit hint: 99.00
 └── 99

# High limits (> max uint32), can't eliminate in this case.
norm expect-not=EliminateLimit
SELECT * FROM (SELECT * FROM a LIMIT 5000000000) LIMIT 5100000000
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── limit hint: 5100000000.00
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── limit hint: 5000000000.00
 │    └── 5000000000
 └── 5100000000

# Don't eliminate in case of negative limit (the limit is instead removed by
# FoldLimits).
norm expect-not=EliminateLimit
SELECT * FROM (SELECT * FROM a LIMIT 0) LIMIT -1
----
limit
 ├── columns: k:1!null i:2!null f:3!null s:4!null j:5!null
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── values
 │    ├── columns: k:1!null i:2!null f:3!null s:4!null j:5!null
 │    ├── cardinality: [0 - 0]
 │    ├── key: ()
 │    ├── fd: ()-->(1-5)
 │    └── limit hint: 1.00
 └── -1

# --------------------------------------------------
# EliminateOffset
# --------------------------------------------------
norm expect=EliminateOffset
SELECT * FROM an OFFSET 0
----
error (42P01): no data source matches prefix: "an"

norm expect=EliminateOffset
SELECT * FROM a LIMIT 5 OFFSET 0
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── limit hint: 5.00
 └── 5

norm expect-not=EliminateOffset
SELECT * FROM a LIMIT 5 OFFSET 1
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 6]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5)
 │    │    └── limit hint: 6.00
 │    └── 6
 └── 1

# --------------------------------------------------
# PushLimitIntoProject
# --------------------------------------------------
norm expect=PushLimitIntoProject
SELECT k, f*2.0 AS r FROM a LIMIT 5
----
project
 ├── columns: k:1!null r:8
 ├── cardinality: [0 - 5]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── limit
 │    ├── columns: k:1!null f:3
 │    ├── cardinality: [0 - 5]
 │    ├── key: (1)
 │    ├── fd: (1)-->(3)
 │    ├── scan a
 │    │    ├── columns: k:1!null f:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(3)
 │    │    └── limit hint: 5.00
 │    └── 5
 └── projections
      └── f:3 * 2.0 [as=r:8, outer=(3), immutable]

norm expect=PushLimitIntoProject
SELECT k, f*2.0 AS r FROM a ORDER BY k LIMIT 5
----
project
 ├── columns: k:1!null r:8
 ├── cardinality: [0 - 5]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── ordering: +1
 ├── limit
 │    ├── columns: k:1!null f:3
 │    ├── internal-ordering: +1
 │    ├── cardinality: [0 - 5]
 │    ├── key: (1)
 │    ├── fd: (1)-->(3)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1!null f:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(3)
 │    │    ├── ordering: +1
 │    │    └── limit hint: 5.00
 │    └── 5
 └── projections
      └── f:3 * 2.0 [as=r:8, outer=(3), immutable]

# Don't push the limit through project when the ordering is on a
# synthesized column.
norm expect-not=PushLimitIntoProject
SELECT k, f*2.0 AS r FROM a ORDER BY r LIMIT 5
----
limit
 ├── columns: k:1!null r:8
 ├── internal-ordering: +8
 ├── cardinality: [0 - 5]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── ordering: +8
 ├── sort
 │    ├── columns: k:1!null r:8
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(8)
 │    ├── ordering: +8
 │    ├── limit hint: 5.00
 │    └── project
 │         ├── columns: r:8 k:1!null
 │         ├── immutable
 │         ├── key: (1)
 │         ├── fd: (1)-->(8)
 │         ├── scan a
 │         │    ├── columns: k:1!null f:3
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3)
 │         └── projections
 │              └── f:3 * 2.0 [as=r:8, outer=(3), immutable]
 └── 5


# Detect PushLimitIntoProject and FilterUnusedLimitCols dependency cycle.
norm
SELECT f, f+1.1 AS r FROM (SELECT f, i FROM a GROUP BY f, i) a ORDER BY f LIMIT 5
----
project
 ├── columns: f:3 r:8
 ├── cardinality: [0 - 5]
 ├── immutable
 ├── fd: (3)-->(8)
 ├── ordering: +3
 ├── limit
 │    ├── columns: i:2 f:3
 │    ├── internal-ordering: +3
 │    ├── cardinality: [0 - 5]
 │    ├── key: (2,3)
 │    ├── ordering: +3
 │    ├── distinct-on
 │    │    ├── columns: i:2 f:3
 │    │    ├── grouping columns: i:2 f:3
 │    │    ├── key: (2,3)
 │    │    ├── ordering: +3
 │    │    ├── limit hint: 5.00
 │    │    └── sort
 │    │         ├── columns: i:2 f:3
 │    │         ├── ordering: +3
 │    │         ├── limit hint: 6.02
 │    │         └── scan a
 │    │              └── columns: i:2 f:3
 │    └── 5
 └── projections
      └── f:3 + 1.1 [as=r:8, outer=(3), immutable]

# Don't push negative limit into Scan.
norm
SELECT * FROM a LIMIT -1
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    └── limit hint: 1.00
 └── -1

# --------------------------------------------------
# PushOffsetIntoProject
# --------------------------------------------------
norm expect=PushOffsetIntoProject
SELECT k, f*2.0 AS r FROM an OFFSET 5
----
error (42P01): no data source matches prefix: "an"

norm expect=PushOffsetIntoProject
SELECT k, f*2.0 AS r FROM a ORDER BY k OFFSET 5
----
project
 ├── columns: k:1!null r:8
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── ordering: +1
 ├── offset
 │    ├── columns: k:1!null f:3
 │    ├── internal-ordering: +1
 │    ├── key: (1)
 │    ├── fd: (1)-->(3)
 │    ├── ordering: +1
 │    ├── scan a
 │    │    ├── columns: k:1!null f:3
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(3)
 │    │    └── ordering: +1
 │    └── 5
 └── projections
      └── f:3 * 2.0 [as=r:8, outer=(3), immutable]

# Don't push the offset through project when the ordering is on a
# synthesized column.
norm expect-not=PushOffsetIntoProject
SELECT k, f*2.0 AS r FROM a ORDER BY r OFFSET 5
----
offset
 ├── columns: k:1!null r:8
 ├── internal-ordering: +8
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(8)
 ├── ordering: +8
 ├── sort
 │    ├── columns: k:1!null r:8
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(8)
 │    ├── ordering: +8
 │    └── project
 │         ├── columns: r:8 k:1!null
 │         ├── immutable
 │         ├── key: (1)
 │         ├── fd: (1)-->(8)
 │         ├── scan a
 │         │    ├── columns: k:1!null f:3
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(3)
 │         └── projections
 │              └── f:3 * 2.0 [as=r:8, outer=(3), immutable]
 └── 5

# Detect PushOffsetIntoProject and FilterUnusedOffsetCols dependency cycle.
norm
SELECT f, f+1.1 AS r FROM (SELECT f, i FROM a GROUP BY f, i) a ORDER BY f OFFSET 5
----
project
 ├── columns: f:3 r:8
 ├── immutable
 ├── fd: (3)-->(8)
 ├── ordering: +3
 ├── offset
 │    ├── columns: i:2 f:3
 │    ├── internal-ordering: +3
 │    ├── key: (2,3)
 │    ├── ordering: +3
 │    ├── sort
 │    │    ├── columns: i:2 f:3
 │    │    ├── key: (2,3)
 │    │    ├── ordering: +3
 │    │    └── distinct-on
 │    │         ├── columns: i:2 f:3
 │    │         ├── grouping columns: i:2 f:3
 │    │         ├── key: (2,3)
 │    │         └── scan a
 │    │              └── columns: i:2 f:3
 │    └── 5
 └── projections
      └── f:3 + 1.1 [as=r:8, outer=(3), immutable]

# --------------------------------------------------
# PushLimitIntoProject + PushOffsetIntoProject
# --------------------------------------------------
norm expect=(PushLimitIntoProject,PushOffsetIntoProject)
SELECT k, f*2.0 AS r FROM an OFFSET 5 LIMIT 10
----
error (42P01): no data source matches prefix: "an"

norm expect=(PushLimitIntoProject,PushOffsetIntoProject)
SELECT f, f+1.1 AS r FROM (SELECT f, i FROM a GROUP BY f, i) a ORDER BY f OFFSET 5 LIMIT 10
----
project
 ├── columns: f:3 r:8
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── fd: (3)-->(8)
 ├── ordering: +3
 ├── offset
 │    ├── columns: i:2 f:3
 │    ├── internal-ordering: +3
 │    ├── cardinality: [0 - 10]
 │    ├── key: (2,3)
 │    ├── ordering: +3
 │    ├── limit
 │    │    ├── columns: i:2 f:3
 │    │    ├── internal-ordering: +3
 │    │    ├── cardinality: [0 - 15]
 │    │    ├── key: (2,3)
 │    │    ├── ordering: +3
 │    │    ├── distinct-on
 │    │    │    ├── columns: i:2 f:3
 │    │    │    ├── grouping columns: i:2 f:3
 │    │    │    ├── key: (2,3)
 │    │    │    ├── ordering: +3
 │    │    │    ├── limit hint: 15.00
 │    │    │    └── sort
 │    │    │         ├── columns: i:2 f:3
 │    │    │         ├── ordering: +3
 │    │    │         ├── limit hint: 18.16
 │    │    │         └── scan a
 │    │    │              └── columns: i:2 f:3
 │    │    └── 15
 │    └── 5
 └── projections
      └── f:3 + 1.1 [as=r:8, outer=(3), immutable]

# --------------------------------------------------
# PushLimitIntoOffset
# --------------------------------------------------

norm expect=PushLimitIntoOffset
SELECT k, i FROM a LIMIT 10 OFFSET 10
----
offset
 ├── columns: k:1!null i:2
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── limit
 │    ├── columns: k:1!null i:2
 │    ├── cardinality: [0 - 20]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── limit hint: 20.00
 │    └── 20
 └── 10

norm expect=(PushLimitIntoOffset)
SELECT k, i FROM an OFFSET 10 LIMIT 10
----
error (42P01): no data source matches prefix: "an"

# Limit can be pushed into the ordering if they have the same ordering.
norm expect=PushLimitIntoOffset
SELECT k, i FROM (SELECT k, i FROM a ORDER BY i OFFSET 20) ORDER BY i LIMIT 10
----
offset
 ├── columns: k:1!null i:2
 ├── internal-ordering: +2
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── ordering: +2
 ├── limit
 │    ├── columns: k:1!null i:2
 │    ├── internal-ordering: +2
 │    ├── cardinality: [0 - 30]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── ordering: +2
 │    ├── sort
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── ordering: +2
 │    │    ├── limit hint: 30.00
 │    │    └── scan a
 │    │         ├── columns: k:1!null i:2
 │    │         ├── key: (1)
 │    │         └── fd: (1)-->(2)
 │    └── 30
 └── 20

norm expect-not=PushLimitIntoOffset
SELECT k, i FROM (SELECT k, i FROM a ORDER BY i OFFSET 20) ORDER BY i DESC LIMIT 10
----
limit
 ├── columns: k:1!null i:2
 ├── internal-ordering: -2
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── ordering: -2
 ├── sort
 │    ├── columns: k:1!null i:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── ordering: -2
 │    ├── limit hint: 10.00
 │    └── offset
 │         ├── columns: k:1!null i:2
 │         ├── internal-ordering: +2
 │         ├── key: (1)
 │         ├── fd: (1)-->(2)
 │         ├── sort
 │         │    ├── columns: k:1!null i:2
 │         │    ├── key: (1)
 │         │    ├── fd: (1)-->(2)
 │         │    ├── ordering: +2
 │         │    └── scan a
 │         │         ├── columns: k:1!null i:2
 │         │         ├── key: (1)
 │         │         └── fd: (1)-->(2)
 │         └── 20
 └── 10

# Using MaxInt64. Do not apply rule when sum overflows.
norm expect-not=PushLimitIntoOffset
SELECT k, i FROM a LIMIT 9223372036854775807 OFFSET 9223372036854775807
----
limit
 ├── columns: k:1!null i:2
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── offset
 │    ├── columns: k:1!null i:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── limit hint: 9223372036854775808.00
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── limit hint: 18446744073709551616.00
 │    └── 9223372036854775807
 └── 9223372036854775807

# --------------------------------------------------
# PushLimitIntoOrdinality
# --------------------------------------------------

norm expect=PushLimitIntoOrdinality
SELECT * FROM (SELECT * FROM a ORDER BY k) WITH ORDINALITY LIMIT 10
----
ordinality
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 └── limit
      ├── columns: k:1!null i:2 f:3 s:4 j:5
      ├── internal-ordering: +1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── ordering: +1
      │    └── limit hint: 10.00
      └── 10

norm expect=PushLimitIntoOrdinality
SELECT * FROM a WITH ORDINALITY ORDER BY k LIMIT 10
----
sort
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +1
 └── ordinality
      ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5,8), (8)-->(1-5)
      └── limit
           ├── columns: k:1!null i:2 f:3 s:4 j:5
           ├── internal-ordering: +1
           ├── cardinality: [0 - 10]
           ├── key: (1)
           ├── fd: (1)-->(2-5)
           ├── scan a
           │    ├── columns: k:1!null i:2 f:3 s:4 j:5
           │    ├── key: (1)
           │    ├── fd: (1)-->(2-5)
           │    ├── ordering: +1
           │    └── limit hint: 10.00
           └── 10


# More complex example of an intersection:
# +(i|f) +s and +f have the intersection +(i|f) +s
norm expect=PushLimitIntoOrdinality
SELECT * FROM (SELECT * FROM a WHERE i=f ORDER BY i, s) WITH ORDINALITY ORDER BY f LIMIT 10
----
ordinality
 ├── columns: k:1!null i:2!null f:3!null s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5), (2)==(3), (3)==(2)
 ├── ordering: +(2|3) [actual: +2]
 └── limit
      ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      ├── internal-ordering: +(2|3),+4
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      ├── ordering: +(2|3),+4 [actual: +2,+4]
      ├── sort
      │    ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      │    ├── ordering: +(2|3),+4 [actual: +2,+4]
      │    ├── limit hint: 10.00
      │    └── select
      │         ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      │         ├── key: (1)
      │         ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      │         ├── scan a
      │         │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │         │    ├── key: (1)
      │         │    └── fd: (1)-->(2-5)
      │         └── filters
      │              └── i:2 = f:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]
      └── 10

norm expect-not=PushLimitIntoOrdinality
SELECT * FROM (SELECT * FROM a ORDER BY k) WITH ORDINALITY ORDER BY i LIMIT 10
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── internal-ordering: +2
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +2
 ├── sort
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │    ├── ordering: +2
 │    ├── limit hint: 10.00
 │    └── ordinality
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │         └── scan a
 │              ├── columns: k:1!null i:2 f:3 s:4 j:5
 │              ├── key: (1)
 │              ├── fd: (1)-->(2-5)
 │              └── ordering: +1
 └── 10

norm expect-not=PushLimitIntoOrdinality
SELECT * FROM (SELECT * FROM a WITH ORDINALITY) ORDER BY ordinality LIMIT 10
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── internal-ordering: +8
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +8
 ├── ordinality
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │    ├── ordering: +8
 │    ├── limit hint: 10.00
 │    └── scan a
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-5)
 │         └── limit hint: 10.00
 └── 10

# --------------------------------------------------
# PushOffsetIntoOrdinality
# --------------------------------------------------

norm expect=PushOffsetIntoOrdinality
SELECT * FROM (SELECT * FROM a ORDER BY k) WITH ORDINALITY OFFSET 10
----
ordinality
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 └── offset
      ├── columns: k:1!null i:2 f:3 s:4 j:5
      ├── internal-ordering: +1
      ├── key: (1)
      ├── fd: (1)-->(2-5)
      ├── ordering: +1
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    └── ordering: +1
      └── 10

norm expect=PushOffsetIntoOrdinality
SELECT * FROM (SELECT * FROM a ORDER BY k) WITH ORDINALITY LIMIT 10 OFFSET 10
----
ordinality
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 └── offset
      ├── columns: k:1!null i:2 f:3 s:4 j:5
      ├── internal-ordering: +1
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5)
      ├── ordering: +1
      ├── limit
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── internal-ordering: +1
      │    ├── cardinality: [0 - 20]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── ordering: +1
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5)
      │    │    ├── ordering: +1
      │    │    └── limit hint: 20.00
      │    └── 20
      └── 10

norm expect=PushOffsetIntoOrdinality
SELECT * FROM a WITH ORDINALITY ORDER BY k LIMIT 10 OFFSET 5
----
sort
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +1
 └── ordinality
      ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5,8), (8)-->(1-5)
      └── offset
           ├── columns: k:1!null i:2 f:3 s:4 j:5
           ├── internal-ordering: +1
           ├── cardinality: [0 - 10]
           ├── key: (1)
           ├── fd: (1)-->(2-5)
           ├── limit
           │    ├── columns: k:1!null i:2 f:3 s:4 j:5
           │    ├── internal-ordering: +1
           │    ├── cardinality: [0 - 15]
           │    ├── key: (1)
           │    ├── fd: (1)-->(2-5)
           │    ├── ordering: +1
           │    ├── scan a
           │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
           │    │    ├── key: (1)
           │    │    ├── fd: (1)-->(2-5)
           │    │    ├── ordering: +1
           │    │    └── limit hint: 15.00
           │    └── 15
           └── 5

norm expect=PushOffsetIntoOrdinality
SELECT * FROM (SELECT * FROM a WHERE i=f ORDER BY i, s) WITH ORDINALITY ORDER BY f LIMIT 10 OFFSET 3
----
ordinality
 ├── columns: k:1!null i:2!null f:3!null s:4 j:5 ordinality:8!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5), (2)==(3), (3)==(2)
 ├── ordering: +(2|3) [actual: +2]
 └── offset
      ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      ├── internal-ordering: +(2|3),+4
      ├── cardinality: [0 - 10]
      ├── key: (1)
      ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      ├── ordering: +(2|3),+4 [actual: +2,+4]
      ├── limit
      │    ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      │    ├── internal-ordering: +(2|3),+4
      │    ├── cardinality: [0 - 13]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      │    ├── ordering: +(2|3),+4 [actual: +2,+4]
      │    ├── sort
      │    │    ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      │    │    ├── ordering: +(2|3),+4 [actual: +2,+4]
      │    │    ├── limit hint: 13.00
      │    │    └── select
      │    │         ├── columns: k:1!null i:2!null f:3!null s:4 j:5
      │    │         ├── key: (1)
      │    │         ├── fd: (1)-->(2-5), (2)==(3), (3)==(2)
      │    │         ├── scan a
      │    │         │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │         │    ├── key: (1)
      │    │         │    └── fd: (1)-->(2-5)
      │    │         └── filters
      │    │              └── i:2 = f:3 [outer=(2,3), constraints=(/2: (/NULL - ]; /3: (/NULL - ]), fd=(2)==(3), (3)==(2)]
      │    └── 13
      └── 3

norm expect-not=PushOffsetIntoOrdinality
SELECT * FROM (SELECT * FROM a ORDER BY k) WITH ORDINALITY ORDER BY i OFFSET 10
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── internal-ordering: +2
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +2
 ├── sort
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │    ├── ordering: +2
 │    └── ordinality
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │         └── scan a
 │              ├── columns: k:1!null i:2 f:3 s:4 j:5
 │              ├── key: (1)
 │              ├── fd: (1)-->(2-5)
 │              └── ordering: +1
 └── 10

norm expect-not=PushOffsetIntoOrdinality
SELECT * FROM (SELECT * FROM a WITH ORDINALITY) ORDER BY ordinality LIMIT 10 OFFSET 5
----
offset
 ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 ├── internal-ordering: +8
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 ├── ordering: +8
 ├── limit
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │    ├── internal-ordering: +8
 │    ├── cardinality: [0 - 15]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │    ├── ordering: +8
 │    ├── ordinality
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 ordinality:8!null
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-5,8), (8)-->(1-5)
 │    │    ├── ordering: +8
 │    │    ├── limit hint: 15.00
 │    │    └── scan a
 │    │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │         ├── key: (1)
 │    │         ├── fd: (1)-->(2-5)
 │    │         └── limit hint: 15.00
 │    └── 15
 └── 5

# ------------------------------------------------
# PushLimitIntoJoinLeft and PushLimitIntoJoinRight
# ------------------------------------------------

# InnerJoin case.
norm expect=PushLimitIntoJoinLeft
SELECT * FROM kvr_fk INNER JOIN uv ON r = u LIMIT 10
----
inner-join (hash)
 ├── columns: k:1!null v:2 r:3!null u:6!null v:7
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (6)-->(7), (3)==(6), (6)==(3)
 ├── limit
 │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── scan kvr_fk
 │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    └── limit hint: 10.00
 │    └── 10
 ├── scan uv
 │    ├── columns: u:6!null uv.v:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── r:3 = u:6 [outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]

# LeftJoin case.
norm expect=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u LIMIT 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── limit
 │    ├── columns: a:1!null b:2
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── limit hint: 10.00
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# InnerJoin case for PushLimitIntoJoinRight.
norm expect=PushLimitIntoJoinRight
SELECT * FROM uv INNER JOIN kvr_fk ON u = r LIMIT 10
----
inner-join (hash)
 ├── columns: u:1!null v:2 k:5!null v:6 r:7!null
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(zero-or-more), right-rows(exactly-one)
 ├── key: (5)
 ├── fd: (1)-->(2), (5)-->(6,7), (1)==(7), (7)==(1)
 ├── scan uv
 │    ├── columns: u:1!null uv.v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── limit
 │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    ├── cardinality: [0 - 10]
 │    ├── key: (5)
 │    ├── fd: (5)-->(6,7)
 │    ├── scan kvr_fk
 │    │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    │    ├── key: (5)
 │    │    ├── fd: (5)-->(6,7)
 │    │    └── limit hint: 10.00
 │    └── 10
 └── filters
      └── u:1 = r:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Ordering can be pushed down.
norm expect=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY a LIMIT 10
----
sort
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +1
 └── left-join (hash)
      ├── columns: a:1!null b:2 u:5 v:6
      ├── cardinality: [0 - 10]
      ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      ├── key: (1)
      ├── fd: (1)-->(2,5,6), (5)-->(6)
      ├── limit
      │    ├── columns: a:1!null b:2
      │    ├── internal-ordering: +1
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── scan ab
      │    │    ├── columns: a:1!null b:2
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    ├── ordering: +1
      │    │    └── limit hint: 10.00
      │    └── 10
      ├── scan uv
      │    ├── columns: u:5!null v:6
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

norm expect=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY b LIMIT 10
----
sort
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +2
 └── left-join (hash)
      ├── columns: a:1!null b:2 u:5 v:6
      ├── cardinality: [0 - 10]
      ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      ├── key: (1)
      ├── fd: (1)-->(2,5,6), (5)-->(6)
      ├── limit
      │    ├── columns: a:1!null b:2
      │    ├── internal-ordering: +2
      │    ├── cardinality: [0 - 10]
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── sort
      │    │    ├── columns: a:1!null b:2
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    ├── ordering: +2
      │    │    ├── limit hint: 10.00
      │    │    └── scan ab
      │    │         ├── columns: a:1!null b:2
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── 10
      ├── scan uv
      │    ├── columns: u:5!null v:6
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# Ordering on u is not equivalent to ordering on a because of NULLs; it cannot
# be pushed down.
norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY u LIMIT 10
----
limit
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +5
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +5
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +5
 │    ├── limit hint: 10.00
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Ordering cannot be pushed down.
norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY v LIMIT 10
----
limit
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +6
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +6
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +6
 │    ├── limit hint: 10.00
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON b = v ORDER BY a, v LIMIT 10
----
limit
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +1,+6
 ├── cardinality: [0 - 10]
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── ordering: +1,+6
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6)
 │    ├── ordering: +1,+6
 │    ├── limit hint: 10.00
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── key: (1,5)
 │         ├── fd: (1)-->(2), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── b:2 = v:6 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
 └── 10

norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY u, b LIMIT 10
----
limit
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +5,+2
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +5,+2
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +5,+2
 │    ├── limit hint: 10.00
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Rule should not fire if the input's cardinality is already less than the
# limit.
norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM (SELECT * FROM ab LIMIT 5) LEFT JOIN uv ON a = u LIMIT 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 5]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── limit
 │    ├── columns: a:1!null b:2
 │    ├── cardinality: [0 - 5]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── limit hint: 5.00
 │    └── 5
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# Push the limit even if the input is already limited (but with a higher limit).
norm expect=PushLimitIntoJoinLeft
SELECT * FROM (SELECT * FROM ab LIMIT 20) LEFT JOIN uv ON a = u LIMIT 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── limit
 │    ├── columns: a:1!null b:2
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    └── limit hint: 10.00
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# Push the limit if both sides of an inner join have identical equality filters
# on FK equality columns.
norm expect=PushLimitIntoJoinLeft
SELECT * FROM kvr_fk INNER JOIN uv ON r = u WHERE r = 5 LIMIT 10
----
inner-join (hash)
 ├── columns: k:1!null v:2 r:3!null u:6!null v:7
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: ()-->(3,6,7), (1)-->(2), (3)==(6), (6)==(3)
 ├── limit
 │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: ()-->(3), (1)-->(2)
 │    ├── select
 │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(3), (1)-->(2)
 │    │    ├── limit hint: 10.00
 │    │    ├── scan kvr_fk
 │    │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2,3)
 │    │    │    └── limit hint: 1000.00
 │    │    └── filters
 │    │         └── r:3 = 5 [outer=(3), constraints=(/3: [/5 - /5]; tight), fd=()-->(3)]
 │    └── 10
 ├── select
 │    ├── columns: u:6!null uv.v:7
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(6,7)
 │    ├── scan uv
 │    │    ├── columns: u:6!null uv.v:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── u:6 = 5 [outer=(6), constraints=(/6: [/5 - /5]; tight), fd=()-->(6)]
 └── filters
      └── r:3 = u:6 [outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]

# Don't push negative limits (or we would enter an infinite loop).
norm expect-not=PushLimitIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u LIMIT -1
----
limit
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(1,2,5,6)
 ├── left-join (hash)
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── limit hint: 1.00
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── -1

# Don't push limits into an inner join that may not preserve rows.
norm expect-not=(PushLimitIntoJoinLeft,PushLimitIntoJoinRight)
SELECT * FROM ab INNER JOIN uv ON a = u LIMIT 10
----
limit
 ├── columns: a:1!null b:2 u:5!null v:6
 ├── cardinality: [0 - 10]
 ├── key: (5)
 ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
 ├── inner-join (hash)
 │    ├── columns: a:1!null b:2 u:5!null v:6
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (5)
 │    ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
 │    ├── limit hint: 10.00
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Don't push a limit into the right side of a LeftJoin.
norm expect-not=PushLimitIntoJoinRight
SELECT * FROM uv LEFT JOIN kvr_fk ON u = r LIMIT 10
----
limit
 ├── columns: u:1!null v:2 k:5 v:6 r:7
 ├── cardinality: [0 - 10]
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6,7)
 ├── left-join (hash)
 │    ├── columns: u:1!null uv.v:2 k:5 kvr_fk.v:6 r:7
 │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6,7)
 │    ├── limit hint: 10.00
 │    ├── limit
 │    │    ├── columns: u:1!null uv.v:2
 │    │    ├── cardinality: [0 - 10]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan uv
 │    │    │    ├── columns: u:1!null uv.v:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    └── limit hint: 10.00
 │    │    └── 10
 │    ├── scan kvr_fk
 │    │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6,7)
 │    └── filters
 │         └── u:1 = r:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 └── 10

# Don't push a limit into either side of a FullJoin.
norm expect-not=(PushLimitIntoJoinLeft,PushLimitIntoJoinRight)
SELECT * FROM ab FULL JOIN uv ON a = u LIMIT 10
----
limit
 ├── columns: a:1 b:2 u:5 v:6
 ├── cardinality: [0 - 10]
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── full-join (hash)
 │    ├── columns: a:1 b:2 u:5 v:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6)
 │    ├── limit hint: 10.00
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# ------------------------------------------------
# PushOffsetIntoJoinLeft and PushOffsetIntoJoinRight
# ------------------------------------------------

# InnerJoin case.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM kvr_fk INNER JOIN uv ON r = u OFFSET 10
----
inner-join (hash)
 ├── columns: k:1!null v:2 r:3!null u:6!null v:7
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (6)-->(7), (3)==(6), (6)==(3)
 ├── offset
 │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── scan kvr_fk
 │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2,3)
 │    └── 10
 ├── scan uv
 │    ├── columns: u:6!null uv.v:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── r:3 = u:6 [outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]

# LeftJoin case.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u OFFSET 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── offset
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# InnerJoin case for PushOffsetIntoJoinRight.
norm expect=PushOffsetIntoJoinRight
SELECT * FROM uv INNER JOIN kvr_fk ON u = r OFFSET 10
----
inner-join (hash)
 ├── columns: u:1!null v:2 k:5!null v:6 r:7!null
 ├── multiplicity: left-rows(zero-or-more), right-rows(exactly-one)
 ├── key: (5)
 ├── fd: (1)-->(2), (5)-->(6,7), (1)==(7), (7)==(1)
 ├── scan uv
 │    ├── columns: u:1!null uv.v:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 ├── offset
 │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    ├── key: (5)
 │    ├── fd: (5)-->(6,7)
 │    ├── scan kvr_fk
 │    │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6,7)
 │    └── 10
 └── filters
      └── u:1 = r:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Ordering can be pushed down.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY an OFFSET 10
----
error (42703): column "an" does not exist

norm expect=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY b OFFSET 10
----
sort
 ├── columns: a:1!null b:2 u:5 v:6
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +2
 └── left-join (hash)
      ├── columns: a:1!null b:2 u:5 v:6
      ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      ├── key: (1)
      ├── fd: (1)-->(2,5,6), (5)-->(6)
      ├── offset
      │    ├── columns: a:1!null b:2
      │    ├── internal-ordering: +2
      │    ├── key: (1)
      │    ├── fd: (1)-->(2)
      │    ├── sort
      │    │    ├── columns: a:1!null b:2
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2)
      │    │    ├── ordering: +2
      │    │    └── scan ab
      │    │         ├── columns: a:1!null b:2
      │    │         ├── key: (1)
      │    │         └── fd: (1)-->(2)
      │    └── 10
      ├── scan uv
      │    ├── columns: u:5!null v:6
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# Ordering on u is not equivalent to ordering on a because of NULLs; it cannot
# be pushed down.
norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY u OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +5
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +5
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +5
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Ordering cannot be pushed down.
norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY v OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +6
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +6
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +6
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON b = v ORDER BY a, v OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +1,+6
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── ordering: +1,+6
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6)
 │    ├── ordering: +1,+6
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── key: (1,5)
 │         ├── fd: (1)-->(2), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── b:2 = v:6 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
 └── 10

norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u ORDER BY u, b OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── internal-ordering: +5,+2
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── ordering: +5,+2
 ├── sort
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── ordering: +5,+2
 │    └── left-join (hash)
 │         ├── columns: a:1!null b:2 u:5 v:6
 │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │         ├── key: (1)
 │         ├── fd: (1)-->(2,5,6), (5)-->(6)
 │         ├── scan ab
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan uv
 │         │    ├── columns: u:5!null v:6
 │         │    ├── key: (5)
 │         │    └── fd: (5)-->(6)
 │         └── filters
 │              └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Difference with PushLimitIntoJoinLeft: rule fires even if the input's
# cardinality is less than the offset.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM (SELECT * FROM ab OFFSET 5) LEFT JOIN uv ON a = u OFFSET 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── offset
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── offset
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan ab
 │    │    │    ├── columns: a:1!null b:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    └── 5
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

norm expect=PushOffsetIntoJoinLeft
SELECT * FROM (SELECT * FROM ab OFFSET 20) LEFT JOIN uv ON a = u OFFSET 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── offset
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── offset
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan ab
 │    │    │    ├── columns: a:1!null b:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    └── 20
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# Push the offset if both sides of an inner join have identical equality filters
# on FK equality columns.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM kvr_fk INNER JOIN uv ON r = u WHERE r = 5 OFFSET 10
----
inner-join (hash)
 ├── columns: k:1!null v:2 r:3!null u:6!null v:7
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: ()-->(3,6,7), (1)-->(2), (3)==(6), (6)==(3)
 ├── offset
 │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    ├── key: (1)
 │    ├── fd: ()-->(3), (1)-->(2)
 │    ├── select
 │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(3), (1)-->(2)
 │    │    ├── scan kvr_fk
 │    │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2,3)
 │    │    └── filters
 │    │         └── r:3 = 5 [outer=(3), constraints=(/3: [/5 - /5]; tight), fd=()-->(3)]
 │    └── 10
 ├── select
 │    ├── columns: u:6!null uv.v:7
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(6,7)
 │    ├── scan uv
 │    │    ├── columns: u:6!null uv.v:7
 │    │    ├── key: (6)
 │    │    └── fd: (6)-->(7)
 │    └── filters
 │         └── u:6 = 5 [outer=(6), constraints=(/6: [/5 - /5]; tight), fd=()-->(6)]
 └── filters
      └── r:3 = u:6 [outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]

# Don't push negative offsets (or we would enter an infinite loop).
norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u OFFSET -1
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── left-join (hash)
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5,6), (5)-->(6)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── -1

# Don't push offsets into an inner join that may not preserve rows.
norm expect-not=(PushOffsetIntoJoinLeft,PushOffsetIntoJoinRight)
SELECT * FROM ab INNER JOIN uv ON a = u OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5!null v:6
 ├── key: (5)
 ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
 ├── inner-join (hash)
 │    ├── columns: a:1!null b:2 u:5!null v:6
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (5)
 │    ├── fd: (1)-->(2), (5)-->(6), (1)==(5), (5)==(1)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Don't push an offset into the right side of a LeftJoin.
norm expect-not=PushOffsetIntoJoinRight
SELECT * FROM uv LEFT JOIN kvr_fk ON u = r OFFSET 10
----
offset
 ├── columns: u:1!null v:2 k:5 v:6 r:7
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6,7)
 ├── left-join (hash)
 │    ├── columns: u:1!null uv.v:2 k:5 kvr_fk.v:6 r:7
 │    ├── multiplicity: left-rows(one-or-more), right-rows(exactly-one)
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6,7)
 │    ├── scan uv
 │    │    ├── columns: u:1!null uv.v:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan kvr_fk
 │    │    ├── columns: k:5!null kvr_fk.v:6 r:7!null
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6,7)
 │    └── filters
 │         └── u:1 = r:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 └── 10

# Don't push an offset into either side of a FullJoin.
norm expect-not=(PushOffsetIntoJoinLeft,PushOffsetIntoJoinRight)
SELECT * FROM ab FULL JOIN uv ON a = u OFFSET 10
----
offset
 ├── columns: a:1 b:2 u:5 v:6
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── full-join (hash)
 │    ├── columns: a:1 b:2 u:5 v:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── 10

# Don't push an offset if the join duplicates input rows.
norm expect-not=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = v OFFSET 10
----
offset
 ├── columns: a:1!null b:2 u:5 v:6
 ├── key: (1,5)
 ├── fd: (1)-->(2), (5)-->(6)
 ├── left-join (hash)
 │    ├── columns: a:1!null b:2 u:5 v:6
 │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (5)-->(6)
 │    ├── scan ab
 │    │    ├── columns: a:1!null b:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    ├── scan uv
 │    │    ├── columns: u:5!null v:6
 │    │    ├── key: (5)
 │    │    └── fd: (5)-->(6)
 │    └── filters
 │         └── a:1 = v:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── 10

# Case with limit + offset.
norm expect=PushOffsetIntoJoinLeft
SELECT * FROM kvr_fk INNER JOIN uv ON r = u LIMIT 10 OFFSET 10
----
inner-join (hash)
 ├── columns: k:1!null v:2 r:3!null u:6!null v:7
 ├── cardinality: [0 - 10]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2,3), (6)-->(7), (3)==(6), (6)==(3)
 ├── offset
 │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3)
 │    ├── limit
 │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    ├── cardinality: [0 - 20]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    ├── scan kvr_fk
 │    │    │    ├── columns: k:1!null kvr_fk.v:2 r:3!null
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2,3)
 │    │    │    └── limit hint: 20.00
 │    │    └── 20
 │    └── 10
 ├── scan uv
 │    ├── columns: u:6!null uv.v:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── r:3 = u:6 [outer=(3,6), constraints=(/3: (/NULL - ]; /6: (/NULL - ]), fd=(3)==(6), (6)==(3)]

norm expect=PushOffsetIntoJoinLeft
SELECT * FROM ab LEFT JOIN uv ON a = u LIMIT 5 OFFSET 10
----
left-join (hash)
 ├── columns: a:1!null b:2 u:5 v:6
 ├── cardinality: [0 - 5]
 ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 ├── key: (1)
 ├── fd: (1)-->(2,5,6), (5)-->(6)
 ├── offset
 │    ├── columns: a:1!null b:2
 │    ├── cardinality: [0 - 5]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── limit
 │    │    ├── columns: a:1!null b:2
 │    │    ├── cardinality: [0 - 15]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan ab
 │    │    │    ├── columns: a:1!null b:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    └── limit hint: 15.00
 │    │    └── 15
 │    └── 10
 ├── scan uv
 │    ├── columns: u:5!null v:6
 │    ├── key: (5)
 │    └── fd: (5)-->(6)
 └── filters
      └── a:1 = u:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]

# ----------
# FoldLimits
# ----------

# Basic case with no orderings.
norm expect=FoldLimits
SELECT * FROM (SELECT * FROM ab LIMIT 10) LIMIT 5
----
limit
 ├── columns: a:1!null b:2
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan ab
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── limit hint: 5.00
 └── 5

# Case where the inner limit has an ordering and the outer limit is unordered.
norm expect=FoldLimits
SELECT * FROM (SELECT * FROM ab ORDER BY a LIMIT 10) LIMIT 5
----
limit
 ├── columns: a:1!null b:2
 ├── internal-ordering: +1
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan ab
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── ordering: +1
 │    └── limit hint: 5.00
 └── 5

# Case where the inner limit ordering implies the outer ordering.
norm expect=FoldLimits
SELECT * FROM (SELECT * FROM a ORDER BY i, f LIMIT 10) ORDER BY i LIMIT 5
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2,+3
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +2
 ├── sort
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +2,+3
 │    ├── limit hint: 5.00
 │    └── scan a
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── key: (1)
 │         └── fd: (1)-->(2-5)
 └── 5

# No-op case where the outer limit is larger than the inner limit. (The limit is
# instead removed by EliminateLimit).
norm expect-not=FoldLimits
SELECT * FROM (SELECT * FROM ab LIMIT 5) LIMIT 10
----
limit
 ├── columns: a:1!null b:2
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── scan ab
 │    ├── columns: a:1!null b:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── limit hint: 5.00
 └── 5

# No-op case where the inner limit ordering does not imply the outer limit
# ordering.
norm expect-not=FoldLimits
SELECT * FROM (SELECT * FROM ab ORDER BY b LIMIT 10) ORDER BY a LIMIT 5
----
limit
 ├── columns: a:1!null b:2
 ├── internal-ordering: +1
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── ordering: +1
 ├── sort
 │    ├── columns: a:1!null b:2
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    ├── ordering: +1
 │    ├── limit hint: 5.00
 │    └── limit
 │         ├── columns: a:1!null b:2
 │         ├── internal-ordering: +2
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(2)
 │         ├── sort
 │         │    ├── columns: a:1!null b:2
 │         │    ├── key: (1)
 │         │    ├── fd: (1)-->(2)
 │         │    ├── ordering: +2
 │         │    ├── limit hint: 10.00
 │         │    └── scan ab
 │         │         ├── columns: a:1!null b:2
 │         │         ├── key: (1)
 │         │         └── fd: (1)-->(2)
 │         └── 10
 └── 5

# No-op case where the outer ordering implies the inner, but the inner doesn't
# imply the outer.
norm expect-not=FoldLimits
SELECT * FROM (SELECT * FROM a ORDER BY i LIMIT 10) ORDER BY i, f LIMIT 5
----
limit
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── internal-ordering: +2,+3
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── ordering: +2,+3
 ├── sort (segmented)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── ordering: +2,+3
 │    ├── limit hint: 5.00
 │    └── limit
 │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         ├── internal-ordering: +2
 │         ├── cardinality: [0 - 10]
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-5)
 │         ├── ordering: +2
 │         ├── sort
 │         │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         │    ├── key: (1)
 │         │    ├── fd: (1)-->(2-5)
 │         │    ├── ordering: +2
 │         │    ├── limit hint: 10.00
 │         │    └── scan a
 │         │         ├── columns: k:1!null i:2 f:3 s:4 j:5
 │         │         ├── key: (1)
 │         │         └── fd: (1)-->(2-5)
 │         └── 10
 └── 5

# ----------------------------------------------------
# AssociateLimitJoinsLeft and AssociateLimitJoinsRight
# ----------------------------------------------------

norm expect=AssociateLimitJoinsLeft format=hide-all
SELECT *
FROM (SELECT * FROM b LEFT JOIN uv ON x = u)
INNER JOIN ab
ON a = y
LIMIT 10
----
left-join (hash)
 ├── limit
 │    ├── inner-join (hash)
 │    │    ├── scan b
 │    │    ├── scan ab
 │    │    └── filters
 │    │         └── a = y
 │    └── 10
 ├── scan uv
 └── filters
      └── x = u

norm expect=AssociateLimitJoinsRight format=hide-all
SELECT *
FROM ab
INNER JOIN (SELECT * FROM b LEFT JOIN uv ON x = u)
ON a = y
LIMIT 10
----
left-join (hash)
 ├── limit
 │    ├── inner-join (hash)
 │    │    ├── scan b
 │    │    ├── scan ab
 │    │    └── filters
 │    │         └── a = y
 │    └── 10
 ├── scan uv
 └── filters
      └── x = u

norm expect=AssociateLimitJoinsRight format=hide-all
SELECT *
FROM kvr_fk
INNER JOIN (SELECT * FROM uv LEFT JOIN ab ON v = b)
ON r = u
LIMIT 10
----
limit
 ├── left-join (hash)
 │    ├── inner-join (hash)
 │    │    ├── scan uv
 │    │    ├── limit
 │    │    │    ├── scan kvr_fk
 │    │    │    └── 10
 │    │    └── filters
 │    │         └── r = u
 │    ├── scan ab
 │    └── filters
 │         └── uv.v = b
 └── 10

# No-op case because the InnerJoin filter references columns from the right side
# of the LeftJoin.
norm expect-not=(AssociateLimitJoinsLeft,AssociateLimitJoinsRight) format=hide-all
SELECT *
FROM (SELECT * FROM b LEFT JOIN uv ON x = u)
INNER JOIN ab
ON a = y AND (b = v OR v IS NULL)
LIMIT 10
----
limit
 ├── inner-join (hash)
 │    ├── left-join (hash)
 │    │    ├── scan b
 │    │    ├── scan uv
 │    │    └── filters
 │    │         └── x = u
 │    ├── scan ab
 │    └── filters
 │         ├── a = y
 │         └── (b = v) OR (v IS NULL)
 └── 10

# No-op case because one of the joins has a join hint.
norm expect-not=(AssociateLimitJoinsLeft,AssociateLimitJoinsRight) format=hide-all
SELECT *
FROM (SELECT * FROM b LEFT JOIN uv ON x = u)
INNER MERGE JOIN ab
ON a = y
LIMIT 10
----
limit
 ├── inner-join (hash)
 │    ├── flags: force merge join
 │    ├── left-join (hash)
 │    │    ├── scan b
 │    │    ├── scan uv
 │    │    └── filters
 │    │         └── x = u
 │    ├── scan ab
 │    └── filters
 │         └── a = y
 └── 10

# No-op case because the left input has outer columns.
norm expect-not=(AssociateLimitJoinsLeft,AssociateLimitJoinsRight) disable=(TryDecorrelateProject,PushLimitIntoProject) format=hide-all
SELECT *
FROM uv
LEFT JOIN LATERAL (
  SELECT *
  FROM (SELECT a*u FROM ab)
  INNER JOIN (VALUES (1))
  ON True
  LIMIT 1
)
ON True
----
distinct-on
 ├── left-join-apply
 │    ├── scan uv
 │    ├── project
 │    │    ├── scan ab
 │    │    └── projections
 │    │         ├── 1
 │    │         └── a * u
 │    └── filters (true)
 └── aggregations
      ├── const-agg
      │    └── v
      ├── first-agg
      │    └── "?column?"
      └── first-agg
           └── column1

# No-op case because the right input has outer columns. An infinite loop will
# occur if the limit is pushed down. Regression test for #50355.
norm expect-not=(AssociateLimitJoinsLeft,AssociateLimitJoinsRight) disable=(TryDecorrelateProject,PushLimitIntoProject) format=hide-all
SELECT *
FROM uv
LEFT JOIN LATERAL (
  SELECT *
  FROM (VALUES (1))
  INNER JOIN (SELECT a*u FROM ab)
  ON True
  LIMIT 1
)
ON True
----
distinct-on
 ├── left-join-apply
 │    ├── scan uv
 │    ├── inner-join (cross)
 │    │    ├── values
 │    │    │    └── (1,)
 │    │    ├── project
 │    │    │    ├── scan ab
 │    │    │    └── projections
 │    │    │         └── a * u
 │    │    └── filters (true)
 │    └── filters (true)
 └── aggregations
      ├── const-agg
      │    └── v
      ├── first-agg
      │    └── column1
      └── first-agg
           └── "?column?"

# ----------------------------------------------------
# PushLimitIntoLock and PushOffsetIntoLock
# ----------------------------------------------------

# Check that we push down LIMIT and OFFSET under SFU locking, except when using
# SKIP LOCKED.

exec-ddl
CREATE TABLE abcde (
  a UUID NOT NULL DEFAULT gen_random_uuid(),
  b STRING NULL,
  c TIMESTAMP NOT NULL DEFAULT current_timestamp():::TIMESTAMP,
  d TIMESTAMP NULL,
  e STRING NULL,
  PRIMARY KEY (a),
  INDEX (c) WHERE d IS NULL
)
----

# Serializable, without SKIP LOCKED.

opt set=optimizer_use_lock_op_for_serializable=true expect=PushLimitIntoLock
SELECT * FROM abcde WHERE d IS NULL LIMIT 1 FOR UPDATE
----
lock abcde
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── key columns: a:1
 ├── lock columns: (8-12)
 ├── locking: for-update
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── index-join abcde
      ├── columns: a:1!null b:2 c:3!null d:4 e:5
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-5)
      └── scan abcde@abcde_c_idx,partial
           ├── columns: a:1!null c:3!null
           ├── limit: 1
           ├── key: ()
           └── fd: ()-->(1,3)

opt set=optimizer_use_lock_op_for_serializable=true expect=PushOffsetIntoLock
SELECT * FROM abcde WHERE d IS NULL OFFSET 1 FOR UPDATE
----
lock abcde
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── key columns: a:1
 ├── lock columns: (8-12)
 ├── locking: for-update
 ├── volatile
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 └── index-join abcde
      ├── columns: a:1!null b:2 c:3!null d:4 e:5
      ├── key: (1)
      ├── fd: ()-->(4), (1)-->(2,3,5)
      └── offset
           ├── columns: a:1!null c:3!null
           ├── key: (1)
           ├── fd: (1)-->(3)
           ├── scan abcde@abcde_c_idx,partial
           │    ├── columns: a:1!null c:3!null
           │    ├── key: (1)
           │    └── fd: (1)-->(3)
           └── 1

# Serializable, with SKIP LOCKED.

opt set=optimizer_use_lock_op_for_serializable=true expect-not=PushLimitIntoLock
SELECT * FROM abcde WHERE d IS NULL LIMIT 1 FOR UPDATE SKIP LOCKED
----
limit
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── lock abcde
 │    ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │    ├── key columns: a:1
 │    ├── lock columns: (8-12)
 │    ├── locking: for-update,skip-locked
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── limit hint: 1.00
 │    └── index-join abcde
 │         ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │         ├── locking: none,skip-locked
 │         ├── volatile
 │         ├── key: (1)
 │         ├── fd: ()-->(4), (1)-->(2,3,5)
 │         ├── limit hint: 1.00
 │         └── scan abcde@abcde_c_idx,partial
 │              ├── columns: a:1!null c:3!null
 │              ├── locking: none,skip-locked
 │              ├── volatile
 │              ├── key: (1)
 │              ├── fd: (1)-->(3)
 │              └── limit hint: 1.00
 └── 1

opt set=optimizer_use_lock_op_for_serializable=true expect-not=PushOffsetIntoLock
SELECT a FROM abcde WHERE d IS NULL OFFSET 1 FOR UPDATE SKIP LOCKED
----
offset
 ├── columns: a:1!null
 ├── volatile
 ├── key: (1)
 ├── lock abcde
 │    ├── columns: a:1!null
 │    ├── key columns: a:1
 │    ├── lock columns: (8-12)
 │    ├── locking: for-update,skip-locked
 │    ├── volatile
 │    ├── key: (1)
 │    └── project
 │         ├── columns: a:1!null
 │         ├── volatile
 │         ├── key: (1)
 │         └── project
 │              ├── columns: d:4 a:1!null
 │              ├── volatile
 │              ├── key: (1)
 │              ├── fd: ()-->(4)
 │              ├── scan abcde@abcde_c_idx,partial
 │              │    ├── columns: a:1!null
 │              │    ├── locking: none,skip-locked
 │              │    ├── volatile
 │              │    └── key: (1)
 │              └── projections
 │                   └── CAST(NULL AS TIMESTAMP) [as=d:4]
 └── 1

# Read committed, without SKIP LOCKED.

opt isolation=ReadCommitted expect=PushLimitIntoLock
SELECT * FROM abcde WHERE d IS NULL LIMIT 1 FOR UPDATE
----
lock abcde
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── key columns: a:1
 ├── lock columns: (8-12)
 ├── locking: for-update,durability-guaranteed
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── index-join abcde
      ├── columns: a:1!null b:2 c:3!null d:4 e:5
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-5)
      └── scan abcde@abcde_c_idx,partial
           ├── columns: a:1!null c:3!null
           ├── limit: 1
           ├── key: ()
           └── fd: ()-->(1,3)

opt isolation=ReadCommitted expect=PushOffsetIntoLock
SELECT * FROM abcde WHERE d IS NULL OFFSET 1 FOR UPDATE
----
lock abcde
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── key columns: a:1
 ├── lock columns: (8-12)
 ├── locking: for-update,durability-guaranteed
 ├── volatile
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 └── index-join abcde
      ├── columns: a:1!null b:2 c:3!null d:4 e:5
      ├── key: (1)
      ├── fd: ()-->(4), (1)-->(2,3,5)
      └── offset
           ├── columns: a:1!null c:3!null
           ├── key: (1)
           ├── fd: (1)-->(3)
           ├── scan abcde@abcde_c_idx,partial
           │    ├── columns: a:1!null c:3!null
           │    ├── key: (1)
           │    └── fd: (1)-->(3)
           └── 1

# Read committed, with SKIP LOCKED.

opt isolation=ReadCommitted expect-not=PushLimitIntoLock
SELECT * FROM abcde WHERE d IS NULL LIMIT 1 FOR UPDATE SKIP LOCKED
----
limit
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── cardinality: [0 - 1]
 ├── volatile
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── lock abcde
 │    ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │    ├── key columns: a:1
 │    ├── lock columns: (8-12)
 │    ├── locking: for-update,skip-locked,durability-guaranteed
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── limit hint: 1.00
 │    └── index-join abcde
 │         ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │         ├── locking: none,skip-locked
 │         ├── volatile
 │         ├── key: (1)
 │         ├── fd: ()-->(4), (1)-->(2,3,5)
 │         ├── limit hint: 1.00
 │         └── scan abcde@abcde_c_idx,partial
 │              ├── columns: a:1!null c:3!null
 │              ├── locking: none,skip-locked
 │              ├── volatile
 │              ├── key: (1)
 │              ├── fd: (1)-->(3)
 │              └── limit hint: 1.00
 └── 1

opt isolation=ReadCommitted expect-not=PushOffsetIntoLock
SELECT * FROM abcde WHERE d IS NULL OFFSET 1 FOR UPDATE SKIP LOCKED
----
offset
 ├── columns: a:1!null b:2 c:3!null d:4 e:5
 ├── volatile
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── lock abcde
 │    ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │    ├── key columns: a:1
 │    ├── lock columns: (8-12)
 │    ├── locking: for-update,skip-locked,durability-guaranteed
 │    ├── volatile
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    └── index-join abcde
 │         ├── columns: a:1!null b:2 c:3!null d:4 e:5
 │         ├── locking: none,skip-locked
 │         ├── volatile
 │         ├── key: (1)
 │         ├── fd: ()-->(4), (1)-->(2,3,5)
 │         └── scan abcde@abcde_c_idx,partial
 │              ├── columns: a:1!null c:3!null
 │              ├── locking: none,skip-locked
 │              ├── volatile
 │              ├── key: (1)
 │              └── fd: (1)-->(3)
 └── 1

# --------------------------------------------------
# PushLimitOrOffsetIntoGroupBy
# --------------------------------------------------

# Basic case: push limit into a GroupBy with an aggregation where grouping
# columns form a key and there's a growing join between scan and group by.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a LEFT JOIN b ON i = y) GROUP BY k LIMIT 10
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:9
 │    ├── fd: (1)-->(2)
 │    ├── limit
 │    │    ├── columns: k:1!null i:2
 │    │    ├── cardinality: [0 - 10]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    └── limit hint: 10.00
 │    │    └── 10
 │    ├── scan b
 │    │    └── columns: y:9
 │    └── filters
 │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# DistinctOn case.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT DISTINCT ON (k) * FROM (SELECT k, i, y FROM a LEFT JOIN b ON i = y) LIMIT 5
----
distinct-on
 ├── columns: k:1!null i:2 y:9
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2,9)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:9
 │    ├── fd: (1)-->(2)
 │    ├── limit
 │    │    ├── columns: k:1!null i:2
 │    │    ├── cardinality: [0 - 5]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    └── limit hint: 5.00
 │    │    └── 5
 │    ├── scan b
 │    │    └── columns: y:9
 │    └── filters
 │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 └── aggregations
      ├── first-agg [as=i:2, outer=(2)]
      │    └── i:2
      └── first-agg [as=y:9, outer=(9)]
           └── y:9

# Offset case.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a LEFT JOIN b ON i = y) GROUP BY k OFFSET 10
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:9
 │    ├── fd: (1)-->(2)
 │    ├── offset
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    └── 10
 │    ├── scan b
 │    │    └── columns: y:9
 │    └── filters
 │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# Cases with a non-duplicating join that maintains the key. The join may filter
# rows, so the limit has to remain on top of it.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY k LIMIT 10
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── limit
 │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    │    ├── limit hint: 10.00
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan b
 │    │    │    ├── columns: x:8!null y:9
 │    │    │    ├── key: (8)
 │    │    │    └── fd: (8)-->(9)
 │    │    └── filters
 │    │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── 10
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# DistinctOn case. Note that the DistinctOn ends up being eliminated.
norm
SELECT DISTINCT k FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) LIMIT 5
----
project
 ├── columns: k:1!null
 ├── cardinality: [0 - 5]
 ├── key: (1)
 └── limit
      ├── columns: k:1!null i:2!null x:8!null
      ├── cardinality: [0 - 5]
      ├── key: (1)
      ├── fd: (1)-->(2), (2)==(8), (8)==(2)
      ├── inner-join (hash)
      │    ├── columns: k:1!null i:2!null x:8!null
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2), (2)==(8), (8)==(2)
      │    ├── limit hint: 5.00
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── scan b
      │    │    ├── columns: x:8!null
      │    │    └── key: (8)
      │    └── filters
      │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
      └── 5

# Case with offset.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY k LIMIT 10 OFFSET 5
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 10]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── offset
 │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    ├── cardinality: [0 - 10]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    ├── limit
 │    │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    │    ├── cardinality: [0 - 15]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    │    │    ├── limit hint: 15.00
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan b
 │    │    │    │    ├── columns: x:8!null y:9
 │    │    │    │    ├── key: (8)
 │    │    │    │    └── fd: (8)-->(9)
 │    │    │    └── filters
 │    │    │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    │    └── 15
 │    └── 5
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# Case with empty grouping columns.
norm expect=PushLimitOrOffsetIntoGroupBy disable=EliminateLimit
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x AND k = 1) GROUP BY k LIMIT 10
----
group-by (streaming)
 ├── columns: k:1!null sum:12
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,12)
 ├── limit
 │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1,2,8,9), (2)==(8), (8)==(2)
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(1,2,8,9), (2)==(8), (8)==(2)
 │    │    ├── limit hint: 10.00
 │    │    ├── select
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── cardinality: [0 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(1,2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── filters
 │    │    │         └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
 │    │    ├── scan b
 │    │    │    ├── columns: x:8!null y:9
 │    │    │    ├── key: (8)
 │    │    │    └── fd: (8)-->(9)
 │    │    └── filters
 │    │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── 10
 └── aggregations
      ├── sum [as=sum:12, outer=(9)]
      │    └── y:9
      └── const-agg [as=k:1, outer=(1)]
           └── k:1

# Push limit through FK joins.
exec-ddl
CREATE TABLE p1 (id1 INT PRIMARY KEY, val1 INT)
----

exec-ddl
CREATE TABLE p2 (id2 INT PRIMARY KEY, val2 INT)
----

exec-ddl
CREATE TABLE child (
  k INT PRIMARY KEY,
  val INT,
  ref1 INT NOT NULL REFERENCES p1 (id1),
  ref2 INT NOT NULL REFERENCES p2 (id2)
)
----

norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(val), sum(val1)
FROM child
INNER JOIN p1 ON id1 = ref1
GROUP BY k
LIMIT 3
----
group-by (hash)
 ├── columns: k:1!null sum:11 sum:12
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(11,12)
 ├── inner-join (hash)
 │    ├── columns: k:1!null val:2 ref1:3!null id1:7!null val1:8
 │    ├── cardinality: [0 - 3]
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3), (7)-->(8), (3)==(7), (7)==(3)
 │    ├── limit
 │    │    ├── columns: k:1!null val:2 ref1:3!null
 │    │    ├── cardinality: [0 - 3]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3)
 │    │    ├── scan child
 │    │    │    ├── columns: k:1!null val:2 ref1:3!null
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2,3)
 │    │    │    └── limit hint: 3.00
 │    │    └── 3
 │    ├── scan p1
 │    │    ├── columns: id1:7!null val1:8
 │    │    ├── key: (7)
 │    │    └── fd: (7)-->(8)
 │    └── filters
 │         └── id1:7 = ref1:3 [outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
 └── aggregations
      ├── sum [as=sum:11, outer=(2)]
      │    └── val:2
      └── sum [as=sum:12, outer=(8)]
           └── val1:8

# Case with two joins.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(val), sum(val1), sum(val2)
FROM child
INNER JOIN p1 ON id1 = ref1
INNER JOIN p2 ON id2 = ref2
GROUP BY k
LIMIT 3
----
group-by (hash)
 ├── columns: k:1!null sum:15 sum:16 sum:17
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(15-17)
 ├── inner-join (hash)
 │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null id1:7!null val1:8 id2:11!null val2:12
 │    ├── cardinality: [0 - 3]
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (7)-->(8), (11)-->(12), (3)==(7), (7)==(3), (4)==(11), (11)==(4)
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null id1:7!null val1:8
 │    │    ├── cardinality: [0 - 3]
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-4), (7)-->(8), (3)==(7), (7)==(3)
 │    │    ├── limit
 │    │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null
 │    │    │    ├── cardinality: [0 - 3]
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2-4)
 │    │    │    ├── scan child
 │    │    │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: (1)-->(2-4)
 │    │    │    │    └── limit hint: 3.00
 │    │    │    └── 3
 │    │    ├── scan p1
 │    │    │    ├── columns: id1:7!null val1:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    └── filters
 │    │         └── id1:7 = ref1:3 [outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
 │    ├── scan p2
 │    │    ├── columns: id2:11!null val2:12
 │    │    ├── key: (11)
 │    │    └── fd: (11)-->(12)
 │    └── filters
 │         └── id2:11 = ref2:4 [outer=(4,11), constraints=(/4: (/NULL - ]; /11: (/NULL - ]), fd=(4)==(11), (11)==(4)]
 └── aggregations
      ├── sum [as=sum:15, outer=(2)]
      │    └── val:2
      ├── sum [as=sum:16, outer=(8)]
      │    └── val1:8
      └── sum [as=sum:17, outer=(12)]
           └── val2:12

# Offset case.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(val), sum(val1), sum(val2)
FROM child
INNER JOIN p1 ON id1 = ref1
INNER JOIN p2 ON id2 = ref2
GROUP BY k
LIMIT 3 OFFSET 5
----
group-by (hash)
 ├── columns: k:1!null sum:15 sum:16 sum:17
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(15-17)
 ├── inner-join (hash)
 │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null id1:7!null val1:8 id2:11!null val2:12
 │    ├── cardinality: [0 - 3]
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (7)-->(8), (11)-->(12), (3)==(7), (7)==(3), (4)==(11), (11)==(4)
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null id1:7!null val1:8
 │    │    ├── cardinality: [0 - 3]
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2-4), (7)-->(8), (3)==(7), (7)==(3)
 │    │    ├── offset
 │    │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null
 │    │    │    ├── cardinality: [0 - 3]
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2-4)
 │    │    │    ├── limit
 │    │    │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null
 │    │    │    │    ├── cardinality: [0 - 8]
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: (1)-->(2-4)
 │    │    │    │    ├── scan child
 │    │    │    │    │    ├── columns: k:1!null val:2 ref1:3!null ref2:4!null
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(2-4)
 │    │    │    │    │    └── limit hint: 8.00
 │    │    │    │    └── 8
 │    │    │    └── 5
 │    │    ├── scan p1
 │    │    │    ├── columns: id1:7!null val1:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    └── filters
 │    │         └── id1:7 = ref1:3 [outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
 │    ├── scan p2
 │    │    ├── columns: id2:11!null val2:12
 │    │    ├── key: (11)
 │    │    └── fd: (11)-->(12)
 │    └── filters
 │         └── id2:11 = ref2:4 [outer=(4,11), constraints=(/4: (/NULL - ]; /11: (/NULL - ]), fd=(4)==(11), (11)==(4)]
 └── aggregations
      ├── sum [as=sum:15, outer=(2)]
      │    └── val:2
      ├── sum [as=sum:16, outer=(8)]
      │    └── val1:8
      └── sum [as=sum:17, outer=(12)]
           └── val2:12

# A filter may prevent matches despite the foreign key, preventing limit
# push-down below the join.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(val), sum(val1)
FROM child
INNER JOIN p1 ON id1 = ref1 AND val1 > 10
GROUP BY k
LIMIT 3
----
group-by (hash)
 ├── columns: k:1!null sum:11 sum:12!null
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(11,12)
 ├── limit
 │    ├── columns: k:1!null val:2 ref1:3!null id1:7!null val1:8!null
 │    ├── cardinality: [0 - 3]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,3), (7)-->(8), (3)==(7), (7)==(3)
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null val:2 ref1:3!null id1:7!null val1:8!null
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,3), (7)-->(8), (3)==(7), (7)==(3)
 │    │    ├── limit hint: 3.00
 │    │    ├── scan child
 │    │    │    ├── columns: k:1!null val:2 ref1:3!null
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2,3)
 │    │    ├── select
 │    │    │    ├── columns: id1:7!null val1:8!null
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(8)
 │    │    │    ├── scan p1
 │    │    │    │    ├── columns: id1:7!null val1:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(8)
 │    │    │    └── filters
 │    │    │         └── val1:8 > 10 [outer=(8), constraints=(/8: [/11 - ]; tight)]
 │    │    └── filters
 │    │         └── id1:7 = ref1:3 [outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
 │    └── 3
 └── aggregations
      ├── sum [as=sum:11, outer=(2)]
      │    └── val:2
      └── sum [as=sum:12, outer=(8)]
           └── val1:8

# Case with Project operator between join and group by - should still work.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(computed) FROM (SELECT k, i*2 as computed FROM a LEFT JOIN b ON i = y) GROUP BY k LIMIT 7 OFFSET 3
----
group-by (hash)
 ├── columns: k:1!null sum:13
 ├── grouping columns: k:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── project
 │    ├── columns: computed:12 k:1!null
 │    ├── immutable
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:9
 │    │    ├── fd: (1)-->(2)
 │    │    ├── offset
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── cardinality: [0 - 7]
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── limit
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── cardinality: [0 - 10]
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: (1)-->(2)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(2)
 │    │    │    │    │    └── limit hint: 10.00
 │    │    │    │    └── 10
 │    │    │    └── 3
 │    │    ├── scan b
 │    │    │    └── columns: y:9
 │    │    └── filters
 │    │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 │    └── projections
 │         └── i:2 * 2 [as=computed:12, outer=(2), immutable]
 └── aggregations
      └── sum [as=sum:13, outer=(12)]
           └── computed:12

# Case with Ordinality operator between join and group by - should still work.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(ordinality) FROM (SELECT k, ordinality FROM a WITH ORDINALITY LEFT JOIN b ON i = y) GROUP BY k LIMIT 7 OFFSET 3
----
group-by (hash)
 ├── columns: k:1!null sum:13!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 ordinality:8!null y:10
 │    ├── fd: (1)-->(2,8), (8)-->(1,2)
 │    ├── ordinality
 │    │    ├── columns: k:1!null i:2 ordinality:8!null
 │    │    ├── cardinality: [0 - 7]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,8), (8)-->(1,2)
 │    │    └── offset
 │    │         ├── columns: k:1!null i:2
 │    │         ├── cardinality: [0 - 7]
 │    │         ├── key: (1)
 │    │         ├── fd: (1)-->(2)
 │    │         ├── limit
 │    │         │    ├── columns: k:1!null i:2
 │    │         │    ├── cardinality: [0 - 10]
 │    │         │    ├── key: (1)
 │    │         │    ├── fd: (1)-->(2)
 │    │         │    ├── scan a
 │    │         │    │    ├── columns: k:1!null i:2
 │    │         │    │    ├── key: (1)
 │    │         │    │    ├── fd: (1)-->(2)
 │    │         │    │    └── limit hint: 10.00
 │    │         │    └── 10
 │    │         └── 3
 │    ├── scan b
 │    │    └── columns: y:10
 │    └── filters
 │         └── i:2 = y:10 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
 └── aggregations
      └── sum [as=sum:13, outer=(8)]
           └── ordinality:8

# Case with Window operator between join and group by - should still work.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(computed) FROM (SELECT k, row_number() OVER () as computed FROM a LEFT JOIN b ON i = y) GROUP BY k LIMIT 7 OFFSET 3
----
group-by (hash)
 ├── columns: k:1!null sum:13
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── window partition=()
 │    ├── columns: k:1!null i:2 y:9 row_number:12
 │    ├── fd: (1)-->(2)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:9
 │    │    ├── fd: (1)-->(2)
 │    │    ├── offset
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── cardinality: [0 - 7]
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── limit
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── cardinality: [0 - 10]
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: (1)-->(2)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(2)
 │    │    │    │    │    └── limit hint: 10.00
 │    │    │    │    └── 10
 │    │    │    └── 3
 │    │    ├── scan b
 │    │    │    └── columns: y:9
 │    │    └── filters
 │    │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 │    └── windows
 │         └── row-number [as=row_number:12]
 └── aggregations
      └── sum [as=sum:13, outer=(12)]
           └── row_number:12

# Case with a Select - the limit is pushed to the filter, but not below it.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a LEFT JOIN b ON i = y WHERE k > 10) GROUP BY k LIMIT 6
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:9
 │    ├── fd: (1)-->(2)
 │    ├── limit
 │    │    ├── columns: k:1!null i:2
 │    │    ├── cardinality: [0 - 6]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── select
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── limit hint: 6.00
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: (1)-->(2)
 │    │    │    │    └── limit hint: 18.00
 │    │    │    └── filters
 │    │    │         └── k:1 > 10 [outer=(1), constraints=(/1: [/11 - ]; tight)]
 │    │    └── 6
 │    ├── scan b
 │    │    └── columns: y:9
 │    └── filters
 │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# Offset case.
norm expect=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a LEFT JOIN b ON i = y WHERE k > 10) GROUP BY k OFFSET 6
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── left-join (hash)
 │    ├── columns: k:1!null i:2 y:9
 │    ├── fd: (1)-->(2)
 │    ├── offset
 │    │    ├── columns: k:1!null i:2
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── select
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── filters
 │    │    │         └── k:1 > 10 [outer=(1), constraints=(/1: [/11 - ]; tight)]
 │    │    └── 6
 │    ├── scan b
 │    │    └── columns: y:9
 │    └── filters
 │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# No-op Limit case for ScalarGroupBy.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) LIMIT 1
----
scalar-group-by
 ├── columns: sum:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 ├── inner-join (hash)
 │    ├── columns: i:2!null x:8!null y:9
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── fd: (8)-->(9), (2)==(8), (8)==(2)
 │    ├── scan a
 │    │    └── columns: i:2
 │    ├── scan b
 │    │    ├── columns: x:8!null y:9
 │    │    ├── key: (8)
 │    │    └── fd: (8)-->(9)
 │    └── filters
 │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# No-op Offset case for ScalarGroupBy.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) OFFSET 1
----
values
 ├── columns: sum:12!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(12)

# Don't match when grouping columns don't form a key in the input.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT i, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY i LIMIT 5 OFFSET 1
----
offset
 ├── columns: i:2!null sum:12
 ├── cardinality: [0 - 5]
 ├── key: (2)
 ├── fd: (2)-->(12)
 ├── limit
 │    ├── columns: i:2!null sum:12
 │    ├── cardinality: [0 - 6]
 │    ├── key: (2)
 │    ├── fd: (2)-->(12)
 │    ├── group-by (hash)
 │    │    ├── columns: i:2!null sum:12
 │    │    ├── grouping columns: i:2!null
 │    │    ├── key: (2)
 │    │    ├── fd: (2)-->(12)
 │    │    ├── limit hint: 6.00
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: i:2!null x:8!null y:9
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── fd: (8)-->(9), (2)==(8), (8)==(2)
 │    │    │    ├── scan a
 │    │    │    │    └── columns: i:2
 │    │    │    ├── scan b
 │    │    │    │    ├── columns: x:8!null y:9
 │    │    │    │    ├── key: (8)
 │    │    │    │    └── fd: (8)-->(9)
 │    │    │    └── filters
 │    │    │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    │    └── aggregations
 │    │         └── sum [as=sum:12, outer=(9)]
 │    │              └── y:9
 │    └── 6
 └── 1

# Don't match when input has outer columns (avoid interfering with decorrelation).
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, (SELECT sum(y) FROM b WHERE x = i GROUP BY x LIMIT 1) FROM a LIMIT 3
----
project
 ├── columns: k:1!null sum:13
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── limit
 │    ├── columns: k:1!null i:2 sum:12
 │    ├── cardinality: [0 - 3]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,12)
 │    ├── left-join-apply
 │    │    ├── columns: k:1!null i:2 sum:12
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,12)
 │    │    ├── limit hint: 3.00
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── group-by (streaming)
 │    │    │    ├── columns: sum:12
 │    │    │    ├── outer: (2)
 │    │    │    ├── cardinality: [0 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(12)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:8!null y:9
 │    │    │    │    ├── outer: (2)
 │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(8,9)
 │    │    │    │    ├── scan b
 │    │    │    │    │    ├── columns: x:8!null y:9
 │    │    │    │    │    ├── key: (8)
 │    │    │    │    │    └── fd: (8)-->(9)
 │    │    │    │    └── filters
 │    │    │    │         └── x:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    │    │    └── aggregations
 │    │    │         └── sum [as=sum:12, outer=(9)]
 │    │    │              └── y:9
 │    │    └── filters (true)
 │    └── 3
 └── projections
      └── sum:12 [as=sum:13, outer=(12)]

# Don't match when limit >= max rows of input (would be eliminated by EliminateLimit).
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM (SELECT * FROM a LIMIT 5) t INNER JOIN b ON i = x) GROUP BY k LIMIT 10
----
group-by (hash)
 ├── columns: k:1!null sum:12
 ├── grouping columns: k:1!null
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── inner-join (hash)
 │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    ├── cardinality: [0 - 5]
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    ├── key: (1)
 │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    ├── limit
 │    │    ├── columns: k:1!null i:2
 │    │    ├── cardinality: [0 - 5]
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    └── limit hint: 5.00
 │    │    └── 5
 │    ├── scan b
 │    │    ├── columns: x:8!null y:9
 │    │    ├── key: (8)
 │    │    └── fd: (8)-->(9)
 │    └── filters
 │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 └── aggregations
      └── sum [as=sum:12, outer=(9)]
           └── y:9

# Don't match when limit ordering can't be satisfied by input columns.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY k ORDER BY sum(y) LIMIT 4
----
limit
 ├── columns: k:1!null sum:12
 ├── internal-ordering: +12
 ├── cardinality: [0 - 4]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── ordering: +12
 ├── sort
 │    ├── columns: k:1!null sum:12
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── ordering: +12
 │    ├── limit hint: 4.00
 │    └── group-by (hash)
 │         ├── columns: k:1!null sum:12
 │         ├── grouping columns: k:1!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(12)
 │         ├── inner-join (hash)
 │         │    ├── columns: k:1!null i:2!null x:8!null y:9
 │         │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │         │    ├── key: (1)
 │         │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │         │    ├── scan a
 │         │    │    ├── columns: k:1!null i:2
 │         │    │    ├── key: (1)
 │         │    │    └── fd: (1)-->(2)
 │         │    ├── scan b
 │         │    │    ├── columns: x:8!null y:9
 │         │    │    ├── key: (8)
 │         │    │    └── fd: (8)-->(9)
 │         │    └── filters
 │         │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │         └── aggregations
 │              └── sum [as=sum:12, outer=(9)]
 │                   └── y:9
 └── 4

# Offset case.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY k ORDER BY sum(y) LIMIT 4
----
limit
 ├── columns: k:1!null sum:12
 ├── internal-ordering: +12
 ├── cardinality: [0 - 4]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── ordering: +12
 ├── sort
 │    ├── columns: k:1!null sum:12
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── ordering: +12
 │    ├── limit hint: 4.00
 │    └── group-by (hash)
 │         ├── columns: k:1!null sum:12
 │         ├── grouping columns: k:1!null
 │         ├── key: (1)
 │         ├── fd: (1)-->(12)
 │         ├── inner-join (hash)
 │         │    ├── columns: k:1!null i:2!null x:8!null y:9
 │         │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │         │    ├── key: (1)
 │         │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │         │    ├── scan a
 │         │    │    ├── columns: k:1!null i:2
 │         │    │    ├── key: (1)
 │         │    │    └── fd: (1)-->(2)
 │         │    ├── scan b
 │         │    │    ├── columns: x:8!null y:9
 │         │    │    ├── key: (8)
 │         │    │    └── fd: (8)-->(9)
 │         │    └── filters
 │         │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │         └── aggregations
 │              └── sum [as=sum:12, outer=(9)]
 │                   └── y:9
 └── 4

# Don't match when the input of the group-by can filter rows.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = y) GROUP BY k LIMIT 6 OFFSET 2
----
offset
 ├── columns: k:1!null sum:12!null
 ├── cardinality: [0 - 6]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── limit
 │    ├── columns: k:1!null sum:12!null
 │    ├── cardinality: [0 - 8]
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── group-by (hash)
 │    │    ├── columns: k:1!null sum:12!null
 │    │    ├── grouping columns: k:1!null
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(12)
 │    │    ├── limit hint: 8.00
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: k:1!null i:2!null y:9!null
 │    │    │    ├── fd: (1)-->(2), (2)==(9), (9)==(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan b
 │    │    │    │    └── columns: y:9
 │    │    │    └── filters
 │    │    │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 │    │    └── aggregations
 │    │         └── sum [as=sum:12, outer=(9)]
 │    │              └── y:9
 │    └── 8
 └── 2

# Don't match when the input of the group-by can add rows.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(i) FROM (SELECT k, i FROM a UNION (SELECT x, y FROM b)) GROUP BY k LIMIT 6 OFFSET 6
----
offset
 ├── columns: k:12!null sum:14
 ├── cardinality: [0 - 6]
 ├── key: (12)
 ├── fd: (12)-->(14)
 ├── limit
 │    ├── columns: k:12!null sum:14
 │    ├── cardinality: [0 - 12]
 │    ├── key: (12)
 │    ├── fd: (12)-->(14)
 │    ├── group-by (hash)
 │    │    ├── columns: k:12!null sum:14
 │    │    ├── grouping columns: k:12!null
 │    │    ├── key: (12)
 │    │    ├── fd: (12)-->(14)
 │    │    ├── limit hint: 12.00
 │    │    ├── union
 │    │    │    ├── columns: k:12!null i:13
 │    │    │    ├── left columns: a.k:1 a.i:2
 │    │    │    ├── right columns: x:8 y:9
 │    │    │    ├── key: (12,13)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: a.k:1!null a.i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── scan b
 │    │    │         ├── columns: x:8!null y:9
 │    │    │         ├── key: (8)
 │    │    │         └── fd: (8)-->(9)
 │    │    └── aggregations
 │    │         └── sum [as=sum:14, outer=(13)]
 │    │              └── i:13
 │    └── 12
 └── 6

# Don't match with negative limit.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a INNER JOIN b ON i = x) GROUP BY k LIMIT -1
----
limit
 ├── columns: k:1!null sum:12
 ├── cardinality: [0 - 0]
 ├── immutable
 ├── key: ()
 ├── fd: ()-->(1,12)
 ├── group-by (hash)
 │    ├── columns: k:1!null sum:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── limit hint: 1.00
 │    ├── inner-join (hash)
 │    │    ├── columns: k:1!null i:2!null x:8!null y:9
 │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan b
 │    │    │    ├── columns: x:8!null y:9
 │    │    │    ├── key: (8)
 │    │    │    └── fd: (8)-->(9)
 │    │    └── filters
 │    │         └── i:2 = x:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── aggregations
 │         └── sum [as=sum:12, outer=(9)]
 │              └── y:9
 └── -1

# No-op because grouping by a projected column.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k_proj, sum(y) FROM (SELECT k * 1000 AS k_proj, i, y FROM a LEFT JOIN b ON i = y) GROUP BY k_proj LIMIT 10
----
limit
 ├── columns: k_proj:12!null sum:13
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (12)
 ├── fd: (12)-->(13)
 ├── group-by (hash)
 │    ├── columns: k_proj:12!null sum:13
 │    ├── grouping columns: k_proj:12!null
 │    ├── immutable
 │    ├── key: (12)
 │    ├── fd: (12)-->(13)
 │    ├── limit hint: 10.00
 │    ├── project
 │    │    ├── columns: k_proj:12!null y:9
 │    │    ├── immutable
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: k:1!null i:2 y:9
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan b
 │    │    │    │    └── columns: y:9
 │    │    │    └── filters
 │    │    │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 │    │    └── projections
 │    │         └── k:1 * 1000 [as=k_proj:12, outer=(1), immutable]
 │    └── aggregations
 │         └── sum [as=sum:13, outer=(9)]
 │              └── y:9
 └── 10

# No-op case with grouping on a projected column under the join.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k_proj, sum(y) FROM (SELECT k_proj, i, y FROM (SELECT *, k * 1000 AS k_proj FROM a) LEFT JOIN b ON i = y) GROUP BY k_proj LIMIT 10
----
limit
 ├── columns: k_proj:8!null sum:13
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (8)
 ├── fd: (8)-->(13)
 ├── group-by (hash)
 │    ├── columns: k_proj:8!null sum:13
 │    ├── grouping columns: k_proj:8!null
 │    ├── immutable
 │    ├── key: (8)
 │    ├── fd: (8)-->(13)
 │    ├── limit hint: 10.00
 │    ├── left-join (hash)
 │    │    ├── columns: i:2 k_proj:8!null y:10
 │    │    ├── immutable
 │    │    ├── project
 │    │    │    ├── columns: k_proj:8!null i:2
 │    │    │    ├── immutable
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── projections
 │    │    │         └── k:1 * 1000 [as=k_proj:8, outer=(1), immutable]
 │    │    ├── scan b
 │    │    │    └── columns: y:10
 │    │    └── filters
 │    │         └── i:2 = y:10 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
 │    └── aggregations
 │         └── sum [as=sum:13, outer=(10)]
 │              └── y:10
 └── 10

# Do not push into the right input of a LeftJoin.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM b LEFT JOIN a ON i = y) GROUP BY k LIMIT 5
----
limit
 ├── columns: k:5 sum:12
 ├── cardinality: [0 - 5]
 ├── key: (5)
 ├── fd: (5)-->(12)
 ├── group-by (hash)
 │    ├── columns: k:5 sum:12
 │    ├── grouping columns: k:5
 │    ├── key: (5)
 │    ├── fd: (5)-->(12)
 │    ├── limit hint: 5.00
 │    ├── left-join (hash)
 │    │    ├── columns: y:2 k:5 i:6
 │    │    ├── fd: (5)-->(6)
 │    │    ├── scan b
 │    │    │    └── columns: y:2
 │    │    ├── scan a
 │    │    │    ├── columns: k:5!null i:6
 │    │    │    ├── key: (5)
 │    │    │    └── fd: (5)-->(6)
 │    │    └── filters
 │    │         └── i:6 = y:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
 │    └── aggregations
 │         └── sum [as=sum:12, outer=(2)]
 │              └── y:2
 └── 5

# Do not push into either input of a FullJoin.
norm expect-not=PushLimitOrOffsetIntoGroupBy
SELECT k, sum(y) FROM (SELECT k, i, y FROM a FULL JOIN b ON i = y) GROUP BY k LIMIT 5
----
limit
 ├── columns: k:1 sum:12
 ├── cardinality: [0 - 5]
 ├── key: (1)
 ├── fd: (1)-->(12)
 ├── group-by (hash)
 │    ├── columns: k:1 sum:12
 │    ├── grouping columns: k:1
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── limit hint: 5.00
 │    ├── full-join (hash)
 │    │    ├── columns: k:1 i:2 y:9
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan b
 │    │    │    └── columns: y:9
 │    │    └── filters
 │    │         └── i:2 = y:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 │    └── aggregations
 │         └── sum [as=sum:12, outer=(9)]
 │              └── y:9
 └── 5
