exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE computed (a INT PRIMARY KEY, b INT, c INT AS (a+b+1) STORED)
----

exec-ddl
CREATE TABLE b (k INT PRIMARY KEY, i INT, f FLOAT, s STRING NOT NULL, j JSON)
----

exec-ddl
CREATE TABLE virt (
  k INT PRIMARY KEY,
  i INT,
  s STRING,
  j JSON,
  v STRING AS (lower(s)) VIRTUAL,
  x JSON AS (j->'x') VIRTUAL,
  INDEX (v),
  INVERTED INDEX (x)
)
----

# --------------------------------------------------
# InlineConstVar
# --------------------------------------------------

norm expect=InlineConstVar
SELECT k FROM b WHERE i=5 AND i IN (1, 2, 3, 4, 5)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null i:2!null
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan b
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT k FROM b WHERE i=8 AND 3 = mod(i, 5)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null i:2!null
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan b
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── i:2 = 8 [outer=(2), constraints=(/2: [/8 - /8]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT k FROM b WHERE i=5 AND i IN (1, 2, 3, 4)
----
values
 ├── columns: k:1!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1)

# Case that requires multiple iterations to fully inline.
norm expect=InlineConstVar
SELECT * FROM xy WHERE x=y AND y=4 AND x IN (1, 2, 3, 4)
----
select
 ├── columns: x:1!null y:2!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2)
 ├── scan xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── filters
      ├── x:1 = 4 [outer=(1), constraints=(/1: [/4 - /4]; tight), fd=()-->(1)]
      └── y:2 = 4 [outer=(2), constraints=(/2: [/4 - /4]; tight), fd=()-->(2)]

norm expect=InlineConstVar
SELECT * FROM xy WHERE x=y AND y=4 AND x=3
----
values
 ├── columns: x:1!null y:2!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1,2)

# Can't inline composite types.
norm expect-not=InlineConstVar
SELECT * FROM (VALUES (0.0), (0.00), (0.000)) AS v (x) WHERE x = 0 AND x::STRING = '0.00';
----
select
 ├── columns: x:1!null
 ├── cardinality: [0 - 3]
 ├── immutable
 ├── fd: ()-->(1)
 ├── values
 │    ├── columns: column1:1!null
 │    ├── cardinality: [3 - 3]
 │    ├── (0.0,)
 │    ├── (0.00,)
 │    └── (0.000,)
 └── filters
      ├── column1:1 = 0 [outer=(1), immutable, constraints=(/1: [/0 - /0]; tight), fd=()-->(1)]
      └── column1:1::STRING = '0.00' [outer=(1), immutable]

# The rule should trigger, but not inline the composite type.
norm expect=InlineConstVar
SELECT * FROM (VALUES (0.0, 'a'), (0.00, 'b'), (0.000, 'b')) AS v (x, y) WHERE x = 0 AND x::STRING = '0.00' AND y = 'b' AND y IN ('a', 'b');
----
select
 ├── columns: x:1!null y:2!null
 ├── cardinality: [0 - 3]
 ├── immutable
 ├── fd: ()-->(1,2)
 ├── values
 │    ├── columns: column1:1!null column2:2!null
 │    ├── cardinality: [3 - 3]
 │    ├── (0.0, 'a')
 │    ├── (0.00, 'b')
 │    └── (0.000, 'b')
 └── filters
      ├── column1:1 = 0 [outer=(1), immutable, constraints=(/1: [/0 - /0]; tight), fd=()-->(1)]
      ├── column1:1::STRING = '0.00' [outer=(1), immutable]
      └── column2:2 = 'b' [outer=(2), constraints=(/2: [/'b' - /'b']; tight), fd=()-->(2)]

# Ensure that InlineConstVar fires before filter pushdown rules.
norm expect=InlineConstVar
SELECT * FROM a INNER JOIN xy ON True WHERE y=10 AND i<y
----
inner-join (cross)
 ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:8!null y:9!null
 ├── key: (1,8)
 ├── fd: ()-->(9), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── i:2 < 10 [outer=(2), constraints=(/2: (/NULL - /9]; tight)]
 ├── select
 │    ├── columns: x:8!null y:9!null
 │    ├── key: (8)
 │    ├── fd: ()-->(9)
 │    ├── scan xy
 │    │    ├── columns: x:8!null y:9
 │    │    ├── key: (8)
 │    │    └── fd: (8)-->(9)
 │    └── filters
 │         └── y:9 = 10 [outer=(9), constraints=(/9: [/10 - /10]; tight), fd=()-->(9)]
 └── filters (true)

# --------------------------------------------------
# InlineProjectConstants
# --------------------------------------------------

# Inline constants from Project expression.
norm expect=InlineProjectConstants
UPDATE computed SET a=1, b=2
----
update computed
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    ├── a_new:11 => a:1
 │    ├── b_new:12 => b:2
 │    └── c_comp:13 => c:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: c_comp:13!null a_new:11!null b_new:12!null a:6!null b:7 c:8
      ├── key: (6)
      ├── fd: ()-->(11-13), (6)-->(7,8)
      ├── scan computed
      │    ├── columns: a:6!null b:7 c:8
      │    ├── computed column expressions
      │    │    └── c:8
      │    │         └── (a:6 + b:7) + 1
      │    ├── key: (6)
      │    └── fd: (6)-->(7,8)
      └── projections
           ├── 4 [as=c_comp:13]
           ├── 1 [as=a_new:11]
           └── 2 [as=b_new:12]

# Inline constants from Values expression.
norm expect=InlineProjectConstants
SELECT one+two+three+four FROM (VALUES (1, $1:::int, 2, $2:::int)) AS t(one, two, three, four)
----
project
 ├── columns: "?column?":5
 ├── cardinality: [1 - 1]
 ├── immutable, has-placeholder
 ├── key: ()
 ├── fd: ()-->(5)
 ├── values
 │    ├── columns: column2:2 column4:4
 │    ├── cardinality: [1 - 1]
 │    ├── has-placeholder
 │    ├── key: ()
 │    ├── fd: ()-->(2,4)
 │    └── ($1, $2)
 └── projections
      └── column4:4 + ((column2:2 + 1) + 2) [as="?column?":5, outer=(2,4), immutable]

# Multiple constant columns, multiple refs to each, interspersed with other
# columns.
norm expect=InlineProjectConstants
SELECT one+two, x, one*two, y FROM (SELECT x, 1 AS one, y, 2 AS two FROM xy)
----
project
 ├── columns: "?column?":7!null x:1!null "?column?":8!null y:2
 ├── key: (1)
 ├── fd: ()-->(7,8), (1)-->(2)
 ├── scan xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      ├── 3 [as="?column?":7]
      └── 2 [as="?column?":8]

# Constant column reference within correlated subquery (which becomes
# uncorrelated as a result).
norm expect=InlineProjectConstants
SELECT EXISTS(SELECT * FROM a WHERE k=one AND i=two) FROM (VALUES (1, 2)) AS t(one, two)
----
values
 ├── columns: exists:10
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(10)
 └── tuple
      └── exists
           └── select
                ├── columns: k:3!null i:4!null f:5 s:6 j:7
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(3-7)
                ├── scan a
                │    ├── columns: k:3!null i:4 f:5 s:6 j:7
                │    ├── key: (3)
                │    └── fd: (3)-->(4-7)
                └── filters
                     ├── k:3 = 1 [outer=(3), constraints=(/3: [/1 - /1]; tight), fd=()-->(3)]
                     └── i:4 = 2 [outer=(4), constraints=(/4: [/2 - /2]; tight), fd=()-->(4)]

# Do not inline constants from Values expression with multiple rows.
norm expect-not=InlineProjectConstants
SELECT one+two FROM (VALUES (1, 2), (3, 4)) AS t(one, two)
----
project
 ├── columns: "?column?":3!null
 ├── cardinality: [2 - 2]
 ├── immutable
 ├── values
 │    ├── columns: column1:1!null column2:2!null
 │    ├── cardinality: [2 - 2]
 │    ├── (1, 2)
 │    └── (3, 4)
 └── projections
      └── column1:1 + column2:2 [as="?column?":3, outer=(1,2), immutable]

# --------------------------------------------------
# InlineSelectConstants
# --------------------------------------------------

# Inline constants from Project expression.
norm expect=InlineSelectConstants
SELECT * FROM (SELECT 1 AS one from xy) WHERE one > 0
----
project
 ├── columns: one:5!null
 ├── fd: ()-->(5)
 ├── scan xy
 └── projections
      └── 1 [as=one:5]

# Inline constants from Values expression.
norm expect=InlineSelectConstants
SELECT *
FROM (VALUES ($1:::int, 1, $2:::float, 2)) AS t(one, two, three, four)
WHERE one = two OR three = four
----
select
 ├── columns: one:1 two:2!null three:3 four:4!null
 ├── cardinality: [0 - 1]
 ├── has-placeholder
 ├── key: ()
 ├── fd: ()-->(1-4)
 ├── values
 │    ├── columns: column1:1 column2:2!null column3:3 column4:4!null
 │    ├── cardinality: [1 - 1]
 │    ├── has-placeholder
 │    ├── key: ()
 │    ├── fd: ()-->(1-4)
 │    └── ($1, 1, $2, 2)
 └── filters
      └── (column1:1 = 1) OR (column3:3 = 2.0) [outer=(1,3)]

# Multiple constant columns, multiple refs to each, interspersed with other
# columns.
norm expect=InlineSelectConstants
SELECT * FROM (SELECT x, 1 AS one, y, 2 AS two FROM xy) WHERE x=one AND y=two
----
project
 ├── columns: x:1!null one:5!null y:2!null two:6!null
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1,2,5,6)
 ├── select
 │    ├── columns: x:1!null y:2!null
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1,2)
 │    ├── scan xy
 │    │    ├── columns: x:1!null y:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── filters
 │         ├── x:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]
 │         └── y:2 = 2 [outer=(2), constraints=(/2: [/2 - /2]; tight), fd=()-->(2)]
 └── projections
      ├── 1 [as=one:5]
      └── 2 [as=two:6]

# Do not inline constants from Values expression with multiple rows.
norm expect-not=InlineSelectConstants
SELECT * FROM (VALUES (1, 2), (3, 4)) AS t(one, two) WHERE one=two
----
select
 ├── columns: one:1!null two:2!null
 ├── cardinality: [0 - 2]
 ├── fd: (1)==(2), (2)==(1)
 ├── values
 │    ├── columns: column1:1!null column2:2!null
 │    ├── cardinality: [2 - 2]
 │    ├── (1, 2)
 │    └── (3, 4)
 └── filters
      └── column1:1 = column2:2 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]

# --------------------------------------------------
# InlineJoinConstantsLeft + InlineJoinConstantsRight
# --------------------------------------------------
norm expect=InlineJoinConstantsLeft
SELECT * FROM (SELECT 1 AS one) LEFT JOIN a ON k=one
----
left-join (cross)
 ├── columns: one:1!null k:2 i:3 f:4 s:5 j:6
 ├── cardinality: [1 - 1]
 ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 ├── key: ()
 ├── fd: ()-->(1-6)
 ├── values
 │    ├── columns: one:1!null
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1)
 │    └── (1,)
 ├── select
 │    ├── columns: k:2!null i:3 f:4 s:5 j:6
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(2-6)
 │    ├── scan a
 │    │    ├── columns: k:2!null i:3 f:4 s:5 j:6
 │    │    ├── key: (2)
 │    │    └── fd: (2)-->(3-6)
 │    └── filters
 │         └── k:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]
 └── filters (true)

norm expect=InlineJoinConstantsRight
SELECT * FROM a FULL JOIN (SELECT 1 AS one) ON k=one
----
full-join (cross)
 ├── columns: k:1 i:2 f:3 s:4 j:5 one:8
 ├── cardinality: [1 - ]
 ├── multiplicity: left-rows(exactly-one), right-rows(one-or-more)
 ├── key: (1)
 ├── fd: (1)-->(2-5,8)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── values
 │    ├── columns: one:8!null
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(8)
 │    └── (1,)
 └── filters
      └── k:1 = 1 [outer=(1), constraints=(/1: [/1 - /1]; tight), fd=()-->(1)]

norm expect=(InlineJoinConstantsLeft,InlineJoinConstantsRight)
SELECT * FROM (SELECT 1 AS one) INNER JOIN (SELECT 2 AS two) ON one=two
----
values
 ├── columns: one:1!null two:2!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(1,2)

# Constant column exists in input, but is not referenced.
norm expect-not=(InlineJoinConstantsLeft,InlineJoinConstantsRight)
SELECT * FROM a INNER JOIN (SELECT 1 AS one, y FROM xy) ON k=y
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5 one:12!null y:9!null
 ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
 ├── fd: ()-->(12), (1)-->(2-5), (1)==(9), (9)==(1)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── project
 │    ├── columns: one:12!null y:9
 │    ├── fd: ()-->(12)
 │    ├── scan xy
 │    │    └── columns: y:9
 │    └── projections
 │         └── 1 [as=one:12]
 └── filters
      └── k:1 = y:9 [outer=(1,9), constraints=(/1: (/NULL - ]; /9: (/NULL - ]), fd=(1)==(9), (9)==(1)]

# Regression test for #50841
exec-ddl
CREATE TABLE kv  (k  INT8 PRIMARY KEY, v  INT8);
----

exec-ddl
CREATE TABLE kv2 (k2 INT8 PRIMARY KEY, v2 INT8);
----

# Ensure that lookup joins are used.
opt expect-not=InlineJoinConstantsLeft format=hide-all
SELECT v, v2
FROM (SELECT unnest('{1}'::INT8[]) AS lookup_k)
INNER LOOKUP JOIN (SELECT k, v FROM kv) ON k = lookup_k
INNER LOOKUP JOIN (SELECT k2, v2 FROM kv2) ON k2 = lookup_k;
----
project
 └── inner-join (lookup kv2)
      ├── flags: force lookup join (into right side)
      ├── lookup columns are key
      ├── inner-join (lookup kv)
      │    ├── flags: force lookup join (into right side)
      │    ├── lookup columns are key
      │    ├── values
      │    │    └── (1,)
      │    └── filters (true)
      └── filters (true)

# Ensure that merge joins are used.
opt expect-not=InlineJoinConstantsLeft format=hide-all
SELECT v, v2
FROM (SELECT unnest('{1}'::INT8[]) AS lookup_k)
INNER MERGE JOIN (SELECT k, v FROM kv) ON k = lookup_k
INNER MERGE JOIN (SELECT k2, v2 FROM kv2) ON k2 = lookup_k;
----
project
 └── inner-join (merge)
      ├── flags: force merge join
      ├── inner-join (merge)
      │    ├── flags: force merge join
      │    ├── values
      │    │    └── (1,)
      │    ├── scan kv
      │    └── filters (true)
      ├── scan kv2
      └── filters (true)

# Ensure that merge joins are used.
opt expect-not=InlineJoinConstantsRight format=hide-all
SELECT v, v2
FROM (SELECT k, v FROM kv)
INNER MERGE JOIN (SELECT unnest('{1}'::INT8[]) AS lookup_k) ON k = lookup_k
INNER MERGE JOIN (SELECT k2, v2 FROM kv2) ON k2 = lookup_k;
----
project
 └── inner-join (merge)
      ├── flags: force merge join
      ├── project
      │    ├── scan kv
      │    │    └── constraint: /1: [/1 - /1]
      │    └── projections
      │         └── 1
      ├── scan kv2
      └── filters (true)

# --------------------------------------------------
# PushSelectIntoInlinableProject
# --------------------------------------------------

# Inline comparison.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM (SELECT k=1 AS expr FROM a) a WHERE expr IS NULL
----
project
 ├── columns: expr:8!null
 ├── select
 │    ├── columns: k:1!null
 │    ├── key: (1)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    └── filters
 │         └── (k:1 = 1) IS NULL [outer=(1)]
 └── projections
      └── k:1 = 1 [as=expr:8, outer=(1)]

# Inline arithmetic.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM (SELECT k*2+1 AS expr FROM a) a WHERE expr > 10
----
project
 ├── columns: expr:8!null
 ├── immutable
 ├── select
 │    ├── columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    └── filters
 │         └── (k:1 * 2) > 9 [outer=(1), immutable]
 └── projections
      └── (k:1 * 2) + 1 [as=expr:8, outer=(1), immutable]

# Inline boolean logic.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM (SELECT NOT(k>1 AND k<=5) AS expr FROM a) a WHERE expr
----
project
 ├── columns: expr:8!null
 ├── select
 │    ├── columns: k:1!null
 │    ├── key: (1)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    └── filters
 │         └── (k:1 <= 1) OR (k:1 > 5) [outer=(1), constraints=(/1: (/NULL - /1] [/6 - ]; tight)]
 └── projections
      └── (k:1 <= 1) OR (k:1 > 5) [as=expr:8, outer=(1)]

# Inline constants.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM (SELECT (f IS NULL OR f != 10.5) AS expr FROM a) a WHERE expr
----
project
 ├── columns: expr:8
 ├── select
 │    ├── columns: f:3
 │    ├── scan a
 │    │    └── columns: f:3
 │    └── filters
 │         └── (f:3 IS NULL) OR (f:3 != 10.5) [outer=(3), constraints=(/3: [/NULL - /10.499999999999998] [/10.500000000000002 - ]; tight)]
 └── projections
      └── (f:3 IS NULL) OR (f:3 != 10.5) [as=expr:8, outer=(3)]

# Reference the expression to inline multiple times.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM (SELECT f+1 AS expr FROM a) a WHERE expr=expr
----
project
 ├── columns: expr:8
 ├── immutable
 ├── select
 │    ├── columns: f:3
 │    ├── immutable
 │    ├── scan a
 │    │    └── columns: f:3
 │    └── filters
 │         └── (f:3 + 1.0) IS DISTINCT FROM CAST(NULL AS FLOAT8) [outer=(3), immutable]
 └── projections
      └── f:3 + 1.0 [as=expr:8, outer=(3), immutable]

# Use outer references in both inlined expression and in referencing expression.
norm expect=PushSelectIntoInlinableProject
SELECT * FROM a WHERE EXISTS(SELECT * FROM (SELECT (x-i) AS expr FROM xy) WHERE expr > i*i)
----
semi-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:8!null
 │    └── key: (8)
 └── filters
      └── (x:8 - i:2) > (i:2 * i:2) [outer=(2,8), immutable]

exec-ddl
CREATE TABLE crdb_internal.zones (
    zone_id INT NOT NULL,
    cli_specifier STRING NULL,
    config_yaml BYTES NOT NULL,
    config_protobuf BYTES NOT NULL
)
----

# Regression test for #28827. Ensure that inlining is not applied when there
# is a correlated subquery in the filter.
norm
SELECT
  subq_0.c0 AS c0
FROM (SELECT zone_id+1 AS c0, zone_id+2 as c1 FROM crdb_internal.zones) AS subq_0
WHERE
  1
  >= CASE
    WHEN subq_0.c1 IS NOT NULL
    THEN pg_catalog.extract(
      CAST(
        CASE
        WHEN
        (
            EXISTS(
              SELECT
                ref_1.config_yaml AS c0,
                ref_1.config_yaml AS c1,
                subq_0.c0 AS c2,
                ref_1.config_yaml AS c3
              FROM
                crdb_internal.zones AS ref_1
              WHERE
                subq_0.c0 IS NOT NULL
              LIMIT
                52
            )
          )
        THEN pg_catalog.version()
        ELSE pg_catalog.version()
        END
          AS TEXT
      ),
      CAST(pg_catalog.current_date() AS DATE)
    )
    ELSE 1
    END
LIMIT
  107
----
project
 ├── columns: c0:8!null
 ├── cardinality: [0 - 107]
 ├── volatile
 └── limit
      ├── columns: c0:8!null c1:9!null
      ├── cardinality: [0 - 107]
      ├── volatile
      ├── select
      │    ├── columns: c0:8!null c1:9!null
      │    ├── volatile
      │    ├── limit hint: 107.00
      │    ├── project
      │    │    ├── columns: c0:8!null c1:9!null
      │    │    ├── immutable
      │    │    ├── limit hint: 321.00
      │    │    ├── scan zones
      │    │    │    ├── columns: crdb_internal.public.zones.zone_id:1!null
      │    │    │    └── limit hint: 321.00
      │    │    └── projections
      │    │         ├── crdb_internal.public.zones.zone_id:1 + 1 [as=c0:8, outer=(1), immutable]
      │    │         └── crdb_internal.public.zones.zone_id:1 + 2 [as=c1:9, outer=(1), immutable]
      │    └── filters
      │         └── le [outer=(8,9), volatile, correlated-subquery]
      │              ├── case
      │              │    ├── true
      │              │    ├── when
      │              │    │    ├── c1:9 IS NOT NULL
      │              │    │    └── function: extract
      │              │    │         ├── case
      │              │    │         │    ├── true
      │              │    │         │    ├── when
      │              │    │         │    │    ├── exists
      │              │    │         │    │    │    └── select
      │              │    │         │    │    │         ├── columns: ref_1.config_yaml:12!null
      │              │    │         │    │    │         ├── outer: (8)
      │              │    │         │    │    │         ├── scan zones [as=ref_1]
      │              │    │         │    │    │         │    └── columns: ref_1.config_yaml:12!null
      │              │    │         │    │    │         └── filters
      │              │    │         │    │    │              └── c0:8 IS NOT NULL [outer=(8), constraints=(/8: (/NULL - ]; tight)]
      │              │    │         │    │    └── version()
      │              │    │         │    └── version()
      │              │    │         └── '2017-05-10'
      │              │    └── 1.0
      │              └── 1.0
      └── 107

# --------------------------------------------------
# InlineSelectVirtualColumns
# --------------------------------------------------

# Inline indexed virtual columns in a Select below the Project.
norm expect=InlineSelectVirtualColumns
SELECT * FROM virt WHERE v = 'foo'
----
project
 ├── columns: k:1!null i:2 s:3 j:4 v:5 x:6
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(5), (4)-->(6)
 ├── select
 │    ├── columns: k:1!null i:2 s:3 j:4
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── scan virt
 │    │    ├── columns: k:1!null i:2 s:3 j:4
 │    │    ├── computed column expressions
 │    │    │    ├── v:5
 │    │    │    │    └── lower(s:3)
 │    │    │    └── x:6
 │    │    │         └── j:4->'x'
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    └── filters
 │         └── lower(s:3) = 'foo' [outer=(3), immutable]
 └── projections
      ├── lower(s:3) [as=v:5, outer=(3), immutable]
      └── j:4->'x' [as=x:6, outer=(4), immutable]

# Inline inverted-indexed virtual columns.
norm expect=InlineSelectVirtualColumns
SELECT * FROM virt WHERE x @> '1'
----
project
 ├── columns: k:1!null i:2 s:3 j:4 v:5 x:6
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(5), (4)-->(6)
 ├── select
 │    ├── columns: k:1!null i:2 s:3 j:4
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4)
 │    ├── scan virt
 │    │    ├── columns: k:1!null i:2 s:3 j:4
 │    │    ├── computed column expressions
 │    │    │    ├── v:5
 │    │    │    │    └── lower(s:3)
 │    │    │    └── x:6
 │    │    │         └── j:4->'x'
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    └── filters
 │         └── (j:4->'x') @> '1' [outer=(4), immutable]
 └── projections
      ├── lower(s:3) [as=v:5, outer=(3), immutable]
      └── j:4->'x' [as=x:6, outer=(4), immutable]

# Split the filters and inline only virtual columns.
norm expect=InlineSelectVirtualColumns
SELECT * FROM (
  SELECT i, v, upper(s) AS w FROM virt
) WHERE v = 'foo' AND w = 'FOO' AND i = 10
----
select
 ├── columns: i:2!null v:5 w:10!null
 ├── immutable
 ├── fd: ()-->(2,10)
 ├── project
 │    ├── columns: w:10 v:5 i:2!null
 │    ├── immutable
 │    ├── fd: ()-->(2)
 │    ├── select
 │    │    ├── columns: i:2!null s:3
 │    │    ├── immutable
 │    │    ├── fd: ()-->(2)
 │    │    ├── scan virt
 │    │    │    ├── columns: i:2 s:3
 │    │    │    └── computed column expressions
 │    │    │         ├── v:5
 │    │    │         │    └── lower(s:3)
 │    │    │         └── x:6
 │    │    │              └── j:4->'x'
 │    │    └── filters
 │    │         ├── lower(s:3) = 'foo' [outer=(3), immutable]
 │    │         └── i:2 = 10 [outer=(2), constraints=(/2: [/10 - /10]; tight), fd=()-->(2)]
 │    └── projections
 │         ├── upper(s:3) [as=w:10, outer=(3), immutable]
 │         └── lower(s:3) [as=v:5, outer=(3), immutable]
 └── filters
      └── w:10 = 'FOO' [outer=(10), constraints=(/10: [/'FOO' - /'FOO']; tight), fd=()-->(10)]

# Do not inline correlated subqueries.
norm expect-not=InlineSelectVirtualColumns
SELECT * FROM virt v1
WHERE EXISTS (
  SELECT * FROM virt v2 WHERE v1.v = v2.s
)
----
semi-join (hash)
 ├── columns: k:1!null i:2 s:3 j:4 v:5 x:6
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-4), (3)-->(5), (4)-->(6)
 ├── project
 │    ├── columns: v:5 x:6 k:1!null i:2 s:3 j:4
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-4), (3)-->(5), (4)-->(6)
 │    ├── scan virt
 │    │    ├── columns: k:1!null i:2 s:3 j:4
 │    │    ├── computed column expressions
 │    │    │    ├── v:5
 │    │    │    │    └── lower(s:3)
 │    │    │    └── x:6
 │    │    │         └── j:4->'x'
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-4)
 │    └── projections
 │         ├── lower(s:3) [as=v:5, outer=(3), immutable]
 │         └── j:4->'x' [as=x:6, outer=(4), immutable]
 ├── scan virt
 │    ├── columns: s:12
 │    └── computed column expressions
 │         ├── v:14
 │         │    └── lower(s:12)
 │         └── x:15
 │              └── j:13->'x'
 └── filters
      └── v:5 = s:12 [outer=(5,12), constraints=(/5: (/NULL - ]; /12: (/NULL - ]), fd=(5)==(12), (12)==(5)]

# Regression test for #63794. Inlining filters on virtual columns during
# exploration should not violate the ordering choice that all columns in an
# ordering column group should be equal according to the expression's FD.
exec-ddl
CREATE TABLE t63794_a (a INT)
----

exec-ddl
CREATE TABLE t63794_bc (b INT, c INT AS (b % 2) VIRTUAL, INDEX (b))
----

opt format=hide-all
SELECT a.a
FROM t63794_a AS a
  JOIN t63794_bc AS bc1
    JOIN t63794_bc AS bc2 ON true
  ON a.a = bc1.b AND
    bc1.b = bc2.b AND
    bc1.c = bc2.c
  JOIN t63794_bc AS bc3 ON
    bc1.b = bc3.b AND bc2.b = bc3.c
----
project
 └── inner-join (hash)
      ├── scan t63794_a [as=a]
      ├── inner-join (merge)
      │    ├── inner-join (merge)
      │    │    ├── project
      │    │    │    ├── scan t63794_bc@secondary
      │    │    │    └── projections
      │    │    │         └── b % 2
      │    │    ├── project
      │    │    │    ├── scan t63794_bc@secondary
      │    │    │    └── projections
      │    │    │         └── b % 2
      │    │    └── filters (true)
      │    ├── project
      │    │    ├── scan t63794_bc@secondary
      │    │    └── projections
      │    │         └── b % 2
      │    └── filters (true)
      └── filters
           └── a = b

# --------------------------------------------------
# InlineProjectInProject
# --------------------------------------------------
norm expect=InlineProjectInProject
SELECT NOT(expr), i+1 AS r FROM (SELECT k=1 AS expr, i FROM a)
----
project
 ├── columns: "?column?":9!null r:10
 ├── immutable
 ├── scan a
 │    ├── columns: k:1!null i:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      ├── k:1 != 1 [as="?column?":9, outer=(1)]
      └── i:2 + 1 [as=r:10, outer=(2), immutable]

# Multiple synthesized column references to same inner passthrough column
# (should still inline).
norm expect=InlineProjectInProject
SELECT x+1, x+2, y1+2 FROM (SELECT x, y+1 AS y1 FROM xy)
----
project
 ├── columns: "?column?":6!null "?column?":7!null "?column?":8
 ├── immutable
 ├── scan xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    └── fd: (1)-->(2)
 └── projections
      ├── x:1 + 1 [as="?column?":6, outer=(1), immutable]
      ├── x:1 + 2 [as="?column?":7, outer=(1), immutable]
      └── (y:2 + 1) + 2 [as="?column?":8, outer=(2), immutable]

# Synthesized and passthrough references to same inner passthrough column
# (should still inline).
norm expect=InlineProjectInProject
SELECT x+y1 FROM (SELECT x, y+1 AS y1 FROM xy) ORDER BY x
----
project
 ├── columns: "?column?":6  [hidden: x:1!null]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(6)
 ├── ordering: +1
 ├── scan xy
 │    ├── columns: x:1!null y:2
 │    ├── key: (1)
 │    ├── fd: (1)-->(2)
 │    └── ordering: +1
 └── projections
      └── x:1 + (y:2 + 1) [as="?column?":6, outer=(1,2), immutable]

# Inline multiple expressions.
norm expect=InlineProjectInProject
SELECT expr+1 AS r, i, expr2 || 'bar' AS s FROM (SELECT k+1 AS expr, s || 'foo' AS expr2, i FROM a)
----
project
 ├── columns: r:10!null i:2 s:11
 ├── immutable
 ├── scan a
 │    ├── columns: k:1!null i:2 a.s:4
 │    ├── key: (1)
 │    └── fd: (1)-->(2,4)
 └── projections
      ├── (k:1 + 1) + 1 [as=r:10, outer=(1), immutable]
      └── (a.s:4 || 'foo') || 'bar' [as=s:11, outer=(4), immutable]

# Don't inline when there are multiple references.
norm expect-not=InlineProjectInProject
SELECT expr, expr*2 AS r FROM (SELECT k+1 AS expr FROM a)
----
project
 ├── columns: expr:8!null r:9!null
 ├── immutable
 ├── fd: (8)-->(9)
 ├── project
 │    ├── columns: expr:8!null
 │    ├── immutable
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    └── projections
 │         └── k:1 + 1 [as=expr:8, outer=(1), immutable]
 └── projections
      └── expr:8 * 2 [as=r:9, outer=(8), immutable]

# Uncorrelated subquery should not block inlining.
norm expect=InlineProjectInProject
SELECT EXISTS(SELECT * FROM xy WHERE x=1 OR x=2), expr*2 AS r FROM (SELECT k+1 AS expr FROM a)
----
project
 ├── columns: exists:13 r:14!null
 ├── immutable
 ├── fd: ()-->(13)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 └── projections
      ├── exists [as=exists:13, subquery]
      │    └── limit
      │         ├── columns: x:9!null y:10
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         ├── fd: ()-->(9,10)
      │         ├── select
      │         │    ├── columns: x:9!null y:10
      │         │    ├── cardinality: [0 - 2]
      │         │    ├── key: (9)
      │         │    ├── fd: (9)-->(10)
      │         │    ├── limit hint: 1.00
      │         │    ├── scan xy
      │         │    │    ├── columns: x:9!null y:10
      │         │    │    ├── key: (9)
      │         │    │    ├── fd: (9)-->(10)
      │         │    │    └── limit hint: 500.00
      │         │    └── filters
      │         │         └── (x:9 = 1) OR (x:9 = 2) [outer=(9), constraints=(/9: [/1 - /1] [/2 - /2]; tight)]
      │         └── 1
      └── (k:1 + 1) * 2 [as=r:14, outer=(1), immutable]

# Correlated subquery should be hoisted as usual.
norm expect=InlineProjectInProject
SELECT EXISTS(SELECT * FROM xy WHERE expr<0) FROM (SELECT k+1 AS expr FROM a)
----
project
 ├── columns: exists:13!null
 ├── immutable
 ├── group-by
 │    ├── columns: true_agg:15 rownum:17!null
 │    ├── grouping columns: rownum:17!null
 │    ├── immutable
 │    ├── key: (17)
 │    ├── fd: (17)-->(15)
 │    ├── left-join (cross)
 │    │    ├── columns: expr:8!null true:14 rownum:17!null
 │    │    ├── immutable
 │    │    ├── fd: (17)-->(8)
 │    │    ├── ordinality
 │    │    │    ├── columns: expr:8!null rownum:17!null
 │    │    │    ├── immutable
 │    │    │    ├── key: (17)
 │    │    │    ├── fd: (17)-->(8)
 │    │    │    └── project
 │    │    │         ├── columns: expr:8!null
 │    │    │         ├── immutable
 │    │    │         ├── scan a
 │    │    │         │    ├── columns: k:1!null
 │    │    │         │    └── key: (1)
 │    │    │         └── projections
 │    │    │              └── k:1 + 1 [as=expr:8, outer=(1), immutable]
 │    │    ├── project
 │    │    │    ├── columns: true:14!null
 │    │    │    ├── fd: ()-->(14)
 │    │    │    ├── scan xy
 │    │    │    └── projections
 │    │    │         └── true [as=true:14]
 │    │    └── filters
 │    │         └── expr:8 < 0 [outer=(8), constraints=(/8: (/NULL - /-1]; tight)]
 │    └── aggregations
 │         └── const-not-null-agg [as=true_agg:15, outer=(14)]
 │              └── true:14
 └── projections
      └── true_agg:15 IS NOT NULL [as=exists:13, outer=(15)]

# After c is replaced with k+2, (k+2) > 2 should be simplified to k > 0.
norm
SELECT c FROM (SELECT k+2 AS c FROM a) AS t WHERE c > 2;
----
project
 ├── columns: c:8!null
 ├── immutable
 ├── select
 │    ├── columns: k:1!null
 │    ├── key: (1)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    └── filters
 │         └── k:1 > 0 [outer=(1), constraints=(/1: [/1 - ]; tight)]
 └── projections
      └── k:1 + 2 [as=c:8, outer=(1), immutable]
