exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----

exec-ddl
CREATE TABLE cd (c INT PRIMARY KEY, d INT NOT NULL)
----

exec-ddl
CREATE TABLE ab (a INT, b INT)
----

# --------------------------------------------------
# DecorrelateJoin
# --------------------------------------------------
norm expect=DecorrelateJoin
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

norm expect=DecorrelateJoin
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Decorrelate UPDATE statement.
norm expect=DecorrelateJoin
UPDATE xy SET (x, y)=(SELECT * FROM uv WHERE u=x)
----
update xy
 ├── columns: <none>
 ├── fetch columns: x:3 y:4
 ├── update-mapping:
 │    ├── u:5 => x:1
 │    └── v:6 => y:2
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── left-join (hash)
      ├── columns: x:3!null y:4 u:5 v:6
      ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      ├── key: (3)
      ├── fd: (3)-->(4-6), (5)-->(6)
      ├── scan xy
      │    ├── columns: x:3!null y:4
      │    ├── key: (3)
      │    └── fd: (3)-->(4)
      ├── scan uv
      │    ├── columns: u:5!null v:6
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           └── u:5 = x:3 [outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]

# Decorrelate INSERT..ON CONFLICT statement.
norm expect=DecorrelateJoin
INSERT INTO xy VALUES (1,2), (3,4)
ON CONFLICT (x) DO UPDATE SET (x, y)=(SELECT * FROM uv WHERE u=excluded.x)
RETURNING *
----
upsert xy
 ├── columns: x:1!null y:2
 ├── canary column: 5
 ├── fetch columns: x:5 y:6
 ├── insert-mapping:
 │    ├── column1:3 => x:1
 │    └── column2:4 => y:2
 ├── update-mapping:
 │    ├── upsert_x:9 => x:1
 │    └── upsert_y:10 => y:2
 ├── return-mapping:
 │    ├── upsert_x:9 => x:1
 │    └── upsert_y:10 => y:2
 ├── cardinality: [2 - 2]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_x:9 upsert_y:10 column1:3!null column2:4!null x:5 y:6
      ├── cardinality: [2 - 2]
      ├── fd: (5)-->(6)
      ├── left-join (hash)
      │    ├── columns: column1:3!null column2:4!null x:5 y:6 u:7 v:8
      │    ├── cardinality: [2 - 2]
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── fd: (5)-->(6), (7)-->(8)
      │    ├── left-join (hash)
      │    │    ├── columns: column1:3!null column2:4!null x:5 y:6
      │    │    ├── cardinality: [2 - 2]
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    ├── fd: (5)-->(6)
      │    │    ├── values
      │    │    │    ├── columns: column1:3!null column2:4!null
      │    │    │    ├── cardinality: [2 - 2]
      │    │    │    ├── (1, 2)
      │    │    │    └── (3, 4)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:5!null y:6
      │    │    │    ├── key: (5)
      │    │    │    └── fd: (5)-->(6)
      │    │    └── filters
      │    │         └── column1:3 = x:5 [outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
      │    ├── scan uv
      │    │    ├── columns: u:7!null v:8
      │    │    ├── key: (7)
      │    │    └── fd: (7)-->(8)
      │    └── filters
      │         └── u:7 = column1:3 [outer=(3,7), constraints=(/3: (/NULL - ]; /7: (/NULL - ]), fd=(3)==(7), (7)==(3)]
      └── projections
           ├── CASE WHEN x:5 IS NULL THEN column1:3 ELSE u:7 END [as=upsert_x:9, outer=(3,5,7)]
           └── CASE WHEN x:5 IS NULL THEN column2:4 ELSE v:8 END [as=upsert_y:10, outer=(4,5,8)]

# Decorrelate DELETE statement.
norm expect=DecorrelateJoin
DELETE FROM xy WHERE EXISTS(SELECT * FROM uv WHERE u=x)
----
delete xy
 ├── columns: <none>
 ├── fetch columns: x:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── semi-join (hash)
      ├── columns: x:3!null
      ├── key: (3)
      ├── scan xy
      │    ├── columns: x:3!null
      │    └── key: (3)
      ├── scan uv
      │    ├── columns: u:5!null
      │    └── key: (5)
      └── filters
           └── u:5 = x:3 [outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]

# --------------------------------------------------
# DecorrelateProjectSet
# --------------------------------------------------

norm expect=DecorrelateProjectSet
SELECT generate_series(0, 5) FROM xy
----
inner-join (cross)
 ├── columns: generate_series:3
 ├── immutable
 ├── scan xy
 ├── project-set
 │    ├── columns: generate_series:3
 │    ├── immutable
 │    ├── values
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    └── ()
 │    └── zip
 │         └── generate_series(0, 5) [immutable]
 └── filters (true)

norm expect=DecorrelateProjectSet
SELECT * FROM a WHERE i IN (SELECT generate_series(k, i) FROM xy)
----
semi-join-apply
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── inner-join (cross)
 │    ├── columns: generate_series:8
 │    ├── outer: (1,2)
 │    ├── immutable
 │    ├── scan xy
 │    ├── project-set
 │    │    ├── columns: generate_series:8
 │    │    ├── outer: (1,2)
 │    │    ├── immutable
 │    │    ├── values
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    └── ()
 │    │    └── zip
 │    │         └── generate_series(k:1, i:2) [outer=(1,2), immutable]
 │    └── filters (true)
 └── filters
      └── i:2 = generate_series:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]

norm expect=DecorrelateProjectSet
SELECT generate_series(0, (SELECT generate_series(1,0) FROM xy)) FROM uv
----
inner-join (cross)
 ├── columns: generate_series:6
 ├── immutable
 ├── scan uv
 ├── project-set
 │    ├── columns: generate_series:6
 │    ├── immutable
 │    ├── values
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    └── ()
 │    └── zip
 │         └── function: generate_series [immutable, subquery]
 │              ├── 0
 │              └── subquery
 │                   └── max1-row
 │                        ├── columns: generate_series:5
 │                        ├── error: "more than one row returned by a subquery used as an expression"
 │                        ├── cardinality: [0 - 1]
 │                        ├── immutable
 │                        ├── key: ()
 │                        ├── fd: ()-->(5)
 │                        └── inner-join (cross)
 │                             ├── columns: generate_series:5
 │                             ├── immutable
 │                             ├── scan xy
 │                             ├── project-set
 │                             │    ├── columns: generate_series:5
 │                             │    ├── immutable
 │                             │    ├── values
 │                             │    │    ├── cardinality: [1 - 1]
 │                             │    │    ├── key: ()
 │                             │    │    └── ()
 │                             │    └── zip
 │                             │         └── generate_series(1, 0) [immutable]
 │                             └── filters (true)
 └── filters (true)

# --------------------------------------------------
# TryDecorrelateWindow
# --------------------------------------------------

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT rank() OVER (), i FROM (SELECT * FROM a WHERE k = u))
WHERE i = 3
----
project
 ├── columns: u:1!null v:2 rank:8 i:4!null
 ├── key: (1,8)
 ├── fd: ()-->(4), (1)-->(2)
 └── window partition=(1)
      ├── columns: u:1!null v:2 k:3!null i:4!null rank:8
      ├── key: (3)
      ├── fd: ()-->(4), (1)-->(2), (1)==(3), (3)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 k:3!null i:4!null
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    ├── key: (3)
      │    ├── fd: ()-->(4), (1)-->(2), (1)==(3), (3)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── select
      │    │    ├── columns: k:3!null i:4!null
      │    │    ├── key: (3)
      │    │    ├── fd: ()-->(4)
      │    │    ├── scan a
      │    │    │    ├── columns: k:3!null i:4
      │    │    │    ├── key: (3)
      │    │    │    └── fd: (3)-->(4)
      │    │    └── filters
      │    │         └── i:4 = 3 [outer=(4), constraints=(/4: [/3 - /3]; tight), fd=()-->(4)]
      │    └── filters
      │         └── k:3 = u:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      └── windows
           └── rank [as=rank:8]

# TryDecorrelateWindow will trigger twice here: first to pull the window above
# the non-apply join, and then again the pull it above the apply join.
norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (
        SELECT
            *
        FROM
            (SELECT x FROM xy) CROSS JOIN (SELECT ntile(u) OVER (), i FROM a)
    )
WHERE
    i = 3
----
project
 ├── columns: u:1!null v:2 x:3!null ntile:10 i:6!null
 ├── fd: ()-->(6), (1)-->(2)
 └── select
      ├── columns: u:1!null v:2 x:3!null i:6!null ntile:10 ntile_1_arg1:11!null
      ├── fd: ()-->(6), (1)-->(2), (1)==(11), (11)==(1)
      ├── window partition=(1,3)
      │    ├── columns: u:1!null v:2 x:3!null i:6 ntile:10 ntile_1_arg1:11!null
      │    ├── fd: (1)-->(2), (1)==(11), (11)==(1)
      │    ├── project
      │    │    ├── columns: ntile_1_arg1:11!null u:1!null v:2 x:3!null i:6
      │    │    ├── fd: (1)-->(2), (1)==(11), (11)==(1)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: u:1!null v:2 x:3!null i:6
      │    │    │    ├── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:1!null v:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── inner-join (cross)
      │    │    │    │    ├── columns: x:3!null i:6
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:3!null
      │    │    │    │    │    └── key: (3)
      │    │    │    │    ├── scan a
      │    │    │    │    │    └── columns: i:6
      │    │    │    │    └── filters (true)
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         └── u:1 [as=ntile_1_arg1:11, outer=(1)]
      │    └── windows
      │         └── ntile [as=ntile:10, outer=(11)]
      │              └── ntile_1_arg1:11
      └── filters
           └── i:6 = 3 [outer=(6), constraints=(/6: [/3 - /3]; tight), fd=()-->(6)]

# If the LHS has no key, we need to add one, or else identical rows would end up in the same
# partition.

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null row_number:7 i:3
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(3)
 └── window partition=(8)
      ├── columns: column1:1!null k:2!null i:3 row_number:7 rownum:8!null
      ├── cardinality: [0 - 3]
      ├── key: (8)
      ├── fd: (8)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      ├── inner-join (hash)
      │    ├── columns: column1:1!null k:2!null i:3 rownum:8!null
      │    ├── cardinality: [0 - 3]
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    ├── key: (8)
      │    ├── fd: (8)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      │    ├── ordinality
      │    │    ├── columns: column1:1!null rownum:8!null
      │    │    ├── cardinality: [3 - 3]
      │    │    ├── key: (8)
      │    │    ├── fd: (8)-->(1)
      │    │    └── values
      │    │         ├── columns: column1:1!null
      │    │         ├── cardinality: [3 - 3]
      │    │         ├── (1,)
      │    │         ├── (1,)
      │    │         └── (1,)
      │    ├── scan a
      │    │    ├── columns: k:2!null i:3
      │    │    ├── key: (2)
      │    │    └── fd: (2)-->(3)
      │    └── filters
      │         └── k:2 = column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      └── windows
           └── row-number [as=row_number:7]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (ORDER BY i), i FROM (SELECT * FROM a WHERE x > 3))
----
project
 ├── columns: x:1!null row_number:7 i:3
 └── window partition=(8) ordering=+3 opt(1,8)
      ├── columns: column1:1!null i:3 row_number:7 rownum:8!null
      ├── fd: (8)-->(1)
      ├── inner-join (cross)
      │    ├── columns: column1:1!null i:3 rownum:8!null
      │    ├── fd: (8)-->(1)
      │    ├── select
      │    │    ├── columns: column1:1!null rownum:8!null
      │    │    ├── cardinality: [0 - 3]
      │    │    ├── key: (8)
      │    │    ├── fd: (8)-->(1)
      │    │    ├── ordinality
      │    │    │    ├── columns: column1:1!null rownum:8!null
      │    │    │    ├── cardinality: [3 - 3]
      │    │    │    ├── key: (8)
      │    │    │    ├── fd: (8)-->(1)
      │    │    │    └── values
      │    │    │         ├── columns: column1:1!null
      │    │    │         ├── cardinality: [3 - 3]
      │    │    │         ├── (1,)
      │    │    │         ├── (1,)
      │    │    │         └── (1,)
      │    │    └── filters
      │    │         └── column1:1 > 3 [outer=(1), constraints=(/1: [/4 - ]; tight)]
      │    ├── scan a
      │    │    └── columns: i:3
      │    └── filters (true)
      └── windows
           └── row-number [as=row_number:7]

# In this example, we introduce a key called rownum, and after TryDecorrelateWindow triggers
# PARTITION BY x becomes PARTITION BY x, rownum. Then later, ReduceWindowPartitionCols triggers,
# recognizing that rownum determines x.

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (PARTITION BY x), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null row_number:7 i:3
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(3)
 └── window partition=(9)
      ├── columns: column1:1!null i:3 row_number:7 rownum:9!null
      ├── cardinality: [0 - 3]
      ├── key: (9)
      ├── fd: (9)-->(1), (1)-->(3)
      ├── project
      │    ├── columns: column1:1!null i:3 rownum:9!null
      │    ├── cardinality: [0 - 3]
      │    ├── key: (9)
      │    ├── fd: (9)-->(1), (1)-->(3)
      │    └── inner-join (hash)
      │         ├── columns: column1:1!null k:2!null i:3 rownum:9!null
      │         ├── cardinality: [0 - 3]
      │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │         ├── key: (9)
      │         ├── fd: (9)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      │         ├── ordinality
      │         │    ├── columns: column1:1!null rownum:9!null
      │         │    ├── cardinality: [3 - 3]
      │         │    ├── key: (9)
      │         │    ├── fd: (9)-->(1)
      │         │    └── values
      │         │         ├── columns: column1:1!null
      │         │         ├── cardinality: [3 - 3]
      │         │         ├── (1,)
      │         │         ├── (1,)
      │         │         └── (1,)
      │         ├── scan a
      │         │    ├── columns: k:2!null i:3
      │         │    ├── key: (2)
      │         │    └── fd: (2)-->(3)
      │         └── filters
      │              └── k:2 = column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      └── windows
           └── row-number [as=row_number:7]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1, 2), (1, 3), (1, 4)) AS v (x, y),
    LATERAL (SELECT row_number() OVER (PARTITION BY x ORDER BY y), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null y:2!null row_number:8 i:4
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(4)
 └── window partition=(11)
      ├── columns: column1:1!null column2:2!null i:4 row_number:8 rownum:11!null
      ├── cardinality: [0 - 3]
      ├── key: (11)
      ├── fd: (11)-->(1,2), (1)-->(4)
      ├── project
      │    ├── columns: column1:1!null column2:2!null i:4 rownum:11!null
      │    ├── cardinality: [0 - 3]
      │    ├── key: (11)
      │    ├── fd: (11)-->(1,2), (1)-->(4)
      │    └── inner-join (hash)
      │         ├── columns: column1:1!null column2:2!null k:3!null i:4 rownum:11!null
      │         ├── cardinality: [0 - 3]
      │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │         ├── key: (11)
      │         ├── fd: (11)-->(1,2), (3)-->(4), (1)==(3), (3)==(1)
      │         ├── ordinality
      │         │    ├── columns: column1:1!null column2:2!null rownum:11!null
      │         │    ├── cardinality: [3 - 3]
      │         │    ├── key: (11)
      │         │    ├── fd: (11)-->(1,2)
      │         │    └── values
      │         │         ├── columns: column1:1!null column2:2!null
      │         │         ├── cardinality: [3 - 3]
      │         │         ├── (1, 2)
      │         │         ├── (1, 3)
      │         │         └── (1, 4)
      │         ├── scan a
      │         │    ├── columns: k:3!null i:4
      │         │    ├── key: (3)
      │         │    └── fd: (3)-->(4)
      │         └── filters
      │              └── k:3 = column1:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      └── windows
           └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY u), i FROM (SELECT * FROM a WHERE k = u))
----
window partition=(1)
 ├── columns: u:1!null v:2 row_number:8 i:4
 ├── key: (1)
 ├── fd: (1)-->(2,4)
 ├── project
 │    ├── columns: u:1!null v:2 i:4
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,4)
 │    └── inner-join (hash)
 │         ├── columns: u:1!null v:2 k:3!null i:4
 │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │         ├── key: (3)
 │         ├── fd: (1)-->(2), (3)-->(4), (1)==(3), (3)==(1)
 │         ├── scan uv
 │         │    ├── columns: u:1!null v:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan a
 │         │    ├── columns: k:3!null i:4
 │         │    ├── key: (3)
 │         │    └── fd: (3)-->(4)
 │         └── filters
 │              └── k:3 = u:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 └── windows
      └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY s), i FROM (SELECT * FROM a WHERE k = u))
----
project
 ├── columns: u:1!null v:2 row_number:8 i:4
 ├── key: (1,8)
 ├── fd: (1)-->(2,4)
 └── window partition=(1)
      ├── columns: u:1!null v:2 k:3!null i:4 row_number:8
      ├── key: (3)
      ├── fd: (1)-->(2), (3)-->(4), (1)==(3), (3)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 k:3!null i:4
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    ├── key: (3)
      │    ├── fd: (1)-->(2), (3)-->(4), (1)==(3), (3)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── scan a
      │    │    ├── columns: k:3!null i:4
      │    │    ├── key: (3)
      │    │    └── fd: (3)-->(4)
      │    └── filters
      │         └── k:3 = u:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      └── windows
           └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY s), i FROM (SELECT * FROM a WHERE i = u))
----
project
 ├── columns: u:1!null v:2 row_number:8 i:4!null
 ├── fd: (1)-->(2), (1)==(4), (4)==(1)
 └── window partition=(1,6)
      ├── columns: u:1!null v:2 i:4!null s:6 row_number:8
      ├── fd: (1)-->(2), (1)==(4), (4)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 i:4!null s:6
      │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    ├── fd: (1)-->(2), (1)==(4), (4)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── scan a
      │    │    └── columns: i:4 s:6
      │    └── filters
      │         └── i:4 = u:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      └── windows
           └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT * FROM uv, LATERAL (SELECT avg(f) FILTER (WHERE u = 3) OVER (), i FROM a)
----
project
 ├── columns: u:1!null v:2 avg:8 i:4
 ├── fd: (1)-->(2)
 └── window partition=(1)
      ├── columns: u:1!null v:2 i:4 f:5 avg:8 avg_1_filter:9!null
      ├── fd: (1)-->(2,9)
      ├── project
      │    ├── columns: avg_1_filter:9!null u:1!null v:2 i:4 f:5
      │    ├── fd: (1)-->(2,9)
      │    ├── inner-join (cross)
      │    │    ├── columns: u:1!null v:2 i:4 f:5
      │    │    ├── fd: (1)-->(2)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:1!null v:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan a
      │    │    │    └── columns: i:4 f:5
      │    │    └── filters (true)
      │    └── projections
      │         └── u:1 = 3 [as=avg_1_filter:9, outer=(1)]
      └── windows
           └── agg-filter [as=avg:8, outer=(5,9)]
                ├── avg
                │    └── f:5
                └── avg_1_filter:9

# --------------------------------------------------
# TryDecorrelateSelect
# --------------------------------------------------
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE EXISTS(SELECT * FROM (VALUES (k), (i)) WHERE column1=k)
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── values
 │    ├── columns: column1:6
 │    ├── outer: (1,2)
 │    ├── cardinality: [2 - 2]
 │    ├── (k:1,)
 │    └── (i:2,)
 └── filters
      └── column1:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM (VALUES (k), (i)) WHERE column1=k)
----
anti-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── values
 │    ├── columns: column1:6
 │    ├── outer: (1,2)
 │    ├── cardinality: [2 - 2]
 │    ├── (k:1,)
 │    └── (i:2,)
 └── filters
      └── column1:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Attempt to decorrelate query by pulling up outer select. But since limit query
# cannot be decorrelated, push the outer select back down again (and make sure
# potential rule cycle is detected and handled).
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE EXISTS(SELECT * FROM (SELECT * FROM xy WHERE y=k LIMIT 1) WHERE y=10)
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: y:7!null
 │    ├── outer: (1)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(7)
 │    ├── select
 │    │    ├── columns: y:7!null
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(7)
 │    │    ├── limit hint: 1.00
 │    │    ├── scan xy
 │    │    │    ├── columns: y:7
 │    │    │    └── limit hint: 1.01
 │    │    └── filters
 │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── 1
 └── filters
      └── y:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]

# Same as previous, but using anti-join.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM (SELECT * FROM xy WHERE y=k LIMIT 1) WHERE y=10)
----
anti-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: y:7!null
 │    ├── outer: (1)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(7)
 │    ├── select
 │    │    ├── columns: y:7!null
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(7)
 │    │    ├── limit hint: 1.00
 │    │    ├── scan xy
 │    │    │    ├── columns: y:7
 │    │    │    └── limit hint: 1.01
 │    │    └── filters
 │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── 1
 └── filters
      └── y:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]

# Decorrelate Select with reference to outer column and no limit.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE (SELECT x FROM xy WHERE x=i) > 100
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── key: (1)
      ├── fd: (1)-->(2-5), (2)==(6), (6)==(2)
      ├── select
      │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2-5)
      │    └── filters
      │         └── i:2 > 100 [outer=(2), constraints=(/2: [/101 - ]; tight)]
      ├── select
      │    ├── columns: x:6!null
      │    ├── key: (6)
      │    ├── scan xy
      │    │    ├── columns: x:6!null
      │    │    └── key: (6)
      │    └── filters
      │         └── x:6 > 100 [outer=(6), constraints=(/6: [/101 - ]; tight)]
      └── filters
           └── x:6 = i:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]

# Decorrelate Select with LeftJoinApply.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE (SELECT x FROM (SELECT * FROM xy LIMIT 1) WHERE k=x) > 100
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null
      ├── cardinality: [0 - 1]
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      ├── key: ()
      ├── fd: ()-->(1-6)
      ├── select
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2-5)
      │    └── filters
      │         └── k:1 > 100 [outer=(1), constraints=(/1: [/101 - ]; tight)]
      ├── select
      │    ├── columns: x:6!null
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6)
      │    ├── limit
      │    │    ├── columns: x:6!null
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null
      │    │    │    ├── key: (6)
      │    │    │    └── limit hint: 1.00
      │    │    └── 1
      │    └── filters
      │         └── x:6 > 100 [outer=(6), constraints=(/6: [/101 - ]; tight)]
      └── filters
           └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Decorrelate with non-apply operator because of multi-level nesting.
norm expect=TryDecorrelateSelect
SELECT *
FROM a
WHERE EXISTS(SELECT * FROM xy WHERE x=k AND EXISTS(SELECT * FROM uv WHERE u=10 AND s='foo'))
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── semi-join (cross)
 │    ├── columns: x:6!null
 │    ├── outer: (4)
 │    ├── key: (6)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── select
 │    │    ├── columns: u:8!null
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(8)
 │    │    ├── scan uv
 │    │    │    ├── columns: u:8!null
 │    │    │    └── key: (8)
 │    │    └── filters
 │    │         └── u:8 = 10 [outer=(8), constraints=(/8: [/10 - /10]; tight), fd=()-->(8)]
 │    └── filters
 │         └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# TryDecorrelateProject +
# TryDecorrelateProjectSelect +
# TryDecorrelateScalarGroupBy
#
# Start with some shared test cases that exercise multiple
# decorrelation rules.
# --------------------------------------------------

# Left join caused by correlated ANY clause.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT 5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:8
 ├── group-by
 │    ├── columns: k:1!null bool_or:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:6 notnull:9
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (6)-->(9), (1)-->(6,9)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: notnull:9!null x:6!null
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(9)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    ├── key: (6)
 │    │    │    │    ├── fd: (6)-->(7)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    │    ├── key: (6)
 │    │    │    │    │    └── fd: (6)-->(7)
 │    │    │    │    └── filters
 │    │    │    │         └── (y:7 = 5) IS NOT false [outer=(7)]
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:9, outer=(7)]
 │    │    └── filters
 │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:10, outer=(9)]
 │              └── notnull:9
 └── projections
      └── CASE WHEN bool_or:10 THEN true WHEN bool_or:10 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(10)]

# Left join caused by zero or one cardinality subquery.
norm expect=TryDecorrelateProjectSelect
SELECT * FROM a WHERE (SELECT y+1 AS r FROM (SELECT * FROM xy LIMIT 1) WHERE x=k) > 10
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null y:7!null
      ├── cardinality: [0 - 1]
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      ├── key: ()
      ├── fd: ()-->(1-7)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── select
      │    ├── columns: x:6!null y:7!null
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(6,7)
      │    ├── limit
      │    │    ├── columns: x:6!null y:7
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6,7)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null y:7
      │    │    │    ├── key: (6)
      │    │    │    ├── fd: (6)-->(7)
      │    │    │    └── limit hint: 1.00
      │    │    └── 1
      │    └── filters
      │         └── y:7 > 9 [outer=(7), constraints=(/7: [/10 - ]; tight)]
      └── filters
           └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Any clause with constant.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT 5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:8
 ├── group-by
 │    ├── columns: k:1!null bool_or:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:6 notnull:9
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (6)-->(9), (1)-->(6,9)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: notnull:9!null x:6!null
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(9)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    ├── key: (6)
 │    │    │    │    ├── fd: (6)-->(7)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    │    ├── key: (6)
 │    │    │    │    │    └── fd: (6)-->(7)
 │    │    │    │    └── filters
 │    │    │    │         └── (y:7 = 5) IS NOT false [outer=(7)]
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:9, outer=(7)]
 │    │    └── filters
 │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:10, outer=(9)]
 │              └── notnull:9
 └── projections
      └── CASE WHEN bool_or:10 THEN true WHEN bool_or:10 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(10)]

# Any clause with variable.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT i=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:8
 ├── group-by
 │    ├── columns: k:1!null i:2 bool_or:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 x:6 y:7 notnull:9
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,6,7,9), (6)-->(7), (7)~~>(9)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: notnull:9!null x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(7), (7)-->(9)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    ├── key: (6)
 │    │    │    │    └── fd: (6)-->(7)
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:9, outer=(7)]
 │    │    └── filters
 │    │         ├── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │         └── (i:2 = y:7) IS NOT false [outer=(2,7)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:10, outer=(9)]
 │         │    └── notnull:9
 │         └── const-agg [as=i:2, outer=(2)]
 │              └── i:2
 └── projections
      └── CASE WHEN bool_or:10 AND (i:2 IS NOT NULL) THEN true WHEN bool_or:10 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(2,10)]

# Any clause with more complex expression that must be cached.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT i*i/5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:8
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null scalar:9 bool_or:11
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(9,11)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:6 y:7 scalar:9 notnull:10
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(6,7,9,10), (6)-->(7), (7)~~>(10)
 │    │    ├── project
 │    │    │    ├── columns: scalar:9 k:1!null
 │    │    │    ├── immutable
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(9)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── projections
 │    │    │         └── (i:2 * i:2) / 5 [as=scalar:9, outer=(2), immutable]
 │    │    ├── project
 │    │    │    ├── columns: notnull:10!null x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(7), (7)-->(10)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    ├── key: (6)
 │    │    │    │    └── fd: (6)-->(7)
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:10, outer=(7)]
 │    │    └── filters
 │    │         ├── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │         └── (scalar:9 = y:7) IS NOT false [outer=(7,9)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:11, outer=(10)]
 │         │    └── notnull:10
 │         └── const-agg [as=scalar:9, outer=(9)]
 │              └── scalar:9
 └── projections
      └── CASE WHEN bool_or:11 AND (scalar:9 IS NOT NULL) THEN true WHEN bool_or:11 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(9,11), immutable]

# --------------------------------------------------
# TryDecorrelateProject
# --------------------------------------------------
norm expect=TryDecorrelateProject
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT u, u/1.1 AS div FROM uv WHERE i=5) ON x=div
)
----
distinct-on
 ├── columns: k:1!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null x:6!null div:10!null
      ├── fd: (6)==(10), (10)==(6)
      ├── project
      │    ├── columns: div:10!null k:1!null x:6!null
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null i:2!null x:6!null u:8!null
      │    │    ├── key: (1,6,8)
      │    │    ├── fd: ()-->(2)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: x:6!null u:8!null
      │    │    │    ├── key: (6,8)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:6!null
      │    │    │    │    └── key: (6)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters (true)
      │    │    └── filters (true)
      │    └── projections
      │         └── u:8 / 1.1 [as=div:10, outer=(8)]
      └── filters
           └── x:6 = div:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]

# Don't hoist Project operator in right join case.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy RIGHT JOIN (SELECT u, u/1.1 AS div FROM uv WHERE i=5) ON x=div
)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── left-join (cross)
      │    ├── columns: x:6 div:10!null
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── project
      │    │    ├── columns: div:10!null
      │    │    ├── outer: (2)
      │    │    ├── select
      │    │    │    ├── columns: u:8!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (8)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:8 / 1.1 [as=div:10, outer=(8)]
      │    ├── scan xy
      │    │    ├── columns: x:6!null
      │    │    └── key: (6)
      │    └── filters
      │         └── x:6 = div:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
      └── filters (true)

# --------------------------------------------------
# TryDecorrelateProjectSelect
# --------------------------------------------------
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy LEFT JOIN (SELECT u, u+1 AS plus FROM uv WHERE i=5) ON x=plus
)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── left-join (hash)
      │    ├── columns: x:6!null plus:10
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    ├── immutable
      │    ├── scan xy
      │    │    ├── columns: x:6!null
      │    │    └── key: (6)
      │    ├── project
      │    │    ├── columns: plus:10!null
      │    │    ├── outer: (2)
      │    │    ├── immutable
      │    │    ├── select
      │    │    │    ├── columns: u:8!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (8)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:8 + 1 [as=plus:10, outer=(8), immutable]
      │    └── filters
      │         └── x:6 = plus:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
      └── filters (true)

# Don't decorrelate FULL JOIN case.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy FULL JOIN (SELECT u, u+1 AS plus FROM uv WHERE i=5) ON x=plus
)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── full-join (hash)
      │    ├── columns: x:6 plus:10
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(one-or-more), right-rows(exactly-one)
      │    ├── immutable
      │    ├── scan xy
      │    │    ├── columns: x:6!null
      │    │    └── key: (6)
      │    ├── project
      │    │    ├── columns: plus:10!null
      │    │    ├── outer: (2)
      │    │    ├── immutable
      │    │    ├── select
      │    │    │    ├── columns: u:8!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (8)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:8 + 1 [as=plus:10, outer=(8), immutable]
      │    └── filters
      │         └── x:6 = plus:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
      └── filters (true)

# --------------------------------------------------
# TryDecorrelateProjectInnerJoin
# --------------------------------------------------
norm expect=TryDecorrelateProjectInnerJoin
SELECT (SELECT sum(y + v) FROM xy, uv WHERE x=u AND x=k) FROM a
----
project
 ├── columns: sum:12
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null sum:11
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(11)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:6 column10:10
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (6)-->(10), (1)-->(6,10)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: column10:10 x:6!null
 │    │    │    ├── immutable
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(10)
 │    │    │    ├── inner-join (hash)
 │    │    │    │    ├── columns: x:6!null y:7 u:8!null v:9
 │    │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    │    │    │    ├── key: (8)
 │    │    │    │    ├── fd: (6)-->(7), (8)-->(9), (6)==(8), (8)==(6)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    │    ├── key: (6)
 │    │    │    │    │    └── fd: (6)-->(7)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    ├── columns: u:8!null v:9
 │    │    │    │    │    ├── key: (8)
 │    │    │    │    │    └── fd: (8)-->(9)
 │    │    │    │    └── filters
 │    │    │    │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 │    │    │    └── projections
 │    │    │         └── y:7 + v:9 [as=column10:10, outer=(7,9), immutable]
 │    │    └── filters
 │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    └── aggregations
 │         └── sum [as=sum:11, outer=(10)]
 │              └── column10:10
 └── projections
      └── sum:11 [as=sum:12, outer=(11)]

# --------------------------------------------------
# TryDecorrelateInnerJoin
# --------------------------------------------------
# Semi-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN uv ON x=u AND x=k
)
----
semi-join (hash)
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── inner-join (hash)
 │    ├── columns: x:6!null u:8!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (8)
 │    ├── fd: (6)==(8), (8)==(6)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── scan uv
 │    │    ├── columns: u:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Anti-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE NOT EXISTS
(
    SELECT * FROM xy INNER JOIN uv ON x=u AND x=k
)
----
anti-join (hash)
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── inner-join (hash)
 │    ├── columns: x:6!null u:8!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (8)
 │    ├── fd: (6)==(8), (8)==(6)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── scan uv
 │    │    ├── columns: u:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Right-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE
(
    SELECT count(*)
    FROM xy
    INNER JOIN uv
    ON x=u AND x=k
) IS DISTINCT FROM 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null count_rows:10!null
      ├── key: (1)
      ├── fd: (1)-->(10)
      ├── group-by
      │    ├── columns: k:1!null count_rows:10!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(10)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null x:6 u:8
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (6)==(8), (8)==(6), (1)-->(6,8)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:6!null u:8!null
      │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    │    │    ├── key: (8)
      │    │    │    ├── fd: (6)==(8), (8)==(6)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:6!null
      │    │    │    │    └── key: (6)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters
      │    │    │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
      │    │    └── filters
      │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    └── aggregations
      │         └── count [as=count_rows:10, outer=(6)]
      │              └── x:6
      └── filters
           └── count_rows:10 IS DISTINCT FROM 1 [outer=(10), constraints=(/10: [ - /0] [/2 - ]; tight)]

# Can't decorrelate left-join as inner.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy LEFT JOIN uv ON x=u AND x=k
)
----
semi-join-apply
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── left-join (hash)
 │    ├── columns: x:6!null u:8
 │    ├── outer: (1)
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (6)
 │    ├── fd: (6)-->(8)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── scan uv
 │    │    ├── columns: u:8!null
 │    │    └── key: (8)
 │    └── filters
 │         ├── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── filters (true)

# Can't decorrelate semi-join as inner.
norm
SELECT k
FROM a
WHERE EXISTS
(
    SELECT *
    FROM xy
    WHERE EXISTS
    (
        SELECT * FROM uv INNER JOIN uv AS uv2 ON uv2.u=k
    )
)
----
semi-join-apply
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── semi-join (cross)
 │    ├── outer: (1)
 │    ├── scan xy
 │    ├── inner-join (cross)
 │    │    ├── columns: uv2.u:10!null
 │    │    ├── scan uv
 │    │    ├── scan uv2
 │    │    │    ├── columns: uv2.u:10!null
 │    │    │    └── key: (10)
 │    │    └── filters (true)
 │    └── filters
 │         └── uv2.u:10 = k:1 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
 └── filters (true)

# --------------------------------------------------
# TryDecorrelateInnerLeftJoin
# --------------------------------------------------
norm expect=TryDecorrelateInnerLeftJoin
SELECT *
FROM (VALUES (1), (2)) AS v(v1)
WHERE EXISTS(
    SELECT k
    FROM a
    WHERE
    (
        SELECT y FROM xy LEFT JOIN (SELECT v1 FROM uv LIMIT 1) ON x=v1 WHERE x=k
    )=i
)
----
select
 ├── columns: v1:1!null
 ├── cardinality: [0 - 2]
 ├── values
 │    ├── columns: column1:1!null
 │    ├── cardinality: [2 - 2]
 │    ├── (1,)
 │    └── (2,)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: k:2!null i:3!null x:7!null y:8!null
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(2,3,7,8)
                ├── inner-join (hash)
                │    ├── columns: k:2!null i:3!null x:7!null y:8!null
                │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
                │    ├── key: (7)
                │    ├── fd: (2)-->(3), (7)-->(8), (2)==(7), (7)==(2), (3)==(8), (8)==(3)
                │    ├── limit hint: 1.00
                │    ├── scan a
                │    │    ├── columns: k:2!null i:3
                │    │    ├── key: (2)
                │    │    └── fd: (2)-->(3)
                │    ├── scan xy
                │    │    ├── columns: x:7!null y:8
                │    │    ├── key: (7)
                │    │    └── fd: (7)-->(8)
                │    └── filters
                │         ├── x:7 = k:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
                │         └── i:3 = y:8 [outer=(3,8), constraints=(/3: (/NULL - ]; /8: (/NULL - ]), fd=(3)==(8), (8)==(3)]
                └── 1

norm expect=TryDecorrelateInnerLeftJoin
SELECT *
FROM xy, uv
WHERE (SELECT i FROM a WHERE k=x) IS DISTINCT FROM u
----
project
 ├── columns: x:1!null y:2 u:3!null v:4
 ├── key: (1,3)
 ├── fd: (1)-->(2), (3)-->(4)
 └── select
      ├── columns: x:1!null y:2 u:3!null v:4 k:5 i:6
      ├── key: (1,3)
      ├── fd: (1)-->(2), (3)-->(4), (5)-->(6), (1,3)-->(5,6)
      ├── left-join (hash)
      │    ├── columns: x:1!null y:2 u:3!null v:4 k:5 i:6
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── key: (1,3)
      │    ├── fd: (1)-->(2), (3)-->(4), (5)-->(6), (1,3)-->(5,6)
      │    ├── inner-join (cross)
      │    │    ├── columns: x:1!null y:2 u:3!null v:4
      │    │    ├── key: (1,3)
      │    │    ├── fd: (1)-->(2), (3)-->(4)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:1!null y:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:3!null v:4
      │    │    │    ├── key: (3)
      │    │    │    └── fd: (3)-->(4)
      │    │    └── filters (true)
      │    ├── scan a
      │    │    ├── columns: k:5!null i:6
      │    │    ├── key: (5)
      │    │    └── fd: (5)-->(6)
      │    └── filters
      │         └── k:5 = x:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      └── filters
           └── u:3 IS DISTINCT FROM i:6 [outer=(3,6)]

# --------------------------------------------------
# TryDecorrelateGroupBy
# --------------------------------------------------
norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT count(*) AS cnt, sum(v) FROM uv WHERE i=5 GROUP BY v) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9 count_rows:10!null
 │    ├── key: (1,6,9)
 │    ├── fd: ()-->(2), (1)-->(3-5), (1,6,9)-->(3-5,10), (6)==(10), (10)==(6)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9 count_rows:10!null
 │    │    ├── grouping columns: k:1!null x:6!null v:9
 │    │    ├── key: (1,6,9)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (1,6,9)-->(2-5,10)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:6!null v:9
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    └── key: (6)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    └── columns: v:9
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── count-rows [as=count_rows:10]
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:6 = count_rows:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT count(DISTINCT uv.v) AS cnt, sum(v) FROM uv WHERE i=5 GROUP BY v) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9 count:10!null
 │    ├── key: (1,6,9)
 │    ├── fd: ()-->(2), (1)-->(3-5), (1,6,9)-->(3-5,10), (6)==(10), (10)==(6)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9 count:10!null
 │    │    ├── grouping columns: k:1!null x:6!null v:9
 │    │    ├── key: (1,6,9)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (1,6,9)-->(2-5,10)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null v:9
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:6!null v:9
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    └── key: (6)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    └── columns: v:9
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── agg-distinct [as=count:10, outer=(9)]
 │    │         │    └── count
 │    │         │         └── v:9
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:6 = count:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Indirectly decorrelate GROUP BY after decorrelating scalar GROUP BY.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM xy, uv
WHERE x=v AND u=(SELECT max(i) FROM a WHERE k=x)
----
project
 ├── columns: x:1!null y:2 u:3!null v:4!null
 ├── key: (3)
 ├── fd: (1)-->(2), (3)-->(1,2,4), (1)==(4), (4)==(1)
 └── select
      ├── columns: x:1!null y:2 u:3!null v:4!null max:10!null
      ├── key: (3)
      ├── fd: (1)-->(2), (3)-->(1,2,4), (1)==(4), (4)==(1), (3)==(10), (10)==(3)
      ├── group-by
      │    ├── columns: x:1!null y:2 u:3!null v:4!null max:10!null
      │    ├── grouping columns: u:3!null
      │    ├── key: (3)
      │    ├── fd: (1)-->(2), (3)-->(1,2,4,10), (1)==(4), (4)==(1)
      │    ├── inner-join (hash)
      │    │    ├── columns: x:1!null y:2 u:3!null v:4!null k:5!null i:6!null
      │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    │    ├── key: (3)
      │    │    ├── fd: (1)-->(2), (3)-->(4), (1)==(4,5), (4)==(1,5), (5)-->(6), (5)==(1,4)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:1!null y:2 u:3!null v:4!null
      │    │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    │    │    ├── key: (3)
      │    │    │    ├── fd: (1)-->(2), (3)-->(4), (1)==(4), (4)==(1)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:1!null y:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:3!null v:4
      │    │    │    │    ├── key: (3)
      │    │    │    │    └── fd: (3)-->(4)
      │    │    │    └── filters
      │    │    │         └── x:1 = v:4 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      │    │    ├── select
      │    │    │    ├── columns: k:5!null i:6!null
      │    │    │    ├── key: (5)
      │    │    │    ├── fd: (5)-->(6)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:5!null i:6
      │    │    │    │    ├── key: (5)
      │    │    │    │    └── fd: (5)-->(6)
      │    │    │    └── filters
      │    │    │         └── i:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
      │    │    └── filters
      │    │         └── k:5 = x:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    └── aggregations
      │         ├── max [as=max:10, outer=(6)]
      │         │    └── i:6
      │         ├── const-agg [as=v:4, outer=(4)]
      │         │    └── v:4
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=x:1, outer=(1)]
      │              └── x:1
      └── filters
           └── u:3 = max:10 [outer=(3,10), constraints=(/3: (/NULL - ]; /10: (/NULL - ]), fd=(3)==(10), (10)==(3)]

# Indirectly decorrelate GROUP BY after decorrelating scalar GROUP BY. Use
# IS DISTINCT FROM to retain left join.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM xy, uv
WHERE x=v AND (SELECT max(i) FROM a WHERE k=x) IS DISTINCT FROM u
----
project
 ├── columns: x:1!null y:2 u:3!null v:4!null
 ├── key: (3)
 ├── fd: (1)-->(2), (3)-->(1,2,4), (1)==(4), (4)==(1)
 └── select
      ├── columns: x:1!null y:2 u:3!null v:4!null max:10
      ├── key: (3)
      ├── fd: (1)-->(2), (3)-->(1,2,4,10), (1)==(4), (4)==(1)
      ├── group-by
      │    ├── columns: x:1!null y:2 u:3!null v:4!null max:10
      │    ├── grouping columns: u:3!null
      │    ├── key: (3)
      │    ├── fd: (1)-->(2), (3)-->(1,2,4,10), (1)==(4), (4)==(1)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1!null y:2 u:3!null v:4!null k:5 i:6
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    ├── key: (3)
      │    │    ├── fd: (1)-->(2), (3)-->(4-6), (1)==(4), (4)==(1), (5)-->(6)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:1!null y:2 u:3!null v:4!null
      │    │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    │    │    ├── key: (3)
      │    │    │    ├── fd: (1)-->(2), (3)-->(4), (1)==(4), (4)==(1)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:1!null y:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:3!null v:4
      │    │    │    │    ├── key: (3)
      │    │    │    │    └── fd: (3)-->(4)
      │    │    │    └── filters
      │    │    │         └── x:1 = v:4 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      │    │    ├── scan a
      │    │    │    ├── columns: k:5!null i:6
      │    │    │    ├── key: (5)
      │    │    │    └── fd: (5)-->(6)
      │    │    └── filters
      │    │         └── k:5 = x:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    └── aggregations
      │         ├── max [as=max:10, outer=(6)]
      │         │    └── i:6
      │         ├── const-agg [as=v:4, outer=(4)]
      │         │    └── v:4
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=x:1, outer=(1)]
      │              └── x:1
      └── filters
           └── u:3 IS DISTINCT FROM max:10 [outer=(3,10)]

# Synthesize key when one is not present.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM
(
    SELECT y, 'foo' AS cst FROM xy
)
WHERE 'bar'=(SELECT max(s) FROM (SELECT * FROM a LIMIT 1) WHERE k=y GROUP BY i)
----
project
 ├── columns: y:2!null cst:3!null
 ├── fd: ()-->(2,3)
 ├── select
 │    ├── columns: x:1!null y:2!null max:9!null
 │    ├── key: (1)
 │    ├── fd: ()-->(2,9)
 │    ├── group-by
 │    │    ├── columns: x:1!null y:2!null max:9
 │    │    ├── grouping columns: x:1!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(2,9)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: x:1!null y:2!null k:4!null s:7
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2,4,7), (2)==(4), (4)==(2)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── limit
 │    │    │    │    ├── columns: k:4!null s:7
 │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(4,7)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:4!null s:7
 │    │    │    │    │    ├── key: (4)
 │    │    │    │    │    ├── fd: (4)-->(7)
 │    │    │    │    │    └── limit hint: 1.00
 │    │    │    │    └── 1
 │    │    │    └── filters
 │    │    │         └── k:4 = y:2 [outer=(2,4), constraints=(/2: (/NULL - ]; /4: (/NULL - ]), fd=(2)==(4), (4)==(2)]
 │    │    └── aggregations
 │    │         ├── max [as=max:9, outer=(7)]
 │    │         │    └── s:7
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── max:9 = 'bar' [outer=(9), constraints=(/9: [/'bar' - /'bar']; tight), fd=()-->(9)]
 └── projections
      └── 'foo' [as=cst:3]

# Decorrelate DistinctOn.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (
        SELECT DISTINCT ON (v) u, v FROM uv WHERE i=5
    ) ON x=u
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null u:8!null v:9
 │    ├── key: (1,8)
 │    ├── fd: ()-->(2), (1)-->(3-5), (8)-->(9), (1,6,9)-->(3-5,8), (6)==(8), (8)==(6)
 │    ├── distinct-on
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null u:8!null v:9
 │    │    ├── grouping columns: k:1!null x:6!null v:9
 │    │    ├── key: (1,6,8)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (8)-->(9), (1,6,9)-->(2-5,8)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:6!null u:8!null v:9
 │    │    │    ├── key: (1,6,8)
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5), (8)-->(9)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:6!null u:8!null v:9
 │    │    │    │    ├── key: (6,8)
 │    │    │    │    ├── fd: (8)-->(9)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    └── key: (6)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    ├── columns: u:8!null v:9
 │    │    │    │    │    ├── key: (8)
 │    │    │    │    │    └── fd: (8)-->(9)
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── first-agg [as=u:8, outer=(8)]
 │    │         │    └── u:8
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Regression test for #40592. Ensure that no new output columns are added
# as a result of TryDecorrelateGroupBy.
exec-ddl
CREATE TABLE tab_orig (
    _int2 INT8 NULL,
    _int8 INT8 NULL,
    _timestamptz TIMESTAMPTZ NULL,
    _bool BOOL NULL,
    _decimal INT8 NULL,
    _string INT8 NULL,
    FAMILY "primary" (_int2, _int8, _timestamptz, _bool, _decimal, _string, rowid)
)
----

norm expect=TryDecorrelateGroupBy disable=InlineWith
SELECT
  NULL
FROM
  tab_orig AS t0
WHERE
  EXISTS(
    SELECT
      NULL
    FROM
      tab_orig
      JOIN tab_orig AS t1
        INNER JOIN tab_orig AS t2
          JOIN tab_orig AS t3 ON true ON
            EXISTS(
              WITH
                w0 AS (SELECT NULL)
              SELECT
                t0._string FROM w0 CROSS JOIN w0 as w1
              WHERE t0._string = 1
            ) ON true
      JOIN tab_orig AS t4 ON
          t3._timestamptz
          = t4._timestamptz
          AND t3._int2 = t4._int8
      JOIN tab_orig AS t5 ON
          t1._decimal = t5._decimal
    WHERE
      t2._bool
    ORDER BY
      t2._decimal
    LIMIT
      66
  );
----
with &1 (w0)
 ├── columns: "?column?":58
 ├── fd: ()-->(58)
 ├── values
 │    ├── columns: "?column?":36
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(36)
 │    └── (NULL,)
 └── project
      ├── columns: "?column?":58
      ├── fd: ()-->(58)
      ├── semi-join-apply
      │    ├── columns: t0._string:6
      │    ├── scan t0
      │    │    └── columns: t0._string:6
      │    ├── inner-join (hash)
      │    │    ├── columns: tab_orig.rowid:14!null t1._decimal:19!null t1.rowid:21!null t2._bool:25!null t2.rowid:28!null t3._int2:29!null t3._timestamptz:31!null t3.rowid:35!null t4._int8:44!null t4._timestamptz:45!null t5._decimal:54!null
      │    │    ├── outer: (6)
      │    │    ├── fd: ()-->(25), (21)-->(19), (35)-->(29,31), (14,21,28,35)-->(19,29,31), (31)==(45), (45)==(31), (29)==(44), (44)==(29), (19)==(54), (54)==(19)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: tab_orig.rowid:14!null t1._decimal:19 t1.rowid:21!null t2._bool:25 t2.rowid:28!null t3._int2:29!null t3._timestamptz:31!null t3.rowid:35!null t4._int8:44!null t4._timestamptz:45!null
      │    │    │    ├── outer: (6)
      │    │    │    ├── fd: (21)-->(19), (28)-->(25), (35)-->(29,31), (14,21,28,35)-->(19,25,29,31), (31)==(45), (45)==(31), (29)==(44), (44)==(29)
      │    │    │    ├── group-by
      │    │    │    │    ├── columns: tab_orig.rowid:14!null t1._decimal:19 t1.rowid:21!null t2._bool:25 t2.rowid:28!null t3._int2:29 t3._timestamptz:31 t3.rowid:35!null
      │    │    │    │    ├── grouping columns: tab_orig.rowid:14!null t1.rowid:21!null t2.rowid:28!null t3.rowid:35!null
      │    │    │    │    ├── outer: (6)
      │    │    │    │    ├── key: (14,21,28,35)
      │    │    │    │    ├── fd: (21)-->(19), (28)-->(25), (35)-->(29,31), (14,21,28,35)-->(19,25,29,31)
      │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    ├── columns: tab_orig.rowid:14!null t1._decimal:19 t1.rowid:21!null t2._bool:25 t2.rowid:28!null t3._int2:29 t3._timestamptz:31 t3.rowid:35!null
      │    │    │    │    │    ├── outer: (6)
      │    │    │    │    │    ├── key: (14,21,28,35)
      │    │    │    │    │    ├── fd: (21)-->(19), (28)-->(25), (35)-->(29,31)
      │    │    │    │    │    ├── scan tab_orig
      │    │    │    │    │    │    ├── columns: tab_orig.rowid:14!null
      │    │    │    │    │    │    └── key: (14)
      │    │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    │    ├── columns: t1._decimal:19 t1.rowid:21!null t2._bool:25 t2.rowid:28!null t3._int2:29 t3._timestamptz:31 t3.rowid:35!null
      │    │    │    │    │    │    ├── key: (21,28,35)
      │    │    │    │    │    │    ├── fd: (21)-->(19), (28)-->(25), (35)-->(29,31)
      │    │    │    │    │    │    ├── scan t1
      │    │    │    │    │    │    │    ├── columns: t1._decimal:19 t1.rowid:21!null
      │    │    │    │    │    │    │    ├── key: (21)
      │    │    │    │    │    │    │    └── fd: (21)-->(19)
      │    │    │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    │    │    ├── columns: t2._bool:25 t2.rowid:28!null t3._int2:29 t3._timestamptz:31 t3.rowid:35!null
      │    │    │    │    │    │    │    ├── key: (28,35)
      │    │    │    │    │    │    │    ├── fd: (28)-->(25), (35)-->(29,31)
      │    │    │    │    │    │    │    ├── scan t2
      │    │    │    │    │    │    │    │    ├── columns: t2._bool:25 t2.rowid:28!null
      │    │    │    │    │    │    │    │    ├── key: (28)
      │    │    │    │    │    │    │    │    └── fd: (28)-->(25)
      │    │    │    │    │    │    │    ├── scan t3
      │    │    │    │    │    │    │    │    ├── columns: t3._int2:29 t3._timestamptz:31 t3.rowid:35!null
      │    │    │    │    │    │    │    │    ├── key: (35)
      │    │    │    │    │    │    │    │    └── fd: (35)-->(29,31)
      │    │    │    │    │    │    │    └── filters (true)
      │    │    │    │    │    │    └── filters (true)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── t0._string:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=t2._bool:25, outer=(25)]
      │    │    │    │         │    └── t2._bool:25
      │    │    │    │         ├── const-agg [as=t3._int2:29, outer=(29)]
      │    │    │    │         │    └── t3._int2:29
      │    │    │    │         ├── const-agg [as=t3._timestamptz:31, outer=(31)]
      │    │    │    │         │    └── t3._timestamptz:31
      │    │    │    │         └── const-agg [as=t1._decimal:19, outer=(19)]
      │    │    │    │              └── t1._decimal:19
      │    │    │    ├── scan t4
      │    │    │    │    └── columns: t4._int8:44 t4._timestamptz:45
      │    │    │    └── filters
      │    │    │         ├── t3._timestamptz:31 = t4._timestamptz:45 [outer=(31,45), constraints=(/31: (/NULL - ]; /45: (/NULL - ]), fd=(31)==(45), (45)==(31)]
      │    │    │         └── t3._int2:29 = t4._int8:44 [outer=(29,44), constraints=(/29: (/NULL - ]; /44: (/NULL - ]), fd=(29)==(44), (44)==(29)]
      │    │    ├── scan t5
      │    │    │    └── columns: t5._decimal:54
      │    │    └── filters
      │    │         ├── t2._bool:25 [outer=(25), constraints=(/25: [/true - /true]; tight), fd=()-->(25)]
      │    │         └── t1._decimal:19 = t5._decimal:54 [outer=(19,54), constraints=(/19: (/NULL - ]; /54: (/NULL - ]), fd=(19)==(54), (54)==(19)]
      │    └── filters (true)
      └── projections
           └── NULL [as="?column?":58]

# --------------------------------------------------
# TryDecorrelateScalarGroupBy
# --------------------------------------------------
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT sum(v), count(*) AS cnt FROM uv WHERE i=5) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null count_rows:11!null
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2-5), (1,6)-->(2-5,11), (6)==(11), (11)==(6)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null count_rows:11!null
 │    │    ├── grouping columns: k:1!null x:6!null
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2-5), (1,6)-->(2-5,11)
 │    │    ├── left-join (cross)
 │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null canary:12
 │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    │    ├── fd: (1)-->(2-5)
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null
 │    │    │    │    ├── key: (1,6)
 │    │    │    │    ├── fd: (1)-->(2-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    └── key: (6)
 │    │    │    │    └── filters (true)
 │    │    │    ├── project
 │    │    │    │    ├── columns: canary:12!null
 │    │    │    │    ├── fd: ()-->(12)
 │    │    │    │    ├── scan uv
 │    │    │    │    └── projections
 │    │    │    │         └── true [as=canary:12]
 │    │    │    └── filters
 │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    └── aggregations
 │    │         ├── count [as=count_rows:11, outer=(12)]
 │    │         │    └── canary:12
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:6 = count_rows:11 [outer=(6,11), constraints=(/6: (/NULL - ]; /11: (/NULL - ]), fd=(6)==(11), (11)==(6)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Synthesize key when one is not present.
norm expect=TryDecorrelateScalarGroupBy
SELECT * FROM (SELECT i, 'foo' AS cst FROM a) WHERE 5=(SELECT max(y) FROM xy WHERE x=i)
----
project
 ├── columns: i:2!null cst:6!null
 ├── fd: ()-->(6)
 ├── select
 │    ├── columns: k:1!null i:2!null max:9!null
 │    ├── key: (1)
 │    ├── fd: ()-->(9), (1)-->(2)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null max:9!null
 │    │    ├── grouping columns: k:1!null
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,9)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: k:1!null i:2!null x:7!null y:8!null
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2), (7)-->(8), (2)==(7), (7)==(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:7!null y:8!null
 │    │    │    │    ├── key: (7)
 │    │    │    │    ├── fd: (7)-->(8)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    │    ├── key: (7)
 │    │    │    │    │    └── fd: (7)-->(8)
 │    │    │    │    └── filters
 │    │    │    │         └── y:8 IS NOT NULL [outer=(8), constraints=(/8: (/NULL - ]; tight)]
 │    │    │    └── filters
 │    │    │         └── x:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    │    └── aggregations
 │    │         ├── max [as=max:9, outer=(8)]
 │    │         │    └── y:8
 │    │         └── const-agg [as=i:2, outer=(2)]
 │    │              └── i:2
 │    └── filters
 │         └── max:9 = 5 [outer=(9), constraints=(/9: [/5 - /5]; tight), fd=()-->(9)]
 └── projections
      └── 'foo' [as=cst:6]

# With an aggregate that can't ignore nulls. xy.y = a.k rejects nulls, so
# there's no canary column to be synthesized.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT array_agg(xy.y) FROM xy WHERE xy.y = a.k) FROM a
----
project
 ├── columns: k:1!null array_agg:9
 ├── key: (1)
 ├── fd: (1)-->(9)
 ├── group-by
 │    ├── columns: k:1!null y:7 array_agg:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(7,10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null y:7
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan xy
 │    │    │    └── columns: y:7
 │    │    └── filters
 │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:10, outer=(7)]
 │         │    └── y:7
 │         └── any-not-null-agg [as=y:7, outer=(7)]
 │              └── y:7
 └── projections
      └── CASE WHEN y:7 IS NOT NULL THEN array_agg:10 ELSE CAST(NULL AS INT8[]) END [as=array_agg:9, outer=(7,10)]

# With multiple columns. Without LATERAL these tests are a bit verbose.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT (r, q) FROM (SELECT array_agg(xy.y) r, max(xy.y) q FROM xy WHERE xy.y = a.k)) FROM a
----
project
 ├── columns: k:1!null "?column?":11
 ├── key: (1)
 ├── fd: (1)-->(11)
 ├── group-by
 │    ├── columns: k:1!null y:7 max:9 array_agg:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(7,9,12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null y:7
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan xy
 │    │    │    └── columns: y:7
 │    │    └── filters
 │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:12, outer=(7)]
 │         │    └── y:7
 │         ├── max [as=max:9, outer=(7)]
 │         │    └── y:7
 │         └── any-not-null-agg [as=y:7, outer=(7)]
 │              └── y:7
 └── projections
      └── (CASE WHEN y:7 IS NOT NULL THEN array_agg:12 ELSE CAST(NULL AS INT8[]) END, max:9) [as="?column?":11, outer=(7,9,12)]


# With an aggregate that can't ignore nulls and when a non-nullable column must be synthesized.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, ARRAY(SELECT y FROM xy WHERE xy.y = a.i OR xy.y IS NULL) FROM a
----
project
 ├── columns: k:1!null array:9
 ├── key: (1)
 ├── fd: (1)-->(9)
 ├── group-by
 │    ├── columns: k:1!null canary:10 array_agg:11
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(10,11)
 │    ├── left-join (cross)
 │    │    ├── columns: k:1!null i:2 y:7 canary:10
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: canary:10!null y:7
 │    │    │    ├── fd: ()-->(10)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:7
 │    │    │    └── projections
 │    │    │         └── true [as=canary:10]
 │    │    └── filters
 │    │         └── (y:7 = i:2) OR (y:7 IS NULL) [outer=(2,7)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:11, outer=(7)]
 │         │    └── y:7
 │         └── any-not-null-agg [as=canary:10, outer=(10)]
 │              └── canary:10
 └── projections
      └── COALESCE(CASE WHEN canary:10 IS NOT NULL THEN array_agg:11 ELSE CAST(NULL AS INT8[]) END, ARRAY[]) [as=array:9, outer=(10,11)]

# With an ordering.
norm expect=TryDecorrelateScalarGroupBy
SELECT i, ARRAY(SELECT y FROM xy WHERE xy.y = a.k OR xy.y IS NULL ORDER BY y) FROM a
----
project
 ├── columns: i:2 array:9
 ├── group-by
 │    ├── columns: k:1!null i:2 canary:10 array_agg:11
 │    ├── grouping columns: k:1!null
 │    ├── internal-ordering: +7
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,10,11)
 │    ├── sort
 │    │    ├── columns: k:1!null i:2 y:7 canary:10
 │    │    ├── fd: (1)-->(2)
 │    │    ├── ordering: +7
 │    │    └── left-join (cross)
 │    │         ├── columns: k:1!null i:2 y:7 canary:10
 │    │         ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │         ├── fd: (1)-->(2)
 │    │         ├── scan a
 │    │         │    ├── columns: k:1!null i:2
 │    │         │    ├── key: (1)
 │    │         │    └── fd: (1)-->(2)
 │    │         ├── project
 │    │         │    ├── columns: canary:10!null y:7
 │    │         │    ├── fd: ()-->(10)
 │    │         │    ├── scan xy
 │    │         │    │    └── columns: y:7
 │    │         │    └── projections
 │    │         │         └── true [as=canary:10]
 │    │         └── filters
 │    │              └── (y:7 = k:1) OR (y:7 IS NULL) [outer=(1,7)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:11, outer=(7)]
 │         │    └── y:7
 │         ├── const-agg [as=i:2, outer=(2)]
 │         │    └── i:2
 │         └── any-not-null-agg [as=canary:10, outer=(10)]
 │              └── canary:10
 └── projections
      └── COALESCE(CASE WHEN canary:10 IS NOT NULL THEN array_agg:11 ELSE CAST(NULL AS INT8[]) END, ARRAY[]) [as=array:9, outer=(10,11)]

# Nest scalar decorrelation within scalar decorrelation, using IS NULL to force
# use of left joins.
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM a
WHERE
(
    SELECT max(y)
    FROM xy
    WHERE
    (
        SELECT max(v) FROM uv WHERE u=k
    ) IS NULL
) IS NULL
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 max:11
      ├── key: (1)
      ├── fd: ()-->(11), (1)-->(2-5)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 max:11
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,11)
      │    ├── left-join-apply
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6 y:7 max:10
      │    │    ├── key: (1,6)
      │    │    ├── fd: (1)-->(2-5), (1,6)-->(7,10)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── group-by
      │    │    │    ├── columns: x:6!null y:7 max:10
      │    │    │    ├── grouping columns: x:6!null
      │    │    │    ├── outer: (1)
      │    │    │    ├── key: (6)
      │    │    │    ├── fd: (6)-->(7,10)
      │    │    │    ├── left-join (cross)
      │    │    │    │    ├── columns: x:6!null y:7 u:8 v:9
      │    │    │    │    ├── outer: (1)
      │    │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    │    │    ├── key: (6,8)
      │    │    │    │    ├── fd: (6)-->(7), (8)-->(9)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:8!null v:9
      │    │    │    │    │    ├── key: (8)
      │    │    │    │    │    └── fd: (8)-->(9)
      │    │    │    │    └── filters
      │    │    │    │         └── u:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    │    │    └── aggregations
      │    │    │         ├── max [as=max:10, outer=(9)]
      │    │    │         │    └── v:9
      │    │    │         └── const-agg [as=y:7, outer=(7)]
      │    │    │              └── y:7
      │    │    └── filters
      │    │         └── max:10 IS NULL [outer=(10), constraints=(/10: [/NULL - /NULL]; tight), fd=()-->(10)]
      │    └── aggregations
      │         ├── max [as=max:11, outer=(7)]
      │         │    └── y:7
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── max:11 IS NULL [outer=(11), constraints=(/11: [/NULL - /NULL]; tight), fd=()-->(11)]

# ScalarGroupBy with non-null ignoring and a non-nullable column.
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM cd
WHERE
(
    SELECT array_agg(y)
    FROM xy
    WHERE c = x
) = ARRAY[]:::INT[]
----
project
 ├── columns: c:1!null d:2!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── select
      ├── columns: c:1!null d:2!null array_agg:5!null
      ├── key: (1)
      ├── fd: ()-->(5), (1)-->(2)
      ├── project
      │    ├── columns: array_agg:5 c:1!null d:2!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,5)
      │    ├── group-by
      │    │    ├── columns: c:1!null d:2!null x:3 array_agg:6
      │    │    ├── grouping columns: c:1!null
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,3,6)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: c:1!null d:2!null x:3 y:4
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-4), (3)-->(4)
      │    │    │    ├── scan cd
      │    │    │    │    ├── columns: c:1!null d:2!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:3!null y:4
      │    │    │    │    ├── key: (3)
      │    │    │    │    └── fd: (3)-->(4)
      │    │    │    └── filters
      │    │    │         └── c:1 = x:3 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      │    │    └── aggregations
      │    │         ├── array-agg [as=array_agg:6, outer=(4)]
      │    │         │    └── y:4
      │    │         ├── const-agg [as=d:2, outer=(2)]
      │    │         │    └── d:2
      │    │         └── any-not-null-agg [as=x:3, outer=(3)]
      │    │              └── x:3
      │    └── projections
      │         └── CASE WHEN x:3 IS NOT NULL THEN array_agg:6 ELSE CAST(NULL AS INT8[]) END [as=array_agg:5, outer=(3,6)]
      └── filters
           └── array_agg:5 = ARRAY[] [outer=(5), constraints=(/5: [/ARRAY[] - /ARRAY[]]; tight), fd=()-->(5)]

norm expect=TryDecorrelateScalarGroupBy
SELECT * FROM a WHERE 'foo'=(SELECT concat_agg(y::string) FROM xy WHERE x=k)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 concat_agg:9!null
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(9), (1)-->(2-5)
      ├── project
      │    ├── columns: concat_agg:9 k:1!null i:2 f:3 s:4 j:5
      │    ├── immutable
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,9)
      │    ├── group-by
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 canary:10 concat_agg:11
      │    │    ├── grouping columns: k:1!null
      │    │    ├── immutable
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,10,11)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6 column8:8 canary:10
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── immutable
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-6,8,10), (6)-->(8)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    ├── project
      │    │    │    │    ├── columns: canary:10!null column8:8 x:6!null
      │    │    │    │    ├── immutable
      │    │    │    │    ├── key: (6)
      │    │    │    │    ├── fd: ()-->(10), (6)-->(8)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    └── projections
      │    │    │    │         ├── true [as=canary:10]
      │    │    │    │         └── y:7::STRING [as=column8:8, outer=(7), immutable]
      │    │    │    └── filters
      │    │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    │    └── aggregations
      │    │         ├── concat-agg [as=concat_agg:11, outer=(8)]
      │    │         │    └── column8:8
      │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │         │    └── i:2
      │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │         │    └── f:3
      │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │         │    └── s:4
      │    │         ├── const-agg [as=j:5, outer=(5)]
      │    │         │    └── j:5
      │    │         └── any-not-null-agg [as=canary:10, outer=(10)]
      │    │              └── canary:10
      │    └── projections
      │         └── CASE WHEN canary:10 IS NOT NULL THEN concat_agg:11 ELSE CAST(NULL AS STRING) END [as=concat_agg:9, outer=(10,11)]
      └── filters
           └── concat_agg:9 = 'foo' [outer=(9), constraints=(/9: [/'foo' - /'foo']; tight), fd=()-->(9)]

# With a multi-argument aggregate.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT string_agg(a.s, ',') FROM a WHERE a.k = a2.i) FROM a AS a2
----
project
 ├── columns: k:1!null string_agg:13
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── group-by
 │    ├── columns: a2.k:1!null string_agg:12
 │    ├── grouping columns: a2.k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: a2.k:1!null a2.i:2 a.k:6 a.s:9 column11:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,6,9,11), (6)-->(9)
 │    │    ├── scan a2
 │    │    │    ├── columns: a2.k:1!null a2.i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: column11:11!null a.k:6!null a.s:9
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: ()-->(11), (6)-->(9)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: a.k:6!null a.s:9
 │    │    │    │    ├── key: (6)
 │    │    │    │    └── fd: (6)-->(9)
 │    │    │    └── projections
 │    │    │         └── ',' [as=column11:11]
 │    │    └── filters
 │    │         └── a.k:6 = a2.i:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
 │    └── aggregations
 │         └── string-agg [as=string_agg:12, outer=(9,11)]
 │              ├── a.s:9
 │              └── column11:11
 └── projections
      └── string_agg:12 [as=string_agg:13, outer=(12)]

# --------------------------------------------------
# TryDecorrelateSemiJoin
# --------------------------------------------------

# Right input of SemiJoin is GroupBy.
norm expect=TryDecorrelateSemiJoin
SELECT *
FROM xy
WHERE EXISTS
(
    SELECT * FROM a WHERE i=(SELECT max(i) FROM a WHERE f=y::float)
)
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── select
 │    ├── columns: x:1!null y:2 k:3!null i:4!null max:13!null
 │    ├── immutable
 │    ├── key: (1,3)
 │    ├── fd: (1)-->(2), (3)-->(4), (1,3)-->(2,4,13), (4)==(13), (13)==(4)
 │    ├── group-by
 │    │    ├── columns: x:1!null y:2 k:3!null i:4 max:13!null
 │    │    ├── grouping columns: x:1!null k:3!null
 │    │    ├── immutable
 │    │    ├── key: (1,3)
 │    │    ├── fd: (1)-->(2), (3)-->(4), (1,3)-->(2,4,13)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null y:2 k:3!null i:4 i:9!null f:10!null column14:14!null
 │    │    │    ├── immutable
 │    │    │    ├── fd: (1)-->(2), (2)-->(14), (10)==(14), (14)==(10), (3)-->(4)
 │    │    │    ├── inner-join (hash)
 │    │    │    │    ├── columns: x:1!null y:2 i:9!null f:10!null column14:14!null
 │    │    │    │    ├── immutable
 │    │    │    │    ├── fd: (1)-->(2), (2)-->(14), (10)==(14), (14)==(10)
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: column14:14 x:1!null y:2
 │    │    │    │    │    ├── immutable
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(2), (2)-->(14)
 │    │    │    │    │    ├── scan xy
 │    │    │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    │    └── fd: (1)-->(2)
 │    │    │    │    │    └── projections
 │    │    │    │    │         └── y:2::FLOAT8 [as=column14:14, outer=(2), immutable]
 │    │    │    │    ├── select
 │    │    │    │    │    ├── columns: i:9!null f:10
 │    │    │    │    │    ├── scan a
 │    │    │    │    │    │    └── columns: i:9 f:10
 │    │    │    │    │    └── filters
 │    │    │    │    │         └── i:9 IS NOT NULL [outer=(9), constraints=(/9: (/NULL - ]; tight)]
 │    │    │    │    └── filters
 │    │    │    │         └── column14:14 = f:10 [outer=(10,14), constraints=(/10: (/NULL - ]; /14: (/NULL - ]), fd=(10)==(14), (14)==(10)]
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:3!null i:4
 │    │    │    │    ├── key: (3)
 │    │    │    │    └── fd: (3)-->(4)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── max [as=max:13, outer=(9)]
 │    │         │    └── i:9
 │    │         ├── const-agg [as=i:4, outer=(4)]
 │    │         │    └── i:4
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── i:4 = max:13 [outer=(4,13), constraints=(/4: (/NULL - ]; /13: (/NULL - ]), fd=(4)==(13), (13)==(4)]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Right input of SemiJoin is DistinctOn.
norm expect=TryDecorrelateSemiJoin
SELECT *
FROM xy
WHERE EXISTS
(
    SELECT * FROM (SELECT DISTINCT ON (f) i FROM a WHERE y > f) WHERE x=i
)
----
group-by
 ├── columns: x:1!null y:2!null
 ├── grouping columns: x:1!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── select
 │    ├── columns: x:1!null y:2!null i:4!null f:5!null
 │    ├── key: (1,5)
 │    ├── fd: (1)-->(2), (1,5)-->(2,4), (1)==(4), (4)==(1)
 │    ├── distinct-on
 │    │    ├── columns: x:1!null y:2!null i:4 f:5!null
 │    │    ├── grouping columns: x:1!null f:5!null
 │    │    ├── key: (1,5)
 │    │    ├── fd: (1)-->(2), (1,5)-->(2,4)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null y:2!null i:4 f:5!null
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    └── columns: i:4 f:5
 │    │    │    └── filters
 │    │    │         └── y:2 > f:5 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ])]
 │    │    └── aggregations
 │    │         ├── first-agg [as=i:4, outer=(4)]
 │    │         │    └── i:4
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── x:1 = i:4 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Right input of SemiJoin is Project.
norm expect=TryDecorrelateSemiJoin
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT coalesce(u, 10) AS computed FROM uv WHERE u=i) ON x=computed
)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null x:6!null computed:10!null
      ├── key: (1)
      ├── fd: (1)-->(10), (6)==(10), (10)==(6)
      ├── project
      │    ├── columns: computed:10 k:1!null x:6!null
      │    ├── key: (1,6)
      │    ├── fd: (1)-->(10)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null i:2!null x:6!null u:8!null
      │    │    ├── key: (1,6)
      │    │    ├── fd: (1)-->(2), (2)==(8), (8)==(2)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: k:1!null i:2!null u:8!null
      │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2), (2)==(8), (8)==(2)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── filters
      │    │    │         └── u:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null
      │    │    │    └── key: (6)
      │    │    └── filters (true)
      │    └── projections
      │         └── COALESCE(u:8, 10) [as=computed:10, outer=(8)]
      └── filters
           └── x:6 = computed:10 [outer=(6,10), constraints=(/6: (/NULL - ]; /10: (/NULL - ]), fd=(6)==(10), (10)==(6)]

# Right input of SemiJoin is ProjectSet.
norm expect=TryDecorrelateSemiJoin
SELECT * FROM xy WHERE EXISTS(SELECT generate_series(x, 10), generate_series(y, 10))
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── project-set
 │    ├── columns: x:1!null y:2 generate_series:3 generate_series:4
 │    ├── immutable
 │    ├── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:1!null y:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── zip
 │         ├── generate_series(x:1, 10) [outer=(1), immutable]
 │         └── generate_series(y:2, 10) [outer=(2), immutable]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# --------------------------------------------------
# TryDecorrelateLimitOne
# --------------------------------------------------

# With inner join.
norm expect=TryDecorrelateLimitOne
SELECT *
FROM a
WHERE EXISTS
(
    SELECT x
    FROM xy
    INNER JOIN (SELECT * FROM uv WHERE v=i LIMIT 1)
    ON x=u
)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── inner-join (hash)
 │    ├── columns: x:6!null u:8!null v:9
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (8)
 │    ├── fd: (8)-->(9), (6)==(8), (8)==(6)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── scan uv
 │    │    ├── columns: u:8!null v:9
 │    │    ├── key: (8)
 │    │    └── fd: (8)-->(9)
 │    └── filters
 │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 └── filters
      └── v:9 = i:2 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]

# With left join.
norm expect=TryDecorrelateLimitOne
SELECT (SELECT x FROM xy WHERE y=i LIMIT 1) FROM a
----
project
 ├── columns: x:8
 ├── distinct-on
 │    ├── columns: k:1!null xy.x:6
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(6)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 xy.x:6 y:7
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2), (6)-->(7)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:6, outer=(6)]
 │              └── xy.x:6
 └── projections
      └── xy.x:6 [as=x:8, outer=(6)]

# With multiple limited queries.
norm expect=TryDecorrelateLimitOne
SELECT * FROM a WHERE (SELECT x FROM xy WHERE y=i LIMIT 1)=k AND (SELECT u FROM uv WHERE v=i LIMIT 1)=k
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:8!null
      ├── key: (1)
      ├── fd: (1)-->(2-5), (1)==(8), (8)==(1)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 u:8
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,8)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null u:8 v:9
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── key: (1,8)
      │    │    ├── fd: (1)-->(2-5), (1)==(6), (6)==(1), (8)-->(9)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5), (1)==(6), (6)==(1)
      │    │    │    ├── distinct-on
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6
      │    │    │    │    ├── grouping columns: k:1!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    ├── fd: (1)-->(2-6)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6 y:7
      │    │    │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    │    │    │    ├── key: (1,6)
      │    │    │    │    │    ├── fd: (1)-->(2-5), (6)-->(7)
      │    │    │    │    │    ├── scan a
      │    │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │    │    │         │    └── i:2
      │    │    │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │    │    │         │    └── f:3
      │    │    │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │    │    │         │    └── s:4
      │    │    │    │         ├── const-agg [as=j:5, outer=(5)]
      │    │    │    │         │    └── j:5
      │    │    │    │         └── first-agg [as=x:6, outer=(6)]
      │    │    │    │              └── x:6
      │    │    │    └── filters
      │    │    │         └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    │    ├── scan uv
      │    │    │    ├── columns: u:8!null v:9
      │    │    │    ├── key: (8)
      │    │    │    └── fd: (8)-->(9)
      │    │    └── filters
      │    │         └── v:9 = i:2 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=u:8, outer=(8)]
      │              └── u:8
      └── filters
           └── k:1 = u:8 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]

# With nested limited queries.
norm expect=TryDecorrelateLimitOne
SELECT *
FROM a
WHERE
(
    SELECT x
    FROM xy
    WHERE y=i AND
    (
        SELECT u FROM uv WHERE v=y LIMIT 1
    )=x
    LIMIT 1
)=k
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null
      ├── key: (1)
      ├── fd: (1)-->(2-5), (1)==(6), (6)==(1)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-6)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6 y:7 u:8
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── key: (1,6)
      │    │    ├── fd: (1)-->(2-5), (6)-->(7), (6)==(8), (8)==(6)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── select
      │    │    │    ├── columns: x:6!null y:7 u:8!null
      │    │    │    ├── key: (6)
      │    │    │    ├── fd: (6)-->(7), (6)==(8), (8)==(6)
      │    │    │    ├── distinct-on
      │    │    │    │    ├── columns: x:6!null y:7 u:8
      │    │    │    │    ├── grouping columns: x:6!null
      │    │    │    │    ├── key: (6)
      │    │    │    │    ├── fd: (6)-->(7,8)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: x:6!null y:7 u:8 v:9
      │    │    │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    │    │    │    ├── key: (6,8)
      │    │    │    │    │    ├── fd: (6)-->(7), (8)-->(9)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    │    ├── scan uv
      │    │    │    │    │    │    ├── columns: u:8!null v:9
      │    │    │    │    │    │    ├── key: (8)
      │    │    │    │    │    │    └── fd: (8)-->(9)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── v:9 = y:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=y:7, outer=(7)]
      │    │    │    │         │    └── y:7
      │    │    │    │         └── first-agg [as=u:8, outer=(8)]
      │    │    │    │              └── u:8
      │    │    │    └── filters
      │    │    │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
      │    │    └── filters
      │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=x:6, outer=(6)]
      │              └── x:6
      └── filters
           └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# With inner join + ORDER BY.
norm expect=TryDecorrelateLimitOne
SELECT
(
    SELECT v
    FROM uv
    INNER JOIN (SELECT * FROM a WHERE i=x ORDER BY f LIMIT 1)
    ON u=k
    LIMIT 1
)
FROM xy
----
project
 ├── columns: v:10
 ├── distinct-on
 │    ├── columns: x:1!null uv.v:4
 │    ├── grouping columns: x:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── left-join (hash)
 │    │    ├── columns: x:1!null u:3 uv.v:4 k:5 i:6
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── key: (1,5)
 │    │    ├── fd: (3)-->(4), (5)-->(6), (3)==(5), (5)==(3)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null
 │    │    │    └── key: (1)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: u:3!null uv.v:4 k:5!null i:6
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    │    │    ├── key: (5)
 │    │    │    ├── fd: (3)-->(4), (5)-->(6), (3)==(5), (5)==(3)
 │    │    │    ├── scan uv
 │    │    │    │    ├── columns: u:3!null uv.v:4
 │    │    │    │    ├── key: (3)
 │    │    │    │    └── fd: (3)-->(4)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:5!null i:6
 │    │    │    │    ├── key: (5)
 │    │    │    │    └── fd: (5)-->(6)
 │    │    │    └── filters
 │    │    │         └── u:3 = k:5 [outer=(3,5), constraints=(/3: (/NULL - ]; /5: (/NULL - ]), fd=(3)==(5), (5)==(3)]
 │    │    └── filters
 │    │         └── i:6 = x:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    └── aggregations
 │         └── first-agg [as=uv.v:4, outer=(4)]
 │              └── uv.v:4
 └── projections
      └── uv.v:4 [as=v:10, outer=(4)]

# With left join + ORDER BY.
norm expect=TryDecorrelateLimitOne
SELECT * FROM xy WHERE (SELECT k FROM a WHERE i=y ORDER BY f,s LIMIT 1)=x
----
project
 ├── columns: x:1!null y:2
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── select
      ├── columns: x:1!null y:2 k:3!null
      ├── key: (1)
      ├── fd: (1)-->(2), (1)==(3), (3)==(1)
      ├── distinct-on
      │    ├── columns: x:1!null y:2 k:3
      │    ├── grouping columns: x:1!null
      │    ├── internal-ordering: +5,+6 opt(4)
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,3)
      │    ├── sort
      │    │    ├── columns: x:1!null y:2 k:3 i:4 f:5 s:6
      │    │    ├── key: (1,3)
      │    │    ├── fd: (1)-->(2), (3)-->(4-6)
      │    │    ├── ordering: +5,+6 opt(4) [actual: +5,+6]
      │    │    └── left-join (hash)
      │    │         ├── columns: x:1!null y:2 k:3 i:4 f:5 s:6
      │    │         ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │         ├── key: (1,3)
      │    │         ├── fd: (1)-->(2), (3)-->(4-6)
      │    │         ├── scan xy
      │    │         │    ├── columns: x:1!null y:2
      │    │         │    ├── key: (1)
      │    │         │    └── fd: (1)-->(2)
      │    │         ├── scan a
      │    │         │    ├── columns: k:3!null i:4 f:5 s:6
      │    │         │    ├── key: (3)
      │    │         │    └── fd: (3)-->(4-6)
      │    │         └── filters
      │    │              └── i:4 = y:2 [outer=(2,4), constraints=(/2: (/NULL - ]; /4: (/NULL - ]), fd=(2)==(4), (4)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── first-agg [as=k:3, outer=(3)]
      │              └── k:3
      └── filters
           └── x:1 = k:3 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]

# --------------------------------------------------
# TryDecorrelateMax1Row
# --------------------------------------------------

# Rule is activated on LeftJoinApply.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT d FROM cd WHERE d=x) FROM xy
----
project
 ├── columns: d:5
 ├── ensure-distinct-on
 │    ├── columns: x:1!null cd.d:4
 │    ├── grouping columns: x:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── left-join (hash)
 │    │    ├── columns: x:1!null cd.d:4
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan cd
 │    │    │    └── columns: cd.d:4!null
 │    │    └── filters
 │    │         └── cd.d:4 = x:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
 │    └── aggregations
 │         └── const-agg [as=cd.d:4, outer=(4)]
 │              └── cd.d:4
 └── projections
      └── cd.d:4 [as=d:5, outer=(4)]

# Rule is activated on LeftJoinApply.
# Case without a primary key on left side of join.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM (SELECT y FROM xy) WHERE 5 = (SELECT d FROM cd WHERE d=y)
----
project
 ├── columns: y:2
 └── select
      ├── columns: x:1!null y:2 d:4!null
      ├── key: (1)
      ├── fd: ()-->(4), (1)-->(2)
      ├── ensure-distinct-on
      │    ├── columns: x:1!null y:2 d:4
      │    ├── grouping columns: x:1!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1!null y:2 d:4
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── fd: (1)-->(2)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:1!null y:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan cd
      │    │    │    └── columns: d:4!null
      │    │    └── filters
      │    │         └── d:4 = y:2 [outer=(2,4), constraints=(/2: (/NULL - ]; /4: (/NULL - ]), fd=(2)==(4), (4)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=d:4, outer=(4)]
      │              └── d:4
      └── filters
           └── d:4 = 5 [outer=(4), constraints=(/4: [/5 - /5]; tight), fd=()-->(4)]

# Rule is activated on LeftJoinApply.
# Case with multiple projected columns that will be translated to multiple
# const-agg functions.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT d FROM cd WHERE d=k), i, f, s, j FROM a
----
project
 ├── columns: d:8 i:2 f:3 s:4 j:5
 ├── ensure-distinct-on
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 cd.d:7
 │    ├── grouping columns: k:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,7)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 cd.d:7
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── fd: (1)-->(2-5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2-5)
 │    │    ├── scan cd
 │    │    │    └── columns: cd.d:7!null
 │    │    └── filters
 │    │         └── cd.d:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         ├── const-agg [as=i:2, outer=(2)]
 │         │    └── i:2
 │         ├── const-agg [as=f:3, outer=(3)]
 │         │    └── f:3
 │         ├── const-agg [as=s:4, outer=(4)]
 │         │    └── s:4
 │         ├── const-agg [as=j:5, outer=(5)]
 │         │    └── j:5
 │         └── const-agg [as=cd.d:7, outer=(7)]
 │              └── cd.d:7
 └── projections
      └── cd.d:7 [as=d:8, outer=(7)]

# Rule is activated on LeftJoin.
# This test is a bit fragile because it depends on DecorrelateJoin activating
# before TryDecorrelateMax1Row.
# A LeftJoin is used because subquery cardinality might be zero.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM a LEFT JOIN LATERAL (SELECT * FROM uv WHERE (SELECT true FROM xy WHERE y=i)) ON true
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5 u:6 v:7
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (1,6)-->(7)
 └── left-join-apply
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:6 v:7 bool:10
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (1,6)-->(7,10)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── ensure-distinct-on
      │    ├── columns: u:6!null v:7 bool:10
      │    ├── grouping columns: u:6!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── outer: (2)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7,10)
      │    ├── left-join (cross)
      │    │    ├── columns: u:6!null v:7 bool:10
      │    │    ├── outer: (2)
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── fd: (6)-->(7)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:6!null v:7
      │    │    │    ├── key: (6)
      │    │    │    └── fd: (6)-->(7)
      │    │    ├── project
      │    │    │    ├── columns: bool:10!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── fd: ()-->(10)
      │    │    │    ├── select
      │    │    │    │    ├── columns: y:9!null
      │    │    │    │    ├── outer: (2)
      │    │    │    │    ├── fd: ()-->(9)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    └── columns: y:9
      │    │    │    │    └── filters
      │    │    │    │         └── y:9 = i:2 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
      │    │    │    └── projections
      │    │    │         └── true [as=bool:10]
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── const-agg [as=v:7, outer=(7)]
      │         │    └── v:7
      │         └── const-agg [as=bool:10, outer=(10)]
      │              └── bool:10
      └── filters
           └── bool:10 [outer=(10), constraints=(/10: [/true - /true]; tight), fd=()-->(10)]

# Rule is activated on InnerJoinApply.
# An InnerJoinApply is used because subquery cardinality is guaranteed to be
# greater than zero.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT t=x FROM (VALUES (1), (2)) f(t)) FROM xy
----
project
 ├── columns: "?column?":5!null
 ├── ensure-distinct-on
 │    ├── columns: x:1!null "?column?":4!null
 │    ├── grouping columns: x:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(4)
 │    ├── project
 │    │    ├── columns: "?column?":4!null x:1!null
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null column1:3!null
 │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null
 │    │    │    │    └── key: (1)
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:3!null
 │    │    │    │    ├── cardinality: [2 - 2]
 │    │    │    │    ├── (1,)
 │    │    │    │    └── (2,)
 │    │    │    └── filters (true)
 │    │    └── projections
 │    │         └── column1:3 = x:1 [as="?column?":4, outer=(1,3)]
 │    └── aggregations
 │         └── const-agg [as="?column?":4, outer=(4)]
 │              └── "?column?":4
 └── projections
      └── "?column?":4 [as="?column?":5, outer=(4)]

# Rule is activated on InnerJoin.
# This test is a bit fragile because it depends on DecorrelateJoin activating
# before TryDecorrelateMax1Row.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM a LEFT JOIN LATERAL (SELECT * FROM uv WHERE (SELECT y=i FROM (VALUES (1), (2)) v(y))) ON true
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5 u:6 v:7
 ├── key: (1,6)
 ├── fd: (1)-->(2-5), (1,6)-->(7)
 └── left-join-apply
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:6 v:7 "?column?":9
      ├── key: (1,6)
      ├── fd: (1)-->(2-5), (1,6)-->(7,9)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── ensure-distinct-on
      │    ├── columns: u:6!null v:7 "?column?":9
      │    ├── grouping columns: u:6!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── outer: (2)
      │    ├── key: (6)
      │    ├── fd: (6)-->(7,9)
      │    ├── project
      │    │    ├── columns: "?column?":9 u:6!null v:7
      │    │    ├── outer: (2)
      │    │    ├── fd: (6)-->(7)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: u:6!null v:7 column1:8!null
      │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    │    ├── fd: (6)-->(7)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:6!null v:7
      │    │    │    │    ├── key: (6)
      │    │    │    │    └── fd: (6)-->(7)
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:8!null
      │    │    │    │    ├── cardinality: [2 - 2]
      │    │    │    │    ├── (1,)
      │    │    │    │    └── (2,)
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         └── column1:8 = i:2 [as="?column?":9, outer=(2,8)]
      │    └── aggregations
      │         ├── const-agg [as=v:7, outer=(7)]
      │         │    └── v:7
      │         └── const-agg [as="?column?":9, outer=(9)]
      │              └── "?column?":9
      └── filters
           └── "?column?":9 [outer=(9), constraints=(/9: [/true - /true]; tight), fd=()-->(9)]

# Filter (y=3) must not be pushed through EnsureDistinctOn in order to ensure
# expected error behavior.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT a FROM (VALUES (0), (0)) v(a) WHERE (SELECT y FROM xy WHERE x<>a)=3
----
project
 ├── columns: a:1!null
 └── select
      ├── columns: column1:1!null y:3!null rownum:4!null
      ├── key: (4)
      ├── fd: ()-->(3), (4)-->(1)
      ├── ensure-distinct-on
      │    ├── columns: column1:1!null y:3 rownum:4!null
      │    ├── grouping columns: rownum:4!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── cardinality: [1 - ]
      │    ├── key: (4)
      │    ├── fd: (4)-->(1,3)
      │    ├── left-join (cross)
      │    │    ├── columns: column1:1!null x:2 y:3 rownum:4!null
      │    │    ├── cardinality: [2 - ]
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── key: (2,4)
      │    │    ├── fd: (4)-->(1), (2)-->(3)
      │    │    ├── ordinality
      │    │    │    ├── columns: column1:1!null rownum:4!null
      │    │    │    ├── cardinality: [2 - 2]
      │    │    │    ├── key: (4)
      │    │    │    ├── fd: (4)-->(1)
      │    │    │    └── values
      │    │    │         ├── columns: column1:1!null
      │    │    │         ├── cardinality: [2 - 2]
      │    │    │         ├── (0,)
      │    │    │         └── (0,)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:2!null y:3
      │    │    │    ├── key: (2)
      │    │    │    └── fd: (2)-->(3)
      │    │    └── filters
      │    │         └── x:2 != column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ])]
      │    └── aggregations
      │         ├── const-agg [as=column1:1, outer=(1)]
      │         │    └── column1:1
      │         └── const-agg [as=y:3, outer=(3)]
      │              └── y:3
      └── filters
           └── y:3 = 3 [outer=(3), constraints=(/3: [/3 - /3]; tight), fd=()-->(3)]

# --------------------------------------------------
# HoistSelectExists
# --------------------------------------------------
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Ensure that EXISTS is hoisted even when it is one of several conjuncts.
norm expect=HoistSelectExists
SELECT * FROM a WHERE s='foo' AND EXISTS(SELECT * FROM xy WHERE x=k) AND i>1
----
semi-join (hash)
 ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 │         └── i:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Multiple Exists operators in same Select list.
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k) AND EXISTS(SELECT * FROM xy WHERE x=i)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Don't hoist uncorrelated subqueries.
norm expect-not=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: x:6!null y:7
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(6,7)
                ├── scan xy
                │    ├── columns: x:6!null y:7
                │    ├── key: (6)
                │    ├── fd: (6)-->(7)
                │    └── limit hint: 1.00
                └── 1

# Hoist nested EXISTS.
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE EXISTS (SELECT * FROM uv WHERE x=u) AND x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: x:6!null
 │    ├── key: (6)
 │    ├── scan xy
 │    │    ├── columns: x:6!null
 │    │    └── key: (6)
 │    ├── scan uv
 │    │    ├── columns: u:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:6 = u:8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# HoistSelectNotExists
# --------------------------------------------------
norm expect=HoistSelectNotExists
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Ensure that NOT EXISTS is hoisted even when one of several conjuncts.
norm expect=HoistSelectNotExists
SELECT * FROM a WHERE s='foo' AND NOT EXISTS(SELECT * FROM xy WHERE x=k) AND i>1
----
anti-join (hash)
 ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 │         └── i:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Multiple Not Exists operators in same Select list.
norm expect=HoistSelectNotExists
SELECT *
FROM a
WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k) AND NOT EXISTS(SELECT * FROM xy WHERE x=i)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# Don't hoist uncorrelated subqueries.
norm expect-not=HoistSelectNotExists
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── not [subquery]
           └── exists
                └── limit
                     ├── columns: x:6!null y:7
                     ├── cardinality: [0 - 1]
                     ├── key: ()
                     ├── fd: ()-->(6,7)
                     ├── scan xy
                     │    ├── columns: x:6!null y:7
                     │    ├── key: (6)
                     │    ├── fd: (6)-->(7)
                     │    └── limit hint: 1.00
                     └── 1

# --------------------------------------------------
# HoistSelectExists + HoistSelectNotExists
# --------------------------------------------------
norm expect=(HoistSelectExists,HoistSelectNotExists)
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k) AND NOT EXISTS(SELECT * FROM xy WHERE x=i)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:8!null
 │    │    └── key: (8)
 │    └── filters
 │         └── x:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 ├── scan xy
 │    ├── columns: x:6!null
 │    └── key: (6)
 └── filters
      └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# HoistSelectSubquery
# --------------------------------------------------
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (SELECT y FROM xy WHERE y=k LIMIT 1) = i
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:7!null
      ├── key: (1)
      ├── fd: (1)-->(2-5,7), (2)==(7), (7)==(2)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,7)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: (1)-->(2-5)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── scan xy
      │    │    │    └── columns: y:7
      │    │    └── filters
      │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=y:7, outer=(7)]
      │              └── y:7
      └── filters
           └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Multiple other conjuncts, including uncorrelated subquery (don't hoist).
norm expect=HoistSelectSubquery disable=InlineConstVar
SELECT *
FROM a
WHERE k=10 AND (SELECT y FROM xy WHERE y=k LIMIT 1) = i AND (SELECT x FROM xy LIMIT 1) = 100
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:7!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-5,7)
      ├── limit
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1-5,7)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: ()-->(1-5)
      │    │    ├── limit hint: 1.00
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── cardinality: [0 - 1]
      │    │    │    ├── key: ()
      │    │    │    ├── fd: ()-->(1-5)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    └── filters
      │    │    │         ├── k:1 = 10 [outer=(1), constraints=(/1: [/10 - /10]; tight), fd=()-->(1)]
      │    │    │         └── eq [subquery]
      │    │    │              ├── subquery
      │    │    │              │    └── limit
      │    │    │              │         ├── columns: x:8!null
      │    │    │              │         ├── cardinality: [0 - 1]
      │    │    │              │         ├── key: ()
      │    │    │              │         ├── fd: ()-->(8)
      │    │    │              │         ├── scan xy
      │    │    │              │         │    ├── columns: x:8!null
      │    │    │              │         │    ├── key: (8)
      │    │    │              │         │    └── limit hint: 1.00
      │    │    │              │         └── 1
      │    │    │              └── 100
      │    │    ├── select
      │    │    │    ├── columns: y:7!null
      │    │    │    ├── fd: ()-->(7)
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:7
      │    │    │    └── filters
      │    │    │         ├── y:7 = 10 [outer=(7), constraints=(/7: [/10 - /10]; tight), fd=()-->(7)]
      │    │    │         └── eq [subquery]
      │    │    │              ├── subquery
      │    │    │              │    └── limit
      │    │    │              │         ├── columns: x:8!null
      │    │    │              │         ├── cardinality: [0 - 1]
      │    │    │              │         ├── key: ()
      │    │    │              │         ├── fd: ()-->(8)
      │    │    │              │         ├── scan xy
      │    │    │              │         │    ├── columns: x:8!null
      │    │    │              │         │    ├── key: (8)
      │    │    │              │         │    └── limit hint: 1.00
      │    │    │              │         └── 1
      │    │    │              └── 100
      │    │    └── filters
      │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── 1
      └── filters
           └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Multiple correlated subqueries.
norm expect=HoistSelectSubquery
SELECT * FROM a
WHERE (SELECT count(*) FROM xy WHERE y=k) > 0 AND (SELECT y FROM xy WHERE y=k LIMIT 1) = i
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:10!null
      ├── key: (1)
      ├── fd: (1)-->(2-5,10), (2)==(10), (10)==(2)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:10
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,10)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:8!null y:10
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: (1)-->(2-5,8)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:8!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5,8)
      │    │    │    ├── group-by
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:8!null
      │    │    │    │    ├── grouping columns: k:1!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    ├── fd: (1)-->(2-5,8)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7
      │    │    │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    │    │    │    ├── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan a
      │    │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    └── columns: y:7
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── y:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── count [as=count_rows:8, outer=(7)]
      │    │    │    │         │    └── y:7
      │    │    │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │    │    │         │    └── i:2
      │    │    │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │    │    │         │    └── f:3
      │    │    │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │    │    │         │    └── s:4
      │    │    │    │         └── const-agg [as=j:5, outer=(5)]
      │    │    │    │              └── j:5
      │    │    │    └── filters
      │    │    │         └── count_rows:8 > 0 [outer=(8), constraints=(/8: [/1 - ]; tight)]
      │    │    ├── scan xy
      │    │    │    └── columns: y:10
      │    │    └── filters
      │    │         └── y:10 = k:1 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=y:10, outer=(10)]
      │              └── y:10
      └── filters
           └── i:2 = y:10 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]

# Subquery nested below interesting scalar operators like cast, function, tuple,
# or, etc).
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (0, length((SELECT count(*) FROM uv WHERE k=u)::string)) > (0, 1) OR i=1
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:8!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2-5,8)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:8!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,8)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 u:6
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-6)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:6!null
      │    │    │    └── key: (6)
      │    │    └── filters
      │    │         └── k:1 = u:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    └── aggregations
      │         ├── count [as=count_rows:8, outer=(6)]
      │         │    └── u:6
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── ((0, length(count_rows:8::STRING)) > (0, 1)) OR (i:2 = 1) [outer=(2,8), immutable]

# Exists within a disjunction.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE i=1 OR EXISTS(SELECT * FROM xy WHERE y=i)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:9
      ├── key: (1)
      ├── fd: (1)-->(2-5,9)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:9
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,9)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:7 true:8
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    ├── fd: (1)-->(2-5)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── project
      │    │    │    ├── columns: true:8!null y:7
      │    │    │    ├── fd: ()-->(8)
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:7
      │    │    │    └── projections
      │    │    │         └── true [as=true:8]
      │    │    └── filters
      │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:9, outer=(8)]
      │         │    └── true:8
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── (i:2 = 1) OR (true_agg:9 IS NOT NULL) [outer=(2,9)]

# Any with IS NULL.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (i = ANY(SELECT y FROM xy WHERE x=k)) IS NULL
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 case:10
      ├── key: (1)
      ├── fd: ()-->(10), (1)-->(2-5)
      ├── project
      │    ├── columns: case:10 k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,10)
      │    ├── group-by
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 bool_or:9
      │    │    ├── grouping columns: k:1!null
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,9)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6 y:7 notnull:8
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-8), (6)-->(7), (7)~~>(8)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    ├── project
      │    │    │    │    ├── columns: notnull:8!null x:6!null y:7
      │    │    │    │    ├── key: (6)
      │    │    │    │    ├── fd: (6)-->(7), (7)-->(8)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    └── projections
      │    │    │    │         └── y:7 IS NOT NULL [as=notnull:8, outer=(7)]
      │    │    │    └── filters
      │    │    │         ├── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │    │    │         └── (i:2 = y:7) IS NOT false [outer=(2,7)]
      │    │    └── aggregations
      │    │         ├── bool-or [as=bool_or:9, outer=(8)]
      │    │         │    └── notnull:8
      │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │         │    └── i:2
      │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │         │    └── f:3
      │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │         │    └── s:4
      │    │         └── const-agg [as=j:5, outer=(5)]
      │    │              └── j:5
      │    └── projections
      │         └── CASE WHEN bool_or:9 AND (i:2 IS NOT NULL) THEN true WHEN bool_or:9 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=case:10, outer=(2,9)]
      └── filters
           └── case:10 IS NULL [outer=(10), constraints=(/10: [/NULL - /NULL]; tight), fd=()-->(10)]

# Any with uncorrelated subquery (should not be hoisted).
norm
SELECT * FROM a WHERE (i = ANY(SELECT y FROM xy)) IS NULL
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── is [outer=(2), correlated-subquery]
           ├── any: eq
           │    ├── scan xy
           │    │    └── columns: y:7
           │    └── i:2
           └── NULL

# ALL with non-trivial expression on left.
norm
SELECT i*i/100 < ALL(SELECT y FROM xy WHERE x=k) AS r, s FROM a
----
project
 ├── columns: r:8 s:4
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null s:4 scalar:9 bool_or:11
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(4,9,11)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null s:4 x:6 y:7 scalar:9 notnull:10
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(4,6,7,9,10), (6)-->(7), (7)~~>(10)
 │    │    ├── project
 │    │    │    ├── columns: scalar:9 k:1!null s:4
 │    │    │    ├── immutable
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(4,9)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2 s:4
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2,4)
 │    │    │    └── projections
 │    │    │         └── (i:2 * i:2) / 100 [as=scalar:9, outer=(2), immutable]
 │    │    ├── project
 │    │    │    ├── columns: notnull:10!null x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    ├── fd: (6)-->(7), (7)-->(10)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    ├── key: (6)
 │    │    │    │    └── fd: (6)-->(7)
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:10, outer=(7)]
 │    │    └── filters
 │    │         ├── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │         └── (scalar:9 >= y:7) IS NOT false [outer=(7,9)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:11, outer=(10)]
 │         │    └── notnull:10
 │         ├── const-agg [as=s:4, outer=(4)]
 │         │    └── s:4
 │         └── const-agg [as=scalar:9, outer=(9)]
 │              └── scalar:9
 └── projections
      └── NOT CASE WHEN bool_or:11 AND (scalar:9 IS NOT NULL) THEN true WHEN bool_or:11 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(9,11), immutable]

# Regress issue #32270: Panic when expression contains both correlated and
# uncorrelated subquery.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy) OR EXISTS(SELECT * FROM xy WHERE x=k)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:11
      ├── key: (1)
      ├── fd: (1)-->(2-5,11)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:11
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,11)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:8 true:10
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,8,10)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── project
      │    │    │    ├── columns: true:10!null x:8!null
      │    │    │    ├── key: (8)
      │    │    │    ├── fd: ()-->(10)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:8!null
      │    │    │    │    └── key: (8)
      │    │    │    └── projections
      │    │    │         └── true [as=true:10]
      │    │    └── filters
      │    │         └── x:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:11, outer=(10)]
      │         │    └── true:10
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── or [outer=(11), subquery]
                ├── exists
                │    └── limit
                │         ├── columns: x:6!null y:7
                │         ├── cardinality: [0 - 1]
                │         ├── key: ()
                │         ├── fd: ()-->(6,7)
                │         ├── scan xy
                │         │    ├── columns: x:6!null y:7
                │         │    ├── key: (6)
                │         │    ├── fd: (6)-->(7)
                │         │    └── limit hint: 1.00
                │         └── 1
                └── true_agg:11 IS NOT NULL

# --------------------------------------------------
# HoistProjectSubquery
# --------------------------------------------------
norm expect=HoistProjectSubquery
SELECT (SELECT x FROM xy WHERE x=k) FROM a
----
project
 ├── columns: x:8
 ├── left-join (hash)
 │    ├── columns: k:1!null xy.x:6
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (1)
 │    ├── fd: (1)-->(6)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    ├── scan xy
 │    │    ├── columns: xy.x:6!null
 │    │    └── key: (6)
 │    └── filters
 │         └── xy.x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 └── projections
      └── xy.x:6 [as=x:8, outer=(6)]

# Mixed correlated and uncorrelated subqueries.
norm expect=HoistProjectSubquery
SELECT
    5 AS a,
    (SELECT x FROM xy WHERE x=k),
    (SELECT y FROM xy LIMIT 1),
    5 IN (SELECT y FROM xy) AS b,
    EXISTS(SELECT * FROM xy),
    (SELECT count(*) FROM xy WHERE y=k)
FROM a
----
project
 ├── columns: a:17!null x:18 y:19 b:20 exists:21 count:22!null
 ├── fd: ()-->(17,19-21)
 ├── group-by
 │    ├── columns: k:1!null xy.x:6 count_rows:16!null
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(6,16)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null xy.x:6 xy.y:15
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── fd: (1)-->(6)
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: k:1!null xy.x:6
 │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(6)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null
 │    │    │    │    └── key: (1)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: xy.x:6!null
 │    │    │    │    └── key: (6)
 │    │    │    └── filters
 │    │    │         └── xy.x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:15
 │    │    └── filters
 │    │         └── xy.y:15 = k:1 [outer=(1,15), constraints=(/1: (/NULL - ]; /15: (/NULL - ]), fd=(1)==(15), (15)==(1)]
 │    └── aggregations
 │         ├── count [as=count_rows:16, outer=(15)]
 │         │    └── xy.y:15
 │         └── const-agg [as=xy.x:6, outer=(6)]
 │              └── xy.x:6
 └── projections
      ├── 5 [as=a:17]
      ├── xy.x:6 [as=x:18, outer=(6)]
      ├── subquery [as=y:19, subquery]
      │    └── limit
      │         ├── columns: xy.y:9
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         ├── fd: ()-->(9)
      │         ├── scan xy
      │         │    ├── columns: xy.y:9
      │         │    └── limit hint: 1.00
      │         └── 1
      ├── any: eq [as=b:20, subquery]
      │    ├── scan xy
      │    │    └── columns: xy.y:11
      │    └── 5
      ├── exists [as=exists:21, subquery]
      │    └── limit
      │         ├── columns: xy.x:12!null xy.y:13
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         ├── fd: ()-->(12,13)
      │         ├── scan xy
      │         │    ├── columns: xy.x:12!null xy.y:13
      │         │    ├── key: (12)
      │         │    ├── fd: (12)-->(13)
      │         │    └── limit hint: 1.00
      │         └── 1
      └── count_rows:16 [as=count:22, outer=(16)]

# Subquery in GroupBy aggregate (optbuilder creates correlated Project).
norm expect=HoistProjectSubquery
SELECT max((SELECT y FROM xy WHERE y=i)) FROM a
----
scalar-group-by
 ├── columns: max:9
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(9)
 ├── project
 │    ├── columns: column8:8
 │    ├── ensure-distinct-on
 │    │    ├── columns: k:1!null y:7
 │    │    ├── grouping columns: k:1!null
 │    │    ├── error: "more than one row returned by a subquery used as an expression"
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(7)
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: k:1!null i:2 y:7
 │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:7
 │    │    │    └── filters
 │    │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    │    └── aggregations
 │    │         └── const-agg [as=y:7, outer=(7)]
 │    │              └── y:7
 │    └── projections
 │         └── y:7 [as=column8:8, outer=(7)]
 └── aggregations
      └── max [as=max:9, outer=(8)]
           └── column8:8

# Exists in projection list.
norm expect=HoistProjectSubquery
SELECT EXISTS(SELECT * FROM xy WHERE y=i) FROM a
----
project
 ├── columns: exists:8!null
 ├── group-by
 │    ├── columns: k:1!null true_agg:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:7 true:9
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: true:9!null y:7
 │    │    │    ├── fd: ()-->(9)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:7
 │    │    │    └── projections
 │    │    │         └── true [as=true:9]
 │    │    └── filters
 │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── aggregations
 │         └── const-not-null-agg [as=true_agg:10, outer=(9)]
 │              └── true:9
 └── projections
      └── true_agg:10 IS NOT NULL [as=exists:8, outer=(10)]

# Any in projection list.
norm expect=HoistProjectSubquery
SELECT 5 < ANY(SELECT y FROM xy WHERE y=i) AS r FROM a
----
project
 ├── columns: r:8
 ├── group-by
 │    ├── columns: k:1!null bool_or:10
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(10)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:7 notnull:9
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── fd: (1)-->(2), (7)~~>(9)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: notnull:9!null y:7
 │    │    │    ├── fd: (7)-->(9)
 │    │    │    ├── select
 │    │    │    │    ├── columns: y:7
 │    │    │    │    ├── scan xy
 │    │    │    │    │    └── columns: y:7
 │    │    │    │    └── filters
 │    │    │    │         └── (y:7 > 5) IS NOT false [outer=(7)]
 │    │    │    └── projections
 │    │    │         └── y:7 IS NOT NULL [as=notnull:9, outer=(7)]
 │    │    └── filters
 │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:10, outer=(9)]
 │              └── notnull:9
 └── projections
      └── CASE WHEN bool_or:10 THEN true WHEN bool_or:10 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:8, outer=(10)]

# Correlated subquery nested in uncorrelated subquery.
norm expect=HoistProjectSubquery
SELECT EXISTS(SELECT EXISTS(SELECT * FROM xy WHERE y=i) FROM a)
----
values
 ├── columns: exists:12
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(12)
 └── tuple
      └── exists
           └── limit
                ├── columns: k:1!null i:2 y:7 true:9
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(1,2,7,9)
                ├── left-join (hash)
                │    ├── columns: k:1!null i:2 y:7 true:9
                │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
                │    ├── fd: ()-->(1,2)
                │    ├── limit hint: 1.00
                │    ├── limit
                │    │    ├── columns: k:1!null i:2
                │    │    ├── cardinality: [0 - 1]
                │    │    ├── key: ()
                │    │    ├── fd: ()-->(1,2)
                │    │    ├── scan a
                │    │    │    ├── columns: k:1!null i:2
                │    │    │    ├── key: (1)
                │    │    │    ├── fd: (1)-->(2)
                │    │    │    └── limit hint: 1.00
                │    │    └── 1
                │    ├── project
                │    │    ├── columns: true:9!null y:7
                │    │    ├── fd: ()-->(9)
                │    │    ├── scan xy
                │    │    │    └── columns: y:7
                │    │    └── projections
                │    │         └── true [as=true:9]
                │    └── filters
                │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
                └── 1

# Don't hoist uncorrelated subquery.
norm
SELECT i < ANY(SELECT y FROM xy) AS r FROM a
----
project
 ├── columns: r:8
 ├── scan a
 │    └── columns: i:2
 └── projections
      └── any: lt [as=r:8, outer=(2), correlated-subquery]
           ├── scan xy
           │    └── columns: y:7
           └── i:2

# --------------------------------------------------
# HoistJoinSubquery
# --------------------------------------------------
norm expect=HoistJoinSubquery
SELECT i, y FROM a INNER JOIN xy ON (SELECT k+1) = x
----
project
 ├── columns: i:2 y:7
 ├── immutable
 └── inner-join-apply
      ├── columns: k:1!null i:2 x:6!null y:7 "?column?":8
      ├── immutable
      ├── key: (1,6)
      ├── fd: (1)-->(2), (1,6)-->(7,8), (6)==(8), (8)==(6)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── inner-join (cross)
      │    ├── columns: x:6!null y:7 "?column?":8
      │    ├── outer: (1)
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── immutable
      │    ├── key: (6)
      │    ├── fd: ()-->(8), (6)-->(7)
      │    ├── scan xy
      │    │    ├── columns: x:6!null y:7
      │    │    ├── key: (6)
      │    │    └── fd: (6)-->(7)
      │    ├── values
      │    │    ├── columns: "?column?":8
      │    │    ├── outer: (1)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── immutable
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(8)
      │    │    └── (k:1 + 1,)
      │    └── filters (true)
      └── filters
           └── x:6 = "?column?":8 [outer=(6,8), constraints=(/6: (/NULL - ]; /8: (/NULL - ]), fd=(6)==(8), (8)==(6)]

# Hoist Exists in join filter disjunction.
norm expect=HoistJoinSubquery
SELECT s, x FROM a INNER JOIN xy ON EXISTS(SELECT * FROM uv WHERE u=y) OR k=x
----
project
 ├── columns: s:4 x:6!null
 └── inner-join (cross)
      ├── columns: k:1!null s:4 x:6!null exists:12!null
      ├── key: (1,6)
      ├── fd: (1)-->(4), (6)-->(12)
      ├── scan a
      │    ├── columns: k:1!null s:4
      │    ├── key: (1)
      │    └── fd: (1)-->(4)
      ├── project
      │    ├── columns: exists:12!null x:6!null
      │    ├── key: (6)
      │    ├── fd: (6)-->(12)
      │    ├── group-by
      │    │    ├── columns: x:6!null true_agg:11
      │    │    ├── grouping columns: x:6!null
      │    │    ├── key: (6)
      │    │    ├── fd: (6)-->(11)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: x:6!null y:7 u:8 true:10
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    │    ├── key: (6)
      │    │    │    ├── fd: (6)-->(7,8,10)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    ├── key: (6)
      │    │    │    │    └── fd: (6)-->(7)
      │    │    │    ├── project
      │    │    │    │    ├── columns: true:10!null u:8!null
      │    │    │    │    ├── key: (8)
      │    │    │    │    ├── fd: ()-->(10)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:8!null
      │    │    │    │    │    └── key: (8)
      │    │    │    │    └── projections
      │    │    │    │         └── true [as=true:10]
      │    │    │    └── filters
      │    │    │         └── u:8 = y:7 [outer=(7,8), constraints=(/7: (/NULL - ]; /8: (/NULL - ]), fd=(7)==(8), (8)==(7)]
      │    │    └── aggregations
      │    │         └── const-not-null-agg [as=true_agg:11, outer=(10)]
      │    │              └── true:10
      │    └── projections
      │         └── true_agg:11 IS NOT NULL [as=exists:12, outer=(11)]
      └── filters
           └── exists:12 OR (k:1 = x:6) [outer=(1,6,12)]

# Any in Join filter disjunction.
norm expect=HoistJoinSubquery
SELECT j, y FROM a INNER JOIN xy ON x IN (SELECT v FROM uv WHERE u=y AND v=i) OR x IS NULL
----
project
 ├── columns: j:5 y:7
 └── select
      ├── columns: j:5 x:6!null y:7 case:12
      ├── fd: (6)-->(7)
      ├── project
      │    ├── columns: case:12 j:5 x:6!null y:7
      │    ├── fd: (6)-->(7)
      │    ├── group-by
      │    │    ├── columns: k:1!null j:5 x:6!null y:7 bool_or:11
      │    │    ├── grouping columns: k:1!null x:6!null
      │    │    ├── key: (1,6)
      │    │    ├── fd: (1)-->(5), (6)-->(7), (1,6)-->(5,7,11)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 j:5 x:6!null y:7 u:8 v:9 notnull:10
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    │    ├── key: (1,6)
      │    │    │    ├── fd: (1)-->(2,5), (6)-->(7), (8)-->(9), (9)~~>(10), (1,6)-->(8-10)
      │    │    │    ├── inner-join (cross)
      │    │    │    │    ├── columns: k:1!null i:2 j:5 x:6!null y:7
      │    │    │    │    ├── key: (1,6)
      │    │    │    │    ├── fd: (1)-->(2,5), (6)-->(7)
      │    │    │    │    ├── scan a
      │    │    │    │    │    ├── columns: k:1!null i:2 j:5
      │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    └── fd: (1)-->(2,5)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:6!null y:7
      │    │    │    │    │    ├── key: (6)
      │    │    │    │    │    └── fd: (6)-->(7)
      │    │    │    │    └── filters (true)
      │    │    │    ├── project
      │    │    │    │    ├── columns: notnull:10!null u:8!null v:9
      │    │    │    │    ├── key: (8)
      │    │    │    │    ├── fd: (8)-->(9), (9)-->(10)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:8!null v:9
      │    │    │    │    │    ├── key: (8)
      │    │    │    │    │    └── fd: (8)-->(9)
      │    │    │    │    └── projections
      │    │    │    │         └── v:9 IS NOT NULL [as=notnull:10, outer=(9)]
      │    │    │    └── filters
      │    │    │         ├── u:8 = y:7 [outer=(7,8), constraints=(/7: (/NULL - ]; /8: (/NULL - ]), fd=(7)==(8), (8)==(7)]
      │    │    │         ├── v:9 = i:2 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
      │    │    │         └── (x:6 = v:9) IS NOT false [outer=(6,9)]
      │    │    └── aggregations
      │    │         ├── bool-or [as=bool_or:11, outer=(10)]
      │    │         │    └── notnull:10
      │    │         ├── const-agg [as=y:7, outer=(7)]
      │    │         │    └── y:7
      │    │         └── const-agg [as=j:5, outer=(5)]
      │    │              └── j:5
      │    └── projections
      │         └── CASE WHEN bool_or:11 AND (x:6 IS NOT NULL) THEN true WHEN bool_or:11 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=case:12, outer=(6,11)]
      └── filters
           └── case:12 OR (x:6 IS NULL) [outer=(6,12)]


# --------------------------------------------------
# HoistValuesSubquery
# --------------------------------------------------
norm expect=HoistValuesSubquery
SELECT (VALUES ((SELECT i+1 AS r)), (10), ((SELECT k+1 AS s))) FROM a
----
project
 ├── columns: column1:9
 ├── immutable
 ├── ensure-distinct-on
 │    ├── columns: k:1!null column1:8
 │    ├── grouping columns: k:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(8)
 │    ├── inner-join-apply
 │    │    ├── columns: k:1!null i:2 r:6 s:7 column1:8
 │    │    ├── immutable
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── inner-join-apply
 │    │    │    ├── columns: r:6 s:7 column1:8
 │    │    │    ├── outer: (1,2)
 │    │    │    ├── cardinality: [3 - 3]
 │    │    │    ├── immutable
 │    │    │    ├── fd: ()-->(6,7)
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: r:6 s:7
 │    │    │    │    ├── outer: (1,2)
 │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    │    │    │    ├── immutable
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(6,7)
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: r:6
 │    │    │    │    │    ├── outer: (2)
 │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    ├── immutable
 │    │    │    │    │    ├── key: ()
 │    │    │    │    │    ├── fd: ()-->(6)
 │    │    │    │    │    └── (i:2 + 1,)
 │    │    │    │    ├── values
 │    │    │    │    │    ├── columns: s:7
 │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    ├── immutable
 │    │    │    │    │    ├── key: ()
 │    │    │    │    │    ├── fd: ()-->(7)
 │    │    │    │    │    └── (k:1 + 1,)
 │    │    │    │    └── filters (true)
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:8
 │    │    │    │    ├── outer: (6,7)
 │    │    │    │    ├── cardinality: [3 - 3]
 │    │    │    │    ├── (r:6,)
 │    │    │    │    ├── (10,)
 │    │    │    │    └── (s:7,)
 │    │    │    └── filters (true)
 │    │    └── filters (true)
 │    └── aggregations
 │         └── const-agg [as=column1:8, outer=(8)]
 │              └── column1:8
 └── projections
      └── column1:8 [as=column1:9, outer=(8)]

# Exists in values row.
norm expect=HoistValuesSubquery
SELECT (VALUES (EXISTS(SELECT * FROM xy WHERE x=k))) FROM a
----
project
 ├── columns: column1:12
 ├── inner-join-apply
 │    ├── columns: k:1!null column1:8 exists:11!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(8,11)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    ├── inner-join-apply
 │    │    ├── columns: column1:8 exists:11!null
 │    │    ├── outer: (1)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(8,11)
 │    │    ├── project
 │    │    │    ├── columns: exists:11!null
 │    │    │    ├── outer: (1)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(11)
 │    │    │    ├── group-by
 │    │    │    │    ├── columns: true_agg:10
 │    │    │    │    ├── outer: (1)
 │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(10)
 │    │    │    │    ├── left-join (cross)
 │    │    │    │    │    ├── columns: true:9
 │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    │    │    │    │    ├── key: ()
 │    │    │    │    │    ├── fd: ()-->(9)
 │    │    │    │    │    ├── values
 │    │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    └── ()
 │    │    │    │    │    ├── project
 │    │    │    │    │    │    ├── columns: true:9!null
 │    │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    ├── fd: ()-->(9)
 │    │    │    │    │    │    ├── select
 │    │    │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    │    ├── fd: ()-->(6)
 │    │    │    │    │    │    │    ├── scan xy
 │    │    │    │    │    │    │    │    ├── columns: x:6!null
 │    │    │    │    │    │    │    │    └── key: (6)
 │    │    │    │    │    │    │    └── filters
 │    │    │    │    │    │    │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │    │    │    │    │    └── projections
 │    │    │    │    │    │         └── true [as=true:9]
 │    │    │    │    │    └── filters (true)
 │    │    │    │    └── aggregations
 │    │    │    │         └── const-not-null-agg [as=true_agg:10, outer=(9)]
 │    │    │    │              └── true:9
 │    │    │    └── projections
 │    │    │         └── true_agg:10 IS NOT NULL [as=exists:11, outer=(10)]
 │    │    ├── values
 │    │    │    ├── columns: column1:8
 │    │    │    ├── outer: (11)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(8)
 │    │    │    └── (exists:11,)
 │    │    └── filters (true)
 │    └── filters (true)
 └── projections
      └── column1:8 [as=column1:12, outer=(8)]

# Any in values row.
norm expect=HoistValuesSubquery
SELECT (VALUES (5 IN (SELECT y FROM xy WHERE x=k))) FROM a
----
project
 ├── columns: column1:12
 ├── inner-join-apply
 │    ├── columns: k:1!null column1:8 case:11
 │    ├── key: (1)
 │    ├── fd: (1)-->(8,11)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    ├── inner-join-apply
 │    │    ├── columns: column1:8 case:11
 │    │    ├── outer: (1)
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(8,11)
 │    │    ├── project
 │    │    │    ├── columns: case:11
 │    │    │    ├── outer: (1)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(11)
 │    │    │    ├── group-by
 │    │    │    │    ├── columns: bool_or:10
 │    │    │    │    ├── outer: (1)
 │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(10)
 │    │    │    │    ├── left-join (cross)
 │    │    │    │    │    ├── columns: notnull:9
 │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(exactly-one)
 │    │    │    │    │    ├── key: ()
 │    │    │    │    │    ├── fd: ()-->(9)
 │    │    │    │    │    ├── values
 │    │    │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    └── ()
 │    │    │    │    │    ├── project
 │    │    │    │    │    │    ├── columns: notnull:9!null
 │    │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    ├── fd: ()-->(9)
 │    │    │    │    │    │    ├── select
 │    │    │    │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    │    │    │    ├── outer: (1)
 │    │    │    │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    │    │    │    ├── key: ()
 │    │    │    │    │    │    │    ├── fd: ()-->(6,7)
 │    │    │    │    │    │    │    ├── scan xy
 │    │    │    │    │    │    │    │    ├── columns: x:6!null y:7
 │    │    │    │    │    │    │    │    ├── key: (6)
 │    │    │    │    │    │    │    │    └── fd: (6)-->(7)
 │    │    │    │    │    │    │    └── filters
 │    │    │    │    │    │    │         ├── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │    │    │    │    │    │         └── (y:7 = 5) IS NOT false [outer=(7)]
 │    │    │    │    │    │    └── projections
 │    │    │    │    │    │         └── y:7 IS NOT NULL [as=notnull:9, outer=(7)]
 │    │    │    │    │    └── filters (true)
 │    │    │    │    └── aggregations
 │    │    │    │         └── bool-or [as=bool_or:10, outer=(9)]
 │    │    │    │              └── notnull:9
 │    │    │    └── projections
 │    │    │         └── CASE WHEN bool_or:10 THEN true WHEN bool_or:10 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=case:11, outer=(10)]
 │    │    ├── values
 │    │    │    ├── columns: column1:8
 │    │    │    ├── outer: (11)
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    ├── fd: ()-->(8)
 │    │    │    └── (case:11,)
 │    │    └── filters (true)
 │    └── filters (true)
 └── projections
      └── column1:8 [as=column1:12, outer=(8)]

# ---------------------------------------------------
# HoistProjectSetSubquery + TryDecorrelateProjectSet
# ---------------------------------------------------
norm expect=HoistProjectSetSubquery
SELECT generate_series(1, (SELECT v FROM uv WHERE u=x)) FROM xy
----
project
 ├── columns: generate_series:5
 ├── immutable
 └── project-set
      ├── columns: v:4 generate_series:5
      ├── immutable
      ├── project
      │    ├── columns: v:4
      │    └── left-join (hash)
      │         ├── columns: x:1!null u:3 v:4
      │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         ├── key: (1)
      │         ├── fd: (3)-->(4), (1)-->(3,4)
      │         ├── scan xy
      │         │    ├── columns: x:1!null
      │         │    └── key: (1)
      │         ├── scan uv
      │         │    ├── columns: u:3!null v:4
      │         │    ├── key: (3)
      │         │    └── fd: (3)-->(4)
      │         └── filters
      │              └── u:3 = x:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      └── zip
           └── generate_series(1, v:4) [outer=(4), immutable]

# Zip correlation within EXISTS.
norm expect=(HoistProjectSetSubquery,TryDecorrelateSemiJoin,TryDecorrelateProjectSet)
SELECT * FROM xy WHERE EXISTS(SELECT * FROM generate_series(1, (SELECT v FROM uv WHERE u=x)))
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── project-set
 │    ├── columns: x:1!null y:2 v:4 generate_series:5
 │    ├── immutable
 │    ├── fd: (1)-->(2,4)
 │    ├── project
 │    │    ├── columns: x:1!null y:2 v:4
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,4)
 │    │    └── left-join (hash)
 │    │         ├── columns: x:1!null y:2 u:3 v:4
 │    │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         ├── key: (1)
 │    │         ├── fd: (1)-->(2-4), (3)-->(4)
 │    │         ├── scan xy
 │    │         │    ├── columns: x:1!null y:2
 │    │         │    ├── key: (1)
 │    │         │    └── fd: (1)-->(2)
 │    │         ├── scan uv
 │    │         │    ├── columns: u:3!null v:4
 │    │         │    ├── key: (3)
 │    │         │    └── fd: (3)-->(4)
 │    │         └── filters
 │    │              └── u:3 = x:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
 │    └── zip
 │         └── generate_series(1, v:4) [outer=(4), immutable]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Function contains multiple subqueries in arguments.
norm expect=HoistProjectSetSubquery
SELECT generate_series((select y FROM xy WHERE x=k), (SELECT v FROM uv WHERE u=k)) FROM a
----
project
 ├── columns: generate_series:10
 ├── immutable
 └── project-set
      ├── columns: y:7 v:9 generate_series:10
      ├── immutable
      ├── project
      │    ├── columns: y:7 v:9
      │    └── left-join (hash)
      │         ├── columns: k:1!null x:6 y:7 u:8 v:9
      │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         ├── key: (1)
      │         ├── fd: (6)-->(7), (1)-->(6-9), (8)-->(9)
      │         ├── left-join (hash)
      │         │    ├── columns: k:1!null x:6 y:7
      │         │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         │    ├── key: (1)
      │         │    ├── fd: (6)-->(7), (1)-->(6,7)
      │         │    ├── scan a
      │         │    │    ├── columns: k:1!null
      │         │    │    └── key: (1)
      │         │    ├── scan xy
      │         │    │    ├── columns: x:6!null y:7
      │         │    │    ├── key: (6)
      │         │    │    └── fd: (6)-->(7)
      │         │    └── filters
      │         │         └── x:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
      │         ├── scan uv
      │         │    ├── columns: u:8!null v:9
      │         │    ├── key: (8)
      │         │    └── fd: (8)-->(9)
      │         └── filters
      │              └── u:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      └── zip
           └── generate_series(y:7, v:9) [outer=(7,9), immutable]

# Multiple functions.
norm expect=HoistProjectSetSubquery
SELECT
    generate_series(1, (SELECT v FROM uv WHERE u=k)),
    information_schema._pg_expandarray(ARRAY[(SELECT x FROM xy WHERE x=k)])
FROM a
----
project
 ├── columns: generate_series:8 information_schema._pg_expandarray:13
 ├── immutable
 ├── project-set
 │    ├── columns: v:7 generate_series:8 xy.x:9 x:11 n:12
 │    ├── immutable
 │    ├── project
 │    │    ├── columns: v:7 xy.x:9
 │    │    └── left-join (hash)
 │    │         ├── columns: k:1!null u:6 v:7 xy.x:9
 │    │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         ├── key: (1)
 │    │         ├── fd: (6)-->(7), (1)-->(6,7,9)
 │    │         ├── left-join (hash)
 │    │         │    ├── columns: k:1!null u:6 v:7
 │    │         │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         │    ├── key: (1)
 │    │         │    ├── fd: (6)-->(7), (1)-->(6,7)
 │    │         │    ├── scan a
 │    │         │    │    ├── columns: k:1!null
 │    │         │    │    └── key: (1)
 │    │         │    ├── scan uv
 │    │         │    │    ├── columns: u:6!null v:7
 │    │         │    │    ├── key: (6)
 │    │         │    │    └── fd: (6)-->(7)
 │    │         │    └── filters
 │    │         │         └── u:6 = k:1 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]
 │    │         ├── scan xy
 │    │         │    ├── columns: xy.x:9!null
 │    │         │    └── key: (9)
 │    │         └── filters
 │    │              └── xy.x:9 = k:1 [outer=(1,9), constraints=(/1: (/NULL - ]; /9: (/NULL - ]), fd=(1)==(9), (9)==(1)]
 │    └── zip
 │         ├── generate_series(1, v:7) [outer=(7), immutable]
 │         └── information_schema._pg_expandarray(ARRAY[xy.x:9]) [outer=(9), immutable]
 └── projections
      └── ((x:11, n:12) AS x, n) [as=information_schema._pg_expandarray:13, outer=(11,12)]

norm expect=HoistProjectSetSubquery
SELECT a, generate_series(1, (SELECT a)) FROM (VALUES (1)) AS v (a)
----
project
 ├── columns: a:1!null generate_series:3
 ├── immutable
 ├── fd: ()-->(1)
 └── project-set
      ├── columns: column1:1!null a:2 generate_series:3
      ├── immutable
      ├── fd: ()-->(1,2)
      ├── inner-join-apply
      │    ├── columns: column1:1!null a:2
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1,2)
      │    ├── values
      │    │    ├── columns: column1:1!null
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(1)
      │    │    └── (1,)
      │    ├── values
      │    │    ├── columns: a:2
      │    │    ├── outer: (1)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(2)
      │    │    └── (column1:1,)
      │    └── filters (true)
      └── zip
           └── generate_series(1, a:2) [outer=(2), immutable]

norm expect=HoistProjectSetSubquery
SELECT a, generate_series(1, (SELECT a)), generate_series(1, (SELECT a)) FROM (VALUES (1)) AS v (a)
----
project
 ├── columns: a:1!null generate_series:3 generate_series:5
 ├── immutable
 ├── fd: ()-->(1)
 └── project-set
      ├── columns: column1:1!null a:2 generate_series:3 a:4 generate_series:5
      ├── immutable
      ├── fd: ()-->(1,2,4)
      ├── inner-join-apply
      │    ├── columns: column1:1!null a:2 a:4
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1,2,4)
      │    ├── inner-join-apply
      │    │    ├── columns: column1:1!null a:2
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(1,2)
      │    │    ├── values
      │    │    │    ├── columns: column1:1!null
      │    │    │    ├── cardinality: [1 - 1]
      │    │    │    ├── key: ()
      │    │    │    ├── fd: ()-->(1)
      │    │    │    └── (1,)
      │    │    ├── values
      │    │    │    ├── columns: a:2
      │    │    │    ├── outer: (1)
      │    │    │    ├── cardinality: [1 - 1]
      │    │    │    ├── key: ()
      │    │    │    ├── fd: ()-->(2)
      │    │    │    └── (column1:1,)
      │    │    └── filters (true)
      │    ├── values
      │    │    ├── columns: a:4
      │    │    ├── outer: (1)
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(4)
      │    │    └── (column1:1,)
      │    └── filters (true)
      └── zip
           ├── generate_series(1, a:2) [outer=(2), immutable]
           └── generate_series(1, a:4) [outer=(4), immutable]

exec-ddl
CREATE TABLE articles (
  id INT PRIMARY KEY,
  body STRING,
  description STRING,
  title STRING,
  slug STRING,
  tag_list STRING[],
  user_id STRING,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
)
----

# Regression test for #31706.
norm expect=(TryDecorrelateSemiJoin,TryDecorrelateProjectSet)
SELECT a0.id, a0.body, a0.description, a0.title, a0.slug, a0.tag_list, a0.user_id, a0.created_at, a0.updated_at
    FROM articles AS a0
   WHERE EXISTS(SELECT * FROM unnest(a0.tag_list) AS tag WHERE tag = 'dragons')
ORDER BY a0.created_at
   LIMIT 10
  OFFSET 0;
----
limit
 ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 ├── internal-ordering: +8
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-9)
 ├── ordering: +8
 ├── sort
 │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-9)
 │    ├── ordering: +8
 │    ├── limit hint: 10.00
 │    └── group-by
 │         ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │         ├── grouping columns: id:1!null
 │         ├── immutable
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-9)
 │         ├── select
 │         │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 unnest:10!null
 │         │    ├── immutable
 │         │    ├── fd: ()-->(10), (1)-->(2-9)
 │         │    ├── project-set
 │         │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 unnest:10
 │         │    │    ├── immutable
 │         │    │    ├── fd: (1)-->(2-9)
 │         │    │    ├── scan a0
 │         │    │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │         │    │    │    ├── key: (1)
 │         │    │    │    └── fd: (1)-->(2-9)
 │         │    │    └── zip
 │         │    │         └── unnest(tag_list:6) [outer=(6), immutable]
 │         │    └── filters
 │         │         └── unnest:10 = 'dragons' [outer=(10), constraints=(/10: [/'dragons' - /'dragons']; tight), fd=()-->(10)]
 │         └── aggregations
 │              ├── const-agg [as=body:2, outer=(2)]
 │              │    └── body:2
 │              ├── const-agg [as=description:3, outer=(3)]
 │              │    └── description:3
 │              ├── const-agg [as=title:4, outer=(4)]
 │              │    └── title:4
 │              ├── const-agg [as=slug:5, outer=(5)]
 │              │    └── slug:5
 │              ├── const-agg [as=tag_list:6, outer=(6)]
 │              │    └── tag_list:6
 │              ├── const-agg [as=user_id:7, outer=(7)]
 │              │    └── user_id:7
 │              ├── const-agg [as=created_at:8, outer=(8)]
 │              │    └── created_at:8
 │              └── const-agg [as=updated_at:9, outer=(9)]
 │                   └── updated_at:9
 └── 10

# TODO(justin): figure out how to get this to decorrelate again.
norm
SELECT * FROM articles, xy WHERE EXISTS(
  SELECT * FROM ROWS FROM (generate_series(x, id), length(title), upper(title), unnest(tag_list))
)
----
project
 ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:10!null y:11
 ├── immutable
 ├── key: (1,10)
 ├── fd: (1)-->(2-9), (1,10)-->(2-9,11)
 └── select
      ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:10!null y:11 true_agg:17!null
      ├── immutable
      ├── key: (1,10)
      ├── fd: (1)-->(2-9), (1,10)-->(2-9,11,17)
      ├── group-by
      │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:10!null y:11 true_agg:17
      │    ├── grouping columns: id:1!null x:10!null
      │    ├── immutable
      │    ├── key: (1,10)
      │    ├── fd: (1)-->(2-9), (1,10)-->(2-9,11,17)
      │    ├── inner-join-apply
      │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:10!null y:11 true:16
      │    │    ├── immutable
      │    │    ├── fd: (1)-->(2-9), (1,10)-->(11)
      │    │    ├── scan articles
      │    │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-9)
      │    │    ├── left-join-apply
      │    │    │    ├── columns: x:10!null y:11 true:16
      │    │    │    ├── outer: (1,4,6)
      │    │    │    ├── immutable
      │    │    │    ├── fd: (10)-->(11)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:10!null y:11
      │    │    │    │    ├── key: (10)
      │    │    │    │    └── fd: (10)-->(11)
      │    │    │    ├── project
      │    │    │    │    ├── columns: true:16!null
      │    │    │    │    ├── outer: (1,4,6,10)
      │    │    │    │    ├── immutable
      │    │    │    │    ├── fd: ()-->(16)
      │    │    │    │    ├── project-set
      │    │    │    │    │    ├── columns: generate_series:12 length:13 upper:14 unnest:15
      │    │    │    │    │    ├── outer: (1,4,6,10)
      │    │    │    │    │    ├── immutable
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── cardinality: [1 - 1]
      │    │    │    │    │    │    ├── key: ()
      │    │    │    │    │    │    └── ()
      │    │    │    │    │    └── zip
      │    │    │    │    │         ├── generate_series(x:10, id:1) [outer=(1,10), immutable]
      │    │    │    │    │         ├── length(title:4) [outer=(4), immutable]
      │    │    │    │    │         ├── upper(title:4) [outer=(4), immutable]
      │    │    │    │    │         └── unnest(tag_list:6) [outer=(6), immutable]
      │    │    │    │    └── projections
      │    │    │    │         └── true [as=true:16]
      │    │    │    └── filters (true)
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:17, outer=(16)]
      │         │    └── true:16
      │         ├── const-agg [as=y:11, outer=(11)]
      │         │    └── y:11
      │         ├── const-agg [as=body:2, outer=(2)]
      │         │    └── body:2
      │         ├── const-agg [as=description:3, outer=(3)]
      │         │    └── description:3
      │         ├── const-agg [as=title:4, outer=(4)]
      │         │    └── title:4
      │         ├── const-agg [as=slug:5, outer=(5)]
      │         │    └── slug:5
      │         ├── const-agg [as=tag_list:6, outer=(6)]
      │         │    └── tag_list:6
      │         ├── const-agg [as=user_id:7, outer=(7)]
      │         │    └── user_id:7
      │         ├── const-agg [as=created_at:8, outer=(8)]
      │         │    └── created_at:8
      │         └── const-agg [as=updated_at:9, outer=(9)]
      │              └── updated_at:9
      └── filters
           └── true_agg:17 IS NOT NULL [outer=(17), constraints=(/17: (/NULL - ]; tight)]

norm expect=TryDecorrelateProjectSet
SELECT id FROM articles WHERE title = ANY(
  SELECT unnest FROM ROWS FROM (upper(title), unnest(tag_list), generate_series(0,1), lower('ABC'))
)
----
distinct-on
 ├── columns: id:1!null
 ├── grouping columns: id:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: id:1!null title:4!null tag_list:6 upper:10 unnest:11!null generate_series:12 lower:13
      ├── immutable
      ├── fd: (1)-->(4,6), (4)==(11), (11)==(4)
      ├── project-set
      │    ├── columns: id:1!null title:4 tag_list:6 upper:10 unnest:11 generate_series:12 lower:13
      │    ├── immutable
      │    ├── fd: (1)-->(4,6)
      │    ├── scan articles
      │    │    ├── columns: id:1!null title:4 tag_list:6
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(4,6)
      │    └── zip
      │         ├── upper(title:4) [outer=(4), immutable]
      │         ├── unnest(tag_list:6) [outer=(6), immutable]
      │         ├── generate_series(0, 1) [immutable]
      │         └── 'abc'
      └── filters
           └── title:4 = unnest:11 [outer=(4,11), constraints=(/4: (/NULL - ]; /11: (/NULL - ]), fd=(4)==(11), (11)==(4)]

# --------------------------------------------------
# NormalizeSelectAnyFilter + NormalizeJoinAnyFilter
# --------------------------------------------------
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE i IN (SELECT y FROM xy)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    └── columns: y:7
 └── filters
      └── i:2 = y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Any is one of several conjuncts.
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE k=10 AND i < ANY(SELECT y FROM xy) AND s='foo'
----
semi-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4!null j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4!null j:5
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── k:1 = 10 [outer=(1), constraints=(/1: [/10 - /10]; tight), fd=()-->(1)]
 │         └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 ├── scan xy
 │    └── columns: y:7
 └── filters
      └── i:2 < y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

# Multiple ANY conjuncts.
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE i < ANY(SELECT y FROM xy) AND s = ANY(SELECT y::string FROM xy)
----
semi-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:10
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:9
 │    │    └── projections
 │    │         └── xy.y:9::STRING [as=y:10, outer=(9), immutable]
 │    └── filters
 │         └── s:4 = y:10 [outer=(4,10), constraints=(/4: (/NULL - ]; /10: (/NULL - ]), fd=(4)==(10), (10)==(4)]
 ├── scan xy
 │    └── columns: xy.y:7
 └── filters
      └── i:2 < xy.y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ])]

# Don't hoist uncorrelated ANY (but rewrite it to EXISTS).
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE 5 IN (SELECT y FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: y:7!null
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(7)
                ├── select
                │    ├── columns: y:7!null
                │    ├── fd: ()-->(7)
                │    ├── limit hint: 1.00
                │    ├── scan xy
                │    │    ├── columns: y:7
                │    │    └── limit hint: 100.00
                │    └── filters
                │         └── y:7 = 5 [outer=(7), constraints=(/7: [/5 - /5]; tight), fd=()-->(7)]
                └── 1

# ANY in Join On condition.
norm expect=NormalizeJoinAnyFilter
SELECT * FROM a INNER JOIN xy ON i IN (SELECT v FROM uv) AND k=x
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null y:7
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan uv
 │    │    └── columns: v:9
 │    └── filters
 │         └── i:2 = v:9 [outer=(2,9), constraints=(/2: (/NULL - ]; /9: (/NULL - ]), fd=(2)==(9), (9)==(2)]
 ├── scan xy
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# NormalizeSelectNotAnyFilter + NormalizeJoinNotAnyFilter
# --------------------------------------------------
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE i NOT IN (SELECT y FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    └── columns: y:7
 └── filters
      └── (i:2 = y:7) IS NOT false [outer=(2,7)]

# NOT ANY is one of several conjuncts. Note that i > ALL(...) gets mapped to
# NOT i <= ANY(...) by optbuilder.
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE k > 1 AND k < 5 AND i > ALL(SELECT y FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 3]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── (k:1 > 1) AND (k:1 < 5) [outer=(1), constraints=(/1: [/2 - /4]; tight)]
 ├── scan xy
 │    └── columns: y:7
 └── filters
      └── (i:2 <= y:7) IS NOT false [outer=(2,7)]

# Multiple NOT ANY conjuncts.
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE i < ALL(SELECT y FROM xy) AND s <> ALL(SELECT y::string FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:10
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:9
 │    │    └── projections
 │    │         └── xy.y:9::STRING [as=y:10, outer=(9), immutable]
 │    └── filters
 │         └── (s:4 = y:10) IS NOT false [outer=(4,10)]
 ├── scan xy
 │    └── columns: xy.y:7
 └── filters
      └── (i:2 >= xy.y:7) IS NOT false [outer=(2,7)]

# Don't hoist uncorrelated NOT ANY (but rewrite it to NOT EXISTS).
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE 5 NOT IN (SELECT y FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── not [subquery]
           └── exists
                └── limit
                     ├── columns: y:7
                     ├── cardinality: [0 - 1]
                     ├── key: ()
                     ├── fd: ()-->(7)
                     ├── select
                     │    ├── columns: y:7
                     │    ├── limit hint: 1.00
                     │    ├── scan xy
                     │    │    ├── columns: y:7
                     │    │    └── limit hint: 3.00
                     │    └── filters
                     │         └── (y:7 = 5) IS NOT false [outer=(7)]
                     └── 1

# NOT ANY in Join On condition.
norm expect=NormalizeJoinNotAnyFilter
SELECT * FROM a INNER JOIN xy ON i NOT IN (SELECT v FROM uv) AND k=x
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5 x:6!null y:7
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (6)
 ├── fd: (1)-->(2-5), (6)-->(7), (1)==(6), (6)==(1)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan uv
 │    │    └── columns: v:9
 │    └── filters
 │         └── (i:2 = v:9) IS NOT false [outer=(2,9)]
 ├── scan xy
 │    ├── columns: x:6!null y:7
 │    ├── key: (6)
 │    └── fd: (6)-->(7)
 └── filters
      └── k:1 = x:6 [outer=(1,6), constraints=(/1: (/NULL - ]; /6: (/NULL - ]), fd=(1)==(6), (6)==(1)]

# --------------------------------------------------
# NormalizeSelectAnyFilter + NormalizeSelectNotAnyFilter
# --------------------------------------------------
norm expect=(NormalizeSelectAnyFilter,NormalizeSelectNotAnyFilter)
SELECT * FROM a WHERE i = ANY(SELECT y FROM xy) AND s <> ALL(SELECT y::string FROM xy)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:10
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:9
 │    │    └── projections
 │    │         └── xy.y:9::STRING [as=y:10, outer=(9), immutable]
 │    └── filters
 │         └── (s:4 = y:10) IS NOT false [outer=(4,10)]
 ├── scan xy
 │    └── columns: xy.y:7
 └── filters
      └── i:2 = xy.y:7 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# --------------------------------------------------
# EnsureKey
# --------------------------------------------------

# Check that when the EnsureKey function is called on a Scan that has pruned its
# key away, it creates a new Scan with the primary key added back rather than
# introducing an ordinality operator.
#
# In this test case, the key column of a is pruned away from the Scan, but when
# TryDecorrelateLimitOne calls EnsureKey on the Scan, the key is added back.
norm
SELECT (SELECT x FROM xy WHERE y=i LIMIT 1) FROM a
----
project
 ├── columns: x:8
 ├── distinct-on
 │    ├── columns: k:1!null xy.x:6
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(6)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 xy.x:6 y:7
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2), (6)-->(7)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:6!null y:7
 │    │    │    ├── key: (6)
 │    │    │    └── fd: (6)-->(7)
 │    │    └── filters
 │    │         └── y:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:6, outer=(6)]
 │              └── xy.x:6
 └── projections
      └── xy.x:6 [as=x:8, outer=(6)]

# Case where EnsureKey retrieves an implicit key to add to the Scan.
norm
SELECT (SELECT x FROM xy WHERE y=b LIMIT 1) FROM ab
----
project
 ├── columns: x:6
 ├── distinct-on
 │    ├── columns: rowid:3!null xy.x:4
 │    ├── grouping columns: rowid:3!null
 │    ├── key: (3)
 │    ├── fd: (3)-->(4)
 │    ├── left-join (hash)
 │    │    ├── columns: b:2 rowid:3!null xy.x:4 y:5
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── key: (3,4)
 │    │    ├── fd: (3)-->(2), (4)-->(5)
 │    │    ├── scan ab
 │    │    │    ├── columns: b:2 rowid:3!null
 │    │    │    ├── key: (3)
 │    │    │    └── fd: (3)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:4!null y:5
 │    │    │    ├── key: (4)
 │    │    │    └── fd: (4)-->(5)
 │    │    └── filters
 │    │         └── y:5 = b:2 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:4, outer=(4)]
 │              └── xy.x:4
 └── projections
      └── xy.x:4 [as=x:6, outer=(4)]

# EnsureKey should construct an Ordinality operator when it is called on a Scan
# over a virtual table.
norm
SELECT (SELECT x FROM xy WHERE y=version LIMIT 1) FROM information_schema.tables
----
project
 ├── columns: x:10
 ├── distinct-on
 │    ├── columns: xy.x:8 rownum:11!null
 │    ├── grouping columns: rownum:11!null
 │    ├── key: (11)
 │    ├── fd: (11)-->(8)
 │    ├── left-join (hash)
 │    │    ├── columns: version:7 xy.x:8 y:9 rownum:11!null
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    ├── key: (8,11)
 │    │    ├── fd: (11)-->(7), (8)-->(9)
 │    │    ├── ordinality
 │    │    │    ├── columns: version:7 rownum:11!null
 │    │    │    ├── key: (11)
 │    │    │    ├── fd: (11)-->(7)
 │    │    │    └── scan information_schema.tables
 │    │    │         └── columns: version:7
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:8!null y:9
 │    │    │    ├── key: (8)
 │    │    │    └── fd: (8)-->(9)
 │    │    └── filters
 │    │         └── y:9 = version:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:8, outer=(8)]
 │              └── xy.x:8
 └── projections
      └── xy.x:8 [as=x:10, outer=(8)]
