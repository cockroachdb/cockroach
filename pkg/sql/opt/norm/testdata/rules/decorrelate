exec-ddl
CREATE TABLE a (k INT PRIMARY KEY, i INT, f FLOAT, s STRING, j JSON)
----

exec-ddl
CREATE TABLE xy (x INT PRIMARY KEY, y INT)
----

exec-ddl
CREATE TABLE uv (u INT PRIMARY KEY, v INT)
----

exec-ddl
CREATE TABLE cd (c INT PRIMARY KEY, d INT NOT NULL)
----

exec-ddl
CREATE TABLE ab (a INT, b INT)
----

# --------------------------------------------------
# DecorrelateJoin
# --------------------------------------------------
norm expect=DecorrelateJoin
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

norm expect=DecorrelateJoin
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Decorrelate UPDATE statement.
norm expect=DecorrelateJoin
UPDATE xy SET (x, y)=(SELECT * FROM uv WHERE u=x)
----
update xy
 ├── columns: <none>
 ├── fetch columns: x:4 y:5
 ├── update-mapping:
 │    ├── u:7 => x:1
 │    └── v:8 => y:2
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── left-join (hash)
      ├── columns: x:4!null y:5 u:7 v:8
      ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      ├── key: (4)
      ├── fd: (4)-->(5,7,8), (7)-->(8)
      ├── scan xy
      │    ├── columns: x:4!null y:5
      │    ├── key: (4)
      │    └── fd: (4)-->(5)
      ├── scan uv
      │    ├── columns: u:7!null v:8
      │    ├── key: (7)
      │    └── fd: (7)-->(8)
      └── filters
           └── u:7 = x:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# Decorrelate INSERT..ON CONFLICT statement.
norm expect=DecorrelateJoin
INSERT INTO xy VALUES (1,2), (3,4)
ON CONFLICT (x) DO UPDATE SET (x, y)=(SELECT * FROM uv WHERE u=excluded.x)
RETURNING *
----
upsert xy
 ├── columns: x:1!null y:2
 ├── arbiter indexes: primary
 ├── canary column: x:6
 ├── fetch columns: x:6 y:7
 ├── insert-mapping:
 │    ├── column1:4 => x:1
 │    └── column2:5 => y:2
 ├── update-mapping:
 │    ├── upsert_x:12 => x:1
 │    └── upsert_y:13 => y:2
 ├── return-mapping:
 │    ├── upsert_x:12 => x:1
 │    └── upsert_y:13 => y:2
 ├── cardinality: [2 - 2]
 ├── volatile, mutations
 └── project
      ├── columns: upsert_x:12 upsert_y:13 column1:4!null column2:5!null x:6 y:7
      ├── cardinality: [2 - 2]
      ├── fd: (6)-->(7)
      ├── left-join (hash)
      │    ├── columns: column1:4!null column2:5!null x:6 y:7 u:9 v:10
      │    ├── cardinality: [2 - 2]
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── fd: (6)-->(7), (9)-->(10)
      │    ├── left-join (hash)
      │    │    ├── columns: column1:4!null column2:5!null x:6 y:7
      │    │    ├── cardinality: [2 - 2]
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    ├── fd: (6)-->(7)
      │    │    ├── values
      │    │    │    ├── columns: column1:4!null column2:5!null
      │    │    │    ├── cardinality: [2 - 2]
      │    │    │    ├── (1, 2)
      │    │    │    └── (3, 4)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:6!null y:7
      │    │    │    ├── key: (6)
      │    │    │    └── fd: (6)-->(7)
      │    │    └── filters
      │    │         └── column1:4 = x:6 [outer=(4,6), constraints=(/4: (/NULL - ]; /6: (/NULL - ]), fd=(4)==(6), (6)==(4)]
      │    ├── scan uv
      │    │    ├── columns: u:9!null v:10
      │    │    ├── key: (9)
      │    │    └── fd: (9)-->(10)
      │    └── filters
      │         └── u:9 = column1:4 [outer=(4,9), constraints=(/4: (/NULL - ]; /9: (/NULL - ]), fd=(4)==(9), (9)==(4)]
      └── projections
           ├── CASE WHEN x:6 IS NULL THEN column1:4 ELSE u:9 END [as=upsert_x:12, outer=(4,6,9)]
           └── CASE WHEN x:6 IS NULL THEN column2:5 ELSE v:10 END [as=upsert_y:13, outer=(5,6,10)]

# Decorrelate DELETE statement.
norm expect=DecorrelateJoin
DELETE FROM xy WHERE EXISTS(SELECT * FROM uv WHERE u=x)
----
delete xy
 ├── columns: <none>
 ├── fetch columns: x:4
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── semi-join (hash)
      ├── columns: x:4!null
      ├── key: (4)
      ├── scan xy
      │    ├── columns: x:4!null
      │    └── key: (4)
      ├── scan uv
      │    ├── columns: u:7!null
      │    └── key: (7)
      └── filters
           └── u:7 = x:4 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]

# --------------------------------------------------
# DecorrelateProjectSet
# --------------------------------------------------

norm expect=DecorrelateProjectSet
SELECT generate_series(0, 5) FROM xy
----
inner-join (cross)
 ├── columns: generate_series:4
 ├── immutable
 ├── scan xy
 ├── project-set
 │    ├── columns: generate_series:4
 │    ├── immutable
 │    ├── values
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    └── ()
 │    └── zip
 │         └── generate_series(0, 5) [immutable]
 └── filters (true)

norm expect=DecorrelateProjectSet
SELECT * FROM a WHERE i IN (SELECT generate_series(k, i) FROM xy)
----
semi-join-apply
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── inner-join (cross)
 │    ├── columns: generate_series:10
 │    ├── outer: (1,2)
 │    ├── immutable
 │    ├── scan xy
 │    ├── project-set
 │    │    ├── columns: generate_series:10
 │    │    ├── outer: (1,2)
 │    │    ├── immutable
 │    │    ├── values
 │    │    │    ├── cardinality: [1 - 1]
 │    │    │    ├── key: ()
 │    │    │    └── ()
 │    │    └── zip
 │    │         └── generate_series(k:1, i:2) [outer=(1,2), immutable]
 │    └── filters (true)
 └── filters
      └── i:2 = generate_series:10 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]

norm expect=DecorrelateProjectSet
SELECT generate_series(0, (SELECT generate_series(1,0) FROM xy)) FROM uv
----
inner-join (cross)
 ├── columns: generate_series:8
 ├── immutable
 ├── scan uv
 ├── project-set
 │    ├── columns: generate_series:8
 │    ├── immutable
 │    ├── values
 │    │    ├── cardinality: [1 - 1]
 │    │    ├── key: ()
 │    │    └── ()
 │    └── zip
 │         └── function: generate_series [immutable, subquery]
 │              ├── 0
 │              └── subquery
 │                   └── max1-row
 │                        ├── columns: generate_series:7
 │                        ├── error: "more than one row returned by a subquery used as an expression"
 │                        ├── cardinality: [0 - 1]
 │                        ├── immutable
 │                        ├── key: ()
 │                        ├── fd: ()-->(7)
 │                        └── inner-join (cross)
 │                             ├── columns: generate_series:7
 │                             ├── immutable
 │                             ├── scan xy
 │                             ├── project-set
 │                             │    ├── columns: generate_series:7
 │                             │    ├── immutable
 │                             │    ├── values
 │                             │    │    ├── cardinality: [1 - 1]
 │                             │    │    ├── key: ()
 │                             │    │    └── ()
 │                             │    └── zip
 │                             │         └── generate_series(1, 0) [immutable]
 │                             └── filters (true)
 └── filters (true)

# --------------------------------------------------
# TryDecorrelateWindow
# --------------------------------------------------

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT rank() OVER (), i FROM (SELECT * FROM a WHERE k = u))
WHERE i = 3
----
project
 ├── columns: u:1!null v:2 rank:10 i:5!null
 ├── key: (1,10)
 ├── fd: ()-->(5), (1)-->(2)
 └── window partition=(1)
      ├── columns: u:1!null v:2 k:4!null i:5!null rank:10
      ├── key: (4)
      ├── fd: ()-->(5), (1)-->(2), (1)==(4), (4)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 k:4!null i:5!null
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    ├── key: (4)
      │    ├── fd: ()-->(5), (1)-->(2), (1)==(4), (4)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── select
      │    │    ├── columns: k:4!null i:5!null
      │    │    ├── key: (4)
      │    │    ├── fd: ()-->(5)
      │    │    ├── scan a
      │    │    │    ├── columns: k:4!null i:5
      │    │    │    ├── key: (4)
      │    │    │    └── fd: (4)-->(5)
      │    │    └── filters
      │    │         └── i:5 = 3 [outer=(5), constraints=(/5: [/3 - /3]; tight), fd=()-->(5)]
      │    └── filters
      │         └── k:4 = u:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      └── windows
           └── rank [as=rank:10]

# TryDecorrelateWindow will trigger twice here: first to pull the window above
# the non-apply join, and then again the pull it above the apply join.
norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (
        SELECT
            *
        FROM
            (SELECT x FROM xy) CROSS JOIN (SELECT ntile(u) OVER (), i FROM a)
    )
WHERE
    i = 3
----
project
 ├── columns: u:1!null v:2 x:4!null ntile:13 i:8!null
 ├── fd: ()-->(8), (1)-->(2)
 └── select
      ├── columns: u:1!null v:2 x:4!null i:8!null ntile:13 ntile_1_arg1:14!null
      ├── fd: ()-->(8), (1)-->(2), (1)==(14), (14)==(1)
      ├── window partition=(1,4)
      │    ├── columns: u:1!null v:2 x:4!null i:8 ntile:13 ntile_1_arg1:14!null
      │    ├── fd: (1)-->(2), (1)==(14), (14)==(1)
      │    ├── project
      │    │    ├── columns: ntile_1_arg1:14!null u:1!null v:2 x:4!null i:8
      │    │    ├── fd: (1)-->(2), (1)==(14), (14)==(1)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: u:1!null v:2 x:4!null i:8
      │    │    │    ├── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:1!null v:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── inner-join (cross)
      │    │    │    │    ├── columns: x:4!null i:8
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:4!null
      │    │    │    │    │    └── key: (4)
      │    │    │    │    ├── scan a
      │    │    │    │    │    └── columns: i:8
      │    │    │    │    └── filters (true)
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         └── u:1 [as=ntile_1_arg1:14, outer=(1)]
      │    └── windows
      │         └── ntile [as=ntile:13, outer=(14)]
      │              └── ntile_1_arg1:14
      └── filters
           └── i:8 = 3 [outer=(8), constraints=(/8: [/3 - /3]; tight), fd=()-->(8)]

# If the LHS has no key, we need to add one, or else identical rows would end up in the same
# partition.

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null row_number:8 i:3
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(3)
 └── window partition=(9)
      ├── columns: column1:1!null k:2!null i:3 row_number:8 rownum:9!null
      ├── cardinality: [0 - 3]
      ├── key: (9)
      ├── fd: (9)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      ├── inner-join (hash)
      │    ├── columns: column1:1!null k:2!null i:3 rownum:9!null
      │    ├── cardinality: [0 - 3]
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    ├── key: (9)
      │    ├── fd: (9)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      │    ├── ordinality
      │    │    ├── columns: column1:1!null rownum:9!null
      │    │    ├── cardinality: [3 - 3]
      │    │    ├── key: (9)
      │    │    ├── fd: (9)-->(1)
      │    │    └── values
      │    │         ├── columns: column1:1!null
      │    │         ├── cardinality: [3 - 3]
      │    │         ├── (1,)
      │    │         ├── (1,)
      │    │         └── (1,)
      │    ├── scan a
      │    │    ├── columns: k:2!null i:3
      │    │    ├── key: (2)
      │    │    └── fd: (2)-->(3)
      │    └── filters
      │         └── k:2 = column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      └── windows
           └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (ORDER BY i), i FROM (SELECT * FROM a WHERE x > 3))
----
project
 ├── columns: x:1!null row_number:8 i:3
 └── window partition=(9) ordering=+3 opt(1,9)
      ├── columns: column1:1!null i:3 row_number:8 rownum:9!null
      ├── fd: (9)-->(1)
      ├── inner-join (cross)
      │    ├── columns: column1:1!null i:3 rownum:9!null
      │    ├── fd: (9)-->(1)
      │    ├── select
      │    │    ├── columns: column1:1!null rownum:9!null
      │    │    ├── cardinality: [0 - 3]
      │    │    ├── key: (9)
      │    │    ├── fd: (9)-->(1)
      │    │    ├── ordinality
      │    │    │    ├── columns: column1:1!null rownum:9!null
      │    │    │    ├── cardinality: [3 - 3]
      │    │    │    ├── key: (9)
      │    │    │    ├── fd: (9)-->(1)
      │    │    │    └── values
      │    │    │         ├── columns: column1:1!null
      │    │    │         ├── cardinality: [3 - 3]
      │    │    │         ├── (1,)
      │    │    │         ├── (1,)
      │    │    │         └── (1,)
      │    │    └── filters
      │    │         └── column1:1 > 3 [outer=(1), constraints=(/1: [/4 - ]; tight)]
      │    ├── scan a
      │    │    └── columns: i:3
      │    └── filters (true)
      └── windows
           └── row-number [as=row_number:8]

# In this example, we introduce a key called rownum, and after TryDecorrelateWindow triggers
# PARTITION BY x becomes PARTITION BY x, rownum. Then later, ReduceWindowPartitionCols triggers,
# recognizing that rownum determines x.

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1), (1), (1)) AS v (x),
    LATERAL (SELECT row_number() OVER (PARTITION BY x), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null row_number:8 i:3
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(3)
 └── window partition=(10)
      ├── columns: column1:1!null i:3 row_number:8 rownum:10!null
      ├── cardinality: [0 - 3]
      ├── key: (10)
      ├── fd: (10)-->(1), (1)-->(3)
      ├── project
      │    ├── columns: column1:1!null i:3 rownum:10!null
      │    ├── cardinality: [0 - 3]
      │    ├── key: (10)
      │    ├── fd: (10)-->(1), (1)-->(3)
      │    └── inner-join (hash)
      │         ├── columns: column1:1!null k:2!null i:3 rownum:10!null
      │         ├── cardinality: [0 - 3]
      │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │         ├── key: (10)
      │         ├── fd: (10)-->(1), (2)-->(3), (1)==(2), (2)==(1)
      │         ├── ordinality
      │         │    ├── columns: column1:1!null rownum:10!null
      │         │    ├── cardinality: [3 - 3]
      │         │    ├── key: (10)
      │         │    ├── fd: (10)-->(1)
      │         │    └── values
      │         │         ├── columns: column1:1!null
      │         │         ├── cardinality: [3 - 3]
      │         │         ├── (1,)
      │         │         ├── (1,)
      │         │         └── (1,)
      │         ├── scan a
      │         │    ├── columns: k:2!null i:3
      │         │    ├── key: (2)
      │         │    └── fd: (2)-->(3)
      │         └── filters
      │              └── k:2 = column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ]), fd=(1)==(2), (2)==(1)]
      └── windows
           └── row-number [as=row_number:8]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    (VALUES (1, 2), (1, 3), (1, 4)) AS v (x, y),
    LATERAL (SELECT row_number() OVER (PARTITION BY x ORDER BY y), i FROM (SELECT * FROM a WHERE k = x))
----
project
 ├── columns: x:1!null y:2!null row_number:9 i:4
 ├── cardinality: [0 - 3]
 ├── fd: (1)-->(4)
 └── window partition=(12)
      ├── columns: column1:1!null column2:2!null i:4 row_number:9 rownum:12!null
      ├── cardinality: [0 - 3]
      ├── key: (12)
      ├── fd: (12)-->(1,2), (1)-->(4)
      ├── project
      │    ├── columns: column1:1!null column2:2!null i:4 rownum:12!null
      │    ├── cardinality: [0 - 3]
      │    ├── key: (12)
      │    ├── fd: (12)-->(1,2), (1)-->(4)
      │    └── inner-join (hash)
      │         ├── columns: column1:1!null column2:2!null k:3!null i:4 rownum:12!null
      │         ├── cardinality: [0 - 3]
      │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │         ├── key: (12)
      │         ├── fd: (12)-->(1,2), (3)-->(4), (1)==(3), (3)==(1)
      │         ├── ordinality
      │         │    ├── columns: column1:1!null column2:2!null rownum:12!null
      │         │    ├── cardinality: [3 - 3]
      │         │    ├── key: (12)
      │         │    ├── fd: (12)-->(1,2)
      │         │    └── values
      │         │         ├── columns: column1:1!null column2:2!null
      │         │         ├── cardinality: [3 - 3]
      │         │         ├── (1, 2)
      │         │         ├── (1, 3)
      │         │         └── (1, 4)
      │         ├── scan a
      │         │    ├── columns: k:3!null i:4
      │         │    ├── key: (3)
      │         │    └── fd: (3)-->(4)
      │         └── filters
      │              └── k:3 = column1:1 [outer=(1,3), constraints=(/1: (/NULL - ]; /3: (/NULL - ]), fd=(1)==(3), (3)==(1)]
      └── windows
           └── row-number [as=row_number:9]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY u), i FROM (SELECT * FROM a WHERE k = u))
----
window partition=(1)
 ├── columns: u:1!null v:2 row_number:10 i:5
 ├── key: (1)
 ├── fd: (1)-->(2,5)
 ├── project
 │    ├── columns: u:1!null v:2 i:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,5)
 │    └── inner-join (hash)
 │         ├── columns: u:1!null v:2 k:4!null i:5
 │         ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │         ├── key: (4)
 │         ├── fd: (1)-->(2), (4)-->(5), (1)==(4), (4)==(1)
 │         ├── scan uv
 │         │    ├── columns: u:1!null v:2
 │         │    ├── key: (1)
 │         │    └── fd: (1)-->(2)
 │         ├── scan a
 │         │    ├── columns: k:4!null i:5
 │         │    ├── key: (4)
 │         │    └── fd: (4)-->(5)
 │         └── filters
 │              └── k:4 = u:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
 └── windows
      └── row-number [as=row_number:10]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY s), i FROM (SELECT * FROM a WHERE k = u))
----
project
 ├── columns: u:1!null v:2 row_number:10 i:5
 ├── key: (1,10)
 ├── fd: (1)-->(2,5)
 └── window partition=(1)
      ├── columns: u:1!null v:2 k:4!null i:5 row_number:10
      ├── key: (4)
      ├── fd: (1)-->(2), (4)-->(5), (1)==(4), (4)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 k:4!null i:5
      │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    ├── key: (4)
      │    ├── fd: (1)-->(2), (4)-->(5), (1)==(4), (4)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── scan a
      │    │    ├── columns: k:4!null i:5
      │    │    ├── key: (4)
      │    │    └── fd: (4)-->(5)
      │    └── filters
      │         └── k:4 = u:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      └── windows
           └── row-number [as=row_number:10]

norm expect=TryDecorrelateWindow
SELECT
    *
FROM
    uv,
    LATERAL (SELECT row_number() OVER (PARTITION BY s), i FROM (SELECT * FROM a WHERE i = u))
----
project
 ├── columns: u:1!null v:2 row_number:10 i:5!null
 ├── fd: (1)-->(2), (1)==(5), (5)==(1)
 └── window partition=(1,7)
      ├── columns: u:1!null v:2 i:5!null s:7 row_number:10
      ├── fd: (1)-->(2), (1)==(5), (5)==(1)
      ├── inner-join (hash)
      │    ├── columns: u:1!null v:2 i:5!null s:7
      │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    ├── fd: (1)-->(2), (1)==(5), (5)==(1)
      │    ├── scan uv
      │    │    ├── columns: u:1!null v:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    ├── scan a
      │    │    └── columns: i:5 s:7
      │    └── filters
      │         └── i:5 = u:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      └── windows
           └── row-number [as=row_number:10]

norm expect=TryDecorrelateWindow
SELECT * FROM uv, LATERAL (SELECT avg(f) FILTER (WHERE u = 3) OVER (), i FROM a)
----
project
 ├── columns: u:1!null v:2 avg:10 i:5
 ├── fd: (1)-->(2)
 └── window partition=(1)
      ├── columns: u:1!null v:2 i:5 f:6 avg:10 avg_1_filter:11!null
      ├── fd: (1)-->(2,11)
      ├── project
      │    ├── columns: avg_1_filter:11!null u:1!null v:2 i:5 f:6
      │    ├── fd: (1)-->(2,11)
      │    ├── inner-join (cross)
      │    │    ├── columns: u:1!null v:2 i:5 f:6
      │    │    ├── fd: (1)-->(2)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:1!null v:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan a
      │    │    │    └── columns: i:5 f:6
      │    │    └── filters (true)
      │    └── projections
      │         └── u:1 = 3 [as=avg_1_filter:11, outer=(1)]
      └── windows
           └── agg-filter [as=avg:10, outer=(6,11)]
                ├── avg
                │    └── f:6
                └── avg_1_filter:11

# --------------------------------------------------
# TryDecorrelateSelect
# --------------------------------------------------
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE EXISTS(SELECT * FROM (VALUES (k), (i)) WHERE column1=k)
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── values
 │    ├── columns: column1:7
 │    ├── outer: (1,2)
 │    ├── cardinality: [2 - 2]
 │    ├── (k:1,)
 │    └── (i:2,)
 └── filters
      └── column1:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM (VALUES (k), (i)) WHERE column1=k)
----
anti-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── values
 │    ├── columns: column1:7
 │    ├── outer: (1,2)
 │    ├── cardinality: [2 - 2]
 │    ├── (k:1,)
 │    └── (i:2,)
 └── filters
      └── column1:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Attempt to decorrelate query by pulling up outer select. But since limit query
# cannot be decorrelated, push the outer select back down again (and make sure
# potential rule cycle is detected and handled).
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE EXISTS(SELECT * FROM (SELECT * FROM xy WHERE y=k LIMIT 1) WHERE y=10)
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: y:8!null
 │    ├── outer: (1)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(8)
 │    ├── select
 │    │    ├── columns: y:8!null
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(8)
 │    │    ├── limit hint: 1.00
 │    │    ├── scan xy
 │    │    │    ├── columns: y:8
 │    │    │    └── limit hint: 1.01
 │    │    └── filters
 │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── 1
 └── filters
      └── y:8 = 10 [outer=(8), constraints=(/8: [/10 - /10]; tight), fd=()-->(8)]

# Same as previous, but using anti-join.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM (SELECT * FROM xy WHERE y=k LIMIT 1) WHERE y=10)
----
anti-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── limit
 │    ├── columns: y:8!null
 │    ├── outer: (1)
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(8)
 │    ├── select
 │    │    ├── columns: y:8!null
 │    │    ├── outer: (1)
 │    │    ├── fd: ()-->(8)
 │    │    ├── limit hint: 1.00
 │    │    ├── scan xy
 │    │    │    ├── columns: y:8
 │    │    │    └── limit hint: 1.01
 │    │    └── filters
 │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── 1
 └── filters
      └── y:8 = 10 [outer=(8), constraints=(/8: [/10 - /10]; tight), fd=()-->(8)]

# Decorrelate Select with reference to outer column and no limit.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE (SELECT x FROM xy WHERE x=i) > 100
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── key: (1)
      ├── fd: (1)-->(2-5), (2)==(7), (7)==(2)
      ├── select
      │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2-5)
      │    └── filters
      │         └── i:2 > 100 [outer=(2), constraints=(/2: [/101 - ]; tight)]
      ├── select
      │    ├── columns: x:7!null
      │    ├── key: (7)
      │    ├── scan xy
      │    │    ├── columns: x:7!null
      │    │    └── key: (7)
      │    └── filters
      │         └── x:7 > 100 [outer=(7), constraints=(/7: [/101 - ]; tight)]
      └── filters
           └── x:7 = i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]

# Decorrelate Select with LeftJoinApply.
norm expect=TryDecorrelateSelect
SELECT * FROM a WHERE (SELECT x FROM (SELECT * FROM xy LIMIT 1) WHERE k=x) > 100
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null
      ├── cardinality: [0 - 1]
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      ├── key: ()
      ├── fd: ()-->(1-5,7), (7)==(1), (1)==(7)
      ├── select
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5)
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2-5)
      │    └── filters
      │         └── k:1 > 100 [outer=(1), constraints=(/1: [/101 - ]; tight)]
      ├── select
      │    ├── columns: x:7!null
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(7)
      │    ├── limit
      │    │    ├── columns: x:7!null
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(7)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:7!null
      │    │    │    ├── key: (7)
      │    │    │    └── limit hint: 1.00
      │    │    └── 1
      │    └── filters
      │         └── x:7 > 100 [outer=(7), constraints=(/7: [/101 - ]; tight)]
      └── filters
           └── k:1 = x:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Decorrelate with non-apply operator because of multi-level nesting.
norm expect=TryDecorrelateSelect
SELECT *
FROM a
WHERE EXISTS(SELECT * FROM xy WHERE x=k AND EXISTS(SELECT * FROM uv WHERE u=10 AND s='foo'))
----
semi-join-apply
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── semi-join (cross)
 │    ├── columns: x:7!null
 │    ├── outer: (4)
 │    ├── key: (7)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── select
 │    │    ├── columns: u:10!null
 │    │    ├── cardinality: [0 - 1]
 │    │    ├── key: ()
 │    │    ├── fd: ()-->(10)
 │    │    ├── scan uv
 │    │    │    ├── columns: u:10!null
 │    │    │    └── key: (10)
 │    │    └── filters
 │    │         └── u:10 = 10 [outer=(10), constraints=(/10: [/10 - /10]; tight), fd=()-->(10)]
 │    └── filters
 │         └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# --------------------------------------------------
# TryDecorrelateProject +
# TryDecorrelateProjectSelect +
# TryDecorrelateScalarGroupBy
#
# Start with some shared test cases that exercise multiple
# decorrelation rules.
# --------------------------------------------------

# Left join caused by correlated ANY clause.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT 5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:10
 ├── group-by
 │    ├── columns: k:1!null bool_or:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 notnull:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (7)-->(11), (1)-->(7,11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: notnull:11!null x:7!null
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(11)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    ├── fd: (7)-->(8)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    │    ├── key: (7)
 │    │    │    │    │    └── fd: (7)-->(8)
 │    │    │    │    └── filters
 │    │    │    │         └── (y:8 = 5) IS NOT false [outer=(8)]
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:11, outer=(8)]
 │    │    └── filters
 │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:12, outer=(11)]
 │              └── notnull:11
 └── projections
      └── CASE WHEN bool_or:12 THEN true WHEN bool_or:12 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(12)]

# Left join caused by zero or one cardinality subquery.
norm expect=TryDecorrelateProjectSelect
SELECT * FROM a WHERE (SELECT y+1 AS r FROM (SELECT * FROM xy LIMIT 1) WHERE x=k) > 10
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── inner-join (hash)
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null y:8!null
      ├── cardinality: [0 - 1]
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      ├── key: ()
      ├── fd: ()-->(1-5,7,8), (7)==(1), (1)==(7)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── select
      │    ├── columns: x:7!null y:8!null
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(7,8)
      │    ├── limit
      │    │    ├── columns: x:7!null y:8
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(7,8)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:7!null y:8
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: (7)-->(8)
      │    │    │    └── limit hint: 1.00
      │    │    └── 1
      │    └── filters
      │         └── y:8 > 9 [outer=(8), constraints=(/8: [/10 - ]; tight)]
      └── filters
           └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Any clause with constant.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT 5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:10
 ├── group-by
 │    ├── columns: k:1!null bool_or:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 notnull:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (7)-->(11), (1)-->(7,11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: notnull:11!null x:7!null
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(11)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    ├── fd: (7)-->(8)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    │    ├── key: (7)
 │    │    │    │    │    └── fd: (7)-->(8)
 │    │    │    │    └── filters
 │    │    │    │         └── (y:8 = 5) IS NOT false [outer=(8)]
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:11, outer=(8)]
 │    │    └── filters
 │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:12, outer=(11)]
 │              └── notnull:11
 └── projections
      └── CASE WHEN bool_or:12 THEN true WHEN bool_or:12 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(12)]

# Any clause with variable.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT i=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:10
 ├── group-by
 │    ├── columns: k:1!null i:2 bool_or:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 x:7 y:8 notnull:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,7,8,11), (7)-->(8), (8)~~>(11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: notnull:11!null x:7!null y:8
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(8), (8)-->(11)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(8)
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:11, outer=(8)]
 │    │    └── filters
 │    │         ├── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │         └── (i:2 = y:8) IS NOT false [outer=(2,8)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:12, outer=(11)]
 │         │    └── notnull:11
 │         └── const-agg [as=i:2, outer=(2)]
 │              └── i:2
 └── projections
      └── CASE WHEN bool_or:12 AND (i:2 IS NOT NULL) THEN true WHEN bool_or:12 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(2,12)]

# Any clause with more complex expression that must be cached.
norm expect=(TryDecorrelateProject,TryDecorrelateProjectSelect,TryDecorrelateScalarGroupBy)
SELECT i*i/5=ANY(SELECT y FROM xy WHERE x=k) AS r FROM a
----
project
 ├── columns: r:10
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null scalar:11 bool_or:13
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(11,13)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 y:8 scalar:11 notnull:12
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(7,8,11,12), (7)-->(8), (8)~~>(12)
 │    │    ├── project
 │    │    │    ├── columns: scalar:11 k:1!null
 │    │    │    ├── immutable
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(11)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    └── projections
 │    │    │         └── (i:2 * i:2) / 5 [as=scalar:11, outer=(2), immutable]
 │    │    ├── project
 │    │    │    ├── columns: notnull:12!null x:7!null y:8
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(8), (8)-->(12)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(8)
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:12, outer=(8)]
 │    │    └── filters
 │    │         ├── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │         └── (scalar:11 = y:8) IS NOT false [outer=(8,11)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:13, outer=(12)]
 │         │    └── notnull:12
 │         └── const-agg [as=scalar:11, outer=(11)]
 │              └── scalar:11
 └── projections
      └── CASE WHEN bool_or:13 AND (scalar:11 IS NOT NULL) THEN true WHEN bool_or:13 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(11,13), immutable]

# --------------------------------------------------
# TryDecorrelateProject
# --------------------------------------------------
norm expect=TryDecorrelateProject
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT u, u/1.1 AS div FROM uv WHERE i=5) ON x=div
)
----
distinct-on
 ├── columns: k:1!null
 ├── grouping columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null x:7!null div:13!null
      ├── fd: (7)==(13), (13)==(7)
      ├── project
      │    ├── columns: div:13!null k:1!null x:7!null
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null i:2!null x:7!null u:10!null
      │    │    ├── key: (1,7,10)
      │    │    ├── fd: ()-->(2)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: ()-->(2)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: x:7!null u:10!null
      │    │    │    ├── key: (7,10)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:7!null
      │    │    │    │    └── key: (7)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters (true)
      │    │    └── filters (true)
      │    └── projections
      │         └── u:10 / 1.1 [as=div:13, outer=(10)]
      └── filters
           └── x:7 = div:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]

# Don't hoist Project operator in right join case.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy RIGHT JOIN (SELECT u, u/1.1 AS div FROM uv WHERE i=5) ON x=div
)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── left-join (cross)
      │    ├── columns: x:7 div:13!null
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── project
      │    │    ├── columns: div:13!null
      │    │    ├── outer: (2)
      │    │    ├── select
      │    │    │    ├── columns: u:10!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (10)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:10 / 1.1 [as=div:13, outer=(10)]
      │    ├── scan xy
      │    │    ├── columns: x:7!null
      │    │    └── key: (7)
      │    └── filters
      │         └── x:7 = div:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]
      └── filters (true)

# --------------------------------------------------
# TryDecorrelateProjectSelect
# --------------------------------------------------
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy LEFT JOIN (SELECT u, u+1 AS plus FROM uv WHERE i=5) ON x=plus
)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── left-join (hash)
      │    ├── columns: x:7!null plus:13
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    ├── immutable
      │    ├── scan xy
      │    │    ├── columns: x:7!null
      │    │    └── key: (7)
      │    ├── project
      │    │    ├── columns: plus:13!null
      │    │    ├── outer: (2)
      │    │    ├── immutable
      │    │    ├── select
      │    │    │    ├── columns: u:10!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (10)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:10 + 1 [as=plus:13, outer=(10), immutable]
      │    └── filters
      │         └── x:7 = plus:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]
      └── filters (true)

# Don't decorrelate FULL JOIN case.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy FULL JOIN (SELECT u, u+1 AS plus FROM uv WHERE i=5) ON x=plus
)
----
project
 ├── columns: k:1!null
 ├── immutable
 ├── key: (1)
 └── semi-join-apply
      ├── columns: k:1!null i:2
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2)
      ├── scan a
      │    ├── columns: k:1!null i:2
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      ├── full-join (hash)
      │    ├── columns: x:7 plus:13
      │    ├── outer: (2)
      │    ├── multiplicity: left-rows(one-or-more), right-rows(exactly-one)
      │    ├── immutable
      │    ├── scan xy
      │    │    ├── columns: x:7!null
      │    │    └── key: (7)
      │    ├── project
      │    │    ├── columns: plus:13!null
      │    │    ├── outer: (2)
      │    │    ├── immutable
      │    │    ├── select
      │    │    │    ├── columns: u:10!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── key: (10)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters
      │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
      │    │    └── projections
      │    │         └── u:10 + 1 [as=plus:13, outer=(10), immutable]
      │    └── filters
      │         └── x:7 = plus:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]
      └── filters (true)

# --------------------------------------------------
# TryDecorrelateProjectInnerJoin
# --------------------------------------------------
norm expect=TryDecorrelateProjectInnerJoin
SELECT (SELECT sum(y + v) FROM xy, uv WHERE x=u AND x=k) FROM a
----
project
 ├── columns: sum:15
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null sum:14
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(14)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 column13:13
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (7)-->(13), (1)-->(7,13)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: column13:13 x:7!null
 │    │    │    ├── immutable
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(13)
 │    │    │    ├── inner-join (hash)
 │    │    │    │    ├── columns: x:7!null y:8 u:10!null v:11
 │    │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    │    │    │    ├── key: (10)
 │    │    │    │    ├── fd: (7)-->(8), (10)-->(11), (7)==(10), (10)==(7)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    │    ├── key: (7)
 │    │    │    │    │    └── fd: (7)-->(8)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    ├── columns: u:10!null v:11
 │    │    │    │    │    ├── key: (10)
 │    │    │    │    │    └── fd: (10)-->(11)
 │    │    │    │    └── filters
 │    │    │    │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 │    │    │    └── projections
 │    │    │         └── y:8 + v:11 [as=column13:13, outer=(8,11), immutable]
 │    │    └── filters
 │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         └── sum [as=sum:14, outer=(13)]
 │              └── column13:13
 └── projections
      └── sum:14 [as=sum:15, outer=(14)]

# --------------------------------------------------
# TryDecorrelateInnerJoin
# --------------------------------------------------
# Semi-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN uv ON x=u AND x=k
)
----
semi-join (hash)
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── inner-join (hash)
 │    ├── columns: x:7!null u:10!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (10)
 │    ├── fd: (7)==(10), (10)==(7)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── scan uv
 │    │    ├── columns: u:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Anti-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE NOT EXISTS
(
    SELECT * FROM xy INNER JOIN uv ON x=u AND x=k
)
----
anti-join (hash)
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── inner-join (hash)
 │    ├── columns: x:7!null u:10!null
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (10)
 │    ├── fd: (7)==(10), (10)==(7)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── scan uv
 │    │    ├── columns: u:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Right-join as outer.
norm expect=TryDecorrelateInnerJoin
SELECT k FROM a
WHERE
(
    SELECT count(*)
    FROM xy
    INNER JOIN uv
    ON x=u AND x=k
) IS DISTINCT FROM 1
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null count_rows:13!null
      ├── key: (1)
      ├── fd: (1)-->(13)
      ├── group-by
      │    ├── columns: k:1!null count_rows:13!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(13)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null x:7 u:10
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (7)==(10), (10)==(7), (1)-->(7,10)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null
      │    │    │    └── key: (1)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:7!null u:10!null
      │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
      │    │    │    ├── key: (10)
      │    │    │    ├── fd: (7)==(10), (10)==(7)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:7!null
      │    │    │    │    └── key: (7)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters
      │    │    │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
      │    │    └── filters
      │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── aggregations
      │         └── count [as=count_rows:13, outer=(7)]
      │              └── x:7
      └── filters
           └── count_rows:13 IS DISTINCT FROM 1 [outer=(13), constraints=(/13: [ - /0] [/2 - ]; tight)]

# Can't decorrelate left-join as inner.
norm
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy LEFT JOIN uv ON x=u AND x=k
)
----
semi-join-apply
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── left-join (hash)
 │    ├── columns: x:7!null u:10
 │    ├── outer: (1)
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (7)
 │    ├── fd: (7)-->(10)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── scan uv
 │    │    ├── columns: u:10!null
 │    │    └── key: (10)
 │    └── filters
 │         ├── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 └── filters (true)

# Can't decorrelate semi-join as inner.
norm
SELECT k
FROM a
WHERE EXISTS
(
    SELECT *
    FROM xy
    WHERE EXISTS
    (
        SELECT * FROM uv INNER JOIN uv AS uv2 ON uv2.u=k
    )
)
----
semi-join-apply
 ├── columns: k:1!null
 ├── key: (1)
 ├── scan a
 │    ├── columns: k:1!null
 │    └── key: (1)
 ├── semi-join (cross)
 │    ├── outer: (1)
 │    ├── scan xy
 │    ├── inner-join (cross)
 │    │    ├── columns: uv2.u:13!null
 │    │    ├── scan uv
 │    │    ├── scan uv [as=uv2]
 │    │    │    ├── columns: uv2.u:13!null
 │    │    │    └── key: (13)
 │    │    └── filters (true)
 │    └── filters
 │         └── uv2.u:13 = k:1 [outer=(1,13), constraints=(/1: (/NULL - ]; /13: (/NULL - ]), fd=(1)==(13), (13)==(1)]
 └── filters (true)

# --------------------------------------------------
# TryDecorrelateInnerLeftJoin
# --------------------------------------------------
norm expect=TryDecorrelateInnerLeftJoin
SELECT *
FROM (VALUES (1), (2)) AS v(v1)
WHERE EXISTS(
    SELECT k
    FROM a
    WHERE
    (
        SELECT y FROM xy LEFT JOIN (SELECT v1 FROM uv LIMIT 1) ON x=v1 WHERE x=k
    )=i
)
----
select
 ├── columns: v1:1!null
 ├── cardinality: [0 - 2]
 ├── values
 │    ├── columns: column1:1!null
 │    ├── cardinality: [2 - 2]
 │    ├── (1,)
 │    └── (2,)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: k:2!null i:3!null x:8!null y:9!null
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(2,3,8,9)
                ├── inner-join (hash)
                │    ├── columns: k:2!null i:3!null x:8!null y:9!null
                │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
                │    ├── key: (8)
                │    ├── fd: (2)-->(3), (8)-->(9), (2)==(8), (8)==(2), (3)==(9), (9)==(3)
                │    ├── limit hint: 1.00
                │    ├── scan a
                │    │    ├── columns: k:2!null i:3
                │    │    ├── key: (2)
                │    │    └── fd: (2)-->(3)
                │    ├── scan xy
                │    │    ├── columns: x:8!null y:9
                │    │    ├── key: (8)
                │    │    └── fd: (8)-->(9)
                │    └── filters
                │         ├── x:8 = k:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
                │         └── i:3 = y:9 [outer=(3,9), constraints=(/3: (/NULL - ]; /9: (/NULL - ]), fd=(3)==(9), (9)==(3)]
                └── 1

norm expect=TryDecorrelateInnerLeftJoin
SELECT *
FROM xy, uv
WHERE (SELECT i FROM a WHERE k=x) IS DISTINCT FROM u
----
project
 ├── columns: x:1!null y:2 u:4!null v:5
 ├── key: (1,4)
 ├── fd: (1)-->(2), (4)-->(5)
 └── select
      ├── columns: x:1!null y:2 u:4!null v:5 k:7 i:8
      ├── key: (1,4)
      ├── fd: (1)-->(2), (4)-->(5), (7)-->(8), (1,4)-->(7,8)
      ├── left-join (hash)
      │    ├── columns: x:1!null y:2 u:4!null v:5 k:7 i:8
      │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    ├── key: (1,4)
      │    ├── fd: (1)-->(2), (4)-->(5), (7)-->(8), (1,4)-->(7,8)
      │    ├── inner-join (cross)
      │    │    ├── columns: x:1!null y:2 u:4!null v:5
      │    │    ├── key: (1,4)
      │    │    ├── fd: (1)-->(2), (4)-->(5)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:1!null y:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:4!null v:5
      │    │    │    ├── key: (4)
      │    │    │    └── fd: (4)-->(5)
      │    │    └── filters (true)
      │    ├── scan a
      │    │    ├── columns: k:7!null i:8
      │    │    ├── key: (7)
      │    │    └── fd: (7)-->(8)
      │    └── filters
      │         └── k:7 = x:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      └── filters
           └── u:4 IS DISTINCT FROM i:8 [outer=(4,8)]

# --------------------------------------------------
# TryDecorrelateGroupBy
# --------------------------------------------------
norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT count(*) AS cnt, sum(v) FROM uv WHERE i=5 GROUP BY v) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11 count_rows:13!null
 │    ├── key: (1,7,11)
 │    ├── fd: ()-->(2), (1)-->(3-5), (1,7,11)-->(3-5,13), (7)==(13), (13)==(7)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11 count_rows:13!null
 │    │    ├── grouping columns: k:1!null x:7!null v:11
 │    │    ├── key: (1,7,11)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (1,7,11)-->(2-5,13)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:7!null v:11
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null
 │    │    │    │    │    └── key: (7)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    └── columns: v:11
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── count-rows [as=count_rows:13]
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:7 = count_rows:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT count(DISTINCT uv.v) AS cnt, sum(v) FROM uv WHERE i=5 GROUP BY v) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11 count:13!null
 │    ├── key: (1,7,11)
 │    ├── fd: ()-->(2), (1)-->(3-5), (1,7,11)-->(3-5,13), (7)==(13), (13)==(7)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11 count:13!null
 │    │    ├── grouping columns: k:1!null x:7!null v:11
 │    │    ├── key: (1,7,11)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (1,7,11)-->(2-5,13)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null v:11
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:7!null v:11
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null
 │    │    │    │    │    └── key: (7)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    └── columns: v:11
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── agg-distinct [as=count:13, outer=(11)]
 │    │         │    └── count
 │    │         │         └── v:11
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:7 = count:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Indirectly decorrelate GROUP BY after decorrelating scalar GROUP BY.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM xy, uv
WHERE x=v AND u=(SELECT max(i) FROM a WHERE k=x)
----
project
 ├── columns: x:1!null y:2 u:4!null v:5!null
 ├── key: (4)
 ├── fd: (1)-->(2), (4)-->(1,2,5), (1)==(5), (5)==(1)
 └── select
      ├── columns: x:1!null y:2 u:4!null v:5!null max:13!null
      ├── key: (4)
      ├── fd: (1)-->(2), (4)-->(1,2,5), (1)==(5), (5)==(1), (4)==(13), (13)==(4)
      ├── group-by
      │    ├── columns: x:1!null y:2 u:4!null v:5!null max:13!null
      │    ├── grouping columns: u:4!null
      │    ├── key: (4)
      │    ├── fd: (1)-->(2), (4)-->(1,2,5,13), (1)==(5), (5)==(1)
      │    ├── inner-join (hash)
      │    │    ├── columns: x:1!null y:2 u:4!null v:5!null k:7!null i:8!null
      │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    │    ├── key: (4)
      │    │    ├── fd: (1)-->(2), (4)-->(5), (1)==(5,7), (5)==(1,7), (7)-->(8), (7)==(1,5)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:1!null y:2 u:4!null v:5!null
      │    │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    │    │    ├── key: (4)
      │    │    │    ├── fd: (1)-->(2), (4)-->(5), (1)==(5), (5)==(1)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:1!null y:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:4!null v:5
      │    │    │    │    ├── key: (4)
      │    │    │    │    └── fd: (4)-->(5)
      │    │    │    └── filters
      │    │    │         └── x:1 = v:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    │    ├── select
      │    │    │    ├── columns: k:7!null i:8!null
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: (7)-->(8)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:7!null i:8
      │    │    │    │    ├── key: (7)
      │    │    │    │    └── fd: (7)-->(8)
      │    │    │    └── filters
      │    │    │         └── i:8 IS NOT NULL [outer=(8), constraints=(/8: (/NULL - ]; tight)]
      │    │    └── filters
      │    │         └── k:7 = x:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── aggregations
      │         ├── max [as=max:13, outer=(8)]
      │         │    └── i:8
      │         ├── const-agg [as=v:5, outer=(5)]
      │         │    └── v:5
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=x:1, outer=(1)]
      │              └── x:1
      └── filters
           └── u:4 = max:13 [outer=(4,13), constraints=(/4: (/NULL - ]; /13: (/NULL - ]), fd=(4)==(13), (13)==(4)]

# Indirectly decorrelate GROUP BY after decorrelating scalar GROUP BY. Use
# IS DISTINCT FROM to retain left join.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM xy, uv
WHERE x=v AND (SELECT max(i) FROM a WHERE k=x) IS DISTINCT FROM u
----
project
 ├── columns: x:1!null y:2 u:4!null v:5!null
 ├── key: (4)
 ├── fd: (1)-->(2), (4)-->(1,2,5), (1)==(5), (5)==(1)
 └── select
      ├── columns: x:1!null y:2 u:4!null v:5!null max:13
      ├── key: (4)
      ├── fd: (1)-->(2), (4)-->(1,2,5,13), (1)==(5), (5)==(1)
      ├── group-by
      │    ├── columns: x:1!null y:2 u:4!null v:5!null max:13
      │    ├── grouping columns: u:4!null
      │    ├── key: (4)
      │    ├── fd: (1)-->(2), (4)-->(1,2,5,13), (1)==(5), (5)==(1)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1!null y:2 u:4!null v:5!null k:7 i:8
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    ├── key: (4)
      │    │    ├── fd: (1)-->(2), (4)-->(5,7,8), (1)==(5), (5)==(1), (7)-->(8)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: x:1!null y:2 u:4!null v:5!null
      │    │    │    ├── multiplicity: left-rows(zero-or-more), right-rows(zero-or-one)
      │    │    │    ├── key: (4)
      │    │    │    ├── fd: (1)-->(2), (4)-->(5), (1)==(5), (5)==(1)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:1!null y:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:4!null v:5
      │    │    │    │    ├── key: (4)
      │    │    │    │    └── fd: (4)-->(5)
      │    │    │    └── filters
      │    │    │         └── x:1 = v:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
      │    │    ├── scan a
      │    │    │    ├── columns: k:7!null i:8
      │    │    │    ├── key: (7)
      │    │    │    └── fd: (7)-->(8)
      │    │    └── filters
      │    │         └── k:7 = x:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── aggregations
      │         ├── max [as=max:13, outer=(8)]
      │         │    └── i:8
      │         ├── const-agg [as=v:5, outer=(5)]
      │         │    └── v:5
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=x:1, outer=(1)]
      │              └── x:1
      └── filters
           └── u:4 IS DISTINCT FROM max:13 [outer=(4,13)]

# Synthesize key when one is not present.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM
(
    SELECT y, 'foo' AS cst FROM xy
)
WHERE 'bar'=(SELECT max(s) FROM (SELECT * FROM a LIMIT 1) WHERE k=y GROUP BY i)
----
project
 ├── columns: y:2!null cst:4!null
 ├── fd: ()-->(2,4)
 ├── select
 │    ├── columns: x:1!null y:2!null max:11!null
 │    ├── key: (1)
 │    ├── fd: ()-->(2,11)
 │    ├── group-by
 │    │    ├── columns: x:1!null y:2!null max:11
 │    │    ├── grouping columns: x:1!null
 │    │    ├── key: (1)
 │    │    ├── fd: ()-->(2), (1)-->(2,11)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: x:1!null y:2!null k:5!null s:8
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: ()-->(2,5,8), (2)==(5), (5)==(2)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── limit
 │    │    │    │    ├── columns: k:5!null s:8
 │    │    │    │    ├── cardinality: [0 - 1]
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(5,8)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:5!null s:8
 │    │    │    │    │    ├── key: (5)
 │    │    │    │    │    ├── fd: (5)-->(8)
 │    │    │    │    │    └── limit hint: 1.00
 │    │    │    │    └── 1
 │    │    │    └── filters
 │    │    │         └── k:5 = y:2 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]
 │    │    └── aggregations
 │    │         ├── max [as=max:11, outer=(8)]
 │    │         │    └── s:8
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── max:11 = 'bar' [outer=(11), constraints=(/11: [/'bar' - /'bar']; tight), fd=()-->(11)]
 └── projections
      └── 'foo' [as=cst:4]

# Decorrelate DistinctOn.
norm expect=TryDecorrelateGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (
        SELECT DISTINCT ON (v) u, v FROM uv WHERE i=5
    ) ON x=u
)
----
group-by
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: ()-->(2), (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null u:10!null v:11
 │    ├── key: (1,10)
 │    ├── fd: ()-->(2), (1)-->(3-5), (10)-->(11), (1,7,11)-->(3-5,10), (7)==(10), (10)==(7)
 │    ├── distinct-on
 │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null u:10!null v:11
 │    │    ├── grouping columns: k:1!null x:7!null v:11
 │    │    ├── key: (1,7,10)
 │    │    ├── fd: ()-->(2), (1)-->(3-5), (10)-->(11), (1,7,11)-->(2-5,10)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5 x:7!null u:10!null v:11
 │    │    │    ├── key: (1,7,10)
 │    │    │    ├── fd: ()-->(2), (1)-->(3-5), (10)-->(11)
 │    │    │    ├── select
 │    │    │    │    ├── columns: k:1!null i:2!null f:3 s:4 j:5
 │    │    │    │    ├── key: (1)
 │    │    │    │    ├── fd: ()-->(2), (1)-->(3-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    └── filters
 │    │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: x:7!null u:10!null v:11
 │    │    │    │    ├── key: (7,10)
 │    │    │    │    ├── fd: (10)-->(11)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null
 │    │    │    │    │    └── key: (7)
 │    │    │    │    ├── scan uv
 │    │    │    │    │    ├── columns: u:10!null v:11
 │    │    │    │    │    ├── key: (10)
 │    │    │    │    │    └── fd: (10)-->(11)
 │    │    │    │    └── filters (true)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── first-agg [as=u:10, outer=(10)]
 │    │         │    └── u:10
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Regression test for #40592. Ensure that no new output columns are added
# as a result of TryDecorrelateGroupBy.
exec-ddl
CREATE TABLE tab_orig (
    _int2 INT8 NULL,
    _int8 INT8 NULL,
    _timestamptz TIMESTAMPTZ NULL,
    _bool BOOL NULL,
    _decimal INT8 NULL,
    _string INT8 NULL,
    FAMILY "primary" (_int2, _int8, _timestamptz, _bool, _decimal, _string, rowid)
)
----

norm expect=TryDecorrelateGroupBy disable=InlineWith
SELECT
  NULL
FROM
  tab_orig AS t0
WHERE
  EXISTS(
    SELECT
      NULL
    FROM
      tab_orig
      JOIN tab_orig AS t1
        INNER JOIN tab_orig AS t2
          JOIN tab_orig AS t3 ON true ON
            EXISTS(
              WITH
                w0 AS (SELECT NULL)
              SELECT
                t0._string FROM w0 CROSS JOIN w0 as w1
              WHERE t0._string = 1
            ) ON true
      JOIN tab_orig AS t4 ON
          t3._timestamptz
          = t4._timestamptz
          AND t3._int2 = t4._int8
      JOIN tab_orig AS t5 ON
          t1._decimal = t5._decimal
    WHERE
      t2._bool
    ORDER BY
      t2._decimal
    LIMIT
      66
  );
----
with &1 (w0)
 ├── columns: "?column?":65
 ├── fd: ()-->(65)
 ├── values
 │    ├── columns: "?column?":41
 │    ├── cardinality: [1 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(41)
 │    └── (NULL,)
 └── project
      ├── columns: "?column?":65
      ├── fd: ()-->(65)
      ├── semi-join-apply
      │    ├── columns: t0._string:6
      │    ├── scan tab_orig [as=t0]
      │    │    └── columns: t0._string:6
      │    ├── inner-join (hash)
      │    │    ├── columns: tab_orig.rowid:15!null t1._decimal:21!null t1.rowid:23!null t2._bool:28!null t2.rowid:31!null t3._int2:33!null t3._timestamptz:35!null t3.rowid:39!null t4._int8:49!null t4._timestamptz:50!null t5._decimal:60!null
      │    │    ├── outer: (6)
      │    │    ├── fd: ()-->(28), (23)-->(21), (39)-->(33,35), (15,23,31,39)-->(21,33,35), (35)==(50), (50)==(35), (33)==(49), (49)==(33), (21)==(60), (60)==(21)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: tab_orig.rowid:15!null t1._decimal:21 t1.rowid:23!null t2._bool:28 t2.rowid:31!null t3._int2:33!null t3._timestamptz:35!null t3.rowid:39!null t4._int8:49!null t4._timestamptz:50!null
      │    │    │    ├── outer: (6)
      │    │    │    ├── fd: (23)-->(21), (31)-->(28), (39)-->(33,35), (15,23,31,39)-->(21,28,33,35), (35)==(50), (50)==(35), (33)==(49), (49)==(33)
      │    │    │    ├── group-by
      │    │    │    │    ├── columns: tab_orig.rowid:15!null t1._decimal:21 t1.rowid:23!null t2._bool:28 t2.rowid:31!null t3._int2:33 t3._timestamptz:35 t3.rowid:39!null
      │    │    │    │    ├── grouping columns: tab_orig.rowid:15!null t1.rowid:23!null t2.rowid:31!null t3.rowid:39!null
      │    │    │    │    ├── outer: (6)
      │    │    │    │    ├── key: (15,23,31,39)
      │    │    │    │    ├── fd: (23)-->(21), (31)-->(28), (39)-->(33,35), (15,23,31,39)-->(21,28,33,35)
      │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    ├── columns: tab_orig.rowid:15!null t1._decimal:21 t1.rowid:23!null t2._bool:28 t2.rowid:31!null t3._int2:33 t3._timestamptz:35 t3.rowid:39!null
      │    │    │    │    │    ├── outer: (6)
      │    │    │    │    │    ├── key: (15,23,31,39)
      │    │    │    │    │    ├── fd: (23)-->(21), (31)-->(28), (39)-->(33,35)
      │    │    │    │    │    ├── scan tab_orig
      │    │    │    │    │    │    ├── columns: tab_orig.rowid:15!null
      │    │    │    │    │    │    └── key: (15)
      │    │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    │    ├── columns: t1._decimal:21 t1.rowid:23!null t2._bool:28 t2.rowid:31!null t3._int2:33 t3._timestamptz:35 t3.rowid:39!null
      │    │    │    │    │    │    ├── key: (23,31,39)
      │    │    │    │    │    │    ├── fd: (23)-->(21), (31)-->(28), (39)-->(33,35)
      │    │    │    │    │    │    ├── scan tab_orig [as=t1]
      │    │    │    │    │    │    │    ├── columns: t1._decimal:21 t1.rowid:23!null
      │    │    │    │    │    │    │    ├── key: (23)
      │    │    │    │    │    │    │    └── fd: (23)-->(21)
      │    │    │    │    │    │    ├── inner-join (cross)
      │    │    │    │    │    │    │    ├── columns: t2._bool:28 t2.rowid:31!null t3._int2:33 t3._timestamptz:35 t3.rowid:39!null
      │    │    │    │    │    │    │    ├── key: (31,39)
      │    │    │    │    │    │    │    ├── fd: (31)-->(28), (39)-->(33,35)
      │    │    │    │    │    │    │    ├── scan tab_orig [as=t2]
      │    │    │    │    │    │    │    │    ├── columns: t2._bool:28 t2.rowid:31!null
      │    │    │    │    │    │    │    │    ├── key: (31)
      │    │    │    │    │    │    │    │    └── fd: (31)-->(28)
      │    │    │    │    │    │    │    ├── scan tab_orig [as=t3]
      │    │    │    │    │    │    │    │    ├── columns: t3._int2:33 t3._timestamptz:35 t3.rowid:39!null
      │    │    │    │    │    │    │    │    ├── key: (39)
      │    │    │    │    │    │    │    │    └── fd: (39)-->(33,35)
      │    │    │    │    │    │    │    └── filters (true)
      │    │    │    │    │    │    └── filters (true)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── t0._string:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=t2._bool:28, outer=(28)]
      │    │    │    │         │    └── t2._bool:28
      │    │    │    │         ├── const-agg [as=t3._int2:33, outer=(33)]
      │    │    │    │         │    └── t3._int2:33
      │    │    │    │         ├── const-agg [as=t3._timestamptz:35, outer=(35)]
      │    │    │    │         │    └── t3._timestamptz:35
      │    │    │    │         └── const-agg [as=t1._decimal:21, outer=(21)]
      │    │    │    │              └── t1._decimal:21
      │    │    │    ├── scan tab_orig [as=t4]
      │    │    │    │    └── columns: t4._int8:49 t4._timestamptz:50
      │    │    │    └── filters
      │    │    │         ├── t3._timestamptz:35 = t4._timestamptz:50 [outer=(35,50), constraints=(/35: (/NULL - ]; /50: (/NULL - ]), fd=(35)==(50), (50)==(35)]
      │    │    │         └── t3._int2:33 = t4._int8:49 [outer=(33,49), constraints=(/33: (/NULL - ]; /49: (/NULL - ]), fd=(33)==(49), (49)==(33)]
      │    │    ├── scan tab_orig [as=t5]
      │    │    │    └── columns: t5._decimal:60
      │    │    └── filters
      │    │         ├── t2._bool:28 [outer=(28), constraints=(/28: [/true - /true]; tight), fd=()-->(28)]
      │    │         └── t1._decimal:21 = t5._decimal:60 [outer=(21,60), constraints=(/21: (/NULL - ]; /60: (/NULL - ]), fd=(21)==(60), (60)==(21)]
      │    └── filters (true)
      └── projections
           └── NULL [as="?column?":65]

# --------------------------------------------------
# TryDecorrelateScalarGroupBy
# --------------------------------------------------
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT sum(v), count(*) AS cnt FROM uv WHERE i=5) ON x=cnt
)
----
group-by
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── grouping columns: k:1!null
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null count_rows:14!null
 │    ├── key: (1,7)
 │    ├── fd: (1)-->(2-5), (1,7)-->(2-5,14), (7)==(14), (14)==(7)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null count_rows:14!null
 │    │    ├── grouping columns: k:1!null x:7!null
 │    │    ├── key: (1,7)
 │    │    ├── fd: (1)-->(2-5), (1,7)-->(2-5,14)
 │    │    ├── left-join (cross)
 │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null canary:15
 │    │    │    ├── fd: (1)-->(2-5)
 │    │    │    ├── inner-join (cross)
 │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null
 │    │    │    │    ├── key: (1,7)
 │    │    │    │    ├── fd: (1)-->(2-5)
 │    │    │    │    ├── scan a
 │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    └── fd: (1)-->(2-5)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null
 │    │    │    │    │    └── key: (7)
 │    │    │    │    └── filters (true)
 │    │    │    ├── project
 │    │    │    │    ├── columns: canary:15!null
 │    │    │    │    ├── fd: ()-->(15)
 │    │    │    │    ├── scan uv
 │    │    │    │    └── projections
 │    │    │    │         └── true [as=canary:15]
 │    │    │    └── filters
 │    │    │         └── i:2 = 5 [outer=(2), constraints=(/2: [/5 - /5]; tight), fd=()-->(2)]
 │    │    └── aggregations
 │    │         ├── count [as=count_rows:14, outer=(15)]
 │    │         │    └── canary:15
 │    │         ├── const-agg [as=i:2, outer=(2)]
 │    │         │    └── i:2
 │    │         ├── const-agg [as=f:3, outer=(3)]
 │    │         │    └── f:3
 │    │         ├── const-agg [as=s:4, outer=(4)]
 │    │         │    └── s:4
 │    │         └── const-agg [as=j:5, outer=(5)]
 │    │              └── j:5
 │    └── filters
 │         └── x:7 = count_rows:14 [outer=(7,14), constraints=(/7: (/NULL - ]; /14: (/NULL - ]), fd=(7)==(14), (14)==(7)]
 └── aggregations
      ├── const-agg [as=i:2, outer=(2)]
      │    └── i:2
      ├── const-agg [as=f:3, outer=(3)]
      │    └── f:3
      ├── const-agg [as=s:4, outer=(4)]
      │    └── s:4
      └── const-agg [as=j:5, outer=(5)]
           └── j:5

# Synthesize key when one is not present.
norm expect=TryDecorrelateScalarGroupBy
SELECT * FROM (SELECT i, 'foo' AS cst FROM a) WHERE 5=(SELECT max(y) FROM xy WHERE x=i)
----
project
 ├── columns: i:2!null cst:7!null
 ├── fd: ()-->(7)
 ├── select
 │    ├── columns: k:1!null i:2!null max:11!null
 │    ├── key: (1)
 │    ├── fd: ()-->(11), (1)-->(2)
 │    ├── group-by
 │    │    ├── columns: k:1!null i:2!null max:11!null
 │    │    ├── grouping columns: k:1!null
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,11)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: k:1!null i:2!null x:8!null y:9!null
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(2), (8)-->(9), (2)==(8), (8)==(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:8!null y:9!null
 │    │    │    │    ├── key: (8)
 │    │    │    │    ├── fd: (8)-->(9)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:8!null y:9
 │    │    │    │    │    ├── key: (8)
 │    │    │    │    │    └── fd: (8)-->(9)
 │    │    │    │    └── filters
 │    │    │    │         └── y:9 IS NOT NULL [outer=(9), constraints=(/9: (/NULL - ]; tight)]
 │    │    │    └── filters
 │    │    │         └── x:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    │    └── aggregations
 │    │         ├── max [as=max:11, outer=(9)]
 │    │         │    └── y:9
 │    │         └── const-agg [as=i:2, outer=(2)]
 │    │              └── i:2
 │    └── filters
 │         └── max:11 = 5 [outer=(11), constraints=(/11: [/5 - /5]; tight), fd=()-->(11)]
 └── projections
      └── 'foo' [as=cst:7]

# With an aggregate that can't ignore nulls. xy.y = a.k rejects nulls, so
# there's no canary column to be synthesized.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT array_agg(xy.y) FROM xy WHERE xy.y = a.k) FROM a
----
project
 ├── columns: k:1!null array_agg:11
 ├── key: (1)
 ├── fd: (1)-->(11)
 ├── group-by
 │    ├── columns: k:1!null y:8 array_agg:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(8,12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null y:8
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan xy
 │    │    │    └── columns: y:8
 │    │    └── filters
 │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:12, outer=(8)]
 │         │    └── y:8
 │         └── any-not-null-agg [as=y:8, outer=(8)]
 │              └── y:8
 └── projections
      └── CASE WHEN y:8 IS NOT NULL THEN array_agg:12 ELSE CAST(NULL AS INT8[]) END [as=array_agg:11, outer=(8,12)]

# With multiple columns. Without LATERAL these tests are a bit verbose.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT (r, q) FROM (SELECT array_agg(xy.y) r, max(xy.y) q FROM xy WHERE xy.y = a.k)) FROM a
----
project
 ├── columns: k:1!null "?column?":13
 ├── key: (1)
 ├── fd: (1)-->(13)
 ├── group-by
 │    ├── columns: k:1!null y:8 max:11 array_agg:14
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(8,11,14)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null y:8
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan xy
 │    │    │    └── columns: y:8
 │    │    └── filters
 │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:14, outer=(8)]
 │         │    └── y:8
 │         ├── max [as=max:11, outer=(8)]
 │         │    └── y:8
 │         └── any-not-null-agg [as=y:8, outer=(8)]
 │              └── y:8
 └── projections
      └── (CASE WHEN y:8 IS NOT NULL THEN array_agg:14 ELSE CAST(NULL AS INT8[]) END, max:11) [as="?column?":13, outer=(8,11,14)]


# With an aggregate that can't ignore nulls and when a non-nullable column must be synthesized.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, ARRAY(SELECT y FROM xy WHERE xy.y = a.i OR xy.y IS NULL) FROM a
----
project
 ├── columns: k:1!null array:11
 ├── key: (1)
 ├── fd: (1)-->(11)
 ├── group-by
 │    ├── columns: k:1!null canary:12 array_agg:13
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12,13)
 │    ├── left-join (cross)
 │    │    ├── columns: k:1!null i:2 y:8 canary:12
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: canary:12!null y:8
 │    │    │    ├── fd: ()-->(12)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:8
 │    │    │    └── projections
 │    │    │         └── true [as=canary:12]
 │    │    └── filters
 │    │         └── (y:8 = i:2) OR (y:8 IS NULL) [outer=(2,8)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:13, outer=(8)]
 │         │    └── y:8
 │         └── any-not-null-agg [as=canary:12, outer=(12)]
 │              └── canary:12
 └── projections
      └── COALESCE(CASE WHEN canary:12 IS NOT NULL THEN array_agg:13 ELSE CAST(NULL AS INT8[]) END, ARRAY[]) [as=array:11, outer=(12,13)]

# With an ordering.
norm expect=TryDecorrelateScalarGroupBy
SELECT i, ARRAY(SELECT y FROM xy WHERE xy.y = a.k OR xy.y IS NULL ORDER BY y) FROM a
----
project
 ├── columns: i:2 array:11
 ├── group-by
 │    ├── columns: k:1!null i:2 canary:12 array_agg:13
 │    ├── grouping columns: k:1!null
 │    ├── internal-ordering: +8
 │    ├── key: (1)
 │    ├── fd: (1)-->(2,12,13)
 │    ├── sort
 │    │    ├── columns: k:1!null i:2 y:8 canary:12
 │    │    ├── fd: (1)-->(2)
 │    │    ├── ordering: +8
 │    │    └── left-join (cross)
 │    │         ├── columns: k:1!null i:2 y:8 canary:12
 │    │         ├── fd: (1)-->(2)
 │    │         ├── scan a
 │    │         │    ├── columns: k:1!null i:2
 │    │         │    ├── key: (1)
 │    │         │    └── fd: (1)-->(2)
 │    │         ├── project
 │    │         │    ├── columns: canary:12!null y:8
 │    │         │    ├── fd: ()-->(12)
 │    │         │    ├── scan xy
 │    │         │    │    └── columns: y:8
 │    │         │    └── projections
 │    │         │         └── true [as=canary:12]
 │    │         └── filters
 │    │              └── (y:8 = k:1) OR (y:8 IS NULL) [outer=(1,8)]
 │    └── aggregations
 │         ├── array-agg [as=array_agg:13, outer=(8)]
 │         │    └── y:8
 │         ├── const-agg [as=i:2, outer=(2)]
 │         │    └── i:2
 │         └── any-not-null-agg [as=canary:12, outer=(12)]
 │              └── canary:12
 └── projections
      └── COALESCE(CASE WHEN canary:12 IS NOT NULL THEN array_agg:13 ELSE CAST(NULL AS INT8[]) END, ARRAY[]) [as=array:11, outer=(12,13)]

# Nest scalar decorrelation within scalar decorrelation, using IS NULL to force
# use of left joins.
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM a
WHERE
(
    SELECT max(y)
    FROM xy
    WHERE
    (
        SELECT max(v) FROM uv WHERE u=k
    ) IS NULL
) IS NULL
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 max:14
      ├── key: (1)
      ├── fd: ()-->(14), (1)-->(2-5)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 max:14
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,14)
      │    ├── left-join-apply
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7 y:8 max:13
      │    │    ├── key: (1,7)
      │    │    ├── fd: (1)-->(2-5), (1,7)-->(8,13)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── group-by
      │    │    │    ├── columns: x:7!null y:8 max:13
      │    │    │    ├── grouping columns: x:7!null
      │    │    │    ├── outer: (1)
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: (7)-->(8,13)
      │    │    │    ├── left-join (cross)
      │    │    │    │    ├── columns: x:7!null y:8 u:10 v:11
      │    │    │    │    ├── outer: (1)
      │    │    │    │    ├── key: (7,10)
      │    │    │    │    ├── fd: (7)-->(8), (10)-->(11)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:10!null v:11
      │    │    │    │    │    ├── key: (10)
      │    │    │    │    │    └── fd: (10)-->(11)
      │    │    │    │    └── filters
      │    │    │    │         └── u:10 = k:1 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
      │    │    │    └── aggregations
      │    │    │         ├── max [as=max:13, outer=(11)]
      │    │    │         │    └── v:11
      │    │    │         └── const-agg [as=y:8, outer=(8)]
      │    │    │              └── y:8
      │    │    └── filters
      │    │         └── max:13 IS NULL [outer=(13), constraints=(/13: [/NULL - /NULL]; tight), fd=()-->(13)]
      │    └── aggregations
      │         ├── max [as=max:14, outer=(8)]
      │         │    └── y:8
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── max:14 IS NULL [outer=(14), constraints=(/14: [/NULL - /NULL]; tight), fd=()-->(14)]

# ScalarGroupBy with non-null ignoring and a non-nullable column.
norm expect=TryDecorrelateScalarGroupBy
SELECT *
FROM cd
WHERE
(
    SELECT array_agg(y)
    FROM xy
    WHERE c = x
) = ARRAY[]:::INT[]
----
project
 ├── columns: c:1!null d:2!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── select
      ├── columns: c:1!null d:2!null array_agg:7!null
      ├── key: (1)
      ├── fd: ()-->(7), (1)-->(2)
      ├── project
      │    ├── columns: array_agg:7 c:1!null d:2!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,7)
      │    ├── group-by
      │    │    ├── columns: c:1!null d:2!null x:4 array_agg:8
      │    │    ├── grouping columns: c:1!null
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2,4,8)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: c:1!null d:2!null x:4 y:5
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2,4,5), (4)-->(5)
      │    │    │    ├── scan cd
      │    │    │    │    ├── columns: c:1!null d:2!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:4!null y:5
      │    │    │    │    ├── key: (4)
      │    │    │    │    └── fd: (4)-->(5)
      │    │    │    └── filters
      │    │    │         └── c:1 = x:4 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      │    │    └── aggregations
      │    │         ├── array-agg [as=array_agg:8, outer=(5)]
      │    │         │    └── y:5
      │    │         ├── const-agg [as=d:2, outer=(2)]
      │    │         │    └── d:2
      │    │         └── any-not-null-agg [as=x:4, outer=(4)]
      │    │              └── x:4
      │    └── projections
      │         └── CASE WHEN x:4 IS NOT NULL THEN array_agg:8 ELSE CAST(NULL AS INT8[]) END [as=array_agg:7, outer=(4,8)]
      └── filters
           └── array_agg:7 = ARRAY[] [outer=(7), constraints=(/7: [/ARRAY[] - /ARRAY[]]; tight), fd=()-->(7)]

norm expect=TryDecorrelateScalarGroupBy
SELECT * FROM a WHERE 'foo'=(SELECT concat_agg(y::string) FROM xy WHERE x=k)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 concat_agg:11!null
      ├── immutable
      ├── key: (1)
      ├── fd: ()-->(11), (1)-->(2-5)
      ├── project
      │    ├── columns: concat_agg:11 k:1!null i:2 f:3 s:4 j:5
      │    ├── immutable
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,11)
      │    ├── group-by
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 canary:12 concat_agg:13
      │    │    ├── grouping columns: k:1!null
      │    │    ├── immutable
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,12,13)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7 column10:10 canary:12
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── immutable
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5,7,10,12), (7)-->(10)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    ├── project
      │    │    │    │    ├── columns: canary:12!null column10:10 x:7!null
      │    │    │    │    ├── immutable
      │    │    │    │    ├── key: (7)
      │    │    │    │    ├── fd: ()-->(12), (7)-->(10)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    └── projections
      │    │    │    │         ├── true [as=canary:12]
      │    │    │    │         └── y:8::STRING [as=column10:10, outer=(8), immutable]
      │    │    │    └── filters
      │    │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    │    └── aggregations
      │    │         ├── concat-agg [as=concat_agg:13, outer=(10)]
      │    │         │    └── column10:10
      │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │         │    └── i:2
      │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │         │    └── f:3
      │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │         │    └── s:4
      │    │         ├── const-agg [as=j:5, outer=(5)]
      │    │         │    └── j:5
      │    │         └── any-not-null-agg [as=canary:12, outer=(12)]
      │    │              └── canary:12
      │    └── projections
      │         └── CASE WHEN canary:12 IS NOT NULL THEN concat_agg:13 ELSE CAST(NULL AS STRING) END [as=concat_agg:11, outer=(12,13)]
      └── filters
           └── concat_agg:11 = 'foo' [outer=(11), constraints=(/11: [/'foo' - /'foo']; tight), fd=()-->(11)]

# With a multi-argument aggregate.
norm expect=TryDecorrelateScalarGroupBy
SELECT k, (SELECT string_agg(a.s, ',') FROM a WHERE a.k = a2.i) FROM a AS a2
----
project
 ├── columns: k:1!null string_agg:15
 ├── key: (1)
 ├── fd: (1)-->(15)
 ├── group-by
 │    ├── columns: a2.k:1!null string_agg:14
 │    ├── grouping columns: a2.k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(14)
 │    ├── left-join (hash)
 │    │    ├── columns: a2.k:1!null a2.i:2 a.k:7 a.s:10 column13:13
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,7,10,13), (7)-->(10)
 │    │    ├── scan a [as=a2]
 │    │    │    ├── columns: a2.k:1!null a2.i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: column13:13!null a.k:7!null a.s:10
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: ()-->(13), (7)-->(10)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: a.k:7!null a.s:10
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(10)
 │    │    │    └── projections
 │    │    │         └── ',' [as=column13:13]
 │    │    └── filters
 │    │         └── a.k:7 = a2.i:2 [outer=(2,7), constraints=(/2: (/NULL - ]; /7: (/NULL - ]), fd=(2)==(7), (7)==(2)]
 │    └── aggregations
 │         └── string-agg [as=string_agg:14, outer=(10,13)]
 │              ├── a.s:10
 │              └── column13:13
 └── projections
      └── string_agg:14 [as=string_agg:15, outer=(14)]

# --------------------------------------------------
# TryDecorrelateSemiJoin
# --------------------------------------------------

# Right input of SemiJoin is GroupBy.
norm expect=TryDecorrelateSemiJoin
SELECT *
FROM xy
WHERE EXISTS
(
    SELECT * FROM a WHERE i=(SELECT max(i) FROM a WHERE f=y::float)
)
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── select
 │    ├── columns: x:1!null y:2 k:4!null i:5!null max:16!null
 │    ├── immutable
 │    ├── key: (1,4)
 │    ├── fd: (1)-->(2), (4)-->(5), (1,4)-->(2,5,16), (5)==(16), (16)==(5)
 │    ├── group-by
 │    │    ├── columns: x:1!null y:2 k:4!null i:5 max:16!null
 │    │    ├── grouping columns: x:1!null k:4!null
 │    │    ├── immutable
 │    │    ├── key: (1,4)
 │    │    ├── fd: (1)-->(2), (4)-->(5), (1,4)-->(2,5,16)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null y:2 k:4!null i:5 i:11!null f:12!null column17:17!null
 │    │    │    ├── immutable
 │    │    │    ├── fd: (1)-->(2), (2)-->(17), (12)==(17), (17)==(12), (4)-->(5)
 │    │    │    ├── inner-join (hash)
 │    │    │    │    ├── columns: x:1!null y:2 i:11!null f:12!null column17:17!null
 │    │    │    │    ├── immutable
 │    │    │    │    ├── fd: (1)-->(2), (2)-->(17), (12)==(17), (17)==(12)
 │    │    │    │    ├── project
 │    │    │    │    │    ├── columns: column17:17 x:1!null y:2
 │    │    │    │    │    ├── immutable
 │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    ├── fd: (1)-->(2), (2)-->(17)
 │    │    │    │    │    ├── scan xy
 │    │    │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    │    │    ├── key: (1)
 │    │    │    │    │    │    └── fd: (1)-->(2)
 │    │    │    │    │    └── projections
 │    │    │    │    │         └── y:2::FLOAT8 [as=column17:17, outer=(2), immutable]
 │    │    │    │    ├── select
 │    │    │    │    │    ├── columns: i:11!null f:12
 │    │    │    │    │    ├── scan a
 │    │    │    │    │    │    └── columns: i:11 f:12
 │    │    │    │    │    └── filters
 │    │    │    │    │         └── i:11 IS NOT NULL [outer=(11), constraints=(/11: (/NULL - ]; tight)]
 │    │    │    │    └── filters
 │    │    │    │         └── column17:17 = f:12 [outer=(12,17), constraints=(/12: (/NULL - ]; /17: (/NULL - ]), fd=(12)==(17), (17)==(12)]
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:4!null i:5
 │    │    │    │    ├── key: (4)
 │    │    │    │    └── fd: (4)-->(5)
 │    │    │    └── filters (true)
 │    │    └── aggregations
 │    │         ├── max [as=max:16, outer=(11)]
 │    │         │    └── i:11
 │    │         ├── const-agg [as=i:5, outer=(5)]
 │    │         │    └── i:5
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── i:5 = max:16 [outer=(5,16), constraints=(/5: (/NULL - ]; /16: (/NULL - ]), fd=(5)==(16), (16)==(5)]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Right input of SemiJoin is DistinctOn.
norm expect=TryDecorrelateSemiJoin
SELECT *
FROM xy
WHERE EXISTS
(
    SELECT * FROM (SELECT DISTINCT ON (f) i FROM a WHERE y > f) WHERE x=i
)
----
group-by
 ├── columns: x:1!null y:2!null
 ├── grouping columns: x:1!null
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── select
 │    ├── columns: x:1!null y:2!null i:5!null f:6!null
 │    ├── key: (1,6)
 │    ├── fd: (1)-->(2), (1,6)-->(2,5), (1)==(5), (5)==(1)
 │    ├── distinct-on
 │    │    ├── columns: x:1!null y:2!null i:5 f:6!null
 │    │    ├── grouping columns: x:1!null f:6!null
 │    │    ├── key: (1,6)
 │    │    ├── fd: (1)-->(2), (1,6)-->(2,5)
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null y:2!null i:5 f:6!null
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null y:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    └── columns: i:5 f:6
 │    │    │    └── filters
 │    │    │         └── y:2 > f:6 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ])]
 │    │    └── aggregations
 │    │         ├── first-agg [as=i:5, outer=(5)]
 │    │         │    └── i:5
 │    │         └── const-agg [as=y:2, outer=(2)]
 │    │              └── y:2
 │    └── filters
 │         └── x:1 = i:5 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Right input of SemiJoin is Project.
norm expect=TryDecorrelateSemiJoin
SELECT k FROM a
WHERE EXISTS
(
    SELECT * FROM xy INNER JOIN (SELECT coalesce(u, 10) AS computed FROM uv WHERE u=i) ON x=computed
)
----
project
 ├── columns: k:1!null
 ├── key: (1)
 └── select
      ├── columns: k:1!null x:7!null computed:13!null
      ├── key: (1)
      ├── fd: (1)-->(13), (7)==(13), (13)==(7)
      ├── project
      │    ├── columns: computed:13 k:1!null x:7!null
      │    ├── key: (1,7)
      │    ├── fd: (1)-->(13)
      │    ├── inner-join (cross)
      │    │    ├── columns: k:1!null i:2!null x:7!null u:10!null
      │    │    ├── key: (1,7)
      │    │    ├── fd: (1)-->(2), (2)==(10), (10)==(2)
      │    │    ├── inner-join (hash)
      │    │    │    ├── columns: k:1!null i:2!null u:10!null
      │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2), (2)==(10), (10)==(2)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── filters
      │    │    │         └── u:10 = i:2 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
      │    │    ├── scan xy
      │    │    │    ├── columns: x:7!null
      │    │    │    └── key: (7)
      │    │    └── filters (true)
      │    └── projections
      │         └── COALESCE(u:10, 10) [as=computed:13, outer=(10)]
      └── filters
           └── x:7 = computed:13 [outer=(7,13), constraints=(/7: (/NULL - ]; /13: (/NULL - ]), fd=(7)==(13), (13)==(7)]

# Right input of SemiJoin is ProjectSet.
norm expect=TryDecorrelateSemiJoin
SELECT * FROM xy WHERE EXISTS(SELECT generate_series(x, 10), generate_series(y, 10))
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── project-set
 │    ├── columns: x:1!null y:2 generate_series:4 generate_series:5
 │    ├── immutable
 │    ├── fd: (1)-->(2)
 │    ├── scan xy
 │    │    ├── columns: x:1!null y:2
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2)
 │    └── zip
 │         ├── generate_series(x:1, 10) [outer=(1), immutable]
 │         └── generate_series(y:2, 10) [outer=(2), immutable]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# --------------------------------------------------
# TryDecorrelateLimitOne
# --------------------------------------------------

# With inner join.
norm expect=TryDecorrelateLimitOne
SELECT *
FROM a
WHERE EXISTS
(
    SELECT x
    FROM xy
    INNER JOIN (SELECT * FROM uv WHERE v=i LIMIT 1)
    ON x=u
)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── inner-join (hash)
 │    ├── columns: x:7!null u:10!null v:11
 │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    ├── key: (10)
 │    ├── fd: (10)-->(11), (7)==(10), (10)==(7)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── scan uv
 │    │    ├── columns: u:10!null v:11
 │    │    ├── key: (10)
 │    │    └── fd: (10)-->(11)
 │    └── filters
 │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 └── filters
      └── v:11 = i:2 [outer=(2,11), constraints=(/2: (/NULL - ]; /11: (/NULL - ]), fd=(2)==(11), (11)==(2)]

# With left join.
norm expect=TryDecorrelateLimitOne
SELECT (SELECT x FROM xy WHERE y=i LIMIT 1) FROM a
----
project
 ├── columns: x:10
 ├── distinct-on
 │    ├── columns: k:1!null xy.x:7
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(7)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 xy.x:7 y:8
 │    │    ├── key: (1,7)
 │    │    ├── fd: (1)-->(2), (7)-->(8)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:7!null y:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    └── filters
 │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:7, outer=(7)]
 │              └── xy.x:7
 └── projections
      └── xy.x:7 [as=x:10, outer=(7)]

# With multiple limited queries.
norm expect=TryDecorrelateLimitOne
SELECT * FROM a WHERE (SELECT x FROM xy WHERE y=i LIMIT 1)=k AND (SELECT u FROM uv WHERE v=i LIMIT 1)=k
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:10!null
      ├── key: (1)
      ├── fd: (1)-->(2-5), (1)==(10), (10)==(1)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 u:10
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,10)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null u:10 v:11
      │    │    ├── key: (1,10)
      │    │    ├── fd: (1)-->(2-5), (1)==(7), (7)==(1), (10)-->(11)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5), (1)==(7), (7)==(1)
      │    │    │    ├── distinct-on
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7
      │    │    │    │    ├── grouping columns: k:1!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    ├── fd: (1)-->(2-5,7)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7 y:8
      │    │    │    │    │    ├── key: (1,7)
      │    │    │    │    │    ├── fd: (1)-->(2-5), (7)-->(8)
      │    │    │    │    │    ├── scan a
      │    │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │    │    │         │    └── i:2
      │    │    │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │    │    │         │    └── f:3
      │    │    │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │    │    │         │    └── s:4
      │    │    │    │         ├── const-agg [as=j:5, outer=(5)]
      │    │    │    │         │    └── j:5
      │    │    │    │         └── first-agg [as=x:7, outer=(7)]
      │    │    │    │              └── x:7
      │    │    │    └── filters
      │    │    │         └── k:1 = x:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    │    ├── scan uv
      │    │    │    ├── columns: u:10!null v:11
      │    │    │    ├── key: (10)
      │    │    │    └── fd: (10)-->(11)
      │    │    └── filters
      │    │         └── v:11 = i:2 [outer=(2,11), constraints=(/2: (/NULL - ]; /11: (/NULL - ]), fd=(2)==(11), (11)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=u:10, outer=(10)]
      │              └── u:10
      └── filters
           └── k:1 = u:10 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]

# With nested limited queries.
norm expect=TryDecorrelateLimitOne
SELECT *
FROM a
WHERE
(
    SELECT x
    FROM xy
    WHERE y=i AND
    (
        SELECT u FROM uv WHERE v=y LIMIT 1
    )=x
    LIMIT 1
)=k
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null
      ├── key: (1)
      ├── fd: (1)-->(2-5), (1)==(7), (7)==(1)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,7)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7 y:8 u:10
      │    │    ├── key: (1,7)
      │    │    ├── fd: (1)-->(2-5), (7)-->(8), (7)==(10), (10)==(7)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── select
      │    │    │    ├── columns: x:7!null y:8 u:10!null
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: (7)-->(8), (7)==(10), (10)==(7)
      │    │    │    ├── distinct-on
      │    │    │    │    ├── columns: x:7!null y:8 u:10
      │    │    │    │    ├── grouping columns: x:7!null
      │    │    │    │    ├── key: (7)
      │    │    │    │    ├── fd: (7)-->(8,10)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: x:7!null y:8 u:10 v:11
      │    │    │    │    │    ├── key: (7,10)
      │    │    │    │    │    ├── fd: (7)-->(8), (10)-->(11)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    │    ├── scan uv
      │    │    │    │    │    │    ├── columns: u:10!null v:11
      │    │    │    │    │    │    ├── key: (10)
      │    │    │    │    │    │    └── fd: (10)-->(11)
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── v:11 = y:8 [outer=(8,11), constraints=(/8: (/NULL - ]; /11: (/NULL - ]), fd=(8)==(11), (11)==(8)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── const-agg [as=y:8, outer=(8)]
      │    │    │    │         │    └── y:8
      │    │    │    │         └── first-agg [as=u:10, outer=(10)]
      │    │    │    │              └── u:10
      │    │    │    └── filters
      │    │    │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
      │    │    └── filters
      │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=x:7, outer=(7)]
      │              └── x:7
      └── filters
           └── k:1 = x:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# With inner join + ORDER BY.
norm expect=TryDecorrelateLimitOne
SELECT
(
    SELECT v
    FROM uv
    INNER JOIN (SELECT * FROM a WHERE i=x ORDER BY f LIMIT 1)
    ON u=k
    LIMIT 1
)
FROM xy
----
project
 ├── columns: v:13
 ├── distinct-on
 │    ├── columns: x:1!null uv.v:5
 │    ├── grouping columns: x:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(5)
 │    ├── left-join (hash)
 │    │    ├── columns: x:1!null u:4 uv.v:5 k:7 i:8
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── key: (1,7)
 │    │    ├── fd: (4)-->(5), (7)-->(8), (4)==(7), (7)==(4)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null
 │    │    │    └── key: (1)
 │    │    ├── inner-join (hash)
 │    │    │    ├── columns: u:4!null uv.v:5 k:7!null i:8
 │    │    │    ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (4)-->(5), (7)-->(8), (4)==(7), (7)==(4)
 │    │    │    ├── scan uv
 │    │    │    │    ├── columns: u:4!null uv.v:5
 │    │    │    │    ├── key: (4)
 │    │    │    │    └── fd: (4)-->(5)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:7!null i:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(8)
 │    │    │    └── filters
 │    │    │         └── u:4 = k:7 [outer=(4,7), constraints=(/4: (/NULL - ]; /7: (/NULL - ]), fd=(4)==(7), (7)==(4)]
 │    │    └── filters
 │    │         └── i:8 = x:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── aggregations
 │         └── first-agg [as=uv.v:5, outer=(5)]
 │              └── uv.v:5
 └── projections
      └── uv.v:5 [as=v:13, outer=(5)]

# With left join + ORDER BY.
norm expect=TryDecorrelateLimitOne
SELECT * FROM xy WHERE (SELECT k FROM a WHERE i=y ORDER BY f,s LIMIT 1)=x
----
project
 ├── columns: x:1!null y:2
 ├── key: (1)
 ├── fd: (1)-->(2)
 └── select
      ├── columns: x:1!null y:2 k:4!null
      ├── key: (1)
      ├── fd: (1)-->(2), (1)==(4), (4)==(1)
      ├── distinct-on
      │    ├── columns: x:1!null y:2 k:4
      │    ├── grouping columns: x:1!null
      │    ├── internal-ordering: +6,+7
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,4)
      │    ├── sort
      │    │    ├── columns: x:1!null y:2 k:4 i:5 f:6 s:7
      │    │    ├── key: (1,4)
      │    │    ├── fd: (1)-->(2), (4)-->(5-7)
      │    │    ├── ordering: +6,+7
      │    │    └── left-join (hash)
      │    │         ├── columns: x:1!null y:2 k:4 i:5 f:6 s:7
      │    │         ├── key: (1,4)
      │    │         ├── fd: (1)-->(2), (4)-->(5-7)
      │    │         ├── scan xy
      │    │         │    ├── columns: x:1!null y:2
      │    │         │    ├── key: (1)
      │    │         │    └── fd: (1)-->(2)
      │    │         ├── scan a
      │    │         │    ├── columns: k:4!null i:5 f:6 s:7
      │    │         │    ├── key: (4)
      │    │         │    └── fd: (4)-->(5-7)
      │    │         └── filters
      │    │              └── i:5 = y:2 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── first-agg [as=k:4, outer=(4)]
      │              └── k:4
      └── filters
           └── x:1 = k:4 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]

# --------------------------------------------------
# TryDecorrelateMax1Row
# --------------------------------------------------

# Rule is activated on LeftJoinApply.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT d FROM cd WHERE d=x) FROM xy
----
project
 ├── columns: d:7
 ├── ensure-distinct-on
 │    ├── columns: x:1!null cd.d:5
 │    ├── grouping columns: x:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(5)
 │    ├── left-join (hash)
 │    │    ├── columns: x:1!null cd.d:5
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── scan xy
 │    │    │    ├── columns: x:1!null
 │    │    │    └── key: (1)
 │    │    ├── scan cd
 │    │    │    └── columns: cd.d:5!null
 │    │    └── filters
 │    │         └── cd.d:5 = x:1 [outer=(1,5), constraints=(/1: (/NULL - ]; /5: (/NULL - ]), fd=(1)==(5), (5)==(1)]
 │    └── aggregations
 │         └── const-agg [as=cd.d:5, outer=(5)]
 │              └── cd.d:5
 └── projections
      └── cd.d:5 [as=d:7, outer=(5)]

# Rule is activated on LeftJoinApply.
# Case without a primary key on left side of join.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM (SELECT y FROM xy) WHERE 5 = (SELECT d FROM cd WHERE d=y)
----
project
 ├── columns: y:2
 └── select
      ├── columns: x:1!null y:2 d:5!null
      ├── key: (1)
      ├── fd: ()-->(5), (1)-->(2)
      ├── ensure-distinct-on
      │    ├── columns: x:1!null y:2 d:5
      │    ├── grouping columns: x:1!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── key: (1)
      │    ├── fd: (1)-->(2,5)
      │    ├── left-join (hash)
      │    │    ├── columns: x:1!null y:2 d:5
      │    │    ├── fd: (1)-->(2)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:1!null y:2
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2)
      │    │    ├── scan cd
      │    │    │    └── columns: d:5!null
      │    │    └── filters
      │    │         └── d:5 = y:2 [outer=(2,5), constraints=(/2: (/NULL - ]; /5: (/NULL - ]), fd=(2)==(5), (5)==(2)]
      │    └── aggregations
      │         ├── const-agg [as=y:2, outer=(2)]
      │         │    └── y:2
      │         └── const-agg [as=d:5, outer=(5)]
      │              └── d:5
      └── filters
           └── d:5 = 5 [outer=(5), constraints=(/5: [/5 - /5]; tight), fd=()-->(5)]

# Rule is activated on LeftJoinApply.
# Case with multiple projected columns that will be translated to multiple
# const-agg functions.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT d FROM cd WHERE d=k), i, f, s, j FROM a
----
project
 ├── columns: d:10 i:2 f:3 s:4 j:5
 ├── ensure-distinct-on
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5 cd.d:8
 │    ├── grouping columns: k:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5,8)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 cd.d:8
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── fd: (1)-->(2-5)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2-5)
 │    │    ├── scan cd
 │    │    │    └── columns: cd.d:8!null
 │    │    └── filters
 │    │         └── cd.d:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
 │    └── aggregations
 │         ├── const-agg [as=i:2, outer=(2)]
 │         │    └── i:2
 │         ├── const-agg [as=f:3, outer=(3)]
 │         │    └── f:3
 │         ├── const-agg [as=s:4, outer=(4)]
 │         │    └── s:4
 │         ├── const-agg [as=j:5, outer=(5)]
 │         │    └── j:5
 │         └── const-agg [as=cd.d:8, outer=(8)]
 │              └── cd.d:8
 └── projections
      └── cd.d:8 [as=d:10, outer=(8)]

# Rule is activated on LeftJoin.
# This test is a bit fragile because it depends on DecorrelateJoin activating
# before TryDecorrelateMax1Row.
# A LeftJoin is used because subquery cardinality might be zero.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM a LEFT JOIN LATERAL (SELECT * FROM uv WHERE (SELECT true FROM xy WHERE y=i)) ON true
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5 u:7 v:8
 ├── key: (1,7)
 ├── fd: (1)-->(2-5), (1,7)-->(8)
 └── left-join-apply
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:7 v:8 bool:13
      ├── key: (1,7)
      ├── fd: (1)-->(2-5), (1,7)-->(8,13)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── ensure-distinct-on
      │    ├── columns: u:7!null v:8 bool:13
      │    ├── grouping columns: u:7!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── outer: (2)
      │    ├── key: (7)
      │    ├── fd: (7)-->(8,13)
      │    ├── left-join (cross)
      │    │    ├── columns: u:7!null v:8 bool:13
      │    │    ├── outer: (2)
      │    │    ├── fd: (7)-->(8)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:7!null v:8
      │    │    │    ├── key: (7)
      │    │    │    └── fd: (7)-->(8)
      │    │    ├── project
      │    │    │    ├── columns: bool:13!null
      │    │    │    ├── outer: (2)
      │    │    │    ├── fd: ()-->(13)
      │    │    │    ├── select
      │    │    │    │    ├── columns: y:11!null
      │    │    │    │    ├── outer: (2)
      │    │    │    │    ├── fd: ()-->(11)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    └── columns: y:11
      │    │    │    │    └── filters
      │    │    │    │         └── y:11 = i:2 [outer=(2,11), constraints=(/2: (/NULL - ]; /11: (/NULL - ]), fd=(2)==(11), (11)==(2)]
      │    │    │    └── projections
      │    │    │         └── true [as=bool:13]
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── const-agg [as=v:8, outer=(8)]
      │         │    └── v:8
      │         └── const-agg [as=bool:13, outer=(13)]
      │              └── bool:13
      └── filters
           └── bool:13 [outer=(13), constraints=(/13: [/true - /true]; tight), fd=()-->(13)]

# Rule is activated on InnerJoinApply.
# An InnerJoinApply is used because subquery cardinality is guaranteed to be
# greater than zero.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT (SELECT t=x FROM (VALUES (1), (2)) f(t)) FROM xy
----
project
 ├── columns: "?column?":6!null
 ├── ensure-distinct-on
 │    ├── columns: x:1!null "?column?":5!null
 │    ├── grouping columns: x:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── key: (1)
 │    ├── fd: (1)-->(5)
 │    ├── project
 │    │    ├── columns: "?column?":5!null x:1!null
 │    │    ├── inner-join (cross)
 │    │    │    ├── columns: x:1!null column1:4!null
 │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:1!null
 │    │    │    │    └── key: (1)
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:4!null
 │    │    │    │    ├── cardinality: [2 - 2]
 │    │    │    │    ├── (1,)
 │    │    │    │    └── (2,)
 │    │    │    └── filters (true)
 │    │    └── projections
 │    │         └── column1:4 = x:1 [as="?column?":5, outer=(1,4)]
 │    └── aggregations
 │         └── const-agg [as="?column?":5, outer=(5)]
 │              └── "?column?":5
 └── projections
      └── "?column?":5 [as="?column?":6, outer=(5)]

# Rule is activated on InnerJoin.
# This test is a bit fragile because it depends on DecorrelateJoin activating
# before TryDecorrelateMax1Row.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT * FROM a LEFT JOIN LATERAL (SELECT * FROM uv WHERE (SELECT y=i FROM (VALUES (1), (2)) v(y))) ON true
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5 u:7 v:8
 ├── key: (1,7)
 ├── fd: (1)-->(2-5), (1,7)-->(8)
 └── left-join-apply
      ├── columns: k:1!null i:2 f:3 s:4 j:5 u:7 v:8 "?column?":11
      ├── key: (1,7)
      ├── fd: (1)-->(2-5), (1,7)-->(8,11)
      ├── scan a
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    └── fd: (1)-->(2-5)
      ├── ensure-distinct-on
      │    ├── columns: u:7!null v:8 "?column?":11
      │    ├── grouping columns: u:7!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── outer: (2)
      │    ├── key: (7)
      │    ├── fd: (7)-->(8,11)
      │    ├── project
      │    │    ├── columns: "?column?":11 u:7!null v:8
      │    │    ├── outer: (2)
      │    │    ├── fd: (7)-->(8)
      │    │    ├── inner-join (cross)
      │    │    │    ├── columns: u:7!null v:8 column1:10!null
      │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-more)
      │    │    │    ├── fd: (7)-->(8)
      │    │    │    ├── scan uv
      │    │    │    │    ├── columns: u:7!null v:8
      │    │    │    │    ├── key: (7)
      │    │    │    │    └── fd: (7)-->(8)
      │    │    │    ├── values
      │    │    │    │    ├── columns: column1:10!null
      │    │    │    │    ├── cardinality: [2 - 2]
      │    │    │    │    ├── (1,)
      │    │    │    │    └── (2,)
      │    │    │    └── filters (true)
      │    │    └── projections
      │    │         └── column1:10 = i:2 [as="?column?":11, outer=(2,10)]
      │    └── aggregations
      │         ├── const-agg [as=v:8, outer=(8)]
      │         │    └── v:8
      │         └── const-agg [as="?column?":11, outer=(11)]
      │              └── "?column?":11
      └── filters
           └── "?column?":11 [outer=(11), constraints=(/11: [/true - /true]; tight), fd=()-->(11)]

# Filter (y=3) must not be pushed through EnsureDistinctOn in order to ensure
# expected error behavior.
norm format=show-miscprops expect=TryDecorrelateMax1Row
SELECT a FROM (VALUES (0), (0)) v(a) WHERE (SELECT y FROM xy WHERE x<>a)=3
----
project
 ├── columns: a:1!null
 └── select
      ├── columns: column1:1!null y:3!null rownum:5!null
      ├── key: (5)
      ├── fd: ()-->(3), (5)-->(1)
      ├── ensure-distinct-on
      │    ├── columns: column1:1!null y:3 rownum:5!null
      │    ├── grouping columns: rownum:5!null
      │    ├── error: "more than one row returned by a subquery used as an expression"
      │    ├── cardinality: [1 - ]
      │    ├── key: (5)
      │    ├── fd: (5)-->(1,3)
      │    ├── left-join (cross)
      │    │    ├── columns: column1:1!null x:2 y:3 rownum:5!null
      │    │    ├── cardinality: [2 - ]
      │    │    ├── key: (2,5)
      │    │    ├── fd: (5)-->(1), (2)-->(3)
      │    │    ├── ordinality
      │    │    │    ├── columns: column1:1!null rownum:5!null
      │    │    │    ├── cardinality: [2 - 2]
      │    │    │    ├── key: (5)
      │    │    │    ├── fd: (5)-->(1)
      │    │    │    └── values
      │    │    │         ├── columns: column1:1!null
      │    │    │         ├── cardinality: [2 - 2]
      │    │    │         ├── (0,)
      │    │    │         └── (0,)
      │    │    ├── scan xy
      │    │    │    ├── columns: x:2!null y:3
      │    │    │    ├── key: (2)
      │    │    │    └── fd: (2)-->(3)
      │    │    └── filters
      │    │         └── x:2 != column1:1 [outer=(1,2), constraints=(/1: (/NULL - ]; /2: (/NULL - ])]
      │    └── aggregations
      │         ├── const-agg [as=column1:1, outer=(1)]
      │         │    └── column1:1
      │         └── const-agg [as=y:3, outer=(3)]
      │              └── y:3
      └── filters
           └── y:3 = 3 [outer=(3), constraints=(/3: [/3 - /3]; tight), fd=()-->(3)]

# --------------------------------------------------
# HoistSelectExists
# --------------------------------------------------
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Ensure that EXISTS is hoisted even when it is one of several conjuncts.
norm expect=HoistSelectExists
SELECT * FROM a WHERE s='foo' AND EXISTS(SELECT * FROM xy WHERE x=k) AND i>1
----
semi-join (hash)
 ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 │         └── i:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Multiple Exists operators in same Select list.
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k) AND EXISTS(SELECT * FROM xy WHERE x=i)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:10 = i:2 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Don't hoist uncorrelated subqueries.
norm expect-not=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: x:7!null y:8
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(7,8)
                ├── scan xy
                │    ├── columns: x:7!null y:8
                │    ├── key: (7)
                │    ├── fd: (7)-->(8)
                │    └── limit hint: 1.00
                └── 1

# Hoist nested EXISTS.
norm expect=HoistSelectExists
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE EXISTS (SELECT * FROM uv WHERE x=u) AND x=k)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: x:7!null
 │    ├── key: (7)
 │    ├── scan xy
 │    │    ├── columns: x:7!null
 │    │    └── key: (7)
 │    ├── scan uv
 │    │    ├── columns: u:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:7 = u:10 [outer=(7,10), constraints=(/7: (/NULL - ]; /10: (/NULL - ]), fd=(7)==(10), (10)==(7)]
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# --------------------------------------------------
# HoistSelectNotExists
# --------------------------------------------------
norm expect=HoistSelectNotExists
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Ensure that NOT EXISTS is hoisted even when one of several conjuncts.
norm expect=HoistSelectNotExists
SELECT * FROM a WHERE s='foo' AND NOT EXISTS(SELECT * FROM xy WHERE x=k) AND i>1
----
anti-join (hash)
 ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 ├── key: (1)
 ├── fd: ()-->(4), (1)-->(2,3,5)
 ├── select
 │    ├── columns: k:1!null i:2!null f:3 s:4!null j:5
 │    ├── key: (1)
 │    ├── fd: ()-->(4), (1)-->(2,3,5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 │         └── i:2 > 1 [outer=(2), constraints=(/2: [/2 - ]; tight)]
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Multiple Not Exists operators in same Select list.
norm expect=HoistSelectNotExists
SELECT *
FROM a
WHERE NOT EXISTS(SELECT * FROM xy WHERE x=k) AND NOT EXISTS(SELECT * FROM xy WHERE x=i)
----
anti-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:10 = i:2 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# Don't hoist uncorrelated subqueries.
norm expect-not=HoistSelectNotExists
SELECT * FROM a WHERE NOT EXISTS(SELECT * FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── not [subquery]
           └── exists
                └── limit
                     ├── columns: x:7!null y:8
                     ├── cardinality: [0 - 1]
                     ├── key: ()
                     ├── fd: ()-->(7,8)
                     ├── scan xy
                     │    ├── columns: x:7!null y:8
                     │    ├── key: (7)
                     │    ├── fd: (7)-->(8)
                     │    └── limit hint: 1.00
                     └── 1

# --------------------------------------------------
# HoistSelectExists + HoistSelectNotExists
# --------------------------------------------------
norm expect=(HoistSelectExists,HoistSelectNotExists)
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy WHERE x=k) AND NOT EXISTS(SELECT * FROM xy WHERE x=i)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan xy
 │    │    ├── columns: x:10!null
 │    │    └── key: (10)
 │    └── filters
 │         └── x:10 = i:2 [outer=(2,10), constraints=(/2: (/NULL - ]; /10: (/NULL - ]), fd=(2)==(10), (10)==(2)]
 ├── scan xy
 │    ├── columns: x:7!null
 │    └── key: (7)
 └── filters
      └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# --------------------------------------------------
# HoistSelectSubquery
# --------------------------------------------------
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (SELECT y FROM xy WHERE y=k LIMIT 1) = i
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:8!null
      ├── key: (1)
      ├── fd: (1)-->(2-5,8), (2)==(8), (8)==(2)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,8)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: (1)-->(2-5)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── scan xy
      │    │    │    └── columns: y:8
      │    │    └── filters
      │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=y:8, outer=(8)]
      │              └── y:8
      └── filters
           └── i:2 = y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]

# Multiple other conjuncts, including uncorrelated subquery (don't hoist).
norm expect=HoistSelectSubquery disable=InlineConstVar
SELECT *
FROM a
WHERE k=10 AND (SELECT y FROM xy WHERE y=k LIMIT 1) = i AND (SELECT x FROM xy LIMIT 1) = 100
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:8!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(1-5,8), (8)==(2), (2)==(8)
      ├── limit
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1-5,8)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: ()-->(1-5)
      │    │    ├── limit hint: 1.00
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── cardinality: [0 - 1]
      │    │    │    ├── key: ()
      │    │    │    ├── fd: ()-->(1-5)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    └── filters
      │    │    │         ├── k:1 = 10 [outer=(1), constraints=(/1: [/10 - /10]; tight), fd=()-->(1)]
      │    │    │         └── eq [subquery]
      │    │    │              ├── subquery
      │    │    │              │    └── limit
      │    │    │              │         ├── columns: x:10!null
      │    │    │              │         ├── cardinality: [0 - 1]
      │    │    │              │         ├── key: ()
      │    │    │              │         ├── fd: ()-->(10)
      │    │    │              │         ├── scan xy
      │    │    │              │         │    ├── columns: x:10!null
      │    │    │              │         │    ├── key: (10)
      │    │    │              │         │    └── limit hint: 1.00
      │    │    │              │         └── 1
      │    │    │              └── 100
      │    │    ├── select
      │    │    │    ├── columns: y:8!null
      │    │    │    ├── fd: ()-->(8)
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:8
      │    │    │    └── filters
      │    │    │         ├── y:8 = 10 [outer=(8), constraints=(/8: [/10 - /10]; tight), fd=()-->(8)]
      │    │    │         └── eq [subquery]
      │    │    │              ├── subquery
      │    │    │              │    └── limit
      │    │    │              │         ├── columns: x:10!null
      │    │    │              │         ├── cardinality: [0 - 1]
      │    │    │              │         ├── key: ()
      │    │    │              │         ├── fd: ()-->(10)
      │    │    │              │         ├── scan xy
      │    │    │              │         │    ├── columns: x:10!null
      │    │    │              │         │    ├── key: (10)
      │    │    │              │         │    └── limit hint: 1.00
      │    │    │              │         └── 1
      │    │    │              └── 100
      │    │    └── filters
      │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    └── 1
      └── filters
           └── i:2 = y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]

# Multiple correlated subqueries.
norm expect=HoistSelectSubquery
SELECT * FROM a
WHERE (SELECT count(*) FROM xy WHERE y=k) > 0 AND (SELECT y FROM xy WHERE y=k LIMIT 1) = i
----
project
 ├── columns: k:1!null i:2!null f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2!null f:3 s:4 j:5 y:12!null
      ├── key: (1)
      ├── fd: (1)-->(2-5,12), (2)==(12), (12)==(2)
      ├── distinct-on
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:12
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,12)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:10!null y:12
      │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    ├── fd: (1)-->(2-5,10)
      │    │    ├── select
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:10!null
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5,10)
      │    │    │    ├── group-by
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:10!null
      │    │    │    │    ├── grouping columns: k:1!null
      │    │    │    │    ├── key: (1)
      │    │    │    │    ├── fd: (1)-->(2-5,10)
      │    │    │    │    ├── left-join (hash)
      │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8
      │    │    │    │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
      │    │    │    │    │    ├── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan a
      │    │    │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    │    │    ├── scan xy
      │    │    │    │    │    │    └── columns: y:8
      │    │    │    │    │    └── filters
      │    │    │    │    │         └── y:8 = k:1 [outer=(1,8), constraints=(/1: (/NULL - ]; /8: (/NULL - ]), fd=(1)==(8), (8)==(1)]
      │    │    │    │    └── aggregations
      │    │    │    │         ├── count [as=count_rows:10, outer=(8)]
      │    │    │    │         │    └── y:8
      │    │    │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │    │    │         │    └── i:2
      │    │    │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │    │    │         │    └── f:3
      │    │    │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │    │    │         │    └── s:4
      │    │    │    │         └── const-agg [as=j:5, outer=(5)]
      │    │    │    │              └── j:5
      │    │    │    └── filters
      │    │    │         └── count_rows:10 > 0 [outer=(10), constraints=(/10: [/1 - ]; tight)]
      │    │    ├── scan xy
      │    │    │    └── columns: y:12
      │    │    └── filters
      │    │         └── y:12 = k:1 [outer=(1,12), constraints=(/1: (/NULL - ]; /12: (/NULL - ]), fd=(1)==(12), (12)==(1)]
      │    └── aggregations
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         ├── const-agg [as=j:5, outer=(5)]
      │         │    └── j:5
      │         └── first-agg [as=y:12, outer=(12)]
      │              └── y:12
      └── filters
           └── i:2 = y:12 [outer=(2,12), constraints=(/2: (/NULL - ]; /12: (/NULL - ]), fd=(2)==(12), (12)==(2)]

# Subquery nested below interesting scalar operators like cast, function, tuple,
# or, etc).
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (0, length((SELECT count(*) FROM uv WHERE k=u)::string)) > (0, 1) OR i=1
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:10!null
      ├── immutable
      ├── key: (1)
      ├── fd: (1)-->(2-5,10)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 count_rows:10!null
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,10)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 u:7
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,7)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── scan uv
      │    │    │    ├── columns: u:7!null
      │    │    │    └── key: (7)
      │    │    └── filters
      │    │         └── k:1 = u:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    └── aggregations
      │         ├── count [as=count_rows:10, outer=(7)]
      │         │    └── u:7
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── ((0, length(count_rows:10::STRING)) > (0, 1)) OR (i:2 = 1) [outer=(2,10), immutable]

# Exists within a disjunction.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE i=1 OR EXISTS(SELECT * FROM xy WHERE y=i)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:11
      ├── key: (1)
      ├── fd: (1)-->(2-5,11)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:11
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,11)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 y:8 true:10
      │    │    ├── fd: (1)-->(2-5)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── project
      │    │    │    ├── columns: true:10!null y:8
      │    │    │    ├── fd: ()-->(10)
      │    │    │    ├── scan xy
      │    │    │    │    └── columns: y:8
      │    │    │    └── projections
      │    │    │         └── true [as=true:10]
      │    │    └── filters
      │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:11, outer=(10)]
      │         │    └── true:10
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── (i:2 = 1) OR (true_agg:11 IS NOT NULL) [outer=(2,11)]

# Any with IS NULL.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE (i = ANY(SELECT y FROM xy WHERE x=k)) IS NULL
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 case:12
      ├── key: (1)
      ├── fd: ()-->(12), (1)-->(2-5)
      ├── project
      │    ├── columns: case:12 k:1!null i:2 f:3 s:4 j:5
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,12)
      │    ├── group-by
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 bool_or:11
      │    │    ├── grouping columns: k:1!null
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,11)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7 y:8 notnull:10
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    │    ├── key: (1)
      │    │    │    ├── fd: (1)-->(2-5,7,8,10), (7)-->(8), (8)~~>(10)
      │    │    │    ├── scan a
      │    │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    │    ├── key: (1)
      │    │    │    │    └── fd: (1)-->(2-5)
      │    │    │    ├── project
      │    │    │    │    ├── columns: notnull:10!null x:7!null y:8
      │    │    │    │    ├── key: (7)
      │    │    │    │    ├── fd: (7)-->(8), (8)-->(10)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    └── projections
      │    │    │    │         └── y:8 IS NOT NULL [as=notnull:10, outer=(8)]
      │    │    │    └── filters
      │    │    │         ├── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │    │    │         └── (i:2 = y:8) IS NOT false [outer=(2,8)]
      │    │    └── aggregations
      │    │         ├── bool-or [as=bool_or:11, outer=(10)]
      │    │         │    └── notnull:10
      │    │         ├── const-agg [as=i:2, outer=(2)]
      │    │         │    └── i:2
      │    │         ├── const-agg [as=f:3, outer=(3)]
      │    │         │    └── f:3
      │    │         ├── const-agg [as=s:4, outer=(4)]
      │    │         │    └── s:4
      │    │         └── const-agg [as=j:5, outer=(5)]
      │    │              └── j:5
      │    └── projections
      │         └── CASE WHEN bool_or:11 AND (i:2 IS NOT NULL) THEN true WHEN bool_or:11 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=case:12, outer=(2,11)]
      └── filters
           └── case:12 IS NULL [outer=(12), constraints=(/12: [/NULL - /NULL]; tight), fd=()-->(12)]

# Any with uncorrelated subquery (should not be hoisted).
norm
SELECT * FROM a WHERE (i = ANY(SELECT y FROM xy)) IS NULL
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── is [outer=(2), correlated-subquery]
           ├── any: eq
           │    ├── scan xy
           │    │    └── columns: y:8
           │    └── i:2
           └── NULL

# ALL with non-trivial expression on left.
norm
SELECT i*i/100 < ALL(SELECT y FROM xy WHERE x=k) AS r, s FROM a
----
project
 ├── columns: r:10 s:4
 ├── immutable
 ├── group-by
 │    ├── columns: k:1!null s:4 scalar:11 bool_or:13
 │    ├── grouping columns: k:1!null
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(4,11,13)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null s:4 x:7 y:8 scalar:11 notnull:12
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── immutable
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(4,7,8,11,12), (7)-->(8), (8)~~>(12)
 │    │    ├── project
 │    │    │    ├── columns: scalar:11 k:1!null s:4
 │    │    │    ├── immutable
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(4,11)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2 s:4
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2,4)
 │    │    │    └── projections
 │    │    │         └── (i:2 * i:2) / 100 [as=scalar:11, outer=(2), immutable]
 │    │    ├── project
 │    │    │    ├── columns: notnull:12!null x:7!null y:8
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(8), (8)-->(12)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    └── fd: (7)-->(8)
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:12, outer=(8)]
 │    │    └── filters
 │    │         ├── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │         └── (scalar:11 >= y:8) IS NOT false [outer=(8,11)]
 │    └── aggregations
 │         ├── bool-or [as=bool_or:13, outer=(12)]
 │         │    └── notnull:12
 │         ├── const-agg [as=s:4, outer=(4)]
 │         │    └── s:4
 │         └── const-agg [as=scalar:11, outer=(11)]
 │              └── scalar:11
 └── projections
      └── NOT CASE WHEN bool_or:13 AND (scalar:11 IS NOT NULL) THEN true WHEN bool_or:13 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(11,13), immutable]

# Regress issue #32270: Panic when expression contains both correlated and
# uncorrelated subquery.
norm expect=HoistSelectSubquery
SELECT * FROM a WHERE EXISTS(SELECT * FROM xy) OR EXISTS(SELECT * FROM xy WHERE x=k)
----
project
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 └── select
      ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:14
      ├── key: (1)
      ├── fd: (1)-->(2-5,14)
      ├── group-by
      │    ├── columns: k:1!null i:2 f:3 s:4 j:5 true_agg:14
      │    ├── grouping columns: k:1!null
      │    ├── key: (1)
      │    ├── fd: (1)-->(2-5,14)
      │    ├── left-join (hash)
      │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5 x:10 true:13
      │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │    │    ├── key: (1)
      │    │    ├── fd: (1)-->(2-5,10,13)
      │    │    ├── scan a
      │    │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-5)
      │    │    ├── project
      │    │    │    ├── columns: true:13!null x:10!null
      │    │    │    ├── key: (10)
      │    │    │    ├── fd: ()-->(13)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:10!null
      │    │    │    │    └── key: (10)
      │    │    │    └── projections
      │    │    │         └── true [as=true:13]
      │    │    └── filters
      │    │         └── x:10 = k:1 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:14, outer=(13)]
      │         │    └── true:13
      │         ├── const-agg [as=i:2, outer=(2)]
      │         │    └── i:2
      │         ├── const-agg [as=f:3, outer=(3)]
      │         │    └── f:3
      │         ├── const-agg [as=s:4, outer=(4)]
      │         │    └── s:4
      │         └── const-agg [as=j:5, outer=(5)]
      │              └── j:5
      └── filters
           └── or [outer=(14), subquery]
                ├── exists
                │    └── limit
                │         ├── columns: x:7!null y:8
                │         ├── cardinality: [0 - 1]
                │         ├── key: ()
                │         ├── fd: ()-->(7,8)
                │         ├── scan xy
                │         │    ├── columns: x:7!null y:8
                │         │    ├── key: (7)
                │         │    ├── fd: (7)-->(8)
                │         │    └── limit hint: 1.00
                │         └── 1
                └── true_agg:14 IS NOT NULL

# --------------------------------------------------
# HoistProjectSubquery
# --------------------------------------------------
norm expect=HoistProjectSubquery
SELECT (SELECT x FROM xy WHERE x=k) FROM a
----
project
 ├── columns: x:10
 ├── left-join (hash)
 │    ├── columns: k:1!null xy.x:7
 │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    ├── key: (1)
 │    ├── fd: (1)-->(7)
 │    ├── scan a
 │    │    ├── columns: k:1!null
 │    │    └── key: (1)
 │    ├── scan xy
 │    │    ├── columns: xy.x:7!null
 │    │    └── key: (7)
 │    └── filters
 │         └── xy.x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 └── projections
      └── xy.x:7 [as=x:10, outer=(7)]

# Mixed correlated and uncorrelated subqueries.
norm expect=HoistProjectSubquery
SELECT
    5 AS a,
    (SELECT x FROM xy WHERE x=k),
    (SELECT y FROM xy LIMIT 1),
    5 IN (SELECT y FROM xy) AS b,
    EXISTS(SELECT * FROM xy),
    (SELECT count(*) FROM xy WHERE y=k)
FROM a
----
project
 ├── columns: a:23!null x:24 y:25 b:26 exists:27 count:28!null
 ├── fd: ()-->(23,25-27)
 ├── group-by
 │    ├── columns: k:1!null xy.x:7 count_rows:22!null
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(7,22)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null xy.x:7 xy.y:20
 │    │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
 │    │    ├── fd: (1)-->(7)
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: k:1!null xy.x:7
 │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    │    ├── key: (1)
 │    │    │    ├── fd: (1)-->(7)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null
 │    │    │    │    └── key: (1)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: xy.x:7!null
 │    │    │    │    └── key: (7)
 │    │    │    └── filters
 │    │    │         └── xy.x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:20
 │    │    └── filters
 │    │         └── xy.y:20 = k:1 [outer=(1,20), constraints=(/1: (/NULL - ]; /20: (/NULL - ]), fd=(1)==(20), (20)==(1)]
 │    └── aggregations
 │         ├── count [as=count_rows:22, outer=(20)]
 │         │    └── xy.y:20
 │         └── const-agg [as=xy.x:7, outer=(7)]
 │              └── xy.x:7
 └── projections
      ├── 5 [as=a:23]
      ├── xy.x:7 [as=x:24, outer=(7)]
      ├── subquery [as=y:25, subquery]
      │    └── limit
      │         ├── columns: xy.y:11
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         ├── fd: ()-->(11)
      │         ├── scan xy
      │         │    ├── columns: xy.y:11
      │         │    └── limit hint: 1.00
      │         └── 1
      ├── any: eq [as=b:26, subquery]
      │    ├── scan xy
      │    │    └── columns: xy.y:14
      │    └── 5
      ├── exists [as=exists:27, subquery]
      │    └── limit
      │         ├── columns: xy.x:16!null xy.y:17
      │         ├── cardinality: [0 - 1]
      │         ├── key: ()
      │         ├── fd: ()-->(16,17)
      │         ├── scan xy
      │         │    ├── columns: xy.x:16!null xy.y:17
      │         │    ├── key: (16)
      │         │    ├── fd: (16)-->(17)
      │         │    └── limit hint: 1.00
      │         └── 1
      └── count_rows:22 [as=count:28, outer=(22)]

# Subquery in GroupBy aggregate (optbuilder creates correlated Project).
norm expect=HoistProjectSubquery
SELECT max((SELECT y FROM xy WHERE y=i)) FROM a
----
scalar-group-by
 ├── columns: max:11
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(11)
 ├── project
 │    ├── columns: column10:10
 │    ├── ensure-distinct-on
 │    │    ├── columns: k:1!null y:8
 │    │    ├── grouping columns: k:1!null
 │    │    ├── error: "more than one row returned by a subquery used as an expression"
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(8)
 │    │    ├── left-join (hash)
 │    │    │    ├── columns: k:1!null i:2 y:8
 │    │    │    ├── fd: (1)-->(2)
 │    │    │    ├── scan a
 │    │    │    │    ├── columns: k:1!null i:2
 │    │    │    │    ├── key: (1)
 │    │    │    │    └── fd: (1)-->(2)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:8
 │    │    │    └── filters
 │    │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    │    └── aggregations
 │    │         └── const-agg [as=y:8, outer=(8)]
 │    │              └── y:8
 │    └── projections
 │         └── y:8 [as=column10:10, outer=(8)]
 └── aggregations
      └── max [as=max:11, outer=(10)]
           └── column10:10

# Exists in projection list.
norm expect=HoistProjectSubquery
SELECT EXISTS(SELECT * FROM xy WHERE y=i) FROM a
----
project
 ├── columns: exists:10!null
 ├── group-by
 │    ├── columns: k:1!null true_agg:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:8 true:11
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: true:11!null y:8
 │    │    │    ├── fd: ()-->(11)
 │    │    │    ├── scan xy
 │    │    │    │    └── columns: y:8
 │    │    │    └── projections
 │    │    │         └── true [as=true:11]
 │    │    └── filters
 │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── aggregations
 │         └── const-not-null-agg [as=true_agg:12, outer=(11)]
 │              └── true:11
 └── projections
      └── true_agg:12 IS NOT NULL [as=exists:10, outer=(12)]

# Any in projection list.
norm expect=HoistProjectSubquery
SELECT 5 < ANY(SELECT y FROM xy WHERE y=i) AS r FROM a
----
project
 ├── columns: r:10
 ├── group-by
 │    ├── columns: k:1!null bool_or:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 y:8 notnull:11
 │    │    ├── fd: (1)-->(2), (8)~~>(11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── project
 │    │    │    ├── columns: notnull:11!null y:8
 │    │    │    ├── fd: (8)-->(11)
 │    │    │    ├── select
 │    │    │    │    ├── columns: y:8
 │    │    │    │    ├── scan xy
 │    │    │    │    │    └── columns: y:8
 │    │    │    │    └── filters
 │    │    │    │         └── (y:8 > 5) IS NOT false [outer=(8)]
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:11, outer=(8)]
 │    │    └── filters
 │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:12, outer=(11)]
 │              └── notnull:11
 └── projections
      └── CASE WHEN bool_or:12 THEN true WHEN bool_or:12 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=r:10, outer=(12)]

# Correlated subquery nested in uncorrelated subquery.
norm expect=HoistProjectSubquery
SELECT EXISTS(SELECT EXISTS(SELECT * FROM xy WHERE y=i) FROM a)
----
values
 ├── columns: exists:14
 ├── cardinality: [1 - 1]
 ├── key: ()
 ├── fd: ()-->(14)
 └── tuple
      └── exists
           └── limit
                ├── columns: k:1!null i:2 y:8 true:11
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(1,2,8,11)
                ├── left-join (hash)
                │    ├── columns: k:1!null i:2 y:8 true:11
                │    ├── multiplicity: left-rows(one-or-more), right-rows(zero-or-one)
                │    ├── fd: ()-->(1,2)
                │    ├── limit hint: 1.00
                │    ├── limit
                │    │    ├── columns: k:1!null i:2
                │    │    ├── cardinality: [0 - 1]
                │    │    ├── key: ()
                │    │    ├── fd: ()-->(1,2)
                │    │    ├── scan a
                │    │    │    ├── columns: k:1!null i:2
                │    │    │    ├── key: (1)
                │    │    │    ├── fd: (1)-->(2)
                │    │    │    └── limit hint: 1.00
                │    │    └── 1
                │    ├── project
                │    │    ├── columns: true:11!null y:8
                │    │    ├── fd: ()-->(11)
                │    │    ├── scan xy
                │    │    │    └── columns: y:8
                │    │    └── projections
                │    │         └── true [as=true:11]
                │    └── filters
                │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
                └── 1

# Don't hoist uncorrelated subquery.
norm
SELECT i < ANY(SELECT y FROM xy) AS r FROM a
----
project
 ├── columns: r:10
 ├── scan a
 │    └── columns: i:2
 └── projections
      └── any: lt [as=r:10, outer=(2), correlated-subquery]
           ├── scan xy
           │    └── columns: y:8
           └── i:2

# --------------------------------------------------
# HoistJoinSubquery
# --------------------------------------------------
norm expect=HoistJoinSubquery
SELECT i, y FROM a INNER JOIN xy ON (SELECT k+1) = x
----
project
 ├── columns: i:2 y:8
 ├── immutable
 └── inner-join (hash)
      ├── columns: i:2 x:7!null y:8 column11:11!null
      ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-more)
      ├── immutable
      ├── fd: (7)-->(8), (7)==(11), (11)==(7)
      ├── project
      │    ├── columns: column11:11!null i:2
      │    ├── immutable
      │    ├── scan a
      │    │    ├── columns: k:1!null i:2
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(2)
      │    └── projections
      │         └── k:1 + 1 [as=column11:11, outer=(1), immutable]
      ├── scan xy
      │    ├── columns: x:7!null y:8
      │    ├── key: (7)
      │    └── fd: (7)-->(8)
      └── filters
           └── column11:11 = x:7 [outer=(7,11), constraints=(/7: (/NULL - ]; /11: (/NULL - ]), fd=(7)==(11), (11)==(7)]

# Hoist Exists in join filter disjunction.
norm expect=HoistJoinSubquery
SELECT s, x FROM a INNER JOIN xy ON EXISTS(SELECT * FROM uv WHERE u=y) OR k=x
----
project
 ├── columns: s:4 x:7!null
 └── inner-join (cross)
      ├── columns: k:1!null s:4 x:7!null exists:15!null
      ├── key: (1,7)
      ├── fd: (1)-->(4), (7)-->(15)
      ├── scan a
      │    ├── columns: k:1!null s:4
      │    ├── key: (1)
      │    └── fd: (1)-->(4)
      ├── project
      │    ├── columns: exists:15!null x:7!null
      │    ├── key: (7)
      │    ├── fd: (7)-->(15)
      │    ├── group-by
      │    │    ├── columns: x:7!null true_agg:14
      │    │    ├── grouping columns: x:7!null
      │    │    ├── key: (7)
      │    │    ├── fd: (7)-->(14)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: x:7!null y:8 u:10 true:13
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    │    ├── key: (7)
      │    │    │    ├── fd: (7)-->(8,10,13)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    ├── key: (7)
      │    │    │    │    └── fd: (7)-->(8)
      │    │    │    ├── project
      │    │    │    │    ├── columns: true:13!null u:10!null
      │    │    │    │    ├── key: (10)
      │    │    │    │    ├── fd: ()-->(13)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:10!null
      │    │    │    │    │    └── key: (10)
      │    │    │    │    └── projections
      │    │    │    │         └── true [as=true:13]
      │    │    │    └── filters
      │    │    │         └── u:10 = y:8 [outer=(8,10), constraints=(/8: (/NULL - ]; /10: (/NULL - ]), fd=(8)==(10), (10)==(8)]
      │    │    └── aggregations
      │    │         └── const-not-null-agg [as=true_agg:14, outer=(13)]
      │    │              └── true:13
      │    └── projections
      │         └── true_agg:14 IS NOT NULL [as=exists:15, outer=(14)]
      └── filters
           └── exists:15 OR (k:1 = x:7) [outer=(1,7,15)]

# Any in Join filter disjunction.
norm expect=HoistJoinSubquery
SELECT j, y FROM a INNER JOIN xy ON x IN (SELECT v FROM uv WHERE u=y AND v=i) OR x IS NULL
----
project
 ├── columns: j:5 y:8
 └── select
      ├── columns: j:5 x:7!null y:8 case:15
      ├── fd: (7)-->(8)
      ├── project
      │    ├── columns: case:15 j:5 x:7!null y:8
      │    ├── fd: (7)-->(8)
      │    ├── group-by
      │    │    ├── columns: k:1!null j:5 x:7!null y:8 bool_or:14
      │    │    ├── grouping columns: k:1!null x:7!null
      │    │    ├── key: (1,7)
      │    │    ├── fd: (1)-->(5), (7)-->(8), (1,7)-->(5,8,14)
      │    │    ├── left-join (hash)
      │    │    │    ├── columns: k:1!null i:2 j:5 x:7!null y:8 u:10 v:11 notnull:13
      │    │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-more)
      │    │    │    ├── key: (1,7)
      │    │    │    ├── fd: (1)-->(2,5), (7)-->(8), (10)-->(11), (11)~~>(13), (1,7)-->(10,11,13)
      │    │    │    ├── inner-join (cross)
      │    │    │    │    ├── columns: k:1!null i:2 j:5 x:7!null y:8
      │    │    │    │    ├── key: (1,7)
      │    │    │    │    ├── fd: (1)-->(2,5), (7)-->(8)
      │    │    │    │    ├── scan a
      │    │    │    │    │    ├── columns: k:1!null i:2 j:5
      │    │    │    │    │    ├── key: (1)
      │    │    │    │    │    └── fd: (1)-->(2,5)
      │    │    │    │    ├── scan xy
      │    │    │    │    │    ├── columns: x:7!null y:8
      │    │    │    │    │    ├── key: (7)
      │    │    │    │    │    └── fd: (7)-->(8)
      │    │    │    │    └── filters (true)
      │    │    │    ├── project
      │    │    │    │    ├── columns: notnull:13!null u:10!null v:11
      │    │    │    │    ├── key: (10)
      │    │    │    │    ├── fd: (10)-->(11), (11)-->(13)
      │    │    │    │    ├── scan uv
      │    │    │    │    │    ├── columns: u:10!null v:11
      │    │    │    │    │    ├── key: (10)
      │    │    │    │    │    └── fd: (10)-->(11)
      │    │    │    │    └── projections
      │    │    │    │         └── v:11 IS NOT NULL [as=notnull:13, outer=(11)]
      │    │    │    └── filters
      │    │    │         ├── u:10 = y:8 [outer=(8,10), constraints=(/8: (/NULL - ]; /10: (/NULL - ]), fd=(8)==(10), (10)==(8)]
      │    │    │         ├── v:11 = i:2 [outer=(2,11), constraints=(/2: (/NULL - ]; /11: (/NULL - ]), fd=(2)==(11), (11)==(2)]
      │    │    │         └── (x:7 = v:11) IS NOT false [outer=(7,11)]
      │    │    └── aggregations
      │    │         ├── bool-or [as=bool_or:14, outer=(13)]
      │    │         │    └── notnull:13
      │    │         ├── const-agg [as=y:8, outer=(8)]
      │    │         │    └── y:8
      │    │         └── const-agg [as=j:5, outer=(5)]
      │    │              └── j:5
      │    └── projections
      │         └── CASE WHEN bool_or:14 AND (x:7 IS NOT NULL) THEN true WHEN bool_or:14 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=case:15, outer=(7,14)]
      └── filters
           └── case:15 OR (x:7 IS NULL) [outer=(7,15)]


# --------------------------------------------------
# HoistValuesSubquery
# --------------------------------------------------
norm expect=HoistValuesSubquery
SELECT (VALUES ((SELECT i+1 AS r)), (10), ((SELECT k+1 AS s))) FROM a
----
project
 ├── columns: column1:10
 ├── immutable
 ├── ensure-distinct-on
 │    ├── columns: k:1!null column1:9
 │    ├── grouping columns: k:1!null
 │    ├── error: "more than one row returned by a subquery used as an expression"
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(9)
 │    ├── inner-join-apply
 │    │    ├── columns: k:1!null i:2 r:7 s:8 column1:9
 │    │    ├── immutable
 │    │    ├── fd: (1)-->(2)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── inner-join-apply
 │    │    │    ├── columns: r:7 s:8 column1:9
 │    │    │    ├── outer: (1,2)
 │    │    │    ├── cardinality: [3 - 3]
 │    │    │    ├── immutable
 │    │    │    ├── fd: ()-->(7,8)
 │    │    │    ├── values
 │    │    │    │    ├── columns: r:7 s:8
 │    │    │    │    ├── outer: (1,2)
 │    │    │    │    ├── cardinality: [1 - 1]
 │    │    │    │    ├── immutable
 │    │    │    │    ├── key: ()
 │    │    │    │    ├── fd: ()-->(7,8)
 │    │    │    │    └── (i:2 + 1, k:1 + 1)
 │    │    │    ├── values
 │    │    │    │    ├── columns: column1:9
 │    │    │    │    ├── outer: (7,8)
 │    │    │    │    ├── cardinality: [3 - 3]
 │    │    │    │    ├── (r:7,)
 │    │    │    │    ├── (10,)
 │    │    │    │    └── (s:8,)
 │    │    │    └── filters (true)
 │    │    └── filters (true)
 │    └── aggregations
 │         └── const-agg [as=column1:9, outer=(9)]
 │              └── column1:9
 └── projections
      └── column1:9 [as=column1:10, outer=(9)]

# Exists in values row.
norm expect=HoistValuesSubquery
SELECT (VALUES (EXISTS(SELECT * FROM xy WHERE x=k))) FROM a
----
project
 ├── columns: column1:14!null
 ├── group-by
 │    ├── columns: k:1!null true_agg:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 true:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(7,11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: true:11!null x:7!null
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: ()-->(11)
 │    │    │    ├── scan xy
 │    │    │    │    ├── columns: x:7!null
 │    │    │    │    └── key: (7)
 │    │    │    └── projections
 │    │    │         └── true [as=true:11]
 │    │    └── filters
 │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         └── const-not-null-agg [as=true_agg:12, outer=(11)]
 │              └── true:11
 └── projections
      └── true_agg:12 IS NOT NULL [as=column1:14, outer=(12)]

# Any in values row.
norm expect=HoistValuesSubquery
SELECT (VALUES (5 IN (SELECT y FROM xy WHERE x=k))) FROM a
----
project
 ├── columns: column1:14
 ├── group-by
 │    ├── columns: k:1!null bool_or:12
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(12)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null x:7 notnull:11
 │    │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │    ├── key: (1)
 │    │    ├── fd: (7)-->(11), (1)-->(7,11)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null
 │    │    │    └── key: (1)
 │    │    ├── project
 │    │    │    ├── columns: notnull:11!null x:7!null
 │    │    │    ├── key: (7)
 │    │    │    ├── fd: (7)-->(11)
 │    │    │    ├── select
 │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    ├── key: (7)
 │    │    │    │    ├── fd: (7)-->(8)
 │    │    │    │    ├── scan xy
 │    │    │    │    │    ├── columns: x:7!null y:8
 │    │    │    │    │    ├── key: (7)
 │    │    │    │    │    └── fd: (7)-->(8)
 │    │    │    │    └── filters
 │    │    │    │         └── (y:8 = 5) IS NOT false [outer=(8)]
 │    │    │    └── projections
 │    │    │         └── y:8 IS NOT NULL [as=notnull:11, outer=(8)]
 │    │    └── filters
 │    │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    └── aggregations
 │         └── bool-or [as=bool_or:12, outer=(11)]
 │              └── notnull:11
 └── projections
      └── CASE WHEN bool_or:12 THEN true WHEN bool_or:12 IS NULL THEN false ELSE CAST(NULL AS BOOL) END [as=column1:14, outer=(12)]

# ---------------------------------------------------
# HoistProjectSetSubquery + TryDecorrelateProjectSet
# ---------------------------------------------------
norm expect=HoistProjectSetSubquery
SELECT generate_series(1, (SELECT v FROM uv WHERE u=x)) FROM xy
----
project
 ├── columns: generate_series:7
 ├── immutable
 └── project-set
      ├── columns: v:5 generate_series:7
      ├── immutable
      ├── project
      │    ├── columns: v:5
      │    └── left-join (hash)
      │         ├── columns: x:1!null u:4 v:5
      │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         ├── key: (1)
      │         ├── fd: (4)-->(5), (1)-->(4,5)
      │         ├── scan xy
      │         │    ├── columns: x:1!null
      │         │    └── key: (1)
      │         ├── scan uv
      │         │    ├── columns: u:4!null v:5
      │         │    ├── key: (4)
      │         │    └── fd: (4)-->(5)
      │         └── filters
      │              └── u:4 = x:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
      └── zip
           └── generate_series(1, v:5) [outer=(5), immutable]

# Zip correlation within EXISTS.
norm expect=(HoistProjectSetSubquery,TryDecorrelateSemiJoin,TryDecorrelateProjectSet)
SELECT * FROM xy WHERE EXISTS(SELECT * FROM generate_series(1, (SELECT v FROM uv WHERE u=x)))
----
group-by
 ├── columns: x:1!null y:2
 ├── grouping columns: x:1!null
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2)
 ├── project-set
 │    ├── columns: x:1!null y:2 v:5 generate_series:7
 │    ├── immutable
 │    ├── fd: (1)-->(2,5)
 │    ├── project
 │    │    ├── columns: x:1!null y:2 v:5
 │    │    ├── key: (1)
 │    │    ├── fd: (1)-->(2,5)
 │    │    └── left-join (hash)
 │    │         ├── columns: x:1!null y:2 u:4 v:5
 │    │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         ├── key: (1)
 │    │         ├── fd: (1)-->(2,4,5), (4)-->(5)
 │    │         ├── scan xy
 │    │         │    ├── columns: x:1!null y:2
 │    │         │    ├── key: (1)
 │    │         │    └── fd: (1)-->(2)
 │    │         ├── scan uv
 │    │         │    ├── columns: u:4!null v:5
 │    │         │    ├── key: (4)
 │    │         │    └── fd: (4)-->(5)
 │    │         └── filters
 │    │              └── u:4 = x:1 [outer=(1,4), constraints=(/1: (/NULL - ]; /4: (/NULL - ]), fd=(1)==(4), (4)==(1)]
 │    └── zip
 │         └── generate_series(1, v:5) [outer=(5), immutable]
 └── aggregations
      └── const-agg [as=y:2, outer=(2)]
           └── y:2

# Function contains multiple subqueries in arguments.
norm expect=HoistProjectSetSubquery
SELECT generate_series((select y FROM xy WHERE x=k), (SELECT v FROM uv WHERE u=k)) FROM a
----
project
 ├── columns: generate_series:13
 ├── immutable
 └── project-set
      ├── columns: y:8 v:11 generate_series:13
      ├── immutable
      ├── project
      │    ├── columns: y:8 v:11
      │    └── left-join (hash)
      │         ├── columns: k:1!null x:7 y:8 u:10 v:11
      │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         ├── key: (1)
      │         ├── fd: (7)-->(8), (1)-->(7,8,10,11), (10)-->(11)
      │         ├── left-join (hash)
      │         │    ├── columns: k:1!null x:7 y:8
      │         │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
      │         │    ├── key: (1)
      │         │    ├── fd: (7)-->(8), (1)-->(7,8)
      │         │    ├── scan a
      │         │    │    ├── columns: k:1!null
      │         │    │    └── key: (1)
      │         │    ├── scan xy
      │         │    │    ├── columns: x:7!null y:8
      │         │    │    ├── key: (7)
      │         │    │    └── fd: (7)-->(8)
      │         │    └── filters
      │         │         └── x:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
      │         ├── scan uv
      │         │    ├── columns: u:10!null v:11
      │         │    ├── key: (10)
      │         │    └── fd: (10)-->(11)
      │         └── filters
      │              └── u:10 = k:1 [outer=(1,10), constraints=(/1: (/NULL - ]; /10: (/NULL - ]), fd=(1)==(10), (10)==(1)]
      └── zip
           └── generate_series(y:8, v:11) [outer=(8,11), immutable]

# Multiple functions.
norm expect=HoistProjectSetSubquery
SELECT
    generate_series(1, (SELECT v FROM uv WHERE u=k)),
    information_schema._pg_expandarray(ARRAY[(SELECT x FROM xy WHERE x=k)])
FROM a
----
project
 ├── columns: generate_series:10 information_schema._pg_expandarray:16
 ├── immutable
 ├── project-set
 │    ├── columns: v:8 generate_series:10 xy.x:11 x:14 n:15
 │    ├── immutable
 │    ├── project
 │    │    ├── columns: v:8 xy.x:11
 │    │    └── left-join (hash)
 │    │         ├── columns: k:1!null u:7 v:8 xy.x:11
 │    │         ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         ├── key: (1)
 │    │         ├── fd: (7)-->(8), (1)-->(7,8,11)
 │    │         ├── left-join (hash)
 │    │         │    ├── columns: k:1!null u:7 v:8
 │    │         │    ├── multiplicity: left-rows(exactly-one), right-rows(zero-or-one)
 │    │         │    ├── key: (1)
 │    │         │    ├── fd: (7)-->(8), (1)-->(7,8)
 │    │         │    ├── scan a
 │    │         │    │    ├── columns: k:1!null
 │    │         │    │    └── key: (1)
 │    │         │    ├── scan uv
 │    │         │    │    ├── columns: u:7!null v:8
 │    │         │    │    ├── key: (7)
 │    │         │    │    └── fd: (7)-->(8)
 │    │         │    └── filters
 │    │         │         └── u:7 = k:1 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]
 │    │         ├── scan xy
 │    │         │    ├── columns: xy.x:11!null
 │    │         │    └── key: (11)
 │    │         └── filters
 │    │              └── xy.x:11 = k:1 [outer=(1,11), constraints=(/1: (/NULL - ]; /11: (/NULL - ]), fd=(1)==(11), (11)==(1)]
 │    └── zip
 │         ├── generate_series(1, v:8) [outer=(8), immutable]
 │         └── information_schema._pg_expandarray(ARRAY[xy.x:11]) [outer=(11), immutable]
 └── projections
      └── ((x:14, n:15) AS x, n) [as=information_schema._pg_expandarray:16, outer=(14,15)]

norm expect=HoistProjectSetSubquery
SELECT a, generate_series(1, (SELECT a)) FROM (VALUES (1)) AS v (a)
----
project
 ├── columns: a:1!null generate_series:3
 ├── immutable
 ├── fd: ()-->(1)
 └── project-set
      ├── columns: column1:1!null a:2!null generate_series:3
      ├── immutable
      ├── fd: ()-->(1,2)
      ├── values
      │    ├── columns: column1:1!null a:2!null
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1,2)
      │    └── (1, 1)
      └── zip
           └── generate_series(1, a:2) [outer=(2), immutable]

norm expect=HoistProjectSetSubquery
SELECT a, generate_series(1, (SELECT a)), generate_series(1, (SELECT a)) FROM (VALUES (1)) AS v (a)
----
project
 ├── columns: a:1!null generate_series:3 generate_series:5
 ├── immutable
 ├── fd: ()-->(1)
 └── project-set
      ├── columns: column1:1!null a:2!null generate_series:3 a:4!null generate_series:5
      ├── immutable
      ├── fd: ()-->(1,2,4)
      ├── values
      │    ├── columns: column1:1!null a:2!null a:4!null
      │    ├── cardinality: [1 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(1,2,4)
      │    └── (1, 1, 1)
      └── zip
           ├── generate_series(1, a:2) [outer=(2), immutable]
           └── generate_series(1, a:4) [outer=(4), immutable]

exec-ddl
CREATE TABLE articles (
  id INT PRIMARY KEY,
  body STRING,
  description STRING,
  title STRING,
  slug STRING,
  tag_list STRING[],
  user_id STRING,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
)
----

# Regression test for #31706.
norm expect=(TryDecorrelateSemiJoin,TryDecorrelateProjectSet)
SELECT a0.id, a0.body, a0.description, a0.title, a0.slug, a0.tag_list, a0.user_id, a0.created_at, a0.updated_at
    FROM articles AS a0
   WHERE EXISTS(SELECT * FROM unnest(a0.tag_list) AS tag WHERE tag = 'dragons')
ORDER BY a0.created_at
   LIMIT 10
  OFFSET 0;
----
limit
 ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 ├── internal-ordering: +8
 ├── cardinality: [0 - 10]
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-9)
 ├── ordering: +8
 ├── sort
 │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-9)
 │    ├── ordering: +8
 │    ├── limit hint: 10.00
 │    └── group-by
 │         ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │         ├── grouping columns: id:1!null
 │         ├── immutable
 │         ├── key: (1)
 │         ├── fd: (1)-->(2-9)
 │         ├── select
 │         │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 unnest:11!null
 │         │    ├── immutable
 │         │    ├── fd: ()-->(11), (1)-->(2-9)
 │         │    ├── project-set
 │         │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 unnest:11
 │         │    │    ├── immutable
 │         │    │    ├── fd: (1)-->(2-9)
 │         │    │    ├── scan articles [as=a0]
 │         │    │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
 │         │    │    │    ├── key: (1)
 │         │    │    │    └── fd: (1)-->(2-9)
 │         │    │    └── zip
 │         │    │         └── unnest(tag_list:6) [outer=(6), immutable]
 │         │    └── filters
 │         │         └── unnest:11 = 'dragons' [outer=(11), constraints=(/11: [/'dragons' - /'dragons']; tight), fd=()-->(11)]
 │         └── aggregations
 │              ├── const-agg [as=body:2, outer=(2)]
 │              │    └── body:2
 │              ├── const-agg [as=description:3, outer=(3)]
 │              │    └── description:3
 │              ├── const-agg [as=title:4, outer=(4)]
 │              │    └── title:4
 │              ├── const-agg [as=slug:5, outer=(5)]
 │              │    └── slug:5
 │              ├── const-agg [as=tag_list:6, outer=(6)]
 │              │    └── tag_list:6
 │              ├── const-agg [as=user_id:7, outer=(7)]
 │              │    └── user_id:7
 │              ├── const-agg [as=created_at:8, outer=(8)]
 │              │    └── created_at:8
 │              └── const-agg [as=updated_at:9, outer=(9)]
 │                   └── updated_at:9
 └── 10

# TODO(justin): figure out how to get this to decorrelate again.
norm
SELECT * FROM articles, xy WHERE EXISTS(
  SELECT * FROM ROWS FROM (generate_series(x, id), length(title), upper(title), unnest(tag_list))
)
----
project
 ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:11!null y:12
 ├── immutable
 ├── key: (1,11)
 ├── fd: (1)-->(2-9), (1,11)-->(2-9,12)
 └── select
      ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:11!null y:12 true_agg:19!null
      ├── immutable
      ├── key: (1,11)
      ├── fd: (1)-->(2-9), (1,11)-->(2-9,12,19)
      ├── group-by
      │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:11!null y:12 true_agg:19
      │    ├── grouping columns: id:1!null x:11!null
      │    ├── immutable
      │    ├── key: (1,11)
      │    ├── fd: (1)-->(2-9), (1,11)-->(2-9,12,19)
      │    ├── inner-join-apply
      │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9 x:11!null y:12 true:18
      │    │    ├── immutable
      │    │    ├── fd: (1)-->(2-9), (1,11)-->(12)
      │    │    ├── scan articles
      │    │    │    ├── columns: id:1!null body:2 description:3 title:4 slug:5 tag_list:6 user_id:7 created_at:8 updated_at:9
      │    │    │    ├── key: (1)
      │    │    │    └── fd: (1)-->(2-9)
      │    │    ├── left-join-apply
      │    │    │    ├── columns: x:11!null y:12 true:18
      │    │    │    ├── outer: (1,4,6)
      │    │    │    ├── immutable
      │    │    │    ├── fd: (11)-->(12)
      │    │    │    ├── scan xy
      │    │    │    │    ├── columns: x:11!null y:12
      │    │    │    │    ├── key: (11)
      │    │    │    │    └── fd: (11)-->(12)
      │    │    │    ├── project
      │    │    │    │    ├── columns: true:18!null
      │    │    │    │    ├── outer: (1,4,6,11)
      │    │    │    │    ├── immutable
      │    │    │    │    ├── fd: ()-->(18)
      │    │    │    │    ├── project-set
      │    │    │    │    │    ├── columns: generate_series:14 length:15 upper:16 unnest:17
      │    │    │    │    │    ├── outer: (1,4,6,11)
      │    │    │    │    │    ├── immutable
      │    │    │    │    │    ├── values
      │    │    │    │    │    │    ├── cardinality: [1 - 1]
      │    │    │    │    │    │    ├── key: ()
      │    │    │    │    │    │    └── ()
      │    │    │    │    │    └── zip
      │    │    │    │    │         ├── generate_series(x:11, id:1) [outer=(1,11), immutable]
      │    │    │    │    │         ├── length(title:4) [outer=(4), immutable]
      │    │    │    │    │         ├── upper(title:4) [outer=(4), immutable]
      │    │    │    │    │         └── unnest(tag_list:6) [outer=(6), immutable]
      │    │    │    │    └── projections
      │    │    │    │         └── true [as=true:18]
      │    │    │    └── filters (true)
      │    │    └── filters (true)
      │    └── aggregations
      │         ├── const-not-null-agg [as=true_agg:19, outer=(18)]
      │         │    └── true:18
      │         ├── const-agg [as=y:12, outer=(12)]
      │         │    └── y:12
      │         ├── const-agg [as=body:2, outer=(2)]
      │         │    └── body:2
      │         ├── const-agg [as=description:3, outer=(3)]
      │         │    └── description:3
      │         ├── const-agg [as=title:4, outer=(4)]
      │         │    └── title:4
      │         ├── const-agg [as=slug:5, outer=(5)]
      │         │    └── slug:5
      │         ├── const-agg [as=tag_list:6, outer=(6)]
      │         │    └── tag_list:6
      │         ├── const-agg [as=user_id:7, outer=(7)]
      │         │    └── user_id:7
      │         ├── const-agg [as=created_at:8, outer=(8)]
      │         │    └── created_at:8
      │         └── const-agg [as=updated_at:9, outer=(9)]
      │              └── updated_at:9
      └── filters
           └── true_agg:19 IS NOT NULL [outer=(19), constraints=(/19: (/NULL - ]; tight)]

norm expect=TryDecorrelateProjectSet
SELECT id FROM articles WHERE title = ANY(
  SELECT unnest FROM ROWS FROM (upper(title), unnest(tag_list), generate_series(0,1), lower('ABC'))
)
----
distinct-on
 ├── columns: id:1!null
 ├── grouping columns: id:1!null
 ├── immutable
 ├── key: (1)
 └── select
      ├── columns: id:1!null title:4!null tag_list:6 upper:11 unnest:12!null generate_series:13 lower:14
      ├── immutable
      ├── fd: (1)-->(4,6), (4)==(12), (12)==(4)
      ├── project-set
      │    ├── columns: id:1!null title:4 tag_list:6 upper:11 unnest:12 generate_series:13 lower:14
      │    ├── immutable
      │    ├── fd: (1)-->(4,6)
      │    ├── scan articles
      │    │    ├── columns: id:1!null title:4 tag_list:6
      │    │    ├── key: (1)
      │    │    └── fd: (1)-->(4,6)
      │    └── zip
      │         ├── upper(title:4) [outer=(4), immutable]
      │         ├── unnest(tag_list:6) [outer=(6), immutable]
      │         ├── generate_series(0, 1) [immutable]
      │         └── 'abc'
      └── filters
           └── title:4 = unnest:12 [outer=(4,12), constraints=(/4: (/NULL - ]; /12: (/NULL - ]), fd=(4)==(12), (12)==(4)]

# --------------------------------------------------
# NormalizeSelectAnyFilter + NormalizeJoinAnyFilter
# --------------------------------------------------
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE i IN (SELECT y FROM xy)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    └── columns: y:8
 └── filters
      └── i:2 = y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]

# Any is one of several conjuncts.
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE k=10 AND i < ANY(SELECT y FROM xy) AND s='foo'
----
semi-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4!null j:5
 ├── cardinality: [0 - 1]
 ├── key: ()
 ├── fd: ()-->(1-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4!null j:5
 │    ├── cardinality: [0 - 1]
 │    ├── key: ()
 │    ├── fd: ()-->(1-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         ├── k:1 = 10 [outer=(1), constraints=(/1: [/10 - /10]; tight), fd=()-->(1)]
 │         └── s:4 = 'foo' [outer=(4), constraints=(/4: [/'foo' - /'foo']; tight), fd=()-->(4)]
 ├── scan xy
 │    └── columns: y:8
 └── filters
      └── i:2 < y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# Multiple ANY conjuncts.
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE i < ANY(SELECT y FROM xy) AND s = ANY(SELECT y::string FROM xy)
----
semi-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:13
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:11
 │    │    └── projections
 │    │         └── xy.y:11::STRING [as=y:13, outer=(11), immutable]
 │    └── filters
 │         └── s:4 = y:13 [outer=(4,13), constraints=(/4: (/NULL - ]; /13: (/NULL - ]), fd=(4)==(13), (13)==(4)]
 ├── scan xy
 │    └── columns: xy.y:8
 └── filters
      └── i:2 < xy.y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ])]

# Don't hoist uncorrelated ANY (but rewrite it to EXISTS).
norm expect=NormalizeSelectAnyFilter
SELECT * FROM a WHERE 5 IN (SELECT y FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── exists [subquery]
           └── limit
                ├── columns: y:8!null
                ├── cardinality: [0 - 1]
                ├── key: ()
                ├── fd: ()-->(8)
                ├── select
                │    ├── columns: y:8!null
                │    ├── fd: ()-->(8)
                │    ├── limit hint: 1.00
                │    ├── scan xy
                │    │    ├── columns: y:8
                │    │    └── limit hint: 100.00
                │    └── filters
                │         └── y:8 = 5 [outer=(8), constraints=(/8: [/5 - /5]; tight), fd=()-->(8)]
                └── 1

# ANY in Join On condition.
norm expect=NormalizeJoinAnyFilter
SELECT * FROM a INNER JOIN xy ON i IN (SELECT v FROM uv) AND k=x
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null y:8
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (7)
 ├── fd: (1)-->(2-5), (7)-->(8), (1)==(7), (7)==(1)
 ├── semi-join (hash)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan uv
 │    │    └── columns: v:11
 │    └── filters
 │         └── i:2 = v:11 [outer=(2,11), constraints=(/2: (/NULL - ]; /11: (/NULL - ]), fd=(2)==(11), (11)==(2)]
 ├── scan xy
 │    ├── columns: x:7!null y:8
 │    ├── key: (7)
 │    └── fd: (7)-->(8)
 └── filters
      └── k:1 = x:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# --------------------------------------------------
# NormalizeSelectNotAnyFilter + NormalizeJoinNotAnyFilter
# --------------------------------------------------
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE i NOT IN (SELECT y FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 ├── scan xy
 │    └── columns: y:8
 └── filters
      └── (i:2 = y:8) IS NOT false [outer=(2,8)]

# NOT ANY is one of several conjuncts. Note that i > ALL(...) gets mapped to
# NOT i <= ANY(...) by optbuilder.
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE k > 1 AND k < 5 AND i > ALL(SELECT y FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── cardinality: [0 - 3]
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── select
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── cardinality: [0 - 3]
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    └── filters
 │         └── (k:1 > 1) AND (k:1 < 5) [outer=(1), constraints=(/1: [/2 - /4]; tight)]
 ├── scan xy
 │    └── columns: y:8
 └── filters
      └── (i:2 <= y:8) IS NOT false [outer=(2,8)]

# Multiple NOT ANY conjuncts.
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE i < ALL(SELECT y FROM xy) AND s <> ALL(SELECT y::string FROM xy)
----
anti-join (cross)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:13
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:11
 │    │    └── projections
 │    │         └── xy.y:11::STRING [as=y:13, outer=(11), immutable]
 │    └── filters
 │         └── (s:4 = y:13) IS NOT false [outer=(4,13)]
 ├── scan xy
 │    └── columns: xy.y:8
 └── filters
      └── (i:2 >= xy.y:8) IS NOT false [outer=(2,8)]

# Don't hoist uncorrelated NOT ANY (but rewrite it to NOT EXISTS).
norm expect=NormalizeSelectNotAnyFilter
SELECT * FROM a WHERE 5 NOT IN (SELECT y FROM xy)
----
select
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── scan a
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    └── fd: (1)-->(2-5)
 └── filters
      └── not [subquery]
           └── exists
                └── limit
                     ├── columns: y:8
                     ├── cardinality: [0 - 1]
                     ├── key: ()
                     ├── fd: ()-->(8)
                     ├── select
                     │    ├── columns: y:8
                     │    ├── limit hint: 1.00
                     │    ├── scan xy
                     │    │    ├── columns: y:8
                     │    │    └── limit hint: 3.00
                     │    └── filters
                     │         └── (y:8 = 5) IS NOT false [outer=(8)]
                     └── 1

# NOT ANY in Join On condition.
norm expect=NormalizeJoinNotAnyFilter
SELECT * FROM a INNER JOIN xy ON i NOT IN (SELECT v FROM uv) AND k=x
----
inner-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5 x:7!null y:8
 ├── multiplicity: left-rows(zero-or-one), right-rows(zero-or-one)
 ├── key: (7)
 ├── fd: (1)-->(2-5), (7)-->(8), (1)==(7), (7)==(1)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── scan uv
 │    │    └── columns: v:11
 │    └── filters
 │         └── (i:2 = v:11) IS NOT false [outer=(2,11)]
 ├── scan xy
 │    ├── columns: x:7!null y:8
 │    ├── key: (7)
 │    └── fd: (7)-->(8)
 └── filters
      └── k:1 = x:7 [outer=(1,7), constraints=(/1: (/NULL - ]; /7: (/NULL - ]), fd=(1)==(7), (7)==(1)]

# --------------------------------------------------
# NormalizeSelectAnyFilter + NormalizeSelectNotAnyFilter
# --------------------------------------------------
norm expect=(NormalizeSelectAnyFilter,NormalizeSelectNotAnyFilter)
SELECT * FROM a WHERE i = ANY(SELECT y FROM xy) AND s <> ALL(SELECT y::string FROM xy)
----
semi-join (hash)
 ├── columns: k:1!null i:2 f:3 s:4 j:5
 ├── immutable
 ├── key: (1)
 ├── fd: (1)-->(2-5)
 ├── anti-join (cross)
 │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    ├── immutable
 │    ├── key: (1)
 │    ├── fd: (1)-->(2-5)
 │    ├── scan a
 │    │    ├── columns: k:1!null i:2 f:3 s:4 j:5
 │    │    ├── key: (1)
 │    │    └── fd: (1)-->(2-5)
 │    ├── project
 │    │    ├── columns: y:13
 │    │    ├── immutable
 │    │    ├── scan xy
 │    │    │    └── columns: xy.y:11
 │    │    └── projections
 │    │         └── xy.y:11::STRING [as=y:13, outer=(11), immutable]
 │    └── filters
 │         └── (s:4 = y:13) IS NOT false [outer=(4,13)]
 ├── scan xy
 │    └── columns: xy.y:8
 └── filters
      └── i:2 = xy.y:8 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]

# --------------------------------------------------
# EnsureKey
# --------------------------------------------------

# Check that when the EnsureKey function is called on a Scan that has pruned its
# key away, it creates a new Scan with the primary key added back rather than
# introducing an ordinality operator.
#
# In this test case, the key column of a is pruned away from the Scan, but when
# TryDecorrelateLimitOne calls EnsureKey on the Scan, the key is added back.
norm
SELECT (SELECT x FROM xy WHERE y=i LIMIT 1) FROM a
----
project
 ├── columns: x:10
 ├── distinct-on
 │    ├── columns: k:1!null xy.x:7
 │    ├── grouping columns: k:1!null
 │    ├── key: (1)
 │    ├── fd: (1)-->(7)
 │    ├── left-join (hash)
 │    │    ├── columns: k:1!null i:2 xy.x:7 y:8
 │    │    ├── key: (1,7)
 │    │    ├── fd: (1)-->(2), (7)-->(8)
 │    │    ├── scan a
 │    │    │    ├── columns: k:1!null i:2
 │    │    │    ├── key: (1)
 │    │    │    └── fd: (1)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:7!null y:8
 │    │    │    ├── key: (7)
 │    │    │    └── fd: (7)-->(8)
 │    │    └── filters
 │    │         └── y:8 = i:2 [outer=(2,8), constraints=(/2: (/NULL - ]; /8: (/NULL - ]), fd=(2)==(8), (8)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:7, outer=(7)]
 │              └── xy.x:7
 └── projections
      └── xy.x:7 [as=x:10, outer=(7)]

# Case where EnsureKey retrieves an implicit key to add to the Scan.
norm
SELECT (SELECT x FROM xy WHERE y=b LIMIT 1) FROM ab
----
project
 ├── columns: x:8
 ├── distinct-on
 │    ├── columns: rowid:3!null xy.x:5
 │    ├── grouping columns: rowid:3!null
 │    ├── key: (3)
 │    ├── fd: (3)-->(5)
 │    ├── left-join (hash)
 │    │    ├── columns: b:2 rowid:3!null xy.x:5 y:6
 │    │    ├── key: (3,5)
 │    │    ├── fd: (3)-->(2), (5)-->(6)
 │    │    ├── scan ab
 │    │    │    ├── columns: b:2 rowid:3!null
 │    │    │    ├── key: (3)
 │    │    │    └── fd: (3)-->(2)
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:5!null y:6
 │    │    │    ├── key: (5)
 │    │    │    └── fd: (5)-->(6)
 │    │    └── filters
 │    │         └── y:6 = b:2 [outer=(2,6), constraints=(/2: (/NULL - ]; /6: (/NULL - ]), fd=(2)==(6), (6)==(2)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:5, outer=(5)]
 │              └── xy.x:5
 └── projections
      └── xy.x:5 [as=x:8, outer=(5)]

# EnsureKey should construct an Ordinality operator when it is called on a Scan
# over a virtual table.
norm
SELECT (SELECT x FROM xy WHERE y=version LIMIT 1) FROM information_schema.tables
----
project
 ├── columns: x:11
 ├── distinct-on
 │    ├── columns: xy.x:8 rownum:12!null
 │    ├── grouping columns: rownum:12!null
 │    ├── key: (12)
 │    ├── fd: (12)-->(8)
 │    ├── left-join (hash)
 │    │    ├── columns: version:7 xy.x:8 y:9 rownum:12!null
 │    │    ├── key: (8,12)
 │    │    ├── fd: (12)-->(7), (8)-->(9)
 │    │    ├── ordinality
 │    │    │    ├── columns: version:7 rownum:12!null
 │    │    │    ├── key: (12)
 │    │    │    ├── fd: (12)-->(7)
 │    │    │    └── scan tables
 │    │    │         └── columns: version:7
 │    │    ├── scan xy
 │    │    │    ├── columns: xy.x:8!null y:9
 │    │    │    ├── key: (8)
 │    │    │    └── fd: (8)-->(9)
 │    │    └── filters
 │    │         └── y:9 = version:7 [outer=(7,9), constraints=(/7: (/NULL - ]; /9: (/NULL - ]), fd=(7)==(9), (9)==(7)]
 │    └── aggregations
 │         └── first-agg [as=xy.x:8, outer=(8)]
 │              └── xy.x:8
 └── projections
      └── xy.x:8 [as=x:11, outer=(8)]
