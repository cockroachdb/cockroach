# --------------------------------------------------
# SimplifyPartialIndexProjections
# --------------------------------------------------

exec-ddl
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  f INT,
  g INT,
  h BOOL,
  INDEX (a),
  INDEX (c) WHERE d > 1,
  INDEX (e) WHERE f > 1 AND g > 1,
  INDEX (b),
  INDEX (d) WHERE c > 1
)
----

# Simplify UPDATE partial index put/del column to false when the indexed columns
# and columns referenced in predicates are not mutating.
norm expect=SimplifyPartialIndexProjections
UPDATE t SET a = 2, b = 2 WHERE k = 1
----
update t
 ├── columns: <none>
 ├── fetch columns: k:12 a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
 ├── update-mapping:
 │    ├── a_new:23 => a:2
 │    └── a_new:23 => b:3
 ├── partial index put columns: partial_index_put1:24 partial_index_put2:25 partial_index_put3:26
 ├── partial index del columns: partial_index_put1:24 partial_index_put2:25 partial_index_put3:26
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put1:24!null partial_index_put2:25!null partial_index_put3:26!null a_new:23!null k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(12-20,23-26)
      ├── select
      │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(12-20)
      │    ├── scan t
      │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    ├── partial index predicates
      │    │    │    ├── t_c_idx: filters
      │    │    │    │    └── d:16 > 1 [outer=(16), constraints=(/16: [/2 - ]; tight)]
      │    │    │    ├── t_e_idx: filters
      │    │    │    │    ├── f:18 > 1 [outer=(18), constraints=(/18: [/2 - ]; tight)]
      │    │    │    │    └── g:19 > 1 [outer=(19), constraints=(/19: [/2 - ]; tight)]
      │    │    │    └── t_d_idx: filters
      │    │    │         └── c:15 > 1 [outer=(15), constraints=(/15: [/2 - ]; tight)]
      │    │    ├── flags: avoid-full-scan
      │    │    ├── key: (12)
      │    │    └── fd: (12)-->(13-20)
      │    └── filters
      │         └── k:12 = 1 [outer=(12), constraints=(/12: [/1 - /1]; tight), fd=()-->(12)]
      └── projections
           ├── false [as=partial_index_put1:24]
           ├── false [as=partial_index_put2:25]
           ├── false [as=partial_index_put3:26]
           └── 2 [as=a_new:23]

# Simplify UPDATE partial index put/del column to false for second partial index
# only.
norm expect=SimplifyPartialIndexProjections
UPDATE t SET a = 2, d = 2 WHERE k = 1
----
update t
 ├── columns: <none>
 ├── fetch columns: k:12 a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
 ├── update-mapping:
 │    ├── a_new:23 => a:2
 │    └── a_new:23 => d:5
 ├── partial index put columns: partial_index_put1:24 partial_index_put2:26 partial_index_put3:27
 ├── partial index del columns: partial_index_del1:25 partial_index_put2:26 partial_index_put3:27
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put1:24!null partial_index_del1:25 partial_index_put2:26!null partial_index_put3:27 a_new:23!null k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(12-20,23-27)
      ├── select
      │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(12-20)
      │    ├── scan t
      │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    ├── partial index predicates
      │    │    │    ├── t_c_idx: filters
      │    │    │    │    └── d:16 > 1 [outer=(16), constraints=(/16: [/2 - ]; tight)]
      │    │    │    ├── t_e_idx: filters
      │    │    │    │    ├── f:18 > 1 [outer=(18), constraints=(/18: [/2 - ]; tight)]
      │    │    │    │    └── g:19 > 1 [outer=(19), constraints=(/19: [/2 - ]; tight)]
      │    │    │    └── t_d_idx: filters
      │    │    │         └── c:15 > 1 [outer=(15), constraints=(/15: [/2 - ]; tight)]
      │    │    ├── flags: avoid-full-scan
      │    │    ├── key: (12)
      │    │    └── fd: (12)-->(13-20)
      │    └── filters
      │         └── k:12 = 1 [outer=(12), constraints=(/12: [/1 - /1]; tight), fd=()-->(12)]
      └── projections
           ├── true [as=partial_index_put1:24]
           ├── d:16 > 1 [as=partial_index_del1:25, outer=(16)]
           ├── false [as=partial_index_put2:26]
           ├── c:15 > 1 [as=partial_index_put3:27, outer=(15)]
           └── 2 [as=a_new:23]

# Do not simplify partial index put/del column to false when the indexed columns
# are mutating.
norm expect-not=SimplifyPartialIndexProjections
UPDATE t SET c = 1, e = 1 WHERE k = 1
----
update t
 ├── columns: <none>
 ├── fetch columns: k:12 a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
 ├── update-mapping:
 │    ├── c_new:23 => c:4
 │    └── c_new:23 => e:6
 ├── partial index put columns: partial_index_put1:24 partial_index_put2:25 partial_index_put3:26
 ├── partial index del columns: partial_index_put1:24 partial_index_put2:25 partial_index_del3:27
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put1:24 partial_index_put2:25 partial_index_put3:26!null partial_index_del3:27 c_new:23!null k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(12-20,23-27)
      ├── select
      │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(12-20)
      │    ├── scan t
      │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    ├── partial index predicates
      │    │    │    ├── t_c_idx: filters
      │    │    │    │    └── d:16 > 1 [outer=(16), constraints=(/16: [/2 - ]; tight)]
      │    │    │    ├── t_e_idx: filters
      │    │    │    │    ├── f:18 > 1 [outer=(18), constraints=(/18: [/2 - ]; tight)]
      │    │    │    │    └── g:19 > 1 [outer=(19), constraints=(/19: [/2 - ]; tight)]
      │    │    │    └── t_d_idx: filters
      │    │    │         └── c:15 > 1 [outer=(15), constraints=(/15: [/2 - ]; tight)]
      │    │    ├── flags: avoid-full-scan
      │    │    ├── key: (12)
      │    │    └── fd: (12)-->(13-20)
      │    └── filters
      │         └── k:12 = 1 [outer=(12), constraints=(/12: [/1 - /1]; tight), fd=()-->(12)]
      └── projections
           ├── d:16 > 1 [as=partial_index_put1:24, outer=(16)]
           ├── (f:18 > 1) AND (g:19 > 1) [as=partial_index_put2:25, outer=(18,19)]
           ├── false [as=partial_index_put3:26]
           ├── c:15 > 1 [as=partial_index_del3:27, outer=(15)]
           └── 1 [as=c_new:23]

# Do not simplify partial index put/del column to false when the columns
# referenced in partial index predicates are mutating.
norm expect-not=SimplifyPartialIndexProjections
UPDATE t SET d = d + 1, g = g + 1 WHERE k = 1
----
update t
 ├── columns: <none>
 ├── fetch columns: k:12 a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
 ├── update-mapping:
 │    ├── d_new:23 => d:5
 │    └── g_new:24 => g:8
 ├── partial index put columns: partial_index_put1:25 partial_index_put2:27 partial_index_put3:29
 ├── partial index del columns: partial_index_del1:26 partial_index_del2:28 partial_index_put3:29
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put1:25 partial_index_del1:26 partial_index_put2:27 partial_index_del2:28 partial_index_put3:29 k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20 d_new:23 g_new:24
      ├── cardinality: [0 - 1]
      ├── immutable
      ├── key: ()
      ├── fd: ()-->(12-20,23-29)
      ├── project
      │    ├── columns: d_new:23 g_new:24 k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    ├── cardinality: [0 - 1]
      │    ├── immutable
      │    ├── key: ()
      │    ├── fd: ()-->(12-20,23,24)
      │    ├── select
      │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(12-20)
      │    │    ├── scan t
      │    │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    │    ├── partial index predicates
      │    │    │    │    ├── t_c_idx: filters
      │    │    │    │    │    └── d:16 > 1 [outer=(16), constraints=(/16: [/2 - ]; tight)]
      │    │    │    │    ├── t_e_idx: filters
      │    │    │    │    │    ├── f:18 > 1 [outer=(18), constraints=(/18: [/2 - ]; tight)]
      │    │    │    │    │    └── g:19 > 1 [outer=(19), constraints=(/19: [/2 - ]; tight)]
      │    │    │    │    └── t_d_idx: filters
      │    │    │    │         └── c:15 > 1 [outer=(15), constraints=(/15: [/2 - ]; tight)]
      │    │    │    ├── flags: avoid-full-scan
      │    │    │    ├── key: (12)
      │    │    │    └── fd: (12)-->(13-20)
      │    │    └── filters
      │    │         └── k:12 = 1 [outer=(12), constraints=(/12: [/1 - /1]; tight), fd=()-->(12)]
      │    └── projections
      │         ├── d:16 + 1 [as=d_new:23, outer=(16), immutable]
      │         └── g:19 + 1 [as=g_new:24, outer=(19), immutable]
      └── projections
           ├── d_new:23 > 1 [as=partial_index_put1:25, outer=(23)]
           ├── d:16 > 1 [as=partial_index_del1:26, outer=(16)]
           ├── (f:18 > 1) AND (g_new:24 > 1) [as=partial_index_put2:27, outer=(18,24)]
           ├── (f:18 > 1) AND (g:19 > 1) [as=partial_index_del2:28, outer=(18,19)]
           └── c:15 > 1 [as=partial_index_put3:29, outer=(15)]

# Do not simplify partial index put/del column to false when it is also an
# update column (h_new).
norm
UPDATE t SET h = d > 1 WHERE k = 1
----
update t
 ├── columns: <none>
 ├── fetch columns: k:12 a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
 ├── update-mapping:
 │    └── h_new:23 => h:9
 ├── partial index put columns: h_new:23 partial_index_put2:24 partial_index_put3:25
 ├── partial index del columns: h_new:23 partial_index_put2:24 partial_index_put3:25
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put2:24!null partial_index_put3:25!null h_new:23 k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(12-20,23-25)
      ├── select
      │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    ├── cardinality: [0 - 1]
      │    ├── key: ()
      │    ├── fd: ()-->(12-20)
      │    ├── scan t
      │    │    ├── columns: k:12!null a:13 b:14 c:15 d:16 e:17 f:18 g:19 h:20
      │    │    ├── partial index predicates
      │    │    │    ├── t_c_idx: filters
      │    │    │    │    └── d:16 > 1 [outer=(16), constraints=(/16: [/2 - ]; tight)]
      │    │    │    ├── t_e_idx: filters
      │    │    │    │    ├── f:18 > 1 [outer=(18), constraints=(/18: [/2 - ]; tight)]
      │    │    │    │    └── g:19 > 1 [outer=(19), constraints=(/19: [/2 - ]; tight)]
      │    │    │    └── t_d_idx: filters
      │    │    │         └── c:15 > 1 [outer=(15), constraints=(/15: [/2 - ]; tight)]
      │    │    ├── flags: avoid-full-scan
      │    │    ├── key: (12)
      │    │    └── fd: (12)-->(13-20)
      │    └── filters
      │         └── k:12 = 1 [outer=(12), constraints=(/12: [/1 - /1]; tight), fd=()-->(12)]
      └── projections
           ├── false [as=partial_index_put2:24]
           ├── false [as=partial_index_put3:25]
           └── d:16 > 1 [as=h_new:23, outer=(16)]

# Regression for #74385. Do not simplify partial index put/del columns to false
# for one index which includes mutating columns where there is another index
# with the same predicate that does not include mutating columns.
exec-ddl
CREATE TABLE t74385 (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  c INT,
  INDEX b_idx (b) WHERE c IS NULL,
  INDEX a_idx (a) WHERE c IS NULL
)
----

norm expect-not=SimplifyPartialIndexProjections
UPDATE t74385 SET b = NULL
----
update t74385
 ├── columns: <none>
 ├── fetch columns: k:7 a:8 b:9 c:10
 ├── update-mapping:
 │    └── b_new:13 => b:3
 ├── partial index put columns: partial_index_put1:14 partial_index_put1:14
 ├── partial index del columns: partial_index_put1:14 partial_index_put1:14
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: partial_index_put1:14!null b_new:13 k:7!null a:8 b:9 c:10
      ├── key: (7)
      ├── fd: ()-->(13), (7)-->(8-10), (10)-->(14)
      ├── scan t74385
      │    ├── columns: k:7!null a:8 b:9 c:10
      │    ├── partial index predicates
      │    │    ├── b_idx: filters
      │    │    │    └── c:10 IS NULL [outer=(10), constraints=(/10: [/NULL - /NULL]; tight), fd=()-->(10)]
      │    │    └── a_idx: filters
      │    │         └── c:10 IS NULL [outer=(10), constraints=(/10: [/NULL - /NULL]; tight), fd=()-->(10)]
      │    ├── flags: avoid-full-scan
      │    ├── key: (7)
      │    └── fd: (7)-->(8-10)
      └── projections
           ├── c:10 IS NULL [as=partial_index_put1:14, outer=(10)]
           └── CAST(NULL AS INT8) [as=b_new:13]

# Regression for #106663. Also simplify passthrough partial index put/del
# columns to false when the indexed columns and columns referenced in predicates
# are not changing.

exec-ddl
CREATE TABLE t106663 (a INT, b INT, c BOOL, INDEX (b) WHERE c, FAMILY (a, b), FAMILY (c))
----

norm expect=SimplifyPartialIndexProjections
UPDATE t106663 SET a = 1 WHERE true
----
update t106663
 ├── columns: <none>
 ├── fetch columns: a:7 b:8 rowid:10
 ├── update-mapping:
 │    └── a_new:13 => a:1
 ├── partial index put columns: partial_index_put2:14
 ├── partial index del columns: partial_index_del2:15
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── project
      ├── columns: a_new:13!null partial_index_put2:14!null partial_index_del2:15!null a:7 b:8 rowid:10!null
      ├── key: (10)
      ├── fd: ()-->(13-15), (10)-->(7,8)
      ├── scan t106663
      │    ├── columns: a:7 b:8 rowid:10!null
      │    ├── partial index predicates
      │    │    └── t106663_b_idx: filters
      │    │         └── c:9 [outer=(9), constraints=(/9: [/true - /true]; tight), fd=()-->(9)]
      │    ├── flags: avoid-full-scan
      │    ├── key: (10)
      │    └── fd: (10)-->(7,8)
      └── projections
           ├── 1 [as=a_new:13]
           ├── false [as=partial_index_put2:14]
           └── false [as=partial_index_del2:15]

norm set=optimizer_use_lock_op_for_serializable=true expect=RemoveZeroCardLock
SELECT a FROM t WHERE a = 1 AND a = 2 FOR UPDATE;
----
values
 ├── columns: a:2!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(2)

norm set=optimizer_use_lock_op_for_serializable=true expect=RemoveZeroCardLock
SELECT a FROM t WHERE a = 1 AND a = 2 FOR SHARE;
----
values
 ├── columns: a:2!null
 ├── cardinality: [0 - 0]
 ├── key: ()
 └── fd: ()-->(2)

norm set=optimizer_use_lock_op_for_serializable=true expect-not=RemoveZeroCardLock
SELECT a FROM t WHERE a = 1 FOR SHARE;
----
lock t
 ├── columns: a:2!null  [hidden: k:1!null]
 ├── key columns: k:1
 ├── lock columns: (12-20)
 ├── locking: for-share
 ├── volatile
 ├── key: (1)
 ├── fd: ()-->(2)
 └── select
      ├── columns: k:1!null a:2!null
      ├── key: (1)
      ├── fd: ()-->(2)
      ├── scan t
      │    ├── columns: k:1!null a:2
      │    ├── partial index predicates
      │    │    ├── t_c_idx: filters
      │    │    │    └── d:5 > 1 [outer=(5), constraints=(/5: [/2 - ]; tight)]
      │    │    ├── t_e_idx: filters
      │    │    │    ├── f:7 > 1 [outer=(7), constraints=(/7: [/2 - ]; tight)]
      │    │    │    └── g:8 > 1 [outer=(8), constraints=(/8: [/2 - ]; tight)]
      │    │    └── t_d_idx: filters
      │    │         └── c:4 > 1 [outer=(4), constraints=(/4: [/2 - ]; tight)]
      │    ├── key: (1)
      │    └── fd: (1)-->(2)
      └── filters
           └── a:2 = 1 [outer=(2), constraints=(/2: [/1 - /1]; tight), fd=()-->(2)]

# --------------------------------------------------
# UseSwapMutation
# --------------------------------------------------

exec-ddl
CREATE TABLE abc (
  a INT NOT NULL,
  b INT,
  c BOOLEAN,
  PRIMARY KEY (a)
)
----

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b IS NOT DISTINCT FROM 2 AND c
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, 2, true)

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND (b = 2 AND c = FALSE)
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, 2, false)

norm expect-not=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b > 2
----
update abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── select
      ├── columns: a:6!null b:7!null c:8
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── scan abc
      │    ├── columns: a:6!null b:7 c:8
      │    ├── flags: avoid-full-scan
      │    ├── key: (6)
      │    └── fd: (6)-->(7,8)
      └── filters
           ├── a:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
           └── b:7 > 2 [outer=(7), constraints=(/7: [/3 - ]; tight)]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b IS NULL AND c IS NULL
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7 c:8
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, NULL, NULL)

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b IS NOT DISTINCT FROM NULL AND c IS NOT DISTINCT FROM NULL
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7 c:8
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, NULL, NULL)

norm expect-not=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b IS DISTINCT FROM NULL AND c
----
update abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── select
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [0 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── scan abc
      │    ├── columns: a:6!null b:7 c:8
      │    ├── flags: avoid-full-scan
      │    ├── key: (6)
      │    └── fd: (6)-->(7,8)
      └── filters
           ├── a:6 = 1 [outer=(6), constraints=(/6: [/1 - /1]; tight), fd=()-->(6)]
           ├── b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
           └── c:8 [outer=(8), constraints=(/8: [/true - /true]; tight), fd=()-->(8)]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = 1 AND b = 2 AND NOT c AND (a > b) = c
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, 2, false)

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b IS NOT DISTINCT FROM $2 AND c IS NOT DISTINCT FROM $3
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── select
      ├── columns: a:6!null b:7 c:8
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── values
      │    ├── columns: a:6 b:7 c:8
      │    ├── cardinality: [1 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    └── ($1, $2, $3)
      └── filters
           └── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]

norm expect-not=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b = $2
----
update abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── select
      ├── columns: a:6!null b:7!null c:8
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── scan abc
      │    ├── columns: a:6!null b:7 c:8
      │    ├── flags: avoid-full-scan
      │    ├── key: (6)
      │    └── fd: (6)-->(7,8)
      └── filters
           ├── a:6 = $1 [outer=(6), constraints=(/6: (/NULL - ]), fd=()-->(6)]
           └── b:7 = $2 [outer=(7), constraints=(/7: (/NULL - ]), fd=()-->(7)]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b = $2 AND c = $3
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── select
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── values
      │    ├── columns: a:6 b:7 c:8
      │    ├── cardinality: [1 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    └── ($1, $2, $3)
      └── filters
           ├── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
           ├── b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
           └── c:8 IS NOT NULL [outer=(8), constraints=(/8: (/NULL - ]; tight)]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b = $2 AND c AND c = $3 AND a < b
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── select
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── values
      │    ├── columns: a:6 b:7 c:8!null
      │    ├── cardinality: [1 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    └── ($1, $2, true)
      └── filters
           ├── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
           ├── b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
           ├── $3
           └── a:6 < b:7 [outer=(6,7), constraints=(/6: (/NULL - ]; /7: (/NULL - ])]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b = $2 AND c AND a < b RETURNING a
----
update (swap) abc
 ├── columns: a:1!null
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── b:7 => a:1
 ├── return-mapping:
 │    └── b:7 => a:1
 ├── cardinality: [0 - 1]
 ├── volatile, mutations, has-placeholder
 ├── key: ()
 ├── fd: ()-->(1)
 └── select
      ├── columns: a:6!null b:7!null c:8!null
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8)
      ├── values
      │    ├── columns: a:6 b:7 c:8!null
      │    ├── cardinality: [1 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    └── ($1, $2, true)
      └── filters
           ├── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
           ├── b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
           └── a:6 < b:7 [outer=(6,7), constraints=(/6: (/NULL - ]; /7: (/NULL - ])]

norm expect=UseSwapMutation
UPDATE abc SET a = b WHERE a = $1 AND b = $2 + 1 AND c RETURNING a + b
----
project
 ├── columns: "?column?":11!null
 ├── cardinality: [0 - 1]
 ├── volatile, mutations, has-placeholder
 ├── key: ()
 ├── fd: ()-->(11)
 ├── update (swap) abc
 │    ├── columns: a:1!null b:2!null
 │    ├── fetch columns: a:6 b:7 c:8
 │    ├── update-mapping:
 │    │    └── b:7 => a:1
 │    ├── return-mapping:
 │    │    ├── b:7 => a:1
 │    │    └── b:7 => b:2
 │    ├── cardinality: [0 - 1]
 │    ├── volatile, mutations, has-placeholder
 │    ├── key: ()
 │    ├── fd: ()-->(1,2), (1)==(2), (2)==(1)
 │    └── select
 │         ├── columns: a:6!null b:7!null c:8!null
 │         ├── cardinality: [0 - 1]
 │         ├── immutable, has-placeholder
 │         ├── key: ()
 │         ├── fd: ()-->(6-8)
 │         ├── values
 │         │    ├── columns: a:6 b:7 c:8!null
 │         │    ├── cardinality: [1 - 1]
 │         │    ├── immutable, has-placeholder
 │         │    ├── key: ()
 │         │    ├── fd: ()-->(6-8)
 │         │    └── ($1, $2 + 1, true)
 │         └── filters
 │              ├── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
 │              └── b:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
 └── projections
      └── a:1 + b:2 [as="?column?":11, outer=(1,2), immutable]

norm expect=UseSwapMutation
DELETE FROM abc WHERE a = 1 AND b IS NOT DISTINCT FROM 1 AND c IS NOT DISTINCT FROM NULL
----
delete (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8)
      └── (1, 1, NULL)

norm expect=UseSwapMutation
DELETE FROM abc WHERE a = $1 AND b IS NOT DISTINCT FROM $2 AND c IS NOT DISTINCT FROM $3 RETURNING $4:::int
----
project
 ├── columns: int8:11
 ├── cardinality: [0 - 1]
 ├── volatile, mutations, has-placeholder
 ├── key: ()
 ├── fd: ()-->(11)
 ├── delete (swap) abc
 │    ├── columns: a:1!null
 │    ├── fetch columns: a:6 b:7 c:8
 │    ├── return-mapping:
 │    │    └── a:6 => a:1
 │    ├── cardinality: [0 - 1]
 │    ├── volatile, mutations, has-placeholder
 │    ├── key: ()
 │    ├── fd: ()-->(1)
 │    └── select
 │         ├── columns: a:6!null b:7 c:8
 │         ├── cardinality: [0 - 1]
 │         ├── has-placeholder
 │         ├── key: ()
 │         ├── fd: ()-->(6-8)
 │         ├── values
 │         │    ├── columns: a:6 b:7 c:8
 │         │    ├── cardinality: [1 - 1]
 │         │    ├── has-placeholder
 │         │    ├── key: ()
 │         │    ├── fd: ()-->(6-8)
 │         │    └── ($1, $2, $3)
 │         └── filters
 │              └── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
 └── projections
      └── $4 [as=int8:11]

# A column with composite key encoding (such as DECIMAL) won't allow swap
# mutations.
exec-ddl
CREATE TABLE xy (
  x INT NOT NULL,
  y DECIMAL,
  PRIMARY KEY (x)
)
----

norm expect-not=UseSwapMutation
UPDATE xy SET x = x WHERE x = 1 AND y = 2
----
update xy
 ├── columns: <none>
 ├── fetch columns: x:5 y:6
 ├── update-mapping:
 │    └── x:5 => x:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── select
      ├── columns: x:5!null y:6!null
      ├── cardinality: [0 - 1]
      ├── immutable
      ├── key: ()
      ├── fd: ()-->(5,6)
      ├── scan xy
      │    ├── columns: x:5!null y:6
      │    ├── flags: avoid-full-scan
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           ├── x:5 = 1 [outer=(5), constraints=(/5: [/1 - /1]; tight), fd=()-->(5)]
           └── y:6 = 2 [outer=(6), immutable, constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]

norm expect-not=UseSwapMutation
DELETE FROM xy WHERE x = 1 AND y = 2
----
delete xy
 ├── columns: <none>
 ├── fetch columns: x:5
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── select
      ├── columns: x:5!null y:6!null
      ├── cardinality: [0 - 1]
      ├── immutable
      ├── key: ()
      ├── fd: ()-->(5,6)
      ├── scan xy
      │    ├── columns: x:5!null y:6
      │    ├── flags: avoid-full-scan
      │    ├── key: (5)
      │    └── fd: (5)-->(6)
      └── filters
           ├── x:5 = 1 [outer=(5), constraints=(/5: [/1 - /1]; tight), fd=()-->(5)]
           └── y:6 = 2 [outer=(6), immutable, constraints=(/6: [/2 - /2]; tight), fd=()-->(6)]

# --------------------------------------------------
# UseSwapMutationWithProjection
# --------------------------------------------------

norm expect=UseSwapMutationWithProjection
UPDATE abc SET a = 2 WHERE a = 1 AND b IS NOT DISTINCT FROM 1 AND c
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    └── a_new:11 => a:1
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8!null a_new:11!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8,11)
      └── (1, 1, true, 2)

norm expect=UseSwapMutationWithProjection
UPDATE abc SET a = 1, b = 2, c = TRUE WHERE a = 4 AND b IS NOT DISTINCT FROM 5 AND c
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    ├── a_new:11 => a:1
 │    ├── b_new:12 => b:2
 │    └── c_new:13 => c:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: a:6!null b:7!null c:8!null a_new:11!null b_new:12!null c_new:13!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(6-8,11-13)
      └── (4, 5, true, 1, 2, true)

norm expect=UseSwapMutationWithProjection
UPDATE abc SET a = $1, b = $2, c = $3 WHERE a = $4 AND b IS NOT DISTINCT FROM $5 AND c IS NOT DISTINCT FROM $6
----
update (swap) abc
 ├── columns: <none>
 ├── fetch columns: a:6 b:7 c:8
 ├── update-mapping:
 │    ├── a_new:11 => a:1
 │    ├── b_new:12 => b:2
 │    └── c_new:13 => c:3
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── project
      ├── columns: a_new:11 b_new:12 c_new:13 a:6!null b:7 c:8
      ├── cardinality: [0 - 1]
      ├── has-placeholder
      ├── key: ()
      ├── fd: ()-->(6-8,11-13)
      ├── select
      │    ├── columns: a:6!null b:7 c:8
      │    ├── cardinality: [0 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(6-8)
      │    ├── values
      │    │    ├── columns: a:6 b:7 c:8
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── has-placeholder
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(6-8)
      │    │    └── ($4, $5, $6)
      │    └── filters
      │         └── a:6 IS NOT NULL [outer=(6), constraints=(/6: (/NULL - ]; tight)]
      └── projections
           ├── $1 [as=a_new:11]
           ├── $2 [as=b_new:12]
           └── $3 [as=c_new:13]

exec-ddl
CREATE TABLE mnop (
  m INT NOT NULL,
  n INT,
  o INT AS (m + n) VIRTUAL,
  p BOOLEAN AS (m < n) VIRTUAL,
  PRIMARY KEY (m),
  UNIQUE INDEX (n),
  INDEX (o)
)
----

norm expect=UseSwapMutationWithProjection
UPDATE mnop SET m = 1, n = 2 WHERE m = 3 AND n IS NOT DISTINCT FROM 4
----
update (swap) mnop
 ├── columns: <none>
 ├── fetch columns: m:7 n:8 o:9 p:10
 ├── update-mapping:
 │    ├── m_new:13 => m:1
 │    ├── n_new:14 => n:2
 │    ├── o_comp:15 => o:3
 │    └── p_comp:16 => p:4
 ├── cardinality: [0 - 0]
 ├── volatile, mutations
 └── values
      ├── columns: m:7!null n:8!null o_comp:15!null p_comp:16!null m_new:13!null n_new:14!null o:9!null p:10!null
      ├── cardinality: [1 - 1]
      ├── key: ()
      ├── fd: ()-->(7-10,13-16)
      └── (3, 4, 3, true, 1, 2, 7, true)

norm expect=UseSwapMutationWithProjection
DELETE FROM mnop WHERE m = $1 AND n IS NOT DISTINCT FROM $2
----
delete (swap) mnop
 ├── columns: <none>
 ├── fetch columns: m:7 n:8 o:9
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── project
      ├── columns: o:9 m:7!null n:8
      ├── cardinality: [0 - 1]
      ├── immutable, has-placeholder
      ├── key: ()
      ├── fd: ()-->(7-9)
      ├── select
      │    ├── columns: m:7!null n:8
      │    ├── cardinality: [0 - 1]
      │    ├── has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(7,8)
      │    ├── values
      │    │    ├── columns: m:7 n:8
      │    │    ├── cardinality: [1 - 1]
      │    │    ├── has-placeholder
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(7,8)
      │    │    └── ($1, $2)
      │    └── filters
      │         └── m:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
      └── projections
           └── m:7 + n:8 [as=o:9, outer=(7,8), immutable]

# --------------------------------------------------
# UseSwapMutationWithProjection
# --------------------------------------------------

norm expect=UseSwapMutationWithProjectionProjection
UPDATE mnop SET m = $1, n = $2 WHERE m = $3 AND n = $4 RETURNING o, p
----
project
 ├── columns: o:3 p:4
 ├── cardinality: [0 - 1]
 ├── volatile, mutations, has-placeholder
 ├── key: ()
 ├── fd: ()-->(3,4)
 └── update (swap) mnop
      ├── columns: m:1!null o:3 p:4
      ├── fetch columns: m:7 n:8 o:9 p:10
      ├── update-mapping:
      │    ├── m_new:13 => m:1
      │    ├── n_new:14 => n:2
      │    ├── o_comp:15 => o:3
      │    └── p_comp:16 => p:4
      ├── return-mapping:
      │    ├── m_new:13 => m:1
      │    ├── o_comp:15 => o:3
      │    └── p_comp:16 => p:4
      ├── cardinality: [0 - 1]
      ├── volatile, mutations, has-placeholder
      ├── key: ()
      ├── fd: ()-->(1,3,4)
      └── project
           ├── columns: o_comp:15 p_comp:16 m:7!null n:8!null o:9!null p:10!null m_new:13 n_new:14
           ├── cardinality: [0 - 1]
           ├── immutable, has-placeholder
           ├── key: ()
           ├── fd: ()-->(7-10,13-16)
           ├── project
           │    ├── columns: m_new:13 n_new:14 o:9!null p:10!null m:7!null n:8!null
           │    ├── cardinality: [0 - 1]
           │    ├── immutable, has-placeholder
           │    ├── key: ()
           │    ├── fd: ()-->(7-10,13,14)
           │    ├── select
           │    │    ├── columns: m:7!null n:8!null
           │    │    ├── cardinality: [0 - 1]
           │    │    ├── has-placeholder
           │    │    ├── key: ()
           │    │    ├── fd: ()-->(7,8)
           │    │    ├── values
           │    │    │    ├── columns: m:7 n:8
           │    │    │    ├── cardinality: [1 - 1]
           │    │    │    ├── has-placeholder
           │    │    │    ├── key: ()
           │    │    │    ├── fd: ()-->(7,8)
           │    │    │    └── ($3, $4)
           │    │    └── filters
           │    │         ├── m:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
           │    │         └── n:8 IS NOT NULL [outer=(8), constraints=(/8: (/NULL - ]; tight)]
           │    └── projections
           │         ├── $1 [as=m_new:13]
           │         ├── $2 [as=n_new:14]
           │         ├── m:7 + n:8 [as=o:9, outer=(7,8), immutable]
           │         └── m:7 < n:8 [as=p:10, outer=(7,8)]
           └── projections
                ├── m_new:13 + n_new:14 [as=o_comp:15, outer=(13,14), immutable]
                └── m_new:13 < n_new:14 [as=p_comp:16, outer=(13,14)]

norm expect=UseSwapMutationWithProjectionProjection
UPDATE mnop SET m = $1, n = n + $2 WHERE m = $3 AND n IS NOT DISTINCT FROM $4 AND o = $5 AND NOT p
----
update (swap) mnop
 ├── columns: <none>
 ├── fetch columns: m:7 n:8 o:9 p:10
 ├── update-mapping:
 │    ├── m_new:13 => m:1
 │    ├── n_new:14 => n:2
 │    ├── o_comp:15 => o:3
 │    └── p_comp:16 => p:4
 ├── cardinality: [0 - 0]
 ├── volatile, mutations, has-placeholder
 └── project
      ├── columns: o_comp:15 p_comp:16 m:7!null n:8!null o:9!null p:10!null m_new:13 n_new:14
      ├── cardinality: [0 - 1]
      ├── immutable, has-placeholder
      ├── key: ()
      ├── fd: ()-->(7-10,13-16)
      ├── project
      │    ├── columns: m_new:13 n_new:14 o:9!null p:10!null m:7!null n:8!null
      │    ├── cardinality: [0 - 1]
      │    ├── immutable, has-placeholder
      │    ├── key: ()
      │    ├── fd: ()-->(7-10,13,14)
      │    ├── select
      │    │    ├── columns: m:7!null n:8!null
      │    │    ├── cardinality: [0 - 1]
      │    │    ├── immutable, has-placeholder
      │    │    ├── key: ()
      │    │    ├── fd: ()-->(7,8)
      │    │    ├── values
      │    │    │    ├── columns: m:7 n:8
      │    │    │    ├── cardinality: [1 - 1]
      │    │    │    ├── has-placeholder
      │    │    │    ├── key: ()
      │    │    │    ├── fd: ()-->(7,8)
      │    │    │    └── ($3, $4)
      │    │    └── filters
      │    │         ├── (m:7 + n:8) = $5 [outer=(7,8), immutable]
      │    │         ├── m:7 >= n:8 [outer=(7,8), constraints=(/7: (/NULL - ]; /8: (/NULL - ])]
      │    │         └── m:7 IS NOT NULL [outer=(7), constraints=(/7: (/NULL - ]; tight)]
      │    └── projections
      │         ├── $1 [as=m_new:13]
      │         ├── n:8 + $2 [as=n_new:14, outer=(8), immutable]
      │         ├── m:7 + n:8 [as=o:9, outer=(7,8), immutable]
      │         └── m:7 < n:8 [as=p:10, outer=(7,8)]
      └── projections
           ├── m_new:13 + n_new:14 [as=o_comp:15, outer=(13,14), immutable]
           └── m_new:13 < n_new:14 [as=p_comp:16, outer=(13,14)]
