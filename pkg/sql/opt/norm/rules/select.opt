# =============================================================================
# select.opt contains normalization rules for the Select operator.
# =============================================================================


# EliminateSelect discards an unnecessary Select operator in the case where its
# filter is always true. Keep this near the top of the file so that it tends to
# be checked early.
[EliminateSelect, Normalize]
(Select $input:* (True)) => $input

# EnsureSelectFiltersAnd replaces an And operator in a Select filter with the
# Filters operator. This allows other rules to rely upon the presence of the
# Filters when matching. See comment at top of bool.opt for more details. This
# rule is a special-case of the EnsureSelectFilters rule, for performance
# reasons (no need to construct a new conditions list) in a common case.
[EnsureSelectFiltersAnd, Normalize]
(Select
    $input:*
    (And $conditions:*)
)
=>
(Select
    $input
    (Filters $conditions)
)

# EnsureSelectFilters adds a Filters operator to a Select's filter condition
# if it does not already exist. This allows other rules to rely upon the
# presence of the Filters when matching. See comment at top of bool.opt for
# more details.
[EnsureSelectFilters, Normalize]
(Select
    $input:*
    $filter:^(Filters | And | True | False)
)
=>
(Select
    $input
    (Filters [ $filter ])
)

# MergeSelects combines two nested Select operators into a single Select that
# ANDs the filter conditions of the two Selects.
[MergeSelects, Normalize]
(Select
    (Select
        $input:*
        $innerFilter:*
    )
    $filter:*
)
=>
(Select
    $input
    (ConcatFilters $innerFilter $filter)
)

# PushSelectIntoProject pushes the Select operator into its Project input. This
# is typically preferable because it minimizes the number of rows which Project
# needs to process. This is especially important if Project is adding expensive
# computed columns.
[PushSelectIntoProject, Normalize]
(Select
    (Project
        $input:*
        $projections:*
    )
    (Filters
        $list:[ ... $condition:* & (IsBoundBy $condition $input) ... ]
    )
)
=>
(Select
    (Project
        (Select
            $input
            (Filters (ExtractBoundConditions $list $input))
        )
        $projections
    )
    (Filters (ExtractUnboundConditions $list $input))
)

# PushSelectIntoJoinLeftAndRight pushes a filter into both the left and right
# sides of a join if it can be mapped to use the columns of both sides.
# For example, consider this query:
#
#   SELECT * FROM a, b WHERE a.x=b.x AND a.y=b.y AND a.x + b.y < 5
#
# In this case, we can map a.x + b.y < 5 to both sides based on the equality
# filters a.x=b.x AND a.y=b.y. For the left side, we can map it to
# a.x + a.y < 5, and for the right side, we can map it to b.x + b.y < 5.
# Given this mapping, we can safely push the filter down to both sides and
# remove it from the Select filters list.
#
# Note that we can apply this rule to any join except for semi- and anti-joins
# because we are filtering *both* sides of the join. If we can only push down
# to one side, this rule does not apply. For example, if we push a filter to
# only the right side of a left join, that will not reduce the number of output
# rows but will result in null columns in the output.
[PushSelectIntoJoinLeftAndRight, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply |
            RightJoin | RightJoinApply | FullJoin | FullJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filters:(Filters $list:[ ... $condition:^(Eq (Variable) (Variable)) & (CanMap $filters $condition $left) & (CanMap $filters $condition $right) ... ])
)
=>
(Select
    ((OpName $input)
        (Select
            $left
            (Filters (InternSingletonList (Map $filters $condition $left)))
        )
        (Select
            $right
            (Filters (InternSingletonList (Map $filters $condition $right)))
        )
        $on
    )
    (Filters (RemoveListItem $list $condition))
)

# MapSelectIntoJoinLeft maps a filter that is not bound by the left side of
# the join to use the columns from the left side. This will allow
# the filter to be pushed down by the PushSelectIntoJoinLeft rule.
# For example, consider this query:
#
#   SELECT * FROM a, b WHERE a.x = b.x AND b.x + a.y < 5
#
# In this case, we can map b.x + a.y < 5 to the left side by replacing b.x
# with the equivalent column a.x.
# NOTE: This rule only applies to cases where it is not possible
#       to map the filter to both sides. If it can be mapped to both sides, it
#       will be handled by PushSelectIntoJoinLeftAndRight (which must be
#       ordered above this rule). For performance reasons, this rule should
#       be ordered before PushSelectIntoJoinLeft (otherwise,
#       PushSelectIntoJoinLeft might need to be applied multiple times).
[MapSelectIntoJoinLeft, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filters:(Filters $list:[ ... $condition:* & ^(Eq (Variable) (Variable)) & ^(IsBoundBy $condition $left) & (CanMap $filters $condition $left) ... ])
)
=>
(Select
    ((OpName $input)
        $left
        $right
        $on
    )
    (Filters (ReplaceListItem $list $condition (Map $filters $condition $left)))
)

# MapSelectIntoJoinRight is symmetric with MapSelectIntoJoinLeft. It maps
# Select filter conditions to use columns from the right side of the join
# rather than the left side. See that rule's comments for more details.
[MapSelectIntoJoinRight, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply | RightJoin | RightJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filters:(Filters $list:[ ... $condition:* & ^(Eq (Variable) (Variable)) & ^(IsBoundBy $condition $right) & (CanMap $filters $condition $right) ... ])
)
=>
(Select
    ((OpName $input)
        $left
        $right
        $on
    )
    (Filters (ReplaceListItem $list $condition (Map $filters $condition $right)))
)

# MergeSelectEqualityJoin merges a Select operator with an InnerJoin input by
# AND'ing the filter conditions of each and creating a new InnerJoin with that
# On condition. This is only safe to do with InnerJoin in the general case
# where the conditions could filter either left or right rows. The special case
# where a condition filters only one or the other is already taken care of by
# the PushSelectIntoJoin rules.
# NOTE: This is a specialization of MergeSelectInnerJoin for the case where
#       the inner join has an equality filter. It must be ordered before the
#       PushSelectIntoJoin rules to avoid missing out on the potential for new
#       filter inference based on equivalent columns.
[MergeSelectEqualityJoin, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply
        $left:*
        $right:*
        $on:(HasEquivalence $on)
    )
    $filter:*
)
=>
((OpName $input)
    $left
    $right
    (ConcatFilters $on $filter)
)

# PushSelectIntoJoinLeft pushes Select filter conditions into the left side of
# an input Join. This is possible in the case of InnerJoin, LeftJoin, SemiJoin,
# and AntiJoin, as long as the condition has no dependencies on the right side
# of the join. Right and Full joins are not eligible, since attempting to filter
# left rows would just result in NULL left rows instead.
#
#   -- No row is returned for a.x=1, a.y=2, b.x=1, since the WHERE excludes it.
#   SELECT * FROM a RIGHT JOIN b ON a.x=b.x WHERE a.y < 0
#
#   -- But if the filter is incorrectly pushed down in RIGHT/FULL JOIN case,
#   -- then a row containing null values on the left side is returned.
#   SELECT * FROM (SELECT * FROM a WHERE a.y < 0) a RIGHT JOIN b ON a.x=b.x
#
# Citations: [1]
[PushSelectIntoJoinLeft, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply |
            SemiJoin | SemiJoinApply | AntiJoin | AntiJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filter:(Filters $list:[ ... $condition:* & (IsBoundBy $condition $left) ... ])
)
=>
(Select
    ((OpName $input)
        (Select
            $left
            (Filters (ExtractBoundConditions $list $left))
        )
        $right
        $on
    )
    (Filters (ExtractUnboundConditions $list $left))
)

# PushSelectIntoJoinRight is symmetric with PushSelectIntoJoinLeft. It pushes
# Select filter conditions into the right side of an input Join rather than
# into the left side. See that rule's comments for more details.
[PushSelectIntoJoinRight, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply | RightJoin | RightJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filter:(Filters $list:[ ... $condition:* & (IsBoundBy $condition $right) ... ])
)
=>
(Select
    ((OpName $input)
        $left
        (Select
            $right
            (Filters (ExtractBoundConditions $list $right))
        )
        $on
    )
    (Filters (ExtractUnboundConditions $list $right))
)

# MergeSelectInnerJoin merges a Select operator with an InnerJoin input by
# AND'ing the filter conditions of each and creating a new InnerJoin with that
# On condition. This is only safe to do with InnerJoin in the general case
# where the conditions could filter either left or right rows. The special case
# where a condition filters only one or the other is already taken care of by
# the PushSelectIntoJoin rules.
# NOTE: Keep this rule ordered after the PushSelectIntoJoin rules, for
#       performance reasons. It's better to push down below the join in a
#       single step, when possible.
[MergeSelectInnerJoin, Normalize]
(Select
    $input:(InnerJoin | InnerJoinApply
        $left:*
        $right:*
        $on:*
    )
    $filter:*
)
=>
((OpName $input)
    $left
    $right
    (ConcatFilters $on $filter)
)

# PushSelectIntoGroupBy pushes a Select condition below a GroupBy in the case
# where it does not reference any of the aggregation columns. This only works
# if this is not an instance of the "scalar" GroupBy, which returns only one
# row, and which exhibits different behavior if the input is empty:
#   SELECT MAX(y) FROM a
#
# If "a" is empty, this returns a single row containing a null value. This is
# different behavior than a GroupBy with grouping columns, which would return
# the empty set for a similar query:
#   SELECT MAX(y) FROM a GROUP BY x
#
# Citations: [2]
[PushSelectIntoGroupBy, Normalize]
(Select
    (GroupBy
        $input:*
        $aggregations:*
        $def:* & ^(IsScalarGroupBy $def)
    )
    (Filters $list:[ ... $condition:* & (IsBoundBy $condition $input) ... ])
)
=>
(Select
    (GroupBy
        (Select
            $input
            (Filters (ExtractBoundConditions $list $input))
        )
        $aggregations
        $def
    )
    (Filters (ExtractUnboundConditions $list $input))
)

# RemoveNotNullCondition removes a filter with an IS NOT NULL condition
# when the given column has a NOT NULL constraint.
[RemoveNotNullCondition, Normalize]
(Select
    $input:*
    (Filters
        $list:[ ... $condition:(IsNot (Variable $col:* & (IsColNotNull $col $input)) (Null))  ... ]
    )
)
=>
(Select
    $input
    (Filters
        (RemoveListItem $list $condition)
     )
)
