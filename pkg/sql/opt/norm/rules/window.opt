# =============================================================================
# window.opt contains normalization rules for the Window operator.
# =============================================================================

# TODO(justin): add a rule to best-effort collapse same ordering+partition
# window functions, like in:
# SELECT
#     rank() OVER (PARTITION BY i), rank() OVER (PARTITION BY i, 1), rank() OVER (PARTITION BY i, 2)
# FROM
#     a

# EliminateWindow removes a Window operator with no window functions (which can
# occur via column pruning).
[EliminateWindow, Normalize]
(Window $input:* [])
=>
$input

# ReduceWindowPartitionCols reduces a set of partition columns to a simpler form
# using FDs.
[ReduceWindowPartitionCols, Normalize]
(Window
    $input:*
    $fn:*
    $private:* & (CanReduceWindowPartitionCols $input $private)
)
=>
(Window
    $input
    $fn
    (ReduceWindowPartitionCols $input $private)
)

# SimplifyWindowOrdering reduces an ordering to a simpler form using FDs.
[SimplifyWindowOrdering, Normalize]
(Window
    $input:*
    $fn:*
    $private:* & (CanSimplifyWindowOrdering $input $private)
)
=>
(Window
    $input
    $fn
    (SimplifyWindowOrdering $input $private)
)

# PushSelectIntoWindow pushes down a Select which can be satisfied by only the
# functional closure of the columns being partitioned over. This is valid
# because it's "all-or-nothing" - we only entirely eliminate a partition or
# don't eliminate it at all.
[PushSelectIntoWindow, Normalize]
(Select
    (Window
      $input:*
      $fn:*
      $private:*
    )
    $filters:[
        ...
        $item:* & (IsDeterminedBy $item $partitionCols:(WindowPartition $private) $input)
        ...
    ]
)
=>
(Select
    (Window
        (Select
            $input
            (ExtractDeterminedConditions $filters $partitionCols $input)
        )
        $fn
        $private
    )
    (ExtractUndeterminedConditions $filters $partitionCols $input)
)

# PushLimitIntoWindow moves a Limit below a Window when able.  This is
# all-or-nothing. Even if we could push the limit below *some* of the window
# functions, if there are any we cannot, then we don't. This is because
# computing additional window functions is not that expensive, and the
# expensive part is doing the sorting and partitioning. Once exec supports
# passing orderings through and does not require re-partitioning and re-sorting
# of window functions, pushing past some-but-not-all of the window functions
# might be profitable.
# 
# SELECT rank() OVER (ORDER BY c) FROM abc ORDER BY c LIMIT 10
# => 
# SELECT
#     rank() OVER (ORDER BY c)
# FROM
#     (SELECT c FROM abc ORDER BY c LIMIT 10)
# 
# SELECT rank() OVER (PARTITION BY b ORDER BY c) FROM abc LIMIT 10
# => 
# SELECT
#     rank() OVER (PARTITION BY b ORDER BY c)
# FROM
#     (SELECT b, c FROM abc ORDER BY b, c LIMIT 10)
# 
# First, we construct a "segmented ordering" consisting of the Window's
# partition columns followed by its ordering columns (the relative positions of
# the partition columns are arbitrary). This ordering is useful because it
# performs the partitioning and then the ordering within each partition.  If
# this ordering is not stronger than the Limit's ordering, we do not proceed.
# 
# Since we now know that the segmented ordering is stronger than the Limit's
# ordering, it's safe to replace the limit with it.
# 
# The Limit having the segmented ordering means that the Limit will then "cut
# off" at most one partition, the one which is ordered last. The window
# function's ordering does not matter for all of the not-cut-off partitions,
# but the one that *does* get cut off, we need to ensure that the limit
# operator allows through a prefix of it, rather than an arbitrary ordering.
# 
# Finally, we require that every window function being computed has the
# "prefix-safe" property.  A window function is prefix safe if it can be
# correctly computed over only a prefix of a partition. For example,
# rank() has this property because rows that come later in the ordering
# don't affect the rank of the rows before, but avg() doesn't, because we
# must see the entire partition to compute the average over it.
#
# TODO(justin): Add a rule that translates a limit with an ordering on rank()
# or dense_rank() into one with an ordering on the ordering of the window
# function. This will allow us to push down limits in cases like:
#
# SELECT rank() OVER (ORDER BY f) rnk FROM a ORDER BY rnk LIMIT 10
#  or
# SELECT rank() OVER (PARTITION BY i ORDER BY f) rnk FROM a ORDER BY i, rnk LIMIT 10
[PushLimitIntoWindow, Normalize]
(Limit
    (Window
        $input:*
        $fns:* & (AllArePrefixSafe $fns)
        $private:*
    )
    $limit:*
    $ordering:* & (ImpliesOrdering
        $newOrdering:(PrependColsToOrdering
            (WindowPartition $private)
            (WindowOrdering $private)
        )
        $ordering
    )
)
=>
(Window
    (Limit
        $input
        $limit
        $newOrdering
    )
    $fns
    $private
)
