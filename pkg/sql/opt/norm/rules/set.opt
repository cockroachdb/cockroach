# =============================================================================
# set.opt contains normalization rules for set operators.
# =============================================================================

# EliminateUnionAllLeft replaces a union all with a right side having a
# cardinality of zero, with just the left side operand.
[EliminateUnionAllLeft, Normalize]
(UnionAll
    $left:*
    $right:* & (HasZeroRows $right)
    $colmap:*
)
=>
(Project
    $left
    (ProjectColMapLeft $colmap)
    (MakeEmptyColSet)
)

# EliminateUnionAllRight replaces a union all with a left side having a
# cardinality of zero, with just the right side operand.
[EliminateUnionAllRight, Normalize]
(UnionAll
    $left:* & (HasZeroRows $left)
    $right:*
    $colmap:*
)
=>
(Project
    $right
    (ProjectColMapRight $colmap)
    (MakeEmptyColSet)
)

# PushFilterIntoSetOp pushes a filter into both the left and right sides
# of all set operators after being mapped to use the columns of both sides.
# For example, consider this query:
#
#   SELECT * FROM (SELECT x FROM a UNION ALL SELECT y FROM b) WHERE x < 5
#
# In this case, we can map x < 5 to both sides based on the knowledge that
# in the union the x out col corresponds to the x column in the (a) table and
# the y column in the (b) table. Therefore our mapping becomes x < 5 in the
# left side, and y <  5 in the right side.
# Given this mapping, we can now safely push the filter down to both sides.
#
# Pushing (all) the filters down for each of the set operators (Union, Union
# All, Except, Except All, Intersect, Intersect All) is logically equivalent
# to filtering after applying the set operator. Here's some justification for
# this claim:
# 
# Two relations are union compatible when they have the same number of
# attributes/column and the domain/type of the corresponding/similar attribute
# in each relation is the same as the other. Notice that each of the set
# operators this rule applies to, only works on union compatible relations.
# The resulting column set after applying the set operator, is also necessarily
# a subset of the column set of the (any) relations it was composed of.
# And so, any filter applied must have a corresponding column in each of the
# base relations.
#
# Here's a claim that requires no proof: pushing the filter down for any of
# the aforementioned set operators is logically incorrect (not equivalent to
# filtering after applying the operator) iff some row has been filtered that
# shouldn't have been, or if some row wasn't filtered when it should have been.
# For some row to be in the result set, it must satisfy the filter condition
# and the condition logically implied by the set operators (Union, Except,
# Intersect). These conditions are independent and so the order in which they
# are satisfied don't matter for correctness. Pushing down the filter
# accomplishes both these conditions and so is logically correct.
#
# Visualization of the rule:
# Let A and B be sets. Let the filter be represented by eliminating some set C.
#
# Union (All):        (A Union B) \ C => (A \ C) Union (B \ C)
# Intersection (All): (A Intersect B) \ C => (A \ C) Intersect (B \ C)
# Except (All):       (A Except B) \ C => (A \ C) Except (B \ C)
[PushFilterIntoSetOp, Normalize]
(Select
    $input:(Set $left:* $right:* $colmap:*)
    $filter:*
)
=>
((OpName $input)
    (Select
        $left
        (MapFiltersOnLeft $filter $colmap)
    )
    (Select
        $right
        (MapFiltersOnRight $filter $colmap)
    )
    $colmap
)
