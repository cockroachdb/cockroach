# =============================================================================
# limit.opt contains normalization rules for the Limit and Offset operators.
# =============================================================================

# Max1RowLimit inserts a LIMIT 2 "under" Max1Row so as to save resources
# to make the Max1Row determination.
#
# This rule is defined here instead of max1row.opt so that it runs
# before the limit elimination rules below.
#
# We avoid this rule if the query is decorrelated because the
# decorrelation rules get confused by the presence of a limit.
# (It will be worth re-considering this when a general-purpose apply
# operator is supported - in that case it can be definitely worthwhile
# pushing down a LIMIT 2 to limit the amount of work done on every row.)
[Max1RowLimitScan, Normalize]
(Max1Row
    $input:* & ^(HasZeroOrOneRow $input) & ^(HasOuterCols $input)
    $subqueryPrivate:* & ^(IsSubqueryLimited $subqueryPrivate))
=>
((OpName)
    (Limit $input (Const 2) (EmptyOrdering))
    (SetSubqueryLimited $subqueryPrivate))

# EliminateLimit discards a Limit operator if its constant limit is greater than
# or equal to the maximum number of rows that can be returned by the input. In
# this case, the Limit is just a no-op, because the rows are already limited.
[EliminateLimit, Normalize]
(Limit
    $input:*
    (Const $limit:*) & (LimitGeMaxRows $limit $input)
)
=>
$input

# PushLimitIntoProject pushes the Limit operator into its Project input. It is
# desirable to push the Limit operator as low in the query as possible, in order
# to minimize the number of rows that other operators need to process.
[PushLimitIntoProject, Normalize]
(Limit
    (Project $input:* $projections:* $passthrough:*)
    $limit:*
    $ordering:* & (HasColsInOrdering $input $ordering)
)
=>
(Project
    (Limit $input $limit (PruneOrdering $ordering (OutputCols $input)))
    $projections
    $passthrough
)

# PushOffsetIntoProject pushes the Offset operator into its Project input. It is
# desirable to push the Offset operator as low in the query as possible, in
# order to minimize the number of rows that other operators need to process.
[PushOffsetIntoProject, Normalize]
(Offset
    (Project $input:* $projections:* $passthrough:*)
    $offset:*
    $ordering:* & (HasColsInOrdering $input $ordering)
)
=>
(Project
    (Offset $input $offset (PruneOrdering $ordering (OutputCols $input)))
    $projections
    $passthrough
)
