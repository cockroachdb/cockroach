# =============================================================================
# decorrelate.opt contains normalization patterns that try to eliminate
# correlated subqueries. A correlated subquery is a subquery with one or more
# outer columns. For example:
#
#   SELECT * FROM a WHERE (SELECT b.y FROM b WHERE a.x=b.x) < 5
#
# A correlated join has outer columns in its right input that refer to columns
# in its left input. For example:
#
#   SELECT * FROM a INNER JOIN LATERAL (SELECT * FROM b WHERE a.x=b.x)
#
# Normalization rules "hoist" or "pull up" subqueries so that they are directly
# joined with the outer relation to which they are bound. Other patterns try
# to "push down" correlated joins (apply) until they disappear or can no
# longer be pushed further. An apply join can be rewritten as a non-apply join
# once there are no outer columns in the right side of the join that are bound
# by the left side of the join (i.e. the inputs are not "correlated").
#
# Together, these pattens tend to eliminate unnecessary correlation, which has
# the desirable effect of eliminating patterns that can only be executed using
# often expensive nested loops, and instead open up other physical plan
# possibilities.
#
# Citations: [3]
# =============================================================================


# DecorrelateJoin maps an apply join into the corresponding join without an
# apply if the right side of the join is not correlated with the left side.
# This allows the optimizer to consider additional physical join operators that
# are unable to handle correlated inputs.
#
# NOTE: Keep this before other decorrelation patterns, as if the correlated
#       join can be removed first, it avoids unnecessarily matching other
#       patterns that only exist to get to this pattern.
#
# Citations: [3]
[DecorrelateJoin, Normalize]
(JoinApply
    $left:*
    $right:* & ^(IsCorrelated $right $left)
    $on:*
)
=>
(ConstructNonApplyJoin (OpName) $left $right $on)

# TryDecorrelateSelect "pushes down" the join apply into the select operator,
# in order to eliminate any correlation between the select filter list and the
# left side of the join, and also to keep "digging" down to find and eliminate
# other unnecessary correlation. Eventually, the hope is to trigger the
# DecorrelateJoin pattern to turn JoinApply operators into non-apply Join
# operators.
#
# This rule triggers a cycle with the PushFilterIntoJoinRight rule. Because this
# rule has the DetectCycle tag, it is skipped once a cycle is detected. This
# gives the PushFilterIntoJoinRight rule one last chance to push Select into the
# right input, and therefore causes the normal form to be (Join (Select)) rather
# than (Select (Join)) when the choice is ambiguous.
#
# This rule is marked as high priority so that it always runs before the
# PushFilterIntoJoinRight rule. A Select operator with outer columns is always
# pulled up as far as possible before being pushed back down.
#
# Note that citation [3] doesn't directly contain this identity, since it
# assumes that the Select will be hoisted above the Join rather than becoming
# part of its On condition. PushFilterIntoJoinRight allows the condition to be
# pushed down, so this rule can correctly pull it up.
#
# Citations: [3] (see identity #3)
[TryDecorrelateSelect, Normalize, DetectCycle, HighPriority]
(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply |
 SemiJoin | SemiJoinApply | AntiJoin | AntiJoinApply
    $left:*
    $right:* & (HasOuterCols $right) & (Select $input:* $filter:*)
    $on:*
)
=>
((OpName)
    $left
    $input
    (ConcatFilters $on $filter)
)

# TryDecorrelateProject "pushes down" a Join into a Project operator, in an
# attempt to eliminate any correlation between the projection list and the left
# side of the join, and also to keep "digging" down to find and eliminate other
# unnecessary correlation. The eventual hope is to trigger the DecorrelateJoin
# rule to turn a JoinApply operator into a non-apply Join operator.
#
# Citations: [3] (see identity #4)
[TryDecorrelateProject, Normalize]
(InnerJoin | InnerJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (Project $input:* $projections:*)
    $on:*
)
=>
(Select
    (Project
        ((OpName)
            $left
            $input
            (True)
        )
        (ProjectColsFromBoth $projections $left)
    )
    $on
)

# TryDecorrelateProjectSelect tries to decorrelate by hoisting a Select operator
# that sits below a LeftJoin/Project operator combo. The Project operator itself
# can't be reordered above the LeftJoin like it can in the InnerJoin case.
# However, the Select filter can be merged with the LeftJoin filter, which is
# enough to decorrelate in several useful cases.
#
# See the comment for TryDecorrelateSelect for an explanation of why the
# DetectCycle and HighPriority tags are in use.
[TryDecorrelateProjectSelect, Normalize, DetectCycle, HighPriority]
(LeftJoinApply
    $left:*
    $right:(Project
        (Select
            $selectInput:*
            $filters:* & ^(IsBoundBy $filters (OutputCols $selectInput))
        )
        $projections:*
    )
    $on:*
)
=>
(Project
    ((OpName)
        $left
        (Project
            $selectInput
            (ProjectColsFromBoth $projections $selectInput)
        )
        (ConcatFilters $on $filters)
    )
    (ProjectColsFromBoth $left $right)
)

# TryDecorrelateProjectInnerJoin tries to decorrelate by hoisting the filter of
# an InnerJoin operator that sits below a LeftJoin/Project operator combo. The
# Project operator itself can't be reordered above the LeftJoin like it can in
# the InnerJoin case. However, the InnerJoin filter can be merged with the
# LeftJoin filter, which is enough to decorrelate in several useful cases. This
# rule works similarly to TryDecorrelateProjectSelect.
#
# See the comment for TryDecorrelateSelect for an explanation of why the
# DetectCycle and HighPriority tags are in use.
[TryDecorrelateProjectInnerJoin, Normalize, DetectCycle, HighPriority]
(LeftJoinApply
    $left:*
    $right:(Project
        $join:(InnerJoin | InnerJoinApply
            $innerLeft:*
            $innerRight:*
            $innerOn:* & ^(IsBoundBy $innerOn (OutputCols2 $innerLeft $innerRight))
        )
        $projections:*
    )
    $on:*
)
=>
(Project
    (LeftJoinApply
        $left
        (Project
            ((OpName $join)
                $innerLeft
                $innerRight
                (True)
            )
            (ProjectColsFromBoth $projections $join)
        )
        (ConcatFilters $on $innerOn)
    )
    (ProjectColsFromBoth $left $right)
)

# TryDecorrelateInnerJoin tries to decorrelate an InnerJoin operator nested
# beneath another Join operator by pulling up its join condition to the outer
# join. This may be enough to decorrelate the outer join, or it may allow any
# outer column references to continue to journey upwards.
#
# See the comment for TryDecorrelateSelect for an explanation of why the
# DetectCycle and HighPriority tags are in use.
#
# TODO(andyk): Consider adding case for outer cols in $left.
[TryDecorrelateInnerJoin, Normalize, DetectCycle, HighPriority]
(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply |
 SemiJoin | SemiJoinApply | AntiJoin | AntiJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (InnerJoin | InnerJoinApply
            $innerLeft:*
            $innerRight:*
            $innerOn:*
        )
    $on:*
)
=>
((OpName)
    $left
    ((OpName $right)
        $innerLeft
        $innerRight
        (True)
    )
    (ConcatFilters $on $innerOn)
)

# TryDecorrelateInnerLeftJoin tries to decorrelate a LeftJoin operator nested
# beneath an InnerJoin operator by using the associative identity to pull up the
# left join to become the outer join. This may be enough to decorrelate the
# outer join, or it may allow any outer column references to continue to journey
# upwards.
#
# Citations: [1] (see identity #6)
[TryDecorrelateInnerLeftJoin, Normalize]
(InnerJoin | InnerJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (LeftJoin
            $innerLeft:*
            $innerRight:*
            $innerOn:*
        )
    $on:* & (IsBoundBy $on (OutputCols2 $left $innerLeft))
)
=>
(LeftJoinApply
    ((OpName)
        $left
        $innerLeft
        $on
    )
    $innerRight
    $innerOn
)

# TryDecorrelateGroupBy "pushes down" a Join into a GroupBy operator, in an
# attempt to keep "digging" down to find and eliminate unnecessary correlation.
# The eventual hope is to trigger the DecorrelateJoin rule to turn a JoinApply
# operator into a non-apply Join operator.
#
# Example:
#
#   SELECT left.x, left.y, input.*
#   FROM left
#   INNER JOIN LATERAL
#   (
#     SELECT COUNT(*) FROM input WHERE input.x = left.x GROUP BY c
#   ) AS input
#   ON left.y = 10
#   =>
#   SELECT CONST_AGG(left.x), CONST_AGG(left.y), COUNT(*)
#   FROM left WITH ORDINALITY
#   INNER JOIN LATERAL
#   (
#     SELECT * FROM input WHERE input.x = left.x
#   ) AS input
#   ON True
#   GROUP BY input.c, left.ordinality
#   HAVING left.y = 10
#
# In other cases, we can use an existing non-null column as a canary; that
# column would not be constant necessarily, hence the use of ANY_NOT_NULL
# instead of CONST_AGG.
#
# An ordinality column only needs to be synthesized if "left" does not already
# have a strict key.
#
# CONST_AGG is an internal aggregation function used when all rows in the
# grouping set have the same value on the column.
#
# Citations: [3] (see identity #8)
[TryDecorrelateGroupBy, Normalize]
(InnerJoin | InnerJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (GroupBy | DistinctOn
            $input:*
            $aggregations:*
            $def:*
        ) &
        (IsUnorderedGroupBy $def)
    $on:*
)
=>
(Select
    ((OpName $right)
        (InnerJoinApply
            $newLeft:(EnsureKey $left)
            $input
            (True)
        )
        (AppendAggCols
            $aggregations
            ConstAgg (NonKeyCols $newLeft)
        )
        (AddColsToGroupByDef $def (KeyCols $newLeft))
    )
    $on
)

# TryDecorrelateScalarGroupBy "pushes down" a Join into a ScalarGroupBy
# operator, in an attempt to keep "digging" down to find and eliminate
# unnecessary correlation. The eventual hope is to trigger the DecorrelateJoin
# rule to turn a JoinApply operator into a non-apply Join operator. This rule
# has several requirements:
#
#   1. The left input must have a strict key. If not already present, a key can
#      be synthesized by using the RowNumber operator to uniquely number the
#      rows.
#   2. All aggregate functions must ignore null values, so that they will
#      ignore the null values generated by the left join. We can remap the ones
#      that do not ignore null values:
#       - CountRows is mapped into a Count aggregate that operates over a
#         not-null column from the right input (one is synthesized if
#         necessary).
#       - ConstAgg is mapped into the less restrictive ConstNotNullAgg.
#       - Any other operator which doesn't ignore NULLs can be replaced with a
#         projection taking into account a non-null column (one is synthesized
#         if necessary) to distinguish NULLs which were present in the right
#         input from those that arose from the left join:
#
#         CASE
#           WHEN notnull IS NOT NULL THEN aggregated_value
#           ELSE NULL
#         END
#
#         This works because for every group there is just one left row
#         (because we group by its key), and if there are right rows we can
#         take the aggregation verbatim, but if there were no matches on the
#         right we need to return the appropriate "0 rows" value for that
#         aggregate (which for now is assumed to be NULL).
#
# Example:
#
#   SELECT left.x, left.y, input.*
#   FROM left
#   INNER JOIN LATERAL
#   (
#     SELECT COUNT(*), SUM(c) FROM input WHERE input.x = left.x
#   ) AS input
#   ON left.y = 10
#   =>
#   SELECT CONST_AGG(left.x), CONST_AGG(left.y), COUNT(input.t), SUM(input.c)
#   FROM left WITH ORDINALITY
#   LEFT JOIN LATERAL
#   (
#     SELECT c, True t FROM input WHERE input.x = left.x
#   ) AS input
#   ON True
#   GROUP BY left.ordinality
#   HAVING left.y = 10
#
# Non-null ignoring example:
#
#   SELECT left.x, input.*
#   FROM left
#   INNER JOIN LATERAL
#   (
#     SELECT ARRAY_AGG(c) FORM INPUT WHERE input.x = left.x
#   ) AS input
#   ON left.y = 10
#   =>
#   SELECT
#   CONST_AGG(left.x),
#   CASE
#     WHEN ANY_NOT_NULL(notnull) IS NOT NULL THEN aggregated_value
#     ELSE NULL
#   END
#   FROM left WITH ORDINALITY
#   LEFT JOIN LATERAL
#   (
#     SELECT c, True notnull FROM input WHERE input.x = left.x
#   ) AS input
#   GROUP BY left.ordinality
#   HAVING left.y = 10
#
# In this example, the "notnull" canary is needed to determine if the value of
# the ARRAY_AGG aggregation should be NULL or {NULL}.
#
# An ordinality column only needs to be synthesized if "left" does not already
# have a key. The "true" column only needs to be added if "input" does not
# already have a not-null column (and COUNT(*) is used).
#
# CONST_AGG is an internal aggregation function used when all rows in the
# grouping set have the same value on the column.
#
# Citations: [3] (see identity #9)
[TryDecorrelateScalarGroupBy, Normalize]
(InnerJoin | InnerJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (ScalarGroupBy
            $input:*
            $aggregations:*
            $def:*
        ) &
        (AggsCanBeDecorrelated $aggregations)
    $on:*
)
=>
(Select
    # TranslateNonIgnoreAggs is where the actual discriminating CASE
    # expressions are introduced.
    (TranslateNonIgnoreAggs
        (GroupBy
            (LeftJoinApply
                $leftWithKey:(EnsureKey $left)
                # canaryCol might be 0 if no canary is necessary, in which case
                # this function does nothing.
                $rightWithCanary:(EnsureCanary
                    $input
                    $canaryCol:(EnsureCanaryCol $input $aggregations)
                )
                (True)
            )
            (AppendAggCols2
                $translatedAggs:(EnsureAggsCanIgnoreNulls
                    $rightWithCanary
                    $aggregations
                )
                ConstAgg (NonKeyCols $leftWithKey)
                AnyNotNullAgg (CanaryColSet $canaryCol)
            )
            (MakeOrderedGroupByDef (KeyCols $leftWithKey) (ExtractGroupByOrdering $def))
        )
        $translatedAggs
        $rightWithCanary
        $aggregations
        $canaryCol
    )
    $on
)

# TryDecorrelateSemiJoin maps a SemiJoin to an equivalent GroupBy/InnerJoin
# complex in hopes of triggering further rules that will ultimately decorrelate
# the query. Once this rule fires, a corresponding InnerJoin decorrelation rule
# will match (i.e. TryDecorrelateGroupBy or TryDecorrelateProject).
#
# Citations: [5]
[TryDecorrelateSemiJoin, Normalize]
(SemiJoin | SemiJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (CanHaveZeroRows $right) & # Let EliminateExistsGroupBy match instead.
        (GroupBy | DistinctOn | Project)
    $on:*
)
=>
(GroupBy
    (InnerJoinApply
        $newLeft:(EnsureKey $left)
        $right
        $on
    )
    (MakeAggCols ConstAgg (NonKeyCols $newLeft))
    (MakeGroupByDef (KeyCols $newLeft))
)

# TryDecorrelateLimitOne "pushes down" a Join into a Limit 1 operator, in an
# attempt to keep "digging" down to find and eliminate unnecessary correlation.
# The eventual hope is to trigger the DecorrelateJoin rule to turn a JoinApply
# operator into a non-apply Join operator.
#
# Like the TryDecorrelateGroupBy and TryDecorrelateScalarGroupBy rules, this
# rule rewrites the expression to perform the join first, followed by a grouping
# that eliminates any extra rows introduced by the join. The DistinctOn operator
# uses First aggregates to select values from the first row in each group. Non-
# key columns from the left join input become Const aggregates, since they are
# functionally dependent on the grouped key columns (and are therefore constant
# in each group).
#
# TODO(andyk): Add other join types.
[TryDecorrelateLimitOne, Normalize]
(InnerJoin | InnerJoinApply | LeftJoin | LeftJoinApply
    $left:*
    $right:* &
        (HasOuterCols $right) &
        (Limit $input:* (Const 1) $ordering:*)
    $on:*
)
=>
(DistinctOn
    ((OpName)
        $newLeft:(EnsureKey $left)
        $input
        $on
    )
    (MakeAggCols2
        ConstAgg (NonKeyCols $newLeft)
        FirstAgg (OutputCols $input)
    )
    (MakeOrderedGroupByDef (KeyCols $newLeft) (ExtractOrdering $ordering))
)

# TryDecorrelateZip "pushes down" an outer InnerJoinApply operator into an inner
# InnerJoinApply operator, in hopes of eliminating any correlation between the
# Zip operator and the outer InnerJoinApply operator. Eventually, the hope is to
# trigger the DecorrelateJoin pattern to turn JoinApply operators into non-apply
# Join operators.
#
# This rule only matches Zip as $innerRight because other relational operators
# can decorrelate by pushing parent joins down into an input operand. But Zip
# does not have an input operand of its own, and so it uses InnerJoinApply as a
# proxy for that, and pushes other operators down through that instead.
#
# TODO(andyk): Consider creating a single ProjectSet relational operator, rather
#              than using InnerJoinApply + Zip, which seems fragile.
[TryDecorrelateZip, Normalize]
(InnerJoinApply
    $left:*
    (InnerJoinApply
        $innerLeft:*
        $innerRight:(Zip)
        $innerOn:*
    )
    $on:*
)
=>
(InnerJoinApply
    (InnerJoinApply
        $left
        $innerLeft
        (True)
    )
    $innerRight
    (ConcatFilters $on $innerOn)
)

# HoistSelectExists extracts existential subqueries from Select filters,
# turning them into semi-joins. This eliminates the subquery, which is often
# expensive to execute and restricts the optimizer's plan choices.
#
# This rule is marked as low priority so that it runs after other rules like
# filter pushdown. Hoisting a correlated subquery is an expensive operation that
# can't be undone, so do it only once all other work is complete. For example,
# filter pushdown rules might be able to move the subquery nearer to the input
# to which it's correlated before it's hoisted, making it easier to decorrelate.
[HoistSelectExists, Normalize, LowPriority]
(Select
    $input:*
    $filter:* &
        (HasHoistableSubquery $filter) &
        (Filters
            $list:[ ... $exists:(Exists $subquery:* & (HasOuterCols $subquery)) ... ]
        )
)
=>
(Select
    (SemiJoinApply
        $input
        $subquery
        (True)
    )
    (Filters (RemoveListItem $list $exists))
)

# HoistSelectNotExists extracts non-existential subqueries from Select filters,
# turning them into anti-joins. This eliminates the subquery, which is often
# expensive to execute and restricts the optimizer's plan choices.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
[HoistSelectNotExists, Normalize, LowPriority]
(Select
    $input:*
    $filter:* &
        (HasHoistableSubquery $filter) &
        (Filters
            $list:[ ... $exists:(Not (Exists $subquery:* & (HasOuterCols $subquery))) ... ]
        )
)
=>
(Select
    (AntiJoinApply
        $input
        $subquery
        (True)
    )
    (Filters (RemoveListItem $list $exists))
)

# HoistSelectSubquery extracts subqueries from a Select filter and joins them
# with the Select input. This and other subquery hoisting patterns create a
# single, top-level relational query with no nesting.
#
# NOTE: Keep this ordered after the HoistSelectExists and HoistSelectNotExists
#       rules. This rule will hoist any existential subqueries using
#       LeftJoinApply, which is equivalent to, but not as efficient as, using
#       SemiJoinApply and AntiJoinApply.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
#
# Citations: [4]
[HoistSelectSubquery, Normalize, LowPriority]
(Select
    $input:*
    $filter:* & (HasHoistableSubquery $filter) & (Filters)
)
=>
(HoistSelectSubquery $input $filter)

# HoistProjectSubquery extracts subqueries from a projections list and joins
# them with the Project input. This and other subquery hoisting patterns create
# a single, top-level relational query with no nesting.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
[HoistProjectSubquery, Normalize, LowPriority]
(Project
    $input:*
    $projections:* & (HasHoistableSubquery $projections)
)
=>
(HoistProjectSubquery $input $projections)

# HoistJoinSubquery extracts subqueries from a join filter and joins them with
# the join's right input. This and other subquery hoisting patterns create a
# single, top-level relational query with no nesting.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
[HoistJoinSubquery, Normalize, LowPriority]
(Join
    $left:*
    $right:*
    $on:* & (HasHoistableSubquery $on) & (Filters)
)
=>
(HoistJoinSubquery (OpName) $left $right $on)

# HoistValuesSubquery extracts subqueries from row tuples and joins them with
# the Values operator. This and other subquery hoisting patterns create a
# single, top-level relational query with no nesting.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
[HoistValuesSubquery, Normalize, LowPriority]
(Values
    $rows:[ ... $item:* & (HasHoistableSubquery $item) ... ]
    $cols:*
)
=>
(HoistValuesSubquery $rows $cols)

# HoistZipSubquery extracts subqueries from zipped functions and joins them with
# the Zip operator using an Apply join. This and other subquery hoisting
# patterns create a single, top-level relational query with no nesting.
#
# This rule is marked as low priority for the same reason as HoistSelectExists.
[HoistZipSubquery, Normalize, LowPriority]
(Zip
    $funcs:[ ... $item:* & (HasHoistableSubquery $item) ... ]
    $cols:*
)
=>
(HoistZipSubquery $funcs $cols)

# NormalizeAnyFilter rewrites Any into Exists when it's a top-level conjunct in
# a Select or Join filter. Any can be rewritten as Exists in this context
# because a NULL return value is treated as False by the filter.
#
# Exists is more efficient than Any, since its null handling is much simpler. In
# addition, the Exists can be transformed into a semi-join.
[NormalizeAnyFilter, Normalize]
(Filters
    $list:[ ... $any:(Any $input:* $scalar:* $subqueryDef:*) ... ]
)
=>
(Filters
    (ReplaceListItem
        $list
        $any
        (Exists
            (Select
                $input
                (Filters [ (ConstructAnyCondition $input $scalar $subqueryDef) ])
            )
            $subqueryDef
        )
    )
)

# NormalizeNotAnyFilter rewrites Not Any into Not Exists when it's a top-level
# conjunct in a Select or Join filter. Not Any can be rewritten as Not Exists in
# this context because a NULL return value is treated as False by the filter.
#
# Exists is more efficient than Any, since its null handling is much simpler. In
# addition, the Not Exists can be transformed into an anti-join.
#
# Citations: [5] (section 3.5)
[NormalizeNotAnyFilter, Normalize]
(Filters
    $list:[ ... $notany:(Not (Any $input:* $scalar:* $subqueryDef:*)) ... ]
)
=>
(Filters
    (ReplaceListItem
        $list
        $notany
        (Not
            (Exists
                (Select
                    $input
                    (Filters
                        [ (IsNot (ConstructAnyCondition $input $scalar $subqueryDef) (False)) ]
                    )
                )
                $subqueryDef
            )
        )
    )
)
