// Copyright 2018 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package norm

import (
	"fmt"

	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/xfunc"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/types"
	"github.com/cockroachdb/cockroach/pkg/util"
)

// MatchedRuleFunc defines the callback function for the NotifyOnMatchedRule
// event supported by the optimizer and factory. It is invoked each time an
// optimization rule (Normalize or Explore) has been matched. The name of the
// matched rule is passed as a parameter. If the function returns false, then
// the rule is not applied (i.e. skipped).
type MatchedRuleFunc func(ruleName opt.RuleName) bool

// AppliedRuleFunc defines the callback function for the NotifyOnAppliedRule
// event supported by the optimizer and factory. It is invoked each time an
// optimization rule (Normalize or Explore) has been applied. The function is
// called with the name of the rule and the memo group it affected. If the rule
// was an exploration rule, then the added parameter gives the number of
// expressions added to the group by the rule.
type AppliedRuleFunc func(ruleName opt.RuleName, group memo.GroupID, added int)

// Factory constructs a normalized expression tree within the memo. As each
// kind of expression is constructed by the factory, it transitively runs
// normalization transformations defined for that expression type. This may
// result in the construction of a different type of expression than what was
// requested. If, after normalization, the expression is already part of the
// memo, then construction is a no-op. Otherwise, a new memo group is created,
// with the normalized expression as its first and only expression.
//
// The result of calling each Factory Construct method is the id of the group
// that was constructed. Callers can access the normalized expression tree that
// the factory constructs by creating a memo.ExprView, like this:
//
//   ev := memo.MakeNormExprView(f.Memo(), group)
//
// Factory is largely auto-generated by optgen. The generated code can be found
// in factory.og.go. The factory.go file contains helper functions that are
// invoked by normalization patterns. While most patterns are specified in the
// optgen DSL, the factory always calls the `onConstruct` method as its last
// step, in order to allow any custom manual code to execute.
type Factory struct {
	mem     *memo.Memo
	evalCtx *tree.EvalContext
	props   rulePropsBuilder

	// scratchItems is a slice that is reused by projectionsBuilder to store
	// temporary results that are accumulated before constructing a new
	// Projections operator.
	scratchItems []memo.GroupID

	// scratchColList is a ColList that is reused by projectionsBuilder to store
	// temporary results that are accumulated before constructing a new
	// Projections operator.
	scratchColList opt.ColList

	// ruleCycles is used to detect cyclical rule invocations. Each rule with
	// the "DetectCycles" tag adds its expression fingerprint into this map
	// before constructing its replacement. If the replacement pattern recursively
	// invokes the same rule (or another rule with the DetectCycles tag) with that
	// same fingerprint, then the rule sees that the fingerprint is already in the
	// map, and will skip application of the rule.
	ruleCycles map[memo.Fingerprint]bool

	// matchedRule is the callback function that is invoked each time a normalize
	// rule has been matched by the factory. It can be set via a call to the
	// NotifyOnMatchedRule method.
	matchedRule MatchedRuleFunc

	// appliedRule is the callback function which is invoked each time a normalize
	// rule has been applied by the factory. It can be set via a call to the
	// NotifyOnAppliedRule method.
	appliedRule AppliedRuleFunc

	// funcs is the struct used to call all custom match and replace functions
	// used by the normalization rules. It wraps an unnamed xfunc.CustomFuncs,
	// so it provides a clean interface for calling functions from both the norm
	// and xfunc packages using the same prefix.
	funcs CustomFuncs
}

// NewFactory returns a new Factory structure with a new, blank memo structure
// inside.
func NewFactory(evalCtx *tree.EvalContext) *Factory {
	mem := memo.New()
	f := &Factory{
		mem:        mem,
		evalCtx:    evalCtx,
		props:      rulePropsBuilder{mem: mem},
		ruleCycles: make(map[memo.Fingerprint]bool),
		funcs:      CustomFuncs{CustomFuncs: xfunc.MakeCustomFuncs(mem, evalCtx)},
	}
	f.funcs.f = f
	return f
}

// DisableOptimizations disables all transformation rules. The unaltered input
// expression tree becomes the output expression tree (because no transforms
// are applied).
func (f *Factory) DisableOptimizations() {
	f.NotifyOnMatchedRule(func(opt.RuleName) bool { return false })
}

// NotifyOnMatchedRule sets a callback function which is invoked each time a
// normalize rule has been matched by the factory. If matchedRule is nil, then
// no further notifications are sent, and all rules are applied by default. In
// addition, callers can invoke the DisableOptimizations convenience method to
// disable all rules.
func (f *Factory) NotifyOnMatchedRule(matchedRule MatchedRuleFunc) {
	f.matchedRule = matchedRule
}

// NotifyOnAppliedRule sets a callback function which is invoked each time a
// normalize rule has been applied by the factory. If appliedRule is nil, then
// no further notifications are sent.
func (f *Factory) NotifyOnAppliedRule(appliedRule AppliedRuleFunc) {
	f.appliedRule = appliedRule
}

// Memo returns the memo structure that the factory is operating upon.
func (f *Factory) Memo() *memo.Memo {
	return f.mem
}

// Metadata returns the query-specific metadata, which includes information
// about the columns and tables used in this particular query.
func (f *Factory) Metadata() *opt.Metadata {
	return f.mem.Metadata()
}

// ConstructSimpleProject is a convenience wrapper for calling
// ConstructProject when there are no synthesized columns.
func (f *Factory) ConstructSimpleProject(
	input memo.GroupID, passthroughCols opt.ColSet,
) memo.GroupID {
	def := memo.ProjectionsOpDef{PassthroughCols: passthroughCols}
	return f.ConstructProject(
		input,
		f.ConstructProjections(memo.EmptyList, f.InternProjectionsOpDef(&def)),
	)
}

// InternList adds the given list of group IDs to memo storage and returns an
// ID that can be used for later lookup. If the same list was added previously,
// this method is a no-op and returns the ID of the previous value.
func (f *Factory) InternList(items []memo.GroupID) memo.ListID {
	return f.mem.InternList(items)
}

// onConstruct is called as a final step by each factory construction method,
// so that any custom manual pattern matching/replacement code can be run.
func (f *Factory) onConstruct(e memo.Expr) memo.GroupID {
	group := f.mem.MemoizeNormExpr(f.evalCtx, e)
	ev := memo.MakeNormExprView(f.mem, group)
	f.props.buildProps(ev)

	// RaceEnabled ensures that checks are run on every change (as part of make
	// testrace) while keeping the check code out of non-test builds.
	// TODO(radu): replace this with a flag that is true for all tests.
	if util.RaceEnabled {
		f.checkExpr(ev)
	}
	return group
}

// ----------------------------------------------------------------------
//
// Private extraction functions
//   Helper functions that make extracting common private types easier.
//
// ----------------------------------------------------------------------

func (f *Factory) extractColID(private memo.PrivateID) opt.ColumnID {
	return f.mem.LookupPrivate(private).(opt.ColumnID)
}

func (f *Factory) extractColList(private memo.PrivateID) opt.ColList {
	return f.mem.LookupPrivate(private).(opt.ColList)
}

func (f *Factory) extractOrdering(private memo.PrivateID) props.Ordering {
	return f.mem.LookupPrivate(private).(props.Ordering)
}

func (f *Factory) extractProjectionsOpDef(private memo.PrivateID) *memo.ProjectionsOpDef {
	return f.mem.LookupPrivate(private).(*memo.ProjectionsOpDef)
}

// ----------------------------------------------------------------------
//
// List functions
//   Helper functions for manipulating lists.
//
// ----------------------------------------------------------------------

// internSingletonList interns a list containing the single given item and
// returns its id.
func (f *Factory) internSingletonList(item memo.GroupID) memo.ListID {
	b := xfunc.MakeListBuilder(&f.funcs.CustomFuncs)
	b.AddItem(item)
	return b.BuildList()
}

// ----------------------------------------------------------------------
//
// Property functions
//   Helper functions used to test expression logical properties.
//
// ----------------------------------------------------------------------

// operator returns the type of the given group's normalized expression.
func (f *Factory) operator(group memo.GroupID) opt.Operator {
	return f.mem.NormExpr(group).Operator()
}

// lookupLogical returns the given group's logical properties.
func (f *Factory) lookupLogical(group memo.GroupID) *props.Logical {
	return f.mem.GroupProperties(group)
}

// lookupRelational returns the given group's logical relational properties.
func (f *Factory) lookupRelational(group memo.GroupID) *props.Relational {
	return f.lookupLogical(group).Relational
}

// lookupScalar returns the given group's logical scalar properties.
func (f *Factory) lookupScalar(group memo.GroupID) *props.Scalar {
	return f.lookupLogical(group).Scalar
}

// outputCols is a helper function that extracts the set of columns projected
// by the given operator. In addition to extracting columns from any relational
// operator, outputCols can also extract columns from the Projections and
// Aggregations scalar operators, which are used with Project and GroupBy.
func (f *Factory) outputCols(group memo.GroupID) opt.ColSet {
	// Handle columns projected by relational operators.
	logical := f.lookupLogical(group)
	if logical.Relational != nil {
		return f.lookupRelational(group).OutputCols
	}

	expr := f.mem.NormExpr(group)
	switch expr.Operator() {
	case opt.AggregationsOp:
		return opt.ColListToSet(f.extractColList(expr.AsAggregations().Cols()))

	case opt.ProjectionsOp:
		return f.extractProjectionsOpDef(expr.AsProjections().Def()).AllCols()

	default:
		panic(fmt.Sprintf("outputCols doesn't support op %s", expr.Operator()))
	}
}

// outerCols returns the set of outer columns associated with the given group,
// whether it be a relational or scalar operator.
func (f *Factory) outerCols(group memo.GroupID) opt.ColSet {
	return f.lookupLogical(group).OuterCols()
}

// shortestKey returns the strong key in the given memo group that is composed
// of the fewest columns. If there are multiple keys with the same number of
// columns, any one of them may be returned. If there are no strong keys in the
// group, then shortestKey returns ok=false.
func (f *Factory) shortestKey(group memo.GroupID) (key opt.ColSet, ok bool) {
	var shortest opt.ColSet
	var shortestLen int
	props := f.lookupLogical(group).Relational
	for _, wk := range props.WeakKeys {
		// A strong key requires all columns to be non-nullable.
		if wk.SubsetOf(props.NotNullCols) {
			l := wk.Len()
			if !ok || l < shortestLen {
				shortestLen = l
				shortest = wk
				ok = true
			}
		}
	}
	return shortest, ok
}

// ensureKey finds the shortest strong key for the input memo group. If no
// strong key exists, then ensureKey wraps the input in a RowNumber operator,
// which provides a key column by uniquely numbering the rows. ensureKey returns
// the input group (perhaps wrapped by RowNumber) and the set of columns that
// form the shortest available key.
func (f *Factory) ensureKey(in memo.GroupID) (out memo.GroupID, key opt.ColSet) {
	key, ok := f.shortestKey(in)
	if ok {
		return in, key
	}

	colID := f.Metadata().AddColumn("rownum", types.Int)
	def := &memo.RowNumberDef{ColID: colID}
	out = f.ConstructRowNumber(in, f.InternRowNumberDef(def))
	key.Add(int(colID))
	return out, key
}

// ----------------------------------------------------------------------
//
// Projection construction functions
//   General helper functions to construct Projections.
//
// ----------------------------------------------------------------------

// projectExtraCol constructs a new Project operator that passes through all
// columns in the given "in" expression, and then adds the given "extra"
// expression as an additional column.
func (f *Factory) projectExtraCol(in, extra memo.GroupID, extraID opt.ColumnID) memo.GroupID {
	pb := projectionsBuilder{f: f}
	pb.addPassthroughCols(f.outputCols(in))
	pb.addSynthesized(extra, extraID)
	return f.ConstructProject(in, pb.buildProjections())
}
