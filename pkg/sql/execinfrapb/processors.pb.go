// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors.proto

package execinfrapb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Each processor has the following components:
//  - one or more input synchronizers; each one merges rows between one or more
//    input streams;
//
//  - a processor "core" which encapsulates the inner logic of each processor;
//
//  - a post-processing stage which allows "inline" post-processing on results
//    (like projection or filtering);
//
//  - one or more output synchronizers; each one directs rows to one or more
//  output streams.
//
//
// == Internal columns ==
//
// The core outputs rows of a certain schema to the post-processing stage. We
// call this the "internal schema" (or "internal columns") and it differs for
// each type of core. Column indices in a PostProcessSpec refers to these
// internal columns. Some columns may be unused by the post-processing stage;
// processor implementations are internally optimized to not produce values for
// such unneeded columns.
type ProcessorSpec struct {
	// In most cases, there is one input.
	Input []InputSyncSpec    `protobuf:"bytes,1,rep,name=input" json:"input"`
	Core  ProcessorCoreUnion `protobuf:"bytes,2,opt,name=core" json:"core"`
	Post  PostProcessSpec    `protobuf:"bytes,4,opt,name=post" json:"post"`
	// In most cases, there is one output.
	Output []OutputRouterSpec `protobuf:"bytes,3,rep,name=output" json:"output"`
	// An optional identifier that can be used to correlate processors that are
	// part of the same stage (e.g. multiple joiners that are part of a
	// distributed join). This has no consequence on the running of flows, but is
	// useful for plan diagrams.
	StageID int32 `protobuf:"varint,5,opt,name=stage_id,json=stageId" json:"stage_id"`
	// processor_id uniquely identifies a processor within a physical plan. This
	// has no consequence on the running of flows, but is useful for plan
	// diagrams and linking information like tracing spans and log messages to
	// processors.
	ProcessorID int32 `protobuf:"varint,6,opt,name=processor_id,json=processorId" json:"processor_id"`
}

func (m *ProcessorSpec) Reset()         { *m = ProcessorSpec{} }
func (m *ProcessorSpec) String() string { return proto.CompactTextString(m) }
func (*ProcessorSpec) ProtoMessage()    {}
func (*ProcessorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{0}
}
func (m *ProcessorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProcessorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorSpec.Merge(dst, src)
}
func (m *ProcessorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorSpec proto.InternalMessageInfo

type ProcessorCoreUnion struct {
	Noop                    *NoopCoreSpec                `protobuf:"bytes,1,opt,name=noop" json:"noop,omitempty"`
	TableReader             *TableReaderSpec             `protobuf:"bytes,2,opt,name=tableReader" json:"tableReader,omitempty"`
	JoinReader              *JoinReaderSpec              `protobuf:"bytes,3,opt,name=joinReader" json:"joinReader,omitempty"`
	Sorter                  *SorterSpec                  `protobuf:"bytes,4,opt,name=sorter" json:"sorter,omitempty"`
	Aggregator              *AggregatorSpec              `protobuf:"bytes,5,opt,name=aggregator" json:"aggregator,omitempty"`
	Distinct                *DistinctSpec                `protobuf:"bytes,7,opt,name=distinct" json:"distinct,omitempty"`
	MergeJoiner             *MergeJoinerSpec             `protobuf:"bytes,8,opt,name=mergeJoiner" json:"mergeJoiner,omitempty"`
	HashJoiner              *HashJoinerSpec              `protobuf:"bytes,9,opt,name=hashJoiner" json:"hashJoiner,omitempty"`
	Values                  *ValuesCoreSpec              `protobuf:"bytes,10,opt,name=values" json:"values,omitempty"`
	Backfiller              *BackfillerSpec              `protobuf:"bytes,11,opt,name=backfiller" json:"backfiller,omitempty"`
	ReadImport              *ReadImportDataSpec          `protobuf:"bytes,13,opt,name=readImport" json:"readImport,omitempty"`
	CSVWriter               *CSVWriterSpec               `protobuf:"bytes,20,opt,name=CSVWriter" json:"CSVWriter,omitempty"`
	Sampler                 *SamplerSpec                 `protobuf:"bytes,15,opt,name=Sampler" json:"Sampler,omitempty"`
	SampleAggregator        *SampleAggregatorSpec        `protobuf:"bytes,16,opt,name=SampleAggregator" json:"SampleAggregator,omitempty"`
	InterleavedReaderJoiner *InterleavedReaderJoinerSpec `protobuf:"bytes,17,opt,name=interleavedReaderJoiner" json:"interleavedReaderJoiner,omitempty"`
	MetadataTestSender      *MetadataTestSenderSpec      `protobuf:"bytes,18,opt,name=metadataTestSender" json:"metadataTestSender,omitempty"`
	MetadataTestReceiver    *MetadataTestReceiverSpec    `protobuf:"bytes,19,opt,name=metadataTestReceiver" json:"metadataTestReceiver,omitempty"`
	ZigzagJoiner            *ZigzagJoinerSpec            `protobuf:"bytes,21,opt,name=zigzagJoiner" json:"zigzagJoiner,omitempty"`
	ProjectSet              *ProjectSetSpec              `protobuf:"bytes,22,opt,name=projectSet" json:"projectSet,omitempty"`
	Windower                *WindowerSpec                `protobuf:"bytes,23,opt,name=windower" json:"windower,omitempty"`
	LocalPlanNode           *LocalPlanNodeSpec           `protobuf:"bytes,24,opt,name=localPlanNode" json:"localPlanNode,omitempty"`
	ChangeAggregator        *ChangeAggregatorSpec        `protobuf:"bytes,25,opt,name=changeAggregator" json:"changeAggregator,omitempty"`
	ChangeFrontier          *ChangeFrontierSpec          `protobuf:"bytes,26,opt,name=changeFrontier" json:"changeFrontier,omitempty"`
	Ordinality              *OrdinalitySpec              `protobuf:"bytes,27,opt,name=ordinality" json:"ordinality,omitempty"`
	BulkRowWriter           *BulkRowWriterSpec           `protobuf:"bytes,28,opt,name=bulkRowWriter" json:"bulkRowWriter,omitempty"`
}

func (m *ProcessorCoreUnion) Reset()         { *m = ProcessorCoreUnion{} }
func (m *ProcessorCoreUnion) String() string { return proto.CompactTextString(m) }
func (*ProcessorCoreUnion) ProtoMessage()    {}
func (*ProcessorCoreUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{1}
}
func (m *ProcessorCoreUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorCoreUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProcessorCoreUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorCoreUnion.Merge(dst, src)
}
func (m *ProcessorCoreUnion) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorCoreUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorCoreUnion.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorCoreUnion proto.InternalMessageInfo

// NoopCoreSpec indicates a "no-op" processor core. This is used when we just
// need post-processing or when only a synchronizer is required (e.g. at the
// final endpoint).
type NoopCoreSpec struct {
}

func (m *NoopCoreSpec) Reset()         { *m = NoopCoreSpec{} }
func (m *NoopCoreSpec) String() string { return proto.CompactTextString(m) }
func (*NoopCoreSpec) ProtoMessage()    {}
func (*NoopCoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{2}
}
func (m *NoopCoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoopCoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NoopCoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoopCoreSpec.Merge(dst, src)
}
func (m *NoopCoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *NoopCoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NoopCoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NoopCoreSpec proto.InternalMessageInfo

// LocalPlanNodeSpec is the specification for a local planNode wrapping
// processor. It's created for situations where a planNode has no DistSQL
// processor equivalent, and constrains the plan to live on the gateway node.
// This spec contains just an index, which is used by the execution engine to
// find the planNode instance this processor is executing in an array of local
// planNodes. See LocalProcessors and LocalProcessorIndexes on
// distsqlplan.PhysicalPlan.
type LocalPlanNodeSpec struct {
	RowSourceIdx *uint32 `protobuf:"varint,1,opt,name=RowSourceIdx" json:"RowSourceIdx,omitempty"`
	NumInputs    *uint32 `protobuf:"varint,2,opt,name=NumInputs" json:"NumInputs,omitempty"`
	Name         *string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
}

func (m *LocalPlanNodeSpec) Reset()         { *m = LocalPlanNodeSpec{} }
func (m *LocalPlanNodeSpec) String() string { return proto.CompactTextString(m) }
func (*LocalPlanNodeSpec) ProtoMessage()    {}
func (*LocalPlanNodeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{3}
}
func (m *LocalPlanNodeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalPlanNodeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LocalPlanNodeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalPlanNodeSpec.Merge(dst, src)
}
func (m *LocalPlanNodeSpec) XXX_Size() int {
	return m.Size()
}
func (m *LocalPlanNodeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalPlanNodeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LocalPlanNodeSpec proto.InternalMessageInfo

type MetadataTestSenderSpec struct {
	ID string `protobuf:"bytes,1,opt,name=id" json:"id"`
}

func (m *MetadataTestSenderSpec) Reset()         { *m = MetadataTestSenderSpec{} }
func (m *MetadataTestSenderSpec) String() string { return proto.CompactTextString(m) }
func (*MetadataTestSenderSpec) ProtoMessage()    {}
func (*MetadataTestSenderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{4}
}
func (m *MetadataTestSenderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataTestSenderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MetadataTestSenderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataTestSenderSpec.Merge(dst, src)
}
func (m *MetadataTestSenderSpec) XXX_Size() int {
	return m.Size()
}
func (m *MetadataTestSenderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataTestSenderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataTestSenderSpec proto.InternalMessageInfo

type MetadataTestReceiverSpec struct {
	SenderIDs []string `protobuf:"bytes,1,rep,name=sender_ids,json=senderIds" json:"sender_ids,omitempty"`
}

func (m *MetadataTestReceiverSpec) Reset()         { *m = MetadataTestReceiverSpec{} }
func (m *MetadataTestReceiverSpec) String() string { return proto.CompactTextString(m) }
func (*MetadataTestReceiverSpec) ProtoMessage()    {}
func (*MetadataTestReceiverSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_266dc90c4e5a635b, []int{5}
}
func (m *MetadataTestReceiverSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataTestReceiverSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MetadataTestReceiverSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataTestReceiverSpec.Merge(dst, src)
}
func (m *MetadataTestReceiverSpec) XXX_Size() int {
	return m.Size()
}
func (m *MetadataTestReceiverSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataTestReceiverSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataTestReceiverSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ProcessorSpec)(nil), "cockroach.sql.distsqlrun.ProcessorSpec")
	proto.RegisterType((*ProcessorCoreUnion)(nil), "cockroach.sql.distsqlrun.ProcessorCoreUnion")
	proto.RegisterType((*NoopCoreSpec)(nil), "cockroach.sql.distsqlrun.NoopCoreSpec")
	proto.RegisterType((*LocalPlanNodeSpec)(nil), "cockroach.sql.distsqlrun.LocalPlanNodeSpec")
	proto.RegisterType((*MetadataTestSenderSpec)(nil), "cockroach.sql.distsqlrun.MetadataTestSenderSpec")
	proto.RegisterType((*MetadataTestReceiverSpec)(nil), "cockroach.sql.distsqlrun.MetadataTestReceiverSpec")
}
func (m *ProcessorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, msg := range m.Input {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessors(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessors(dAtA, i, uint64(m.Core.Size()))
	n1, err := m.Core.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Output) > 0 {
		for _, msg := range m.Output {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessors(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessors(dAtA, i, uint64(m.Post.Size()))
	n2, err := m.Post.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessors(dAtA, i, uint64(m.StageID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessors(dAtA, i, uint64(m.ProcessorID))
	return i, nil
}

func (m *ProcessorCoreUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorCoreUnion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Noop != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Noop.Size()))
		n3, err := m.Noop.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TableReader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.TableReader.Size()))
		n4, err := m.TableReader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.JoinReader != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.JoinReader.Size()))
		n5, err := m.JoinReader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Sorter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Sorter.Size()))
		n6, err := m.Sorter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Aggregator != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Aggregator.Size()))
		n7, err := m.Aggregator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Distinct != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Distinct.Size()))
		n8, err := m.Distinct.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MergeJoiner != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.MergeJoiner.Size()))
		n9, err := m.MergeJoiner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HashJoiner != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.HashJoiner.Size()))
		n10, err := m.HashJoiner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Values != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Values.Size()))
		n11, err := m.Values.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Backfiller != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Backfiller.Size()))
		n12, err := m.Backfiller.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ReadImport != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.ReadImport.Size()))
		n13, err := m.ReadImport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Sampler != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Sampler.Size()))
		n14, err := m.Sampler.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.SampleAggregator != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.SampleAggregator.Size()))
		n15, err := m.SampleAggregator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.InterleavedReaderJoiner != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.InterleavedReaderJoiner.Size()))
		n16, err := m.InterleavedReaderJoiner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MetadataTestSender != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.MetadataTestSender.Size()))
		n17, err := m.MetadataTestSender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.MetadataTestReceiver != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.MetadataTestReceiver.Size()))
		n18, err := m.MetadataTestReceiver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.CSVWriter != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.CSVWriter.Size()))
		n19, err := m.CSVWriter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ZigzagJoiner != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.ZigzagJoiner.Size()))
		n20, err := m.ZigzagJoiner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.ProjectSet != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.ProjectSet.Size()))
		n21, err := m.ProjectSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Windower != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Windower.Size()))
		n22, err := m.Windower.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.LocalPlanNode != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.LocalPlanNode.Size()))
		n23, err := m.LocalPlanNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ChangeAggregator != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.ChangeAggregator.Size()))
		n24, err := m.ChangeAggregator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ChangeFrontier != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.ChangeFrontier.Size()))
		n25, err := m.ChangeFrontier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Ordinality != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.Ordinality.Size()))
		n26, err := m.Ordinality.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.BulkRowWriter != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(m.BulkRowWriter.Size()))
		n27, err := m.BulkRowWriter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *NoopCoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoopCoreSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *LocalPlanNodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalPlanNodeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RowSourceIdx != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(*m.RowSourceIdx))
	}
	if m.NumInputs != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(*m.NumInputs))
	}
	if m.Name != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessors(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	return i, nil
}

func (m *MetadataTestSenderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataTestSenderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessors(dAtA, i, uint64(len(m.ID)))
	i += copy(dAtA[i:], m.ID)
	return i, nil
}

func (m *MetadataTestReceiverSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataTestReceiverSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SenderIDs) > 0 {
		for _, s := range m.SenderIDs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintProcessors(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ProcessorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, e := range m.Input {
			l = e.Size()
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	l = m.Core.Size()
	n += 1 + l + sovProcessors(uint64(l))
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	l = m.Post.Size()
	n += 1 + l + sovProcessors(uint64(l))
	n += 1 + sovProcessors(uint64(m.StageID))
	n += 1 + sovProcessors(uint64(m.ProcessorID))
	return n
}

func (m *ProcessorCoreUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Noop != nil {
		l = m.Noop.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.TableReader != nil {
		l = m.TableReader.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.JoinReader != nil {
		l = m.JoinReader.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Sorter != nil {
		l = m.Sorter.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Aggregator != nil {
		l = m.Aggregator.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Distinct != nil {
		l = m.Distinct.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.MergeJoiner != nil {
		l = m.MergeJoiner.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.HashJoiner != nil {
		l = m.HashJoiner.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Backfiller != nil {
		l = m.Backfiller.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.ReadImport != nil {
		l = m.ReadImport.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Sampler != nil {
		l = m.Sampler.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.SampleAggregator != nil {
		l = m.SampleAggregator.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.InterleavedReaderJoiner != nil {
		l = m.InterleavedReaderJoiner.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.MetadataTestSender != nil {
		l = m.MetadataTestSender.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.MetadataTestReceiver != nil {
		l = m.MetadataTestReceiver.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.CSVWriter != nil {
		l = m.CSVWriter.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ZigzagJoiner != nil {
		l = m.ZigzagJoiner.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ProjectSet != nil {
		l = m.ProjectSet.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Windower != nil {
		l = m.Windower.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.LocalPlanNode != nil {
		l = m.LocalPlanNode.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ChangeAggregator != nil {
		l = m.ChangeAggregator.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ChangeFrontier != nil {
		l = m.ChangeFrontier.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Ordinality != nil {
		l = m.Ordinality.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.BulkRowWriter != nil {
		l = m.BulkRowWriter.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	return n
}

func (m *NoopCoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LocalPlanNodeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowSourceIdx != nil {
		n += 1 + sovProcessors(uint64(*m.RowSourceIdx))
	}
	if m.NumInputs != nil {
		n += 1 + sovProcessors(uint64(*m.NumInputs))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovProcessors(uint64(l))
	}
	return n
}

func (m *MetadataTestSenderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovProcessors(uint64(l))
	return n
}

func (m *MetadataTestReceiverSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SenderIDs) > 0 {
		for _, s := range m.SenderIDs {
			l = len(s)
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	return n
}

func sovProcessors(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessors(x uint64) (n int) {
	return sovProcessors(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProcessorCoreUnion) GetValue() interface{} {
	if this.Noop != nil {
		return this.Noop
	}
	if this.TableReader != nil {
		return this.TableReader
	}
	if this.JoinReader != nil {
		return this.JoinReader
	}
	if this.Sorter != nil {
		return this.Sorter
	}
	if this.Aggregator != nil {
		return this.Aggregator
	}
	if this.Distinct != nil {
		return this.Distinct
	}
	if this.MergeJoiner != nil {
		return this.MergeJoiner
	}
	if this.HashJoiner != nil {
		return this.HashJoiner
	}
	if this.Values != nil {
		return this.Values
	}
	if this.Backfiller != nil {
		return this.Backfiller
	}
	if this.ReadImport != nil {
		return this.ReadImport
	}
	if this.Sampler != nil {
		return this.Sampler
	}
	if this.SampleAggregator != nil {
		return this.SampleAggregator
	}
	if this.InterleavedReaderJoiner != nil {
		return this.InterleavedReaderJoiner
	}
	if this.MetadataTestSender != nil {
		return this.MetadataTestSender
	}
	if this.MetadataTestReceiver != nil {
		return this.MetadataTestReceiver
	}
	if this.CSVWriter != nil {
		return this.CSVWriter
	}
	if this.ZigzagJoiner != nil {
		return this.ZigzagJoiner
	}
	if this.ProjectSet != nil {
		return this.ProjectSet
	}
	if this.Windower != nil {
		return this.Windower
	}
	if this.LocalPlanNode != nil {
		return this.LocalPlanNode
	}
	if this.ChangeAggregator != nil {
		return this.ChangeAggregator
	}
	if this.ChangeFrontier != nil {
		return this.ChangeFrontier
	}
	if this.Ordinality != nil {
		return this.Ordinality
	}
	if this.BulkRowWriter != nil {
		return this.BulkRowWriter
	}
	return nil
}

func (this *ProcessorCoreUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *NoopCoreSpec:
		this.Noop = vt
	case *TableReaderSpec:
		this.TableReader = vt
	case *JoinReaderSpec:
		this.JoinReader = vt
	case *SorterSpec:
		this.Sorter = vt
	case *AggregatorSpec:
		this.Aggregator = vt
	case *DistinctSpec:
		this.Distinct = vt
	case *MergeJoinerSpec:
		this.MergeJoiner = vt
	case *HashJoinerSpec:
		this.HashJoiner = vt
	case *ValuesCoreSpec:
		this.Values = vt
	case *BackfillerSpec:
		this.Backfiller = vt
	case *ReadImportDataSpec:
		this.ReadImport = vt
	case *SamplerSpec:
		this.Sampler = vt
	case *SampleAggregatorSpec:
		this.SampleAggregator = vt
	case *InterleavedReaderJoinerSpec:
		this.InterleavedReaderJoiner = vt
	case *MetadataTestSenderSpec:
		this.MetadataTestSender = vt
	case *MetadataTestReceiverSpec:
		this.MetadataTestReceiver = vt
	case *CSVWriterSpec:
		this.CSVWriter = vt
	case *ZigzagJoinerSpec:
		this.ZigzagJoiner = vt
	case *ProjectSetSpec:
		this.ProjectSet = vt
	case *WindowerSpec:
		this.Windower = vt
	case *LocalPlanNodeSpec:
		this.LocalPlanNode = vt
	case *ChangeAggregatorSpec:
		this.ChangeAggregator = vt
	case *ChangeFrontierSpec:
		this.ChangeFrontier = vt
	case *OrdinalitySpec:
		this.Ordinality = vt
	case *BulkRowWriterSpec:
		this.BulkRowWriter = vt
	default:
		return false
	}
	return true
}
func (m *ProcessorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, InputSyncSpec{})
			if err := m.Input[len(m.Input)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Core.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, OutputRouterSpec{})
			if err := m.Output[len(m.Output)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Post.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageID", wireType)
			}
			m.StageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorID", wireType)
			}
			m.ProcessorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessorID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorCoreUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorCoreUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorCoreUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Noop == nil {
				m.Noop = &NoopCoreSpec{}
			}
			if err := m.Noop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableReader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableReader == nil {
				m.TableReader = &TableReaderSpec{}
			}
			if err := m.TableReader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinReader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinReader == nil {
				m.JoinReader = &JoinReaderSpec{}
			}
			if err := m.JoinReader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sorter == nil {
				m.Sorter = &SorterSpec{}
			}
			if err := m.Sorter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregator == nil {
				m.Aggregator = &AggregatorSpec{}
			}
			if err := m.Aggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Distinct == nil {
				m.Distinct = &DistinctSpec{}
			}
			if err := m.Distinct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeJoiner == nil {
				m.MergeJoiner = &MergeJoinerSpec{}
			}
			if err := m.MergeJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashJoiner == nil {
				m.HashJoiner = &HashJoinerSpec{}
			}
			if err := m.HashJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &ValuesCoreSpec{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backfiller == nil {
				m.Backfiller = &BackfillerSpec{}
			}
			if err := m.Backfiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadImport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadImport == nil {
				m.ReadImport = &ReadImportDataSpec{}
			}
			if err := m.ReadImport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sampler == nil {
				m.Sampler = &SamplerSpec{}
			}
			if err := m.Sampler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleAggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampleAggregator == nil {
				m.SampleAggregator = &SampleAggregatorSpec{}
			}
			if err := m.SampleAggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterleavedReaderJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterleavedReaderJoiner == nil {
				m.InterleavedReaderJoiner = &InterleavedReaderJoinerSpec{}
			}
			if err := m.InterleavedReaderJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataTestSender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataTestSender == nil {
				m.MetadataTestSender = &MetadataTestSenderSpec{}
			}
			if err := m.MetadataTestSender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataTestReceiver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataTestReceiver == nil {
				m.MetadataTestReceiver = &MetadataTestReceiverSpec{}
			}
			if err := m.MetadataTestReceiver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSVWriter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CSVWriter == nil {
				m.CSVWriter = &CSVWriterSpec{}
			}
			if err := m.CSVWriter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZigzagJoiner == nil {
				m.ZigzagJoiner = &ZigzagJoinerSpec{}
			}
			if err := m.ZigzagJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProjectSet == nil {
				m.ProjectSet = &ProjectSetSpec{}
			}
			if err := m.ProjectSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windower == nil {
				m.Windower = &WindowerSpec{}
			}
			if err := m.Windower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPlanNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalPlanNode == nil {
				m.LocalPlanNode = &LocalPlanNodeSpec{}
			}
			if err := m.LocalPlanNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeAggregator == nil {
				m.ChangeAggregator = &ChangeAggregatorSpec{}
			}
			if err := m.ChangeAggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeFrontier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeFrontier == nil {
				m.ChangeFrontier = &ChangeFrontierSpec{}
			}
			if err := m.ChangeFrontier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordinality == nil {
				m.Ordinality = &OrdinalitySpec{}
			}
			if err := m.Ordinality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulkRowWriter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BulkRowWriter == nil {
				m.BulkRowWriter = &BulkRowWriterSpec{}
			}
			if err := m.BulkRowWriter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoopCoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoopCoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoopCoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalPlanNodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalPlanNodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalPlanNodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSourceIdx", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RowSourceIdx = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInputs", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumInputs = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataTestSenderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataTestSenderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataTestSenderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataTestReceiverSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataTestReceiverSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataTestReceiverSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderIDs = append(m.SenderIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessors(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessors
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessors
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessors(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessors = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessors   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/execinfrapb/processors.proto", fileDescriptor_processors_266dc90c4e5a635b)
}

var fileDescriptor_processors_266dc90c4e5a635b = []byte{
	// 1076 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0x61, 0x4f, 0x1b, 0x37,
	0x18, 0xc7, 0x09, 0x04, 0x48, 0x1c, 0x02, 0xd4, 0x65, 0xed, 0x8d, 0x55, 0x01, 0x45, 0xed, 0xc6,
	0x3a, 0x16, 0x26, 0xb4, 0xed, 0x45, 0x35, 0x69, 0x5b, 0x92, 0x55, 0x84, 0x75, 0x94, 0x5d, 0x58,
	0x2b, 0xf1, 0x86, 0x99, 0x3b, 0x13, 0x5c, 0x2e, 0xe7, 0xc3, 0x76, 0xa0, 0xed, 0x97, 0xd8, 0x3e,
	0xc2, 0x3e, 0x0e, 0x2f, 0xfb, 0xb2, 0xd2, 0x24, 0xb4, 0x85, 0x2f, 0x52, 0xf9, 0xf1, 0x71, 0x77,
	0x09, 0xdc, 0x5d, 0xdf, 0x9d, 0x7c, 0xff, 0xff, 0xef, 0x79, 0xfc, 0xd8, 0x8f, 0x6d, 0xb4, 0x2a,
	0x4f, 0xbd, 0x0d, 0xfa, 0x9a, 0x3a, 0xcc, 0x3f, 0x12, 0x24, 0x38, 0xdc, 0x08, 0x04, 0x77, 0xa8,
	0x94, 0x5c, 0xc8, 0x46, 0x20, 0xb8, 0xe2, 0xd8, 0x72, 0xb8, 0x73, 0x22, 0x38, 0x71, 0x8e, 0x1b,
	0xf2, 0xd4, 0x6b, 0xb8, 0x4c, 0x2a, 0x79, 0xea, 0x89, 0x81, 0xbf, 0xbc, 0x3c, 0xee, 0x75, 0x89,
	0x22, 0xc6, 0xb5, 0xfc, 0x28, 0x9d, 0x7b, 0x70, 0x48, 0x24, 0x0d, 0x65, 0x0f, 0x33, 0x64, 0x3a,
	0x9a, 0x51, 0xad, 0x65, 0xc1, 0x06, 0xde, 0xc9, 0x01, 0xe3, 0xa1, 0x72, 0x3d, 0x43, 0xe9, 0x1c,
	0x13, 0xbf, 0x47, 0x8f, 0x28, 0x75, 0xe5, 0x47, 0xa8, 0x15, 0x39, 0xf4, 0xe8, 0x81, 0x54, 0x44,
	0x5d, 0xab, 0x97, 0x7a, 0xbc, 0xc7, 0xe1, 0x73, 0x43, 0x7f, 0x99, 0xd1, 0xfa, 0x5f, 0x53, 0xa8,
	0xba, 0x7b, 0x6d, 0xeb, 0x06, 0xd4, 0xc1, 0x2d, 0x34, 0xcd, 0xfc, 0x60, 0xa0, 0xac, 0xc2, 0xea,
	0xd4, 0x5a, 0x65, 0xf3, 0x8b, 0x46, 0x5a, 0x01, 0x1b, 0x1d, 0x2d, 0xeb, 0xbe, 0xf1, 0x1d, 0xed,
	0x6b, 0x16, 0x2f, 0x2e, 0x57, 0x26, 0x6c, 0xe3, 0xc5, 0x4f, 0x51, 0xd1, 0xe1, 0x82, 0x5a, 0x93,
	0xab, 0x85, 0xb5, 0xca, 0xe6, 0x7a, 0x3a, 0x23, 0x8a, 0xdd, 0xe2, 0x82, 0xfe, 0xe1, 0x33, 0xee,
	0x87, 0x20, 0xf0, 0xe3, 0x2d, 0x34, 0xc3, 0x07, 0x4a, 0x67, 0x33, 0x05, 0xd9, 0x3c, 0x4e, 0x27,
	0x3d, 0x07, 0x9d, 0xcd, 0x07, 0x8a, 0x8a, 0x44, 0x42, 0xa1, 0x1f, 0xb7, 0x50, 0x31, 0xe0, 0x52,
	0x59, 0x45, 0xc8, 0xe8, 0xcb, 0x8c, 0x8c, 0xb8, 0x54, 0x61, 0x56, 0x09, 0x0c, 0x98, 0xf1, 0x63,
	0x54, 0x92, 0x8a, 0xf4, 0xe8, 0x01, 0x73, 0xad, 0xe9, 0xd5, 0xc2, 0xda, 0x74, 0x73, 0x41, 0xff,
	0x1d, 0x5e, 0xae, 0xcc, 0x76, 0xf5, 0x78, 0xa7, 0x6d, 0xcf, 0x82, 0xa0, 0xe3, 0xe2, 0xef, 0xd1,
	0x5c, 0xb4, 0x1e, 0x5a, 0x3f, 0x03, 0xfa, 0xbb, 0xa1, 0xbe, 0x12, 0x4d, 0xbc, 0xd3, 0xb6, 0x2b,
	0x91, 0xb0, 0xe3, 0xd6, 0xff, 0x5d, 0x40, 0xf8, 0x66, 0x55, 0xf0, 0x13, 0x54, 0xf4, 0x39, 0x0f,
	0xac, 0x02, 0xe4, 0xff, 0x79, 0x7a, 0xfe, 0x3b, 0x9c, 0x07, 0xda, 0xa6, 0x93, 0xb7, 0xc1, 0x83,
	0x7f, 0x45, 0x15, 0xd8, 0x0f, 0x36, 0x25, 0x2e, 0x15, 0xe1, 0xa2, 0x64, 0x94, 0x60, 0x2f, 0x16,
	0x03, 0x25, 0xe9, 0xc6, 0x5b, 0x08, 0xbd, 0xe2, 0xcc, 0x0f, 0x59, 0x53, 0xc0, 0x5a, 0x4b, 0x67,
	0x6d, 0x47, 0x5a, 0x40, 0x25, 0xbc, 0xf8, 0x07, 0x34, 0x23, 0xb9, 0x50, 0x54, 0x84, 0x8b, 0xf2,
	0x30, 0x9d, 0xd2, 0x05, 0x1d, 0x10, 0x42, 0x8f, 0xce, 0x83, 0xf4, 0x7a, 0x82, 0xf6, 0x88, 0xe2,
	0x02, 0x56, 0x23, 0x33, 0x8f, 0x9f, 0x23, 0xad, 0xc9, 0x23, 0xf6, 0xe2, 0x26, 0x2a, 0x69, 0x21,
	0xf3, 0x1d, 0x65, 0xcd, 0xe6, 0x95, 0xb7, 0x1d, 0x2a, 0x81, 0x12, 0xf9, 0x74, 0x89, 0xfb, 0x54,
	0xf4, 0xa8, 0x9e, 0x2e, 0x15, 0x56, 0x29, 0xaf, 0xc4, 0xbf, 0xc5, 0x62, 0x53, 0xe2, 0x84, 0x5b,
	0x4f, 0xed, 0x98, 0xc8, 0xe3, 0x90, 0x55, 0xce, 0x9b, 0xda, 0x56, 0xa4, 0x35, 0x53, 0x8b, 0xbd,
	0xf8, 0x27, 0x34, 0x73, 0x46, 0xbc, 0x01, 0x95, 0x16, 0xca, 0xa3, 0xbc, 0x00, 0x5d, 0xb4, 0x73,
	0x42, 0x9f, 0xce, 0xe5, 0x90, 0x38, 0x27, 0x47, 0xcc, 0xf3, 0xa8, 0xb0, 0x2a, 0x79, 0x94, 0x66,
	0xa4, 0x35, 0xb9, 0xc4, 0x5e, 0xfc, 0x0c, 0x21, 0x41, 0x89, 0xdb, 0xe9, 0x07, 0x5c, 0x28, 0xab,
	0x9a, 0x77, 0x32, 0xd8, 0x91, 0xb6, 0x4d, 0x14, 0x31, 0xb4, 0xd8, 0x8f, 0x7f, 0x44, 0xb3, 0x5d,
	0xd2, 0x0f, 0x74, 0x52, 0x0b, 0x80, 0x7a, 0x94, 0xb1, 0x7b, 0x8c, 0x10, 0x18, 0xd7, 0x2e, 0xbc,
	0x8f, 0x16, 0xcd, 0x67, 0xbc, 0x33, 0xac, 0x45, 0x20, 0x35, 0xf2, 0x48, 0x63, 0x7b, 0xe9, 0x06,
	0x07, 0x73, 0x74, 0x9f, 0xf9, 0x8a, 0x0a, 0x8f, 0x92, 0x33, 0xea, 0x9a, 0xed, 0x1e, 0xae, 0xe6,
	0x1d, 0x08, 0xf1, 0x5d, 0xd6, 0xa9, 0x7a, 0xab, 0x11, 0x22, 0xa5, 0x51, 0xf1, 0x9f, 0x08, 0xf7,
	0xa9, 0x22, 0xfa, 0x06, 0xdb, 0xa3, 0x52, 0x75, 0xa9, 0xaf, 0x9b, 0x13, 0x43, 0xac, 0x6f, 0xb2,
	0x76, 0xe1, 0xb8, 0x07, 0xc2, 0xdc, 0xc2, 0xc2, 0x47, 0x68, 0x29, 0x39, 0x6a, 0x53, 0x87, 0xb2,
	0x33, 0x2a, 0xac, 0xbb, 0x10, 0x63, 0xf3, 0xe3, 0x62, 0x5c, 0xbb, 0x20, 0xca, 0xad, 0x3c, 0xfc,
	0x0b, 0x2a, 0xb7, 0xba, 0x2f, 0x5e, 0x0a, 0xa6, 0xcf, 0x85, 0x25, 0x80, 0x67, 0x5c, 0x41, 0x91,
	0x14, 0x88, 0xb1, 0x13, 0xef, 0xa0, 0xb9, 0xb7, 0xac, 0xf7, 0x96, 0xf4, 0xc2, 0xb2, 0x7f, 0x02,
	0xa4, 0x8c, 0xeb, 0x63, 0x3f, 0xa1, 0x06, 0xd8, 0x88, 0x5f, 0xb7, 0x41, 0x20, 0xf8, 0x2b, 0xea,
	0xa8, 0x2e, 0x55, 0xd6, 0xbd, 0xbc, 0x36, 0xd8, 0x8d, 0xb4, 0x66, 0xe3, 0xc6, 0x5e, 0x7d, 0xda,
	0x9c, 0x33, 0xdf, 0xe5, 0xe7, 0x54, 0x58, 0xf7, 0xf3, 0x4e, 0x9b, 0x97, 0xa1, 0xd2, 0x9c, 0x36,
	0xd7, 0x3e, 0xfc, 0x3b, 0xaa, 0x7a, 0xdc, 0x21, 0xde, 0xae, 0x47, 0xfc, 0x1d, 0xee, 0x52, 0xcb,
	0x02, 0xd0, 0x57, 0xe9, 0xa0, 0x67, 0x49, 0x39, 0xd0, 0x46, 0x09, 0xba, 0x1d, 0xcc, 0x0b, 0x23,
	0xd1, 0x0e, 0x9f, 0xe6, 0xb5, 0x43, 0x6b, 0xcc, 0x61, 0xda, 0x61, 0x9c, 0x83, 0xf7, 0xd0, 0xbc,
	0x19, 0x7b, 0x2a, 0xb8, 0xaf, 0x18, 0x15, 0xd6, 0x72, 0x5e, 0xf7, 0xb7, 0x46, 0xf4, 0xc0, 0x1d,
	0x63, 0xe8, 0x25, 0xe1, 0xc2, 0x65, 0x3e, 0xf1, 0x98, 0x7a, 0x63, 0x7d, 0x96, 0xb7, 0x24, 0xcf,
	0x23, 0xad, 0x59, 0x92, 0xd8, 0xab, 0xcb, 0xa9, 0xdf, 0x61, 0x36, 0x3f, 0x0f, 0xf7, 0xdd, 0x83,
	0xbc, 0x72, 0x36, 0x93, 0x72, 0x53, 0xce, 0x11, 0xc2, 0x93, 0xe2, 0xc5, 0x3f, 0x2b, 0x85, 0xed,
	0x62, 0x69, 0x7e, 0x71, 0x61, 0xbb, 0x58, 0x9a, 0x59, 0x9c, 0xdd, 0x2e, 0x96, 0xe6, 0x16, 0xab,
	0xf5, 0x79, 0x34, 0x97, 0xbc, 0xa0, 0xeb, 0x0c, 0xdd, 0xb9, 0xb1, 0x34, 0xb8, 0x8e, 0xe6, 0x6c,
	0x7e, 0xde, 0xe5, 0x03, 0xe1, 0xd0, 0x8e, 0xfb, 0x1a, 0xee, 0xfc, 0xaa, 0x3d, 0x32, 0x86, 0x1f,
	0xa0, 0xf2, 0xce, 0xa0, 0x0f, 0x4f, 0x30, 0x09, 0x37, 0x7a, 0xd5, 0x8e, 0x07, 0x30, 0x46, 0xc5,
	0x1d, 0xd2, 0xa7, 0x70, 0x3d, 0x97, 0x6d, 0xf8, 0xae, 0x7f, 0x8b, 0xee, 0xdd, 0xde, 0xef, 0x78,
	0x19, 0x4d, 0x32, 0x17, 0xa2, 0x94, 0x9b, 0x28, 0x7c, 0xa0, 0x4c, 0x76, 0xda, 0xf6, 0x24, 0x73,
	0xeb, 0x5b, 0xc8, 0x4a, 0xeb, 0x60, 0xbc, 0x8e, 0x90, 0x04, 0xca, 0x01, 0x73, 0x25, 0xbc, 0x17,
	0xcb, 0xcd, 0xea, 0xf0, 0x72, 0xa5, 0x6c, 0xd8, 0x9d, 0xb6, 0xb4, 0xcb, 0x46, 0xd0, 0x71, 0x65,
	0xf3, 0xeb, 0x8b, 0xff, 0x6b, 0x13, 0x17, 0xc3, 0x5a, 0xe1, 0xdd, 0xb0, 0x56, 0x78, 0x3f, 0xac,
	0x15, 0xfe, 0x1b, 0xd6, 0x0a, 0x7f, 0x5f, 0xd5, 0x26, 0xde, 0x5d, 0xd5, 0x26, 0xde, 0x5f, 0xd5,
	0x26, 0xf6, 0x2b, 0x89, 0xc7, 0xec, 0x87, 0x00, 0x00, 0x00, 0xff, 0xff, 0x87, 0xe5, 0x5f, 0x4a,
	0xdb, 0x0b, 0x00, 0x00,
}
