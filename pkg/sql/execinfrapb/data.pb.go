// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/data.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	_ "github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgerror"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/cockroachdb/cockroach/pkg/util/hlc"
	tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	errorspb "github.com/cockroachdb/errors/errorspb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types1 "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The direction of the desired ordering for a column.
type Ordering_Column_Direction int32

const (
	Ordering_Column_ASC  Ordering_Column_Direction = 0
	Ordering_Column_DESC Ordering_Column_Direction = 1
)

var Ordering_Column_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}

var Ordering_Column_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Ordering_Column_Direction) Enum() *Ordering_Column_Direction {
	p := new(Ordering_Column_Direction)
	*p = x
	return p
}

func (x Ordering_Column_Direction) String() string {
	return proto.EnumName(Ordering_Column_Direction_name, int32(x))
}

func (x *Ordering_Column_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Ordering_Column_Direction_value, data, "Ordering_Column_Direction")
	if err != nil {
		return err
	}
	*x = Ordering_Column_Direction(value)
	return nil
}

func (Ordering_Column_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{2, 0, 0}
}

type StreamEndpointSpec_Type int32

const (
	// Stream that is part of the local flow.
	StreamEndpointSpec_LOCAL StreamEndpointSpec_Type = 0
	// Stream that has the other endpoint on a different node.
	StreamEndpointSpec_REMOTE StreamEndpointSpec_Type = 1
	// Special stream used when in "sync flow" mode. In this mode, we return
	// results directly as part of the RPC call that set up the flow. This saves
	// overhead (extra RPCs) compared to the normal mode where the RPC just sets
	// up the flow. This type can only be used with outbound endpoints.
	StreamEndpointSpec_SYNC_RESPONSE StreamEndpointSpec_Type = 2
)

var StreamEndpointSpec_Type_name = map[int32]string{
	0: "LOCAL",
	1: "REMOTE",
	2: "SYNC_RESPONSE",
}

var StreamEndpointSpec_Type_value = map[string]int32{
	"LOCAL":         0,
	"REMOTE":        1,
	"SYNC_RESPONSE": 2,
}

func (x StreamEndpointSpec_Type) Enum() *StreamEndpointSpec_Type {
	p := new(StreamEndpointSpec_Type)
	*p = x
	return p
}

func (x StreamEndpointSpec_Type) String() string {
	return proto.EnumName(StreamEndpointSpec_Type_name, int32(x))
}

func (x *StreamEndpointSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StreamEndpointSpec_Type_value, data, "StreamEndpointSpec_Type")
	if err != nil {
		return err
	}
	*x = StreamEndpointSpec_Type(value)
	return nil
}

func (StreamEndpointSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{3, 0}
}

type InputSyncSpec_Type int32

const (
	// Rows from the input streams are interleaved arbitrarily. Each input
	// stream runs in a separate goroutine in order to not block on the slow
	// producers.
	InputSyncSpec_PARALLEL_UNORDERED InputSyncSpec_Type = 0
	// The input streams are guaranteed to be ordered according to the column
	// ordering field; rows from the streams are interleaved to preserve that
	// ordering.
	InputSyncSpec_ORDERED InputSyncSpec_Type = 1
	// Each input stream is consumed fully, in turn, before the next input
	// stream is received from.
	InputSyncSpec_SERIAL_UNORDERED InputSyncSpec_Type = 2
)

var InputSyncSpec_Type_name = map[int32]string{
	0: "PARALLEL_UNORDERED",
	1: "ORDERED",
	2: "SERIAL_UNORDERED",
}

var InputSyncSpec_Type_value = map[string]int32{
	"PARALLEL_UNORDERED": 0,
	"ORDERED":            1,
	"SERIAL_UNORDERED":   2,
}

func (x InputSyncSpec_Type) Enum() *InputSyncSpec_Type {
	p := new(InputSyncSpec_Type)
	*p = x
	return p
}

func (x InputSyncSpec_Type) String() string {
	return proto.EnumName(InputSyncSpec_Type_name, int32(x))
}

func (x *InputSyncSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InputSyncSpec_Type_value, data, "InputSyncSpec_Type")
	if err != nil {
		return err
	}
	*x = InputSyncSpec_Type(value)
	return nil
}

func (InputSyncSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{4, 0}
}

type OutputRouterSpec_Type int32

const (
	// Single output stream.
	OutputRouterSpec_PASS_THROUGH OutputRouterSpec_Type = 0
	// Each row is sent to all output streams.
	OutputRouterSpec_MIRROR OutputRouterSpec_Type = 1
	// Each row is sent to one stream, chosen by hashing certain columns of
	// the row (specified by the hash_columns field).
	OutputRouterSpec_BY_HASH OutputRouterSpec_Type = 2
	// Each row is sent to one stream, chosen according to preset boundaries
	// for the values of certain columns of the row.
	OutputRouterSpec_BY_RANGE OutputRouterSpec_Type = 3
)

var OutputRouterSpec_Type_name = map[int32]string{
	0: "PASS_THROUGH",
	1: "MIRROR",
	2: "BY_HASH",
	3: "BY_RANGE",
}

var OutputRouterSpec_Type_value = map[string]int32{
	"PASS_THROUGH": 0,
	"MIRROR":       1,
	"BY_HASH":      2,
	"BY_RANGE":     3,
}

func (x OutputRouterSpec_Type) Enum() *OutputRouterSpec_Type {
	p := new(OutputRouterSpec_Type)
	*p = x
	return p
}

func (x OutputRouterSpec_Type) String() string {
	return proto.EnumName(OutputRouterSpec_Type_name, int32(x))
}

func (x *OutputRouterSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OutputRouterSpec_Type_value, data, "OutputRouterSpec_Type")
	if err != nil {
		return err
	}
	*x = OutputRouterSpec_Type(value)
	return nil
}

func (OutputRouterSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{5, 0}
}

// Error is a generic representation including a string message.
type Error struct {
	// full_error contains a structured errors with possibly multiple
	// wrapping layers implementing the errors.Cause() interface.
	FullError *errorspb.EncodedError `protobuf:"bytes,3,opt,name=full_error,json=fullError" json:"full_error,omitempty"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Expression) Reset()      { *m = Expression{} }
func (*Expression) ProtoMessage() {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{1}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

// Ordering defines an order - specifically a list of column indices and
// directions. See colinfo.ColumnOrdering.
type Ordering struct {
	Columns []Ordering_Column `protobuf:"bytes,1,rep,name=columns" json:"columns"`
}

func (m *Ordering) Reset()         { *m = Ordering{} }
func (m *Ordering) String() string { return proto.CompactTextString(m) }
func (*Ordering) ProtoMessage()    {}
func (*Ordering) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{2}
}
func (m *Ordering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ordering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ordering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ordering.Merge(m, src)
}
func (m *Ordering) XXX_Size() int {
	return m.Size()
}
func (m *Ordering) XXX_DiscardUnknown() {
	xxx_messageInfo_Ordering.DiscardUnknown(m)
}

var xxx_messageInfo_Ordering proto.InternalMessageInfo

type Ordering_Column struct {
	ColIdx    uint32                    `protobuf:"varint,1,opt,name=col_idx,json=colIdx" json:"col_idx"`
	Direction Ordering_Column_Direction `protobuf:"varint,2,opt,name=direction,enum=cockroach.sql.distsqlrun.Ordering_Column_Direction" json:"direction"`
}

func (m *Ordering_Column) Reset()         { *m = Ordering_Column{} }
func (m *Ordering_Column) String() string { return proto.CompactTextString(m) }
func (*Ordering_Column) ProtoMessage()    {}
func (*Ordering_Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{2, 0}
}
func (m *Ordering_Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ordering_Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ordering_Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ordering_Column.Merge(m, src)
}
func (m *Ordering_Column) XXX_Size() int {
	return m.Size()
}
func (m *Ordering_Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Ordering_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Ordering_Column proto.InternalMessageInfo

// StreamEndpointSpec describes one of the endpoints (input or output) of a physical
// stream.
type StreamEndpointSpec struct {
	Type StreamEndpointSpec_Type `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.StreamEndpointSpec_Type" json:"type"`
	// The ID of this stream.
	//
	// For LOCAL streams, both ends of the stream are part of the flow on this
	// machine (and there must be a corresponding endpoint with the same ID).
	//
	// For REMOTE streams, this ID is used in the ProducerHeader when connecting to
	// the other host.
	//
	// For SYNC_RESPONSE streams, the ID is unused.
	StreamID StreamID `protobuf:"varint,2,opt,name=stream_id,json=streamId,casttype=StreamID" json:"stream_id"`
	// Node ID of the target host, only used for outgoing REMOTE streams.
	TargetNodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,4,opt,name=target_node_id,json=targetNodeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"target_node_id"`
	// Node ID of the origin node, only used for REMOTE streams.
	OriginNodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,5,opt,name=origin_node_id,json=originNodeId,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"origin_node_id"`
}

func (m *StreamEndpointSpec) Reset()         { *m = StreamEndpointSpec{} }
func (m *StreamEndpointSpec) String() string { return proto.CompactTextString(m) }
func (*StreamEndpointSpec) ProtoMessage()    {}
func (*StreamEndpointSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{3}
}
func (m *StreamEndpointSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamEndpointSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamEndpointSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamEndpointSpec.Merge(m, src)
}
func (m *StreamEndpointSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamEndpointSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamEndpointSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamEndpointSpec proto.InternalMessageInfo

// InputSyncSpec is the specification for an input synchronizer; it decides how
// to interleave rows from multiple input streams.
type InputSyncSpec struct {
	Type     InputSyncSpec_Type   `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.InputSyncSpec_Type" json:"type"`
	Ordering Ordering             `protobuf:"bytes,2,opt,name=ordering" json:"ordering"`
	Streams  []StreamEndpointSpec `protobuf:"bytes,3,rep,name=streams" json:"streams"`
	// Schema for the streams entering this synchronizer.
	ColumnTypes []*types.T `protobuf:"bytes,4,rep,name=column_types,json=columnTypes" json:"column_types,omitempty"`
}

func (m *InputSyncSpec) Reset()         { *m = InputSyncSpec{} }
func (m *InputSyncSpec) String() string { return proto.CompactTextString(m) }
func (*InputSyncSpec) ProtoMessage()    {}
func (*InputSyncSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{4}
}
func (m *InputSyncSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputSyncSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InputSyncSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputSyncSpec.Merge(m, src)
}
func (m *InputSyncSpec) XXX_Size() int {
	return m.Size()
}
func (m *InputSyncSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InputSyncSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InputSyncSpec proto.InternalMessageInfo

// OutputRouterSpec is the specification for the output router of a processor;
// it decides how to send results to multiple output streams.
type OutputRouterSpec struct {
	Type    OutputRouterSpec_Type `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.OutputRouterSpec_Type" json:"type"`
	Streams []StreamEndpointSpec  `protobuf:"bytes,2,rep,name=streams" json:"streams"`
	// Only used for the BY_HASH type; these are the indexes of the columns we are
	// hashing.
	HashColumns     []uint32                         `protobuf:"varint,3,rep,name=hash_columns,json=hashColumns" json:"hash_columns,omitempty"`
	RangeRouterSpec OutputRouterSpec_RangeRouterSpec `protobuf:"bytes,4,opt,name=range_router_spec,json=rangeRouterSpec" json:"range_router_spec"`
	// disable_buffering disables output buffering. Generally buffering should be
	// enabled to prevent deadlocks. However some plans are known not to deadlock,
	// and so can set this flag to prevent unbounded buffering causing OOMs.
	DisableBuffering bool `protobuf:"varint,5,opt,name=disable_buffering,json=disableBuffering" json:"disable_buffering"`
}

func (m *OutputRouterSpec) Reset()         { *m = OutputRouterSpec{} }
func (m *OutputRouterSpec) String() string { return proto.CompactTextString(m) }
func (*OutputRouterSpec) ProtoMessage()    {}
func (*OutputRouterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{5}
}
func (m *OutputRouterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRouterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutputRouterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRouterSpec.Merge(m, src)
}
func (m *OutputRouterSpec) XXX_Size() int {
	return m.Size()
}
func (m *OutputRouterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRouterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRouterSpec proto.InternalMessageInfo

type OutputRouterSpec_RangeRouterSpec struct {
	// spans is a slice of Span. Input matching a span will be routed to its
	// specified stream.
	Spans []OutputRouterSpec_RangeRouterSpec_Span `protobuf:"bytes,1,rep,name=spans" json:"spans"`
	// default_dest, if not nil, is the index of the stream to send rows that do
	// not match any span. If nil, a row that does not match a span will produce
	// an error in the router.
	DefaultDest *int32 `protobuf:"varint,2,opt,name=default_dest,json=defaultDest" json:"default_dest,omitempty"`
	// encodings is a slice of columns and encodings. Each will be appended to a
	// []byte, which is used as input to the spans. Columns from the input rows
	// potentially need to be recoded to match the encoding used for the spans.
	Encodings []OutputRouterSpec_RangeRouterSpec_ColumnEncoding `protobuf:"bytes,3,rep,name=encodings" json:"encodings"`
}

func (m *OutputRouterSpec_RangeRouterSpec) Reset()         { *m = OutputRouterSpec_RangeRouterSpec{} }
func (m *OutputRouterSpec_RangeRouterSpec) String() string { return proto.CompactTextString(m) }
func (*OutputRouterSpec_RangeRouterSpec) ProtoMessage()    {}
func (*OutputRouterSpec_RangeRouterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{5, 0}
}
func (m *OutputRouterSpec_RangeRouterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRouterSpec_RangeRouterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutputRouterSpec_RangeRouterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec.Merge(m, src)
}
func (m *OutputRouterSpec_RangeRouterSpec) XXX_Size() int {
	return m.Size()
}
func (m *OutputRouterSpec_RangeRouterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRouterSpec_RangeRouterSpec proto.InternalMessageInfo

type OutputRouterSpec_RangeRouterSpec_ColumnEncoding struct {
	// column is the index of a column to encode.
	Column uint32 `protobuf:"varint,1,opt,name=column" json:"column"`
	// encoding specifies how a particular column is to be encoded for
	// generating the sort key for a row. This needs to correspond to the way
	// the Span.{start,end} keys have been generated.
	Encoding descpb.DatumEncoding `protobuf:"varint,2,opt,name=encoding,enum=cockroach.sql.sqlbase.DatumEncoding" json:"encoding"`
}

func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) Reset() {
	*m = OutputRouterSpec_RangeRouterSpec_ColumnEncoding{}
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) String() string {
	return proto.CompactTextString(m)
}
func (*OutputRouterSpec_RangeRouterSpec_ColumnEncoding) ProtoMessage() {}
func (*OutputRouterSpec_RangeRouterSpec_ColumnEncoding) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{5, 0, 0}
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_ColumnEncoding.Merge(m, src)
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) XXX_Size() int {
	return m.Size()
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_ColumnEncoding.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_ColumnEncoding proto.InternalMessageInfo

// Span matches bytes in [start, end).
type OutputRouterSpec_RangeRouterSpec_Span struct {
	Start []byte `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   []byte `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
	// stream is the index of the destination stream.
	Stream int32 `protobuf:"varint,3,opt,name=stream" json:"stream"`
}

func (m *OutputRouterSpec_RangeRouterSpec_Span) Reset()         { *m = OutputRouterSpec_RangeRouterSpec_Span{} }
func (m *OutputRouterSpec_RangeRouterSpec_Span) String() string { return proto.CompactTextString(m) }
func (*OutputRouterSpec_RangeRouterSpec_Span) ProtoMessage()    {}
func (*OutputRouterSpec_RangeRouterSpec_Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{5, 0, 1}
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_Span.Merge(m, src)
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) XXX_Size() int {
	return m.Size()
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_Span.DiscardUnknown(m)
}

var xxx_messageInfo_OutputRouterSpec_RangeRouterSpec_Span proto.InternalMessageInfo

type DatumInfo struct {
	Encoding descpb.DatumEncoding `protobuf:"varint,1,opt,name=encoding,enum=cockroach.sql.sqlbase.DatumEncoding" json:"encoding"`
	Type     *types.T             `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *DatumInfo) Reset()         { *m = DatumInfo{} }
func (m *DatumInfo) String() string { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()    {}
func (*DatumInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{6}
}
func (m *DatumInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatumInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatumInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatumInfo.Merge(m, src)
}
func (m *DatumInfo) XXX_Size() int {
	return m.Size()
}
func (m *DatumInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DatumInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DatumInfo proto.InternalMessageInfo

// ProducerHeader is a message that is sent once at the beginning of a stream.
type ProducerHeader struct {
	FlowID   FlowID   `protobuf:"bytes,1,opt,name=flow_id,json=flowId,customtype=FlowID" json:"flow_id"`
	StreamID StreamID `protobuf:"varint,2,opt,name=stream_id,json=streamId,casttype=StreamID" json:"stream_id"`
}

func (m *ProducerHeader) Reset()         { *m = ProducerHeader{} }
func (m *ProducerHeader) String() string { return proto.CompactTextString(m) }
func (*ProducerHeader) ProtoMessage()    {}
func (*ProducerHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{7}
}
func (m *ProducerHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProducerHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProducerHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProducerHeader.Merge(m, src)
}
func (m *ProducerHeader) XXX_Size() int {
	return m.Size()
}
func (m *ProducerHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ProducerHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ProducerHeader proto.InternalMessageInfo

// ProducerData is a message that can be sent multiple times as part of a stream
// from a producer to a consumer. It contains 0 or more rows and/or 0 or more
// metadata messages.
type ProducerData struct {
	// A bunch of rows, encoded. Each datum is encoded according to the
	// corresponding DatumInfo.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
	// In the special case when the stream contains empty rows, the count is
	// passed instead.
	NumEmptyRows int32 `protobuf:"varint,3,opt,name=num_empty_rows,json=numEmptyRows" json:"num_empty_rows"`
	// A bunch of metadata messages.
	Metadata []RemoteProducerMetadata `protobuf:"bytes,2,rep,name=metadata" json:"metadata"`
}

func (m *ProducerData) Reset()         { *m = ProducerData{} }
func (m *ProducerData) String() string { return proto.CompactTextString(m) }
func (*ProducerData) ProtoMessage()    {}
func (*ProducerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{8}
}
func (m *ProducerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProducerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProducerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProducerData.Merge(m, src)
}
func (m *ProducerData) XXX_Size() int {
	return m.Size()
}
func (m *ProducerData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProducerData.DiscardUnknown(m)
}

var xxx_messageInfo_ProducerData proto.InternalMessageInfo

type ProducerMessage struct {
	Header *ProducerHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// Typing information. There will be one DatumInfo for each element in a row.
	// This field has to be populated on, or before, a ProducerMessage with data
	// in it, and can only be populated once. It can be nil if only zero length
	// rows will be sent.
	// TODO(andrei): It'd be nice if the typing information for streams would be
	// configured statically at plan creation time, instead of being discovered
	// dynamically through the first rows that flow.
	Typing []DatumInfo  `protobuf:"bytes,2,rep,name=typing" json:"typing"`
	Data   ProducerData `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *ProducerMessage) Reset()         { *m = ProducerMessage{} }
func (m *ProducerMessage) String() string { return proto.CompactTextString(m) }
func (*ProducerMessage) ProtoMessage()    {}
func (*ProducerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{9}
}
func (m *ProducerMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProducerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProducerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProducerMessage.Merge(m, src)
}
func (m *ProducerMessage) XXX_Size() int {
	return m.Size()
}
func (m *ProducerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProducerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ProducerMessage proto.InternalMessageInfo

// RemoteProducerMetadata represents records that a producer wants to pass to
// a consumer, other than data rows. It's named RemoteProducerMetadata to not
// clash with ProducerMetadata, which is used internally within a node and has
// a different go error instead of a proto error inside.
type RemoteProducerMetadata struct {
	// Types that are valid to be assigned to Value:
	//	*RemoteProducerMetadata_RangeInfo
	//	*RemoteProducerMetadata_Error
	//	*RemoteProducerMetadata_TraceData_
	//	*RemoteProducerMetadata_LeafTxnFinalState
	//	*RemoteProducerMetadata_RowNum_
	//	*RemoteProducerMetadata_SamplerProgress_
	//	*RemoteProducerMetadata_Metrics_
	//	*RemoteProducerMetadata_BulkProcessorProgress_
	Value isRemoteProducerMetadata_Value `protobuf_oneof:"value"`
}

func (m *RemoteProducerMetadata) Reset()         { *m = RemoteProducerMetadata{} }
func (m *RemoteProducerMetadata) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata) ProtoMessage()    {}
func (*RemoteProducerMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10}
}
func (m *RemoteProducerMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata.Merge(m, src)
}
func (m *RemoteProducerMetadata) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata proto.InternalMessageInfo

type isRemoteProducerMetadata_Value interface {
	isRemoteProducerMetadata_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RemoteProducerMetadata_RangeInfo struct {
	RangeInfo *RemoteProducerMetadata_RangeInfos `protobuf:"bytes,1,opt,name=range_info,json=rangeInfo,oneof" json:"range_info,omitempty"`
}
type RemoteProducerMetadata_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof" json:"error,omitempty"`
}
type RemoteProducerMetadata_TraceData_ struct {
	TraceData *RemoteProducerMetadata_TraceData `protobuf:"bytes,3,opt,name=trace_data,json=traceData,oneof" json:"trace_data,omitempty"`
}
type RemoteProducerMetadata_LeafTxnFinalState struct {
	LeafTxnFinalState *roachpb.LeafTxnFinalState `protobuf:"bytes,4,opt,name=leaf_txn_final_state,json=leafTxnFinalState,oneof" json:"leaf_txn_final_state,omitempty"`
}
type RemoteProducerMetadata_RowNum_ struct {
	RowNum *RemoteProducerMetadata_RowNum `protobuf:"bytes,5,opt,name=row_num,json=rowNum,oneof" json:"row_num,omitempty"`
}
type RemoteProducerMetadata_SamplerProgress_ struct {
	SamplerProgress *RemoteProducerMetadata_SamplerProgress `protobuf:"bytes,7,opt,name=sampler_progress,json=samplerProgress,oneof" json:"sampler_progress,omitempty"`
}
type RemoteProducerMetadata_Metrics_ struct {
	Metrics *RemoteProducerMetadata_Metrics `protobuf:"bytes,8,opt,name=metrics,oneof" json:"metrics,omitempty"`
}
type RemoteProducerMetadata_BulkProcessorProgress_ struct {
	BulkProcessorProgress *RemoteProducerMetadata_BulkProcessorProgress `protobuf:"bytes,9,opt,name=bulk_processor_progress,json=bulkProcessorProgress,oneof" json:"bulk_processor_progress,omitempty"`
}

func (*RemoteProducerMetadata_RangeInfo) isRemoteProducerMetadata_Value()              {}
func (*RemoteProducerMetadata_Error) isRemoteProducerMetadata_Value()                  {}
func (*RemoteProducerMetadata_TraceData_) isRemoteProducerMetadata_Value()             {}
func (*RemoteProducerMetadata_LeafTxnFinalState) isRemoteProducerMetadata_Value()      {}
func (*RemoteProducerMetadata_RowNum_) isRemoteProducerMetadata_Value()                {}
func (*RemoteProducerMetadata_SamplerProgress_) isRemoteProducerMetadata_Value()       {}
func (*RemoteProducerMetadata_Metrics_) isRemoteProducerMetadata_Value()               {}
func (*RemoteProducerMetadata_BulkProcessorProgress_) isRemoteProducerMetadata_Value() {}

func (m *RemoteProducerMetadata) GetValue() isRemoteProducerMetadata_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RemoteProducerMetadata) GetRangeInfo() *RemoteProducerMetadata_RangeInfos {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_RangeInfo); ok {
		return x.RangeInfo
	}
	return nil
}

func (m *RemoteProducerMetadata) GetError() *Error {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_Error); ok {
		return x.Error
	}
	return nil
}

func (m *RemoteProducerMetadata) GetTraceData() *RemoteProducerMetadata_TraceData {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_TraceData_); ok {
		return x.TraceData
	}
	return nil
}

func (m *RemoteProducerMetadata) GetLeafTxnFinalState() *roachpb.LeafTxnFinalState {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_LeafTxnFinalState); ok {
		return x.LeafTxnFinalState
	}
	return nil
}

func (m *RemoteProducerMetadata) GetRowNum() *RemoteProducerMetadata_RowNum {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_RowNum_); ok {
		return x.RowNum
	}
	return nil
}

func (m *RemoteProducerMetadata) GetSamplerProgress() *RemoteProducerMetadata_SamplerProgress {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_SamplerProgress_); ok {
		return x.SamplerProgress
	}
	return nil
}

func (m *RemoteProducerMetadata) GetMetrics() *RemoteProducerMetadata_Metrics {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_Metrics_); ok {
		return x.Metrics
	}
	return nil
}

func (m *RemoteProducerMetadata) GetBulkProcessorProgress() *RemoteProducerMetadata_BulkProcessorProgress {
	if x, ok := m.GetValue().(*RemoteProducerMetadata_BulkProcessorProgress_); ok {
		return x.BulkProcessorProgress
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RemoteProducerMetadata) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RemoteProducerMetadata_RangeInfo)(nil),
		(*RemoteProducerMetadata_Error)(nil),
		(*RemoteProducerMetadata_TraceData_)(nil),
		(*RemoteProducerMetadata_LeafTxnFinalState)(nil),
		(*RemoteProducerMetadata_RowNum_)(nil),
		(*RemoteProducerMetadata_SamplerProgress_)(nil),
		(*RemoteProducerMetadata_Metrics_)(nil),
		(*RemoteProducerMetadata_BulkProcessorProgress_)(nil),
	}
}

type RemoteProducerMetadata_RangeInfos struct {
	RangeInfo []roachpb.RangeInfo `protobuf:"bytes,1,rep,name=range_info,json=rangeInfo" json:"range_info"`
}

func (m *RemoteProducerMetadata_RangeInfos) Reset()         { *m = RemoteProducerMetadata_RangeInfos{} }
func (m *RemoteProducerMetadata_RangeInfos) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata_RangeInfos) ProtoMessage()    {}
func (*RemoteProducerMetadata_RangeInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 0}
}
func (m *RemoteProducerMetadata_RangeInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_RangeInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_RangeInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_RangeInfos.Merge(m, src)
}
func (m *RemoteProducerMetadata_RangeInfos) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_RangeInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_RangeInfos.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_RangeInfos proto.InternalMessageInfo

type RemoteProducerMetadata_TraceData struct {
	CollectedSpans []tracingpb.RecordedSpan `protobuf:"bytes,1,rep,name=collected_spans,json=collectedSpans" json:"collected_spans"`
}

func (m *RemoteProducerMetadata_TraceData) Reset()         { *m = RemoteProducerMetadata_TraceData{} }
func (m *RemoteProducerMetadata_TraceData) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata_TraceData) ProtoMessage()    {}
func (*RemoteProducerMetadata_TraceData) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 1}
}
func (m *RemoteProducerMetadata_TraceData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_TraceData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_TraceData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_TraceData.Merge(m, src)
}
func (m *RemoteProducerMetadata_TraceData) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_TraceData) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_TraceData.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_TraceData proto.InternalMessageInfo

// RowNum is used to count the rows sent from a processor. It is used in tests
// to check that metadata is propagated correctly.
type RemoteProducerMetadata_RowNum struct {
	// The ID of the processor that is producing rows.
	SenderID string `protobuf:"bytes,1,opt,name=sender_id,json=senderId" json:"sender_id"`
	// A running count of the number of rows emitted from the sender so far.
	RowNum int32 `protobuf:"varint,2,opt,name=row_num,json=rowNum" json:"row_num"`
	// When set, indicates that the row count contains the expected number of
	// RowNum messages with this ID.
	LastMsg bool `protobuf:"varint,3,opt,name=last_msg,json=lastMsg" json:"last_msg"`
}

func (m *RemoteProducerMetadata_RowNum) Reset()         { *m = RemoteProducerMetadata_RowNum{} }
func (m *RemoteProducerMetadata_RowNum) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata_RowNum) ProtoMessage()    {}
func (*RemoteProducerMetadata_RowNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 2}
}
func (m *RemoteProducerMetadata_RowNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_RowNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_RowNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_RowNum.Merge(m, src)
}
func (m *RemoteProducerMetadata_RowNum) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_RowNum) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_RowNum.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_RowNum proto.InternalMessageInfo

type RemoteProducerMetadata_SamplerProgress struct {
	// The number of rows processed by the sampler processor since the last
	// update.
	RowsProcessed uint64 `protobuf:"varint,1,opt,name=rows_processed,json=rowsProcessed" json:"rows_processed"`
	// Indicates that sample collection for histograms should be disabled,
	// likely because the sampler processor ran out of memory.
	HistogramDisabled bool `protobuf:"varint,2,opt,name=histogram_disabled,json=histogramDisabled" json:"histogram_disabled"`
}

func (m *RemoteProducerMetadata_SamplerProgress) Reset() {
	*m = RemoteProducerMetadata_SamplerProgress{}
}
func (m *RemoteProducerMetadata_SamplerProgress) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata_SamplerProgress) ProtoMessage()    {}
func (*RemoteProducerMetadata_SamplerProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 3}
}
func (m *RemoteProducerMetadata_SamplerProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_SamplerProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_SamplerProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_SamplerProgress.Merge(m, src)
}
func (m *RemoteProducerMetadata_SamplerProgress) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_SamplerProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_SamplerProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_SamplerProgress proto.InternalMessageInfo

type RemoteProducerMetadata_BulkProcessorProgress struct {
	CompletedSpans    []roachpb.Span    `protobuf:"bytes,1,rep,name=completed_spans,json=completedSpans" json:"completed_spans"`
	CompletedFraction map[int32]float32 `protobuf:"bytes,2,rep,name=completed_fraction,json=completedFraction" json:"completed_fraction,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"fixed32,2,opt,name=value"`
	ResumePos         map[int32]int64   `protobuf:"bytes,3,rep,name=resume_pos,json=resumePos" json:"resume_pos,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Used to stream back progress to the coordinator of a bulk job.
	ProgressDetails types1.Any `protobuf:"bytes,4,opt,name=progress_details,json=progressDetails" json:"progress_details"`
}

func (m *RemoteProducerMetadata_BulkProcessorProgress) Reset() {
	*m = RemoteProducerMetadata_BulkProcessorProgress{}
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) String() string {
	return proto.CompactTextString(m)
}
func (*RemoteProducerMetadata_BulkProcessorProgress) ProtoMessage() {}
func (*RemoteProducerMetadata_BulkProcessorProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 4}
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_BulkProcessorProgress.Merge(m, src)
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_BulkProcessorProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_BulkProcessorProgress proto.InternalMessageInfo

// Metrics are unconditionally emitted by table readers.
type RemoteProducerMetadata_Metrics struct {
	// Total number of bytes read while executing a statement.
	BytesRead int64 `protobuf:"varint,1,opt,name=bytes_read,json=bytesRead" json:"bytes_read"`
	// Total number of rows read while executing a statement.
	RowsRead int64 `protobuf:"varint,2,opt,name=rows_read,json=rowsRead" json:"rows_read"`
}

func (m *RemoteProducerMetadata_Metrics) Reset()         { *m = RemoteProducerMetadata_Metrics{} }
func (m *RemoteProducerMetadata_Metrics) String() string { return proto.CompactTextString(m) }
func (*RemoteProducerMetadata_Metrics) ProtoMessage()    {}
func (*RemoteProducerMetadata_Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{10, 5}
}
func (m *RemoteProducerMetadata_Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteProducerMetadata_Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteProducerMetadata_Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteProducerMetadata_Metrics.Merge(m, src)
}
func (m *RemoteProducerMetadata_Metrics) XXX_Size() int {
	return m.Size()
}
func (m *RemoteProducerMetadata_Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteProducerMetadata_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteProducerMetadata_Metrics proto.InternalMessageInfo

// DistSQLVersionGossipInfo represents the DistSQL server version information
// that gets gossiped for each node. This is used by planners to avoid planning
// on nodes with incompatible version during rolling cluster updates.
//
// For the meaning of the fields, see the corresponding constants in
// distsqlrun/server.go.
type DistSQLVersionGossipInfo struct {
	Version            DistSQLVersion `protobuf:"varint,1,opt,name=version,casttype=DistSQLVersion" json:"version"`
	MinAcceptedVersion DistSQLVersion `protobuf:"varint,2,opt,name=min_accepted_version,json=minAcceptedVersion,casttype=DistSQLVersion" json:"min_accepted_version"`
}

func (m *DistSQLVersionGossipInfo) Reset()         { *m = DistSQLVersionGossipInfo{} }
func (m *DistSQLVersionGossipInfo) String() string { return proto.CompactTextString(m) }
func (*DistSQLVersionGossipInfo) ProtoMessage()    {}
func (*DistSQLVersionGossipInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{11}
}
func (m *DistSQLVersionGossipInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistSQLVersionGossipInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistSQLVersionGossipInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistSQLVersionGossipInfo.Merge(m, src)
}
func (m *DistSQLVersionGossipInfo) XXX_Size() int {
	return m.Size()
}
func (m *DistSQLVersionGossipInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DistSQLVersionGossipInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DistSQLVersionGossipInfo proto.InternalMessageInfo

// DistSQLDrainingInfo represents the DistSQL draining state that gets gossiped
// for each node. This is used by planners to avoid planning on nodes that are
// known to be draining.
type DistSQLDrainingInfo struct {
	Draining bool `protobuf:"varint,1,opt,name=draining" json:"draining"`
}

func (m *DistSQLDrainingInfo) Reset()         { *m = DistSQLDrainingInfo{} }
func (m *DistSQLDrainingInfo) String() string { return proto.CompactTextString(m) }
func (*DistSQLDrainingInfo) ProtoMessage()    {}
func (*DistSQLDrainingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_88f01b948ed44512, []int{12}
}
func (m *DistSQLDrainingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistSQLDrainingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistSQLDrainingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistSQLDrainingInfo.Merge(m, src)
}
func (m *DistSQLDrainingInfo) XXX_Size() int {
	return m.Size()
}
func (m *DistSQLDrainingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DistSQLDrainingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DistSQLDrainingInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.Ordering_Column_Direction", Ordering_Column_Direction_name, Ordering_Column_Direction_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.StreamEndpointSpec_Type", StreamEndpointSpec_Type_name, StreamEndpointSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.InputSyncSpec_Type", InputSyncSpec_Type_name, InputSyncSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.OutputRouterSpec_Type", OutputRouterSpec_Type_name, OutputRouterSpec_Type_value)
	proto.RegisterType((*Error)(nil), "cockroach.sql.distsqlrun.Error")
	proto.RegisterType((*Expression)(nil), "cockroach.sql.distsqlrun.Expression")
	proto.RegisterType((*Ordering)(nil), "cockroach.sql.distsqlrun.Ordering")
	proto.RegisterType((*Ordering_Column)(nil), "cockroach.sql.distsqlrun.Ordering.Column")
	proto.RegisterType((*StreamEndpointSpec)(nil), "cockroach.sql.distsqlrun.StreamEndpointSpec")
	proto.RegisterType((*InputSyncSpec)(nil), "cockroach.sql.distsqlrun.InputSyncSpec")
	proto.RegisterType((*OutputRouterSpec)(nil), "cockroach.sql.distsqlrun.OutputRouterSpec")
	proto.RegisterType((*OutputRouterSpec_RangeRouterSpec)(nil), "cockroach.sql.distsqlrun.OutputRouterSpec.RangeRouterSpec")
	proto.RegisterType((*OutputRouterSpec_RangeRouterSpec_ColumnEncoding)(nil), "cockroach.sql.distsqlrun.OutputRouterSpec.RangeRouterSpec.ColumnEncoding")
	proto.RegisterType((*OutputRouterSpec_RangeRouterSpec_Span)(nil), "cockroach.sql.distsqlrun.OutputRouterSpec.RangeRouterSpec.Span")
	proto.RegisterType((*DatumInfo)(nil), "cockroach.sql.distsqlrun.DatumInfo")
	proto.RegisterType((*ProducerHeader)(nil), "cockroach.sql.distsqlrun.ProducerHeader")
	proto.RegisterType((*ProducerData)(nil), "cockroach.sql.distsqlrun.ProducerData")
	proto.RegisterType((*ProducerMessage)(nil), "cockroach.sql.distsqlrun.ProducerMessage")
	proto.RegisterType((*RemoteProducerMetadata)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata")
	proto.RegisterType((*RemoteProducerMetadata_RangeInfos)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.RangeInfos")
	proto.RegisterType((*RemoteProducerMetadata_TraceData)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.TraceData")
	proto.RegisterType((*RemoteProducerMetadata_RowNum)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.RowNum")
	proto.RegisterType((*RemoteProducerMetadata_SamplerProgress)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.SamplerProgress")
	proto.RegisterType((*RemoteProducerMetadata_BulkProcessorProgress)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.BulkProcessorProgress")
	proto.RegisterMapType((map[int32]float32)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.BulkProcessorProgress.CompletedFractionEntry")
	proto.RegisterMapType((map[int32]int64)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.BulkProcessorProgress.ResumePosEntry")
	proto.RegisterType((*RemoteProducerMetadata_Metrics)(nil), "cockroach.sql.distsqlrun.RemoteProducerMetadata.Metrics")
	proto.RegisterType((*DistSQLVersionGossipInfo)(nil), "cockroach.sql.distsqlrun.DistSQLVersionGossipInfo")
	proto.RegisterType((*DistSQLDrainingInfo)(nil), "cockroach.sql.distsqlrun.DistSQLDrainingInfo")
}

func init() { proto.RegisterFile("sql/execinfrapb/data.proto", fileDescriptor_88f01b948ed44512) }

var fileDescriptor_88f01b948ed44512 = []byte{
	// 2109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xbb, 0x73, 0x5b, 0xc7,
	0xd5, 0xc7, 0x8b, 0x78, 0x1c, 0xf0, 0x01, 0xee, 0x47, 0xcb, 0xf8, 0x10, 0x85, 0x94, 0xa1, 0x8c,
	0x47, 0x71, 0xec, 0x0b, 0x89, 0x2a, 0xe4, 0x30, 0xc9, 0x48, 0x00, 0x01, 0x0a, 0x90, 0x29, 0x92,
	0xbe, 0xa0, 0xe2, 0x91, 0x1d, 0xcf, 0x9d, 0x8b, 0x7b, 0x17, 0xe0, 0xb5, 0xee, 0x4b, 0xbb, 0x7b,
	0x45, 0xb2, 0xc9, 0x64, 0x26, 0x29, 0x53, 0xa4, 0xca, 0xa4, 0x74, 0x9a, 0x34, 0x29, 0xd2, 0xe7,
	0x0f, 0xf0, 0xa8, 0x74, 0xa9, 0x49, 0xa1, 0x49, 0xa8, 0x26, 0x4d, 0x66, 0xd2, 0xc6, 0x55, 0x66,
	0x5f, 0x78, 0x50, 0xa4, 0x14, 0x5a, 0x6e, 0x80, 0xdd, 0xb3, 0xe7, 0xf7, 0x3b, 0x67, 0xcf, 0x9e,
	0x3d, 0xbb, 0x7b, 0xa1, 0x46, 0x1f, 0xfb, 0x0d, 0x7c, 0x84, 0x1d, 0x2f, 0x1c, 0x12, 0x3b, 0x1e,
	0x34, 0x5c, 0x9b, 0xd9, 0x46, 0x4c, 0x22, 0x16, 0xa1, 0xaa, 0x13, 0x39, 0x8f, 0x48, 0x64, 0x3b,
	0x07, 0x06, 0x7d, 0xec, 0x1b, 0xae, 0x47, 0x19, 0x7d, 0xec, 0x93, 0x24, 0xac, 0x5d, 0xfa, 0x22,
	0x1a, 0xd0, 0x06, 0xff, 0x89, 0x07, 0xe2, 0x4f, 0x22, 0x6a, 0xcb, 0x42, 0x3b, 0x1e, 0x34, 0xec,
	0xd8, 0x53, 0x22, 0xa4, 0x45, 0x13, 0xe2, 0xda, 0x8a, 0x96, 0x61, 0x42, 0x22, 0xa2, 0xc1, 0x6f,
	0xc9, 0xde, 0x69, 0xf1, 0x1a, 0xf7, 0x30, 0x1e, 0x1d, 0x7a, 0x04, 0x37, 0xe2, 0x91, 0x18, 0x9a,
	0x55, 0xb8, 0xca, 0x15, 0x1c, 0x9b, 0xd9, 0x7e, 0x34, 0x6a, 0xb8, 0x98, 0x3a, 0xf1, 0xa0, 0x41,
	0x19, 0x49, 0x1c, 0x96, 0x10, 0xec, 0x2a, 0xa5, 0x77, 0xcf, 0x50, 0xc2, 0xa1, 0x13, 0xb9, 0xd8,
	0xb5, 0x5c, 0x9b, 0x25, 0x81, 0x76, 0x82, 0xeb, 0xb1, 0xe3, 0x18, 0x53, 0xf9, 0xab, 0xc4, 0xef,
	0x25, 0xcc, 0xf3, 0x1b, 0x8c, 0xd8, 0x8e, 0x17, 0x8e, 0xf4, 0x7f, 0x3c, 0x68, 0x10, 0xec, 0x44,
	0x84, 0x73, 0xd0, 0xd8, 0x0e, 0xf5, 0xec, 0x46, 0xd1, 0x28, 0x12, 0xcd, 0x06, 0x6f, 0x29, 0x69,
	0x55, 0x30, 0x1c, 0xf8, 0x4e, 0x83, 0x79, 0x01, 0xa6, 0xcc, 0x0e, 0x62, 0x35, 0xf2, 0xff, 0xa3,
	0x28, 0x1a, 0xf9, 0xb8, 0x21, 0x7a, 0x83, 0x64, 0xd8, 0xb0, 0xc3, 0x63, 0x39, 0x54, 0xff, 0x14,
	0xe6, 0x3a, 0x7c, 0xaa, 0xe8, 0x36, 0xc0, 0x30, 0xf1, 0x7d, 0x4b, 0x4c, 0xbc, 0x9a, 0xbd, 0x92,
	0xbe, 0x56, 0x5e, 0xbf, 0x62, 0x4c, 0xd6, 0x47, 0x87, 0xce, 0xe8, 0xc8, 0x39, 0x09, 0x94, 0x59,
	0xe2, 0x18, 0xd1, 0xdc, 0xc8, 0xfd, 0xe1, 0xcb, 0xb5, 0xd4, 0xbd, 0x5c, 0x31, 0x5d, 0xc9, 0xdc,
	0xcb, 0x15, 0x33, 0x95, 0x6c, 0x7d, 0x0f, 0xa0, 0x73, 0x14, 0x13, 0x4c, 0xa9, 0x17, 0x85, 0x68,
	0x15, 0x0a, 0x4f, 0x30, 0xe1, 0xcd, 0x6a, 0xfa, 0x4a, 0xfa, 0x5a, 0xa9, 0x95, 0x7b, 0xfa, 0x7c,
	0x2d, 0x65, 0x6a, 0x21, 0xaa, 0x42, 0x0e, 0x1f, 0xc5, 0xa4, 0x9a, 0x99, 0x1a, 0x14, 0x92, 0x8d,
	0x22, 0x67, 0xfe, 0xf7, 0x1f, 0xd7, 0x52, 0xf5, 0xdf, 0x64, 0xa0, 0xb8, 0x4b, 0x5c, 0x4c, 0xbc,
	0x70, 0x84, 0x7a, 0x50, 0x70, 0x22, 0x3f, 0x09, 0x42, 0x5a, 0x4d, 0x5f, 0xc9, 0x5e, 0x2b, 0xaf,
	0xff, 0xd0, 0x38, 0x2f, 0x9d, 0x0c, 0x0d, 0x32, 0x36, 0x05, 0x42, 0xdb, 0x56, 0xf8, 0xda, 0x9f,
	0xd2, 0x90, 0x97, 0x23, 0xe8, 0xfb, 0x82, 0xd5, 0xf2, 0xdc, 0x23, 0xe1, 0xe6, 0x82, 0x52, 0xcd,
	0x3b, 0x91, 0xdf, 0x73, 0x8f, 0xd0, 0x27, 0x50, 0x72, 0x3d, 0x82, 0x1d, 0xc6, 0xe7, 0xc1, 0x5d,
	0x5d, 0x5c, 0xbf, 0xf9, 0x3f, 0x9b, 0x35, 0xda, 0x1a, 0xaa, 0x58, 0x27, 0x5c, 0xf5, 0x55, 0x28,
	0x8d, 0x47, 0x51, 0x01, 0xb2, 0xcd, 0xfe, 0x66, 0x25, 0x85, 0x8a, 0x90, 0x6b, 0x77, 0xfa, 0x9b,
	0x95, 0xf4, 0x46, 0xee, 0x9f, 0x5f, 0xae, 0xa9, 0xdf, 0xfa, 0x5f, 0xb3, 0x80, 0xfa, 0x8c, 0x60,
	0x3b, 0xe8, 0x84, 0x6e, 0x1c, 0x79, 0x21, 0xeb, 0xc7, 0xd8, 0x41, 0x1f, 0x41, 0x8e, 0x67, 0x94,
	0xf0, 0x7b, 0x71, 0xfd, 0xc6, 0xf9, 0x6e, 0xbd, 0x8c, 0x35, 0xf6, 0x8f, 0x63, 0xac, 0x83, 0xce,
	0x49, 0xd0, 0x8f, 0xa1, 0x44, 0x85, 0x9a, 0xe5, 0xb9, 0x62, 0xa2, 0x73, 0xad, 0xcb, 0x7c, 0xf8,
	0xe4, 0xf9, 0x5a, 0x51, 0xe2, 0x7b, 0xed, 0x6f, 0xa6, 0xda, 0x66, 0x51, 0xaa, 0xf7, 0x5c, 0xf4,
	0x18, 0x16, 0x99, 0x4d, 0x46, 0x98, 0x59, 0x61, 0xe4, 0x62, 0x8e, 0xcf, 0x09, 0xfc, 0x47, 0x0a,
	0x3f, 0xbf, 0x2f, 0x46, 0x77, 0x22, 0x17, 0x0b, 0x8e, 0x9b, 0x23, 0x8f, 0x1d, 0x24, 0x03, 0xc3,
	0x89, 0x82, 0xc6, 0xd8, 0x67, 0x77, 0x30, 0x69, 0x37, 0xe2, 0x47, 0xa3, 0x86, 0xda, 0xd1, 0x86,
	0x84, 0x99, 0xf3, 0x6c, 0x42, 0x22, 0x4c, 0x46, 0xc4, 0x1b, 0x79, 0xe1, 0xd8, 0xe4, 0xdc, 0xac,
	0xc9, 0x5d, 0x31, 0xfa, 0x86, 0x26, 0xa3, 0x09, 0x89, 0x5b, 0xbf, 0x0e, 0x39, 0x1e, 0x34, 0x54,
	0x82, 0xb9, 0xed, 0xdd, 0xcd, 0xe6, 0x76, 0x25, 0x85, 0x00, 0xf2, 0x66, 0xe7, 0xfe, 0xee, 0x7e,
	0xa7, 0x92, 0x46, 0xcb, 0xb0, 0xd0, 0x7f, 0xb8, 0xb3, 0x69, 0x99, 0x9d, 0xfe, 0xde, 0xee, 0x4e,
	0xbf, 0x23, 0x76, 0x45, 0xb6, 0x92, 0xab, 0xff, 0x2b, 0x03, 0x0b, 0xbd, 0x30, 0x4e, 0x58, 0xff,
	0x38, 0x74, 0xc4, 0xba, 0x6d, 0xcd, 0xac, 0xdb, 0xfb, 0xe7, 0xaf, 0xdb, 0x0c, 0xec, 0xe5, 0x25,
	0x6b, 0x43, 0x31, 0x52, 0x09, 0x27, 0x56, 0xac, 0xbc, 0x5e, 0x7f, 0x7d, 0x6a, 0x2a, 0x86, 0x31,
	0x12, 0x6d, 0x43, 0x41, 0xae, 0x24, 0xad, 0x66, 0xc5, 0xb6, 0x7a, 0xff, 0x22, 0x89, 0xa4, 0x77,
	0x96, 0xa2, 0x40, 0x3f, 0x83, 0x79, 0xb9, 0xc9, 0x2c, 0x51, 0xec, 0xaa, 0x39, 0x41, 0x59, 0x3b,
	0x45, 0x49, 0x71, 0x60, 0xc8, 0x62, 0xb8, 0x6f, 0x96, 0xa5, 0x3e, 0x9f, 0x1d, 0xad, 0x37, 0x55,
	0x90, 0x2f, 0x01, 0xda, 0x6b, 0x9a, 0xcd, 0xed, 0xed, 0xce, 0xb6, 0xf5, 0x60, 0x67, 0xd7, 0x6c,
	0x77, 0xcc, 0x4e, 0xbb, 0x92, 0x42, 0x65, 0x28, 0xe8, 0x4e, 0x1a, 0xad, 0x40, 0xa5, 0xdf, 0x31,
	0x7b, 0xcd, 0x69, 0x95, 0x4c, 0xfd, 0x3f, 0x79, 0xa8, 0xec, 0x26, 0x2c, 0x4e, 0x98, 0x19, 0x25,
	0x0c, 0x13, 0x11, 0xf2, 0xde, 0x4c, 0xc8, 0x1b, 0xaf, 0x08, 0xd3, 0x29, 0xe4, 0xcb, 0x51, 0x9f,
	0x8a, 0x57, 0xe6, 0xcd, 0xe3, 0xf5, 0x0e, 0xcc, 0x1f, 0xd8, 0xf4, 0xc0, 0xd2, 0x95, 0x8d, 0x2f,
	0xc1, 0x82, 0x59, 0xe6, 0x32, 0x59, 0x43, 0x28, 0xf2, 0x61, 0x99, 0xd8, 0xe1, 0x08, 0x5b, 0x44,
	0x78, 0x65, 0xd1, 0x18, 0x3b, 0x62, 0x87, 0x95, 0xd7, 0x37, 0x2e, 0x30, 0x11, 0x93, 0x73, 0x4c,
	0xfa, 0xca, 0x91, 0x25, 0x32, 0x2b, 0x46, 0x37, 0x60, 0xd9, 0xf5, 0xa8, 0x3d, 0xf0, 0xb1, 0x35,
	0x48, 0x86, 0x43, 0x99, 0x5d, 0x7c, 0x73, 0x15, 0x15, 0xa2, 0xa2, 0x86, 0x5b, 0x7a, 0xb4, 0xf6,
	0x55, 0x16, 0x96, 0x4e, 0xb1, 0xa3, 0xcf, 0x60, 0x8e, 0x1f, 0x60, 0xba, 0x54, 0xdf, 0xfe, 0xf6,
	0x8e, 0x1a, 0xfd, 0xd8, 0xd6, 0xf5, 0x53, 0x72, 0xf2, 0xa0, 0xb9, 0x78, 0x68, 0x27, 0x3e, 0xb3,
	0x5c, 0x4c, 0x99, 0x2c, 0x57, 0x66, 0x59, 0xc9, 0xda, 0x98, 0x32, 0x14, 0x40, 0x49, 0x1c, 0xc6,
	0x5e, 0x38, 0xd2, 0x79, 0xdd, 0x7b, 0x03, 0x1f, 0xe4, 0x5a, 0x74, 0x14, 0xa3, 0xae, 0xe6, 0x63,
	0x0b, 0xb5, 0x27, 0xb0, 0x38, 0xab, 0x82, 0x2e, 0x43, 0x5e, 0xae, 0xe9, 0x4b, 0xc7, 0x0a, 0x3f,
	0x75, 0xb6, 0xa0, 0xa8, 0xc1, 0xea, 0x54, 0xf9, 0xc1, 0xe9, 0x2d, 0xf2, 0xd8, 0x1f, 0xd8, 0x14,
	0x1b, 0x6d, 0x7e, 0x95, 0x38, 0x65, 0x78, 0x8c, 0xad, 0x6d, 0x43, 0x8e, 0x87, 0x07, 0xad, 0xc0,
	0x1c, 0x65, 0x36, 0x61, 0xc2, 0xd8, 0xbc, 0x29, 0x3b, 0xa8, 0x02, 0x59, 0x1c, 0xca, 0x6a, 0x3e,
	0x6f, 0xf2, 0x26, 0xf7, 0x4a, 0x66, 0x9e, 0x38, 0xf1, 0xe7, 0xb4, 0x57, 0x52, 0x56, 0xbf, 0xad,
	0x76, 0x5f, 0x05, 0xe6, 0xf7, 0x9a, 0xfd, 0xbe, 0xb5, 0xdf, 0x35, 0x77, 0x1f, 0xdc, 0xed, 0xca,
	0x4a, 0x77, 0xbf, 0x67, 0x9a, 0xbb, 0x66, 0x25, 0xcd, 0xf7, 0x60, 0xeb, 0xa1, 0xd5, 0x6d, 0xf6,
	0xbb, 0x95, 0x0c, 0x9a, 0x87, 0x62, 0xeb, 0xa1, 0x65, 0x36, 0x77, 0xee, 0x76, 0x2a, 0xd9, 0xfa,
	0xaf, 0xd3, 0x50, 0x12, 0x0e, 0xf7, 0xc2, 0x61, 0x34, 0x33, 0xc9, 0xf4, 0xb7, 0x9f, 0x24, 0x32,
	0xd4, 0xe6, 0x95, 0x35, 0xee, 0x55, 0xb5, 0x44, 0xe8, 0xd5, 0x7f, 0x09, 0x8b, 0x7b, 0x24, 0x72,
	0x13, 0x07, 0x93, 0x2e, 0xb6, 0x5d, 0x4c, 0xd0, 0x0d, 0x28, 0x0c, 0xfd, 0xe8, 0x90, 0x9f, 0x13,
	0x22, 0x40, 0xad, 0x2a, 0x37, 0xf1, 0xb7, 0xe7, 0x6b, 0xf9, 0x2d, 0x3f, 0x3a, 0xec, 0xb5, 0x4f,
	0xc6, 0x2d, 0x33, 0xcf, 0x15, 0x7b, 0xee, 0x1b, 0x9c, 0x87, 0xf5, 0x3f, 0xa7, 0x61, 0x5e, 0x3b,
	0xd0, 0xb6, 0x99, 0x8d, 0xbe, 0x07, 0x25, 0x62, 0x1f, 0x5a, 0x83, 0x63, 0x86, 0xa9, 0x5a, 0xa1,
	0x22, 0xb1, 0x0f, 0x5b, 0xbc, 0x8f, 0xde, 0x83, 0xc5, 0x30, 0x09, 0x2c, 0x1c, 0xc4, 0xec, 0xd8,
	0x22, 0xd1, 0x21, 0x9d, 0x59, 0x9a, 0xf9, 0x30, 0x09, 0x3a, 0x7c, 0xc8, 0x8c, 0x0e, 0x29, 0x32,
	0xa1, 0x18, 0x60, 0x66, 0xf3, 0x8b, 0xaf, 0x2a, 0x3e, 0xd7, 0xcf, 0x4f, 0x6a, 0x13, 0x07, 0x11,
	0xc3, 0xda, 0x91, 0xfb, 0x0a, 0xa7, 0xa3, 0xab, 0x79, 0xea, 0xcf, 0xd2, 0xb0, 0x34, 0x51, 0xa2,
	0xd4, 0x1e, 0x61, 0x74, 0x07, 0xf2, 0x07, 0x22, 0x72, 0xc2, 0xdb, 0xf2, 0xfa, 0xb5, 0xf3, 0xad,
	0xcc, 0x46, 0xda, 0x54, 0x38, 0xd4, 0x84, 0x3c, 0x3b, 0x8e, 0x65, 0x7a, 0x73, 0x3f, 0xaf, 0x9e,
	0xcf, 0x30, 0x4e, 0x18, 0x9d, 0x8d, 0x12, 0x88, 0xee, 0x40, 0x4e, 0x4c, 0x54, 0xde, 0x4d, 0xdf,
	0x7d, 0xbd, 0x0b, 0xed, 0xc9, 0xf4, 0x04, 0xb2, 0xfe, 0xd5, 0x22, 0x5c, 0x3a, 0x3b, 0x0a, 0xe8,
	0x17, 0x00, 0xb2, 0xa8, 0x7a, 0xe1, 0x30, 0x52, 0xb3, 0xfc, 0xc9, 0x45, 0x63, 0x29, 0xcb, 0x04,
	0x77, 0x9d, 0x76, 0x53, 0x66, 0x89, 0xe8, 0x1e, 0xba, 0x05, 0x73, 0xf2, 0x5e, 0x2d, 0x53, 0x76,
	0xed, 0x7c, 0x62, 0x71, 0x97, 0xee, 0xa6, 0x4c, 0xa9, 0x8f, 0x3e, 0x03, 0xe0, 0x4f, 0x01, 0x6c,
	0x4d, 0xcd, 0x7c, 0xe3, 0xc2, 0x6e, 0xed, 0x73, 0x0a, 0x1e, 0x0d, 0xee, 0x15, 0xd3, 0x1d, 0xf4,
	0x09, 0xac, 0xf8, 0xd8, 0x1e, 0x5a, 0xec, 0x28, 0xb4, 0x86, 0x5e, 0x68, 0xfb, 0x16, 0x65, 0x36,
	0xc3, 0xea, 0x2c, 0x99, 0xde, 0x9b, 0xfa, 0x22, 0xb4, 0x8d, 0xed, 0xe1, 0xfe, 0x51, 0xb8, 0xc5,
	0x95, 0xfb, 0x5c, 0xb7, 0x9b, 0x32, 0x97, 0xfd, 0xd3, 0x42, 0x64, 0x42, 0x81, 0x44, 0x87, 0x56,
	0x98, 0x04, 0xe2, 0xa4, 0x28, 0xaf, 0xdf, 0xba, 0x78, 0x24, 0xa3, 0xc3, 0x9d, 0x24, 0xe8, 0xa6,
	0xcc, 0x3c, 0x11, 0x2d, 0x14, 0x40, 0x85, 0xda, 0x41, 0xec, 0x63, 0x62, 0xc5, 0x24, 0x1a, 0xf1,
	0x57, 0x45, 0xb5, 0x20, 0xc8, 0xef, 0x5c, 0x98, 0xbc, 0x2f, 0x89, 0xf6, 0x14, 0x4f, 0x37, 0x65,
	0x2e, 0xd1, 0x59, 0x11, 0xda, 0x87, 0x42, 0x80, 0x19, 0xf1, 0x1c, 0x5a, 0x2d, 0x0a, 0x2b, 0x1f,
	0x5e, 0xd8, 0xca, 0x7d, 0x89, 0xef, 0xa6, 0x4c, 0x4d, 0x85, 0x7e, 0x95, 0x86, 0xb7, 0x07, 0x89,
	0xff, 0x88, 0x4f, 0xc1, 0xc1, 0x94, 0x46, 0x53, 0x93, 0x29, 0x09, 0x33, 0x5b, 0x17, 0x36, 0xd3,
	0x4a, 0xfc, 0x47, 0x7b, 0x9a, 0x6e, 0x6a, 0x4a, 0x6f, 0x0d, 0xce, 0x1a, 0xa8, 0xed, 0x02, 0x4c,
	0xb2, 0x14, 0x35, 0x4f, 0xa5, 0x3d, 0xdf, 0x9a, 0x97, 0xcf, 0x58, 0xf8, 0x31, 0x44, 0x1f, 0x75,
	0xe3, 0xdc, 0xae, 0x7d, 0x01, 0xa5, 0x71, 0x7e, 0xa1, 0xcf, 0x61, 0xc9, 0x89, 0x7c, 0x1f, 0x3b,
	0x4c, 0xbd, 0x58, 0xf5, 0x81, 0x6f, 0x4c, 0x91, 0xf2, 0x77, 0xaa, 0xa1, 0x5e, 0xb8, 0xc6, 0xf8,
	0xa5, 0x6b, 0x98, 0xea, 0xa5, 0x3b, 0x75, 0xbe, 0x2f, 0x8e, 0xc9, 0xb8, 0x90, 0xd6, 0x0e, 0x21,
	0x2f, 0x13, 0x03, 0x7d, 0x00, 0x25, 0x8a, 0x43, 0x17, 0x13, 0x5d, 0xc3, 0x4b, 0xad, 0xca, 0xb8,
	0x1c, 0x8b, 0x01, 0x51, 0x82, 0x65, 0xcb, 0xe5, 0xaf, 0x3a, 0x9d, 0x91, 0x99, 0xe9, 0x83, 0x4e,
	0x25, 0xd7, 0x1a, 0x14, 0x7d, 0x9b, 0x32, 0x2b, 0xa0, 0x23, 0xb1, 0xc9, 0xf4, 0xdd, 0xa6, 0xc0,
	0xa5, 0xf7, 0xe9, 0xa8, 0x46, 0x61, 0xe9, 0x54, 0xd2, 0xa0, 0x1f, 0xc1, 0x22, 0xaf, 0xce, 0x7a,
	0x29, 0xb1, 0x74, 0x23, 0xa7, 0x90, 0x0b, 0x7c, 0x6c, 0x4f, 0x0f, 0xa1, 0x9b, 0x80, 0x0e, 0x3c,
	0xca, 0xa2, 0x11, 0xb1, 0x03, 0x4b, 0x5d, 0x98, 0xe4, 0x31, 0xa2, 0x4d, 0x2d, 0x8f, 0xc7, 0xdb,
	0x6a, 0xb8, 0xf6, 0x97, 0x1c, 0xbc, 0x75, 0xe6, 0xea, 0xa2, 0x2d, 0x1e, 0x66, 0xee, 0xce, 0xe9,
	0x30, 0xbf, 0x7d, 0xc6, 0xda, 0xcd, 0xc6, 0x53, 0xa1, 0x44, 0x3c, 0xd1, 0x6f, 0xd3, 0x80, 0x26,
	0x44, 0x43, 0x62, 0xeb, 0x77, 0x2d, 0xe7, 0xfa, 0xfc, 0xbb, 0x49, 0x45, 0x63, 0x53, 0x1b, 0xd8,
	0x52, 0xfc, 0x9d, 0x90, 0x91, 0x63, 0x73, 0xd9, 0x39, 0x2d, 0x47, 0x0c, 0x80, 0x60, 0x9a, 0x04,
	0xd8, 0x8a, 0x23, 0x7d, 0x4b, 0x7b, 0xf0, 0x1d, 0x79, 0x61, 0x0a, 0xe2, 0xbd, 0x88, 0x4a, 0xeb,
	0x25, 0xa2, 0xfb, 0xa8, 0x03, 0x15, 0xbd, 0x09, 0x2d, 0x17, 0x33, 0xdb, 0xf3, 0xa9, 0x2a, 0x81,
	0x2b, 0x86, 0xfc, 0x70, 0x62, 0xe8, 0x0f, 0x27, 0x46, 0x33, 0x3c, 0xd6, 0x17, 0x65, 0x8d, 0x69,
	0x4b, 0x48, 0xad, 0x0d, 0x97, 0xce, 0x9e, 0x29, 0xbf, 0x76, 0x3d, 0xc2, 0xc7, 0x22, 0x3d, 0xe6,
	0x4c, 0xde, 0xe4, 0xd7, 0xb3, 0x27, 0xb6, 0x9f, 0xc8, 0x2b, 0x4c, 0xc6, 0x94, 0x9d, 0x8d, 0xcc,
	0x87, 0xe9, 0xda, 0x4f, 0x61, 0x71, 0xd6, 0xd3, 0xd7, 0xa1, 0xb3, 0xd3, 0xe8, 0x8f, 0xa1, 0xa0,
	0xaa, 0x0e, 0xba, 0x0a, 0x20, 0xee, 0x17, 0x16, 0xc1, 0xb6, 0x4c, 0xcd, 0xac, 0xde, 0xbb, 0x42,
	0x6e, 0x62, 0xdb, 0x45, 0xef, 0x40, 0x49, 0xe4, 0xb0, 0xd0, 0xc9, 0x4c, 0xe9, 0x14, 0xb9, 0x98,
	0xab, 0xb4, 0x0a, 0xca, 0xd8, 0xbd, 0x5c, 0x31, 0x5f, 0x29, 0xdc, 0xcb, 0x15, 0xa1, 0x52, 0xae,
	0xff, 0x3e, 0x0d, 0xd5, 0xb6, 0x47, 0x59, 0xff, 0xe3, 0xed, 0x9f, 0xcb, 0xcf, 0x37, 0x77, 0x23,
	0x4a, 0xbd, 0x58, 0x1c, 0x76, 0xd7, 0x67, 0x3f, 0xf4, 0x2c, 0xb4, 0x2e, 0x71, 0xca, 0x6f, 0x9e,
	0xaf, 0x2d, 0xce, 0x42, 0x26, 0x9f, 0x7e, 0xba, 0xb0, 0x12, 0x78, 0xa1, 0x65, 0x3b, 0x0e, 0x8e,
	0x79, 0x22, 0x6a, 0x78, 0xe6, 0x95, 0x70, 0x14, 0x78, 0x61, 0x53, 0x41, 0x94, 0xac, 0x7e, 0x0b,
	0xfe, 0x4f, 0x69, 0xb5, 0x89, 0xed, 0x85, 0x5e, 0x38, 0x12, 0x2e, 0x5d, 0x81, 0xa2, 0xab, 0xfa,
	0xc2, 0x27, 0xbd, 0xe9, 0xc6, 0xd2, 0xd6, 0x07, 0x4f, 0xff, 0xb1, 0x9a, 0x7a, 0x7a, 0xb2, 0x9a,
	0xfe, 0xfa, 0x64, 0x35, 0xfd, 0xec, 0x64, 0x35, 0xfd, 0xf7, 0x93, 0xd5, 0xf4, 0xef, 0x5e, 0xac,
	0xa6, 0xbe, 0x7e, 0xb1, 0x9a, 0x7a, 0xf6, 0x62, 0x35, 0xf5, 0x69, 0x79, 0xea, 0x1b, 0xe6, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x5e, 0xe1, 0xc0, 0xd5, 0x14, 0x00, 0x00,
}

func (this *Ordering) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ordering)
	if !ok {
		that2, ok := that.(Ordering)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(&that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *Ordering_Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ordering_Column)
	if !ok {
		that2, ok := that.(Ordering_Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ColIdx != that1.ColIdx {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	return true
}
func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FullError != nil {
		{
			size, err := m.FullError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Expr)
	copy(dAtA[i:], m.Expr)
	i = encodeVarintData(dAtA, i, uint64(len(m.Expr)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Ordering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ordering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ordering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Ordering_Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ordering_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ordering_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.Direction))
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.ColIdx))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *StreamEndpointSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamEndpointSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamEndpointSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.OriginNodeID))
	i--
	dAtA[i] = 0x28
	i = encodeVarintData(dAtA, i, uint64(m.TargetNodeID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintData(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InputSyncSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputSyncSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputSyncSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnTypes) > 0 {
		for iNdEx := len(m.ColumnTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColumnTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintData(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *OutputRouterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRouterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRouterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.DisableBuffering {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	{
		size, err := m.RangeRouterSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.HashColumns) > 0 {
		for iNdEx := len(m.HashColumns) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintData(dAtA, i, uint64(m.HashColumns[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintData(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *OutputRouterSpec_RangeRouterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRouterSpec_RangeRouterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRouterSpec_RangeRouterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Encodings) > 0 {
		for iNdEx := len(m.Encodings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Encodings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DefaultDest != nil {
		i = encodeVarintData(dAtA, i, uint64(*m.DefaultDest))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.Encoding))
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.Column))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *OutputRouterSpec_RangeRouterSpec_Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputRouterSpec_RangeRouterSpec_Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutputRouterSpec_RangeRouterSpec_Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.Stream))
	i--
	dAtA[i] = 0x18
	if m.End != nil {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintData(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if m.Start != nil {
		i -= len(m.Start)
		copy(dAtA[i:], m.Start)
		i = encodeVarintData(dAtA, i, uint64(len(m.Start)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatumInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatumInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintData(dAtA, i, uint64(m.Encoding))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ProducerHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProducerHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProducerHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x10
	{
		size := m.FlowID.Size()
		i -= size
		if _, err := m.FlowID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProducerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProducerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProducerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.NumEmptyRows))
	i--
	dAtA[i] = 0x18
	if len(m.Metadata) > 0 {
		for iNdEx := len(m.Metadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RawBytes != nil {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintData(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProducerMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProducerMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProducerMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Typing) > 0 {
		for iNdEx := len(m.Typing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Typing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_RangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_RangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeInfo != nil {
		{
			size, err := m.RangeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_TraceData_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_TraceData_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TraceData != nil {
		{
			size, err := m.TraceData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_LeafTxnFinalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_LeafTxnFinalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeafTxnFinalState != nil {
		{
			size, err := m.LeafTxnFinalState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_RowNum_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_RowNum_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RowNum != nil {
		{
			size, err := m.RowNum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_SamplerProgress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_SamplerProgress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamplerProgress != nil {
		{
			size, err := m.SamplerProgress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_Metrics_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_Metrics_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_BulkProcessorProgress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_BulkProcessorProgress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BulkProcessorProgress != nil {
		{
			size, err := m.BulkProcessorProgress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RemoteProducerMetadata_RangeInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_RangeInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_RangeInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeInfo) > 0 {
		for iNdEx := len(m.RangeInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_TraceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_TraceData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_TraceData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectedSpans) > 0 {
		for iNdEx := len(m.CollectedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_RowNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_RowNum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_RowNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.LastMsg {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i = encodeVarintData(dAtA, i, uint64(m.RowNum))
	i--
	dAtA[i] = 0x10
	i -= len(m.SenderID)
	copy(dAtA[i:], m.SenderID)
	i = encodeVarintData(dAtA, i, uint64(len(m.SenderID)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_SamplerProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_SamplerProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_SamplerProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.HistogramDisabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.RowsProcessed))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_BulkProcessorProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_BulkProcessorProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_BulkProcessorProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ProgressDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ResumePos) > 0 {
		keysForResumePos := make([]int32, 0, len(m.ResumePos))
		for k := range m.ResumePos {
			keysForResumePos = append(keysForResumePos, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResumePos)
		for iNdEx := len(keysForResumePos) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResumePos[int32(keysForResumePos[iNdEx])]
			baseI := i
			i = encodeVarintData(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintData(dAtA, i, uint64(keysForResumePos[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CompletedFraction) > 0 {
		keysForCompletedFraction := make([]int32, 0, len(m.CompletedFraction))
		for k := range m.CompletedFraction {
			keysForCompletedFraction = append(keysForCompletedFraction, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForCompletedFraction)
		for iNdEx := len(keysForCompletedFraction) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CompletedFraction[int32(keysForCompletedFraction[iNdEx])]
			baseI := i
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i--
			dAtA[i] = 0x15
			i = encodeVarintData(dAtA, i, uint64(keysForCompletedFraction[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CompletedSpans) > 0 {
		for iNdEx := len(m.CompletedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CompletedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteProducerMetadata_Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteProducerMetadata_Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteProducerMetadata_Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.RowsRead))
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.BytesRead))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DistSQLVersionGossipInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistSQLVersionGossipInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistSQLVersionGossipInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintData(dAtA, i, uint64(m.MinAcceptedVersion))
	i--
	dAtA[i] = 0x10
	i = encodeVarintData(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DistSQLDrainingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistSQLDrainingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistSQLDrainingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Draining {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	offset -= sovData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FullError != nil {
		l = m.FullError.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	n += 1 + l + sovData(uint64(l))
	l = len(m.Expr)
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *Ordering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *Ordering_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.ColIdx))
	n += 1 + sovData(uint64(m.Direction))
	return n
}

func (m *StreamEndpointSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Type))
	n += 1 + sovData(uint64(m.StreamID))
	n += 1 + sovData(uint64(m.TargetNodeID))
	n += 1 + sovData(uint64(m.OriginNodeID))
	return n
}

func (m *InputSyncSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Type))
	l = m.Ordering.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.ColumnTypes) > 0 {
		for _, e := range m.ColumnTypes {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *OutputRouterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Type))
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.HashColumns) > 0 {
		for _, e := range m.HashColumns {
			n += 1 + sovData(uint64(e))
		}
	}
	l = m.RangeRouterSpec.Size()
	n += 1 + l + sovData(uint64(l))
	n += 2
	return n
}

func (m *OutputRouterSpec_RangeRouterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.DefaultDest != nil {
		n += 1 + sovData(uint64(*m.DefaultDest))
	}
	if len(m.Encodings) > 0 {
		for _, e := range m.Encodings {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Column))
	n += 1 + sovData(uint64(m.Encoding))
	return n
}

func (m *OutputRouterSpec_RangeRouterSpec_Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = len(m.Start)
		n += 1 + l + sovData(uint64(l))
	}
	if m.End != nil {
		l = len(m.End)
		n += 1 + l + sovData(uint64(l))
	}
	n += 1 + sovData(uint64(m.Stream))
	return n
}

func (m *DatumInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Encoding))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ProducerHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.FlowID.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.StreamID))
	return n
}

func (m *ProducerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RawBytes != nil {
		l = len(m.RawBytes)
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	n += 1 + sovData(uint64(m.NumEmptyRows))
	return n
}

func (m *ProducerMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Typing) > 0 {
		for _, e := range m.Typing {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	l = m.Data.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *RemoteProducerMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *RemoteProducerMetadata_RangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeInfo != nil {
		l = m.RangeInfo.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_TraceData_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TraceData != nil {
		l = m.TraceData.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_LeafTxnFinalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeafTxnFinalState != nil {
		l = m.LeafTxnFinalState.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_RowNum_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowNum != nil {
		l = m.RowNum.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_SamplerProgress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamplerProgress != nil {
		l = m.SamplerProgress.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_Metrics_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_BulkProcessorProgress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BulkProcessorProgress != nil {
		l = m.BulkProcessorProgress.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}
func (m *RemoteProducerMetadata_RangeInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RangeInfo) > 0 {
		for _, e := range m.RangeInfo {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *RemoteProducerMetadata_TraceData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollectedSpans) > 0 {
		for _, e := range m.CollectedSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *RemoteProducerMetadata_RowNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SenderID)
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.RowNum))
	n += 2
	return n
}

func (m *RemoteProducerMetadata_SamplerProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.RowsProcessed))
	n += 2
	return n
}

func (m *RemoteProducerMetadata_BulkProcessorProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CompletedSpans) > 0 {
		for _, e := range m.CompletedSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.CompletedFraction) > 0 {
		for k, v := range m.CompletedFraction {
			_ = k
			_ = v
			mapEntrySize := 1 + sovData(uint64(k)) + 1 + 4
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	if len(m.ResumePos) > 0 {
		for k, v := range m.ResumePos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovData(uint64(k)) + 1 + sovData(uint64(v))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	l = m.ProgressDetails.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *RemoteProducerMetadata_Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.BytesRead))
	n += 1 + sovData(uint64(m.RowsRead))
	return n
}

func (m *DistSQLVersionGossipInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Version))
	n += 1 + sovData(uint64(m.MinAcceptedVersion))
	return n
}

func (m *DistSQLDrainingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func sovData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FullError == nil {
				m.FullError = &errorspb.EncodedError{}
			}
			if err := m.FullError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ordering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ordering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ordering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, Ordering_Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ordering_Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIdx", wireType)
			}
			m.ColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Ordering_Column_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamEndpointSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamEndpointSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamEndpointSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StreamEndpointSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= StreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNodeID", wireType)
			}
			m.TargetNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginNodeID", wireType)
			}
			m.OriginNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginNodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputSyncSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputSyncSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputSyncSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= InputSyncSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, StreamEndpointSpec{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnTypes = append(m.ColumnTypes, &types.T{})
			if err := m.ColumnTypes[len(m.ColumnTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRouterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputRouterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputRouterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OutputRouterSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, StreamEndpointSpec{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HashColumns = append(m.HashColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HashColumns) == 0 {
					m.HashColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HashColumns = append(m.HashColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HashColumns", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeRouterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeRouterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableBuffering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableBuffering = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRouterSpec_RangeRouterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeRouterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeRouterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, OutputRouterSpec_RangeRouterSpec_Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDest", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultDest = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encodings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encodings = append(m.Encodings, OutputRouterSpec_RangeRouterSpec_ColumnEncoding{})
			if err := m.Encodings[len(m.Encodings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRouterSpec_RangeRouterSpec_ColumnEncoding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnEncoding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnEncoding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= descpb.DatumEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRouterSpec_RangeRouterSpec_Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			m.Stream = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stream |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= descpb.DatumEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProducerHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProducerHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProducerHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FlowID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= StreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProducerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProducerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProducerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, RemoteProducerMetadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumEmptyRows", wireType)
			}
			m.NumEmptyRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumEmptyRows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProducerMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProducerMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProducerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ProducerHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Typing = append(m.Typing, DatumInfo{})
			if err := m.Typing[len(m.Typing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteProducerMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteProducerMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_RangeInfos{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_RangeInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_Error{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_TraceData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_TraceData_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafTxnFinalState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &roachpb.LeafTxnFinalState{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_LeafTxnFinalState{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_RowNum{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_RowNum_{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplerProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_SamplerProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_SamplerProgress_{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_Metrics{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_Metrics_{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulkProcessorProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteProducerMetadata_BulkProcessorProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RemoteProducerMetadata_BulkProcessorProgress_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_RangeInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeInfo = append(m.RangeInfo, roachpb.RangeInfo{})
			if err := m.RangeInfo[len(m.RangeInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_TraceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpans = append(m.CollectedSpans, tracingpb.RecordedSpan{})
			if err := m.CollectedSpans[len(m.CollectedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_RowNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowNum", wireType)
			}
			m.RowNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMsg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastMsg = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_SamplerProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplerProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplerProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsProcessed", wireType)
			}
			m.RowsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsProcessed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HistogramDisabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_BulkProcessorProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkProcessorProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkProcessorProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedSpans = append(m.CompletedSpans, roachpb.Span{})
			if err := m.CompletedSpans[len(m.CompletedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedFraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedFraction == nil {
				m.CompletedFraction = make(map[int32]float32)
			}
			var mapkey int32
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CompletedFraction[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePos == nil {
				m.ResumePos = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResumePos[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProgressDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteProducerMetadata_Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			m.RowsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistSQLVersionGossipInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistSQLVersionGossipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistSQLVersionGossipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= DistSQLVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAcceptedVersion", wireType)
			}
			m.MinAcceptedVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAcceptedVersion |= DistSQLVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistSQLDrainingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistSQLDrainingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistSQLDrainingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Draining = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupData = fmt.Errorf("proto: unexpected end of group")
)
