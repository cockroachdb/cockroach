// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_bulk_io.proto

package execinfrapb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import time "time"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// FileCompression list of the compression codecs which are currently
// supported for CSVWriter spec
type FileCompression int32

const (
	FileCompression_None FileCompression = 0
	FileCompression_Gzip FileCompression = 1
)

var FileCompression_name = map[int32]string{
	0: "None",
	1: "Gzip",
}
var FileCompression_value = map[string]int32{
	"None": 0,
	"Gzip": 1,
}

func (x FileCompression) Enum() *FileCompression {
	p := new(FileCompression)
	*p = x
	return p
}
func (x FileCompression) String() string {
	return proto.EnumName(FileCompression_name, int32(x))
}
func (x *FileCompression) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FileCompression_value, data, "FileCompression")
	if err != nil {
		return err
	}
	*x = FileCompression(value)
	return nil
}
func (FileCompression) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{0}
}

type BackfillerSpec_Type int32

const (
	BackfillerSpec_Invalid BackfillerSpec_Type = 0
	BackfillerSpec_Column  BackfillerSpec_Type = 1
	BackfillerSpec_Index   BackfillerSpec_Type = 2
)

var BackfillerSpec_Type_name = map[int32]string{
	0: "Invalid",
	1: "Column",
	2: "Index",
}
var BackfillerSpec_Type_value = map[string]int32{
	"Invalid": 0,
	"Column":  1,
	"Index":   2,
}

func (x BackfillerSpec_Type) Enum() *BackfillerSpec_Type {
	p := new(BackfillerSpec_Type)
	*p = x
	return p
}
func (x BackfillerSpec_Type) String() string {
	return proto.EnumName(BackfillerSpec_Type_name, int32(x))
}
func (x *BackfillerSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BackfillerSpec_Type_value, data, "BackfillerSpec_Type")
	if err != nil {
		return err
	}
	*x = BackfillerSpec_Type(value)
	return nil
}
func (BackfillerSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{0, 0}
}

// BackfillerSpec is the specification for a "schema change backfiller".
// The created backfill processor runs a backfill for the first mutations in
// the table descriptor mutation list with the same mutation id and type.
// A backfiller processor performs KV operations to retrieve rows for a
// table and backfills the new indexes/columns contained in the table
// descriptor. It checkpoints its progress by updating the table
// descriptor in the database, and doesn't emit any rows nor support
// any post-processing.
type BackfillerSpec struct {
	Type  BackfillerSpec_Type     `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.BackfillerSpec_Type" json:"type"`
	Table sqlbase.TableDescriptor `protobuf:"bytes,2,opt,name=table" json:"table"`
	// Sections of the table to be backfilled.
	Spans []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Run the backfill for approximately this duration.
	// The backfill will always process at least one backfill chunk.
	Duration time.Duration `protobuf:"varint,4,opt,name=duration,casttype=time.Duration" json:"duration"`
	// The backfill involves a complete table scan in chunks,
	// where each chunk is a transactional read of a set of rows
	// along with a backfill for the rows. This is the maximum number
	// of entries backfilled per chunk.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// Any other (leased) table descriptors necessary for the
	// backfiller to do its job, such as the descriptors for tables with fk
	// relationships to the table being modified.
	OtherTables []sqlbase.TableDescriptor `protobuf:"bytes,6,rep,name=other_tables,json=otherTables" json:"other_tables"`
	// The timestamp to perform index backfill historical scans at.
	ReadAsOf hlc.Timestamp `protobuf:"bytes,7,opt,name=readAsOf" json:"readAsOf"`
}

func (m *BackfillerSpec) Reset()         { *m = BackfillerSpec{} }
func (m *BackfillerSpec) String() string { return proto.CompactTextString(m) }
func (*BackfillerSpec) ProtoMessage()    {}
func (*BackfillerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{0}
}
func (m *BackfillerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackfillerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillerSpec.Merge(dst, src)
}
func (m *BackfillerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackfillerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillerSpec proto.InternalMessageInfo

// JobProgress identifies the job to report progress on. This reporting
// happens outside this package.
type JobProgress struct {
	JobID int64 `protobuf:"varint,1,opt,name=job_id,json=jobId" json:"job_id"`
	// contribution is the percent of work of the total this processor will
	// process.
	Contribution float32 `protobuf:"fixed32,2,opt,name=contribution" json:"contribution"`
	// slot is the index into the job details for this processor's completion.
	Slot int32 `protobuf:"varint,3,opt,name=slot" json:"slot"`
}

func (m *JobProgress) Reset()         { *m = JobProgress{} }
func (m *JobProgress) String() string { return proto.CompactTextString(m) }
func (*JobProgress) ProtoMessage()    {}
func (*JobProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{1}
}
func (m *JobProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobProgress.Merge(dst, src)
}
func (m *JobProgress) XXX_Size() int {
	return m.Size()
}
func (m *JobProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_JobProgress.DiscardUnknown(m)
}

var xxx_messageInfo_JobProgress proto.InternalMessageInfo

type ReadImportDataSpec struct {
	Format roachpb.IOFileFormat `protobuf:"bytes,8,opt,name=format" json:"format"`
	// sample_size is the rate at which to output rows, based on an input row's size.
	SampleSize int32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// tables supports input formats that can read multiple tables. If it is
	// non-empty, the keys specify the names of tables for which the processor
	// should read and emit data (ignoring data for any other tables that is
	// present in the input).
	//
	// TODO(dt): If a key has a nil value, the schema for that table should be
	// determined from the input on-the-fly (e.g. by parsing a CREATE TABLE in a
	// dump file) and the processor should emit a key/value for the generated
	// TableDescriptor with the corresponding descriptor ID key. If tables is
	// empty (and table_desc above is not specified), the processor should read
	// all tables in the input, determining their schemas on the fly.
	Tables map[string]*ReadImportDataSpec_ImportTable `protobuf:"bytes,9,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// uri is a cloud.ExternalStorage URI pointing to the CSV files to be
	// read. The map key must be unique across the entire IMPORT job.
	Uri map[int32]string `protobuf:"bytes,7,rep,name=uri" json:"uri,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// resume_pos specifies a map from an input ID to an offset in that
	// input from which the processing should continue.
	// The meaning of offset is specific to each processor.
	ResumePos              map[int32]int64 `protobuf:"bytes,14,rep,name=resume_pos,json=resumePos" json:"resume_pos,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Progress               JobProgress     `protobuf:"bytes,6,opt,name=progress" json:"progress"`
	SkipMissingForeignKeys bool            `protobuf:"varint,10,opt,name=skip_missing_foreign_keys,json=skipMissingForeignKeys" json:"skip_missing_foreign_keys"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,11,opt,name=walltimeNanos" json:"walltimeNanos"`
	// If set, specifies reader parallelism; 0 implies "use default".
	ReaderParallelism int32 `protobuf:"varint,13,opt,name=readerParallelism" json:"readerParallelism"`
}

func (m *ReadImportDataSpec) Reset()         { *m = ReadImportDataSpec{} }
func (m *ReadImportDataSpec) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec) ProtoMessage()    {}
func (*ReadImportDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{2}
}
func (m *ReadImportDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ReadImportDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec.Merge(dst, src)
}
func (m *ReadImportDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec proto.InternalMessageInfo

type ReadImportDataSpec_ImportTable struct {
	Desc *sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// targetCols is used to store the target columns for each existing table
	// being imported into. These are the columns for which the processor should
	// read and emit data (ignoring data for any other tables or columns outside
	// of the targetCols, that is present in the input).
	TargetCols []string `protobuf:"bytes,2,rep,name=targetCols" json:"targetCols,omitempty"`
}

func (m *ReadImportDataSpec_ImportTable) Reset()         { *m = ReadImportDataSpec_ImportTable{} }
func (m *ReadImportDataSpec_ImportTable) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec_ImportTable) ProtoMessage()    {}
func (*ReadImportDataSpec_ImportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{2, 0}
}
func (m *ReadImportDataSpec_ImportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ReadImportDataSpec_ImportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.Merge(dst, src)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec_ImportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec_ImportTable proto.InternalMessageInfo

// CSVWriterSpec is the specification for a processor that consumes rows and
// writes them to CSV files at uri. It outputs a row per file written with
// the file name, row count and byte size.
type CSVWriterSpec struct {
	// destination as a cloud.ExternalStorage URI pointing to an export store
	// location (directory).
	Destination string             `protobuf:"bytes,1,opt,name=destination" json:"destination"`
	NamePattern string             `protobuf:"bytes,2,opt,name=name_pattern,json=namePattern" json:"name_pattern"`
	Options     roachpb.CSVOptions `protobuf:"bytes,3,opt,name=options" json:"options"`
	// chunk_rows is num rows to write per file. 0 = no limit.
	ChunkRows int64 `protobuf:"varint,4,opt,name=chunk_rows,json=chunkRows" json:"chunk_rows"`
	// compression_codec specifies compression used for exported file.
	CompressionCodec FileCompression `protobuf:"varint,5,opt,name=compression_codec,json=compressionCodec,enum=cockroach.sql.distsqlrun.FileCompression" json:"compression_codec"`
}

func (m *CSVWriterSpec) Reset()         { *m = CSVWriterSpec{} }
func (m *CSVWriterSpec) String() string { return proto.CompactTextString(m) }
func (*CSVWriterSpec) ProtoMessage()    {}
func (*CSVWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{3}
}
func (m *CSVWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CSVWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVWriterSpec.Merge(dst, src)
}
func (m *CSVWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *CSVWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CSVWriterSpec proto.InternalMessageInfo

// BulkRowWriterSpec is the specification for a processor that consumes rows and
// writes them to a target table using AddSSTable. It outputs a BulkOpSummary.
type BulkRowWriterSpec struct {
	Table sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
}

func (m *BulkRowWriterSpec) Reset()         { *m = BulkRowWriterSpec{} }
func (m *BulkRowWriterSpec) String() string { return proto.CompactTextString(m) }
func (*BulkRowWriterSpec) ProtoMessage()    {}
func (*BulkRowWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_8cd4c8af43285ea2, []int{4}
}
func (m *BulkRowWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkRowWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BulkRowWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkRowWriterSpec.Merge(dst, src)
}
func (m *BulkRowWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *BulkRowWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkRowWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BulkRowWriterSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BackfillerSpec)(nil), "cockroach.sql.distsqlrun.BackfillerSpec")
	proto.RegisterType((*JobProgress)(nil), "cockroach.sql.distsqlrun.JobProgress")
	proto.RegisterType((*ReadImportDataSpec)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec")
	proto.RegisterMapType((map[int32]int64)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ResumePosEntry")
	proto.RegisterMapType((map[string]*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.TablesEntry")
	proto.RegisterMapType((map[int32]string)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.UriEntry")
	proto.RegisterType((*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ImportTable")
	proto.RegisterType((*CSVWriterSpec)(nil), "cockroach.sql.distsqlrun.CSVWriterSpec")
	proto.RegisterType((*BulkRowWriterSpec)(nil), "cockroach.sql.distsqlrun.BulkRowWriterSpec")
	proto.RegisterEnum("cockroach.sql.distsqlrun.FileCompression", FileCompression_name, FileCompression_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.BackfillerSpec_Type", BackfillerSpec_Type_name, BackfillerSpec_Type_value)
}
func (m *BackfillerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Table.Size()))
	n1, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Duration))
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	if len(m.OtherTables) > 0 {
		for _, msg := range m.OtherTables {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReadAsOf.Size()))
	n2, err := m.ReadAsOf.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *JobProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Contribution))))
	i += 4
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Slot))
	return i, nil
}

func (m *ReadImportDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SampleSize))
	dAtA[i] = 0x32
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Progress.Size()))
	n3, err := m.Progress.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Uri) > 0 {
		keysForUri := make([]int32, 0, len(m.Uri))
		for k := range m.Uri {
			keysForUri = append(keysForUri, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForUri)
		for _, k := range keysForUri {
			dAtA[i] = 0x3a
			i++
			v := m.Uri[int32(k)]
			mapSize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Format.Size()))
	n4, err := m.Format.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Tables) > 0 {
		keysForTables := make([]string, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTables)
		for _, k := range keysForTables {
			dAtA[i] = 0x4a
			i++
			v := m.Tables[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovProcessorsBulkIo(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + msgSize
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	dAtA[i] = 0x50
	i++
	if m.SkipMissingForeignKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	dAtA[i] = 0x68
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReaderParallelism))
	if len(m.ResumePos) > 0 {
		keysForResumePos := make([]int32, 0, len(m.ResumePos))
		for k := range m.ResumePos {
			keysForResumePos = append(keysForResumePos, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResumePos)
		for _, k := range keysForResumePos {
			dAtA[i] = 0x72
			i++
			v := m.ResumePos[int32(k)]
			mapSize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + sovProcessorsBulkIo(uint64(v))
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ReadImportDataSpec_ImportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec_ImportTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Desc.Size()))
		n6, err := m.Desc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CSVWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Destination)))
	i += copy(dAtA[i:], m.Destination)
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NamePattern)))
	i += copy(dAtA[i:], m.NamePattern)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Options.Size()))
	n7, err := m.Options.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkRows))
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.CompressionCodec))
	return i, nil
}

func (m *BulkRowWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkRowWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Table.Size()))
	n8, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func encodeVarintProcessorsBulkIo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BackfillerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.Type))
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.Duration))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	if len(m.OtherTables) > 0 {
		for _, e := range m.OtherTables {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = m.ReadAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *JobProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 5
	n += 1 + sovProcessorsBulkIo(uint64(m.Slot))
	return n
}

func (m *ReadImportDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.SampleSize))
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Uri) > 0 {
		for k, v := range m.Uri {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProcessorsBulkIo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	n += 1 + sovProcessorsBulkIo(uint64(m.ReaderParallelism))
	if len(m.ResumePos) > 0 {
		for k, v := range m.ResumePos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + sovProcessorsBulkIo(uint64(v))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ReadImportDataSpec_ImportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *CSVWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.NamePattern)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Options.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkRows))
	n += 1 + sovProcessorsBulkIo(uint64(m.CompressionCodec))
	return n
}

func (m *BulkRowWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func sovProcessorsBulkIo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessorsBulkIo(x uint64) (n int) {
	return sovProcessorsBulkIo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackfillerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (BackfillerSpec_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (time.Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherTables = append(m.OtherTables, sqlbase.TableDescriptor{})
			if err := m.OtherTables[len(m.OtherTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Contribution = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadImportDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadImportDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uri[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*ReadImportDataSpec_ImportTable)
			}
			var mapkey string
			var mapvalue *ReadImportDataSpec_ImportTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReadImportDataSpec_ImportTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMissingForeignKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMissingForeignKeys = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderParallelism", wireType)
			}
			m.ReaderParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderParallelism |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePos == nil {
				m.ResumePos = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResumePos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec_ImportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &sqlbase.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkRows", wireType)
			}
			m.ChunkRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkRows |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionCodec", wireType)
			}
			m.CompressionCodec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionCodec |= (FileCompression(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkRowWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkRowWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkRowWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsBulkIo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsBulkIo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessorsBulkIo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessorsBulkIo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsBulkIo   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_bulk_io.proto", fileDescriptor_processors_bulk_io_8cd4c8af43285ea2)
}

var fileDescriptor_processors_bulk_io_8cd4c8af43285ea2 = []byte{
	// 1086 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x6f, 0x6f, 0xd3, 0x46,
	0x18, 0x8f, 0x13, 0x27, 0x75, 0x9e, 0xb4, 0x9d, 0x39, 0x31, 0xe4, 0x55, 0x5b, 0x1a, 0x75, 0x94,
	0x65, 0x48, 0x38, 0x5a, 0xa5, 0x4d, 0x68, 0x1b, 0x62, 0x4b, 0x0b, 0x55, 0x33, 0x8d, 0x56, 0x2e,
	0x03, 0x09, 0x4d, 0x8a, 0xce, 0xf6, 0x35, 0x3d, 0x72, 0xf1, 0xb9, 0x77, 0x67, 0x4a, 0xf8, 0x14,
	0xfb, 0x0c, 0xfb, 0x34, 0xbc, 0xe4, 0x25, 0xaf, 0xd0, 0x68, 0xbf, 0x05, 0xaf, 0xa6, 0x3b, 0xdb,
	0xc5, 0x05, 0x95, 0xa9, 0x7b, 0xd3, 0xba, 0xf7, 0x3c, 0xbf, 0xdf, 0xfd, 0x9e, 0xbf, 0x57, 0xe8,
	0xcb, 0x23, 0x36, 0x20, 0xcf, 0x49, 0x44, 0x93, 0x03, 0x81, 0xd3, 0x70, 0x90, 0x0a, 0x1e, 0x11,
	0x29, 0xb9, 0x90, 0xe3, 0x30, 0x63, 0xd3, 0x31, 0xe5, 0x7e, 0x2a, 0xb8, 0xe2, 0xc8, 0x8b, 0x78,
	0x34, 0x15, 0x1c, 0x47, 0x87, 0xbe, 0x3c, 0x62, 0x7e, 0x4c, 0xa5, 0x92, 0x47, 0x4c, 0x64, 0xc9,
	0xca, 0xb5, 0xa7, 0x3c, 0x94, 0x03, 0xfd, 0x23, 0x0d, 0xcd, 0xaf, 0x1c, 0xb1, 0xe2, 0x19, 0xef,
	0x34, 0x1c, 0x50, 0x7e, 0xeb, 0x80, 0x8b, 0x19, 0x56, 0xa5, 0xe5, 0x4b, 0x7d, 0xab, 0x3c, 0x62,
	0x21, 0x96, 0x64, 0x20, 0x95, 0xc8, 0x22, 0x95, 0x09, 0x12, 0x17, 0xd6, 0xf5, 0x4f, 0x69, 0xc2,
	0x92, 0x94, 0xf4, 0x99, 0xa2, 0x6c, 0x70, 0xc8, 0xa2, 0x81, 0xa2, 0x33, 0x22, 0x15, 0x9e, 0xa5,
	0x85, 0xe5, 0xea, 0x84, 0x4f, 0xb8, 0xf9, 0x1c, 0xe8, 0xaf, 0xfc, 0x74, 0xed, 0x5d, 0x03, 0x96,
	0x87, 0x38, 0x9a, 0x1e, 0x50, 0xc6, 0x88, 0xd8, 0x4f, 0x49, 0x84, 0xb6, 0xc1, 0x56, 0xf3, 0x94,
	0x78, 0x56, 0xcf, 0xea, 0x2f, 0x6f, 0xdc, 0xf2, 0x2f, 0x0a, 0xd1, 0x3f, 0x8f, 0xf3, 0x1f, 0xce,
	0x53, 0x32, 0xb4, 0x5f, 0xbe, 0x59, 0xad, 0x05, 0x86, 0x00, 0x0d, 0xa1, 0xa9, 0x70, 0xc8, 0x88,
	0x57, 0xef, 0x59, 0xfd, 0xce, 0xc6, 0x8d, 0x0f, 0x98, 0x8a, 0x50, 0xfd, 0x87, 0xda, 0x67, 0x8b,
	0xc8, 0x48, 0xd0, 0x54, 0x71, 0x51, 0x50, 0xe4, 0x50, 0x74, 0x0f, 0x9a, 0x32, 0xc5, 0x89, 0xf4,
	0x1a, 0xbd, 0x46, 0xbf, 0xb3, 0xf1, 0xed, 0xc5, 0x6a, 0x0c, 0x4d, 0x40, 0x70, 0xac, 0xe5, 0xe0,
	0xa4, 0xa4, 0x31, 0x68, 0xf4, 0x1d, 0x38, 0x71, 0x26, 0xb0, 0xa2, 0x3c, 0xf1, 0xec, 0x9e, 0xd5,
	0x6f, 0x0c, 0x3f, 0xd7, 0xe6, 0x77, 0x6f, 0x56, 0x97, 0x74, 0x9e, 0xfc, 0xad, 0xc2, 0x18, 0x9c,
	0xb9, 0xa1, 0xaf, 0x01, 0xa2, 0xc3, 0x2c, 0x99, 0x8e, 0x25, 0x7d, 0x41, 0xbc, 0xa6, 0x01, 0xe5,
	0x9c, 0x6d, 0x73, 0xbe, 0x4f, 0x5f, 0x10, 0xb4, 0x0b, 0x8b, 0x5c, 0x1d, 0x12, 0x31, 0x36, 0x6a,
	0xa5, 0xd7, 0x32, 0x2a, 0x2f, 0x17, 0x69, 0xc7, 0x30, 0x18, 0x9b, 0x44, 0x77, 0xc1, 0x11, 0x04,
	0xc7, 0xbf, 0xca, 0xdd, 0x03, 0x6f, 0xc1, 0xa4, 0xed, 0xab, 0x0a, 0x99, 0x2e, 0xae, 0x7f, 0xc8,
	0x22, 0xff, 0x61, 0x59, 0xdc, 0x82, 0xe3, 0x0c, 0xb4, 0x76, 0x13, 0x6c, 0x5d, 0x08, 0xd4, 0x81,
	0x85, 0x9d, 0xe4, 0x19, 0x66, 0x34, 0x76, 0x6b, 0x08, 0xa0, 0xb5, 0xc9, 0x59, 0x36, 0x4b, 0x5c,
	0x0b, 0xb5, 0xa1, 0xb9, 0x93, 0xc4, 0xe4, 0xb9, 0x5b, 0x5f, 0x3b, 0x86, 0xce, 0x88, 0x87, 0x7b,
	0x82, 0x4f, 0x04, 0x91, 0x12, 0x5d, 0x87, 0xd6, 0x53, 0x1e, 0x8e, 0x69, 0x6c, 0x4a, 0xdf, 0x18,
	0x2e, 0x69, 0xea, 0x93, 0x37, 0xab, 0xcd, 0x11, 0x0f, 0x77, 0xb6, 0x82, 0xe6, 0x53, 0x1e, 0xee,
	0xc4, 0xa8, 0x0f, 0x8b, 0x11, 0x4f, 0x94, 0xa0, 0x61, 0x66, 0xd2, 0xa9, 0x8b, 0x5b, 0x2f, 0x64,
	0x9c, 0xb3, 0x20, 0x0f, 0x6c, 0xc9, 0xb8, 0xf2, 0x1a, 0x3d, 0xab, 0xdf, 0x2c, 0x3b, 0x43, 0x9f,
	0xac, 0xbd, 0x5d, 0x00, 0xa4, 0x4b, 0xb5, 0x33, 0x4b, 0xb9, 0x50, 0x5b, 0x58, 0x61, 0xd3, 0x79,
	0xeb, 0xd0, 0x91, 0x78, 0x96, 0x32, 0x92, 0xe7, 0xbc, 0x5e, 0xc1, 0x41, 0x6e, 0x30, 0x49, 0xdf,
	0x06, 0x27, 0x2d, 0x34, 0x7b, 0x2d, 0x93, 0xa3, 0xf5, 0x8b, 0xdb, 0xa2, 0x12, 0x60, 0x99, 0xab,
	0x12, 0x8c, 0xb6, 0xa1, 0x91, 0x09, 0xea, 0x2d, 0x98, 0xa2, 0x7d, 0x7f, 0x31, 0xc7, 0xc7, 0x52,
	0xfd, 0x3f, 0x04, 0xbd, 0x97, 0x28, 0x31, 0x0f, 0x34, 0x03, 0xba, 0x03, 0xad, 0x7c, 0x96, 0x3d,
	0xc7, 0xe8, 0x59, 0xad, 0x70, 0x15, 0xf3, 0xee, 0xef, 0xec, 0xde, 0xa7, 0x8c, 0xdc, 0x37, 0x6e,
	0x85, 0x92, 0x02, 0x84, 0x1e, 0x41, 0xab, 0xe8, 0x9f, 0xb6, 0x91, 0x72, 0xfb, 0x52, 0x52, 0xf2,
	0xce, 0x31, 0x6a, 0x0c, 0xaf, 0x15, 0x14, 0x6c, 0xe8, 0x2e, 0x7c, 0x21, 0xa7, 0x34, 0x1d, 0xcf,
	0xa8, 0x94, 0x34, 0x99, 0x8c, 0x0f, 0xb8, 0x20, 0x74, 0x92, 0x8c, 0xa7, 0x64, 0x2e, 0x3d, 0xe8,
	0x59, 0x7d, 0xa7, 0x10, 0x72, 0x4d, 0xbb, 0xfd, 0x9e, 0x7b, 0xdd, 0xcf, 0x9d, 0x7e, 0x23, 0x73,
	0x89, 0x6e, 0xc2, 0xd2, 0x31, 0x66, 0x4c, 0x8f, 0xc8, 0x03, 0x9c, 0x70, 0xe9, 0x75, 0x2a, 0x63,
	0x70, 0xde, 0x84, 0x36, 0xe0, 0x8a, 0x30, 0xd3, 0xb7, 0x87, 0x05, 0x66, 0x8c, 0x30, 0x2a, 0x67,
	0xde, 0x52, 0xa5, 0x84, 0x1f, 0x9b, 0xd1, 0x13, 0x00, 0x41, 0x64, 0x36, 0x23, 0xe3, 0x94, 0x4b,
	0x6f, 0xd9, 0x04, 0xff, 0xd3, 0xa5, 0x82, 0x0f, 0x0c, 0x7c, 0x8f, 0xe7, 0xf1, 0x07, 0x6d, 0x51,
	0xfe, 0xbd, 0x92, 0x41, 0x27, 0xf7, 0x35, 0xf9, 0x41, 0xbf, 0x80, 0x1d, 0x13, 0x19, 0x99, 0xd6,
	0xbe, 0xdc, 0x84, 0x5a, 0x81, 0x41, 0xa2, 0xeb, 0x00, 0x0a, 0x8b, 0x09, 0x51, 0x9b, 0x9c, 0x49,
	0xaf, 0xde, 0x6b, 0xf4, 0xdb, 0x85, 0xbd, 0x72, 0xbe, 0x22, 0xa1, 0x53, 0x29, 0x08, 0x72, 0xa1,
	0x31, 0x25, 0x73, 0x73, 0x6b, 0x3b, 0xd0, 0x9f, 0xe8, 0x01, 0x34, 0x9f, 0x61, 0x96, 0x95, 0x5b,
	0xf1, 0x72, 0xb5, 0xae, 0x44, 0x14, 0xe4, 0x34, 0x3f, 0xd6, 0x6f, 0x5b, 0x2b, 0x3f, 0x80, 0x53,
	0x36, 0x64, 0xf5, 0xc6, 0x66, 0x7e, 0xe3, 0xd5, 0xea, 0x8d, 0xed, 0x2a, 0xee, 0x67, 0x58, 0x3e,
	0x9f, 0xc0, 0xff, 0x42, 0x37, 0x2a, 0xe8, 0x91, 0xed, 0x58, 0x6e, 0x7d, 0x64, 0x3b, 0x0d, 0xd7,
	0x1e, 0xd9, 0x8e, 0xed, 0x36, 0x47, 0xb6, 0xd3, 0x74, 0x5b, 0x23, 0xdb, 0x59, 0x74, 0x97, 0xd6,
	0xfe, 0xae, 0xc3, 0xd2, 0xe6, 0xfe, 0xa3, 0xc7, 0x82, 0xaa, 0xe2, 0x61, 0xb9, 0x01, 0x9d, 0x98,
	0x48, 0x45, 0x93, 0x7c, 0x0f, 0x9b, 0x9c, 0x94, 0x3b, 0xb0, 0x62, 0x40, 0xdf, 0xc0, 0x62, 0x82,
	0x75, 0x4f, 0x60, 0xa5, 0x88, 0xc8, 0x37, 0xcc, 0x99, 0xa3, 0xb6, 0xec, 0xe5, 0x06, 0x74, 0x07,
	0x16, 0x78, 0xaa, 0x21, 0xd2, 0xec, 0x98, 0xf3, 0xbb, 0xb2, 0x9c, 0xbb, 0xcd, 0xfd, 0x47, 0xbb,
	0xb9, 0x53, 0x41, 0x51, 0x62, 0xde, 0x6f, 0x78, 0xc1, 0x8f, 0x65, 0xf1, 0x2c, 0x54, 0x37, 0x7c,
	0xc0, 0x8f, 0x25, 0xfa, 0x13, 0xae, 0x44, 0x7c, 0x96, 0xea, 0x7d, 0x41, 0x79, 0x32, 0x8e, 0x78,
	0x4c, 0x22, 0xf3, 0x1a, 0x2c, 0x7f, 0xea, 0x31, 0xd2, 0xa3, 0xbe, 0xf9, 0x1e, 0x56, 0xd0, 0xba,
	0x15, 0xa6, 0x4d, 0x4d, 0xb4, 0xf6, 0x18, 0xae, 0x0c, 0x33, 0xa6, 0x6f, 0xaa, 0xe4, 0xe9, 0xec,
	0xdd, 0xb4, 0xfe, 0xf7, 0xbb, 0x79, 0x73, 0x1d, 0x3e, 0xfb, 0x40, 0x03, 0x72, 0xc0, 0x7e, 0xc0,
	0x13, 0xe2, 0xd6, 0xf4, 0xd7, 0xf6, 0x0b, 0x9a, 0xba, 0xd6, 0xf0, 0xd6, 0xcb, 0xb7, 0xdd, 0xda,
	0xcb, 0x93, 0xae, 0xf5, 0xea, 0xa4, 0x6b, 0xbd, 0x3e, 0xe9, 0x5a, 0xff, 0x9c, 0x74, 0xad, 0xbf,
	0x4e, 0xbb, 0xb5, 0x57, 0xa7, 0xdd, 0xda, 0xeb, 0xd3, 0x6e, 0xed, 0x49, 0xa7, 0xf2, 0x3f, 0xc7,
	0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x63, 0xb9, 0x6a, 0x6d, 0x19, 0x09, 0x00, 0x00,
}
