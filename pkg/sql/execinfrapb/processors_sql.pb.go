// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_sql.proto

package execinfrapb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"

import github_com_cockroachdb_cockroach_pkg_sql_types "github.com/cockroachdb/cockroach/pkg/sql/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ScanVisibility controls which columns are seen by scans - just normal
// columns, or normal columns and also in-progress schema change columns.
type ScanVisibility int32

const (
	ScanVisibility_PUBLIC                ScanVisibility = 0
	ScanVisibility_PUBLIC_AND_NOT_PUBLIC ScanVisibility = 1
)

var ScanVisibility_name = map[int32]string{
	0: "PUBLIC",
	1: "PUBLIC_AND_NOT_PUBLIC",
}
var ScanVisibility_value = map[string]int32{
	"PUBLIC":                0,
	"PUBLIC_AND_NOT_PUBLIC": 1,
}

func (x ScanVisibility) Enum() *ScanVisibility {
	p := new(ScanVisibility)
	*p = x
	return p
}
func (x ScanVisibility) String() string {
	return proto.EnumName(ScanVisibility_name, int32(x))
}
func (x *ScanVisibility) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScanVisibility_value, data, "ScanVisibility")
	if err != nil {
		return err
	}
	*x = ScanVisibility(value)
	return nil
}
func (ScanVisibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{0}
}

// These mirror the aggregate functions supported by sql/parser. See
// sql/parser/aggregate_builtins.go.
type AggregatorSpec_Func int32

const (
	AggregatorSpec_ANY_NOT_NULL   AggregatorSpec_Func = 0
	AggregatorSpec_AVG            AggregatorSpec_Func = 1
	AggregatorSpec_BOOL_AND       AggregatorSpec_Func = 2
	AggregatorSpec_BOOL_OR        AggregatorSpec_Func = 3
	AggregatorSpec_CONCAT_AGG     AggregatorSpec_Func = 4
	AggregatorSpec_COUNT          AggregatorSpec_Func = 5
	AggregatorSpec_MAX            AggregatorSpec_Func = 7
	AggregatorSpec_MIN            AggregatorSpec_Func = 8
	AggregatorSpec_STDDEV         AggregatorSpec_Func = 9
	AggregatorSpec_SUM            AggregatorSpec_Func = 10
	AggregatorSpec_SUM_INT        AggregatorSpec_Func = 11
	AggregatorSpec_VARIANCE       AggregatorSpec_Func = 12
	AggregatorSpec_XOR_AGG        AggregatorSpec_Func = 13
	AggregatorSpec_COUNT_ROWS     AggregatorSpec_Func = 14
	AggregatorSpec_SQRDIFF        AggregatorSpec_Func = 15
	AggregatorSpec_FINAL_VARIANCE AggregatorSpec_Func = 16
	AggregatorSpec_FINAL_STDDEV   AggregatorSpec_Func = 17
	AggregatorSpec_ARRAY_AGG      AggregatorSpec_Func = 18
	AggregatorSpec_JSON_AGG       AggregatorSpec_Func = 19
	// JSONB_AGG is an alias for JSON_AGG, they do the same thing.
	AggregatorSpec_JSONB_AGG  AggregatorSpec_Func = 20
	AggregatorSpec_STRING_AGG AggregatorSpec_Func = 21
	AggregatorSpec_BIT_AND    AggregatorSpec_Func = 22
	AggregatorSpec_BIT_OR     AggregatorSpec_Func = 23
)

var AggregatorSpec_Func_name = map[int32]string{
	0:  "ANY_NOT_NULL",
	1:  "AVG",
	2:  "BOOL_AND",
	3:  "BOOL_OR",
	4:  "CONCAT_AGG",
	5:  "COUNT",
	7:  "MAX",
	8:  "MIN",
	9:  "STDDEV",
	10: "SUM",
	11: "SUM_INT",
	12: "VARIANCE",
	13: "XOR_AGG",
	14: "COUNT_ROWS",
	15: "SQRDIFF",
	16: "FINAL_VARIANCE",
	17: "FINAL_STDDEV",
	18: "ARRAY_AGG",
	19: "JSON_AGG",
	20: "JSONB_AGG",
	21: "STRING_AGG",
	22: "BIT_AND",
	23: "BIT_OR",
}
var AggregatorSpec_Func_value = map[string]int32{
	"ANY_NOT_NULL":   0,
	"AVG":            1,
	"BOOL_AND":       2,
	"BOOL_OR":        3,
	"CONCAT_AGG":     4,
	"COUNT":          5,
	"MAX":            7,
	"MIN":            8,
	"STDDEV":         9,
	"SUM":            10,
	"SUM_INT":        11,
	"VARIANCE":       12,
	"XOR_AGG":        13,
	"COUNT_ROWS":     14,
	"SQRDIFF":        15,
	"FINAL_VARIANCE": 16,
	"FINAL_STDDEV":   17,
	"ARRAY_AGG":      18,
	"JSON_AGG":       19,
	"JSONB_AGG":      20,
	"STRING_AGG":     21,
	"BIT_AND":        22,
	"BIT_OR":         23,
}

func (x AggregatorSpec_Func) Enum() *AggregatorSpec_Func {
	p := new(AggregatorSpec_Func)
	*p = x
	return p
}
func (x AggregatorSpec_Func) String() string {
	return proto.EnumName(AggregatorSpec_Func_name, int32(x))
}
func (x *AggregatorSpec_Func) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Func_value, data, "AggregatorSpec_Func")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Func(value)
	return nil
}
func (AggregatorSpec_Func) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{10, 0}
}

type AggregatorSpec_Type int32

const (
	// This setting exists just for backwards compatibility; it's equivalent to
	// SCALAR when there are no grouping columns, and to NON_SCALAR when there
	// are grouping columns.
	AggregatorSpec_AUTO AggregatorSpec_Type = 0
	// A scalar aggregation has no grouping columns and always returns one
	// result row.
	AggregatorSpec_SCALAR AggregatorSpec_Type = 1
	// A non-scalar aggregation returns no rows if there are no input rows; it
	// may or may not have grouping columns.
	AggregatorSpec_NON_SCALAR AggregatorSpec_Type = 2
)

var AggregatorSpec_Type_name = map[int32]string{
	0: "AUTO",
	1: "SCALAR",
	2: "NON_SCALAR",
}
var AggregatorSpec_Type_value = map[string]int32{
	"AUTO":       0,
	"SCALAR":     1,
	"NON_SCALAR": 2,
}

func (x AggregatorSpec_Type) Enum() *AggregatorSpec_Type {
	p := new(AggregatorSpec_Type)
	*p = x
	return p
}
func (x AggregatorSpec_Type) String() string {
	return proto.EnumName(AggregatorSpec_Type_name, int32(x))
}
func (x *AggregatorSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Type_value, data, "AggregatorSpec_Type")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Type(value)
	return nil
}
func (AggregatorSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{10, 1}
}

type WindowerSpec_WindowFunc int32

const (
	// These mirror window functions from window_builtins.go.
	WindowerSpec_ROW_NUMBER   WindowerSpec_WindowFunc = 0
	WindowerSpec_RANK         WindowerSpec_WindowFunc = 1
	WindowerSpec_DENSE_RANK   WindowerSpec_WindowFunc = 2
	WindowerSpec_PERCENT_RANK WindowerSpec_WindowFunc = 3
	WindowerSpec_CUME_DIST    WindowerSpec_WindowFunc = 4
	WindowerSpec_NTILE        WindowerSpec_WindowFunc = 5
	WindowerSpec_LAG          WindowerSpec_WindowFunc = 6
	WindowerSpec_LEAD         WindowerSpec_WindowFunc = 7
	WindowerSpec_FIRST_VALUE  WindowerSpec_WindowFunc = 8
	WindowerSpec_LAST_VALUE   WindowerSpec_WindowFunc = 9
	WindowerSpec_NTH_VALUE    WindowerSpec_WindowFunc = 10
)

var WindowerSpec_WindowFunc_name = map[int32]string{
	0:  "ROW_NUMBER",
	1:  "RANK",
	2:  "DENSE_RANK",
	3:  "PERCENT_RANK",
	4:  "CUME_DIST",
	5:  "NTILE",
	6:  "LAG",
	7:  "LEAD",
	8:  "FIRST_VALUE",
	9:  "LAST_VALUE",
	10: "NTH_VALUE",
}
var WindowerSpec_WindowFunc_value = map[string]int32{
	"ROW_NUMBER":   0,
	"RANK":         1,
	"DENSE_RANK":   2,
	"PERCENT_RANK": 3,
	"CUME_DIST":    4,
	"NTILE":        5,
	"LAG":          6,
	"LEAD":         7,
	"FIRST_VALUE":  8,
	"LAST_VALUE":   9,
	"NTH_VALUE":    10,
}

func (x WindowerSpec_WindowFunc) Enum() *WindowerSpec_WindowFunc {
	p := new(WindowerSpec_WindowFunc)
	*p = x
	return p
}
func (x WindowerSpec_WindowFunc) String() string {
	return proto.EnumName(WindowerSpec_WindowFunc_name, int32(x))
}
func (x *WindowerSpec_WindowFunc) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_WindowFunc_value, data, "WindowerSpec_WindowFunc")
	if err != nil {
		return err
	}
	*x = WindowerSpec_WindowFunc(value)
	return nil
}
func (WindowerSpec_WindowFunc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 0}
}

// Mode indicates which mode of framing is used.
type WindowerSpec_Frame_Mode int32

const (
	// RANGE specifies frame in terms of logical range (e.g. 1 unit cheaper).
	WindowerSpec_Frame_RANGE WindowerSpec_Frame_Mode = 0
	// ROWS specifies frame in terms of physical offsets (e.g. 1 row before).
	WindowerSpec_Frame_ROWS WindowerSpec_Frame_Mode = 1
	// GROUPS specifies frame in terms of peer groups (where "peers" mean
	// rows not distinct in the ordering columns).
	WindowerSpec_Frame_GROUPS WindowerSpec_Frame_Mode = 2
)

var WindowerSpec_Frame_Mode_name = map[int32]string{
	0: "RANGE",
	1: "ROWS",
	2: "GROUPS",
}
var WindowerSpec_Frame_Mode_value = map[string]int32{
	"RANGE":  0,
	"ROWS":   1,
	"GROUPS": 2,
}

func (x WindowerSpec_Frame_Mode) Enum() *WindowerSpec_Frame_Mode {
	p := new(WindowerSpec_Frame_Mode)
	*p = x
	return p
}
func (x WindowerSpec_Frame_Mode) String() string {
	return proto.EnumName(WindowerSpec_Frame_Mode_name, int32(x))
}
func (x *WindowerSpec_Frame_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Mode_value, data, "WindowerSpec_Frame_Mode")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Mode(value)
	return nil
}
func (WindowerSpec_Frame_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1, 0}
}

// BoundType indicates which type of boundary is used.
type WindowerSpec_Frame_BoundType int32

const (
	WindowerSpec_Frame_UNBOUNDED_PRECEDING WindowerSpec_Frame_BoundType = 0
	WindowerSpec_Frame_UNBOUNDED_FOLLOWING WindowerSpec_Frame_BoundType = 1
	// Offsets are stored within Bound.
	WindowerSpec_Frame_OFFSET_PRECEDING WindowerSpec_Frame_BoundType = 2
	WindowerSpec_Frame_OFFSET_FOLLOWING WindowerSpec_Frame_BoundType = 3
	WindowerSpec_Frame_CURRENT_ROW      WindowerSpec_Frame_BoundType = 4
)

var WindowerSpec_Frame_BoundType_name = map[int32]string{
	0: "UNBOUNDED_PRECEDING",
	1: "UNBOUNDED_FOLLOWING",
	2: "OFFSET_PRECEDING",
	3: "OFFSET_FOLLOWING",
	4: "CURRENT_ROW",
}
var WindowerSpec_Frame_BoundType_value = map[string]int32{
	"UNBOUNDED_PRECEDING": 0,
	"UNBOUNDED_FOLLOWING": 1,
	"OFFSET_PRECEDING":    2,
	"OFFSET_FOLLOWING":    3,
	"CURRENT_ROW":         4,
}

func (x WindowerSpec_Frame_BoundType) Enum() *WindowerSpec_Frame_BoundType {
	p := new(WindowerSpec_Frame_BoundType)
	*p = x
	return p
}
func (x WindowerSpec_Frame_BoundType) String() string {
	return proto.EnumName(WindowerSpec_Frame_BoundType_name, int32(x))
}
func (x *WindowerSpec_Frame_BoundType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_BoundType_value, data, "WindowerSpec_Frame_BoundType")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_BoundType(value)
	return nil
}
func (WindowerSpec_Frame_BoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1, 1}
}

// Exclusion specifies the type of frame exclusion.
type WindowerSpec_Frame_Exclusion int32

const (
	WindowerSpec_Frame_NO_EXCLUSION        WindowerSpec_Frame_Exclusion = 0
	WindowerSpec_Frame_EXCLUDE_CURRENT_ROW WindowerSpec_Frame_Exclusion = 1
	WindowerSpec_Frame_EXCLUDE_GROUP       WindowerSpec_Frame_Exclusion = 2
	WindowerSpec_Frame_EXCLUDE_TIES        WindowerSpec_Frame_Exclusion = 3
)

var WindowerSpec_Frame_Exclusion_name = map[int32]string{
	0: "NO_EXCLUSION",
	1: "EXCLUDE_CURRENT_ROW",
	2: "EXCLUDE_GROUP",
	3: "EXCLUDE_TIES",
}
var WindowerSpec_Frame_Exclusion_value = map[string]int32{
	"NO_EXCLUSION":        0,
	"EXCLUDE_CURRENT_ROW": 1,
	"EXCLUDE_GROUP":       2,
	"EXCLUDE_TIES":        3,
}

func (x WindowerSpec_Frame_Exclusion) Enum() *WindowerSpec_Frame_Exclusion {
	p := new(WindowerSpec_Frame_Exclusion)
	*p = x
	return p
}
func (x WindowerSpec_Frame_Exclusion) String() string {
	return proto.EnumName(WindowerSpec_Frame_Exclusion_name, int32(x))
}
func (x *WindowerSpec_Frame_Exclusion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Exclusion_value, data, "WindowerSpec_Frame_Exclusion")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Exclusion(value)
	return nil
}
func (WindowerSpec_Frame_Exclusion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1, 2}
}

// ValuesCoreSpec is the core of a processor that has no inputs and generates
// "pre-canned" rows. This is not intended to be used for very large datasets.
type ValuesCoreSpec struct {
	// There is one DatumInfo for each element in a row. Can be empty, in which
	// case raw_bytes must be empty.
	Columns []DatumInfo `protobuf:"bytes,1,rep,name=columns" json:"columns"`
	// The number of rows is especially useful when we have zero columns.
	NumRows uint64 `protobuf:"varint,3,opt,name=num_rows,json=numRows" json:"num_rows"`
	// Each raw block encodes one or more data rows; each datum is encoded
	// according to the corresponding DatumInfo.
	RawBytes [][]byte `protobuf:"bytes,2,rep,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
}

func (m *ValuesCoreSpec) Reset()         { *m = ValuesCoreSpec{} }
func (m *ValuesCoreSpec) String() string { return proto.CompactTextString(m) }
func (*ValuesCoreSpec) ProtoMessage()    {}
func (*ValuesCoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{0}
}
func (m *ValuesCoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValuesCoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ValuesCoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValuesCoreSpec.Merge(dst, src)
}
func (m *ValuesCoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *ValuesCoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ValuesCoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ValuesCoreSpec proto.InternalMessageInfo

// TableReaderSpec is the specification for a "table reader". A table reader
// performs KV operations to retrieve rows for a table and outputs the desired
// columns of the rows that pass a filter expression.
//
// The "internal columns" of a TableReader (see ProcessorSpec) are all the
// columns of the table. Internally, only the values for the columns needed by
// the post-processing stage are to be populated. If is_check is set, the
// TableReader will run additional data checking procedures and the
// "internal columns" are:
//  - Error type (string).
//  - Primary key as a string, if it was obtainable.
//  - JSON of all decoded column values.
type TableReaderSpec struct {
	Table sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Reverse  bool              `protobuf:"varint,3,opt,name=reverse" json:"reverse"`
	Spans    []TableReaderSpan `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	// A hint for how many rows the consumer of the table reader output might
	// need. This is used to size the initial KV batches to try to avoid reading
	// many more rows than needed by the processor receiving the output.
	//
	// Not used if there is a limit set in the PostProcessSpec of this processor
	// (that value will be used for sizing batches instead).
	LimitHint int64 `protobuf:"varint,5,opt,name=limit_hint,json=limitHint" json:"limit_hint"`
	// Indicates whether the TableReader is being run as an exhaustive
	// check. This is only true during SCRUB commands.
	IsCheck bool `protobuf:"varint,6,opt,name=is_check,json=isCheck" json:"is_check"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to public. Will be set to publicAndNotPublic if the
	// consumer of this TableReader expects to be able to see in-progress schema
	// changes.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	// If non-zero, this is a guarantee for the upper bound of rows a TableReader
	// will read. If 0, the number of results is unbounded.
	MaxResults uint64 `protobuf:"varint,8,opt,name=max_results,json=maxResults" json:"max_results"`
	// If non-zero, this enables inconsistent historical scanning where different
	// batches can be read with different timestamps. This is used for
	// long-running table statistics which may outlive the TTL. Using this setting
	// will cause inconsistencies across rows and even within rows.
	//
	// The value is a duration (in nanoseconds), which is the maximum "age" of the
	// timestamp. If the scan takes long enough for the timestamp to become older,
	// the timestamp is advanced by however much time passed.
	//
	// Example:
	//
	//     current time:      10
	//     initial timestamp: 0
	//     max timestamp age: 30
	//
	//     time
	//     10:    start scan, timestamp=0
	//     10-29: continue scanning at timestamp=0
	//     30:    bump timestamp to 20
	//     30-49: continue scanning at timestamp=20
	//     50:    bump timestamp to 40
	//     ...
	//
	// Note: it is an error to perform a historical read at an initial timestamp
	// older than this value.
	//
	MaxTimestampAgeNanos uint64 `protobuf:"varint,9,opt,name=max_timestamp_age_nanos,json=maxTimestampAgeNanos" json:"max_timestamp_age_nanos"`
}

func (m *TableReaderSpec) Reset()         { *m = TableReaderSpec{} }
func (m *TableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*TableReaderSpec) ProtoMessage()    {}
func (*TableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{1}
}
func (m *TableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReaderSpec.Merge(dst, src)
}
func (m *TableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *TableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TableReaderSpec proto.InternalMessageInfo

// IndexSkipTableReaderSpec is the specification for a table reader that
// is performing a loose index scan over rows in the table. This means that
// this reader will return distinct rows from the table while using the index
// to skip unnecessary rows. This reader is used for different optimizations
// when operating on a prefix of a compound key.
type IndexSkipTableReaderSpec struct {
	Table sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Spans    []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to public. Will be set to publicAndNotPublic if the
	// consumer of this TableReader expects to be able to see in-progress schema
	// changes.
	Visibility ScanVisibility `protobuf:"varint,4,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	Reverse    bool           `protobuf:"varint,5,opt,name=reverse" json:"reverse"`
}

func (m *IndexSkipTableReaderSpec) Reset()         { *m = IndexSkipTableReaderSpec{} }
func (m *IndexSkipTableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*IndexSkipTableReaderSpec) ProtoMessage()    {}
func (*IndexSkipTableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{2}
}
func (m *IndexSkipTableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexSkipTableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IndexSkipTableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexSkipTableReaderSpec.Merge(dst, src)
}
func (m *IndexSkipTableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexSkipTableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexSkipTableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexSkipTableReaderSpec proto.InternalMessageInfo

// JoinReaderSpec is the specification for a "join reader". A join reader
// performs KV operations to retrieve specific rows that correspond to the
// values in the input stream (join by lookup). The output always preserves the
// order of the input rows.
//
// The "internal columns" of a JoinReader (see ProcessorSpec) are either:
//  - the columns of the table, if we are performing an index join (no lookup
//    columns) or if we are performing a semi or anti join, or
//  - the concatenation of the columns of the input stream with the table
//    columns.
//
// Internally, only the values for the columns needed by the post-processing
// stage are populated.
//
// Example:
// Input stream columns: | a | b |              Table columns: | c | d | e |
//
// If performing a lookup join on a = c (lookup columns is [0]):
//        Internal columns: | a | b | c | d | e |
//
// If performing an index join (where a = c and b = d) (lookup columns is []):
//        Internal columns: | c | d | e |
type JoinReaderSpec struct {
	Table sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index; each row in the input stream has a value
	// for each primary key. The index must provide all lookup columns.
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// Column indexes in the input stream specifying the columns which match with
	// the index columns. These are the equality columns of the join.
	//
	// If empty (index join), the start of the input stream schema is assumed to
	// match the index columns. The joinReader will perform an index join and the
	// "internal columns" will be the columns of the table.
	//
	// If populated (lookup join), the `joinReader` will perform a lookup join
	// and the "internal columns" will be the concatenation of the input stream
	// columns followed by the table columns (except for semi/anti join, which
	// don't output any table columns).
	LookupColumns []uint32 `protobuf:"varint,3,rep,packed,name=lookup_columns,json=lookupColumns" json:"lookup_columns,omitempty"`
	// If set, the lookup columns form a key in the target table and thus each
	// lookup has at most one result.
	LookupColumnsAreKey bool `protobuf:"varint,8,opt,name=lookup_columns_are_key,json=lookupColumnsAreKey" json:"lookup_columns_are_key"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @N to @(N+M) refer to columns in
	// the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// For lookup joins. Only JoinType_INNER and JoinType_LEFT_OUTER are
	// supported.
	Type sqlbase.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// For index joins that are sources to mutation statements - what visibility
	// of columns should we return? Mutations sometimes need to see in-progress
	// schema change columns, in which case this field will be changed from its
	// default PUBLIC state. Causes the index join to return these schema change
	// columns.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
}

func (m *JoinReaderSpec) Reset()         { *m = JoinReaderSpec{} }
func (m *JoinReaderSpec) String() string { return proto.CompactTextString(m) }
func (*JoinReaderSpec) ProtoMessage()    {}
func (*JoinReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{3}
}
func (m *JoinReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JoinReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinReaderSpec.Merge(dst, src)
}
func (m *JoinReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *JoinReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JoinReaderSpec proto.InternalMessageInfo

// SorterSpec is the specification for a "sorting aggregator". A sorting
// processor sorts elements in the input stream providing a certain output
// order guarantee regardless of the input ordering. The output ordering is
// according to a configurable set of columns.
//
// The "internal columns" of a Sorter (see ProcessorSpec) are the same as the
// input columns.
type SorterSpec struct {
	OutputOrdering Ordering `protobuf:"bytes,1,opt,name=output_ordering,json=outputOrdering" json:"output_ordering"`
	// Ordering match length, specifying that the input is already sorted by the
	// first 'n' output ordering columns, can be optionally specified for
	// possible speed-ups taking advantage of the partial orderings.
	OrderingMatchLen uint32 `protobuf:"varint,2,opt,name=ordering_match_len,json=orderingMatchLen" json:"ordering_match_len"`
}

func (m *SorterSpec) Reset()         { *m = SorterSpec{} }
func (m *SorterSpec) String() string { return proto.CompactTextString(m) }
func (*SorterSpec) ProtoMessage()    {}
func (*SorterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{4}
}
func (m *SorterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SorterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SorterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SorterSpec.Merge(dst, src)
}
func (m *SorterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SorterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SorterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SorterSpec proto.InternalMessageInfo

type DistinctSpec struct {
	// The ordered columns in the input stream can be optionally specified for
	// possible optimizations. The specific ordering (ascending/descending) of
	// the column itself is not important nor is the order in which the columns
	// are specified. The ordered columns must be a subset of the distinct
	// columns.
	OrderedColumns []uint32 `protobuf:"varint,1,rep,name=ordered_columns,json=orderedColumns" json:"ordered_columns,omitempty"`
	// The distinct columns in the input stream are those columns on which we
	// check for distinct rows. If A,B,C are in distinct_columns and there is a
	// 4th column D which is not included in distinct_columns, its values are not
	// considered, so rows A1,B1,C1,D1 and A1,B1,C1,D2 are considered equal and
	// only one of them (the first) is output.
	DistinctColumns []uint32 `protobuf:"varint,2,rep,name=distinct_columns,json=distinctColumns" json:"distinct_columns,omitempty"`
}

func (m *DistinctSpec) Reset()         { *m = DistinctSpec{} }
func (m *DistinctSpec) String() string { return proto.CompactTextString(m) }
func (*DistinctSpec) ProtoMessage()    {}
func (*DistinctSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{5}
}
func (m *DistinctSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistinctSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DistinctSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistinctSpec.Merge(dst, src)
}
func (m *DistinctSpec) XXX_Size() int {
	return m.Size()
}
func (m *DistinctSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DistinctSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DistinctSpec proto.InternalMessageInfo

// The specification for a WITH ORDINALITY processor. It adds a new column to
// each resulting row that contains the ordinal number of the row. Since there
// are no arguments for this operator, the spec is empty.
type OrdinalitySpec struct {
}

func (m *OrdinalitySpec) Reset()         { *m = OrdinalitySpec{} }
func (m *OrdinalitySpec) String() string { return proto.CompactTextString(m) }
func (*OrdinalitySpec) ProtoMessage()    {}
func (*OrdinalitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{6}
}
func (m *OrdinalitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdinalitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OrdinalitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdinalitySpec.Merge(dst, src)
}
func (m *OrdinalitySpec) XXX_Size() int {
	return m.Size()
}
func (m *OrdinalitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdinalitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrdinalitySpec proto.InternalMessageInfo

// ZigzagJoinerSpec is the specification for a zigzag join processor. The
// processor's current implementation fetches the rows using internal
// rowFetchers.
//
// The "internal columns" of a ZigzagJoiner (see ProcessorSpec) are the
// concatenation of all of the columns of the tables specified. The columns
// are populated if they are contained in the index specified for that table.
type ZigzagJoinerSpec struct {
	// TODO(pbardea): Replace these with inputs that conform to a RowSource-like
	// interface.
	Tables []sqlbase.TableDescriptor `protobuf:"bytes,1,rep,name=tables" json:"tables"`
	// An array of arrays. The array at eq_columns[side_idx] contains the
	// equality columns for that side. All arrays in eq_columns should have
	// equal length.
	EqColumns []Columns `protobuf:"bytes,2,rep,name=eq_columns,json=eqColumns" json:"eq_columns"`
	IndexIds  []uint32  `protobuf:"varint,3,rep,packed,name=index_ids,json=indexIds" json:"index_ids,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// Fixed values at the start of indices.
	FixedValues []*ValuesCoreSpec `protobuf:"bytes,5,rep,name=fixed_values,json=fixedValues" json:"fixed_values,omitempty"`
	Type        sqlbase.JoinType  `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
}

func (m *ZigzagJoinerSpec) Reset()         { *m = ZigzagJoinerSpec{} }
func (m *ZigzagJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*ZigzagJoinerSpec) ProtoMessage()    {}
func (*ZigzagJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{7}
}
func (m *ZigzagJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZigzagJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ZigzagJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZigzagJoinerSpec.Merge(dst, src)
}
func (m *ZigzagJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ZigzagJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ZigzagJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ZigzagJoinerSpec proto.InternalMessageInfo

// MergeJoinerSpec is the specification for a merge join processor. The processor
// has two inputs and one output. The inputs must have the same ordering on the
// columns that have equality constraints. For example:
//   SELECT * FROM T1 INNER JOIN T2 ON T1.C1 = T2.C5 AND T1.C2 = T2.C4
//
// To perform a merge join, the streams corresponding to T1 and T2 must have the
// same ordering on columns C1, C2 and C5, C4 respectively. For example: C1+,C2-
// and C5+,C4-.
//
// The "internal columns" of a MergeJoiner (see ProcessorSpec) are the
// concatenation of left input columns and right input columns. If the left
// input has N columns and the right input has M columns, the first N columns
// contain values from the left side and the following M columns contain values
// from the right side.
//
// In the case of semi-join and anti-join, the processor core outputs only the
// left columns.
type MergeJoinerSpec struct {
	// The streams must be ordered according to the columns that have equality
	// constraints. The first column of the left ordering is constrained to be
	// equal to the first column in the right ordering and so on. The ordering
	// lengths and directions must match.
	// In the example above, left ordering describes C1+,C2- and right ordering
	// describes C5+,C4-.
	LeftOrdering  Ordering `protobuf:"bytes,1,opt,name=left_ordering,json=leftOrdering" json:"left_ordering"`
	RightOrdering Ordering `protobuf:"bytes,2,opt,name=right_ordering,json=rightOrdering" json:"right_ordering"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression       `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   sqlbase.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// NullEquality indicates that NULL = NULL should be considered true.
	// This allows OUTER JOINs to consider NULL values meaningfully. An
	// example of this is during SCRUB checks on secondary indexes.
	NullEquality bool `protobuf:"varint,7,opt,name=null_equality,json=nullEquality" json:"null_equality"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
}

func (m *MergeJoinerSpec) Reset()         { *m = MergeJoinerSpec{} }
func (m *MergeJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*MergeJoinerSpec) ProtoMessage()    {}
func (*MergeJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{8}
}
func (m *MergeJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MergeJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeJoinerSpec.Merge(dst, src)
}
func (m *MergeJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *MergeJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MergeJoinerSpec proto.InternalMessageInfo

// HashJoinerSpec is the specification for a hash join processor. The processor
// has two inputs and one output.
//
// The processor works by reading the entire right input and putting it in a hash
// table. Thus, there is no guarantee on the ordering of results that stem only
// from the right input (in the case of RIGHT_OUTER, FULL_OUTER). However, it is
// guaranteed that results that involve the left stream preserve the ordering;
// i.e. all results that stem from left row (i) precede results that stem from
// left row (i+1).
//
// The "internal columns" of a HashJoiner (see ProcessorSpec) are the
// concatenation of merged columns (if present), left input columns and right
// input columns. Each merged column corresponds to a left and a right equality
// column; its value is the value on the left if it is not NULL, otherwise it is
// the value on the right. There are either zero or
// E=len(left_eq_columns)=len(right_eq_columns) merged columns.
//
// If the left input has N columns and the right input has M columns, the
// first N columns contain values from the left side and the following M columns
// contain values from the right side. If merged columns are present, they
// occupy first E positions followed by N values from the left side and M values
// from the right side.
//
// In the case of semi-join and anti-join, the processor core outputs only the
// left columns.
type HashJoinerSpec struct {
	// The join constraints certain columns from the left stream to equal
	// corresponding columns on the right stream. These must have the same length.
	LeftEqColumns  []uint32 `protobuf:"varint,1,rep,packed,name=left_eq_columns,json=leftEqColumns" json:"left_eq_columns,omitempty"`
	RightEqColumns []uint32 `protobuf:"varint,2,rep,packed,name=right_eq_columns,json=rightEqColumns" json:"right_eq_columns,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @N to @(N+M) refer to columns in
	// the right stream.
	// Having "ON" expression implies no merged columns.
	OnExpr Expression       `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   sqlbase.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
	// DEPRECATED
	//
	// Extra merged columns that are added in case of OUTER JOINS. These
	// columns occupy first positions in a row amd it's the left value if it's not
	// NULL, otherwise it's the right value. In INNER JOIN case no merged columns are
	// needed since left stream values are guaranteed to be not NULL.
	//
	// This has been deprecated; the distsqlrun layer still supports it for
	// backward compatibility during upgrade.
	MergedColumns bool `protobuf:"varint,7,opt,name=merged_columns,json=mergedColumns" json:"merged_columns"`
}

func (m *HashJoinerSpec) Reset()         { *m = HashJoinerSpec{} }
func (m *HashJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*HashJoinerSpec) ProtoMessage()    {}
func (*HashJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{9}
}
func (m *HashJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HashJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashJoinerSpec.Merge(dst, src)
}
func (m *HashJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *HashJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HashJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HashJoinerSpec proto.InternalMessageInfo

// AggregatorSpec is the specification for an "aggregator" (processor core
// type, not the logical plan computation stage). An aggregator performs
// 'aggregation' in the SQL sense in that it groups rows and computes an aggregate
// for each group. The group is configured using the group key. The aggregator
// can be configured with one or more aggregation functions.
//
// The "internal columns" of an Aggregator map 1-1 to the aggregations.
type AggregatorSpec struct {
	Type AggregatorSpec_Type `protobuf:"varint,5,opt,name=type,enum=cockroach.sql.distsqlrun.AggregatorSpec_Type" json:"type"`
	// The group key is a subset of the columns in the input stream schema on the
	// basis of which we define our groups.
	GroupCols    []uint32                     `protobuf:"varint,2,rep,packed,name=group_cols,json=groupCols" json:"group_cols,omitempty"`
	Aggregations []AggregatorSpec_Aggregation `protobuf:"bytes,3,rep,name=aggregations" json:"aggregations"`
	// A subset of the GROUP BY columns which are ordered in the input.
	OrderedGroupCols []uint32 `protobuf:"varint,4,rep,packed,name=ordered_group_cols,json=orderedGroupCols" json:"ordered_group_cols,omitempty"`
}

func (m *AggregatorSpec) Reset()         { *m = AggregatorSpec{} }
func (m *AggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec) ProtoMessage()    {}
func (*AggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{10}
}
func (m *AggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec.Merge(dst, src)
}
func (m *AggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec proto.InternalMessageInfo

type AggregatorSpec_Aggregation struct {
	Func AggregatorSpec_Func `protobuf:"varint,1,opt,name=func,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"func"`
	// Aggregation functions with distinct = true functions like you would
	// expect '<FUNC> DISTINCT' to operate, the default behavior would be
	// the '<FUNC> ALL' operation.
	Distinct bool `protobuf:"varint,2,opt,name=distinct" json:"distinct"`
	// The column index specifies the argument(s) to the aggregator function.
	//
	// Most aggregations take one argument
	// COUNT_ROWS takes no arguments.
	// FINAL_STDDEV and FINAL_VARIANCE take three arguments (SQRDIFF, SUM,
	// COUNT).
	ColIdx []uint32 `protobuf:"varint,5,rep,name=col_idx,json=colIdx" json:"col_idx,omitempty"`
	// If set, this column index specifies a boolean argument; rows for which
	// this value is not true don't contribute to this aggregation. This enables
	// the filter clause, e.g.:
	//   SELECT SUM(x) FILTER (WHERE y > 1), SUM(x) FILTER (WHERE y < 1) FROM t
	FilterColIdx *uint32 `protobuf:"varint,4,opt,name=filter_col_idx,json=filterColIdx" json:"filter_col_idx,omitempty"`
	// Arguments are const expressions passed to aggregation functions.
	Arguments []Expression `protobuf:"bytes,6,rep,name=arguments" json:"arguments"`
}

func (m *AggregatorSpec_Aggregation) Reset()         { *m = AggregatorSpec_Aggregation{} }
func (m *AggregatorSpec_Aggregation) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec_Aggregation) ProtoMessage()    {}
func (*AggregatorSpec_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{10, 0}
}
func (m *AggregatorSpec_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorSpec_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec_Aggregation.Merge(dst, src)
}
func (m *AggregatorSpec_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec_Aggregation proto.InternalMessageInfo

// InterleavedReaderJoinerSpec is the specification for a processor that performs
// KV operations to retrieve rows from 2+ tables from an interleaved hierarchy,
// performs intermediate filtering on rows from each table, and performs a
// join on the rows from the 2+ tables.
//
// Limitations: the InterleavedReaderJoiner currently supports only equality INNER joins
// on the full interleave prefix.
// See https://github.com/cockroachdb/cockroach/blob/master/docs/RFCS/20171025_interleaved_table_joins.md.
//
// The "internal columns" of an InterleavedReaderJoiner are the
// concatenation of left input columns and right input columns. If the left
// table has N columns and the right table has M columns, the first N columns
// contain values from the left table and the following M columns contain values
// from the right table.
type InterleavedReaderJoinerSpec struct {
	// For the common case of two tables, table at index 0 is the left/parent
	// table and table at index 1 is the right/child table.
	Tables  []InterleavedReaderJoinerSpec_Table `protobuf:"bytes,1,rep,name=tables" json:"tables"`
	Reverse bool                                `protobuf:"varint,2,opt,name=reverse" json:"reverse"`
	// A hint for how many joined rows from the tables the consumer of the
	// interleavedReaderJoiner might need. This is used to size the initial KV
	// batches to try to avoid reading many more rows than needed by the
	// processor receiving the output.
	// Not used if there is a limit set in the PostProcessSpec of this processor
	// (that value will be used for sizing batches instead).
	LimitHint int64 `protobuf:"varint,3,opt,name=limit_hint,json=limitHint" json:"limit_hint"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left table has N columns and the second
	// table stream has M columns, in this expression ordinal references @1 to @N
	// refer to columns of the left table and variables @(N+1) to @(N+M) refer to
	// columns in the right table.
	OnExpr Expression       `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   sqlbase.JoinType `protobuf:"varint,5,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
}

func (m *InterleavedReaderJoinerSpec) Reset()         { *m = InterleavedReaderJoinerSpec{} }
func (m *InterleavedReaderJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*InterleavedReaderJoinerSpec) ProtoMessage()    {}
func (*InterleavedReaderJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{11}
}
func (m *InterleavedReaderJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterleavedReaderJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InterleavedReaderJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterleavedReaderJoinerSpec.Merge(dst, src)
}
func (m *InterleavedReaderJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InterleavedReaderJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InterleavedReaderJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InterleavedReaderJoinerSpec proto.InternalMessageInfo

type InterleavedReaderJoinerSpec_Table struct {
	Desc sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. desc.indexes[index_idx-1]
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// The PostProcessSpecs of the corresponding TableReaderSpecs of each table
	// are fed as arguments to InterleavedReaderJoiner.
	//
	// This is required to properly post-process the rows (i.e. filtering and
	// projections) after reading from the table but before joining.
	// It may be necessary to modify/introduce additional intermediate filters
	// for correctness (see comment above 'spans' under
	// InterleavedReaderJoinerSpec).
	Post PostProcessSpec `protobuf:"bytes,3,opt,name=post" json:"post"`
	// The tables must be ordered according to the columns that have equality
	// constraints. The first column of the first table's ordering is constrained
	// to be equal to the first column in the second table's ordering and so on
	// for the other tables and their corresponding columns.
	Ordering Ordering `protobuf:"bytes,4,opt,name=ordering" json:"ordering"`
	// The span covering the rows from this table to join. Note the
	// InterleavedReaderJoiner processor will taking the union of all spans across
	// all tables to do a single pass-through scan. InterleavedReaderJoiner will
	// then check if a given row for a table is within any of its spans.
	// There must exist at least one non-empty set of spans for some table.
	Spans []TableReaderSpan `protobuf:"bytes,5,rep,name=spans" json:"spans"`
}

func (m *InterleavedReaderJoinerSpec_Table) Reset()         { *m = InterleavedReaderJoinerSpec_Table{} }
func (m *InterleavedReaderJoinerSpec_Table) String() string { return proto.CompactTextString(m) }
func (*InterleavedReaderJoinerSpec_Table) ProtoMessage()    {}
func (*InterleavedReaderJoinerSpec_Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{11, 0}
}
func (m *InterleavedReaderJoinerSpec_Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterleavedReaderJoinerSpec_Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InterleavedReaderJoinerSpec_Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterleavedReaderJoinerSpec_Table.Merge(dst, src)
}
func (m *InterleavedReaderJoinerSpec_Table) XXX_Size() int {
	return m.Size()
}
func (m *InterleavedReaderJoinerSpec_Table) XXX_DiscardUnknown() {
	xxx_messageInfo_InterleavedReaderJoinerSpec_Table.DiscardUnknown(m)
}

var xxx_messageInfo_InterleavedReaderJoinerSpec_Table proto.InternalMessageInfo

// ProjectSetSpec is the specification of a processor which applies a set of
// expressions, which may be set-returning functions, to its input.
type ProjectSetSpec struct {
	// Expressions to be applied
	Exprs []Expression `protobuf:"bytes,1,rep,name=exprs" json:"exprs"`
	// Column types for the generated values
	GeneratedColumns []github_com_cockroachdb_cockroach_pkg_sql_types.T `protobuf:"bytes,2,rep,name=generated_columns,json=generatedColumns,customtype=github.com/cockroachdb/cockroach/pkg/sql/types.T" json:"generated_columns"`
	// The number of columns each expression returns. Same length as exprs.
	NumColsPerGen []uint32 `protobuf:"varint,3,rep,name=num_cols_per_gen,json=numColsPerGen" json:"num_cols_per_gen,omitempty"`
}

func (m *ProjectSetSpec) Reset()         { *m = ProjectSetSpec{} }
func (m *ProjectSetSpec) String() string { return proto.CompactTextString(m) }
func (*ProjectSetSpec) ProtoMessage()    {}
func (*ProjectSetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{12}
}
func (m *ProjectSetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProjectSetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSetSpec.Merge(dst, src)
}
func (m *ProjectSetSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSetSpec proto.InternalMessageInfo

// WindowerSpec is the specification of a processor that performs computations
// of window functions that have the same PARTITION BY clause. For a particular
// windowFn, the processor puts result at windowFn.ArgIdxStart and "consumes"
// all arguments to windowFn (windowFn.ArgCount of them). So if windowFn takes
// no arguments, an extra column is added; if windowFn takes more than one
// argument, (windowFn.ArgCount - 1) columns are removed.
type WindowerSpec struct {
	// PartitionBy specifies how to partition rows for all window functions.
	PartitionBy []uint32 `protobuf:"varint,1,rep,name=partitionBy" json:"partitionBy,omitempty"`
	// WindowFns is the specification of all window functions to be computed.
	WindowFns []WindowerSpec_WindowFn `protobuf:"bytes,2,rep,name=windowFns" json:"windowFns"`
}

func (m *WindowerSpec) Reset()         { *m = WindowerSpec{} }
func (m *WindowerSpec) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec) ProtoMessage()    {}
func (*WindowerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13}
}
func (m *WindowerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec.Merge(dst, src)
}
func (m *WindowerSpec) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec proto.InternalMessageInfo

// Func specifies which function to compute. It can either be built-in
// aggregate or built-in window function.
type WindowerSpec_Func struct {
	AggregateFunc *AggregatorSpec_Func     `protobuf:"varint,1,opt,name=aggregateFunc,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"aggregateFunc,omitempty"`
	WindowFunc    *WindowerSpec_WindowFunc `protobuf:"varint,2,opt,name=windowFunc,enum=cockroach.sql.distsqlrun.WindowerSpec_WindowFunc" json:"windowFunc,omitempty"`
}

func (m *WindowerSpec_Func) Reset()         { *m = WindowerSpec_Func{} }
func (m *WindowerSpec_Func) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Func) ProtoMessage()    {}
func (*WindowerSpec_Func) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 0}
}
func (m *WindowerSpec_Func) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Func) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Func) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Func.Merge(dst, src)
}
func (m *WindowerSpec_Func) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Func) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Func.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Func proto.InternalMessageInfo

// Frame is the specification of a single window frame for a window function.
type WindowerSpec_Frame struct {
	Mode      WindowerSpec_Frame_Mode      `protobuf:"varint,1,opt,name=mode,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode" json:"mode"`
	Bounds    WindowerSpec_Frame_Bounds    `protobuf:"bytes,2,opt,name=bounds" json:"bounds"`
	Exclusion WindowerSpec_Frame_Exclusion `protobuf:"varint,3,opt,name=exclusion,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion" json:"exclusion"`
}

func (m *WindowerSpec_Frame) Reset()         { *m = WindowerSpec_Frame{} }
func (m *WindowerSpec_Frame) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame) ProtoMessage()    {}
func (*WindowerSpec_Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1}
}
func (m *WindowerSpec_Frame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame.Merge(dst, src)
}
func (m *WindowerSpec_Frame) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame proto.InternalMessageInfo

// Bound specifies the type of boundary and the offset (if present).
type WindowerSpec_Frame_Bound struct {
	BoundType WindowerSpec_Frame_BoundType `protobuf:"varint,1,opt,name=boundType,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType" json:"boundType"`
	// For UNBOUNDED_PRECEDING, UNBOUNDED_FOLLOWING, and CURRENT_ROW offset
	// is ignored. Integer offset for ROWS and GROUPS modes is stored in
	// int_offset while an encoded datum and the type information are stored
	// for RANGE mode.
	IntOffset   uint64    `protobuf:"varint,2,opt,name=int_offset,json=intOffset" json:"int_offset"`
	TypedOffset []byte    `protobuf:"bytes,3,opt,name=typed_offset,json=typedOffset" json:"typed_offset,omitempty"`
	OffsetType  DatumInfo `protobuf:"bytes,4,opt,name=offset_type,json=offsetType" json:"offset_type"`
}

func (m *WindowerSpec_Frame_Bound) Reset()         { *m = WindowerSpec_Frame_Bound{} }
func (m *WindowerSpec_Frame_Bound) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bound) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bound) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1, 0}
}
func (m *WindowerSpec_Frame_Bound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame_Bound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bound.Merge(dst, src)
}
func (m *WindowerSpec_Frame_Bound) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bound) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bound.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bound proto.InternalMessageInfo

// Bounds specifies boundaries of the window frame.
type WindowerSpec_Frame_Bounds struct {
	// Start bound must always be present whereas end bound might be omitted.
	Start WindowerSpec_Frame_Bound  `protobuf:"bytes,1,opt,name=start" json:"start"`
	End   *WindowerSpec_Frame_Bound `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *WindowerSpec_Frame_Bounds) Reset()         { *m = WindowerSpec_Frame_Bounds{} }
func (m *WindowerSpec_Frame_Bounds) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bounds) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 1, 1}
}
func (m *WindowerSpec_Frame_Bounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame_Bounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.Merge(dst, src)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bounds) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bounds proto.InternalMessageInfo

// WindowFn is the specification of a single window function.
type WindowerSpec_WindowFn struct {
	// Func is which function to compute.
	Func WindowerSpec_Func `protobuf:"bytes,1,opt,name=func" json:"func"`
	// ArgsIdxs contains indices of the columns that are arguments to the
	// window function.
	ArgsIdxs []uint32 `protobuf:"varint,7,rep,name=argsIdxs" json:"argsIdxs,omitempty"`
	// Ordering specifies in which order rows should be considered by this
	// window function. Its contents come from ORDER BY clause of the window
	// function.
	Ordering Ordering `protobuf:"bytes,4,opt,name=ordering" json:"ordering"`
	// Frame specifies over which frame this window function is computed.
	Frame *WindowerSpec_Frame `protobuf:"bytes,5,opt,name=frame" json:"frame,omitempty"`
	// Optional index of a column over which filtering of rows will be done.
	// Special value -1 indicates that filter is not present.
	FilterColIdx int32 `protobuf:"varint,6,opt,name=filterColIdx" json:"filterColIdx"`
	// OutputColIdx specifies the column index which the window function should
	// put its output into.
	OutputColIdx uint32 `protobuf:"varint,8,opt,name=outputColIdx" json:"outputColIdx"`
}

func (m *WindowerSpec_WindowFn) Reset()         { *m = WindowerSpec_WindowFn{} }
func (m *WindowerSpec_WindowFn) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_WindowFn) ProtoMessage()    {}
func (*WindowerSpec_WindowFn) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_6bfb74580171eec1, []int{13, 2}
}
func (m *WindowerSpec_WindowFn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_WindowFn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_WindowFn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_WindowFn.Merge(dst, src)
}
func (m *WindowerSpec_WindowFn) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_WindowFn) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_WindowFn.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_WindowFn proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ValuesCoreSpec)(nil), "cockroach.sql.distsqlrun.ValuesCoreSpec")
	proto.RegisterType((*TableReaderSpec)(nil), "cockroach.sql.distsqlrun.TableReaderSpec")
	proto.RegisterType((*IndexSkipTableReaderSpec)(nil), "cockroach.sql.distsqlrun.IndexSkipTableReaderSpec")
	proto.RegisterType((*JoinReaderSpec)(nil), "cockroach.sql.distsqlrun.JoinReaderSpec")
	proto.RegisterType((*SorterSpec)(nil), "cockroach.sql.distsqlrun.SorterSpec")
	proto.RegisterType((*DistinctSpec)(nil), "cockroach.sql.distsqlrun.DistinctSpec")
	proto.RegisterType((*OrdinalitySpec)(nil), "cockroach.sql.distsqlrun.OrdinalitySpec")
	proto.RegisterType((*ZigzagJoinerSpec)(nil), "cockroach.sql.distsqlrun.ZigzagJoinerSpec")
	proto.RegisterType((*MergeJoinerSpec)(nil), "cockroach.sql.distsqlrun.MergeJoinerSpec")
	proto.RegisterType((*HashJoinerSpec)(nil), "cockroach.sql.distsqlrun.HashJoinerSpec")
	proto.RegisterType((*AggregatorSpec)(nil), "cockroach.sql.distsqlrun.AggregatorSpec")
	proto.RegisterType((*AggregatorSpec_Aggregation)(nil), "cockroach.sql.distsqlrun.AggregatorSpec.Aggregation")
	proto.RegisterType((*InterleavedReaderJoinerSpec)(nil), "cockroach.sql.distsqlrun.InterleavedReaderJoinerSpec")
	proto.RegisterType((*InterleavedReaderJoinerSpec_Table)(nil), "cockroach.sql.distsqlrun.InterleavedReaderJoinerSpec.Table")
	proto.RegisterType((*ProjectSetSpec)(nil), "cockroach.sql.distsqlrun.ProjectSetSpec")
	proto.RegisterType((*WindowerSpec)(nil), "cockroach.sql.distsqlrun.WindowerSpec")
	proto.RegisterType((*WindowerSpec_Func)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Func")
	proto.RegisterType((*WindowerSpec_Frame)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame")
	proto.RegisterType((*WindowerSpec_Frame_Bound)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bound")
	proto.RegisterType((*WindowerSpec_Frame_Bounds)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bounds")
	proto.RegisterType((*WindowerSpec_WindowFn)(nil), "cockroach.sql.distsqlrun.WindowerSpec.WindowFn")
	proto.RegisterEnum("cockroach.sql.distsqlrun.ScanVisibility", ScanVisibility_name, ScanVisibility_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Func", AggregatorSpec_Func_name, AggregatorSpec_Func_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Type", AggregatorSpec_Type_name, AggregatorSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_WindowFunc", WindowerSpec_WindowFunc_name, WindowerSpec_WindowFunc_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode", WindowerSpec_Frame_Mode_name, WindowerSpec_Frame_Mode_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType", WindowerSpec_Frame_BoundType_name, WindowerSpec_Frame_BoundType_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion", WindowerSpec_Frame_Exclusion_name, WindowerSpec_Frame_Exclusion_value)
}
func (m *ValuesCoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValuesCoreSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RawBytes) > 0 {
		for _, b := range m.RawBytes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.NumRows))
	return i, nil
}

func (m *TableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n1, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	dAtA[i] = 0x18
	i++
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LimitHint))
	dAtA[i] = 0x30
	i++
	if m.IsCheck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x40
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.MaxResults))
	dAtA[i] = 0x48
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.MaxTimestampAgeNanos))
	return i, nil
}

func (m *IndexSkipTableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexSkipTableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n2, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x28
	i++
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *JoinReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n3, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	if len(m.LookupColumns) > 0 {
		dAtA5 := make([]byte, len(m.LookupColumns)*10)
		var j4 int
		for _, num := range m.LookupColumns {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n6, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x40
	i++
	if m.LookupColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *SorterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SorterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OutputOrdering.Size()))
	n7, err := m.OutputOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OrderingMatchLen))
	return i, nil
}

func (m *DistinctSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistinctSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderedColumns) > 0 {
		for _, num := range m.OrderedColumns {
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.DistinctColumns) > 0 {
		for _, num := range m.DistinctColumns {
			dAtA[i] = 0x10
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *OrdinalitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdinalitySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ZigzagJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZigzagJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EqColumns) > 0 {
		for _, msg := range m.EqColumns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IndexIds) > 0 {
		dAtA9 := make([]byte, len(m.IndexIds)*10)
		var j8 int
		for _, num := range m.IndexIds {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n10, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.FixedValues) > 0 {
		for _, msg := range m.FixedValues {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *MergeJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LeftOrdering.Size()))
	n11, err := m.LeftOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.RightOrdering.Size()))
	n12, err := m.RightOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n13, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	if m.NullEquality {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *HashJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LeftEqColumns) > 0 {
		dAtA15 := make([]byte, len(m.LeftEqColumns)*10)
		var j14 int
		for _, num := range m.LeftEqColumns {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.RightEqColumns) > 0 {
		dAtA17 := make([]byte, len(m.RightEqColumns)*10)
		var j16 int
		for _, num := range m.RightEqColumns {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n18, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	if m.MergedColumns {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *AggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		dAtA20 := make([]byte, len(m.GroupCols)*10)
		var j19 int
		for _, num := range m.GroupCols {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.Aggregations) > 0 {
		for _, msg := range m.Aggregations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		dAtA22 := make([]byte, len(m.OrderedGroupCols)*10)
		var j21 int
		for _, num := range m.OrderedGroupCols {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *AggregatorSpec_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Func))
	dAtA[i] = 0x10
	i++
	if m.Distinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.FilterColIdx != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, num := range m.ColIdx {
			dAtA[i] = 0x28
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.Arguments) > 0 {
		for _, msg := range m.Arguments {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterleavedReaderJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterleavedReaderJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LimitHint))
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n23, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *InterleavedReaderJoinerSpec_Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterleavedReaderJoinerSpec_Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Desc.Size()))
	n24, err := m.Desc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Post.Size()))
	n25, err := m.Post.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Ordering.Size()))
	n26, err := m.Ordering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProjectSetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, msg := range m.Exprs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for _, msg := range m.GeneratedColumns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NumColsPerGen) > 0 {
		for _, num := range m.NumColsPerGen {
			dAtA[i] = 0x18
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *WindowerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, num := range m.PartitionBy {
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.WindowFns) > 0 {
		for _, msg := range m.WindowFns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WindowerSpec_Func) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Func) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AggregateFunc != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.AggregateFunc))
	}
	if m.WindowFunc != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.WindowFunc))
	}
	return i, nil
}

func (m *WindowerSpec_Frame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Mode))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Bounds.Size()))
	n27, err := m.Bounds.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Exclusion))
	return i, nil
}

func (m *WindowerSpec_Frame_Bound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.BoundType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IntOffset))
	if m.TypedOffset != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.TypedOffset)))
		i += copy(dAtA[i:], m.TypedOffset)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OffsetType.Size()))
	n28, err := m.OffsetType.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	return i, nil
}

func (m *WindowerSpec_Frame_Bounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bounds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Start.Size()))
	n29, err := m.Start.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n29
	if m.End != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.End.Size()))
		n30, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *WindowerSpec_WindowFn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_WindowFn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Func.Size()))
	n31, err := m.Func.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Ordering.Size()))
	n32, err := m.Ordering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if m.Frame != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Frame.Size()))
		n33, err := m.Frame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.FilterColIdx))
	if len(m.ArgsIdxs) > 0 {
		for _, num := range m.ArgsIdxs {
			dAtA[i] = 0x38
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OutputColIdx))
	return i, nil
}

func encodeVarintProcessorsSql(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ValuesCoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.RawBytes) > 0 {
		for _, b := range m.RawBytes {
			l = len(b)
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.NumRows))
	return n
}

func (m *TableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	n += 2
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.LimitHint))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 1 + sovProcessorsSql(uint64(m.MaxResults))
	n += 1 + sovProcessorsSql(uint64(m.MaxTimestampAgeNanos))
	return n
}

func (m *IndexSkipTableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	return n
}

func (m *JoinReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.LookupColumns) > 0 {
		l = 0
		for _, e := range m.LookupColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	return n
}

func (m *SorterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutputOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.OrderingMatchLen))
	return n
}

func (m *DistinctSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderedColumns) > 0 {
		for _, e := range m.OrderedColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.DistinctColumns) > 0 {
		for _, e := range m.DistinctColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	return n
}

func (m *OrdinalitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ZigzagJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.EqColumns) > 0 {
		for _, e := range m.EqColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.IndexIds) > 0 {
		l = 0
		for _, e := range m.IndexIds {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if len(m.FixedValues) > 0 {
		for _, e := range m.FixedValues {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *MergeJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.RightOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *HashJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LeftEqColumns) > 0 {
		l = 0
		for _, e := range m.LeftEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.RightEqColumns) > 0 {
		l = 0
		for _, e := range m.RightEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *AggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		l = 0
		for _, e := range m.GroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		l = 0
		for _, e := range m.OrderedGroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *AggregatorSpec_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Func))
	n += 2
	if m.FilterColIdx != nil {
		n += 1 + sovProcessorsSql(uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, e := range m.ColIdx {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *InterleavedReaderJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.LimitHint))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *InterleavedReaderJoinerSpec_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	l = m.Post.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.Ordering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *ProjectSetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for _, e := range m.GeneratedColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.NumColsPerGen) > 0 {
		for _, e := range m.NumColsPerGen {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	return n
}

func (m *WindowerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.WindowFns) > 0 {
		for _, e := range m.WindowFns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *WindowerSpec_Func) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.AggregateFunc))
	}
	if m.WindowFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.WindowFunc))
	}
	return n
}

func (m *WindowerSpec_Frame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Mode))
	l = m.Bounds.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Exclusion))
	return n
}

func (m *WindowerSpec_Frame_Bound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.BoundType))
	n += 1 + sovProcessorsSql(uint64(m.IntOffset))
	if m.TypedOffset != nil {
		l = len(m.TypedOffset)
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	l = m.OffsetType.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *WindowerSpec_Frame_Bounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *WindowerSpec_WindowFn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Func.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.Ordering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	n += 1 + sovProcessorsSql(uint64(m.FilterColIdx))
	if len(m.ArgsIdxs) > 0 {
		for _, e := range m.ArgsIdxs {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.OutputColIdx))
	return n
}

func sovProcessorsSql(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessorsSql(x uint64) (n int) {
	return sovProcessorsSql(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WindowerSpec_Func) GetValue() interface{} {
	if this.AggregateFunc != nil {
		return this.AggregateFunc
	}
	if this.WindowFunc != nil {
		return this.WindowFunc
	}
	return nil
}

func (this *WindowerSpec_Func) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *AggregatorSpec_Func:
		this.AggregateFunc = vt
	case *WindowerSpec_WindowFunc:
		this.WindowFunc = vt
	default:
		return false
	}
	return true
}
func (m *ValuesCoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValuesCoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValuesCoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, DatumInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes, make([]byte, postIndex-iNdEx))
			copy(m.RawBytes[len(m.RawBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			m.NumRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRows |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitHint", wireType)
			}
			m.LimitHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitHint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCheck = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestampAgeNanos", wireType)
			}
			m.MaxTimestampAgeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestampAgeNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexSkipTableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LookupColumns = append(m.LookupColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LookupColumns) == 0 {
					m.LookupColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LookupColumns = append(m.LookupColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumns", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (sqlbase.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LookupColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SorterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SorterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SorterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderingMatchLen", wireType)
			}
			m.OrderingMatchLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderingMatchLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistinctSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistinctSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistinctSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedColumns = append(m.OrderedColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedColumns) == 0 {
					m.OrderedColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedColumns = append(m.OrderedColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DistinctColumns = append(m.DistinctColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DistinctColumns) == 0 {
					m.DistinctColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DistinctColumns = append(m.DistinctColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctColumns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdinalitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdinalitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdinalitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZigzagJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, sqlbase.TableDescriptor{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqColumns = append(m.EqColumns, Columns{})
			if err := m.EqColumns[len(m.EqColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexIds = append(m.IndexIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexIds) == 0 {
					m.IndexIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexIds = append(m.IndexIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedValues = append(m.FixedValues, &ValuesCoreSpec{})
			if err := m.FixedValues[len(m.FixedValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (sqlbase.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (sqlbase.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullEquality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullEquality = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeftEqColumns = append(m.LeftEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeftEqColumns) == 0 {
					m.LeftEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeftEqColumns = append(m.LeftEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RightEqColumns = append(m.RightEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RightEqColumns) == 0 {
					m.RightEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RightEqColumns = append(m.RightEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumns", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (sqlbase.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergedColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MergedColumns = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupCols = append(m.GroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupCols) == 0 {
					m.GroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupCols = append(m.GroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, AggregatorSpec_Aggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedGroupCols = append(m.OrderedGroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedGroupCols) == 0 {
					m.OrderedGroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedGroupCols = append(m.OrderedGroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedGroupCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AggregatorSpec_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec_Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			m.Func = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Func |= (AggregatorSpec_Func(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterColIdx = &v
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColIdx = append(m.ColIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColIdx) == 0 {
					m.ColIdx = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColIdx = append(m.ColIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleavedReaderJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterleavedReaderJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterleavedReaderJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, InterleavedReaderJoinerSpec_Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitHint", wireType)
			}
			m.LimitHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitHint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (sqlbase.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleavedReaderJoinerSpec_Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Post.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, Expression{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedColumns", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_sql_types.T
			m.GeneratedColumns = append(m.GeneratedColumns, v)
			if err := m.GeneratedColumns[len(m.GeneratedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NumColsPerGen = append(m.NumColsPerGen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NumColsPerGen) == 0 {
					m.NumColsPerGen = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NumColsPerGen = append(m.NumColsPerGen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColsPerGen", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionBy = append(m.PartitionBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionBy) == 0 {
					m.PartitionBy = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionBy = append(m.PartitionBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowFns = append(m.WindowFns, WindowerSpec_WindowFn{})
			if err := m.WindowFns[len(m.WindowFns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Func) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Func: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Func: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateFunc", wireType)
			}
			var v AggregatorSpec_Func
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AggregatorSpec_Func(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AggregateFunc = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFunc", wireType)
			}
			var v WindowerSpec_WindowFunc
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WindowerSpec_WindowFunc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowFunc = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (WindowerSpec_Frame_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusion", wireType)
			}
			m.Exclusion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exclusion |= (WindowerSpec_Frame_Exclusion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundType", wireType)
			}
			m.BoundType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoundType |= (WindowerSpec_Frame_BoundType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntOffset", wireType)
			}
			m.IntOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedOffset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypedOffset = append(m.TypedOffset[:0], dAtA[iNdEx:postIndex]...)
			if m.TypedOffset == nil {
				m.TypedOffset = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OffsetType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &WindowerSpec_Frame_Bound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_WindowFn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &WindowerSpec_Frame{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			m.FilterColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsIdxs = append(m.ArgsIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsIdxs) == 0 {
					m.ArgsIdxs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsIdxs = append(m.ArgsIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsIdxs", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputColIdx", wireType)
			}
			m.OutputColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputColIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsSql(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsSql
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessorsSql(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessorsSql = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsSql   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_sql.proto", fileDescriptor_processors_sql_6bfb74580171eec1)
}

var fileDescriptor_processors_sql_6bfb74580171eec1 = []byte{
	// 2325 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x73, 0xdb, 0xc6,
	0xf5, 0x17, 0x48, 0x50, 0x22, 0x1f, 0x7f, 0x68, 0xbd, 0x76, 0x62, 0x7e, 0xe5, 0xef, 0x48, 0x32,
	0xe3, 0xd4, 0x72, 0xe2, 0x48, 0xa9, 0xda, 0x49, 0x9b, 0xa4, 0x87, 0x80, 0x24, 0x48, 0x53, 0xa6,
	0x00, 0x19, 0x24, 0xe5, 0x1f, 0x9d, 0x29, 0x06, 0x22, 0x56, 0x14, 0x22, 0x12, 0xa0, 0xf0, 0xc3,
	0xa2, 0xf2, 0x0f, 0xe4, 0xd6, 0x69, 0xa7, 0xf7, 0x4e, 0x2e, 0xfd, 0x0b, 0xda, 0x43, 0x4f, 0x39,
	0xfb, 0x98, 0x53, 0x9b, 0xf6, 0x90, 0x69, 0xec, 0x3f, 0xa2, 0xb7, 0x4e, 0x67, 0x17, 0x0b, 0x08,
	0xd4, 0x98, 0x1e, 0xd3, 0xf6, 0xd4, 0x37, 0xee, 0x7b, 0xfb, 0xf9, 0xec, 0xdb, 0xf7, 0xde, 0xbe,
	0x7d, 0x0b, 0xc2, 0x0d, 0xef, 0x64, 0xb8, 0x45, 0x26, 0xa4, 0x6f, 0xd9, 0x87, 0xae, 0x31, 0x3e,
	0xd8, 0x1a, 0xbb, 0x4e, 0x9f, 0x78, 0x9e, 0xe3, 0x7a, 0xba, 0x77, 0x32, 0xdc, 0x1c, 0xbb, 0x8e,
	0xef, 0xe0, 0x72, 0xdf, 0xe9, 0x1f, 0xbb, 0x8e, 0xd1, 0x3f, 0xda, 0xa4, 0x42, 0xd3, 0xf2, 0x7c,
	0xef, 0x64, 0xe8, 0x06, 0xf6, 0xca, 0xff, 0x53, 0xbc, 0x77, 0x32, 0x3c, 0x30, 0x3c, 0xb2, 0xe5,
	0xf9, 0x6e, 0xd0, 0xf7, 0x03, 0x97, 0x98, 0x21, 0x6e, 0xe5, 0x5a, 0x52, 0xfb, 0xa5, 0x63, 0xd9,
	0xba, 0x7f, 0x36, 0x26, 0x5c, 0xb9, 0x72, 0x71, 0x69, 0xd3, 0xf0, 0x0d, 0xae, 0x7b, 0xff, 0x05,
	0x66, 0x51, 0x32, 0x3e, 0xed, 0xca, 0xc0, 0x19, 0x38, 0xec, 0xe7, 0x16, 0xfd, 0x15, 0x4a, 0x2b,
	0x7f, 0x10, 0xa0, 0xb4, 0x6f, 0x0c, 0x03, 0xe2, 0xd5, 0x1c, 0x97, 0x74, 0xc6, 0xa4, 0x8f, 0x6b,
	0xb0, 0xd4, 0x77, 0x86, 0xc1, 0xc8, 0xf6, 0xca, 0xc2, 0x7a, 0x7a, 0x23, 0xbf, 0xfd, 0xde, 0xe6,
	0xac, 0x2d, 0x6d, 0xd6, 0x0d, 0x3f, 0x18, 0xb5, 0xec, 0x43, 0xa7, 0x2a, 0x3e, 0xf9, 0x61, 0x6d,
	0x41, 0x8b, 0x90, 0xf8, 0x1a, 0xe4, 0x5c, 0xe3, 0x54, 0x3f, 0x38, 0xf3, 0x89, 0x57, 0x4e, 0xad,
	0xa7, 0x37, 0x0a, 0x5a, 0xd6, 0x35, 0x4e, 0xab, 0x74, 0x8c, 0xd7, 0x20, 0x6b, 0x07, 0x23, 0xdd,
	0x75, 0x4e, 0xbd, 0x72, 0x7a, 0x5d, 0xd8, 0x10, 0x23, 0xb4, 0x1d, 0x8c, 0x34, 0xe7, 0xd4, 0xab,
	0xfc, 0x23, 0x0d, 0xcb, 0x5d, 0xe3, 0x60, 0x48, 0x34, 0x62, 0x98, 0xc4, 0x65, 0x66, 0x55, 0x21,
	0xe3, 0x53, 0x51, 0x59, 0x58, 0x17, 0x36, 0xf2, 0xdb, 0x3f, 0xb9, 0x60, 0x14, 0xf7, 0xdc, 0x26,
	0x83, 0xd5, 0x89, 0xd7, 0x77, 0xad, 0xb1, 0xef, 0xb8, 0x9c, 0x39, 0x84, 0xe2, 0xeb, 0x90, 0xb3,
	0x6c, 0x93, 0x4c, 0x74, 0xcb, 0x9c, 0x94, 0x53, 0xeb, 0xc2, 0x46, 0x91, 0xeb, 0xb3, 0x4c, 0xdc,
	0x32, 0x27, 0x78, 0x15, 0x96, 0x5c, 0xf2, 0x98, 0xb8, 0x1e, 0x61, 0xa6, 0x65, 0x23, 0xd3, 0xb8,
	0x10, 0xcb, 0x90, 0xf1, 0xc6, 0x86, 0xed, 0x95, 0x45, 0xe6, 0x9b, 0x5b, 0xb3, 0x7d, 0x33, 0xb5,
	0x01, 0xc3, 0x8e, 0x2c, 0x61, 0x68, 0xfc, 0x1e, 0xc0, 0xd0, 0x1a, 0x59, 0xbe, 0x7e, 0x64, 0xd9,
	0x7e, 0x39, 0xb3, 0x2e, 0x6c, 0xa4, 0xf9, 0x84, 0x1c, 0x93, 0xdf, 0xb1, 0x6c, 0x9f, 0xfa, 0xc9,
	0xf2, 0xf4, 0xfe, 0x11, 0xe9, 0x1f, 0x97, 0x17, 0x93, 0xc6, 0x58, 0x5e, 0x8d, 0x0a, 0xb1, 0x02,
	0xf0, 0xd8, 0xf2, 0xac, 0x03, 0x6b, 0x68, 0xf9, 0x67, 0xe5, 0xa5, 0x75, 0x61, 0xa3, 0xb4, 0xbd,
	0x31, 0xdb, 0xa2, 0x4e, 0xdf, 0xb0, 0xf7, 0xe3, 0xf9, 0x9c, 0x2c, 0xc1, 0x80, 0xdf, 0x87, 0xfc,
	0xc8, 0x98, 0xe8, 0x2e, 0xf1, 0x82, 0xa1, 0xef, 0x95, 0xb3, 0x89, 0xd8, 0xc0, 0xc8, 0x98, 0x68,
	0xa1, 0x1c, 0x7f, 0x0e, 0x57, 0xe9, 0x34, 0xdf, 0x1a, 0x11, 0xcf, 0x37, 0x46, 0x63, 0xdd, 0x18,
	0x10, 0xdd, 0x36, 0x6c, 0xc7, 0x2b, 0xe7, 0x12, 0x90, 0x2b, 0x23, 0x63, 0xd2, 0x8d, 0xe6, 0x48,
	0x03, 0xa2, 0xd0, 0x19, 0x95, 0xbf, 0xa6, 0xa0, 0xdc, 0xa2, 0xde, 0xee, 0x1c, 0x5b, 0xe3, 0xb7,
	0x14, 0xe4, 0x38, 0x88, 0xe9, 0xd7, 0x0a, 0xe2, 0xb4, 0xfb, 0xc5, 0xd7, 0x76, 0x7f, 0x22, 0xf7,
	0x32, 0xcf, 0xc9, 0xbd, 0xca, 0x9f, 0xd3, 0x50, 0xda, 0x71, 0x2c, 0xfb, 0x7f, 0xef, 0xb0, 0x5b,
	0x50, 0x1a, 0x3a, 0xce, 0x71, 0x30, 0xd6, 0xa3, 0xd2, 0x40, 0x3d, 0x57, 0xac, 0xa6, 0x90, 0xa0,
	0x15, 0x43, 0x4d, 0x8d, 0x9f, 0xfc, 0x1a, 0x2c, 0x39, 0xb6, 0x4e, 0x26, 0x63, 0x97, 0x79, 0x24,
	0xbf, 0x7d, 0x63, 0xb6, 0x47, 0xe4, 0xc9, 0xd8, 0x25, 0x9e, 0x67, 0x39, 0x91, 0x63, 0x17, 0x1d,
	0x9b, 0xca, 0xf0, 0xa7, 0x20, 0xd2, 0xea, 0xc7, 0xb2, 0xbe, 0xb4, 0xbd, 0x36, 0x63, 0x57, 0xd4,
	0x17, 0xdd, 0xb3, 0x31, 0xe1, 0x60, 0x06, 0x79, 0xe3, 0x67, 0xe2, 0x53, 0x78, 0x77, 0x7a, 0xeb,
	0xba, 0xe1, 0x12, 0xfd, 0x98, 0x9c, 0xb1, 0xe3, 0x11, 0xc5, 0xe8, 0xf2, 0x94, 0x13, 0x24, 0x97,
	0xdc, 0x25, 0x67, 0x3b, 0x62, 0x36, 0x83, 0x16, 0x69, 0x89, 0x85, 0x8e, 0xe3, 0xfa, 0x3c, 0x62,
	0xf7, 0x60, 0xd9, 0x09, 0xfc, 0x71, 0xe0, 0xeb, 0x8e, 0x6b, 0x12, 0xd7, 0xb2, 0x07, 0x3c, 0x76,
	0x95, 0xd9, 0x46, 0xaa, 0x7c, 0x26, 0x5f, 0xac, 0x14, 0x12, 0x44, 0x52, 0xbc, 0x0d, 0x38, 0xe2,
	0xd2, 0x47, 0x86, 0xdf, 0x3f, 0xd2, 0x87, 0xc4, 0x9e, 0x8a, 0x24, 0x8a, 0xf4, 0xbb, 0x54, 0xdd,
	0x26, 0x76, 0xe5, 0x00, 0x0a, 0x75, 0xcb, 0xf3, 0x2d, 0xbb, 0xef, 0x33, 0xb3, 0x6e, 0xc2, 0x32,
	0x9b, 0x43, 0x4c, 0x3d, 0x59, 0xfd, 0x8b, 0x5a, 0x89, 0x8b, 0xa3, 0xf8, 0xde, 0x02, 0x64, 0x72,
	0x60, 0x3c, 0x33, 0xc5, 0x66, 0x2e, 0x47, 0x72, 0x3e, 0xb5, 0x82, 0xa0, 0xa4, 0xba, 0xa6, 0x65,
	0x1b, 0xd4, 0x91, 0x74, 0x95, 0xca, 0x6f, 0xd3, 0x80, 0x1e, 0x59, 0x83, 0xaf, 0x8c, 0x01, 0x8d,
	0x1d, 0xf7, 0x48, 0x1d, 0x16, 0x59, 0x22, 0x46, 0xf7, 0xcd, 0x7c, 0x49, 0xcc, 0xb1, 0xb8, 0x01,
	0x40, 0x4e, 0xa6, 0x2c, 0xca, 0x6f, 0x5f, 0x9f, 0xed, 0x52, 0x6e, 0x63, 0x54, 0x74, 0xc9, 0x49,
	0xb4, 0xbf, 0xb5, 0xf3, 0xd3, 0x90, 0xcc, 0xf2, 0xe8, 0x2c, 0xbc, 0xa1, 0x04, 0xbf, 0x0b, 0x85,
	0x43, 0x6b, 0x42, 0x4c, 0xfd, 0x31, 0xbb, 0x7c, 0xcb, 0x19, 0x66, 0xef, 0x0b, 0xf2, 0x74, 0xfa,
	0x92, 0xd6, 0xf2, 0x0c, 0x1d, 0x0a, 0x5f, 0xe3, 0xb4, 0x54, 0xfe, 0x96, 0x86, 0xe5, 0x5d, 0xe2,
	0x0e, 0x48, 0x22, 0x1e, 0xbb, 0x50, 0x1c, 0x92, 0xc3, 0xd7, 0xc8, 0xcf, 0x02, 0x85, 0xc7, 0xd9,
	0xa9, 0x42, 0xc9, 0xb5, 0x06, 0x47, 0x09, 0xbe, 0xd4, 0x9c, 0x7c, 0x45, 0x86, 0x8f, 0x09, 0x13,
	0x01, 0xc8, 0xbc, 0x8d, 0x0a, 0x73, 0x0b, 0x8a, 0x76, 0x30, 0x1c, 0xea, 0xe4, 0x24, 0x30, 0xe2,
	0x22, 0x13, 0x15, 0x82, 0x02, 0x55, 0xc9, 0x5c, 0x83, 0x3f, 0x83, 0xab, 0xcc, 0x95, 0xe7, 0x99,
	0x39, 0xa3, 0x7a, 0x90, 0x43, 0x5f, 0x3e, 0x99, 0xaa, 0x1e, 0xf8, 0x57, 0x50, 0x0e, 0xfd, 0xf6,
	0x1c, 0x70, 0x2e, 0x01, 0xbe, 0xc2, 0x66, 0x5d, 0x40, 0x57, 0x7e, 0x9f, 0x86, 0xd2, 0x1d, 0xc3,
	0x3b, 0x4a, 0xc4, 0xf5, 0x03, 0x58, 0xbe, 0x60, 0x4c, 0x78, 0xc4, 0x79, 0x15, 0x4f, 0x9a, 0x80,
	0x6f, 0x03, 0xba, 0xb8, 0x78, 0x78, 0xca, 0xd9, 0xe4, 0xd2, 0xf4, 0x92, 0x6f, 0x3d, 0x22, 0x1f,
	0x42, 0x69, 0x44, 0x93, 0xf8, 0xbc, 0x76, 0x25, 0x43, 0x52, 0x0c, 0x75, 0x91, 0xb1, 0x6f, 0x2f,
	0x26, 0x5f, 0x2f, 0x41, 0x49, 0x1a, 0x0c, 0x5c, 0x32, 0x30, 0x7c, 0x27, 0x8c, 0xc9, 0x75, 0x80,
	0x81, 0xeb, 0x84, 0x97, 0x4b, 0xd2, 0xc3, 0x39, 0x26, 0xad, 0x39, 0x43, 0x0f, 0xff, 0x06, 0x0a,
	0x06, 0x07, 0x59, 0x4e, 0xdc, 0xb3, 0xfc, 0x7c, 0xb6, 0x87, 0xa7, 0x97, 0x88, 0x87, 0xe7, 0x1e,
	0x9f, 0xe2, 0xc3, 0x1f, 0xf3, 0xdb, 0x83, 0x98, 0x7a, 0xc2, 0x14, 0x31, 0x36, 0x05, 0x71, 0x6d,
	0x33, 0xb6, 0xa8, 0xc9, 0x23, 0x95, 0x61, 0x91, 0xfa, 0xe8, 0xa5, 0x2d, 0xb9, 0x18, 0xb7, 0x95,
	0xaf, 0x53, 0x90, 0x4f, 0x98, 0x47, 0x89, 0x0f, 0x03, 0xbb, 0xcf, 0x0a, 0xce, 0x3c, 0xc4, 0x8d,
	0xc0, 0xee, 0x47, 0xc4, 0x94, 0x00, 0xaf, 0x43, 0x36, 0xba, 0x8c, 0x58, 0xb5, 0x89, 0xe2, 0x12,
	0x4b, 0xf1, 0x0d, 0x28, 0x1d, 0x5a, 0x43, 0x9f, 0xb8, 0x74, 0xbb, 0xac, 0xf3, 0xa1, 0xc5, 0xbc,
	0xa8, 0x15, 0x42, 0x69, 0xcd, 0x19, 0xd2, 0xbe, 0xe7, 0x2a, 0x7b, 0x0b, 0x31, 0x75, 0x86, 0xdd,
	0x71, 0x8b, 0xfd, 0x50, 0x71, 0x07, 0x72, 0x86, 0x3b, 0x08, 0x46, 0xc4, 0xf6, 0xbd, 0xf2, 0x22,
	0x8b, 0xc8, 0x3c, 0x39, 0x7f, 0x0e, 0xde, 0x11, 0xb3, 0x69, 0x24, 0x56, 0xbe, 0x4d, 0x81, 0x48,
	0x77, 0x81, 0x11, 0x14, 0x24, 0xe5, 0xa1, 0xae, 0xa8, 0x5d, 0x5d, 0xe9, 0xb5, 0xdb, 0x68, 0x01,
	0x2f, 0x41, 0x5a, 0xda, 0x6f, 0x22, 0x01, 0x17, 0x20, 0x5b, 0x55, 0xd5, 0xb6, 0x2e, 0x29, 0x75,
	0x94, 0xc2, 0x79, 0x58, 0x62, 0x23, 0x55, 0x43, 0x69, 0x5c, 0x02, 0xa8, 0xa9, 0x4a, 0x4d, 0xea,
	0xea, 0x52, 0xb3, 0x89, 0x44, 0x9c, 0x83, 0x4c, 0x4d, 0xed, 0x29, 0x5d, 0x94, 0xa1, 0xf0, 0x5d,
	0xe9, 0x01, 0x5a, 0x62, 0x3f, 0x5a, 0x0a, 0xca, 0x62, 0x80, 0xc5, 0x4e, 0xb7, 0x5e, 0x97, 0xf7,
	0x51, 0x8e, 0x0a, 0x3b, 0xbd, 0x5d, 0x04, 0x94, 0xae, 0xd3, 0xdb, 0xd5, 0x5b, 0x4a, 0x17, 0xe5,
	0xe9, 0x4a, 0xfb, 0x92, 0xd6, 0x92, 0x94, 0x9a, 0x8c, 0x0a, 0x54, 0xf5, 0x40, 0xd5, 0x18, 0x73,
	0x31, 0x5c, 0xa9, 0xa7, 0x74, 0x75, 0x4d, 0xbd, 0xdf, 0x41, 0x25, 0x86, 0xbb, 0xa7, 0xd5, 0x5b,
	0x8d, 0x06, 0x5a, 0xc6, 0x18, 0x4a, 0x8d, 0x96, 0x22, 0xb5, 0xf5, 0x18, 0x8d, 0xe8, 0x86, 0x42,
	0x19, 0x5f, 0xf3, 0x12, 0x2e, 0x42, 0x4e, 0xd2, 0x34, 0xe9, 0x21, 0x63, 0xc4, 0x74, 0xb1, 0x9d,
	0x8e, 0xaa, 0xb0, 0xd1, 0x65, 0xaa, 0xa4, 0xa3, 0x2a, 0x1b, 0x5e, 0xa1, 0xcb, 0x75, 0xba, 0x5a,
	0x4b, 0x69, 0xb2, 0xf1, 0x3b, 0x6c, 0xd7, 0xad, 0x2e, 0x73, 0xc1, 0xbb, 0x74, 0x23, 0x74, 0xa0,
	0x6a, 0xe8, 0x6a, 0xe5, 0x36, 0x88, 0x34, 0xbd, 0x70, 0x16, 0x44, 0xa9, 0xd7, 0x55, 0xd1, 0x02,
	0xdb, 0x66, 0x4d, 0x6a, 0x4b, 0x1a, 0x12, 0x28, 0x8d, 0xa2, 0x2a, 0x3a, 0x1f, 0xa7, 0x2a, 0xff,
	0x11, 0xe1, 0x5a, 0xcb, 0xf6, 0x89, 0x3b, 0x24, 0xc6, 0x63, 0x62, 0x86, 0x0d, 0x75, 0xa2, 0x54,
	0x3e, 0xbc, 0xd0, 0x92, 0x7c, 0x3e, 0x3b, 0xb6, 0x2f, 0xa0, 0x09, 0x3b, 0x96, 0x0b, 0x7d, 0x4a,
	0xa2, 0xc9, 0x4f, 0x3d, 0xef, 0x81, 0x39, 0xfd, 0x32, 0x4c, 0x3f, 0xff, 0x65, 0xf8, 0x46, 0x9b,
	0xec, 0xcc, 0xdc, 0x05, 0x77, 0xe5, 0xdb, 0x14, 0x64, 0xd8, 0xe6, 0xf0, 0x17, 0x20, 0x9a, 0xc4,
	0xeb, 0xbf, 0xd2, 0xfb, 0x83, 0x21, 0x5f, 0xe6, 0xf9, 0x51, 0x03, 0x71, 0xec, 0x78, 0xa1, 0x37,
	0x5e, 0xf8, 0x5c, 0xdb, 0x73, 0x3c, 0x7f, 0x2f, 0xfc, 0xfc, 0x41, 0x03, 0x10, 0xad, 0x43, 0xc1,
	0xb8, 0x0e, 0xd9, 0xb8, 0x03, 0x11, 0xe7, 0xec, 0x40, 0x62, 0xe4, 0xf9, 0xd3, 0x31, 0xf3, 0x3a,
	0x4f, 0xc7, 0xca, 0x53, 0x01, 0x4a, 0x7b, 0xae, 0xf3, 0x25, 0xe9, 0xfb, 0x1d, 0x12, 0x76, 0xe0,
	0x5f, 0x40, 0x86, 0x06, 0x34, 0x4a, 0xb9, 0x79, 0x22, 0x1a, 0x02, 0x31, 0x81, 0x4b, 0x03, 0x62,
	0x13, 0xd7, 0xf0, 0x13, 0x37, 0x21, 0xfb, 0xf8, 0x52, 0xfd, 0x25, 0x9d, 0xf7, 0xcf, 0x1f, 0xd6,
	0x3e, 0x1e, 0x58, 0xfe, 0x51, 0x70, 0xb0, 0xd9, 0x77, 0x46, 0x5b, 0x31, 0xbf, 0x79, 0x70, 0xfe,
	0x7b, 0x6b, 0x7c, 0x3c, 0xd8, 0xf2, 0x4e, 0x86, 0x5b, 0x34, 0xce, 0xde, 0x66, 0x57, 0x43, 0x31,
	0x65, 0x74, 0x81, 0xde, 0x04, 0x64, 0x07, 0x23, 0x76, 0x4d, 0xe8, 0x63, 0xe2, 0xea, 0x03, 0x62,
	0x87, 0x8d, 0xb2, 0x56, 0xb4, 0x83, 0x11, 0xbd, 0x21, 0xf6, 0x88, 0xdb, 0x24, 0x76, 0xe5, 0xc7,
	0x22, 0x14, 0xee, 0x5b, 0xb6, 0xe9, 0x9c, 0xf2, 0x63, 0xb5, 0x0e, 0xf9, 0xb1, 0xe1, 0xfa, 0x16,
	0xbb, 0x8b, 0xce, 0xf8, 0x03, 0x23, 0x29, 0xc2, 0x1d, 0xc8, 0x9d, 0x32, 0x44, 0x23, 0x6e, 0xe2,
	0xb7, 0x66, 0x3b, 0x22, 0x49, 0xce, 0x07, 0x8d, 0xb8, 0xc4, 0xc6, 0x3c, 0x2b, 0x7f, 0x11, 0x78,
	0x71, 0xed, 0x40, 0x31, 0xba, 0xfa, 0x48, 0xe3, 0x55, 0x2f, 0x1a, 0x6d, 0x9a, 0x03, 0xdf, 0x03,
	0xe0, 0x4b, 0x51, 0xc6, 0x14, 0x63, 0xfc, 0xe9, 0x7c, 0x36, 0x53, 0xd6, 0x04, 0xc9, 0x67, 0xe2,
	0x93, 0x6f, 0xd6, 0x84, 0x95, 0x6f, 0x96, 0x20, 0xd3, 0x70, 0x8d, 0x11, 0xc1, 0x77, 0x41, 0x1c,
	0x39, 0x26, 0xe1, 0xe6, 0xbe, 0x2c, 0x39, 0xc3, 0x6e, 0xee, 0x3a, 0x66, 0x7c, 0x76, 0x29, 0x09,
	0xbe, 0x07, 0x8b, 0x07, 0x4e, 0x60, 0x9b, 0x1e, 0xef, 0xc3, 0x7f, 0x36, 0x17, 0x5d, 0x95, 0x41,
	0xa3, 0x4a, 0x12, 0x12, 0xe1, 0x47, 0x90, 0x23, 0x93, 0xfe, 0x30, 0xa0, 0x29, 0xc9, 0x0e, 0x69,
	0x69, 0xfb, 0x93, 0xb9, 0x58, 0xe5, 0x08, 0x1d, 0xbf, 0xc7, 0x22, 0xc1, 0xca, 0xbf, 0x05, 0xc8,
	0xb0, 0x45, 0xe9, 0x2a, 0x6c, 0x3d, 0x5a, 0x8d, 0xb8, 0x2b, 0x3e, 0x99, 0xdf, 0xf6, 0x44, 0x2d,
	0x3b, 0xa7, 0xa3, 0x55, 0xd7, 0xb2, 0x7d, 0xdd, 0x39, 0x3c, 0xf4, 0x48, 0xd8, 0x32, 0x44, 0x5f,
	0xb1, 0x72, 0x96, 0xed, 0xab, 0x4c, 0x8c, 0xaf, 0x43, 0x81, 0x9e, 0x0a, 0x33, 0x9a, 0x46, 0x77,
	0x5a, 0xd0, 0xf2, 0x4c, 0xc6, 0xa7, 0xec, 0x40, 0x3e, 0x54, 0xb2, 0xaf, 0xb7, 0xbc, 0xce, 0xcc,
	0xf1, 0x01, 0x15, 0x42, 0x34, 0xb5, 0x69, 0xe5, 0x8f, 0x02, 0x2c, 0x86, 0xee, 0xc6, 0x0a, 0x64,
	0x3c, 0xdf, 0x70, 0x7d, 0x5e, 0x66, 0xb7, 0xe7, 0xdf, 0x76, 0x5c, 0x7e, 0x28, 0x0d, 0xae, 0x43,
	0x9a, 0xd8, 0x26, 0x4f, 0x80, 0x57, 0x60, 0xd3, 0x28, 0xbc, 0x72, 0x13, 0x44, 0x9a, 0x5d, 0xb4,
	0xdb, 0xd0, 0x24, 0xa5, 0x29, 0xa3, 0x05, 0x7a, 0xfd, 0xb2, 0xc6, 0x40, 0xa0, 0xd7, 0x6f, 0x53,
	0x53, 0x7b, 0x7b, 0x1d, 0x94, 0xaa, 0x7c, 0x05, 0xb9, 0xd8, 0xf7, 0xf8, 0x2a, 0x5c, 0xee, 0x29,
	0x55, 0xb5, 0xa7, 0xd4, 0xe5, 0xba, 0xbe, 0xa7, 0xc9, 0x35, 0xb9, 0xde, 0x52, 0x9a, 0x68, 0x61,
	0x5a, 0xd1, 0x50, 0xdb, 0x6d, 0xf5, 0x3e, 0x55, 0x08, 0xf8, 0x0a, 0x20, 0xb5, 0xd1, 0xe8, 0xc8,
	0xdd, 0xc4, 0xf4, 0x54, 0x42, 0x7a, 0x3e, 0x37, 0x8d, 0x97, 0x21, 0x5f, 0xeb, 0x69, 0x9a, 0x1c,
	0x76, 0x28, 0x48, 0xac, 0xfc, 0x1a, 0x72, 0x71, 0x76, 0xd1, 0x66, 0x44, 0x51, 0x75, 0xf9, 0x41,
	0xad, 0xdd, 0xeb, 0xb4, 0x54, 0x25, 0x5c, 0x94, 0x0d, 0xeb, 0xb2, 0x9e, 0xc4, 0x09, 0xf8, 0x12,
	0x14, 0x23, 0x05, 0xdb, 0x07, 0x4a, 0x51, 0x74, 0x24, 0xea, 0xb6, 0xe4, 0x0e, 0x4a, 0xaf, 0xfc,
	0x3d, 0x05, 0xd9, 0xa8, 0xee, 0x60, 0x39, 0xd1, 0xbd, 0xe6, 0xb7, 0x3f, 0x7c, 0x59, 0xaf, 0x5e,
	0xec, 0x5d, 0xdf, 0xcc, 0x3d, 0x55, 0x85, 0xcc, 0x21, 0x8d, 0x17, 0x7f, 0x90, 0xdd, 0x9e, 0x27,
	0xc6, 0x5a, 0x08, 0xc5, 0x1b, 0x30, 0xd5, 0x0d, 0xb3, 0x97, 0x59, 0x26, 0x7a, 0x43, 0x4c, 0xf5,
	0xc9, 0x2b, 0x90, 0x35, 0xdc, 0x81, 0xd7, 0x32, 0x27, 0xf4, 0xe9, 0x45, 0xab, 0x7a, 0x3c, 0xa6,
	0x2c, 0xe1, 0xf7, 0x2a, 0xce, 0x92, 0x4d, 0x5c, 0xf1, 0x53, 0x9a, 0x1d, 0x31, 0x9b, 0x42, 0x69,
	0xde, 0x10, 0xff, 0x49, 0x00, 0x38, 0xaf, 0x8e, 0xb4, 0x81, 0xd3, 0xd4, 0xfb, 0xba, 0xd2, 0xdb,
	0xad, 0xca, 0x1a, 0xcf, 0x33, 0x49, 0xb9, 0x1b, 0xb6, 0x76, 0x75, 0x59, 0xe9, 0xc8, 0x3a, 0x1b,
	0xb3, 0x20, 0xed, 0xc9, 0x5a, 0x8d, 0x05, 0x92, 0x4a, 0xd2, 0xb4, 0xa5, 0xac, 0xf5, 0x76, 0x65,
	0xbd, 0xde, 0xea, 0x74, 0xc3, 0xde, 0x58, 0xe9, 0xb6, 0xda, 0x72, 0xd8, 0x1b, 0xb7, 0xa5, 0x26,
	0x5a, 0xa4, 0x74, 0x6d, 0x59, 0xaa, 0xa3, 0x25, 0x9a, 0x3f, 0x8d, 0x96, 0xd6, 0xe9, 0xea, 0xfb,
	0x52, 0xbb, 0x27, 0xa3, 0x2c, 0xe5, 0x6f, 0x4b, 0xf1, 0x38, 0x47, 0xd9, 0x94, 0xee, 0x1d, 0x3e,
	0x84, 0x0f, 0x7e, 0x01, 0xa5, 0xe9, 0x4f, 0x88, 0x34, 0xf1, 0xf7, 0x7a, 0xd5, 0x76, 0xab, 0x86,
	0x16, 0xf0, 0xff, 0xc1, 0x3b, 0xe1, 0x6f, 0xda, 0xb1, 0xb2, 0xa6, 0x9e, 0xab, 0x84, 0xea, 0x47,
	0x4f, 0x7e, 0x5c, 0x5d, 0x78, 0xf2, 0x74, 0x55, 0xf8, 0xee, 0xe9, 0xaa, 0xf0, 0xfd, 0xd3, 0x55,
	0xe1, 0x5f, 0x4f, 0x57, 0x85, 0xdf, 0x3d, 0x5b, 0x5d, 0xf8, 0xee, 0xd9, 0xea, 0xc2, 0xf7, 0xcf,
	0x56, 0x17, 0x1e, 0xe5, 0x13, 0x7f, 0xea, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0xbb, 0x55, 0x1a,
	0xae, 0x7d, 0x1a, 0x00, 0x00,
}
