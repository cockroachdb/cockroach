// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_sql.proto

package execinfrapb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
import invertedexpr "github.com/cockroachdb/cockroach/pkg/sql/opt/invertedexpr"
import types "github.com/cockroachdb/cockroach/pkg/sql/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ScanVisibility controls which columns are seen by scans - just normal
// columns, or normal columns and also in-progress schema change columns.
type ScanVisibility int32

const (
	ScanVisibility_PUBLIC                ScanVisibility = 0
	ScanVisibility_PUBLIC_AND_NOT_PUBLIC ScanVisibility = 1
)

var ScanVisibility_name = map[int32]string{
	0: "PUBLIC",
	1: "PUBLIC_AND_NOT_PUBLIC",
}
var ScanVisibility_value = map[string]int32{
	"PUBLIC":                0,
	"PUBLIC_AND_NOT_PUBLIC": 1,
}

func (x ScanVisibility) Enum() *ScanVisibility {
	p := new(ScanVisibility)
	*p = x
	return p
}
func (x ScanVisibility) String() string {
	return proto.EnumName(ScanVisibility_name, int32(x))
}
func (x *ScanVisibility) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScanVisibility_value, data, "ScanVisibility")
	if err != nil {
		return err
	}
	*x = ScanVisibility(value)
	return nil
}
func (ScanVisibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{0}
}

// These mirror the aggregate functions supported by sql/parser. See
// sql/parser/aggregate_builtins.go.
type AggregatorSpec_Func int32

const (
	AggregatorSpec_ANY_NOT_NULL   AggregatorSpec_Func = 0
	AggregatorSpec_AVG            AggregatorSpec_Func = 1
	AggregatorSpec_BOOL_AND       AggregatorSpec_Func = 2
	AggregatorSpec_BOOL_OR        AggregatorSpec_Func = 3
	AggregatorSpec_CONCAT_AGG     AggregatorSpec_Func = 4
	AggregatorSpec_COUNT          AggregatorSpec_Func = 5
	AggregatorSpec_MAX            AggregatorSpec_Func = 7
	AggregatorSpec_MIN            AggregatorSpec_Func = 8
	AggregatorSpec_STDDEV         AggregatorSpec_Func = 9
	AggregatorSpec_SUM            AggregatorSpec_Func = 10
	AggregatorSpec_SUM_INT        AggregatorSpec_Func = 11
	AggregatorSpec_VARIANCE       AggregatorSpec_Func = 12
	AggregatorSpec_XOR_AGG        AggregatorSpec_Func = 13
	AggregatorSpec_COUNT_ROWS     AggregatorSpec_Func = 14
	AggregatorSpec_SQRDIFF        AggregatorSpec_Func = 15
	AggregatorSpec_FINAL_VARIANCE AggregatorSpec_Func = 16
	AggregatorSpec_FINAL_STDDEV   AggregatorSpec_Func = 17
	AggregatorSpec_ARRAY_AGG      AggregatorSpec_Func = 18
	AggregatorSpec_JSON_AGG       AggregatorSpec_Func = 19
	// JSONB_AGG is an alias for JSON_AGG, they do the same thing.
	AggregatorSpec_JSONB_AGG            AggregatorSpec_Func = 20
	AggregatorSpec_STRING_AGG           AggregatorSpec_Func = 21
	AggregatorSpec_BIT_AND              AggregatorSpec_Func = 22
	AggregatorSpec_BIT_OR               AggregatorSpec_Func = 23
	AggregatorSpec_CORR                 AggregatorSpec_Func = 24
	AggregatorSpec_PERCENTILE_DISC_IMPL AggregatorSpec_Func = 25
	AggregatorSpec_PERCENTILE_CONT_IMPL AggregatorSpec_Func = 26
	AggregatorSpec_JSON_OBJECT_AGG      AggregatorSpec_Func = 27
	AggregatorSpec_JSONB_OBJECT_AGG     AggregatorSpec_Func = 28
	AggregatorSpec_VAR_POP              AggregatorSpec_Func = 29
	AggregatorSpec_STDDEV_POP           AggregatorSpec_Func = 30
	AggregatorSpec_ST_MAKELINE          AggregatorSpec_Func = 31
	AggregatorSpec_ST_EXTENT            AggregatorSpec_Func = 32
	AggregatorSpec_ST_UNION             AggregatorSpec_Func = 33
	AggregatorSpec_ST_COLLECT           AggregatorSpec_Func = 34
)

var AggregatorSpec_Func_name = map[int32]string{
	0:  "ANY_NOT_NULL",
	1:  "AVG",
	2:  "BOOL_AND",
	3:  "BOOL_OR",
	4:  "CONCAT_AGG",
	5:  "COUNT",
	7:  "MAX",
	8:  "MIN",
	9:  "STDDEV",
	10: "SUM",
	11: "SUM_INT",
	12: "VARIANCE",
	13: "XOR_AGG",
	14: "COUNT_ROWS",
	15: "SQRDIFF",
	16: "FINAL_VARIANCE",
	17: "FINAL_STDDEV",
	18: "ARRAY_AGG",
	19: "JSON_AGG",
	20: "JSONB_AGG",
	21: "STRING_AGG",
	22: "BIT_AND",
	23: "BIT_OR",
	24: "CORR",
	25: "PERCENTILE_DISC_IMPL",
	26: "PERCENTILE_CONT_IMPL",
	27: "JSON_OBJECT_AGG",
	28: "JSONB_OBJECT_AGG",
	29: "VAR_POP",
	30: "STDDEV_POP",
	31: "ST_MAKELINE",
	32: "ST_EXTENT",
	33: "ST_UNION",
	34: "ST_COLLECT",
}
var AggregatorSpec_Func_value = map[string]int32{
	"ANY_NOT_NULL":         0,
	"AVG":                  1,
	"BOOL_AND":             2,
	"BOOL_OR":              3,
	"CONCAT_AGG":           4,
	"COUNT":                5,
	"MAX":                  7,
	"MIN":                  8,
	"STDDEV":               9,
	"SUM":                  10,
	"SUM_INT":              11,
	"VARIANCE":             12,
	"XOR_AGG":              13,
	"COUNT_ROWS":           14,
	"SQRDIFF":              15,
	"FINAL_VARIANCE":       16,
	"FINAL_STDDEV":         17,
	"ARRAY_AGG":            18,
	"JSON_AGG":             19,
	"JSONB_AGG":            20,
	"STRING_AGG":           21,
	"BIT_AND":              22,
	"BIT_OR":               23,
	"CORR":                 24,
	"PERCENTILE_DISC_IMPL": 25,
	"PERCENTILE_CONT_IMPL": 26,
	"JSON_OBJECT_AGG":      27,
	"JSONB_OBJECT_AGG":     28,
	"VAR_POP":              29,
	"STDDEV_POP":           30,
	"ST_MAKELINE":          31,
	"ST_EXTENT":            32,
	"ST_UNION":             33,
	"ST_COLLECT":           34,
}

func (x AggregatorSpec_Func) Enum() *AggregatorSpec_Func {
	p := new(AggregatorSpec_Func)
	*p = x
	return p
}
func (x AggregatorSpec_Func) String() string {
	return proto.EnumName(AggregatorSpec_Func_name, int32(x))
}
func (x *AggregatorSpec_Func) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Func_value, data, "AggregatorSpec_Func")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Func(value)
	return nil
}
func (AggregatorSpec_Func) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{12, 0}
}

type AggregatorSpec_Type int32

const (
	// This setting exists just for backwards compatibility; it's equivalent to
	// SCALAR when there are no grouping columns, and to NON_SCALAR when there
	// are grouping columns.
	AggregatorSpec_AUTO AggregatorSpec_Type = 0
	// A scalar aggregation has no grouping columns and always returns one
	// result row.
	AggregatorSpec_SCALAR AggregatorSpec_Type = 1
	// A non-scalar aggregation returns no rows if there are no input rows; it
	// may or may not have grouping columns.
	AggregatorSpec_NON_SCALAR AggregatorSpec_Type = 2
)

var AggregatorSpec_Type_name = map[int32]string{
	0: "AUTO",
	1: "SCALAR",
	2: "NON_SCALAR",
}
var AggregatorSpec_Type_value = map[string]int32{
	"AUTO":       0,
	"SCALAR":     1,
	"NON_SCALAR": 2,
}

func (x AggregatorSpec_Type) Enum() *AggregatorSpec_Type {
	p := new(AggregatorSpec_Type)
	*p = x
	return p
}
func (x AggregatorSpec_Type) String() string {
	return proto.EnumName(AggregatorSpec_Type_name, int32(x))
}
func (x *AggregatorSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Type_value, data, "AggregatorSpec_Type")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Type(value)
	return nil
}
func (AggregatorSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{12, 1}
}

type WindowerSpec_WindowFunc int32

const (
	// These mirror window functions from window_builtins.go.
	WindowerSpec_ROW_NUMBER   WindowerSpec_WindowFunc = 0
	WindowerSpec_RANK         WindowerSpec_WindowFunc = 1
	WindowerSpec_DENSE_RANK   WindowerSpec_WindowFunc = 2
	WindowerSpec_PERCENT_RANK WindowerSpec_WindowFunc = 3
	WindowerSpec_CUME_DIST    WindowerSpec_WindowFunc = 4
	WindowerSpec_NTILE        WindowerSpec_WindowFunc = 5
	WindowerSpec_LAG          WindowerSpec_WindowFunc = 6
	WindowerSpec_LEAD         WindowerSpec_WindowFunc = 7
	WindowerSpec_FIRST_VALUE  WindowerSpec_WindowFunc = 8
	WindowerSpec_LAST_VALUE   WindowerSpec_WindowFunc = 9
	WindowerSpec_NTH_VALUE    WindowerSpec_WindowFunc = 10
)

var WindowerSpec_WindowFunc_name = map[int32]string{
	0:  "ROW_NUMBER",
	1:  "RANK",
	2:  "DENSE_RANK",
	3:  "PERCENT_RANK",
	4:  "CUME_DIST",
	5:  "NTILE",
	6:  "LAG",
	7:  "LEAD",
	8:  "FIRST_VALUE",
	9:  "LAST_VALUE",
	10: "NTH_VALUE",
}
var WindowerSpec_WindowFunc_value = map[string]int32{
	"ROW_NUMBER":   0,
	"RANK":         1,
	"DENSE_RANK":   2,
	"PERCENT_RANK": 3,
	"CUME_DIST":    4,
	"NTILE":        5,
	"LAG":          6,
	"LEAD":         7,
	"FIRST_VALUE":  8,
	"LAST_VALUE":   9,
	"NTH_VALUE":    10,
}

func (x WindowerSpec_WindowFunc) Enum() *WindowerSpec_WindowFunc {
	p := new(WindowerSpec_WindowFunc)
	*p = x
	return p
}
func (x WindowerSpec_WindowFunc) String() string {
	return proto.EnumName(WindowerSpec_WindowFunc_name, int32(x))
}
func (x *WindowerSpec_WindowFunc) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_WindowFunc_value, data, "WindowerSpec_WindowFunc")
	if err != nil {
		return err
	}
	*x = WindowerSpec_WindowFunc(value)
	return nil
}
func (WindowerSpec_WindowFunc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 0}
}

// Mode indicates which mode of framing is used.
type WindowerSpec_Frame_Mode int32

const (
	// RANGE specifies frame in terms of logical range (e.g. 1 unit cheaper).
	WindowerSpec_Frame_RANGE WindowerSpec_Frame_Mode = 0
	// ROWS specifies frame in terms of physical offsets (e.g. 1 row before).
	WindowerSpec_Frame_ROWS WindowerSpec_Frame_Mode = 1
	// GROUPS specifies frame in terms of peer groups (where "peers" mean
	// rows not distinct in the ordering columns).
	WindowerSpec_Frame_GROUPS WindowerSpec_Frame_Mode = 2
)

var WindowerSpec_Frame_Mode_name = map[int32]string{
	0: "RANGE",
	1: "ROWS",
	2: "GROUPS",
}
var WindowerSpec_Frame_Mode_value = map[string]int32{
	"RANGE":  0,
	"ROWS":   1,
	"GROUPS": 2,
}

func (x WindowerSpec_Frame_Mode) Enum() *WindowerSpec_Frame_Mode {
	p := new(WindowerSpec_Frame_Mode)
	*p = x
	return p
}
func (x WindowerSpec_Frame_Mode) String() string {
	return proto.EnumName(WindowerSpec_Frame_Mode_name, int32(x))
}
func (x *WindowerSpec_Frame_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Mode_value, data, "WindowerSpec_Frame_Mode")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Mode(value)
	return nil
}
func (WindowerSpec_Frame_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1, 0}
}

// BoundType indicates which type of boundary is used.
type WindowerSpec_Frame_BoundType int32

const (
	WindowerSpec_Frame_UNBOUNDED_PRECEDING WindowerSpec_Frame_BoundType = 0
	WindowerSpec_Frame_UNBOUNDED_FOLLOWING WindowerSpec_Frame_BoundType = 1
	// Offsets are stored within Bound.
	WindowerSpec_Frame_OFFSET_PRECEDING WindowerSpec_Frame_BoundType = 2
	WindowerSpec_Frame_OFFSET_FOLLOWING WindowerSpec_Frame_BoundType = 3
	WindowerSpec_Frame_CURRENT_ROW      WindowerSpec_Frame_BoundType = 4
)

var WindowerSpec_Frame_BoundType_name = map[int32]string{
	0: "UNBOUNDED_PRECEDING",
	1: "UNBOUNDED_FOLLOWING",
	2: "OFFSET_PRECEDING",
	3: "OFFSET_FOLLOWING",
	4: "CURRENT_ROW",
}
var WindowerSpec_Frame_BoundType_value = map[string]int32{
	"UNBOUNDED_PRECEDING": 0,
	"UNBOUNDED_FOLLOWING": 1,
	"OFFSET_PRECEDING":    2,
	"OFFSET_FOLLOWING":    3,
	"CURRENT_ROW":         4,
}

func (x WindowerSpec_Frame_BoundType) Enum() *WindowerSpec_Frame_BoundType {
	p := new(WindowerSpec_Frame_BoundType)
	*p = x
	return p
}
func (x WindowerSpec_Frame_BoundType) String() string {
	return proto.EnumName(WindowerSpec_Frame_BoundType_name, int32(x))
}
func (x *WindowerSpec_Frame_BoundType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_BoundType_value, data, "WindowerSpec_Frame_BoundType")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_BoundType(value)
	return nil
}
func (WindowerSpec_Frame_BoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1, 1}
}

// Exclusion specifies the type of frame exclusion.
type WindowerSpec_Frame_Exclusion int32

const (
	WindowerSpec_Frame_NO_EXCLUSION        WindowerSpec_Frame_Exclusion = 0
	WindowerSpec_Frame_EXCLUDE_CURRENT_ROW WindowerSpec_Frame_Exclusion = 1
	WindowerSpec_Frame_EXCLUDE_GROUP       WindowerSpec_Frame_Exclusion = 2
	WindowerSpec_Frame_EXCLUDE_TIES        WindowerSpec_Frame_Exclusion = 3
)

var WindowerSpec_Frame_Exclusion_name = map[int32]string{
	0: "NO_EXCLUSION",
	1: "EXCLUDE_CURRENT_ROW",
	2: "EXCLUDE_GROUP",
	3: "EXCLUDE_TIES",
}
var WindowerSpec_Frame_Exclusion_value = map[string]int32{
	"NO_EXCLUSION":        0,
	"EXCLUDE_CURRENT_ROW": 1,
	"EXCLUDE_GROUP":       2,
	"EXCLUDE_TIES":        3,
}

func (x WindowerSpec_Frame_Exclusion) Enum() *WindowerSpec_Frame_Exclusion {
	p := new(WindowerSpec_Frame_Exclusion)
	*p = x
	return p
}
func (x WindowerSpec_Frame_Exclusion) String() string {
	return proto.EnumName(WindowerSpec_Frame_Exclusion_name, int32(x))
}
func (x *WindowerSpec_Frame_Exclusion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Exclusion_value, data, "WindowerSpec_Frame_Exclusion")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Exclusion(value)
	return nil
}
func (WindowerSpec_Frame_Exclusion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1, 2}
}

// ValuesCoreSpec is the core of a processor that has no inputs and generates
// "pre-canned" rows. This is not intended to be used for very large datasets.
type ValuesCoreSpec struct {
	// There is one DatumInfo for each element in a row. Can be empty, in which
	// case raw_bytes must be empty.
	Columns []DatumInfo `protobuf:"bytes,1,rep,name=columns" json:"columns"`
	// The number of rows is especially useful when we have zero columns.
	NumRows uint64 `protobuf:"varint,3,opt,name=num_rows,json=numRows" json:"num_rows"`
	// Each raw block encodes one or more data rows; each datum is encoded
	// according to the corresponding DatumInfo.
	RawBytes [][]byte `protobuf:"bytes,2,rep,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
}

func (m *ValuesCoreSpec) Reset()         { *m = ValuesCoreSpec{} }
func (m *ValuesCoreSpec) String() string { return proto.CompactTextString(m) }
func (*ValuesCoreSpec) ProtoMessage()    {}
func (*ValuesCoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{0}
}
func (m *ValuesCoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValuesCoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ValuesCoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValuesCoreSpec.Merge(dst, src)
}
func (m *ValuesCoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *ValuesCoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ValuesCoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ValuesCoreSpec proto.InternalMessageInfo

// TableReaderSpec is the specification for a "table reader". A table reader
// performs KV operations to retrieve rows for a table and outputs the desired
// columns of the rows that pass a filter expression.
//
// The "internal columns" of a TableReader (see ProcessorSpec) are all the
// columns of the table. Internally, only the values for the columns needed by
// the post-processing stage are to be populated. If is_check is set, the
// TableReader will run additional data checking procedures and the
// "internal columns" are:
//  - Error type (string).
//  - Primary key as a string, if it was obtainable.
//  - JSON of all decoded column values.
type TableReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Reverse  bool              `protobuf:"varint,3,opt,name=reverse" json:"reverse"`
	Spans    []TableReaderSpan `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	// A hint for how many rows the consumer of the table reader output might
	// need. This is used to size the initial KV batches to try to avoid reading
	// many more rows than needed by the processor receiving the output.
	//
	// Not used if there is a limit set in the PostProcessSpec of this processor
	// (that value will be used for sizing batches instead).
	LimitHint int64 `protobuf:"varint,5,opt,name=limit_hint,json=limitHint" json:"limit_hint"`
	// Indicates whether the TableReader is being run as an exhaustive
	// check. This is only true during SCRUB commands.
	IsCheck bool `protobuf:"varint,6,opt,name=is_check,json=isCheck" json:"is_check"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to PUBLIC. Will be set to PUBLIC_AND_NOT_PUBLIC if
	// the consumer of this TableReader expects to be able to see in-progress
	// schema changes.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	// If set, the TableReader can read all the spans in parallel, without any
	// batch limits. This should only be the case when there is a known upper
	// bound on the number of rows we can read, and when there is no limit or
	// limit hint.
	Parallelize bool `protobuf:"varint,12,opt,name=parallelize" json:"parallelize"`
	// If non-zero, this enables inconsistent historical scanning where different
	// batches can be read with different timestamps. This is used for
	// long-running table statistics which may outlive the TTL. Using this setting
	// will cause inconsistencies across rows and even within rows.
	//
	// The value is a duration (in nanoseconds), which is the maximum "age" of the
	// timestamp. If the scan takes long enough for the timestamp to become older,
	// the timestamp is advanced by however much time passed.
	//
	// Example:
	//
	//     current time:      10
	//     initial timestamp: 0
	//     max timestamp age: 30
	//
	//     time
	//     10:    start scan, timestamp=0
	//     10-29: continue scanning at timestamp=0
	//     30:    bump timestamp to 20
	//     30-49: continue scanning at timestamp=20
	//     50:    bump timestamp to 40
	//     ...
	//
	// Note: it is an error to perform a historical read at an initial timestamp
	// older than this value.
	//
	MaxTimestampAgeNanos uint64 `protobuf:"varint,9,opt,name=max_timestamp_age_nanos,json=maxTimestampAgeNanos" json:"max_timestamp_age_nanos"`
	// Indicates the row-level locking strength to be used by the scan. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,10,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the scan for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,11,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
	// Indicates whether or not this TableReader is expected to produce any
	// system columns in its output.
	HasSystemColumns bool `protobuf:"varint,14,opt,name=has_system_columns,json=hasSystemColumns" json:"has_system_columns"`
}

func (m *TableReaderSpec) Reset()         { *m = TableReaderSpec{} }
func (m *TableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*TableReaderSpec) ProtoMessage()    {}
func (*TableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{1}
}
func (m *TableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReaderSpec.Merge(dst, src)
}
func (m *TableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *TableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TableReaderSpec proto.InternalMessageInfo

// IndexSkipTableReaderSpec is the specification for a table reader that
// is performing a loose index scan over rows in the table. This means that
// this reader will return distinct rows from the table while using the index
// to skip unnecessary rows. This reader is used for different optimizations
// when operating on a prefix of a compound key.
type IndexSkipTableReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Spans    []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to PUBLIC. Will be set to PUBLIC_AND_NOT_PUBLIC if
	// the consumer of this TableReader expects to be able to see in-progress
	// schema changes.
	Visibility ScanVisibility `protobuf:"varint,4,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	Reverse    bool           `protobuf:"varint,5,opt,name=reverse" json:"reverse"`
	// Indicates the row-level locking strength to be used by the scan. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,6,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the scan for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,7,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
}

func (m *IndexSkipTableReaderSpec) Reset()         { *m = IndexSkipTableReaderSpec{} }
func (m *IndexSkipTableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*IndexSkipTableReaderSpec) ProtoMessage()    {}
func (*IndexSkipTableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{2}
}
func (m *IndexSkipTableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexSkipTableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IndexSkipTableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexSkipTableReaderSpec.Merge(dst, src)
}
func (m *IndexSkipTableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexSkipTableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexSkipTableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexSkipTableReaderSpec proto.InternalMessageInfo

// JoinReaderSpec is the specification for a "join reader". A join reader
// performs KV operations to retrieve specific rows that correspond to the
// values in the input stream (join by lookup). The output always preserves the
// order of the input rows.
//
// The "internal columns" of a JoinReader (see ProcessorSpec) are either:
//  - the columns of the table, if we are performing an index join (no lookup
//    columns) or if we are performing a semi or anti join, or
//  - the concatenation of the columns of the input stream with the table
//    columns.
//
// Internally, only the values for the columns needed by the post-processing
// stage are populated.
//
// Example:
// Input stream columns: | a | b |              Table columns: | c | d | e |
//
// If performing a lookup join on a = c (lookup columns is [0]):
//        Internal columns: | a | b | c | d | e |
//
// If performing an index join (where a = c and b = d) (lookup columns is []):
//        Internal columns: | c | d | e |
//
// There is a special case when a "join reader" is used as the second join in
// a pair of joins to accomplish a LEFT_OUTER, LEFT_SEMI or LEFT_ANTI join.
// The first join in this pair of joins is unable to precisely evaluate the
// join condition and produces false positives. This is typical when the first
// join is an inverted join (see InvertedJoinerSpec), but can also be the case
// when the first join is being evaluated over an index that does not have all
// the columns needed to evaluate the join condition. The first join outputs
// rows in sorted order of the original left columns. The input stream columns
// for the second join are a combination of the original left columns and the
// lookup columns. The first join additionally adds a continuation column that
// demarcates a group of successive rows that correspond to an original left
// row. The first row in a group contains false (since it is not a
// continuation of the group) and successive rows contain true.
//
// The mapping from the original join to the pair of joins is:
// LEFT_OUTER => LEFT_OUTER, LEFT_OUTER
// LEFT_SEMI  => INNER, LEFT_SEMI (better than doing INNER, INNER, SORT, DISTINCT)
// LEFT_ANTI  => LEFT_OUTER, LEFT_ANTI.
// where the first join always preserves order.
//
// More specifically, consider a lookup join example where the input stream
// columns are: | a | b | c | d | cont |.
// The lookup column is | d |. And the table columns are | e | f | with
// d = e.
// This join reader can see input of the form
// a1, b1, c1, d1,   false
// a1, b1, c1, d2,   true
// a1, b2, c1, null, false // when the first join is LEFT_OUTER
// a2, b1, c1, d3,   false
// a2, b1, c1, d4,   true
//
// Say both the results for (a1, b1, c1) are false positives, and the first
// of the (a2, b1, c1) result is a false positive.
// The output for LEFT_OUTER:
// a1, b1, c1, d1,   false, null, null
// a1, b2, c1, null, false, null, null
// a2, b1, c1, d4,   true,  d4,   f1
// The d, cont columns are not part of the original left row, so will be
// projected away after the join.
//
// The output for LEFT_ANTI:
// a1, b1, c1, d1,   false
// a1, b2, c1, null, false
// Again, the d, cont columns will be projected away after the join.
//
// The output for LEFT_SEMI:
// a2, b1, c1, d4, true
// Again, the d, cont columns will be projected away after the join.
type JoinReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index; each row in the input stream has a value
	// for each primary key. The index must provide all lookup columns.
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// Column indexes in the input stream specifying the columns which match with
	// the index columns. These are the equality columns of the join.
	//
	// If empty (index join), the start of the input stream schema is assumed to
	// match the index columns. The joinReader will perform an index join and the
	// "internal columns" will be the columns of the table.
	//
	// If populated (lookup join), the `joinReader` will perform a lookup join
	// and the "internal columns" will be the concatenation of the input stream
	// columns followed by the table columns (except for semi/anti join, which
	// don't output any table columns).
	LookupColumns []uint32 `protobuf:"varint,3,rep,packed,name=lookup_columns,json=lookupColumns" json:"lookup_columns,omitempty"`
	// If set, the lookup columns form a key in the target table and thus each
	// lookup has at most one result.
	LookupColumnsAreKey bool `protobuf:"varint,8,opt,name=lookup_columns_are_key,json=lookupColumnsAreKey" json:"lookup_columns_are_key"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @N to @(N+M) refer to columns in
	// the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// For lookup joins. Only JoinType_INNER and JoinType_LEFT_OUTER are
	// supported.
	Type descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// For index joins that are sources to mutation statements - what visibility
	// of columns should we return? Mutations sometimes need to see in-progress
	// schema change columns, in which case this field will be changed from its
	// default PUBLIC state. Causes the index join to return these schema change
	// columns.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	// Indicates the row-level locking strength to be used by the join. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,9,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the join for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,10,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
	// Indicates that the join reader should maintain the ordering of the input
	// stream. This is applicable to both lookup joins and index joins.
	// Maintaining ordering with lookup joins is expensive. With index joins,
	// not maintaining ordering allows for optimizations at lower layers.
	MaintainOrdering bool `protobuf:"varint,11,opt,name=maintain_ordering,json=maintainOrdering" json:"maintain_ordering"`
	// Indicates whether or not this JoinReader is expected to produce any
	// system columns in its output.
	//
	// This is only used in the special case of index joins, where the final
	// result of the secondary index joined against the primary index is
	// expected to contain the materialized system columns.
	HasSystemColumns bool `protobuf:"varint,13,opt,name=has_system_columns,json=hasSystemColumns" json:"has_system_columns"`
	// LeftJoinWithPairedJoiner is used when a left {outer,anti,semi} join is
	// being achieved by pairing two joins. See the comment above.
	LeftJoinWithPairedJoiner bool `protobuf:"varint,14,opt,name=left_join_with_paired_joiner,json=leftJoinWithPairedJoiner" json:"left_join_with_paired_joiner"`
}

func (m *JoinReaderSpec) Reset()         { *m = JoinReaderSpec{} }
func (m *JoinReaderSpec) String() string { return proto.CompactTextString(m) }
func (*JoinReaderSpec) ProtoMessage()    {}
func (*JoinReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{3}
}
func (m *JoinReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JoinReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinReaderSpec.Merge(dst, src)
}
func (m *JoinReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *JoinReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JoinReaderSpec proto.InternalMessageInfo

// SorterSpec is the specification for a "sorting aggregator". A sorting
// processor sorts elements in the input stream providing a certain output
// order guarantee regardless of the input ordering. The output ordering is
// according to a configurable set of columns.
//
// The "internal columns" of a Sorter (see ProcessorSpec) are the same as the
// input columns.
type SorterSpec struct {
	OutputOrdering Ordering `protobuf:"bytes,1,opt,name=output_ordering,json=outputOrdering" json:"output_ordering"`
	// Ordering match length, specifying that the input is already sorted by the
	// first 'n' output ordering columns, can be optionally specified for
	// possible speed-ups taking advantage of the partial orderings.
	OrderingMatchLen uint32 `protobuf:"varint,2,opt,name=ordering_match_len,json=orderingMatchLen" json:"ordering_match_len"`
}

func (m *SorterSpec) Reset()         { *m = SorterSpec{} }
func (m *SorterSpec) String() string { return proto.CompactTextString(m) }
func (*SorterSpec) ProtoMessage()    {}
func (*SorterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{4}
}
func (m *SorterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SorterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SorterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SorterSpec.Merge(dst, src)
}
func (m *SorterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SorterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SorterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SorterSpec proto.InternalMessageInfo

type DistinctSpec struct {
	// The ordered columns in the input stream can be optionally specified for
	// possible optimizations. The specific ordering (ascending/descending) of
	// the column itself is not important nor is the order in which the columns
	// are specified. The ordered columns must be a subset of the distinct
	// columns.
	OrderedColumns []uint32 `protobuf:"varint,1,rep,name=ordered_columns,json=orderedColumns" json:"ordered_columns,omitempty"`
	// The distinct columns in the input stream are those columns on which we
	// check for distinct rows. If A,B,C are in distinct_columns and there is a
	// 4th column D which is not included in distinct_columns, its values are not
	// considered, so rows A1,B1,C1,D1 and A1,B1,C1,D2 are considered equal and
	// only one of them (the first) is output.
	DistinctColumns []uint32 `protobuf:"varint,2,rep,name=distinct_columns,json=distinctColumns" json:"distinct_columns,omitempty"`
	// If true, then NULL values are treated as not equal to one another. Each NULL
	// value will cause a new row group to be created. For example:
	//
	//   c
	//   ----
	//   NULL
	//   NULL
	//
	// A distinct operation on column "c" will result in one output row if
	// NullsAreDistinct is false, or two output rows if true. This is set to true
	// for UPSERT and INSERT..ON CONFLICT statements, since they must treat NULL
	// values as distinct.
	NullsAreDistinct bool `protobuf:"varint,3,opt,name=nulls_are_distinct,json=nullsAreDistinct" json:"nulls_are_distinct"`
	// If not empty, then an error with this text will be raised if there are two
	// rows with duplicate distinct column values. This is used to implement the
	// UPSERT and INSERT..ON CONFLICT statements, both of which prohibit the same
	// row from being changed twice.
	ErrorOnDup string `protobuf:"bytes,4,opt,name=error_on_dup,json=errorOnDup" json:"error_on_dup"`
}

func (m *DistinctSpec) Reset()         { *m = DistinctSpec{} }
func (m *DistinctSpec) String() string { return proto.CompactTextString(m) }
func (*DistinctSpec) ProtoMessage()    {}
func (*DistinctSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{5}
}
func (m *DistinctSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistinctSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DistinctSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistinctSpec.Merge(dst, src)
}
func (m *DistinctSpec) XXX_Size() int {
	return m.Size()
}
func (m *DistinctSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DistinctSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DistinctSpec proto.InternalMessageInfo

// The specification for a WITH ORDINALITY processor. It adds a new column to
// each resulting row that contains the ordinal number of the row. Since there
// are no arguments for this operator, the spec is empty.
type OrdinalitySpec struct {
}

func (m *OrdinalitySpec) Reset()         { *m = OrdinalitySpec{} }
func (m *OrdinalitySpec) String() string { return proto.CompactTextString(m) }
func (*OrdinalitySpec) ProtoMessage()    {}
func (*OrdinalitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{6}
}
func (m *OrdinalitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdinalitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *OrdinalitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdinalitySpec.Merge(dst, src)
}
func (m *OrdinalitySpec) XXX_Size() int {
	return m.Size()
}
func (m *OrdinalitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdinalitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrdinalitySpec proto.InternalMessageInfo

// ZigzagJoinerSpec is the specification for a zigzag join processor. The
// processor's current implementation fetches the rows using internal
// rowFetchers.
//
// The "internal columns" of a ZigzagJoiner (see ProcessorSpec) are the
// concatenation of all of the columns of the tables specified. The columns
// are populated if they are contained in the index specified for that table.
type ZigzagJoinerSpec struct {
	// TODO(pbardea): Replace these with inputs that conform to a RowSource-like
	// interface.
	Tables []descpb.TableDescriptor `protobuf:"bytes,1,rep,name=tables" json:"tables"`
	// An array of arrays. The array at eq_columns[side_idx] contains the
	// equality columns for that side. All arrays in eq_columns should have
	// equal length.
	EqColumns []Columns `protobuf:"bytes,2,rep,name=eq_columns,json=eqColumns" json:"eq_columns"`
	// Each value indicates an index: if 0, primary index; otherwise the n-th
	// secondary index, i.e. tables[side_idx].indexes[index_ordinals[side_idx]].
	IndexOrdinals []uint32 `protobuf:"varint,3,rep,packed,name=index_ordinals,json=indexOrdinals" json:"index_ordinals,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// Fixed values at the start of indices.
	FixedValues []*ValuesCoreSpec `protobuf:"bytes,5,rep,name=fixed_values,json=fixedValues" json:"fixed_values,omitempty"`
	Type        descpb.JoinType   `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
}

func (m *ZigzagJoinerSpec) Reset()         { *m = ZigzagJoinerSpec{} }
func (m *ZigzagJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*ZigzagJoinerSpec) ProtoMessage()    {}
func (*ZigzagJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{7}
}
func (m *ZigzagJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZigzagJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ZigzagJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZigzagJoinerSpec.Merge(dst, src)
}
func (m *ZigzagJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ZigzagJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ZigzagJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ZigzagJoinerSpec proto.InternalMessageInfo

// MergeJoinerSpec is the specification for a merge join processor. The processor
// has two inputs and one output. The inputs must have the same ordering on the
// columns that have equality constraints. For example:
//   SELECT * FROM T1 INNER JOIN T2 ON T1.C1 = T2.C5 AND T1.C2 = T2.C4
//
// To perform a merge join, the streams corresponding to T1 and T2 must have the
// same ordering on columns C1, C2 and C5, C4 respectively. For example: C1+,C2-
// and C5+,C4-.
//
// The "internal columns" of a MergeJoiner (see ProcessorSpec) are the
// concatenation of left input columns and right input columns. If the left
// input has N columns and the right input has M columns, the first N columns
// contain values from the left side and the following M columns contain values
// from the right side.
//
// In the case of semi-join and anti-join, the processor core outputs only the
// left columns.
type MergeJoinerSpec struct {
	// The streams must be ordered according to the columns that have equality
	// constraints. The first column of the left ordering is constrained to be
	// equal to the first column in the right ordering and so on. The ordering
	// lengths and directions must match.
	// In the example above, left ordering describes C1+,C2- and right ordering
	// describes C5+,C4-.
	LeftOrdering  Ordering `protobuf:"bytes,1,opt,name=left_ordering,json=leftOrdering" json:"left_ordering"`
	RightOrdering Ordering `protobuf:"bytes,2,opt,name=right_ordering,json=rightOrdering" json:"right_ordering"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression      `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// NullEquality indicates that NULL = NULL should be considered true.
	// This allows OUTER JOINs to consider NULL values meaningfully. An
	// example of this is during SCRUB checks on secondary indexes.
	NullEquality bool `protobuf:"varint,7,opt,name=null_equality,json=nullEquality" json:"null_equality"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
}

func (m *MergeJoinerSpec) Reset()         { *m = MergeJoinerSpec{} }
func (m *MergeJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*MergeJoinerSpec) ProtoMessage()    {}
func (*MergeJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{8}
}
func (m *MergeJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MergeJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeJoinerSpec.Merge(dst, src)
}
func (m *MergeJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *MergeJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MergeJoinerSpec proto.InternalMessageInfo

// HashJoinerSpec is the specification for a hash join processor. The processor
// has two inputs and one output.
//
// The processor works by reading the entire right input and putting it in a hash
// table. Thus, there is no guarantee on the ordering of results that stem only
// from the right input (in the case of RIGHT_OUTER, FULL_OUTER). However, it is
// guaranteed that results that involve the left stream preserve the ordering;
// i.e. all results that stem from left row (i) precede results that stem from
// left row (i+1).
//
// The "internal columns" of a HashJoiner (see ProcessorSpec) are the
// concatenation of left input columns and right input columns.
//
// If the left input has N columns and the right input has M columns, the
// first N columns contain values from the left side and the following M columns
// contain values from the right side.
//
// In the case of semi-join and anti-join, the processor core outputs only the
// left columns.
type HashJoinerSpec struct {
	// The join constraints certain columns from the left stream to equal
	// corresponding columns on the right stream. These must have the same length.
	LeftEqColumns  []uint32 `protobuf:"varint,1,rep,packed,name=left_eq_columns,json=leftEqColumns" json:"left_eq_columns,omitempty"`
	RightEqColumns []uint32 `protobuf:"varint,2,rep,packed,name=right_eq_columns,json=rightEqColumns" json:"right_eq_columns,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @N to @(N+M) refer to columns in
	// the right stream.
	OnExpr Expression      `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
}

func (m *HashJoinerSpec) Reset()         { *m = HashJoinerSpec{} }
func (m *HashJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*HashJoinerSpec) ProtoMessage()    {}
func (*HashJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{9}
}
func (m *HashJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HashJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashJoinerSpec.Merge(dst, src)
}
func (m *HashJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *HashJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HashJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HashJoinerSpec proto.InternalMessageInfo

// InvertedJoinerSpec is the specification for an inverted join. The processor
// has two inputs and one output.
//
// The processor uses the inverted index on a column of the right input to
// join with a column of the left input. In addition to the InvertedExpr which
// is specified on these two columns, it also evaluates an OnExpr on the
// joined rows that satisfy the InvertedExpr. The "internal columns" of an
// InvertedJoiner for INNER and LEFT_OUTER joins are a concatenation of the
// columns of left and right input. The only columns of the right input that
// are populated are the columns present in the inverted index, except for the
// inverted column (since it does not represent a complete value for the datum
// that was indexed). For LEFT_SEMI and LEFT_ANTI, the "internal columns" are
// the columns of the left input.
//
// In many cases, the inverted join will contain false positives wrt the
// original join condition. This is handled by pairing it with a lookup join.
// This pairing works naturally when the user query specified INNER, by
// running an INNER inverted join followed by INNER lookup join. For a user
// query with LEFT_OUTER/LEFT_ANTI, the inverted join is run as a LEFT_OUTER
// with a special mode that outputs an additional bool column that represents
// whether this row is a continuation of a group, where a group is defined as
// rows corresponding to the same original left row. This is paired with a
// lookup join that also knows about the semantics of this bool column. For a
// user query with LEFT_SEMI, the inverted join is run as an INNER join with
// the same special mode. See the JoinReaderSpec for an example.
//
// Example:
// Input stream columns: | a | b |
// Table columns: | c | d | e |
// The InvertedExpr involves columns b, e and the primary key for the right
// input is c.
// The inverted index has columns: | e' | c |
// where e' is derived from e. For instance, if e is an array, e' will
// correspond to elements of the array.
// The OnExpr can use columns a, b, c, since they are the other columns that
// are present in the input stream and the inverted index.
//
// Internal columns for INNER and LEFT_OUTER: | a | b | c | d | e |
// where d, e are not populated.
// Internal columns for LEFT_SEMI and LEFT_ANTI: | a | b |
//
// For INNER/LEFT_OUTER with OutputGroupContinuationForLeftRow = true, the
// internal columns include an additional bool column as the last column.
type InvertedJoinerSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// The ID of the inverted index. The first column in the index is the
	// inverted column, and the the remaining columns are the primary key.
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// Expression involving the indexed column and columns from the input.
	// Assuming that the input stream has N columns and the table that has been
	// indexed has M columns, in this expression variables @1 to @N refer to
	// columns of the input stream and variables @(N+1) to @(N+M) refer to
	// columns in the table. Although the numbering includes all columns, only
	// columns corresponding to the indexed column and the input columns may be
	// present in this expression. Note that the column numbering matches the
	// numbering used below by the on expression.
	//
	// The expression is passed to xform.NewDatumToInvertedExpr to construct an
	// implementation of invertedexpr.DatumToInvertedExpr, which will be fed each
	// input row and output an expression to evaluate over the inverted index.
	InvertedExpr Expression `protobuf:"bytes,4,opt,name=inverted_expr,json=invertedExpr" json:"inverted_expr"`
	// Optional expression involving the columns in the index (other than the
	// inverted column) and the columns in the input stream. Assuming that the
	// input stream has N columns and the table that has been indexed has M
	// columns, in this expression variables @1 to @N refer to columns of the
	// input stream and variables @(N+1) to @(N+M) refer to columns in the
	// table. The numbering does not omit the column in the table corresponding
	// to the inverted column, or other table columns absent from the index, but
	// they cannot be present in this expression. Note that the column numbering
	// matches the numbering used above by the inverted expression.
	OnExpr Expression `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// Only INNER, LEFT_OUTER, LEFT_SEMI, LEFT_ANTI are supported. For indexes
	// that produce false positives for user expressions, like geospatial
	// indexes, only INNER and LEFT_OUTER are actually useful -- LEFT_SEMI will
	// be mapped to INNER by the optimizer, and LEFT_ANTI to LEFT_OUTER, to
	// allow the false positives to be eliminated by evaluating the exact
	// expression on the rows output by this join.
	Type descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// Indicates that the inverted joiner should maintain the ordering of the
	// input stream.
	MaintainOrdering bool `protobuf:"varint,7,opt,name=maintain_ordering,json=maintainOrdering" json:"maintain_ordering"`
	// Indicates that the join should output a continuation column that
	// indicates whether a row is a continuation of a group corresponding to a
	// left row.
	OutputGroupContinuationForLeftRow bool `protobuf:"varint,8,opt,name=output_group_continuation_for_left_row,json=outputGroupContinuationForLeftRow" json:"output_group_continuation_for_left_row"`
}

func (m *InvertedJoinerSpec) Reset()         { *m = InvertedJoinerSpec{} }
func (m *InvertedJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedJoinerSpec) ProtoMessage()    {}
func (*InvertedJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{10}
}
func (m *InvertedJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InvertedJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedJoinerSpec.Merge(dst, src)
}
func (m *InvertedJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedJoinerSpec proto.InternalMessageInfo

// InvertedFiltererSpec is the specification of a processor that does filtering
// on a table by evaluating an invertedexpr.SpanExpressionProto on an inverted
// index of the table. The input consists of the inverted index rows from
// InvertedExpr.SpansToRead. It is acceptable for a filter on the primary key
// to be pushed down between the scan and the inverted filterer.
//
// Example:
// Table columns: | a | b | c | d |
// where a, d are the primary key and b is the column with the inverted index.
// Inverted index columns: | a | b' | d |
// where b' is derived from b. For instance, if b is an array, b' will be
// elements of the array.
//
// Internal columns are | a | b | d |. The output sets b to NULL, since it does
// not have the value of the original column that was indexed in the inverted
// column.
//
// Optionally, there can be a pre-filtering spec that describes an expression
// (derived from the original expression that was converted to inverted_expr),
// that must evaluate to true on each inverted row. This is a performance
// optimization -- for more details see invertedidx.PreFilterer (geometry
// and geography inverted indexes are the only ones that currently use
// pre-filtering).
type InvertedFiltererSpec struct {
	// The index in the input row of the inverted column.
	InvertedColIdx uint32 `protobuf:"varint,1,opt,name=inverted_col_idx,json=invertedColIdx" json:"inverted_col_idx"`
	// The expression to evaluate. The SpansToRead are ignored since they
	// have already been used to setup the input.
	InvertedExpr    invertedexpr.SpanExpressionProto      `protobuf:"bytes,2,opt,name=inverted_expr,json=invertedExpr" json:"inverted_expr"`
	PreFiltererSpec *InvertedFiltererSpec_PreFiltererSpec `protobuf:"bytes,6,opt,name=pre_filterer_spec,json=preFiltererSpec" json:"pre_filterer_spec,omitempty"`
}

func (m *InvertedFiltererSpec) Reset()         { *m = InvertedFiltererSpec{} }
func (m *InvertedFiltererSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedFiltererSpec) ProtoMessage()    {}
func (*InvertedFiltererSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{11}
}
func (m *InvertedFiltererSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedFiltererSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InvertedFiltererSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedFiltererSpec.Merge(dst, src)
}
func (m *InvertedFiltererSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedFiltererSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedFiltererSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedFiltererSpec proto.InternalMessageInfo

// Optional pre-filtering expression.
type InvertedFiltererSpec_PreFiltererSpec struct {
	// Expression has only one variable, @1, which refers to the column with
	// the inverted index.
	Expression Expression `protobuf:"bytes,1,opt,name=expression" json:"expression"`
	// The type of the original column that was indexed in the inverted index.
	Type *types.T `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Reset()         { *m = InvertedFiltererSpec_PreFiltererSpec{} }
func (m *InvertedFiltererSpec_PreFiltererSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedFiltererSpec_PreFiltererSpec) ProtoMessage()    {}
func (*InvertedFiltererSpec_PreFiltererSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{11, 0}
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *InvertedFiltererSpec_PreFiltererSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec.Merge(dst, src)
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec proto.InternalMessageInfo

// AggregatorSpec is the specification for an "aggregator" (processor core
// type, not the logical plan computation stage). An aggregator performs
// 'aggregation' in the SQL sense in that it groups rows and computes an aggregate
// for each group. The group is configured using the group key. The aggregator
// can be configured with one or more aggregation functions.
//
// The "internal columns" of an Aggregator map 1-1 to the aggregations.
type AggregatorSpec struct {
	Type AggregatorSpec_Type `protobuf:"varint,5,opt,name=type,enum=cockroach.sql.distsqlrun.AggregatorSpec_Type" json:"type"`
	// The group key is a subset of the columns in the input stream schema on the
	// basis of which we define our groups.
	GroupCols    []uint32                     `protobuf:"varint,2,rep,packed,name=group_cols,json=groupCols" json:"group_cols,omitempty"`
	Aggregations []AggregatorSpec_Aggregation `protobuf:"bytes,3,rep,name=aggregations" json:"aggregations"`
	// A subset of the GROUP BY columns which are ordered in the input.
	OrderedGroupCols []uint32 `protobuf:"varint,4,rep,packed,name=ordered_group_cols,json=orderedGroupCols" json:"ordered_group_cols,omitempty"`
}

func (m *AggregatorSpec) Reset()         { *m = AggregatorSpec{} }
func (m *AggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec) ProtoMessage()    {}
func (*AggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{12}
}
func (m *AggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec.Merge(dst, src)
}
func (m *AggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec proto.InternalMessageInfo

type AggregatorSpec_Aggregation struct {
	Func AggregatorSpec_Func `protobuf:"varint,1,opt,name=func,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"func"`
	// Aggregation functions with distinct = true functions like you would
	// expect '<FUNC> DISTINCT' to operate, the default behavior would be
	// the '<FUNC> ALL' operation.
	Distinct bool `protobuf:"varint,2,opt,name=distinct" json:"distinct"`
	// The column index specifies the argument(s) to the aggregator function.
	//
	// Most aggregations take one argument
	// COUNT_ROWS takes no arguments.
	// FINAL_STDDEV and FINAL_VARIANCE take three arguments (SQRDIFF, SUM,
	// COUNT).
	ColIdx []uint32 `protobuf:"varint,5,rep,name=col_idx,json=colIdx" json:"col_idx,omitempty"`
	// If set, this column index specifies a boolean argument; rows for which
	// this value is not true don't contribute to this aggregation. This enables
	// the filter clause, e.g.:
	//   SELECT SUM(x) FILTER (WHERE y > 1), SUM(x) FILTER (WHERE y < 1) FROM t
	FilterColIdx *uint32 `protobuf:"varint,4,opt,name=filter_col_idx,json=filterColIdx" json:"filter_col_idx,omitempty"`
	// Arguments are const expressions passed to aggregation functions.
	Arguments []Expression `protobuf:"bytes,6,rep,name=arguments" json:"arguments"`
}

func (m *AggregatorSpec_Aggregation) Reset()         { *m = AggregatorSpec_Aggregation{} }
func (m *AggregatorSpec_Aggregation) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec_Aggregation) ProtoMessage()    {}
func (*AggregatorSpec_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{12, 0}
}
func (m *AggregatorSpec_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AggregatorSpec_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec_Aggregation.Merge(dst, src)
}
func (m *AggregatorSpec_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec_Aggregation proto.InternalMessageInfo

// ProjectSetSpec is the specification of a processor which applies a set of
// expressions, which may be set-returning functions, to its input.
type ProjectSetSpec struct {
	// Expressions to be applied
	Exprs []Expression `protobuf:"bytes,1,rep,name=exprs" json:"exprs"`
	// Column types for the generated values
	GeneratedColumns []*types.T `protobuf:"bytes,2,rep,name=generated_columns,json=generatedColumns" json:"generated_columns,omitempty"`
	// The number of columns each expression returns. Same length as exprs.
	NumColsPerGen []uint32 `protobuf:"varint,3,rep,name=num_cols_per_gen,json=numColsPerGen" json:"num_cols_per_gen,omitempty"`
}

func (m *ProjectSetSpec) Reset()         { *m = ProjectSetSpec{} }
func (m *ProjectSetSpec) String() string { return proto.CompactTextString(m) }
func (*ProjectSetSpec) ProtoMessage()    {}
func (*ProjectSetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{13}
}
func (m *ProjectSetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProjectSetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSetSpec.Merge(dst, src)
}
func (m *ProjectSetSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSetSpec proto.InternalMessageInfo

// WindowerSpec is the specification of a processor that performs computations
// of window functions that have the same PARTITION BY clause. For a particular
// windowFn, the processor puts result at windowFn.ArgIdxStart and "consumes"
// all arguments to windowFn (windowFn.ArgCount of them). So if windowFn takes
// no arguments, an extra column is added; if windowFn takes more than one
// argument, (windowFn.ArgCount - 1) columns are removed.
type WindowerSpec struct {
	// PartitionBy specifies how to partition rows for all window functions.
	PartitionBy []uint32 `protobuf:"varint,1,rep,name=partitionBy" json:"partitionBy,omitempty"`
	// WindowFns is the specification of all window functions to be computed.
	WindowFns []WindowerSpec_WindowFn `protobuf:"bytes,2,rep,name=windowFns" json:"windowFns"`
}

func (m *WindowerSpec) Reset()         { *m = WindowerSpec{} }
func (m *WindowerSpec) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec) ProtoMessage()    {}
func (*WindowerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14}
}
func (m *WindowerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec.Merge(dst, src)
}
func (m *WindowerSpec) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec proto.InternalMessageInfo

// Func specifies which function to compute. It can either be built-in
// aggregate or built-in window function.
type WindowerSpec_Func struct {
	AggregateFunc *AggregatorSpec_Func     `protobuf:"varint,1,opt,name=aggregateFunc,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"aggregateFunc,omitempty"`
	WindowFunc    *WindowerSpec_WindowFunc `protobuf:"varint,2,opt,name=windowFunc,enum=cockroach.sql.distsqlrun.WindowerSpec_WindowFunc" json:"windowFunc,omitempty"`
}

func (m *WindowerSpec_Func) Reset()         { *m = WindowerSpec_Func{} }
func (m *WindowerSpec_Func) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Func) ProtoMessage()    {}
func (*WindowerSpec_Func) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 0}
}
func (m *WindowerSpec_Func) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Func) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Func) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Func.Merge(dst, src)
}
func (m *WindowerSpec_Func) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Func) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Func.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Func proto.InternalMessageInfo

// Frame is the specification of a single window frame for a window function.
type WindowerSpec_Frame struct {
	Mode      WindowerSpec_Frame_Mode      `protobuf:"varint,1,opt,name=mode,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode" json:"mode"`
	Bounds    WindowerSpec_Frame_Bounds    `protobuf:"bytes,2,opt,name=bounds" json:"bounds"`
	Exclusion WindowerSpec_Frame_Exclusion `protobuf:"varint,3,opt,name=exclusion,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion" json:"exclusion"`
}

func (m *WindowerSpec_Frame) Reset()         { *m = WindowerSpec_Frame{} }
func (m *WindowerSpec_Frame) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame) ProtoMessage()    {}
func (*WindowerSpec_Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1}
}
func (m *WindowerSpec_Frame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame.Merge(dst, src)
}
func (m *WindowerSpec_Frame) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame proto.InternalMessageInfo

// Bound specifies the type of boundary and the offset (if present).
type WindowerSpec_Frame_Bound struct {
	BoundType WindowerSpec_Frame_BoundType `protobuf:"varint,1,opt,name=boundType,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType" json:"boundType"`
	// For UNBOUNDED_PRECEDING, UNBOUNDED_FOLLOWING, and CURRENT_ROW offset
	// is ignored. Integer offset for ROWS and GROUPS modes is stored in
	// int_offset while an encoded datum and the type information are stored
	// for RANGE mode.
	IntOffset   uint64    `protobuf:"varint,2,opt,name=int_offset,json=intOffset" json:"int_offset"`
	TypedOffset []byte    `protobuf:"bytes,3,opt,name=typed_offset,json=typedOffset" json:"typed_offset,omitempty"`
	OffsetType  DatumInfo `protobuf:"bytes,4,opt,name=offset_type,json=offsetType" json:"offset_type"`
}

func (m *WindowerSpec_Frame_Bound) Reset()         { *m = WindowerSpec_Frame_Bound{} }
func (m *WindowerSpec_Frame_Bound) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bound) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bound) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1, 0}
}
func (m *WindowerSpec_Frame_Bound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame_Bound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bound.Merge(dst, src)
}
func (m *WindowerSpec_Frame_Bound) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bound) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bound.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bound proto.InternalMessageInfo

// Bounds specifies boundaries of the window frame.
type WindowerSpec_Frame_Bounds struct {
	// Start bound must always be present whereas end bound might be omitted.
	Start WindowerSpec_Frame_Bound  `protobuf:"bytes,1,opt,name=start" json:"start"`
	End   *WindowerSpec_Frame_Bound `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *WindowerSpec_Frame_Bounds) Reset()         { *m = WindowerSpec_Frame_Bounds{} }
func (m *WindowerSpec_Frame_Bounds) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bounds) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 1, 1}
}
func (m *WindowerSpec_Frame_Bounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_Frame_Bounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.Merge(dst, src)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bounds) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bounds proto.InternalMessageInfo

// WindowFn is the specification of a single window function.
type WindowerSpec_WindowFn struct {
	// Func is which function to compute.
	Func WindowerSpec_Func `protobuf:"bytes,1,opt,name=func" json:"func"`
	// ArgsIdxs contains indices of the columns that are arguments to the
	// window function.
	ArgsIdxs []uint32 `protobuf:"varint,7,rep,name=argsIdxs" json:"argsIdxs,omitempty"`
	// Ordering specifies in which order rows should be considered by this
	// window function. Its contents come from ORDER BY clause of the window
	// function.
	Ordering Ordering `protobuf:"bytes,4,opt,name=ordering" json:"ordering"`
	// Frame specifies over which frame this window function is computed.
	Frame *WindowerSpec_Frame `protobuf:"bytes,5,opt,name=frame" json:"frame,omitempty"`
	// Optional index of a column over which filtering of rows will be done.
	// Special value -1 indicates that filter is not present.
	FilterColIdx int32 `protobuf:"varint,6,opt,name=filterColIdx" json:"filterColIdx"`
	// OutputColIdx specifies the column index which the window function should
	// put its output into.
	OutputColIdx uint32 `protobuf:"varint,8,opt,name=outputColIdx" json:"outputColIdx"`
}

func (m *WindowerSpec_WindowFn) Reset()         { *m = WindowerSpec_WindowFn{} }
func (m *WindowerSpec_WindowFn) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_WindowFn) ProtoMessage()    {}
func (*WindowerSpec_WindowFn) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_sql_b359f10a859601d7, []int{14, 2}
}
func (m *WindowerSpec_WindowFn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_WindowFn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *WindowerSpec_WindowFn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_WindowFn.Merge(dst, src)
}
func (m *WindowerSpec_WindowFn) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_WindowFn) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_WindowFn.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_WindowFn proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ValuesCoreSpec)(nil), "cockroach.sql.distsqlrun.ValuesCoreSpec")
	proto.RegisterType((*TableReaderSpec)(nil), "cockroach.sql.distsqlrun.TableReaderSpec")
	proto.RegisterType((*IndexSkipTableReaderSpec)(nil), "cockroach.sql.distsqlrun.IndexSkipTableReaderSpec")
	proto.RegisterType((*JoinReaderSpec)(nil), "cockroach.sql.distsqlrun.JoinReaderSpec")
	proto.RegisterType((*SorterSpec)(nil), "cockroach.sql.distsqlrun.SorterSpec")
	proto.RegisterType((*DistinctSpec)(nil), "cockroach.sql.distsqlrun.DistinctSpec")
	proto.RegisterType((*OrdinalitySpec)(nil), "cockroach.sql.distsqlrun.OrdinalitySpec")
	proto.RegisterType((*ZigzagJoinerSpec)(nil), "cockroach.sql.distsqlrun.ZigzagJoinerSpec")
	proto.RegisterType((*MergeJoinerSpec)(nil), "cockroach.sql.distsqlrun.MergeJoinerSpec")
	proto.RegisterType((*HashJoinerSpec)(nil), "cockroach.sql.distsqlrun.HashJoinerSpec")
	proto.RegisterType((*InvertedJoinerSpec)(nil), "cockroach.sql.distsqlrun.InvertedJoinerSpec")
	proto.RegisterType((*InvertedFiltererSpec)(nil), "cockroach.sql.distsqlrun.InvertedFiltererSpec")
	proto.RegisterType((*InvertedFiltererSpec_PreFiltererSpec)(nil), "cockroach.sql.distsqlrun.InvertedFiltererSpec.PreFiltererSpec")
	proto.RegisterType((*AggregatorSpec)(nil), "cockroach.sql.distsqlrun.AggregatorSpec")
	proto.RegisterType((*AggregatorSpec_Aggregation)(nil), "cockroach.sql.distsqlrun.AggregatorSpec.Aggregation")
	proto.RegisterType((*ProjectSetSpec)(nil), "cockroach.sql.distsqlrun.ProjectSetSpec")
	proto.RegisterType((*WindowerSpec)(nil), "cockroach.sql.distsqlrun.WindowerSpec")
	proto.RegisterType((*WindowerSpec_Func)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Func")
	proto.RegisterType((*WindowerSpec_Frame)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame")
	proto.RegisterType((*WindowerSpec_Frame_Bound)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bound")
	proto.RegisterType((*WindowerSpec_Frame_Bounds)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bounds")
	proto.RegisterType((*WindowerSpec_WindowFn)(nil), "cockroach.sql.distsqlrun.WindowerSpec.WindowFn")
	proto.RegisterEnum("cockroach.sql.distsqlrun.ScanVisibility", ScanVisibility_name, ScanVisibility_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Func", AggregatorSpec_Func_name, AggregatorSpec_Func_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Type", AggregatorSpec_Type_name, AggregatorSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_WindowFunc", WindowerSpec_WindowFunc_name, WindowerSpec_WindowFunc_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode", WindowerSpec_Frame_Mode_name, WindowerSpec_Frame_Mode_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType", WindowerSpec_Frame_BoundType_name, WindowerSpec_Frame_BoundType_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion", WindowerSpec_Frame_Exclusion_name, WindowerSpec_Frame_Exclusion_value)
}
func (m *ValuesCoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValuesCoreSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RawBytes) > 0 {
		for _, b := range m.RawBytes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.NumRows))
	return i, nil
}

func (m *TableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n1, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	dAtA[i] = 0x18
	i++
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LimitHint))
	dAtA[i] = 0x30
	i++
	if m.IsCheck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x48
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.MaxTimestampAgeNanos))
	dAtA[i] = 0x50
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	dAtA[i] = 0x58
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	dAtA[i] = 0x60
	i++
	if m.Parallelize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	if m.HasSystemColumns {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *IndexSkipTableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexSkipTableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n2, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x28
	i++
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	return i, nil
}

func (m *JoinReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n3, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	if len(m.LookupColumns) > 0 {
		dAtA5 := make([]byte, len(m.LookupColumns)*10)
		var j4 int
		for _, num := range m.LookupColumns {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n6, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	dAtA[i] = 0x40
	i++
	if m.LookupColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	dAtA[i] = 0x50
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	dAtA[i] = 0x58
	i++
	if m.MaintainOrdering {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x68
	i++
	if m.HasSystemColumns {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	if m.LeftJoinWithPairedJoiner {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *SorterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SorterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OutputOrdering.Size()))
	n7, err := m.OutputOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OrderingMatchLen))
	return i, nil
}

func (m *DistinctSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistinctSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderedColumns) > 0 {
		for _, num := range m.OrderedColumns {
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.DistinctColumns) > 0 {
		for _, num := range m.DistinctColumns {
			dAtA[i] = 0x10
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x18
	i++
	if m.NullsAreDistinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.ErrorOnDup)))
	i += copy(dAtA[i:], m.ErrorOnDup)
	return i, nil
}

func (m *OrdinalitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdinalitySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ZigzagJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZigzagJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EqColumns) > 0 {
		for _, msg := range m.EqColumns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IndexOrdinals) > 0 {
		dAtA9 := make([]byte, len(m.IndexOrdinals)*10)
		var j8 int
		for _, num := range m.IndexOrdinals {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n10, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.FixedValues) > 0 {
		for _, msg := range m.FixedValues {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *MergeJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LeftOrdering.Size()))
	n11, err := m.LeftOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.RightOrdering.Size()))
	n12, err := m.RightOrdering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n13, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	if m.NullEquality {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *HashJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LeftEqColumns) > 0 {
		dAtA15 := make([]byte, len(m.LeftEqColumns)*10)
		var j14 int
		for _, num := range m.LeftEqColumns {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.RightEqColumns) > 0 {
		dAtA17 := make([]byte, len(m.RightEqColumns)*10)
		var j16 int
		for _, num := range m.RightEqColumns {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n18, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x40
	i++
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *InvertedJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Table.Size()))
	n19, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.InvertedExpr.Size()))
	n20, err := m.InvertedExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OnExpr.Size()))
	n21, err := m.OnExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x38
	i++
	if m.MaintainOrdering {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.OutputGroupContinuationForLeftRow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *InvertedFiltererSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedFiltererSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.InvertedColIdx))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.InvertedExpr.Size()))
	n22, err := m.InvertedExpr.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if m.PreFiltererSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.PreFiltererSpec.Size()))
		n23, err := m.PreFiltererSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedFiltererSpec_PreFiltererSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Expression.Size()))
	n24, err := m.Expression.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	if m.Type != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type.Size()))
		n25, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *AggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		dAtA27 := make([]byte, len(m.GroupCols)*10)
		var j26 int
		for _, num := range m.GroupCols {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if len(m.Aggregations) > 0 {
		for _, msg := range m.Aggregations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		dAtA29 := make([]byte, len(m.OrderedGroupCols)*10)
		var j28 int
		for _, num := range m.OrderedGroupCols {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *AggregatorSpec_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Func))
	dAtA[i] = 0x10
	i++
	if m.Distinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.FilterColIdx != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, num := range m.ColIdx {
			dAtA[i] = 0x28
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.Arguments) > 0 {
		for _, msg := range m.Arguments {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProjectSetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSetSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, msg := range m.Exprs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for _, msg := range m.GeneratedColumns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NumColsPerGen) > 0 {
		for _, num := range m.NumColsPerGen {
			dAtA[i] = 0x18
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *WindowerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, num := range m.PartitionBy {
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	if len(m.WindowFns) > 0 {
		for _, msg := range m.WindowFns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WindowerSpec_Func) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Func) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AggregateFunc != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.AggregateFunc))
	}
	if m.WindowFunc != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.WindowFunc))
	}
	return i, nil
}

func (m *WindowerSpec_Frame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Mode))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Bounds.Size()))
	n30, err := m.Bounds.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Exclusion))
	return i, nil
}

func (m *WindowerSpec_Frame_Bound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.BoundType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IntOffset))
	if m.TypedOffset != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.TypedOffset)))
		i += copy(dAtA[i:], m.TypedOffset)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OffsetType.Size()))
	n31, err := m.OffsetType.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	return i, nil
}

func (m *WindowerSpec_Frame_Bounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bounds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Start.Size()))
	n32, err := m.Start.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if m.End != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.End.Size()))
		n33, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *WindowerSpec_WindowFn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_WindowFn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Func.Size()))
	n34, err := m.Func.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	dAtA[i] = 0x22
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Ordering.Size()))
	n35, err := m.Ordering.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	if m.Frame != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Frame.Size()))
		n36, err := m.Frame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.FilterColIdx))
	if len(m.ArgsIdxs) > 0 {
		for _, num := range m.ArgsIdxs {
			dAtA[i] = 0x38
			i++
			i = encodeVarintProcessorsSql(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OutputColIdx))
	return i, nil
}

func encodeVarintProcessorsSql(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ValuesCoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.RawBytes) > 0 {
		for _, b := range m.RawBytes {
			l = len(b)
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.NumRows))
	return n
}

func (m *TableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	n += 2
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.LimitHint))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 1 + sovProcessorsSql(uint64(m.MaxTimestampAgeNanos))
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	n += 2
	n += 2
	return n
}

func (m *IndexSkipTableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	return n
}

func (m *JoinReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.LookupColumns) > 0 {
		l = 0
		for _, e := range m.LookupColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *SorterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutputOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.OrderingMatchLen))
	return n
}

func (m *DistinctSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderedColumns) > 0 {
		for _, e := range m.OrderedColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.DistinctColumns) > 0 {
		for _, e := range m.DistinctColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	n += 2
	l = len(m.ErrorOnDup)
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *OrdinalitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ZigzagJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.EqColumns) > 0 {
		for _, e := range m.EqColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.IndexOrdinals) > 0 {
		l = 0
		for _, e := range m.IndexOrdinals {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if len(m.FixedValues) > 0 {
		for _, e := range m.FixedValues {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *MergeJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.RightOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *HashJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LeftEqColumns) > 0 {
		l = 0
		for _, e := range m.LeftEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.RightEqColumns) > 0 {
		l = 0
		for _, e := range m.RightEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	return n
}

func (m *InvertedJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	l = m.InvertedExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	return n
}

func (m *InvertedFiltererSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.InvertedColIdx))
	l = m.InvertedExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.PreFiltererSpec != nil {
		l = m.PreFiltererSpec.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Expression.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *AggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		l = 0
		for _, e := range m.GroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		l = 0
		for _, e := range m.OrderedGroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *AggregatorSpec_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Func))
	n += 2
	if m.FilterColIdx != nil {
		n += 1 + sovProcessorsSql(uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, e := range m.ColIdx {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *ProjectSetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for _, e := range m.GeneratedColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.NumColsPerGen) > 0 {
		for _, e := range m.NumColsPerGen {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	return n
}

func (m *WindowerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.WindowFns) > 0 {
		for _, e := range m.WindowFns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *WindowerSpec_Func) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.AggregateFunc))
	}
	if m.WindowFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.WindowFunc))
	}
	return n
}

func (m *WindowerSpec_Frame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Mode))
	l = m.Bounds.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Exclusion))
	return n
}

func (m *WindowerSpec_Frame_Bound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.BoundType))
	n += 1 + sovProcessorsSql(uint64(m.IntOffset))
	if m.TypedOffset != nil {
		l = len(m.TypedOffset)
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	l = m.OffsetType.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *WindowerSpec_Frame_Bounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *WindowerSpec_WindowFn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Func.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.Ordering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	n += 1 + sovProcessorsSql(uint64(m.FilterColIdx))
	if len(m.ArgsIdxs) > 0 {
		for _, e := range m.ArgsIdxs {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.OutputColIdx))
	return n
}

func sovProcessorsSql(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessorsSql(x uint64) (n int) {
	return sovProcessorsSql(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WindowerSpec_Func) GetValue() interface{} {
	if this.AggregateFunc != nil {
		return this.AggregateFunc
	}
	if this.WindowFunc != nil {
		return this.WindowFunc
	}
	return nil
}

func (this *WindowerSpec_Func) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *AggregatorSpec_Func:
		this.AggregateFunc = vt
	case *WindowerSpec_WindowFunc:
		this.WindowFunc = vt
	default:
		return false
	}
	return true
}
func (m *ValuesCoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValuesCoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValuesCoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, DatumInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes, make([]byte, postIndex-iNdEx))
			copy(m.RawBytes[len(m.RawBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			m.NumRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRows |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitHint", wireType)
			}
			m.LimitHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitHint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCheck = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestampAgeNanos", wireType)
			}
			m.MaxTimestampAgeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestampAgeNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= (descpb.ScanLockingStrength(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= (descpb.ScanLockingWaitPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Parallelize = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasSystemColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasSystemColumns = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexSkipTableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= (descpb.ScanLockingStrength(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= (descpb.ScanLockingWaitPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LookupColumns = append(m.LookupColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LookupColumns) == 0 {
					m.LookupColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LookupColumns = append(m.LookupColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumns", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (descpb.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (ScanVisibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LookupColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= (descpb.ScanLockingStrength(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= (descpb.ScanLockingWaitPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainOrdering = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasSystemColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasSystemColumns = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoinWithPairedJoiner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftJoinWithPairedJoiner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SorterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SorterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SorterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderingMatchLen", wireType)
			}
			m.OrderingMatchLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderingMatchLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistinctSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistinctSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistinctSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedColumns = append(m.OrderedColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedColumns) == 0 {
					m.OrderedColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedColumns = append(m.OrderedColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DistinctColumns = append(m.DistinctColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DistinctColumns) == 0 {
					m.DistinctColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DistinctColumns = append(m.DistinctColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctColumns", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullsAreDistinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullsAreDistinct = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorOnDup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorOnDup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdinalitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdinalitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdinalitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZigzagJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, descpb.TableDescriptor{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqColumns = append(m.EqColumns, Columns{})
			if err := m.EqColumns[len(m.EqColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexOrdinals = append(m.IndexOrdinals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexOrdinals) == 0 {
					m.IndexOrdinals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexOrdinals = append(m.IndexOrdinals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexOrdinals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedValues = append(m.FixedValues, &ValuesCoreSpec{})
			if err := m.FixedValues[len(m.FixedValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (descpb.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (descpb.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullEquality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullEquality = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeftEqColumns = append(m.LeftEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeftEqColumns) == 0 {
					m.LeftEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeftEqColumns = append(m.LeftEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RightEqColumns = append(m.RightEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RightEqColumns) == 0 {
					m.RightEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RightEqColumns = append(m.RightEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumns", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (descpb.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InvertedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (descpb.JoinType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainOrdering = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputGroupContinuationForLeftRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputGroupContinuationForLeftRow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedFiltererSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedFiltererSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedFiltererSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedColIdx", wireType)
			}
			m.InvertedColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedColIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InvertedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreFiltererSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreFiltererSpec == nil {
				m.PreFiltererSpec = &InvertedFiltererSpec_PreFiltererSpec{}
			}
			if err := m.PreFiltererSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedFiltererSpec_PreFiltererSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreFiltererSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreFiltererSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupCols = append(m.GroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupCols) == 0 {
					m.GroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupCols = append(m.GroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, AggregatorSpec_Aggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedGroupCols = append(m.OrderedGroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedGroupCols) == 0 {
					m.OrderedGroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedGroupCols = append(m.OrderedGroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedGroupCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AggregatorSpec_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec_Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			m.Func = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Func |= (AggregatorSpec_Func(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterColIdx = &v
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColIdx = append(m.ColIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColIdx) == 0 {
					m.ColIdx = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColIdx = append(m.ColIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, Expression{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedColumns = append(m.GeneratedColumns, &types.T{})
			if err := m.GeneratedColumns[len(m.GeneratedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NumColsPerGen = append(m.NumColsPerGen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NumColsPerGen) == 0 {
					m.NumColsPerGen = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NumColsPerGen = append(m.NumColsPerGen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColsPerGen", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionBy = append(m.PartitionBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionBy) == 0 {
					m.PartitionBy = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionBy = append(m.PartitionBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowFns = append(m.WindowFns, WindowerSpec_WindowFn{})
			if err := m.WindowFns[len(m.WindowFns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Func) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Func: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Func: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateFunc", wireType)
			}
			var v AggregatorSpec_Func
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AggregatorSpec_Func(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AggregateFunc = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFunc", wireType)
			}
			var v WindowerSpec_WindowFunc
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (WindowerSpec_WindowFunc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowFunc = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (WindowerSpec_Frame_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusion", wireType)
			}
			m.Exclusion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exclusion |= (WindowerSpec_Frame_Exclusion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundType", wireType)
			}
			m.BoundType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoundType |= (WindowerSpec_Frame_BoundType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntOffset", wireType)
			}
			m.IntOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedOffset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypedOffset = append(m.TypedOffset[:0], dAtA[iNdEx:postIndex]...)
			if m.TypedOffset == nil {
				m.TypedOffset = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OffsetType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &WindowerSpec_Frame_Bound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_WindowFn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &WindowerSpec_Frame{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			m.FilterColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsIdxs = append(m.ArgsIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsIdxs) == 0 {
					m.ArgsIdxs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsIdxs = append(m.ArgsIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsIdxs", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputColIdx", wireType)
			}
			m.OutputColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputColIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsSql(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsSql
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessorsSql(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessorsSql = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsSql   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_sql.proto", fileDescriptor_processors_sql_b359f10a859601d7)
}

var fileDescriptor_processors_sql_b359f10a859601d7 = []byte{
	// 2768 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x39, 0x4d, 0x6f, 0x1b, 0xc7,
	0xd9, 0x5a, 0x7e, 0x48, 0xe4, 0xc3, 0x0f, 0x8d, 0xc7, 0x4a, 0xcc, 0x28, 0x79, 0x65, 0x99, 0xce,
	0xeb, 0xc8, 0x7e, 0x1d, 0xe9, 0x8d, 0x5a, 0xa4, 0x48, 0x5a, 0x14, 0xa5, 0xc8, 0xa5, 0x4c, 0x99,
	0xda, 0x95, 0x97, 0x4b, 0xc9, 0x49, 0x80, 0x0c, 0x56, 0xe4, 0x88, 0xda, 0x78, 0xb9, 0x4b, 0xcd,
	0x2e, 0x2d, 0x29, 0xc7, 0x5e, 0x7a, 0x2a, 0x50, 0xa0, 0x97, 0x9e, 0x8a, 0xa0, 0x40, 0xd1, 0x3f,
	0xd0, 0x73, 0x4f, 0x3d, 0x18, 0xe8, 0x25, 0xa7, 0x36, 0x40, 0x81, 0xa0, 0x71, 0x6e, 0xfd, 0x03,
	0x45, 0x6f, 0xc5, 0xcc, 0xce, 0xae, 0x96, 0x82, 0xe8, 0x46, 0x8e, 0x13, 0x5f, 0x04, 0xce, 0xf3,
	0x35, 0xcf, 0xf7, 0xf3, 0xcc, 0x0a, 0xde, 0xf4, 0x8f, 0x9c, 0x35, 0x7a, 0x42, 0x7b, 0xb6, 0x7b,
	0xc0, 0xac, 0xd1, 0xfe, 0xda, 0x88, 0x79, 0x3d, 0xea, 0xfb, 0x1e, 0xf3, 0x89, 0x7f, 0xe4, 0xac,
	0x8e, 0x98, 0x17, 0x78, 0xb8, 0xd2, 0xf3, 0x7a, 0x8f, 0x98, 0x67, 0xf5, 0x0e, 0x57, 0x39, 0xb0,
	0x6f, 0xfb, 0x81, 0x7f, 0xe4, 0xb0, 0xb1, 0xbb, 0x78, 0x93, 0xf3, 0xf7, 0xac, 0xc0, 0x72, 0xbc,
	0xc1, 0x5a, 0x9f, 0xfa, 0xbd, 0xd1, 0xfe, 0x9a, 0x1f, 0xb0, 0x71, 0x2f, 0x18, 0x33, 0xda, 0x0f,
	0xd9, 0x17, 0xab, 0x17, 0x10, 0x7d, 0xe2, 0xd9, 0x2e, 0x09, 0x4e, 0x47, 0x54, 0xd2, 0x2c, 0x5f,
	0x40, 0xe3, 0x78, 0xbd, 0x47, 0xb6, 0x3b, 0x90, 0x14, 0xaf, 0x70, 0x0a, 0xce, 0xe1, 0x87, 0x7f,
	0x25, 0x78, 0xf1, 0xbc, 0x05, 0x7d, 0x2b, 0xb0, 0x24, 0xee, 0x7f, 0x9f, 0x61, 0xdd, 0xbe, 0xe5,
	0x47, 0x77, 0xdf, 0xe1, 0x64, 0xde, 0x28, 0x58, 0xb3, 0xdd, 0xc7, 0x94, 0x05, 0xb4, 0x4f, 0x4f,
	0x46, 0x6c, 0xcd, 0x1f, 0x59, 0x2e, 0xe1, 0xbf, 0xa8, 0xef, 0xdb, 0x9e, 0x2b, 0x69, 0x17, 0x06,
	0xde, 0xc0, 0x13, 0x3f, 0xd7, 0xf8, 0xaf, 0x10, 0x5a, 0xfd, 0xb5, 0x02, 0xe5, 0x5d, 0xcb, 0x19,
	0x53, 0xbf, 0xee, 0x31, 0xda, 0x19, 0xd1, 0x1e, 0xae, 0xc3, 0x5c, 0xcf, 0x73, 0xc6, 0x43, 0xd7,
	0xaf, 0x28, 0xcb, 0xe9, 0x95, 0xc2, 0xfa, 0xcd, 0xd5, 0x69, 0x5e, 0x5c, 0x6d, 0x58, 0xc1, 0x78,
	0xd8, 0x72, 0x0f, 0xbc, 0x8d, 0xcc, 0x93, 0x2f, 0xaf, 0xcf, 0x18, 0x11, 0x27, 0x7e, 0x1d, 0xf2,
	0xcc, 0x3a, 0x26, 0xfb, 0xa7, 0x01, 0xf5, 0x2b, 0xa9, 0xe5, 0xf4, 0x4a, 0xd1, 0xc8, 0x31, 0xeb,
	0x78, 0x83, 0x9f, 0xf1, 0x75, 0xc8, 0xb9, 0xe3, 0x21, 0x61, 0xde, 0xb1, 0x5f, 0x49, 0x2f, 0x2b,
	0x2b, 0x99, 0x88, 0xdb, 0x1d, 0x0f, 0x0d, 0xef, 0xd8, 0xaf, 0xfe, 0x3d, 0x0b, 0xf3, 0xa6, 0xb5,
	0xef, 0x50, 0x83, 0x5a, 0x7d, 0xca, 0x84, 0x5a, 0x1b, 0x90, 0x0d, 0x38, 0xa8, 0xa2, 0x2c, 0x2b,
	0x2b, 0x85, 0xf5, 0x5b, 0xe7, 0x94, 0xf2, 0x8f, 0x1c, 0xe1, 0x18, 0xc1, 0xd6, 0xa0, 0x7e, 0x8f,
	0xd9, 0xa3, 0xc0, 0x63, 0x52, 0x72, 0xc8, 0x8a, 0x6f, 0x40, 0xde, 0x76, 0xfb, 0xf4, 0x84, 0xd8,
	0xfd, 0x93, 0x4a, 0x6a, 0x59, 0x59, 0x29, 0x49, 0x7c, 0x4e, 0x80, 0x5b, 0xfd, 0x13, 0xbc, 0x04,
	0x73, 0x8c, 0x3e, 0xa6, 0xcc, 0xa7, 0x42, 0xb5, 0x5c, 0xa4, 0x9a, 0x04, 0x62, 0x15, 0xb2, 0xdc,
	0xbf, 0x7e, 0x25, 0x23, 0x7c, 0x73, 0x7b, 0xba, 0x6f, 0x26, 0x0c, 0xb0, 0xdc, 0x48, 0x13, 0xc1,
	0x8d, 0x6f, 0x02, 0x38, 0xf6, 0xd0, 0x0e, 0xc8, 0xa1, 0xed, 0x06, 0x95, 0xec, 0xb2, 0xb2, 0x92,
	0x96, 0x04, 0x79, 0x01, 0xbf, 0x67, 0xbb, 0x01, 0xf7, 0x93, 0xed, 0x93, 0xde, 0x21, 0xed, 0x3d,
	0xaa, 0xcc, 0x26, 0x95, 0xb1, 0xfd, 0x3a, 0x07, 0x62, 0x0d, 0xe0, 0xb1, 0xed, 0xdb, 0xfb, 0xb6,
	0x63, 0x07, 0xa7, 0x95, 0xb9, 0x65, 0x65, 0xa5, 0xbc, 0xbe, 0x32, 0x5d, 0xa3, 0x4e, 0xcf, 0x72,
	0x77, 0x63, 0x7a, 0x29, 0x2c, 0x21, 0x01, 0xff, 0x18, 0xae, 0x0d, 0xad, 0x13, 0x12, 0xd8, 0x43,
	0xea, 0x07, 0xd6, 0x70, 0x44, 0xac, 0x01, 0x25, 0xae, 0xe5, 0x7a, 0x7e, 0x25, 0x9f, 0x88, 0xd3,
	0xc2, 0xd0, 0x3a, 0x31, 0x23, 0x9a, 0xda, 0x80, 0x6a, 0x9c, 0x02, 0x7f, 0x04, 0x48, 0xe6, 0x3d,
	0xf1, 0x03, 0x46, 0xdd, 0x41, 0x70, 0x58, 0x01, 0xa1, 0xd2, 0x9d, 0x29, 0xb1, 0xe2, 0xfa, 0xb4,
	0x43, 0x96, 0x8e, 0xe4, 0x90, 0x37, 0xcc, 0x3b, 0x93, 0x60, 0xbc, 0x0f, 0x57, 0x23, 0xe1, 0xc7,
	0x96, 0x1d, 0x90, 0x91, 0xe7, 0xd8, 0xbd, 0xd3, 0x4a, 0x41, 0xc8, 0xbf, 0xfb, 0xdf, 0xe5, 0xef,
	0x59, 0x76, 0xb0, 0x23, 0x78, 0xe4, 0x0d, 0x57, 0x9c, 0xf3, 0x08, 0x7c, 0x0b, 0x0a, 0x23, 0x8b,
	0x59, 0x8e, 0x43, 0x1d, 0xfb, 0x53, 0x5a, 0x29, 0x26, 0x3c, 0x9e, 0x44, 0xe0, 0x75, 0xc0, 0x87,
	0x96, 0x4f, 0xfc, 0x53, 0x3f, 0xa0, 0x43, 0x12, 0xd5, 0x4a, 0x39, 0x41, 0x8e, 0x0e, 0x2d, 0xbf,
	0x23, 0xd0, 0xf5, 0x10, 0xbb, 0x95, 0xc9, 0xe5, 0x50, 0x7e, 0x2b, 0x93, 0x2b, 0xa1, 0x72, 0xf5,
	0xdf, 0x69, 0xa8, 0xb4, 0x78, 0xbe, 0x75, 0x1e, 0xd9, 0xa3, 0x97, 0x94, 0xe6, 0x71, 0x1a, 0xa7,
	0xbf, 0x55, 0x1a, 0x4f, 0x26, 0x60, 0xe6, 0x5b, 0x27, 0x60, 0xa2, 0xfa, 0xb2, 0x17, 0x55, 0xdf,
	0x45, 0x39, 0x36, 0xfb, 0x1d, 0xe7, 0xd8, 0xdc, 0x0b, 0xcc, 0xb1, 0xea, 0x1f, 0x66, 0xa1, 0xbc,
	0xe5, 0xd9, 0xee, 0xf7, 0x1f, 0xf1, 0xdb, 0x50, 0x76, 0x3c, 0xef, 0xd1, 0x78, 0x14, 0x67, 0x2c,
	0x0f, 0x7d, 0x69, 0x23, 0x85, 0x14, 0xa3, 0x14, 0x62, 0x64, 0xb2, 0xf2, 0x09, 0xe0, 0x85, 0x13,
	0x44, 0x84, 0xb4, 0xb0, 0xfe, 0xe6, 0xf4, 0x90, 0xaa, 0xf1, 0x9c, 0x91, 0x37, 0xce, 0x7a, 0x2e,
	0x87, 0xe1, 0xf7, 0x20, 0xc3, 0xa7, 0x9d, 0x0c, 0xcf, 0xf5, 0x29, 0x56, 0x71, 0x5f, 0x98, 0xa7,
	0x23, 0x2a, 0x99, 0x05, 0xcb, 0x0b, 0x6f, 0x6b, 0xef, 0xc1, 0xab, 0x93, 0xa6, 0x13, 0x8b, 0x51,
	0xf2, 0x88, 0x9e, 0x56, 0x72, 0x89, 0x24, 0xbb, 0x3a, 0xe1, 0x84, 0x1a, 0xa3, 0xf7, 0xe9, 0xe9,
	0x85, 0x09, 0x97, 0xff, 0x8e, 0x13, 0x0e, 0x5e, 0x64, 0x53, 0x7b, 0x07, 0xae, 0x0c, 0x2d, 0xdb,
	0x0d, 0x2c, 0xdb, 0x25, 0x1e, 0xeb, 0x53, 0x66, 0xbb, 0x03, 0xd1, 0x36, 0xe3, 0x5e, 0x15, 0xa1,
	0x75, 0x89, 0x9d, 0xd2, 0xdf, 0x4a, 0xcf, 0xea, 0x6f, 0xb8, 0x01, 0x6f, 0x38, 0xf4, 0x20, 0x20,
	0x62, 0x3b, 0x3a, 0xb6, 0x83, 0x43, 0x32, 0xb2, 0x6c, 0x46, 0xfb, 0x02, 0x40, 0xd9, 0x44, 0x77,
	0xac, 0x70, 0x4a, 0x1e, 0xf8, 0x3d, 0x3b, 0x38, 0xdc, 0x11, 0x64, 0x5b, 0x82, 0x6a, 0x2b, 0x93,
	0xcb, 0xa2, 0xd9, 0xad, 0x4c, 0xae, 0x88, 0x4a, 0x7c, 0x33, 0x81, 0x8e, 0xc7, 0x02, 0x59, 0x25,
	0x0f, 0x60, 0xde, 0x1b, 0x07, 0xa3, 0x71, 0x70, 0x66, 0x45, 0x58, 0x2f, 0xd5, 0xe9, 0x89, 0x11,
	0x59, 0x24, 0xef, 0x2d, 0x87, 0x02, 0x92, 0x76, 0x46, 0xb2, 0xc8, 0xd0, 0x0a, 0x7a, 0x87, 0xc4,
	0xa1, 0xee, 0x44, 0xf5, 0xa0, 0x08, 0xbf, 0xcd, 0xd1, 0x6d, 0xea, 0x56, 0xff, 0xa4, 0x40, 0xb1,
	0x61, 0xfb, 0x81, 0xed, 0xf6, 0x02, 0xa1, 0xd7, 0x5b, 0x30, 0x2f, 0x88, 0x68, 0x9f, 0x24, 0xb7,
	0xa6, 0x92, 0x51, 0x96, 0xe0, 0xc8, 0x43, 0xb7, 0x01, 0xf5, 0x25, 0x63, 0x4c, 0x99, 0x12, 0x94,
	0xf3, 0x11, 0x3c, 0x22, 0x5d, 0x07, 0xec, 0x8e, 0x1d, 0x27, 0x4c, 0xd3, 0x08, 0x39, 0xb1, 0x8e,
	0x20, 0x81, 0xaf, 0x31, 0x1a, 0xe9, 0x82, 0x6f, 0x41, 0x91, 0x32, 0xe6, 0x31, 0xe2, 0xb9, 0xa4,
	0x3f, 0x1e, 0x89, 0xc2, 0xcd, 0x47, 0xb5, 0x20, 0x30, 0xba, 0xdb, 0x18, 0x8f, 0xaa, 0x08, 0xca,
	0x3a, 0xeb, 0xdb, 0xae, 0xc5, 0x2b, 0x83, 0x5b, 0x50, 0xfd, 0x4d, 0x1a, 0xd0, 0x87, 0xf6, 0xe0,
	0x53, 0x6b, 0x10, 0x46, 0x41, 0x98, 0xd5, 0x80, 0x59, 0xd1, 0x59, 0xa2, 0x1d, 0xf0, 0x72, 0x5d,
	0x49, 0xf2, 0xe2, 0x26, 0x00, 0x3d, 0x9a, 0xb0, 0xb6, 0xb0, 0x7e, 0x63, 0x7a, 0xbc, 0xa4, 0xfd,
	0xd1, 0x22, 0x44, 0x8f, 0xce, 0x7c, 0x57, 0x0e, 0xdb, 0x9b, 0x17, 0xaa, 0x3e, 0xd1, 0xbb, 0x04,
	0x46, 0xda, 0xf4, 0x82, 0x7a, 0xd7, 0x7d, 0x28, 0x1e, 0xd8, 0x27, 0xb4, 0x4f, 0x1e, 0x8b, 0xd5,
	0xb8, 0x92, 0x15, 0x9a, 0x3f, 0xa3, 0x05, 0x4d, 0xae, 0xd0, 0x46, 0x41, 0x70, 0x87, 0xc0, 0x6f,
	0xd1, 0x08, 0xab, 0x7f, 0x4d, 0xc3, 0xfc, 0x36, 0x65, 0x03, 0x9a, 0x88, 0xcc, 0x36, 0x94, 0x44,
	0xa5, 0x3d, 0x77, 0x19, 0x14, 0x39, 0x7b, 0x5c, 0x04, 0x3a, 0x94, 0x99, 0x3d, 0x38, 0x4c, 0xc8,
	0x4b, 0x5d, 0x52, 0x5e, 0x49, 0xf0, 0xc7, 0x02, 0x13, 0x01, 0xc8, 0xbe, 0x8c, 0xe1, 0x71, 0x1b,
	0x4a, 0xbc, 0x38, 0x08, 0x3d, 0x1a, 0x5b, 0xf1, 0xfc, 0x88, 0xea, 0xa6, 0xc8, 0x51, 0xaa, 0xc4,
	0xe0, 0xf7, 0xe1, 0x9a, 0x70, 0xe5, 0x59, 0x8e, 0x4e, 0x19, 0x0c, 0xf4, 0x20, 0x50, 0x8f, 0x26,
	0x07, 0xc3, 0x4f, 0xa0, 0x12, 0xfa, 0xed, 0x02, 0xe6, 0x7c, 0x82, 0x79, 0x41, 0x50, 0x9d, 0xe3,
	0xae, 0xfe, 0x33, 0x05, 0xe5, 0x7b, 0x96, 0x7f, 0x98, 0x88, 0xeb, 0x1d, 0x98, 0x3f, 0xa7, 0x4c,
	0xd8, 0x48, 0xe4, 0x80, 0x4e, 0xaa, 0x80, 0xef, 0x02, 0x3a, 0x7f, 0x79, 0xd8, 0x4b, 0x04, 0x71,
	0x79, 0xf2, 0xca, 0x97, 0x1e, 0x91, 0x97, 0xe6, 0xe6, 0xad, 0x4c, 0x6e, 0x0e, 0xe5, 0xaa, 0x5f,
	0xa6, 0x01, 0xb7, 0xe4, 0x03, 0x39, 0xe1, 0xf0, 0xef, 0x69, 0xef, 0xd2, 0xa1, 0x14, 0xbd, 0xce,
	0x9f, 0xb7, 0x2d, 0x15, 0x23, 0x01, 0x22, 0x12, 0x2f, 0x3b, 0x9c, 0x17, 0x6e, 0x14, 0x73, 0xcf,
	0xdc, 0x28, 0xf6, 0xe0, 0x96, 0x1c, 0xde, 0x03, 0xe6, 0x89, 0x35, 0xcc, 0x0d, 0x6c, 0x77, 0x6c,
	0x05, 0xb6, 0xe7, 0x92, 0x03, 0x8f, 0x11, 0x91, 0x1f, 0xcc, 0x3b, 0x9e, 0x48, 0x88, 0x1b, 0x21,
	0xcf, 0x26, 0x67, 0xa9, 0x27, 0x38, 0x9a, 0x1e, 0x6b, 0xd3, 0x83, 0xc0, 0xf0, 0x8e, 0xb7, 0x32,
	0xb9, 0x34, 0xca, 0x54, 0x7f, 0x97, 0x86, 0x85, 0x28, 0xc0, 0x4d, 0xdb, 0x09, 0x28, 0x93, 0x21,
	0x5e, 0x05, 0x14, 0xfb, 0xbe, 0xe7, 0x39, 0x22, 0x4a, 0x4a, 0x22, 0x4a, 0xe5, 0x08, 0x5b, 0xf7,
	0x1c, 0x1e, 0xab, 0x8f, 0xcf, 0xc7, 0x2a, 0xec, 0x85, 0x3f, 0x38, 0xe7, 0x1e, 0x6f, 0x14, 0xac,
	0x26, 0xbf, 0xb8, 0xac, 0xf2, 0x87, 0xd1, 0x99, 0xab, 0x77, 0x98, 0x17, 0x78, 0x17, 0x86, 0xee,
	0x13, 0xb8, 0x32, 0x62, 0x94, 0x1c, 0x48, 0x1d, 0x89, 0x3f, 0xa2, 0x3d, 0x11, 0x82, 0xc2, 0xfa,
	0x4f, 0xa7, 0x07, 0xf1, 0x22, 0xd3, 0x56, 0x77, 0x18, 0x4d, 0x9e, 0x8d, 0xf9, 0xd1, 0x24, 0x60,
	0xf1, 0x97, 0x0a, 0xcc, 0x9f, 0x23, 0xc2, 0x5b, 0x00, 0x67, 0xdf, 0x85, 0x64, 0xde, 0x5f, 0x26,
	0x7b, 0x12, 0xdc, 0x78, 0x55, 0x66, 0x50, 0xe8, 0xa2, 0xc5, 0xf3, 0x19, 0x44, 0x87, 0xab, 0xe1,
	0xc7, 0x2e, 0x53, 0xce, 0xb2, 0xbf, 0xe4, 0xa0, 0x5c, 0x1b, 0x0c, 0x18, 0x1d, 0x58, 0x81, 0x17,
	0xaa, 0x73, 0x03, 0x20, 0xca, 0x07, 0x27, 0xd9, 0xc0, 0xf2, 0x83, 0x30, 0xe4, 0x8e, 0x8f, 0x3f,
	0x86, 0xa2, 0x25, 0x99, 0x6c, 0x2f, 0x7e, 0xae, 0xfe, 0x70, 0xba, 0xce, 0x93, 0x57, 0xc4, 0xc7,
	0x44, 0x31, 0x25, 0xe5, 0xe1, 0xff, 0x97, 0x3b, 0x20, 0xed, 0x93, 0x84, 0x2a, 0x99, 0x58, 0x15,
	0x24, 0xb1, 0x9b, 0xb1, 0x46, 0x9b, 0xd2, 0xee, 0xac, 0xa8, 0x9c, 0xb7, 0xbf, 0xb1, 0x26, 0xe7,
	0xeb, 0x68, 0xf1, 0x17, 0x29, 0x28, 0x24, 0xd4, 0xe3, 0x82, 0x0f, 0xc6, 0x6e, 0x4f, 0x84, 0xe5,
	0x32, 0x82, 0x9b, 0x63, 0xb7, 0x17, 0x09, 0xe6, 0x02, 0xf0, 0x32, 0xe4, 0xe2, 0xa5, 0x31, 0x95,
	0xa8, 0xa7, 0x18, 0x8a, 0xdf, 0x84, 0x72, 0x98, 0x83, 0x71, 0x55, 0xf0, 0xa6, 0x54, 0x32, 0x8a,
	0x21, 0x54, 0x56, 0xc3, 0x35, 0xf1, 0x21, 0x50, 0xa0, 0xb3, 0x62, 0x51, 0x9d, 0xed, 0x85, 0x88,
	0x7b, 0x90, 0xb7, 0xd8, 0x60, 0x3c, 0xa4, 0x6e, 0xe0, 0x57, 0x66, 0x45, 0x44, 0x2e, 0x93, 0x45,
	0x67, 0xcc, 0xb2, 0x7e, 0x7f, 0x9e, 0x81, 0x0c, 0xb7, 0x02, 0x23, 0x28, 0xd6, 0xb4, 0x0f, 0x88,
	0xa6, 0x9b, 0x44, 0xeb, 0xb6, 0xdb, 0x68, 0x06, 0xcf, 0x41, 0xba, 0xb6, 0xbb, 0x89, 0x14, 0x5c,
	0x84, 0xdc, 0x86, 0xae, 0xb7, 0x49, 0x4d, 0x6b, 0xa0, 0x14, 0x2e, 0xc0, 0x9c, 0x38, 0xe9, 0x06,
	0x4a, 0xe3, 0x32, 0x40, 0x5d, 0xd7, 0xea, 0x35, 0x93, 0xd4, 0x36, 0x37, 0x51, 0x06, 0xe7, 0x21,
	0x5b, 0xd7, 0xbb, 0x9a, 0x89, 0xb2, 0x9c, 0x7d, 0xbb, 0xf6, 0x10, 0xcd, 0x89, 0x1f, 0x2d, 0x0d,
	0xe5, 0x30, 0xc0, 0x6c, 0xc7, 0x6c, 0x34, 0xd4, 0x5d, 0x94, 0xe7, 0xc0, 0x4e, 0x77, 0x1b, 0x01,
	0x17, 0xd7, 0xe9, 0x6e, 0x93, 0x96, 0x66, 0xa2, 0x02, 0xbf, 0x69, 0xb7, 0x66, 0xb4, 0x6a, 0x5a,
	0x5d, 0x45, 0x45, 0x8e, 0x7a, 0xa8, 0x1b, 0x42, 0x72, 0x29, 0xbc, 0xa9, 0xab, 0x99, 0xc4, 0xd0,
	0xf7, 0x3a, 0xa8, 0x2c, 0xf8, 0x1e, 0x18, 0x8d, 0x56, 0xb3, 0x89, 0xe6, 0x31, 0x86, 0x72, 0xb3,
	0xa5, 0xd5, 0xda, 0x24, 0xe6, 0x46, 0xdc, 0xa0, 0x10, 0x26, 0xef, 0xbc, 0x82, 0x4b, 0x90, 0xaf,
	0x19, 0x46, 0xed, 0x03, 0x21, 0x11, 0xf3, 0xcb, 0xb6, 0x3a, 0xba, 0x26, 0x4e, 0x57, 0x39, 0x92,
	0x9f, 0x36, 0xc4, 0x71, 0x81, 0x5f, 0xd7, 0x31, 0x8d, 0x96, 0xb6, 0x29, 0xce, 0xaf, 0x08, 0xab,
	0x5b, 0xa6, 0x70, 0xc1, 0xab, 0xdc, 0x10, 0x7e, 0xd0, 0x0d, 0x74, 0x0d, 0xe7, 0x20, 0x53, 0xd7,
	0x0d, 0x03, 0x55, 0x70, 0x05, 0x16, 0x76, 0x54, 0xa3, 0xae, 0x6a, 0x66, 0xab, 0xad, 0x92, 0x46,
	0xab, 0x53, 0x27, 0xad, 0xed, 0x9d, 0x36, 0x7a, 0xed, 0x1c, 0xa6, 0xae, 0x6b, 0x66, 0x88, 0x59,
	0xc4, 0x57, 0x61, 0x5e, 0xe8, 0xa0, 0x6f, 0x6c, 0xa9, 0xf5, 0xd0, 0x89, 0xaf, 0xe3, 0x05, 0x40,
	0xa1, 0x2a, 0x09, 0xe8, 0x1b, 0x5c, 0x83, 0xdd, 0x9a, 0x41, 0x76, 0xf4, 0x1d, 0xf4, 0x3f, 0xa1,
	0x7a, 0xdc, 0x2c, 0x71, 0x5e, 0xc2, 0xf3, 0x50, 0xe8, 0x98, 0x64, 0xbb, 0x76, 0x5f, 0x6d, 0xb7,
	0x34, 0x15, 0x5d, 0xe7, 0xe6, 0x74, 0x4c, 0xa2, 0x3e, 0x34, 0x55, 0xcd, 0x44, 0xcb, 0xdc, 0xd6,
	0x8e, 0x49, 0xba, 0x5a, 0x4b, 0xd7, 0xd0, 0x8d, 0x90, 0x9b, 0xd4, 0xf5, 0x76, 0x5b, 0xad, 0x9b,
	0xa8, 0x5a, 0xbd, 0x0b, 0x19, 0x5e, 0x22, 0xdc, 0x96, 0x5a, 0xd7, 0xd4, 0xd1, 0x8c, 0x08, 0x55,
	0xbd, 0xd6, 0xae, 0x19, 0x48, 0xe1, 0xd4, 0x9a, 0xae, 0x11, 0x79, 0x4e, 0x55, 0xff, 0xac, 0x40,
	0x79, 0x87, 0x79, 0x9f, 0xd0, 0x5e, 0xd0, 0xa1, 0xe1, 0x4b, 0xec, 0x67, 0x90, 0xe5, 0xed, 0x29,
	0x7a, 0xb1, 0x5c, 0x26, 0x23, 0x43, 0x46, 0xbc, 0x09, 0x57, 0x06, 0xd4, 0xa5, 0xcc, 0x0a, 0x12,
	0xaf, 0xb9, 0xf0, 0xd5, 0xf2, 0xac, 0xfe, 0x86, 0x62, 0xa6, 0x68, 0xe3, 0x7a, 0x0b, 0x90, 0x3b,
	0x16, 0x4f, 0x67, 0x9f, 0x8c, 0x28, 0x23, 0x03, 0xea, 0x86, 0x2f, 0x16, 0xa3, 0xe4, 0x8e, 0xf9,
	0x9b, 0xd9, 0xdf, 0xa1, 0x6c, 0x93, 0xba, 0xd5, 0xaf, 0x4a, 0x50, 0xdc, 0xb3, 0xdd, 0xbe, 0x77,
	0x2c, 0x3b, 0xf4, 0xb2, 0xf8, 0x06, 0x19, 0xd8, 0xa2, 0x61, 0x9d, 0xca, 0xa7, 0x64, 0x12, 0x84,
	0x3b, 0x90, 0x3f, 0x16, 0x1c, 0xcd, 0x58, 0xb9, 0xb5, 0xe9, 0xa6, 0x26, 0x85, 0xcb, 0x43, 0x33,
	0xae, 0xc3, 0x58, 0xce, 0xe2, 0x1f, 0x15, 0x59, 0x81, 0x1d, 0x28, 0x45, 0xfd, 0x91, 0x36, 0x9f,
	0xb7, 0x1b, 0x19, 0x93, 0x32, 0xf0, 0x03, 0x00, 0x79, 0x15, 0x97, 0x98, 0x12, 0x12, 0xdf, 0xb9,
	0x9c, 0xce, 0x5c, 0x6a, 0x42, 0xc8, 0xfb, 0x99, 0x27, 0x9f, 0x5d, 0x57, 0x16, 0x3f, 0x9b, 0x83,
	0x6c, 0x93, 0x59, 0x43, 0x8a, 0xef, 0x43, 0x66, 0xe8, 0xf5, 0xa9, 0x54, 0xf7, 0x9b, 0x0a, 0x17,
	0xbc, 0xab, 0xdb, 0x5e, 0x3f, 0xee, 0xcc, 0x5c, 0x08, 0x7e, 0x00, 0xb3, 0xfb, 0xde, 0xd8, 0xed,
	0xfb, 0x53, 0xe6, 0xff, 0xb3, 0xc5, 0x6d, 0x08, 0xd6, 0x68, 0xdf, 0x0a, 0x05, 0xe1, 0x0f, 0x21,
	0x4f, 0x4f, 0x7a, 0xce, 0x58, 0x0c, 0xde, 0xb4, 0x50, 0xf2, 0xdd, 0x4b, 0x49, 0x55, 0x23, 0xee,
	0xf8, 0x75, 0x1c, 0x01, 0x16, 0xff, 0xa5, 0x40, 0x56, 0x5c, 0xca, 0x6f, 0x11, 0xf7, 0xf1, 0x42,
	0x92, 0xae, 0x78, 0xf7, 0xf2, 0xba, 0x27, 0x26, 0xd5, 0x99, 0x38, 0x7c, 0x13, 0xc0, 0x76, 0x03,
	0xe2, 0x1d, 0x1c, 0xf8, 0x34, 0x9c, 0x2b, 0xd1, 0xbf, 0x03, 0xf2, 0xb6, 0x1b, 0xe8, 0x02, 0x8c,
	0x6f, 0x40, 0x91, 0x57, 0x45, 0x3f, 0x22, 0xe3, 0x96, 0x16, 0x8d, 0x82, 0x80, 0x49, 0x92, 0x2d,
	0x28, 0x84, 0x48, 0xf1, 0x4f, 0x34, 0xb9, 0x0d, 0x5f, 0xe2, 0x5f, 0x4c, 0x10, 0x72, 0x73, 0x9d,
	0x16, 0x7f, 0xab, 0xc0, 0x6c, 0xe8, 0x6e, 0xac, 0x41, 0xd6, 0x0f, 0x2c, 0x16, 0xc8, 0xad, 0x66,
	0xfd, 0xf2, 0x66, 0xc7, 0x5f, 0xb6, 0xb9, 0x18, 0xdc, 0x80, 0x34, 0x75, 0xfb, 0x32, 0x01, 0x9e,
	0x43, 0x9a, 0xc1, 0xd9, 0xab, 0x6f, 0x41, 0x86, 0x67, 0x17, 0x1f, 0x49, 0x46, 0x4d, 0xdb, 0x54,
	0xd1, 0x0c, 0xef, 0x6f, 0x62, 0x7a, 0x28, 0xbc, 0xbf, 0x6d, 0x1a, 0x7a, 0x77, 0xa7, 0x83, 0x52,
	0xd5, 0x4f, 0x21, 0x1f, 0xfb, 0x1e, 0x5f, 0x83, 0xab, 0x5d, 0x6d, 0x43, 0xef, 0x6a, 0x0d, 0xb5,
	0x41, 0x76, 0x0c, 0xb5, 0xae, 0x36, 0x5a, 0xda, 0x26, 0x9a, 0x99, 0x44, 0x34, 0xf5, 0x76, 0x5b,
	0xdf, 0xe3, 0x08, 0x85, 0x77, 0x6b, 0xbd, 0xd9, 0xec, 0xa8, 0x66, 0x82, 0x3c, 0x95, 0x80, 0x9e,
	0xd1, 0xa6, 0x79, 0x9b, 0xae, 0x77, 0x0d, 0x43, 0x0d, 0xc7, 0x18, 0xca, 0x54, 0x3f, 0x82, 0x7c,
	0x9c, 0x5d, 0x7c, 0x62, 0x69, 0x3a, 0x51, 0x1f, 0xd6, 0xdb, 0xdd, 0x0e, 0x6f, 0xd4, 0xe2, 0x52,
	0x71, 0x6c, 0xa8, 0x24, 0xc9, 0xa7, 0xe0, 0x2b, 0x50, 0x8a, 0x10, 0xc2, 0x0e, 0x94, 0xe2, 0xdc,
	0x11, 0xc8, 0x6c, 0xa9, 0x1d, 0x94, 0x5e, 0xfc, 0x5b, 0x0a, 0x72, 0x51, 0xdf, 0xc1, 0x6a, 0x62,
	0xc5, 0x29, 0xac, 0xff, 0xdf, 0x37, 0xf5, 0xea, 0xf9, 0x05, 0xa7, 0x01, 0xb9, 0xf8, 0xe1, 0x91,
	0xb9, 0xe4, 0xd7, 0x8a, 0x98, 0x93, 0xbf, 0xff, 0x0e, 0x78, 0xbc, 0xe4, 0x2b, 0xea, 0xee, 0x65,
	0x62, 0x6c, 0x84, 0xac, 0x78, 0x05, 0x26, 0x56, 0x26, 0xb1, 0xcb, 0x67, 0xa3, 0x45, 0x73, 0x62,
	0x99, 0x5a, 0x84, 0x9c, 0xc5, 0x06, 0x7e, 0xab, 0x7f, 0xe2, 0x57, 0xe6, 0x44, 0x57, 0x8f, 0xcf,
	0x5c, 0x4a, 0xf8, 0xd4, 0x91, 0x52, 0x72, 0x89, 0x27, 0xca, 0x04, 0x66, 0x2b, 0x93, 0x4b, 0xa1,
	0xb4, 0xdc, 0x9a, 0x7e, 0xaf, 0x00, 0x9c, 0x75, 0x47, 0x3e, 0x21, 0x0d, 0x7d, 0x8f, 0x68, 0xdd,
	0xed, 0x0d, 0xd5, 0x90, 0x79, 0x56, 0xd3, 0xee, 0x87, 0xb3, 0xb3, 0xa1, 0x6a, 0x1d, 0x95, 0x88,
	0xb3, 0x08, 0x92, 0xdc, 0x04, 0x42, 0x48, 0x9a, 0x0f, 0xea, 0x7a, 0x77, 0x5b, 0xec, 0x0b, 0x66,
	0xb8, 0x40, 0x89, 0x2d, 0x21, 0x5c, 0xa0, 0xda, 0xb5, 0x4d, 0x34, 0xcb, 0xc5, 0xb5, 0xd5, 0x5a,
	0x03, 0xcd, 0xf1, 0xfc, 0x69, 0xb6, 0x8c, 0x8e, 0x49, 0x76, 0x6b, 0xed, 0xae, 0x8a, 0x72, 0x5c,
	0x7e, 0xbb, 0x16, 0x9f, 0xf3, 0x5c, 0x9a, 0x66, 0xde, 0x93, 0x47, 0xb8, 0xf3, 0x23, 0x28, 0x4f,
	0x7e, 0xa1, 0xe7, 0x89, 0xbf, 0xd3, 0xdd, 0x68, 0xb7, 0xea, 0x68, 0x06, 0xbf, 0x06, 0xaf, 0x84,
	0xbf, 0xf9, 0x5a, 0x23, 0x36, 0x3f, 0x89, 0x52, 0x36, 0xde, 0x7e, 0xf2, 0xd5, 0xd2, 0xcc, 0x93,
	0xa7, 0x4b, 0xca, 0xe7, 0x4f, 0x97, 0x94, 0x2f, 0x9e, 0x2e, 0x29, 0xff, 0x78, 0xba, 0xa4, 0xfc,
	0xea, 0xeb, 0xa5, 0x99, 0xcf, 0xbf, 0x5e, 0x9a, 0xf9, 0xe2, 0xeb, 0xa5, 0x99, 0x0f, 0x0b, 0x89,
	0x7f, 0x91, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0x5b, 0xfe, 0xd9, 0x1c, 0x12, 0x20, 0x00, 0x00,
}
