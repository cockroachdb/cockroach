// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_sql.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	fmt "fmt"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	inverted "github.com/cockroachdb/cockroach/pkg/sql/inverted"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ScanVisibility controls which columns are seen by scans - just normal
// columns, or normal columns and also in-progress schema change columns.
type ScanVisibility int32

const (
	ScanVisibility_PUBLIC                ScanVisibility = 0
	ScanVisibility_PUBLIC_AND_NOT_PUBLIC ScanVisibility = 1
)

var ScanVisibility_name = map[int32]string{
	0: "PUBLIC",
	1: "PUBLIC_AND_NOT_PUBLIC",
}

var ScanVisibility_value = map[string]int32{
	"PUBLIC":                0,
	"PUBLIC_AND_NOT_PUBLIC": 1,
}

func (x ScanVisibility) Enum() *ScanVisibility {
	p := new(ScanVisibility)
	*p = x
	return p
}

func (x ScanVisibility) String() string {
	return proto.EnumName(ScanVisibility_name, int32(x))
}

func (x *ScanVisibility) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ScanVisibility_value, data, "ScanVisibility")
	if err != nil {
		return err
	}
	*x = ScanVisibility(value)
	return nil
}

func (ScanVisibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{0}
}

// These mirror the aggregate functions supported by sql/parser. See
// sql/parser/aggregate_builtins.go.
type AggregatorSpec_Func int32

const (
	AggregatorSpec_ANY_NOT_NULL   AggregatorSpec_Func = 0
	AggregatorSpec_AVG            AggregatorSpec_Func = 1
	AggregatorSpec_BOOL_AND       AggregatorSpec_Func = 2
	AggregatorSpec_BOOL_OR        AggregatorSpec_Func = 3
	AggregatorSpec_CONCAT_AGG     AggregatorSpec_Func = 4
	AggregatorSpec_COUNT          AggregatorSpec_Func = 5
	AggregatorSpec_MAX            AggregatorSpec_Func = 7
	AggregatorSpec_MIN            AggregatorSpec_Func = 8
	AggregatorSpec_STDDEV         AggregatorSpec_Func = 9
	AggregatorSpec_SUM            AggregatorSpec_Func = 10
	AggregatorSpec_SUM_INT        AggregatorSpec_Func = 11
	AggregatorSpec_VARIANCE       AggregatorSpec_Func = 12
	AggregatorSpec_XOR_AGG        AggregatorSpec_Func = 13
	AggregatorSpec_COUNT_ROWS     AggregatorSpec_Func = 14
	AggregatorSpec_SQRDIFF        AggregatorSpec_Func = 15
	AggregatorSpec_FINAL_VARIANCE AggregatorSpec_Func = 16
	AggregatorSpec_FINAL_STDDEV   AggregatorSpec_Func = 17
	AggregatorSpec_ARRAY_AGG      AggregatorSpec_Func = 18
	AggregatorSpec_JSON_AGG       AggregatorSpec_Func = 19
	// JSONB_AGG is an alias for JSON_AGG, they do the same thing.
	AggregatorSpec_JSONB_AGG            AggregatorSpec_Func = 20
	AggregatorSpec_STRING_AGG           AggregatorSpec_Func = 21
	AggregatorSpec_BIT_AND              AggregatorSpec_Func = 22
	AggregatorSpec_BIT_OR               AggregatorSpec_Func = 23
	AggregatorSpec_CORR                 AggregatorSpec_Func = 24
	AggregatorSpec_PERCENTILE_DISC_IMPL AggregatorSpec_Func = 25
	AggregatorSpec_PERCENTILE_CONT_IMPL AggregatorSpec_Func = 26
	AggregatorSpec_JSON_OBJECT_AGG      AggregatorSpec_Func = 27
	AggregatorSpec_JSONB_OBJECT_AGG     AggregatorSpec_Func = 28
	AggregatorSpec_VAR_POP              AggregatorSpec_Func = 29
	AggregatorSpec_STDDEV_POP           AggregatorSpec_Func = 30
	AggregatorSpec_ST_MAKELINE          AggregatorSpec_Func = 31
	AggregatorSpec_ST_EXTENT            AggregatorSpec_Func = 32
	AggregatorSpec_ST_UNION             AggregatorSpec_Func = 33
	AggregatorSpec_ST_COLLECT           AggregatorSpec_Func = 34
	AggregatorSpec_COVAR_POP            AggregatorSpec_Func = 35
	AggregatorSpec_COVAR_SAMP           AggregatorSpec_Func = 36
	AggregatorSpec_REGR_INTERCEPT       AggregatorSpec_Func = 37
	AggregatorSpec_REGR_R2              AggregatorSpec_Func = 38
	AggregatorSpec_REGR_SLOPE           AggregatorSpec_Func = 39
	AggregatorSpec_REGR_SXX             AggregatorSpec_Func = 40
	AggregatorSpec_REGR_SYY             AggregatorSpec_Func = 41
	AggregatorSpec_REGR_SXY             AggregatorSpec_Func = 42
	AggregatorSpec_REGR_COUNT           AggregatorSpec_Func = 43
	AggregatorSpec_REGR_AVGX            AggregatorSpec_Func = 44
	AggregatorSpec_REGR_AVGY            AggregatorSpec_Func = 45
)

var AggregatorSpec_Func_name = map[int32]string{
	0:  "ANY_NOT_NULL",
	1:  "AVG",
	2:  "BOOL_AND",
	3:  "BOOL_OR",
	4:  "CONCAT_AGG",
	5:  "COUNT",
	7:  "MAX",
	8:  "MIN",
	9:  "STDDEV",
	10: "SUM",
	11: "SUM_INT",
	12: "VARIANCE",
	13: "XOR_AGG",
	14: "COUNT_ROWS",
	15: "SQRDIFF",
	16: "FINAL_VARIANCE",
	17: "FINAL_STDDEV",
	18: "ARRAY_AGG",
	19: "JSON_AGG",
	20: "JSONB_AGG",
	21: "STRING_AGG",
	22: "BIT_AND",
	23: "BIT_OR",
	24: "CORR",
	25: "PERCENTILE_DISC_IMPL",
	26: "PERCENTILE_CONT_IMPL",
	27: "JSON_OBJECT_AGG",
	28: "JSONB_OBJECT_AGG",
	29: "VAR_POP",
	30: "STDDEV_POP",
	31: "ST_MAKELINE",
	32: "ST_EXTENT",
	33: "ST_UNION",
	34: "ST_COLLECT",
	35: "COVAR_POP",
	36: "COVAR_SAMP",
	37: "REGR_INTERCEPT",
	38: "REGR_R2",
	39: "REGR_SLOPE",
	40: "REGR_SXX",
	41: "REGR_SYY",
	42: "REGR_SXY",
	43: "REGR_COUNT",
	44: "REGR_AVGX",
	45: "REGR_AVGY",
}

var AggregatorSpec_Func_value = map[string]int32{
	"ANY_NOT_NULL":         0,
	"AVG":                  1,
	"BOOL_AND":             2,
	"BOOL_OR":              3,
	"CONCAT_AGG":           4,
	"COUNT":                5,
	"MAX":                  7,
	"MIN":                  8,
	"STDDEV":               9,
	"SUM":                  10,
	"SUM_INT":              11,
	"VARIANCE":             12,
	"XOR_AGG":              13,
	"COUNT_ROWS":           14,
	"SQRDIFF":              15,
	"FINAL_VARIANCE":       16,
	"FINAL_STDDEV":         17,
	"ARRAY_AGG":            18,
	"JSON_AGG":             19,
	"JSONB_AGG":            20,
	"STRING_AGG":           21,
	"BIT_AND":              22,
	"BIT_OR":               23,
	"CORR":                 24,
	"PERCENTILE_DISC_IMPL": 25,
	"PERCENTILE_CONT_IMPL": 26,
	"JSON_OBJECT_AGG":      27,
	"JSONB_OBJECT_AGG":     28,
	"VAR_POP":              29,
	"STDDEV_POP":           30,
	"ST_MAKELINE":          31,
	"ST_EXTENT":            32,
	"ST_UNION":             33,
	"ST_COLLECT":           34,
	"COVAR_POP":            35,
	"COVAR_SAMP":           36,
	"REGR_INTERCEPT":       37,
	"REGR_R2":              38,
	"REGR_SLOPE":           39,
	"REGR_SXX":             40,
	"REGR_SYY":             41,
	"REGR_SXY":             42,
	"REGR_COUNT":           43,
	"REGR_AVGX":            44,
	"REGR_AVGY":            45,
}

func (x AggregatorSpec_Func) Enum() *AggregatorSpec_Func {
	p := new(AggregatorSpec_Func)
	*p = x
	return p
}

func (x AggregatorSpec_Func) String() string {
	return proto.EnumName(AggregatorSpec_Func_name, int32(x))
}

func (x *AggregatorSpec_Func) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Func_value, data, "AggregatorSpec_Func")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Func(value)
	return nil
}

func (AggregatorSpec_Func) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{13, 0}
}

type AggregatorSpec_Type int32

const (
	// This setting exists just for backwards compatibility; it's equivalent to
	// SCALAR when there are no grouping columns, and to NON_SCALAR when there
	// are grouping columns.
	AggregatorSpec_AUTO AggregatorSpec_Type = 0
	// A scalar aggregation has no grouping columns and always returns one
	// result row.
	AggregatorSpec_SCALAR AggregatorSpec_Type = 1
	// A non-scalar aggregation returns no rows if there are no input rows; it
	// may or may not have grouping columns.
	AggregatorSpec_NON_SCALAR AggregatorSpec_Type = 2
)

var AggregatorSpec_Type_name = map[int32]string{
	0: "AUTO",
	1: "SCALAR",
	2: "NON_SCALAR",
}

var AggregatorSpec_Type_value = map[string]int32{
	"AUTO":       0,
	"SCALAR":     1,
	"NON_SCALAR": 2,
}

func (x AggregatorSpec_Type) Enum() *AggregatorSpec_Type {
	p := new(AggregatorSpec_Type)
	*p = x
	return p
}

func (x AggregatorSpec_Type) String() string {
	return proto.EnumName(AggregatorSpec_Type_name, int32(x))
}

func (x *AggregatorSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AggregatorSpec_Type_value, data, "AggregatorSpec_Type")
	if err != nil {
		return err
	}
	*x = AggregatorSpec_Type(value)
	return nil
}

func (AggregatorSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{13, 1}
}

type WindowerSpec_WindowFunc int32

const (
	// These mirror window functions from window_builtins.go.
	WindowerSpec_ROW_NUMBER   WindowerSpec_WindowFunc = 0
	WindowerSpec_RANK         WindowerSpec_WindowFunc = 1
	WindowerSpec_DENSE_RANK   WindowerSpec_WindowFunc = 2
	WindowerSpec_PERCENT_RANK WindowerSpec_WindowFunc = 3
	WindowerSpec_CUME_DIST    WindowerSpec_WindowFunc = 4
	WindowerSpec_NTILE        WindowerSpec_WindowFunc = 5
	WindowerSpec_LAG          WindowerSpec_WindowFunc = 6
	WindowerSpec_LEAD         WindowerSpec_WindowFunc = 7
	WindowerSpec_FIRST_VALUE  WindowerSpec_WindowFunc = 8
	WindowerSpec_LAST_VALUE   WindowerSpec_WindowFunc = 9
	WindowerSpec_NTH_VALUE    WindowerSpec_WindowFunc = 10
)

var WindowerSpec_WindowFunc_name = map[int32]string{
	0:  "ROW_NUMBER",
	1:  "RANK",
	2:  "DENSE_RANK",
	3:  "PERCENT_RANK",
	4:  "CUME_DIST",
	5:  "NTILE",
	6:  "LAG",
	7:  "LEAD",
	8:  "FIRST_VALUE",
	9:  "LAST_VALUE",
	10: "NTH_VALUE",
}

var WindowerSpec_WindowFunc_value = map[string]int32{
	"ROW_NUMBER":   0,
	"RANK":         1,
	"DENSE_RANK":   2,
	"PERCENT_RANK": 3,
	"CUME_DIST":    4,
	"NTILE":        5,
	"LAG":          6,
	"LEAD":         7,
	"FIRST_VALUE":  8,
	"LAST_VALUE":   9,
	"NTH_VALUE":    10,
}

func (x WindowerSpec_WindowFunc) Enum() *WindowerSpec_WindowFunc {
	p := new(WindowerSpec_WindowFunc)
	*p = x
	return p
}

func (x WindowerSpec_WindowFunc) String() string {
	return proto.EnumName(WindowerSpec_WindowFunc_name, int32(x))
}

func (x *WindowerSpec_WindowFunc) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_WindowFunc_value, data, "WindowerSpec_WindowFunc")
	if err != nil {
		return err
	}
	*x = WindowerSpec_WindowFunc(value)
	return nil
}

func (WindowerSpec_WindowFunc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 0}
}

// Mode indicates which mode of framing is used.
type WindowerSpec_Frame_Mode int32

const (
	// RANGE specifies frame in terms of logical range (e.g. 1 unit cheaper).
	WindowerSpec_Frame_RANGE WindowerSpec_Frame_Mode = 0
	// ROWS specifies frame in terms of physical offsets (e.g. 1 row before).
	WindowerSpec_Frame_ROWS WindowerSpec_Frame_Mode = 1
	// GROUPS specifies frame in terms of peer groups (where "peers" mean
	// rows not distinct in the ordering columns).
	WindowerSpec_Frame_GROUPS WindowerSpec_Frame_Mode = 2
)

var WindowerSpec_Frame_Mode_name = map[int32]string{
	0: "RANGE",
	1: "ROWS",
	2: "GROUPS",
}

var WindowerSpec_Frame_Mode_value = map[string]int32{
	"RANGE":  0,
	"ROWS":   1,
	"GROUPS": 2,
}

func (x WindowerSpec_Frame_Mode) Enum() *WindowerSpec_Frame_Mode {
	p := new(WindowerSpec_Frame_Mode)
	*p = x
	return p
}

func (x WindowerSpec_Frame_Mode) String() string {
	return proto.EnumName(WindowerSpec_Frame_Mode_name, int32(x))
}

func (x *WindowerSpec_Frame_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Mode_value, data, "WindowerSpec_Frame_Mode")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Mode(value)
	return nil
}

func (WindowerSpec_Frame_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1, 0}
}

// BoundType indicates which type of boundary is used.
type WindowerSpec_Frame_BoundType int32

const (
	WindowerSpec_Frame_UNBOUNDED_PRECEDING WindowerSpec_Frame_BoundType = 0
	WindowerSpec_Frame_UNBOUNDED_FOLLOWING WindowerSpec_Frame_BoundType = 1
	// Offsets are stored within Bound.
	WindowerSpec_Frame_OFFSET_PRECEDING WindowerSpec_Frame_BoundType = 2
	WindowerSpec_Frame_OFFSET_FOLLOWING WindowerSpec_Frame_BoundType = 3
	WindowerSpec_Frame_CURRENT_ROW      WindowerSpec_Frame_BoundType = 4
)

var WindowerSpec_Frame_BoundType_name = map[int32]string{
	0: "UNBOUNDED_PRECEDING",
	1: "UNBOUNDED_FOLLOWING",
	2: "OFFSET_PRECEDING",
	3: "OFFSET_FOLLOWING",
	4: "CURRENT_ROW",
}

var WindowerSpec_Frame_BoundType_value = map[string]int32{
	"UNBOUNDED_PRECEDING": 0,
	"UNBOUNDED_FOLLOWING": 1,
	"OFFSET_PRECEDING":    2,
	"OFFSET_FOLLOWING":    3,
	"CURRENT_ROW":         4,
}

func (x WindowerSpec_Frame_BoundType) Enum() *WindowerSpec_Frame_BoundType {
	p := new(WindowerSpec_Frame_BoundType)
	*p = x
	return p
}

func (x WindowerSpec_Frame_BoundType) String() string {
	return proto.EnumName(WindowerSpec_Frame_BoundType_name, int32(x))
}

func (x *WindowerSpec_Frame_BoundType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_BoundType_value, data, "WindowerSpec_Frame_BoundType")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_BoundType(value)
	return nil
}

func (WindowerSpec_Frame_BoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1, 1}
}

// Exclusion specifies the type of frame exclusion.
type WindowerSpec_Frame_Exclusion int32

const (
	WindowerSpec_Frame_NO_EXCLUSION        WindowerSpec_Frame_Exclusion = 0
	WindowerSpec_Frame_EXCLUDE_CURRENT_ROW WindowerSpec_Frame_Exclusion = 1
	WindowerSpec_Frame_EXCLUDE_GROUP       WindowerSpec_Frame_Exclusion = 2
	WindowerSpec_Frame_EXCLUDE_TIES        WindowerSpec_Frame_Exclusion = 3
)

var WindowerSpec_Frame_Exclusion_name = map[int32]string{
	0: "NO_EXCLUSION",
	1: "EXCLUDE_CURRENT_ROW",
	2: "EXCLUDE_GROUP",
	3: "EXCLUDE_TIES",
}

var WindowerSpec_Frame_Exclusion_value = map[string]int32{
	"NO_EXCLUSION":        0,
	"EXCLUDE_CURRENT_ROW": 1,
	"EXCLUDE_GROUP":       2,
	"EXCLUDE_TIES":        3,
}

func (x WindowerSpec_Frame_Exclusion) Enum() *WindowerSpec_Frame_Exclusion {
	p := new(WindowerSpec_Frame_Exclusion)
	*p = x
	return p
}

func (x WindowerSpec_Frame_Exclusion) String() string {
	return proto.EnumName(WindowerSpec_Frame_Exclusion_name, int32(x))
}

func (x *WindowerSpec_Frame_Exclusion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WindowerSpec_Frame_Exclusion_value, data, "WindowerSpec_Frame_Exclusion")
	if err != nil {
		return err
	}
	*x = WindowerSpec_Frame_Exclusion(value)
	return nil
}

func (WindowerSpec_Frame_Exclusion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1, 2}
}

// ValuesCoreSpec is the core of a processor that has no inputs and generates
// "pre-canned" rows. This is not intended to be used for very large datasets.
type ValuesCoreSpec struct {
	// There is one DatumInfo for each element in a row. Can be empty, in which
	// case raw_bytes will be empty.
	Columns []DatumInfo `protobuf:"bytes,1,rep,name=columns" json:"columns"`
	// The number of rows is especially useful when we have zero columns.
	NumRows uint64 `protobuf:"varint,3,opt,name=num_rows,json=numRows" json:"num_rows"`
	// Each raw block encodes one row; each datum is encoded according to the
	// corresponding DatumInfo. As an optimization, if columns is empty, this will
	// be empty rather than containing empty byte strings.
	RawBytes [][]byte `protobuf:"bytes,2,rep,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
}

func (m *ValuesCoreSpec) Reset()         { *m = ValuesCoreSpec{} }
func (m *ValuesCoreSpec) String() string { return proto.CompactTextString(m) }
func (*ValuesCoreSpec) ProtoMessage()    {}
func (*ValuesCoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{0}
}
func (m *ValuesCoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValuesCoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ValuesCoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValuesCoreSpec.Merge(m, src)
}
func (m *ValuesCoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *ValuesCoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ValuesCoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ValuesCoreSpec proto.InternalMessageInfo

// TableReaderSpec is the specification for a "table reader". A table reader
// performs KV operations to retrieve rows for a table and outputs the desired
// columns of the rows that pass a filter expression.
//
// The "internal columns" of a TableReader (see ProcessorSpec) are all the
// columns of the table. Internally, only the values for the columns specified
// by needed_columns are to be populated. If is_check is set, the TableReader
// will run additional data checking procedures and the "internal columns" are:
//  - Error type (string).
//  - Primary key as a string, if it was obtainable.
//  - JSON of all decoded column values.
type TableReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Reverse  bool              `protobuf:"varint,3,opt,name=reverse" json:"reverse"`
	Spans    []TableReaderSpan `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	// A hint for how many rows the consumer of the table reader output might
	// need. This is used to size the initial KV batches to try to avoid reading
	// many more rows than needed by the processor receiving the output.
	//
	// Not used if there is a limit set in the PostProcessSpec of this processor
	// (that value will be used for sizing batches instead).
	LimitHint int64 `protobuf:"varint,5,opt,name=limit_hint,json=limitHint" json:"limit_hint"`
	// Indicates whether the TableReader is being run as an exhaustive
	// check. This is only true during SCRUB commands.
	IsCheck bool `protobuf:"varint,6,opt,name=is_check,json=isCheck" json:"is_check"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to PUBLIC. Will be set to PUBLIC_AND_NOT_PUBLIC if
	// the consumer of this TableReader expects to be able to see in-progress
	// schema changes.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	// If set, the TableReader can read all the spans in parallel, without any
	// batch limits. This should only be the case when there is a known upper
	// bound on the number of rows we can read, and when there is no limit or
	// limit hint.
	Parallelize bool `protobuf:"varint,12,opt,name=parallelize" json:"parallelize"`
	// If non-zero, this enables inconsistent historical scanning where different
	// batches can be read with different timestamps. This is used for
	// long-running table statistics which may outlive the TTL. Using this setting
	// will cause inconsistencies across rows and even within rows.
	//
	// The value is a duration (in nanoseconds), which is the maximum "age" of the
	// timestamp. If the scan takes long enough for the timestamp to become older,
	// the timestamp is advanced by however much time passed.
	//
	// Example:
	//
	//     current time:      10
	//     initial timestamp: 0
	//     max timestamp age: 30
	//
	//     time
	//     10:    start scan, timestamp=0
	//     10-29: continue scanning at timestamp=0
	//     30:    bump timestamp to 20
	//     30-49: continue scanning at timestamp=20
	//     50:    bump timestamp to 40
	//     ...
	//
	// Note: it is an error to perform a historical read at an initial timestamp
	// older than this value.
	//
	MaxTimestampAgeNanos uint64 `protobuf:"varint,9,opt,name=max_timestamp_age_nanos,json=maxTimestampAgeNanos" json:"max_timestamp_age_nanos"`
	// Indicates the row-level locking strength to be used by the scan. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,10,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the scan for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,11,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
	// Indicates whether or not this TableReader is expected to produce any
	// system columns in its output.
	HasSystemColumns bool `protobuf:"varint,14,opt,name=has_system_columns,json=hasSystemColumns" json:"has_system_columns"`
	// Indicates the ordinals of the columns values for which are needed by the
	// post-processing stage and, therefore, are to be populated. It is ignored
	// if is_check is true.
	NeededColumns []uint32 `protobuf:"varint,15,rep,name=needed_columns,json=neededColumns" json:"needed_columns,omitempty"`
	// Indicates a virtual column which may have a different type than the column
	// stored in the table descriptor. For example, the inverted column in an
	// inverted index has a different type than the column it indexes in the base
	// table.
	VirtualColumn *descpb.ColumnDescriptor `protobuf:"bytes,16,opt,name=virtual_column,json=virtualColumn" json:"virtual_column,omitempty"`
}

func (m *TableReaderSpec) Reset()         { *m = TableReaderSpec{} }
func (m *TableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*TableReaderSpec) ProtoMessage()    {}
func (*TableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{1}
}
func (m *TableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableReaderSpec.Merge(m, src)
}
func (m *TableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *TableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TableReaderSpec proto.InternalMessageInfo

// FiltererSpec is the specification for a processor that filters input rows
// according to a boolean expression.
type FiltererSpec struct {
	// A filtering expression which references the internal columns of the
	// processor via ordinal references (@1, @2, etc).
	Filter Expression `protobuf:"bytes,1,opt,name=filter" json:"filter"`
}

func (m *FiltererSpec) Reset()         { *m = FiltererSpec{} }
func (m *FiltererSpec) String() string { return proto.CompactTextString(m) }
func (*FiltererSpec) ProtoMessage()    {}
func (*FiltererSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{2}
}
func (m *FiltererSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FiltererSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FiltererSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FiltererSpec.Merge(m, src)
}
func (m *FiltererSpec) XXX_Size() int {
	return m.Size()
}
func (m *FiltererSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FiltererSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FiltererSpec proto.InternalMessageInfo

// IndexSkipTableReaderSpec is the specification for a table reader that
// is performing a loose index scan over rows in the table. This means that
// this reader will return distinct rows from the table while using the index
// to skip unnecessary rows. This reader is used for different optimizations
// when operating on a prefix of a compound key.
type IndexSkipTableReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Spans    []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Indicates the visibility level of the columns that should be returned.
	// Normally, will be set to PUBLIC. Will be set to PUBLIC_AND_NOT_PUBLIC if
	// the consumer of this TableReader expects to be able to see in-progress
	// schema changes.
	Visibility ScanVisibility `protobuf:"varint,4,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	Reverse    bool           `protobuf:"varint,5,opt,name=reverse" json:"reverse"`
	// Indicates the row-level locking strength to be used by the scan. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,6,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the scan for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,7,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
}

func (m *IndexSkipTableReaderSpec) Reset()         { *m = IndexSkipTableReaderSpec{} }
func (m *IndexSkipTableReaderSpec) String() string { return proto.CompactTextString(m) }
func (*IndexSkipTableReaderSpec) ProtoMessage()    {}
func (*IndexSkipTableReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{3}
}
func (m *IndexSkipTableReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexSkipTableReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexSkipTableReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexSkipTableReaderSpec.Merge(m, src)
}
func (m *IndexSkipTableReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexSkipTableReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexSkipTableReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexSkipTableReaderSpec proto.InternalMessageInfo

// JoinReaderSpec is the specification for a "join reader". A join reader
// performs KV operations to retrieve specific rows that correspond to the
// values in the input stream (join by lookup). The output always preserves the
// order of the input rows.
//
// The "internal columns" of a JoinReader (see ProcessorSpec) are either:
//  - the columns of the table, if we are performing an index join (no lookup
//    columns) or if we are performing a semi or anti join, or
//  - the concatenation of the columns of the input stream with the table
//    columns.
//
// Internally, only the values for the columns needed by the post-processing
// stage are populated.
//
// Example:
// Input stream columns: | a | b |              Table columns: | c | d | e |
//
// If performing a lookup join on a = c (lookup columns is [0]):
//        Internal columns: | a | b | c | d | e |
//
// If performing an index join (where a = c and b = d) (lookup columns is []):
//        Internal columns: | c | d | e |
//
// There is a special case when a "join reader" is used as the second join in
// a pair of joins to accomplish a LEFT_OUTER, LEFT_SEMI or LEFT_ANTI join.
// The first join in this pair of joins is unable to precisely evaluate the
// join condition and produces false positives. This is typical when the first
// join is an inverted join (see InvertedJoinerSpec), but can also be the case
// when the first join is being evaluated over an index that does not have all
// the columns needed to evaluate the join condition. The first join outputs
// rows in sorted order of the original left columns. The input stream columns
// for the second join are a combination of the original left columns and the
// lookup columns. The first join additionally adds a continuation column that
// demarcates a group of successive rows that correspond to an original left
// row. The first row in a group contains false (since it is not a
// continuation of the group) and successive rows contain true.
//
// The mapping from the original join to the pair of joins is:
// LEFT_OUTER => LEFT_OUTER, LEFT_OUTER
// LEFT_SEMI  => INNER, LEFT_SEMI (better than doing INNER, INNER, SORT, DISTINCT)
// LEFT_ANTI  => LEFT_OUTER, LEFT_ANTI.
// where the first join always preserves order.
//
// More specifically, consider a lookup join example where the input stream
// columns are: | a | b | c | d | cont |.
// The lookup column is | d |. And the table columns are | e | f | with
// d = e.
// This join reader can see input of the form
// a1, b1, c1, d1,   false
// a1, b1, c1, d2,   true
// a1, b2, c1, null, false // when the first join is LEFT_OUTER
// a2, b1, c1, d3,   false
// a2, b1, c1, d4,   true
//
// Say both the results for (a1, b1, c1) are false positives, and the first
// of the (a2, b1, c1) result is a false positive.
// The output for LEFT_OUTER:
// a1, b1, c1, d1,   false, null, null
// a1, b2, c1, null, false, null, null
// a2, b1, c1, d4,   true,  d4,   f1
// The d, cont columns are not part of the original left row, so will be
// projected away after the join.
//
// The output for LEFT_ANTI:
// a1, b1, c1, d1,   false
// a1, b2, c1, null, false
// Again, the d, cont columns will be projected away after the join.
//
// The output for LEFT_SEMI:
// a2, b1, c1, d4, true
// Again, the d, cont columns will be projected away after the join.
//
// The example above is for a lookup join as the second join in the
// paired-joins. The lookup join can also be the first join in the
// paired-joins, which is indicated by both
// OutputGroupContinuationForLeftRow and MaintainOrdering set to true.
type JoinReaderSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index; each row in the input stream has a value
	// for each primary key. The index must provide all lookup columns.
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// LookupExpr represents the part of the join condition used to perform the
	// lookup into the index. It should only be set when LookupColumns is empty.
	// LookupExpr is used instead of LookupColumns when the lookup condition is
	// more complicated than a simple equality between input columns and index
	// columns. In this case, LookupExpr specifies the expression that will be
	// used to construct the spans for each lookup. Currently, the only
	// expressions supported are conjunctions (AND expressions) of equality and
	// IN expressions, specifically:
	//  1. equalities between two variables (one from the input and one from the
	//     index) representing the equi-join condition(s),
	//  2. equalities between an index column and a constant, and
	//  3. IN expressions between an index column and a tuple of constants.
	//
	// Variables in this expression are assigned in the same way as the ON
	// condition below. Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @(N+1) to @(N+M) refer to columns
	// in the right stream.
	//
	// For example, a valid LookupExpr for N=2 and M=2 might be:
	//   @3 IN (10, 20) AND @2 = @4.
	LookupExpr Expression `protobuf:"bytes,16,opt,name=lookup_expr,json=lookupExpr" json:"lookup_expr"`
	// If RemoteLookupExpr is set, this is a locality optimized lookup join. In
	// this case, LookupExpr contains the lookup join conditions targeting ranges
	// located on local nodes (relative to the gateway region), and
	// RemoteLookupExpr contains the lookup join conditions targeting remote
	// nodes. The optimizer will only plan a locality optimized lookup join if it
	// is known that each lookup returns at most one row. This fact allows the
	// joinReader to use the local conditions in LookupExpr first, and if a match
	// is found locally for each input row, there is no need to search remote
	// nodes. If a local match is not found for all input rows, the joinReader
	// uses RemoteLookupExpr to search remote nodes.
	//
	// The same restrictions on supported expressions that apply to LookupExpr
	// also apply to RemoteLookupExpr. See the comment above LookupExpr for more
	// details.
	RemoteLookupExpr Expression `protobuf:"bytes,17,opt,name=remote_lookup_expr,json=remoteLookupExpr" json:"remote_lookup_expr"`
	// LookupColumns, like LookupExpr, represents the part of the join condition
	// used to perform the lookup into the index. It is used as an optimization
	// for the common case where the join conditions are all simple equalities
	// between input and index columns (i.e., only the first of the supported
	// expression types listed above for LookupExpr). LookupColumns should only
	// be set when LookupExpr is empty.
	//
	// LookupColumns contains the column indexes in the input stream that match
	// with the index columns. These are the equality columns of the join. For
	// example, if there are 3 input columns and 2 index columns, LookupColumns
	// {0, 2} is equivalent to the LookupExpr @1 = @4 AND @3 = @5.
	//
	// If LookupExpr is empty, LookupColumns can be interpreted as follows:
	//
	// If empty (index join), the start of the input stream schema is assumed to
	// match the index columns. The joinReader will perform an index join and the
	// "internal columns" will be the columns of the table.
	//
	// If populated (lookup join), the `joinReader` will perform a lookup join
	// and the "internal columns" will be the concatenation of the input stream
	// columns followed by the table columns (except for semi/anti join, which
	// don't output any table columns).
	// TODO(rytaft): remove this field and use LookupExpr for all cases. This
	// requires ensuring that cases currently using LookupColumns do not regress.
	LookupColumns []uint32 `protobuf:"varint,3,rep,packed,name=lookup_columns,json=lookupColumns" json:"lookup_columns,omitempty"`
	// If set, the lookup columns form a key in the target table and thus each
	// lookup has at most one result.
	LookupColumnsAreKey bool `protobuf:"varint,8,opt,name=lookup_columns_are_key,json=lookupColumnsAreKey" json:"lookup_columns_are_key"`
	// "ON" expression (in addition to the conditions in LookupExpr and/or
	// equality constraints captured by the LookupColumns). Assuming that the left
	// stream has N columns and the right stream has M columns, in this expression
	// variables @1 to @N refer to columns of the left stream and variables @(N+1)
	// to @(N+M) refer to columns in the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// For lookup joins. Only JoinType_INNER and JoinType_LEFT_OUTER are
	// supported.
	Type descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// For index joins that are sources to mutation statements - what visibility
	// of columns should we return? Mutations sometimes need to see in-progress
	// schema change columns, in which case this field will be changed from its
	// default PUBLIC state. Causes the index join to return these schema change
	// columns.
	Visibility ScanVisibility `protobuf:"varint,7,opt,name=visibility,enum=cockroach.sql.distsqlrun.ScanVisibility" json:"visibility"`
	// Indicates the row-level locking strength to be used by the join. If set to
	// FOR_NONE, no row-level locking should be performed.
	LockingStrength descpb.ScanLockingStrength `protobuf:"varint,9,opt,name=locking_strength,json=lockingStrength,enum=cockroach.sql.sqlbase.ScanLockingStrength" json:"locking_strength"`
	// Indicates the policy to be used by the join for handling conflicting locks
	// held by other active transactions when attempting to lock rows. Always set
	// to BLOCK when locking_stength is FOR_NONE.
	LockingWaitPolicy descpb.ScanLockingWaitPolicy `protobuf:"varint,10,opt,name=locking_wait_policy,json=lockingWaitPolicy,enum=cockroach.sql.sqlbase.ScanLockingWaitPolicy" json:"locking_wait_policy"`
	// Indicates that the join reader should maintain the ordering of the input
	// stream. This is applicable to both lookup joins and index joins. For lookup
	// joins, maintaining order is expensive because it requires buffering. For
	// index joins buffering is not required, but still, if ordering is not
	// required, we'll change the output order to allow for some Pebble
	// optimizations.
	MaintainOrdering bool `protobuf:"varint,11,opt,name=maintain_ordering,json=maintainOrdering" json:"maintain_ordering"`
	// Indicates whether or not this JoinReader is expected to produce any
	// system columns in its output.
	//
	// This is only used in the special case of index joins, where the final
	// result of the secondary index joined against the primary index is
	// expected to contain the materialized system columns.
	HasSystemColumns bool `protobuf:"varint,13,opt,name=has_system_columns,json=hasSystemColumns" json:"has_system_columns"`
	// LeftJoinWithPairedJoiner is used when a left {outer,anti,semi} join is
	// being achieved by pairing two joins, and this is the second join. See
	// the comment above.
	LeftJoinWithPairedJoiner bool `protobuf:"varint,14,opt,name=left_join_with_paired_joiner,json=leftJoinWithPairedJoiner" json:"left_join_with_paired_joiner"`
	// OutputGroupContinuationForLeftRow indicates that this join is the first
	// join in the paired-joins. At most one of OutputGroupContinuationForLeftRow
	// and LeftJoinWithPairedJoiner must be true. Additionally, if
	// OutputGroupContinuationForLeftRow is true, MaintainOrdering must also
	// be true.
	OutputGroupContinuationForLeftRow bool `protobuf:"varint,15,opt,name=output_group_continuation_for_left_row,json=outputGroupContinuationForLeftRow" json:"output_group_continuation_for_left_row"`
}

func (m *JoinReaderSpec) Reset()         { *m = JoinReaderSpec{} }
func (m *JoinReaderSpec) String() string { return proto.CompactTextString(m) }
func (*JoinReaderSpec) ProtoMessage()    {}
func (*JoinReaderSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{4}
}
func (m *JoinReaderSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinReaderSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JoinReaderSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinReaderSpec.Merge(m, src)
}
func (m *JoinReaderSpec) XXX_Size() int {
	return m.Size()
}
func (m *JoinReaderSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinReaderSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JoinReaderSpec proto.InternalMessageInfo

// SorterSpec is the specification for a "sorting aggregator". A sorting
// processor sorts elements in the input stream providing a certain output
// order guarantee regardless of the input ordering. The output ordering is
// according to a configurable set of columns.
//
// The "internal columns" of a Sorter (see ProcessorSpec) are the same as the
// input columns.
type SorterSpec struct {
	OutputOrdering Ordering `protobuf:"bytes,1,opt,name=output_ordering,json=outputOrdering" json:"output_ordering"`
	// Ordering match length, specifying that the input is already sorted by the
	// first 'n' output ordering columns, can be optionally specified for
	// possible speed-ups taking advantage of the partial orderings.
	OrderingMatchLen uint32 `protobuf:"varint,2,opt,name=ordering_match_len,json=orderingMatchLen" json:"ordering_match_len"`
}

func (m *SorterSpec) Reset()         { *m = SorterSpec{} }
func (m *SorterSpec) String() string { return proto.CompactTextString(m) }
func (*SorterSpec) ProtoMessage()    {}
func (*SorterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{5}
}
func (m *SorterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SorterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SorterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SorterSpec.Merge(m, src)
}
func (m *SorterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SorterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SorterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SorterSpec proto.InternalMessageInfo

type DistinctSpec struct {
	// The ordered columns in the input stream can be optionally specified for
	// possible optimizations. The specific ordering (ascending/descending) of
	// the column itself is not important nor is the order in which the columns
	// are specified. The ordered columns must be a subset of the distinct
	// columns.
	OrderedColumns []uint32 `protobuf:"varint,1,rep,name=ordered_columns,json=orderedColumns" json:"ordered_columns,omitempty"`
	// The distinct columns in the input stream are those columns on which we
	// check for distinct rows. If A,B,C are in distinct_columns and there is a
	// 4th column D which is not included in distinct_columns, its values are not
	// considered, so rows A1,B1,C1,D1 and A1,B1,C1,D2 are considered equal and
	// only one of them (the first) is output.
	DistinctColumns []uint32 `protobuf:"varint,2,rep,name=distinct_columns,json=distinctColumns" json:"distinct_columns,omitempty"`
	// If true, then NULL values are treated as not equal to one another. Each NULL
	// value will cause a new row group to be created. For example:
	//
	//   c
	//   ----
	//   NULL
	//   NULL
	//
	// A distinct operation on column "c" will result in one output row if
	// NullsAreDistinct is false, or two output rows if true. This is set to true
	// for UPSERT and INSERT..ON CONFLICT statements, since they must treat NULL
	// values as distinct.
	NullsAreDistinct bool `protobuf:"varint,3,opt,name=nulls_are_distinct,json=nullsAreDistinct" json:"nulls_are_distinct"`
	// If not empty, then an error with this text will be raised if there are two
	// rows with duplicate distinct column values. This is used to implement the
	// UPSERT and INSERT..ON CONFLICT statements, both of which prohibit the same
	// row from being changed twice.
	ErrorOnDup string `protobuf:"bytes,4,opt,name=error_on_dup,json=errorOnDup" json:"error_on_dup"`
	// OutputOrdering specifies the required ordering of the output produced by
	// the distinct. The input to the processor *must* already be ordered
	// according to it.
	OutputOrdering Ordering `protobuf:"bytes,5,opt,name=output_ordering,json=outputOrdering" json:"output_ordering"`
}

func (m *DistinctSpec) Reset()         { *m = DistinctSpec{} }
func (m *DistinctSpec) String() string { return proto.CompactTextString(m) }
func (*DistinctSpec) ProtoMessage()    {}
func (*DistinctSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{6}
}
func (m *DistinctSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DistinctSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DistinctSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistinctSpec.Merge(m, src)
}
func (m *DistinctSpec) XXX_Size() int {
	return m.Size()
}
func (m *DistinctSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DistinctSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DistinctSpec proto.InternalMessageInfo

// The specification for a WITH ORDINALITY processor. It adds a new column to
// each resulting row that contains the ordinal number of the row. Since there
// are no arguments for this operator, the spec is empty.
type OrdinalitySpec struct {
}

func (m *OrdinalitySpec) Reset()         { *m = OrdinalitySpec{} }
func (m *OrdinalitySpec) String() string { return proto.CompactTextString(m) }
func (*OrdinalitySpec) ProtoMessage()    {}
func (*OrdinalitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{7}
}
func (m *OrdinalitySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrdinalitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OrdinalitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrdinalitySpec.Merge(m, src)
}
func (m *OrdinalitySpec) XXX_Size() int {
	return m.Size()
}
func (m *OrdinalitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrdinalitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrdinalitySpec proto.InternalMessageInfo

// ZigzagJoinerSpec is the specification for a zigzag join processor. The
// processor's current implementation fetches the rows using internal
// rowFetchers.
//
// The "internal columns" of a ZigzagJoiner (see ProcessorSpec) are the
// concatenation of all of the columns of the tables specified. The columns
// are populated if they are contained in the index specified for that table.
type ZigzagJoinerSpec struct {
	// TODO(pbardea): Replace these with inputs that conform to a RowSource-like
	// interface.
	Tables []descpb.TableDescriptor `protobuf:"bytes,1,rep,name=tables" json:"tables"`
	// An array of arrays. The array at eq_columns[side_idx] contains the
	// equality columns for that side. All arrays in eq_columns should have
	// equal length.
	EqColumns []Columns `protobuf:"bytes,2,rep,name=eq_columns,json=eqColumns" json:"eq_columns"`
	// Each value indicates an index: if 0, primary index; otherwise the n-th
	// secondary index, i.e. tables[side_idx].indexes[index_ordinals[side_idx]].
	IndexOrdinals []uint32 `protobuf:"varint,3,rep,packed,name=index_ordinals,json=indexOrdinals" json:"index_ordinals,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression `protobuf:"bytes,4,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// Fixed values at the start of indices.
	FixedValues []*ValuesCoreSpec `protobuf:"bytes,5,rep,name=fixed_values,json=fixedValues" json:"fixed_values,omitempty"`
	Type        descpb.JoinType   `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
}

func (m *ZigzagJoinerSpec) Reset()         { *m = ZigzagJoinerSpec{} }
func (m *ZigzagJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*ZigzagJoinerSpec) ProtoMessage()    {}
func (*ZigzagJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{8}
}
func (m *ZigzagJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZigzagJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ZigzagJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZigzagJoinerSpec.Merge(m, src)
}
func (m *ZigzagJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ZigzagJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ZigzagJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ZigzagJoinerSpec proto.InternalMessageInfo

// MergeJoinerSpec is the specification for a merge join processor. The processor
// has two inputs and one output. The inputs must have the same ordering on the
// columns that have equality constraints. For example:
//   SELECT * FROM T1 INNER JOIN T2 ON T1.C1 = T2.C5 AND T1.C2 = T2.C4
//
// To perform a merge join, the streams corresponding to T1 and T2 must have the
// same ordering on columns C1, C2 and C5, C4 respectively. For example: C1+,C2-
// and C5+,C4-.
//
// The "internal columns" of a MergeJoiner (see ProcessorSpec) are:
// - for INNER, LEFT_OUTER, RIGHT_OUTER, FULL_OUTER - the concatenation of left
//   input columns and right input columns.
//   If the left input has N columns and the right input has M columns, the
//   first N columns contain values from the left side and the following M
//   columns contain values from the right side.
// - for LEFT_SEMI, LEFT_ANTI, INTERSECT_ALL, EXCEPT_ALL - the left input
//   columns.
// - for RIGHT_SEMI, RIGHT_ANTI - the right input columns.
//
// Note that, regardless of the join type, an optional ON expression can refer
// to columns from both inputs.
type MergeJoinerSpec struct {
	// The streams must be ordered according to the columns that have equality
	// constraints. The first column of the left ordering is constrained to be
	// equal to the first column in the right ordering and so on. The ordering
	// lengths and directions must match.
	// In the example above, left ordering describes C1+,C2- and right ordering
	// describes C5+,C4-.
	LeftOrdering  Ordering `protobuf:"bytes,1,opt,name=left_ordering,json=leftOrdering" json:"left_ordering"`
	RightOrdering Ordering `protobuf:"bytes,2,opt,name=right_ordering,json=rightOrdering" json:"right_ordering"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression ordinal references @1 to @N refer
	// to columns of the left stream and variables @(N+1) to @(N+M) refer to
	// columns in the right stream.
	OnExpr Expression      `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// NullEquality indicates that NULL = NULL should be considered true.
	// This allows OUTER JOINs to consider NULL values meaningfully. An
	// example of this is during SCRUB checks on secondary indexes.
	NullEquality bool `protobuf:"varint,7,opt,name=null_equality,json=nullEquality" json:"null_equality"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
}

func (m *MergeJoinerSpec) Reset()         { *m = MergeJoinerSpec{} }
func (m *MergeJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*MergeJoinerSpec) ProtoMessage()    {}
func (*MergeJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{9}
}
func (m *MergeJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeJoinerSpec.Merge(m, src)
}
func (m *MergeJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *MergeJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MergeJoinerSpec proto.InternalMessageInfo

// HashJoinerSpec is the specification for a hash join processor. The processor
// has two inputs and one output.
//
// The processor works by reading the entire right input and putting it in a hash
// table. Thus, there is no guarantee on the ordering of results that stem only
// from the right input (in the case of RIGHT_OUTER, FULL_OUTER). However, it is
// guaranteed that results that involve the left stream preserve the ordering;
// i.e. all results that stem from left row (i) precede results that stem from
// left row (i+1).
//
// The "internal columns" of a HashJoiner (see ProcessorSpec) are:
// - for INNER, LEFT_OUTER, RIGHT_OUTER, FULL_OUTER - the concatenation of left
//   input columns and right input columns.
//   If the left input has N columns and the right input has M columns, the
//   first N columns contain values from the left side and the following M
//   columns contain values from the right side.
// - for LEFT_SEMI, LEFT_ANTI, INTERSECT_ALL, EXCEPT_ALL - the left input
//   columns.
// - for RIGHT_SEMI, RIGHT_ANTI - the right input columns.
//
// Note that, regardless of the join type, an optional ON expression can refer
// to columns from both inputs.
type HashJoinerSpec struct {
	// The join constraints certain columns from the left stream to equal
	// corresponding columns on the right stream. These must have the same length.
	LeftEqColumns  []uint32 `protobuf:"varint,1,rep,packed,name=left_eq_columns,json=leftEqColumns" json:"left_eq_columns,omitempty"`
	RightEqColumns []uint32 `protobuf:"varint,2,rep,packed,name=right_eq_columns,json=rightEqColumns" json:"right_eq_columns,omitempty"`
	// "ON" expression (in addition to the equality constraints captured by the
	// orderings). Assuming that the left stream has N columns and the right
	// stream has M columns, in this expression variables @1 to @N refer to
	// columns of the left stream and variables @(N+1) to @(N+M) refer to columns
	// in the right stream.
	OnExpr Expression      `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	Type   descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// If true, it is guaranteed that the left equality columns form a key for
	// the left input. In other words, no two rows from the left input have the
	// same set of values on the left equality columns.
	LeftEqColumnsAreKey bool `protobuf:"varint,8,opt,name=left_eq_columns_are_key,json=leftEqColumnsAreKey" json:"left_eq_columns_are_key"`
	// If true, it is guaranteed that the right equality columns form a key for
	// the right input. In other words, no two rows from the right input have the
	// same set of values on the right equality columns.
	RightEqColumnsAreKey bool `protobuf:"varint,9,opt,name=right_eq_columns_are_key,json=rightEqColumnsAreKey" json:"right_eq_columns_are_key"`
}

func (m *HashJoinerSpec) Reset()         { *m = HashJoinerSpec{} }
func (m *HashJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*HashJoinerSpec) ProtoMessage()    {}
func (*HashJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{10}
}
func (m *HashJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HashJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashJoinerSpec.Merge(m, src)
}
func (m *HashJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *HashJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HashJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HashJoinerSpec proto.InternalMessageInfo

// InvertedJoinerSpec is the specification for an inverted join. The processor
// has two inputs and one output.
//
// The processor uses the inverted index on a column of the right input to
// join with a column of the left input. In addition to the InvertedExpr which
// is specified on these two columns, it also evaluates an OnExpr on the
// joined rows that satisfy the InvertedExpr. The "internal columns" of an
// InvertedJoiner for INNER and LEFT_OUTER joins are a concatenation of the
// columns of left and right input. The only columns of the right input that
// are populated are the columns present in the inverted index, except for the
// inverted column (since it does not represent a complete value for the datum
// that was indexed). For LEFT_SEMI and LEFT_ANTI, the "internal columns" are
// the columns of the left input.
//
// In many cases, the inverted join will contain false positives wrt the
// original join condition. This is handled by pairing it with a lookup join.
// This pairing works naturally when the user query specified INNER, by
// running an INNER inverted join followed by INNER lookup join. For a user
// query with LEFT_OUTER/LEFT_ANTI, the inverted join is run as a LEFT_OUTER
// with a special mode that outputs an additional bool column that represents
// whether this row is a continuation of a group, where a group is defined as
// rows corresponding to the same original left row. This is paired with a
// lookup join that also knows about the semantics of this bool column. For a
// user query with LEFT_SEMI, the inverted join is run as an INNER join with
// the same special mode. See the JoinReaderSpec for an example.
//
// Example:
// Input stream columns: | a | b |
// Table columns: | c | d | e |
// The InvertedExpr involves columns b, e and the primary key for the right
// input is c.
// The inverted index has columns: | e' | c |
// where e' is derived from e. For instance, if e is an array, e' will
// correspond to elements of the array.
// The OnExpr can use columns a, b, c, since they are the other columns that
// are present in the input stream and the inverted index.
//
// Internal columns for INNER and LEFT_OUTER: | a | b | c | d | e |
// where d, e are not populated.
// Internal columns for LEFT_SEMI and LEFT_ANTI: | a | b |
//
// Multi-column inverted index example:
// Input stream columns: | a | b | c |
// Table columns: | d | e | f | g |
// The InvertedExpr involves columns b, e. The non-inverted prefix key columns
// equate c to f. The primary key for the right input is d.
// The inverted index has columns: | f | e' | d |
// where e' is derived from e and f is a non-inverted prefix column.
// The OnExpr can use columns a, b, c, d, f.
//
// Internal columns for INNER and LEFT_OUTER: | a | b | c | d | e | f | g |
// where e, g are not populated.
// Internal columns for LEFT_SEMI and LEFT_ANTI: | a | b | c |
//
// For INNER/LEFT_OUTER with OutputGroupContinuationForLeftRow = true, the
// internal columns include an additional bool column as the last column.
type InvertedJoinerSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// The ID of the inverted index. The first column in the index is the
	// inverted column, and the remaining columns are the primary key.
	IndexIdx uint32 `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	// Expression involving the indexed column and columns from the input.
	// Assuming that the input stream has N columns and the table that has been
	// indexed has M columns, in this expression variables @1 to @N refer to
	// columns of the input stream and variables @(N+1) to @(N+M) refer to
	// columns in the table. Although the numbering includes all columns, only
	// columns corresponding to the indexed column and the input columns may be
	// present in this expression. Note that the column numbering matches the
	// numbering used below by the on expression.
	//
	// The expression is passed to xform.NewDatumToInvertedExpr to construct an
	// implementation of invertedexpr.DatumToInvertedExpr, which will be fed each
	// input row and output an expression to evaluate over the inverted index.
	InvertedExpr Expression `protobuf:"bytes,4,opt,name=inverted_expr,json=invertedExpr" json:"inverted_expr"`
	// Optional expression involving the columns in the index (other than the
	// inverted column) and the columns in the input stream. Assuming that the
	// input stream has N columns and the table that has been indexed has M
	// columns, in this expression variables @1 to @N refer to columns of the
	// input stream and variables @(N+1) to @(N+M) refer to columns in the
	// table. The numbering does not omit the column in the table corresponding
	// to the inverted column, or other table columns absent from the index, but
	// they cannot be present in this expression. Note that the column numbering
	// matches the numbering used above by the inverted expression.
	OnExpr Expression `protobuf:"bytes,5,opt,name=on_expr,json=onExpr" json:"on_expr"`
	// Only INNER, LEFT_OUTER, LEFT_SEMI, LEFT_ANTI are supported. For indexes
	// that produce false positives for user expressions, like geospatial
	// indexes, only INNER and LEFT_OUTER are actually useful -- LEFT_SEMI will
	// be mapped to INNER by the optimizer, and LEFT_ANTI to LEFT_OUTER, to
	// allow the false positives to be eliminated by evaluating the exact
	// expression on the rows output by this join.
	Type descpb.JoinType `protobuf:"varint,6,opt,name=type,enum=cockroach.sql.sqlbase.JoinType" json:"type"`
	// Indicates that the inverted joiner should maintain the ordering of the
	// input stream.
	MaintainOrdering bool `protobuf:"varint,7,opt,name=maintain_ordering,json=maintainOrdering" json:"maintain_ordering"`
	// Indicates that the join should output a continuation column that
	// indicates whether a row is a continuation of a group corresponding to a
	// left row.
	OutputGroupContinuationForLeftRow bool `protobuf:"varint,8,opt,name=output_group_continuation_for_left_row,json=outputGroupContinuationForLeftRow" json:"output_group_continuation_for_left_row"`
	// Column indexes in the input stream specifying the columns which match with
	// the non-inverted prefix columns of the index, if the index is multi-column.
	// These are the equality columns of the join. The length of
	// prefix_equality_columns should be equal to the number of non-inverted
	// prefix columns in the index.
	PrefixEqualityColumns []uint32 `protobuf:"varint,9,rep,packed,name=prefix_equality_columns,json=prefixEqualityColumns" json:"prefix_equality_columns,omitempty"`
}

func (m *InvertedJoinerSpec) Reset()         { *m = InvertedJoinerSpec{} }
func (m *InvertedJoinerSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedJoinerSpec) ProtoMessage()    {}
func (*InvertedJoinerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{11}
}
func (m *InvertedJoinerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedJoinerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InvertedJoinerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedJoinerSpec.Merge(m, src)
}
func (m *InvertedJoinerSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedJoinerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedJoinerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedJoinerSpec proto.InternalMessageInfo

// InvertedFiltererSpec is the specification of a processor that does filtering
// on a table by evaluating an invertedexpr.SpanExpressionProto on an inverted
// index of the table. The input consists of the inverted index rows from
// InvertedExpr.SpansToRead. It is acceptable for a filter on the primary key
// to be pushed down between the scan and the inverted filterer.
//
// Example:
// Table columns: | a | b | c | d |
// where a, d are the primary key and b is the column with the inverted index.
// Inverted index columns: | a | b' | d |
// where b' is derived from b. For instance, if b is an array, b' will be
// elements of the array.
//
// Internal columns are | a | b | d |. The output sets b to NULL, since it does
// not have the value of the original column that was indexed in the inverted
// column.
//
// Optionally, there can be a pre-filtering spec that describes an expression
// (derived from the original expression that was converted to inverted_expr),
// that must evaluate to true on each inverted row. This is a performance
// optimization -- for more details see invertedidx.PreFilterer (geometry
// and geography inverted indexes are the only ones that currently use
// pre-filtering).
type InvertedFiltererSpec struct {
	// The index in the input row of the inverted column.
	InvertedColIdx uint32 `protobuf:"varint,1,opt,name=inverted_col_idx,json=invertedColIdx" json:"inverted_col_idx"`
	// The expression to evaluate. The SpansToRead are ignored since they
	// have already been used to setup the input.
	InvertedExpr    inverted.SpanExpressionProto          `protobuf:"bytes,2,opt,name=inverted_expr,json=invertedExpr" json:"inverted_expr"`
	PreFiltererSpec *InvertedFiltererSpec_PreFiltererSpec `protobuf:"bytes,6,opt,name=pre_filterer_spec,json=preFiltererSpec" json:"pre_filterer_spec,omitempty"`
}

func (m *InvertedFiltererSpec) Reset()         { *m = InvertedFiltererSpec{} }
func (m *InvertedFiltererSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedFiltererSpec) ProtoMessage()    {}
func (*InvertedFiltererSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{12}
}
func (m *InvertedFiltererSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedFiltererSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InvertedFiltererSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedFiltererSpec.Merge(m, src)
}
func (m *InvertedFiltererSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedFiltererSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedFiltererSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedFiltererSpec proto.InternalMessageInfo

// Optional pre-filtering expression.
type InvertedFiltererSpec_PreFiltererSpec struct {
	// Expression has only one variable, @1, which refers to the column with
	// the inverted index.
	Expression Expression `protobuf:"bytes,1,opt,name=expression" json:"expression"`
	// The type of the original column that was indexed in the inverted index.
	Type *types.T `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Reset()         { *m = InvertedFiltererSpec_PreFiltererSpec{} }
func (m *InvertedFiltererSpec_PreFiltererSpec) String() string { return proto.CompactTextString(m) }
func (*InvertedFiltererSpec_PreFiltererSpec) ProtoMessage()    {}
func (*InvertedFiltererSpec_PreFiltererSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{12, 0}
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec.Merge(m, src)
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_Size() int {
	return m.Size()
}
func (m *InvertedFiltererSpec_PreFiltererSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec.DiscardUnknown(m)
}

var xxx_messageInfo_InvertedFiltererSpec_PreFiltererSpec proto.InternalMessageInfo

// AggregatorSpec is the specification for an "aggregator" (processor core
// type, not the logical plan computation stage). An aggregator performs
// 'aggregation' in the SQL sense in that it groups rows and computes an aggregate
// for each group. The group is configured using the group key. The aggregator
// can be configured with one or more aggregation functions.
//
// The "internal columns" of an Aggregator map 1-1 to the aggregations.
type AggregatorSpec struct {
	// The group key is a subset of the columns in the input stream schema on the
	// basis of which we define our groups.
	GroupCols    []uint32                     `protobuf:"varint,2,rep,packed,name=group_cols,json=groupCols" json:"group_cols,omitempty"`
	Aggregations []AggregatorSpec_Aggregation `protobuf:"bytes,3,rep,name=aggregations" json:"aggregations"`
	// A subset of the GROUP BY columns which are ordered in the input.
	OrderedGroupCols []uint32            `protobuf:"varint,4,rep,packed,name=ordered_group_cols,json=orderedGroupCols" json:"ordered_group_cols,omitempty"`
	Type             AggregatorSpec_Type `protobuf:"varint,5,opt,name=type,enum=cockroach.sql.distsqlrun.AggregatorSpec_Type" json:"type"`
	// OutputOrdering specifies the required ordering of the output produced by
	// the aggregator. The input to the processor *must* already be ordered
	// according to it.
	OutputOrdering Ordering `protobuf:"bytes,6,opt,name=output_ordering,json=outputOrdering" json:"output_ordering"`
}

func (m *AggregatorSpec) Reset()         { *m = AggregatorSpec{} }
func (m *AggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec) ProtoMessage()    {}
func (*AggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{13}
}
func (m *AggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec.Merge(m, src)
}
func (m *AggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec proto.InternalMessageInfo

type AggregatorSpec_Aggregation struct {
	Func AggregatorSpec_Func `protobuf:"varint,1,opt,name=func,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"func"`
	// Aggregation functions with distinct = true functions like you would
	// expect '<FUNC> DISTINCT' to operate, the default behavior would be
	// the '<FUNC> ALL' operation.
	Distinct bool `protobuf:"varint,2,opt,name=distinct" json:"distinct"`
	// The column index specifies the argument(s) to the aggregator function.
	//
	// Most aggregations take one argument
	// COUNT_ROWS takes no arguments.
	// FINAL_STDDEV and FINAL_VARIANCE take three arguments (SQRDIFF, SUM,
	// COUNT).
	ColIdx []uint32 `protobuf:"varint,5,rep,name=col_idx,json=colIdx" json:"col_idx,omitempty"`
	// If set, this column index specifies a boolean argument; rows for which
	// this value is not true don't contribute to this aggregation. This enables
	// the filter clause, e.g.:
	//   SELECT SUM(x) FILTER (WHERE y > 1), SUM(x) FILTER (WHERE y < 1) FROM t
	FilterColIdx *uint32 `protobuf:"varint,4,opt,name=filter_col_idx,json=filterColIdx" json:"filter_col_idx,omitempty"`
	// Arguments are const expressions passed to aggregation functions.
	Arguments []Expression `protobuf:"bytes,6,rep,name=arguments" json:"arguments"`
}

func (m *AggregatorSpec_Aggregation) Reset()         { *m = AggregatorSpec_Aggregation{} }
func (m *AggregatorSpec_Aggregation) String() string { return proto.CompactTextString(m) }
func (*AggregatorSpec_Aggregation) ProtoMessage()    {}
func (*AggregatorSpec_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{13, 0}
}
func (m *AggregatorSpec_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatorSpec_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AggregatorSpec_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatorSpec_Aggregation.Merge(m, src)
}
func (m *AggregatorSpec_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *AggregatorSpec_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatorSpec_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatorSpec_Aggregation proto.InternalMessageInfo

// ProjectSetSpec is the specification of a processor which applies a set of
// expressions, which may be set-returning functions, to its input.
type ProjectSetSpec struct {
	// Expressions to be applied
	Exprs []Expression `protobuf:"bytes,1,rep,name=exprs" json:"exprs"`
	// Column types for the generated values
	GeneratedColumns []*types.T `protobuf:"bytes,2,rep,name=generated_columns,json=generatedColumns" json:"generated_columns,omitempty"`
	// The number of columns each expression returns. Same length as exprs.
	NumColsPerGen []uint32 `protobuf:"varint,3,rep,name=num_cols_per_gen,json=numColsPerGen" json:"num_cols_per_gen,omitempty"`
}

func (m *ProjectSetSpec) Reset()         { *m = ProjectSetSpec{} }
func (m *ProjectSetSpec) String() string { return proto.CompactTextString(m) }
func (*ProjectSetSpec) ProtoMessage()    {}
func (*ProjectSetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{14}
}
func (m *ProjectSetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProjectSetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSetSpec.Merge(m, src)
}
func (m *ProjectSetSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSetSpec proto.InternalMessageInfo

// WindowerSpec is the specification of a processor that performs computations
// of window functions that have the same PARTITION BY clause. For a particular
// windowFn, the processor puts result at windowFn.ArgIdxStart and "consumes"
// all arguments to windowFn (windowFn.ArgCount of them). So if windowFn takes
// no arguments, an extra column is added; if windowFn takes more than one
// argument, (windowFn.ArgCount - 1) columns are removed.
type WindowerSpec struct {
	// PartitionBy specifies how to partition rows for all window functions.
	PartitionBy []uint32 `protobuf:"varint,1,rep,name=partitionBy" json:"partitionBy,omitempty"`
	// WindowFns is the specification of all window functions to be computed.
	WindowFns []WindowerSpec_WindowFn `protobuf:"bytes,2,rep,name=windowFns" json:"windowFns"`
}

func (m *WindowerSpec) Reset()         { *m = WindowerSpec{} }
func (m *WindowerSpec) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec) ProtoMessage()    {}
func (*WindowerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15}
}
func (m *WindowerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec.Merge(m, src)
}
func (m *WindowerSpec) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec proto.InternalMessageInfo

// Func specifies which function to compute. It can either be built-in
// aggregate or built-in window function.
type WindowerSpec_Func struct {
	AggregateFunc *AggregatorSpec_Func     `protobuf:"varint,1,opt,name=aggregateFunc,enum=cockroach.sql.distsqlrun.AggregatorSpec_Func" json:"aggregateFunc,omitempty"`
	WindowFunc    *WindowerSpec_WindowFunc `protobuf:"varint,2,opt,name=windowFunc,enum=cockroach.sql.distsqlrun.WindowerSpec_WindowFunc" json:"windowFunc,omitempty"`
}

func (m *WindowerSpec_Func) Reset()         { *m = WindowerSpec_Func{} }
func (m *WindowerSpec_Func) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Func) ProtoMessage()    {}
func (*WindowerSpec_Func) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 0}
}
func (m *WindowerSpec_Func) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Func) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec_Func) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Func.Merge(m, src)
}
func (m *WindowerSpec_Func) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Func) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Func.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Func proto.InternalMessageInfo

// Frame is the specification of a single window frame for a window function.
type WindowerSpec_Frame struct {
	Mode      WindowerSpec_Frame_Mode      `protobuf:"varint,1,opt,name=mode,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode" json:"mode"`
	Bounds    WindowerSpec_Frame_Bounds    `protobuf:"bytes,2,opt,name=bounds" json:"bounds"`
	Exclusion WindowerSpec_Frame_Exclusion `protobuf:"varint,3,opt,name=exclusion,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion" json:"exclusion"`
}

func (m *WindowerSpec_Frame) Reset()         { *m = WindowerSpec_Frame{} }
func (m *WindowerSpec_Frame) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame) ProtoMessage()    {}
func (*WindowerSpec_Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1}
}
func (m *WindowerSpec_Frame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec_Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame.Merge(m, src)
}
func (m *WindowerSpec_Frame) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame proto.InternalMessageInfo

// Bound specifies the type of boundary and the offset (if present).
type WindowerSpec_Frame_Bound struct {
	BoundType WindowerSpec_Frame_BoundType `protobuf:"varint,1,opt,name=boundType,enum=cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType" json:"boundType"`
	// For UNBOUNDED_PRECEDING, UNBOUNDED_FOLLOWING, and CURRENT_ROW offset
	// is ignored. Integer offset for ROWS and GROUPS modes is stored in
	// int_offset while an encoded datum and the type information are stored
	// for RANGE mode.
	IntOffset   uint64    `protobuf:"varint,2,opt,name=int_offset,json=intOffset" json:"int_offset"`
	TypedOffset []byte    `protobuf:"bytes,3,opt,name=typed_offset,json=typedOffset" json:"typed_offset,omitempty"`
	OffsetType  DatumInfo `protobuf:"bytes,4,opt,name=offset_type,json=offsetType" json:"offset_type"`
}

func (m *WindowerSpec_Frame_Bound) Reset()         { *m = WindowerSpec_Frame_Bound{} }
func (m *WindowerSpec_Frame_Bound) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bound) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bound) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1, 0}
}
func (m *WindowerSpec_Frame_Bound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec_Frame_Bound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bound.Merge(m, src)
}
func (m *WindowerSpec_Frame_Bound) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bound) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bound.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bound proto.InternalMessageInfo

// Bounds specifies boundaries of the window frame.
type WindowerSpec_Frame_Bounds struct {
	// Start bound must always be present whereas end bound might be omitted.
	Start WindowerSpec_Frame_Bound  `protobuf:"bytes,1,opt,name=start" json:"start"`
	End   *WindowerSpec_Frame_Bound `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *WindowerSpec_Frame_Bounds) Reset()         { *m = WindowerSpec_Frame_Bounds{} }
func (m *WindowerSpec_Frame_Bounds) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_Frame_Bounds) ProtoMessage()    {}
func (*WindowerSpec_Frame_Bounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 1, 1}
}
func (m *WindowerSpec_Frame_Bounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec_Frame_Bounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.Merge(m, src)
}
func (m *WindowerSpec_Frame_Bounds) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_Frame_Bounds) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_Frame_Bounds.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_Frame_Bounds proto.InternalMessageInfo

// WindowFn is the specification of a single window function.
type WindowerSpec_WindowFn struct {
	// Func is which function to compute.
	Func WindowerSpec_Func `protobuf:"bytes,1,opt,name=func" json:"func"`
	// ArgsIdxs contains indices of the columns that are arguments to the
	// window function.
	ArgsIdxs []uint32 `protobuf:"varint,7,rep,name=argsIdxs" json:"argsIdxs,omitempty"`
	// Ordering specifies in which order rows should be considered by this
	// window function. Its contents come from ORDER BY clause of the window
	// function.
	Ordering Ordering `protobuf:"bytes,4,opt,name=ordering" json:"ordering"`
	// Frame specifies over which frame this window function is computed.
	Frame *WindowerSpec_Frame `protobuf:"bytes,5,opt,name=frame" json:"frame,omitempty"`
	// Optional index of a column over which filtering of rows will be done.
	// Special value -1 indicates that filter is not present.
	FilterColIdx int32 `protobuf:"varint,6,opt,name=filterColIdx" json:"filterColIdx"`
	// OutputColIdx specifies the column index which the window function should
	// put its output into.
	OutputColIdx uint32 `protobuf:"varint,8,opt,name=outputColIdx" json:"outputColIdx"`
}

func (m *WindowerSpec_WindowFn) Reset()         { *m = WindowerSpec_WindowFn{} }
func (m *WindowerSpec_WindowFn) String() string { return proto.CompactTextString(m) }
func (*WindowerSpec_WindowFn) ProtoMessage()    {}
func (*WindowerSpec_WindowFn) Descriptor() ([]byte, []int) {
	return fileDescriptor_90493aed97b6d28f, []int{15, 2}
}
func (m *WindowerSpec_WindowFn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowerSpec_WindowFn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WindowerSpec_WindowFn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowerSpec_WindowFn.Merge(m, src)
}
func (m *WindowerSpec_WindowFn) XXX_Size() int {
	return m.Size()
}
func (m *WindowerSpec_WindowFn) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowerSpec_WindowFn.DiscardUnknown(m)
}

var xxx_messageInfo_WindowerSpec_WindowFn proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.ScanVisibility", ScanVisibility_name, ScanVisibility_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Func", AggregatorSpec_Func_name, AggregatorSpec_Func_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.AggregatorSpec_Type", AggregatorSpec_Type_name, AggregatorSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_WindowFunc", WindowerSpec_WindowFunc_name, WindowerSpec_WindowFunc_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Mode", WindowerSpec_Frame_Mode_name, WindowerSpec_Frame_Mode_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_BoundType", WindowerSpec_Frame_BoundType_name, WindowerSpec_Frame_BoundType_value)
	proto.RegisterEnum("cockroach.sql.distsqlrun.WindowerSpec_Frame_Exclusion", WindowerSpec_Frame_Exclusion_name, WindowerSpec_Frame_Exclusion_value)
	proto.RegisterType((*ValuesCoreSpec)(nil), "cockroach.sql.distsqlrun.ValuesCoreSpec")
	proto.RegisterType((*TableReaderSpec)(nil), "cockroach.sql.distsqlrun.TableReaderSpec")
	proto.RegisterType((*FiltererSpec)(nil), "cockroach.sql.distsqlrun.FiltererSpec")
	proto.RegisterType((*IndexSkipTableReaderSpec)(nil), "cockroach.sql.distsqlrun.IndexSkipTableReaderSpec")
	proto.RegisterType((*JoinReaderSpec)(nil), "cockroach.sql.distsqlrun.JoinReaderSpec")
	proto.RegisterType((*SorterSpec)(nil), "cockroach.sql.distsqlrun.SorterSpec")
	proto.RegisterType((*DistinctSpec)(nil), "cockroach.sql.distsqlrun.DistinctSpec")
	proto.RegisterType((*OrdinalitySpec)(nil), "cockroach.sql.distsqlrun.OrdinalitySpec")
	proto.RegisterType((*ZigzagJoinerSpec)(nil), "cockroach.sql.distsqlrun.ZigzagJoinerSpec")
	proto.RegisterType((*MergeJoinerSpec)(nil), "cockroach.sql.distsqlrun.MergeJoinerSpec")
	proto.RegisterType((*HashJoinerSpec)(nil), "cockroach.sql.distsqlrun.HashJoinerSpec")
	proto.RegisterType((*InvertedJoinerSpec)(nil), "cockroach.sql.distsqlrun.InvertedJoinerSpec")
	proto.RegisterType((*InvertedFiltererSpec)(nil), "cockroach.sql.distsqlrun.InvertedFiltererSpec")
	proto.RegisterType((*InvertedFiltererSpec_PreFiltererSpec)(nil), "cockroach.sql.distsqlrun.InvertedFiltererSpec.PreFiltererSpec")
	proto.RegisterType((*AggregatorSpec)(nil), "cockroach.sql.distsqlrun.AggregatorSpec")
	proto.RegisterType((*AggregatorSpec_Aggregation)(nil), "cockroach.sql.distsqlrun.AggregatorSpec.Aggregation")
	proto.RegisterType((*ProjectSetSpec)(nil), "cockroach.sql.distsqlrun.ProjectSetSpec")
	proto.RegisterType((*WindowerSpec)(nil), "cockroach.sql.distsqlrun.WindowerSpec")
	proto.RegisterType((*WindowerSpec_Func)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Func")
	proto.RegisterType((*WindowerSpec_Frame)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame")
	proto.RegisterType((*WindowerSpec_Frame_Bound)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bound")
	proto.RegisterType((*WindowerSpec_Frame_Bounds)(nil), "cockroach.sql.distsqlrun.WindowerSpec.Frame.Bounds")
	proto.RegisterType((*WindowerSpec_WindowFn)(nil), "cockroach.sql.distsqlrun.WindowerSpec.WindowFn")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_sql.proto", fileDescriptor_90493aed97b6d28f)
}

var fileDescriptor_90493aed97b6d28f = []byte{
	// 2975 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x3a, 0x4b, 0x6f, 0x1b, 0xd7,
	0xb9, 0xe2, 0x4b, 0x22, 0x3f, 0x3e, 0x74, 0x7c, 0x6c, 0xc7, 0x8c, 0x92, 0x2b, 0xcb, 0xb4, 0x63,
	0xcb, 0x8e, 0x23, 0xdf, 0xe8, 0x5e, 0xe4, 0x22, 0xb9, 0x45, 0x51, 0x8a, 0x1c, 0xd2, 0x94, 0xa9,
	0x19, 0x7a, 0x48, 0x4a, 0x72, 0x02, 0xf4, 0x60, 0x44, 0x1e, 0x51, 0x13, 0x0f, 0x67, 0xa8, 0x99,
	0xa1, 0x25, 0xe5, 0x0f, 0x74, 0x55, 0xa0, 0x45, 0x37, 0x45, 0x16, 0x45, 0x36, 0x45, 0x81, 0xae,
	0xfb, 0x13, 0x8a, 0xc2, 0xcb, 0xa0, 0x8b, 0x36, 0xab, 0xa2, 0x71, 0x76, 0xfd, 0x03, 0x45, 0x77,
	0xc5, 0x79, 0xcc, 0x68, 0xa8, 0x88, 0x6e, 0x68, 0x3b, 0xf1, 0xc6, 0xd0, 0xf7, 0x3c, 0xdf, 0xf9,
	0xde, 0x67, 0x68, 0xb8, 0xe1, 0x1d, 0x5a, 0xf7, 0xe8, 0x31, 0xed, 0x99, 0xf6, 0xbe, 0x6b, 0x8c,
	0xf6, 0xee, 0x8d, 0x5c, 0xa7, 0x47, 0x3d, 0xcf, 0x71, 0x3d, 0xe2, 0x1d, 0x5a, 0x6b, 0x23, 0xd7,
	0xf1, 0x1d, 0x5c, 0xec, 0x39, 0xbd, 0xc7, 0xae, 0x63, 0xf4, 0x0e, 0xd6, 0x18, 0xb2, 0x6f, 0x7a,
	0xbe, 0x77, 0x68, 0xb9, 0x63, 0x7b, 0xe9, 0x3a, 0x93, 0xef, 0x19, 0xbe, 0x61, 0x39, 0x83, 0x7b,
	0x7d, 0xea, 0xf5, 0x46, 0x7b, 0xf7, 0x3c, 0xdf, 0x1d, 0xf7, 0xfc, 0xb1, 0x4b, 0xfb, 0x42, 0x7c,
	0xa9, 0x74, 0x0e, 0xd3, 0xa7, 0x8e, 0x69, 0x13, 0xff, 0x64, 0x44, 0x25, 0xcf, 0xca, 0x39, 0x3c,
	0x96, 0xd3, 0x7b, 0x6c, 0xda, 0x03, 0xc9, 0x71, 0x99, 0x71, 0x30, 0x09, 0x4f, 0xfc, 0x2b, 0xd1,
	0x4b, 0x67, 0x6f, 0xd0, 0x37, 0x7c, 0x43, 0xd2, 0xde, 0x79, 0xce, 0xed, 0xf6, 0x0c, 0x8f, 0x46,
	0xed, 0x33, 0xed, 0x27, 0xd4, 0xf5, 0x69, 0xff, 0x9e, 0x37, 0x32, 0x6c, 0x42, 0x8f, 0x47, 0x2e,
	0xf5, 0x3c, 0xd3, 0xb1, 0x25, 0xcf, 0xa5, 0x81, 0x33, 0x70, 0xf8, 0x9f, 0xf7, 0xd8, 0x5f, 0x02,
	0x5b, 0xfa, 0x55, 0x0c, 0x0a, 0xdb, 0x86, 0x35, 0xa6, 0x5e, 0xc5, 0x71, 0x69, 0x7b, 0x44, 0x7b,
	0xb8, 0x02, 0x0b, 0x3d, 0xc7, 0x1a, 0x0f, 0x6d, 0xaf, 0x18, 0x5b, 0x49, 0xac, 0x66, 0xd7, 0xaf,
	0xaf, 0x4d, 0xf3, 0xde, 0x5a, 0xd5, 0xf0, 0xc7, 0xc3, 0x86, 0xbd, 0xef, 0x6c, 0x24, 0x9f, 0xfe,
	0xed, 0xea, 0x9c, 0x1e, 0x48, 0xe2, 0xab, 0x90, 0xb6, 0xc7, 0x43, 0xe2, 0x3a, 0x47, 0x5e, 0x31,
	0xb1, 0x12, 0x5b, 0x4d, 0x06, 0x0c, 0xf6, 0x78, 0xa8, 0x3b, 0x47, 0x1e, 0x7e, 0x0b, 0x32, 0xae,
	0x71, 0x44, 0xf6, 0x4e, 0x7c, 0xea, 0x15, 0xe3, 0x2b, 0x89, 0xd5, 0x9c, 0x9e, 0x76, 0x8d, 0xa3,
	0x0d, 0x06, 0x97, 0xfe, 0x3c, 0x0f, 0x8b, 0x1d, 0x63, 0xcf, 0xa2, 0x3a, 0x35, 0xfa, 0xd4, 0xe5,
	0x66, 0x6d, 0x40, 0xca, 0x67, 0xa8, 0x62, 0x6c, 0x25, 0xb6, 0x9a, 0x5d, 0xbf, 0x79, 0xc6, 0x28,
	0xef, 0xd0, 0xe2, 0x0e, 0xe1, 0x62, 0x55, 0xea, 0xf5, 0x5c, 0x73, 0xe4, 0x3b, 0xae, 0x3c, 0x56,
	0x88, 0xe2, 0x6b, 0x90, 0x31, 0xed, 0x3e, 0x3d, 0x26, 0x66, 0xff, 0xb8, 0x18, 0x5f, 0x89, 0xad,
	0xe6, 0x25, 0x3d, 0xcd, 0xd1, 0x8d, 0xfe, 0x31, 0x5e, 0x86, 0x05, 0x97, 0x3e, 0xa1, 0xae, 0x47,
	0xb9, 0xdd, 0xe9, 0xc0, 0x6e, 0x89, 0xc4, 0x0a, 0xa4, 0x98, 0x7f, 0xbd, 0x62, 0x92, 0xfb, 0xe6,
	0xf6, 0x74, 0xdf, 0x4c, 0x5c, 0xc0, 0xb0, 0x03, 0x4b, 0xb8, 0x34, 0xbe, 0x0e, 0x60, 0x99, 0x43,
	0xd3, 0x27, 0x07, 0xa6, 0xed, 0x17, 0x53, 0x2b, 0xb1, 0xd5, 0x84, 0x64, 0xc8, 0x70, 0xfc, 0x7d,
	0xd3, 0xf6, 0x99, 0x13, 0x4d, 0x8f, 0xf4, 0x0e, 0x68, 0xef, 0x71, 0x71, 0x3e, 0x6a, 0x8c, 0xe9,
	0x55, 0x18, 0x12, 0xab, 0x00, 0x4f, 0x4c, 0xcf, 0xdc, 0x33, 0x2d, 0xd3, 0x3f, 0x29, 0x2e, 0xac,
	0xc4, 0x56, 0x0b, 0xeb, 0xab, 0xd3, 0x2d, 0x6a, 0xf7, 0x0c, 0x7b, 0x3b, 0xe4, 0x97, 0xca, 0x22,
	0x1a, 0xf0, 0x4d, 0xc8, 0x8e, 0x0c, 0xd7, 0xb0, 0x2c, 0x6a, 0x99, 0x9f, 0xd1, 0x62, 0x2e, 0x72,
	0x66, 0x94, 0x80, 0xff, 0x1f, 0xae, 0x0c, 0x8d, 0x63, 0xe2, 0x9b, 0x43, 0xea, 0xf9, 0xc6, 0x70,
	0x44, 0x8c, 0x01, 0x25, 0xb6, 0x61, 0x3b, 0x5e, 0x31, 0x13, 0x09, 0xf6, 0xa5, 0xa1, 0x71, 0xdc,
	0x09, 0x78, 0xca, 0x03, 0xaa, 0x32, 0x0e, 0xfc, 0x09, 0x20, 0x59, 0x17, 0xc4, 0xf3, 0x5d, 0x6a,
	0x0f, 0xfc, 0x83, 0x22, 0x70, 0xd3, 0xef, 0x4c, 0x89, 0x29, 0xb3, 0xbb, 0x29, 0x44, 0xda, 0x52,
	0x42, 0x9e, 0xb0, 0x68, 0x4d, 0xa2, 0xf1, 0x1e, 0x5c, 0x0c, 0x94, 0x1f, 0x19, 0xa6, 0x4f, 0x46,
	0x8e, 0x65, 0xf6, 0x4e, 0x8a, 0x59, 0xae, 0xff, 0xee, 0x7f, 0xd6, 0xbf, 0x63, 0x98, 0x7e, 0x8b,
	0xcb, 0xc8, 0x13, 0x2e, 0x58, 0x67, 0x09, 0x78, 0x1d, 0xf0, 0x81, 0xe1, 0x11, 0xef, 0xc4, 0xf3,
	0xe9, 0x90, 0x04, 0xb5, 0x52, 0x88, 0x38, 0x0b, 0x1d, 0x18, 0x5e, 0x9b, 0x93, 0x2b, 0xb2, 0x1e,
	0xde, 0x81, 0x82, 0x4d, 0x69, 0x9f, 0xf6, 0x43, 0xfe, 0xc5, 0x95, 0xc4, 0x6a, 0x5e, 0xcf, 0x0b,
	0x6c, 0xc0, 0xa6, 0x42, 0xe1, 0x89, 0xe9, 0xfa, 0x63, 0xc3, 0x92, 0x7c, 0x45, 0xc4, 0xb3, 0xfd,
	0xd6, 0x14, 0xcb, 0x85, 0xdc, 0x69, 0xba, 0xeb, 0x79, 0x29, 0x2e, 0x08, 0x9b, 0xc9, 0x74, 0x1a,
	0x65, 0x36, 0x93, 0xe9, 0x3c, 0x2a, 0x94, 0x74, 0xc8, 0xd5, 0x4c, 0xcb, 0xa7, 0x6e, 0x58, 0x50,
	0xf3, 0xfb, 0x1c, 0x96, 0x15, 0x75, 0x63, 0x7a, 0xe2, 0x28, 0x61, 0x33, 0x91, 0x17, 0x94, 0x92,
	0xa5, 0x7f, 0x25, 0xa0, 0xd8, 0x60, 0xa5, 0xd3, 0x7e, 0x6c, 0x8e, 0x5e, 0x53, 0xc5, 0x86, 0x15,
	0x99, 0x78, 0xa9, 0x8a, 0x9c, 0xac, 0xa5, 0xe4, 0x4b, 0xd7, 0x52, 0xa4, 0x91, 0xa4, 0xce, 0x6b,
	0x24, 0xe7, 0x95, 0xc1, 0xfc, 0xf7, 0x5c, 0x06, 0x0b, 0xaf, 0xb0, 0x0c, 0x4a, 0xbf, 0x4b, 0x43,
	0x61, 0xd3, 0x31, 0xed, 0x1f, 0x3e, 0xe2, 0x0f, 0x20, 0x6b, 0x39, 0xce, 0xe3, 0xf1, 0x88, 0x4f,
	0x39, 0x59, 0x22, 0xb3, 0xa4, 0x2f, 0x08, 0x71, 0x86, 0xc7, 0xbb, 0x80, 0x5d, 0x3a, 0x74, 0x7c,
	0x4a, 0xa2, 0x3a, 0x2f, 0xcc, 0xac, 0x13, 0x09, 0x2d, 0xcd, 0x53, 0xcd, 0xb7, 0xa1, 0x20, 0x55,
	0x06, 0x35, 0xcf, 0x32, 0x34, 0xbf, 0x11, 0x47, 0x31, 0x3d, 0x2f, 0x28, 0x41, 0xdd, 0x7f, 0x08,
	0x6f, 0x4c, 0xb2, 0x12, 0xc3, 0xa5, 0xe4, 0x31, 0x3d, 0x29, 0xa6, 0x23, 0xb9, 0x73, 0x71, 0x42,
	0xa8, 0xec, 0xd2, 0x07, 0xf4, 0x84, 0x8d, 0x6b, 0x47, 0x8c, 0x7b, 0x9e, 0xb4, 0x33, 0xd6, 0xb1,
	0x63, 0x73, 0x53, 0x3f, 0x84, 0x24, 0x5b, 0x49, 0x64, 0x02, 0x5e, 0x9d, 0x12, 0x37, 0x16, 0xed,
	0xce, 0xc9, 0x88, 0x4a, 0x61, 0x2e, 0xf2, 0xca, 0x67, 0xd0, 0x79, 0x75, 0x91, 0xf9, 0x9e, 0xeb,
	0x02, 0x5e, 0xe5, 0x78, 0x78, 0x1f, 0x2e, 0x0c, 0x0d, 0xd3, 0xf6, 0x0d, 0xd3, 0x26, 0x8e, 0xdb,
	0xa7, 0xae, 0x69, 0x0f, 0xf8, 0x00, 0x0a, 0xa7, 0x43, 0x40, 0xd6, 0x24, 0x75, 0xca, 0x44, 0xc9,
	0x3f, 0x77, 0xa2, 0x54, 0xe1, 0x6d, 0x8b, 0xee, 0xfb, 0x84, 0xef, 0xa1, 0x47, 0xa6, 0x7f, 0x40,
	0x46, 0x86, 0xe9, 0xd2, 0x3e, 0x47, 0x50, 0x77, 0x62, 0x1e, 0x15, 0x19, 0x27, 0x8b, 0xde, 0x8e,
	0xe9, 0x1f, 0xb4, 0x38, 0xdb, 0x26, 0xe7, 0xc2, 0x3b, 0x70, 0xd3, 0x19, 0xfb, 0xa3, 0xb1, 0x4f,
	0x06, 0xae, 0xc3, 0xd3, 0xcf, 0xf6, 0x4d, 0x7b, 0x6c, 0xf8, 0xa6, 0x63, 0x93, 0x7d, 0xc7, 0x25,
	0xfc, 0x0c, 0xd7, 0x39, 0x2a, 0x2e, 0x46, 0xf4, 0x5d, 0x13, 0x32, 0x75, 0x26, 0x52, 0x89, 0x48,
	0xd4, 0x1c, 0xb7, 0x49, 0xf7, 0x7d, 0xdd, 0x39, 0xda, 0x4c, 0xa6, 0x53, 0x68, 0x7e, 0x33, 0x99,
	0xce, 0xa1, 0x3c, 0x5b, 0x32, 0xa1, 0xed, 0xb8, 0xbe, 0xec, 0x12, 0x0f, 0x61, 0x51, 0x9e, 0x19,
	0xba, 0x47, 0xf4, 0x8b, 0xd2, 0xf4, 0xb4, 0x09, 0x5c, 0x25, 0x0d, 0x28, 0x08, 0x05, 0x51, 0x07,
	0x06, 0xba, 0xc8, 0xd0, 0xf0, 0x7b, 0x07, 0xc4, 0xa2, 0xf6, 0x44, 0xf7, 0x40, 0x01, 0x7d, 0x8b,
	0x91, 0x9b, 0xd4, 0x2e, 0xfd, 0x32, 0x0e, 0xb9, 0xaa, 0xe9, 0xf9, 0xa6, 0xdd, 0xf3, 0xb9, 0x5d,
	0xb7, 0x60, 0x91, 0x33, 0x45, 0x86, 0x74, 0x8c, 0x0f, 0xe9, 0x82, 0x44, 0x07, 0xae, 0xbf, 0x0d,
	0xa8, 0x2f, 0x05, 0x43, 0xce, 0x38, 0xe7, 0x5c, 0x0c, 0xf0, 0x01, 0xeb, 0x3a, 0x60, 0x7b, 0x6c,
	0x59, 0xa2, 0x9e, 0x03, 0xe2, 0xc4, 0x66, 0x89, 0x38, 0xbd, 0xec, 0xd2, 0xc0, 0x16, 0x7c, 0x13,
	0x72, 0xd4, 0x75, 0x1d, 0x97, 0x38, 0x36, 0xe9, 0x8f, 0x47, 0xbc, 0xac, 0x33, 0x41, 0xa5, 0x70,
	0x8a, 0x66, 0x57, 0xc7, 0xa3, 0xf3, 0xfc, 0x98, 0x7a, 0x39, 0x3f, 0x96, 0x10, 0x14, 0x34, 0xb7,
	0x6f, 0xda, 0x06, 0x2b, 0x45, 0xe6, 0x94, 0xd2, 0xaf, 0x13, 0x80, 0x3e, 0x36, 0x07, 0x9f, 0x19,
	0x03, 0x91, 0x31, 0xdc, 0x53, 0x55, 0x98, 0xe7, 0xcd, 0x3a, 0x78, 0x21, 0xcc, 0xd6, 0xe8, 0xa5,
	0x2c, 0xae, 0x01, 0xd0, 0xc3, 0x09, 0x07, 0x66, 0xd7, 0xaf, 0x4d, 0x37, 0x5d, 0xba, 0x34, 0x58,
	0x93, 0xe9, 0xe1, 0x69, 0x38, 0x0a, 0x62, 0x62, 0x38, 0xc2, 0xf4, 0x89, 0x3e, 0xcb, 0x29, 0xf2,
	0x4e, 0xde, 0xab, 0x69, 0x96, 0x0f, 0x20, 0xb7, 0x6f, 0x1e, 0xd3, 0x3e, 0x79, 0xc2, 0x1f, 0x4e,
	0xc5, 0x14, 0xb7, 0xfc, 0x39, 0x3d, 0x6f, 0xf2, 0x81, 0xa5, 0x67, 0xb9, 0xb4, 0x40, 0xbe, 0x44,
	0xe7, 0x2d, 0xfd, 0x25, 0x01, 0x8b, 0x5b, 0xd4, 0x1d, 0xd0, 0x48, 0x64, 0xb6, 0x20, 0xcf, 0x2b,
	0xf6, 0x85, 0x2b, 0x2b, 0xc7, 0xc4, 0xc3, 0xba, 0xd2, 0xa0, 0xe0, 0x9a, 0x83, 0x83, 0x88, 0xbe,
	0xf8, 0x8c, 0xfa, 0xf2, 0x5c, 0x3e, 0x54, 0x18, 0x09, 0x40, 0xea, 0x75, 0x4c, 0xab, 0xdb, 0x90,
	0x67, 0xf5, 0x46, 0xe8, 0xe1, 0xd8, 0x08, 0x07, 0x56, 0x50, 0x8a, 0x39, 0x46, 0x52, 0x24, 0x05,
	0x7f, 0x04, 0x57, 0xb8, 0x2b, 0x4f, 0x73, 0x74, 0xca, 0x50, 0xa6, 0xfb, 0xbe, 0x72, 0x38, 0x39,
	0x94, 0x7f, 0x04, 0x45, 0xe1, 0xb7, 0x73, 0x84, 0x33, 0x11, 0xe1, 0x4b, 0x9c, 0xeb, 0x8c, 0x74,
	0xe9, 0x1f, 0x71, 0x28, 0xdc, 0x37, 0xbc, 0x83, 0x48, 0x5c, 0xef, 0xc0, 0xe2, 0x19, 0x63, 0x44,
	0x6f, 0x92, 0xcb, 0x44, 0xd4, 0x04, 0x7c, 0x17, 0xd0, 0xd9, 0xc3, 0x45, 0x7b, 0xe2, 0xcc, 0x85,
	0xc9, 0x23, 0x5f, 0x7b, 0x44, 0x5e, 0x9b, 0x9b, 0x37, 0x93, 0xe9, 0x05, 0x94, 0x2e, 0x7d, 0x9e,
	0x04, 0xdc, 0x90, 0x9f, 0x4e, 0x22, 0x0e, 0xff, 0x81, 0x56, 0x59, 0x0d, 0xf2, 0xc1, 0x77, 0x9b,
	0x17, 0x6d, 0x4b, 0xb9, 0x40, 0x01, 0x8f, 0xc4, 0xeb, 0x0e, 0xe7, 0xb9, 0xdb, 0xcf, 0xc2, 0x73,
	0xb7, 0x9f, 0xef, 0xbe, 0x83, 0xa4, 0x67, 0xda, 0x41, 0x58, 0x6a, 0x8d, 0x5c, 0xba, 0x6f, 0x1e,
	0x87, 0xe5, 0x1e, 0xd6, 0x43, 0x26, 0xac, 0x87, 0xcb, 0x82, 0x25, 0x28, 0x7b, 0x99, 0x22, 0x9b,
	0xc9, 0x74, 0x02, 0x25, 0x4b, 0x9f, 0x27, 0xe0, 0x52, 0x90, 0x1c, 0x13, 0x8f, 0xe7, 0x35, 0x40,
	0x61, 0xdc, 0x7a, 0x8e, 0xc5, 0x23, 0x1c, 0x8b, 0x44, 0xb8, 0x10, 0x50, 0x2b, 0x8e, 0xc5, 0xe2,
	0xbc, 0x7d, 0x36, 0xce, 0xa2, 0x8f, 0xbe, 0x7b, 0xc6, 0xb5, 0x01, 0xcf, 0x1a, 0x7b, 0x9f, 0x9e,
	0x86, 0xa7, 0xe5, 0x3a, 0xbe, 0x73, 0x6e, 0xb8, 0x3f, 0x85, 0x0b, 0x23, 0x97, 0x92, 0x7d, 0x69,
	0x1b, 0xf1, 0x46, 0xb4, 0xc7, 0xc3, 0x96, 0x5d, 0xff, 0xf1, 0xf4, 0xc0, 0x9f, 0x77, 0xa5, 0xb5,
	0x96, 0x4b, 0xa3, 0xb0, 0xbe, 0x38, 0x9a, 0x44, 0x2c, 0xfd, 0x3c, 0x06, 0x8b, 0x67, 0x98, 0xf0,
	0x26, 0xc0, 0xe9, 0x97, 0xc6, 0x17, 0xf8, 0x90, 0x10, 0x91, 0xc6, 0x6b, 0x32, 0xeb, 0x84, 0x6b,
	0x96, 0xce, 0x66, 0x1d, 0x1d, 0xae, 0x89, 0xcf, 0xa6, 0x1d, 0x39, 0xff, 0xfe, 0x04, 0x50, 0x28,
	0x0f, 0x06, 0x2e, 0x1d, 0x18, 0xbe, 0x23, 0xcc, 0xb9, 0x06, 0x10, 0xe4, 0x90, 0x15, 0x6d, 0x7a,
	0x99, 0x81, 0x48, 0x13, 0xcb, 0xc3, 0x3f, 0x85, 0x9c, 0x21, 0x85, 0x4c, 0x27, 0xfc, 0x6a, 0xf0,
	0xbf, 0xd3, 0x6d, 0x9e, 0x3c, 0x22, 0x04, 0x23, 0x05, 0x18, 0xd5, 0x87, 0xff, 0x5b, 0xae, 0xa2,
	0xb4, 0x4f, 0x22, 0xa6, 0x24, 0x43, 0x53, 0x90, 0xa4, 0xd6, 0x43, 0x8b, 0xea, 0xf2, 0xde, 0x29,
	0x5e, 0x6d, 0xef, 0x7d, 0x67, 0x4b, 0xbe, 0x55, 0x7b, 0xe7, 0x2c, 0x84, 0xf3, 0x2f, 0xb7, 0x10,
	0x2e, 0xfd, 0x2c, 0x0e, 0xd9, 0xc8, 0x8d, 0x99, 0xad, 0xfb, 0x63, 0xbb, 0xc7, 0x23, 0x3d, 0x8b,
	0xad, 0xb5, 0xb1, 0xdd, 0x0b, 0x6c, 0x65, 0x0a, 0xf0, 0x0a, 0xa4, 0xc3, 0x75, 0x38, 0x1e, 0x29,
	0xeb, 0x10, 0x8b, 0xaf, 0xf0, 0xef, 0xd0, 0xbc, 0xb2, 0x52, 0x7c, 0xb9, 0x9e, 0xef, 0x89, 0x5a,
	0xba, 0x01, 0x05, 0x91, 0xef, 0x61, 0xe5, 0xb1, 0xa6, 0x99, 0xd7, 0x73, 0x02, 0x2b, 0x2b, 0xee,
	0x3e, 0x64, 0x0c, 0x77, 0x30, 0x1e, 0x52, 0xdb, 0xf7, 0x8a, 0xf3, 0x3c, 0xc8, 0xb3, 0x24, 0xe6,
	0xa9, 0xb0, 0x6c, 0x05, 0xbf, 0x4f, 0x41, 0x92, 0xdd, 0x02, 0x23, 0xc8, 0x95, 0xd5, 0x47, 0x44,
	0xd5, 0x3a, 0x44, 0xed, 0x36, 0x9b, 0x68, 0x0e, 0x2f, 0x40, 0xa2, 0xbc, 0x5d, 0x47, 0x31, 0x9c,
	0x83, 0xf4, 0x86, 0xa6, 0x35, 0x49, 0x59, 0xad, 0xa2, 0x38, 0xce, 0xc2, 0x02, 0x87, 0x34, 0x1d,
	0x25, 0x70, 0x01, 0xa0, 0xa2, 0xa9, 0x95, 0x72, 0x87, 0x94, 0xeb, 0x75, 0x94, 0xc4, 0x19, 0x48,
	0x55, 0xb4, 0xae, 0xda, 0x41, 0x29, 0x26, 0xbe, 0x55, 0xde, 0x45, 0x0b, 0xfc, 0x8f, 0x86, 0x8a,
	0xd2, 0x18, 0x60, 0xbe, 0xdd, 0xa9, 0x56, 0x95, 0x6d, 0x94, 0x61, 0xc8, 0x76, 0x77, 0x0b, 0x01,
	0x53, 0xd7, 0xee, 0x6e, 0x91, 0x86, 0xda, 0x41, 0x59, 0x76, 0xd2, 0x76, 0x59, 0x6f, 0x94, 0xd5,
	0x8a, 0x82, 0x72, 0x8c, 0xb4, 0xab, 0xe9, 0x5c, 0x73, 0x5e, 0x9c, 0xd4, 0x55, 0x3b, 0x44, 0xd7,
	0x76, 0xda, 0xa8, 0xc0, 0xe5, 0x1e, 0xea, 0xd5, 0x46, 0xad, 0x86, 0x16, 0x31, 0x86, 0x42, 0xad,
	0xa1, 0x96, 0x9b, 0x24, 0x94, 0x46, 0xec, 0x42, 0x02, 0x27, 0xcf, 0xbc, 0x80, 0xf3, 0x90, 0x29,
	0xeb, 0x7a, 0xf9, 0x11, 0xd7, 0x88, 0xd9, 0x61, 0x9b, 0x6d, 0x4d, 0xe5, 0xd0, 0x45, 0x46, 0x64,
	0xd0, 0x06, 0x07, 0x2f, 0xb1, 0xe3, 0xda, 0x1d, 0xbd, 0xa1, 0xd6, 0x39, 0x7c, 0x99, 0xdf, 0xba,
	0xd1, 0xe1, 0x2e, 0x78, 0x83, 0x5d, 0x84, 0x01, 0x9a, 0x8e, 0xae, 0xe0, 0x34, 0x24, 0x2b, 0x9a,
	0xae, 0xa3, 0x22, 0x2e, 0xc2, 0xa5, 0x96, 0xa2, 0x57, 0x14, 0xb5, 0xd3, 0x68, 0x2a, 0xa4, 0xda,
	0x68, 0x57, 0x48, 0x63, 0xab, 0xd5, 0x44, 0x6f, 0x9e, 0xa1, 0x54, 0x34, 0xb5, 0x23, 0x28, 0x4b,
	0xf8, 0x22, 0x2c, 0x72, 0x1b, 0xb4, 0x8d, 0x4d, 0xa5, 0x22, 0x9c, 0xf8, 0x16, 0xbe, 0x04, 0x48,
	0x98, 0x12, 0xc1, 0xbe, 0xcd, 0x2c, 0xd8, 0x2e, 0xeb, 0xa4, 0xa5, 0xb5, 0xd0, 0x7f, 0x09, 0xf3,
	0xd8, 0xb5, 0x38, 0xbc, 0x8c, 0x17, 0x21, 0xdb, 0xee, 0x90, 0xad, 0xf2, 0x03, 0xa5, 0xd9, 0x50,
	0x15, 0x74, 0x95, 0x5d, 0xa7, 0xdd, 0x21, 0xca, 0x6e, 0x47, 0x51, 0x3b, 0x68, 0x85, 0xdd, 0xb5,
	0xdd, 0x21, 0x5d, 0xb5, 0xa1, 0xa9, 0xe8, 0x9a, 0x90, 0x26, 0x15, 0xad, 0xd9, 0x54, 0x2a, 0x1d,
	0x54, 0x62, 0xcc, 0x15, 0x2d, 0x50, 0x7e, 0x5d, 0xb8, 0x9a, 0x81, 0xed, 0xf2, 0x56, 0x0b, 0xdd,
	0x60, 0xde, 0xd5, 0x95, 0xba, 0xce, 0x62, 0xc4, 0x6e, 0xd1, 0xea, 0xa0, 0x77, 0x98, 0x35, 0x1c,
	0xa7, 0xaf, 0xa3, 0x9b, 0x4c, 0x80, 0x03, 0xed, 0xa6, 0xd6, 0x52, 0xd0, 0x2d, 0x76, 0x9a, 0x80,
	0x77, 0x77, 0xd1, 0xea, 0x29, 0xf4, 0xe8, 0x11, 0xba, 0x1d, 0xa1, 0x3d, 0x42, 0x77, 0x42, 0x49,
	0x91, 0x34, 0xef, 0x32, 0x4b, 0x38, 0x5c, 0xde, 0xae, 0xef, 0xa2, 0xbb, 0x51, 0xf0, 0x11, 0x7a,
	0xaf, 0x74, 0x17, 0x92, 0xac, 0x3b, 0x30, 0x9f, 0x97, 0xbb, 0x1d, 0x0d, 0xcd, 0xf1, 0x94, 0xaa,
	0x94, 0x9b, 0x65, 0x1d, 0xc5, 0x98, 0x2e, 0x55, 0x53, 0x89, 0x84, 0xe3, 0xa5, 0x3f, 0xc6, 0xa0,
	0xd0, 0x72, 0x9d, 0x4f, 0x69, 0xcf, 0x6f, 0x53, 0xf1, 0x16, 0xfe, 0x09, 0xa4, 0x58, 0x67, 0x0e,
	0x1e, 0x78, 0xb3, 0x54, 0x8e, 0x10, 0xc4, 0x75, 0xb8, 0x30, 0xa0, 0x36, 0x75, 0x0d, 0x3f, 0xf2,
	0x9e, 0x16, 0x8f, 0xbc, 0xe7, 0xb5, 0x76, 0x14, 0x0a, 0x05, 0x0b, 0xea, 0x2d, 0x40, 0xf6, 0x98,
	0x7f, 0x15, 0xf1, 0xc8, 0x88, 0xba, 0x64, 0x40, 0x6d, 0xf1, 0xc0, 0xd3, 0xf3, 0xf6, 0x78, 0xc8,
	0x3a, 0x68, 0x8b, 0xba, 0x75, 0x6a, 0x97, 0xbe, 0xce, 0x43, 0x6e, 0xc7, 0xb4, 0xfb, 0xce, 0x91,
	0x1c, 0x4e, 0x2b, 0xfc, 0xe7, 0x0c, 0xdf, 0xe4, 0xbd, 0xfa, 0x44, 0x3e, 0xe6, 0xa3, 0x28, 0xdc,
	0x86, 0xcc, 0x11, 0x97, 0xa8, 0x85, 0xc6, 0xdd, 0x9b, 0x7e, 0xd5, 0xa8, 0x72, 0x09, 0xd4, 0xc2,
	0x7e, 0x11, 0xea, 0x59, 0xfa, 0x43, 0x4c, 0x76, 0x8a, 0x36, 0xe4, 0x83, 0xd1, 0x40, 0x6b, 0x2f,
	0xda, 0x35, 0xf5, 0x49, 0x1d, 0xf8, 0x21, 0x80, 0x3c, 0x8a, 0x69, 0x8c, 0x73, 0x8d, 0xef, 0xcf,
	0x66, 0x33, 0xd3, 0x1a, 0x51, 0xf2, 0x51, 0xf2, 0xe9, 0x17, 0x57, 0x63, 0x4b, 0x5f, 0x2c, 0x40,
	0xaa, 0xe6, 0x1a, 0x43, 0x8a, 0x1f, 0x40, 0x72, 0xe8, 0xf4, 0xa9, 0x34, 0xf7, 0xbb, 0x2a, 0xe7,
	0xb2, 0x6b, 0x5b, 0x4e, 0x3f, 0x1c, 0x4a, 0x4c, 0x09, 0x7e, 0x08, 0xf3, 0x7b, 0xce, 0xd8, 0xee,
	0x7b, 0x72, 0xae, 0xff, 0xcf, 0x4c, 0xea, 0x36, 0xb8, 0x68, 0xb0, 0x9e, 0x0a, 0x45, 0xf8, 0x63,
	0xc8, 0xd0, 0xe3, 0x9e, 0x35, 0xe6, 0x3b, 0x47, 0x82, 0x1b, 0xf9, 0xc1, 0x4c, 0x5a, 0x95, 0x40,
	0x3a, 0xfc, 0x98, 0x10, 0x20, 0x96, 0xfe, 0x19, 0x83, 0x14, 0x3f, 0x94, 0x9d, 0xc2, 0xcf, 0x63,
	0x85, 0x24, 0x5d, 0xf1, 0xc1, 0xec, 0xb6, 0x47, 0x86, 0xf4, 0xa9, 0x3a, 0x7c, 0x1d, 0xc0, 0xb4,
	0x7d, 0xe2, 0xec, 0xef, 0x7b, 0x54, 0xcc, 0xbf, 0xe0, 0x37, 0xb3, 0x8c, 0x69, 0xfb, 0x1a, 0x47,
	0xe3, 0x6b, 0x90, 0x63, 0x55, 0xd1, 0x0f, 0xd8, 0xd8, 0x4d, 0x73, 0x7a, 0x96, 0xe3, 0x24, 0xcb,
	0x26, 0x64, 0x05, 0x91, 0xff, 0x12, 0x2d, 0x1f, 0x0f, 0x33, 0xfc, 0x5e, 0x0b, 0x42, 0x9a, 0xd9,
	0xb4, 0xf4, 0x9b, 0x18, 0xcc, 0x0b, 0x77, 0x63, 0x15, 0x52, 0x9e, 0x6f, 0xb8, 0xbe, 0x5c, 0xe8,
	0xd6, 0x67, 0xbf, 0x76, 0xf8, 0xdb, 0x0a, 0x53, 0x83, 0xab, 0x90, 0xa0, 0x76, 0x5f, 0x26, 0xc0,
	0x0b, 0x68, 0xd3, 0x99, 0x78, 0xe9, 0x16, 0x24, 0x59, 0x76, 0xb1, 0xd1, 0xa9, 0x97, 0xd5, 0xba,
	0x82, 0xe6, 0x58, 0x7f, 0xe3, 0x53, 0x2e, 0xc6, 0xfa, 0x5b, 0x5d, 0xd7, 0xba, 0xad, 0x36, 0x8a,
	0x97, 0x3e, 0x83, 0x4c, 0xe8, 0x7b, 0x7c, 0x05, 0x2e, 0x76, 0xd5, 0x0d, 0xad, 0xab, 0x56, 0x95,
	0x2a, 0x69, 0xe9, 0x4a, 0x45, 0xa9, 0x36, 0xd4, 0x3a, 0x9a, 0x9b, 0x24, 0xd4, 0xb4, 0x66, 0x53,
	0xdb, 0x61, 0x84, 0x18, 0x9b, 0x2a, 0x5a, 0xad, 0xd6, 0x56, 0x3a, 0x11, 0xf6, 0x78, 0x04, 0x7b,
	0xca, 0x9b, 0x60, 0xe3, 0xa4, 0xd2, 0xd5, 0x75, 0x45, 0x8c, 0x5b, 0x94, 0x2c, 0x7d, 0x02, 0x99,
	0x30, 0xbb, 0xd8, 0x64, 0x55, 0x35, 0xa2, 0xec, 0x56, 0x9a, 0xdd, 0x36, 0x1b, 0x28, 0xfc, 0x50,
	0x0e, 0x56, 0x15, 0x12, 0x95, 0x8b, 0xe1, 0x0b, 0x90, 0x0f, 0x08, 0xfc, 0x1e, 0x28, 0xce, 0xa4,
	0x03, 0x54, 0xa7, 0xa1, 0xb4, 0x51, 0x62, 0xe9, 0xaf, 0x71, 0x48, 0x07, 0x7d, 0x07, 0x2b, 0x91,
	0x55, 0xec, 0xdb, 0x2f, 0x89, 0xa9, 0x5e, 0x3d, 0xbb, 0x88, 0x2d, 0x41, 0xda, 0x70, 0x07, 0x5e,
	0xa3, 0x7f, 0xec, 0x15, 0x17, 0x78, 0x87, 0x0c, 0x61, 0x5c, 0x85, 0x74, 0xb8, 0x49, 0x26, 0x67,
	0xdc, 0x24, 0x43, 0x49, 0xf6, 0x94, 0xde, 0x67, 0xb1, 0x94, 0x0f, 0xd2, 0xbb, 0xb3, 0xc4, 0x5f,
	0x17, 0xa2, 0x78, 0x15, 0x26, 0xb6, 0x3b, 0xbe, 0xd7, 0xa6, 0x82, 0xfd, 0x7b, 0x62, 0xef, 0x5b,
	0x85, 0x9c, 0xd8, 0x61, 0x25, 0x67, 0x3a, 0xf2, 0x2a, 0x9b, 0xa0, 0x6c, 0x26, 0xd3, 0x71, 0x94,
	0x90, 0xdb, 0xdd, 0x6f, 0x63, 0x00, 0xa7, 0xdd, 0x91, 0x4f, 0x5b, 0x6d, 0x87, 0xa8, 0xdd, 0xad,
	0x0d, 0x45, 0x97, 0x79, 0x56, 0x56, 0x1f, 0x88, 0xd9, 0x59, 0x55, 0xd4, 0xb6, 0x42, 0x38, 0xcc,
	0x83, 0x24, 0x37, 0x16, 0x81, 0x49, 0xf0, 0x1d, 0xa1, 0xbb, 0xc5, 0xf7, 0x9a, 0x8e, 0x58, 0xf4,
	0xf8, 0x36, 0x23, 0x16, 0xbd, 0x66, 0xb9, 0x8e, 0xe6, 0x99, 0xba, 0xa6, 0x52, 0xae, 0xa2, 0x05,
	0x96, 0x3f, 0xb5, 0x86, 0xde, 0xee, 0x90, 0xed, 0x72, 0xb3, 0xab, 0xa0, 0x34, 0xd3, 0xdf, 0x2c,
	0x87, 0x70, 0x86, 0x69, 0x53, 0x3b, 0xf7, 0x25, 0x08, 0x77, 0xfe, 0x0f, 0x0a, 0x93, 0xbf, 0xa0,
	0xb0, 0xc4, 0x6f, 0x75, 0x37, 0x9a, 0x8d, 0x0a, 0x9a, 0xc3, 0x6f, 0xc2, 0x65, 0xf1, 0x37, 0x5b,
	0xbf, 0xf8, 0x86, 0x2a, 0x49, 0xb1, 0x8d, 0xf7, 0x9e, 0x7e, 0xbd, 0x3c, 0xf7, 0xf4, 0xd9, 0x72,
	0xec, 0xcb, 0x67, 0xcb, 0xb1, 0xaf, 0x9e, 0x2d, 0xc7, 0xfe, 0xfe, 0x6c, 0x39, 0xf6, 0x8b, 0x6f,
	0x96, 0xe7, 0xbe, 0xfc, 0x66, 0x79, 0xee, 0xab, 0x6f, 0x96, 0xe7, 0x3e, 0xce, 0x46, 0xfe, 0x9f,
	0xc9, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x70, 0x1f, 0x46, 0x09, 0x57, 0x23, 0x00, 0x00,
}

func (m *ValuesCoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValuesCoreSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValuesCoreSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.NumRows))
	i--
	dAtA[i] = 0x18
	if len(m.RawBytes) > 0 {
		for iNdEx := len(m.RawBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RawBytes[iNdEx])
			copy(dAtA[i:], m.RawBytes[iNdEx])
			i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.RawBytes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableReaderSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VirtualColumn != nil {
		{
			size, err := m.VirtualColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.NeededColumns) > 0 {
		for iNdEx := len(m.NeededColumns) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.NeededColumns[iNdEx]))
			i--
			dAtA[i] = 0x78
		}
	}
	i--
	if m.HasSystemColumns {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	i--
	if m.Parallelize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	i--
	dAtA[i] = 0x58
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	i--
	dAtA[i] = 0x50
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.MaxTimestampAgeNanos))
	i--
	dAtA[i] = 0x48
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	i--
	dAtA[i] = 0x38
	i--
	if m.IsCheck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LimitHint))
	i--
	dAtA[i] = 0x28
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i--
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FiltererSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiltererSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FiltererSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexSkipTableReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexSkipTableReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexSkipTableReaderSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	i--
	dAtA[i] = 0x38
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	i--
	dAtA[i] = 0x30
	i--
	if m.Reverse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	i--
	dAtA[i] = 0x20
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *JoinReaderSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinReaderSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinReaderSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RemoteLookupExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.LookupExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i--
	if m.OutputGroupContinuationForLeftRow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	i--
	if m.LeftJoinWithPairedJoiner {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	i--
	if m.HasSystemColumns {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	i--
	if m.MaintainOrdering {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingWaitPolicy))
	i--
	dAtA[i] = 0x50
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.LockingStrength))
	i--
	dAtA[i] = 0x48
	i--
	if m.LookupColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Visibility))
	i--
	dAtA[i] = 0x38
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	{
		size, err := m.OnExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.LookupColumns) > 0 {
		dAtA9 := make([]byte, len(m.LookupColumns)*10)
		var j8 int
		for _, num := range m.LookupColumns {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SorterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SorterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SorterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OrderingMatchLen))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.OutputOrdering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DistinctSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistinctSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DistinctSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutputOrdering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i -= len(m.ErrorOnDup)
	copy(dAtA[i:], m.ErrorOnDup)
	i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.ErrorOnDup)))
	i--
	dAtA[i] = 0x22
	i--
	if m.NullsAreDistinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.DistinctColumns) > 0 {
		for iNdEx := len(m.DistinctColumns) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.DistinctColumns[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	if len(m.OrderedColumns) > 0 {
		for iNdEx := len(m.OrderedColumns) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OrderedColumns[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrdinalitySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrdinalitySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrdinalitySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ZigzagJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZigzagJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZigzagJoinerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	if len(m.FixedValues) > 0 {
		for iNdEx := len(m.FixedValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FixedValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.OnExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.IndexOrdinals) > 0 {
		dAtA15 := make([]byte, len(m.IndexOrdinals)*10)
		var j14 int
		for _, num := range m.IndexOrdinals {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EqColumns) > 0 {
		for iNdEx := len(m.EqColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EqColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MergeJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeJoinerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	i--
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.NullEquality {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	{
		size, err := m.OnExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.RightOrdering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LeftOrdering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HashJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashJoinerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.RightEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	i--
	if m.LeftEqColumnsAreKey {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	{
		size, err := m.OnExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.RightEqColumns) > 0 {
		dAtA21 := make([]byte, len(m.RightEqColumns)*10)
		var j20 int
		for _, num := range m.RightEqColumns {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LeftEqColumns) > 0 {
		dAtA23 := make([]byte, len(m.LeftEqColumns)*10)
		var j22 int
		for _, num := range m.LeftEqColumns {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvertedJoinerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedJoinerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvertedJoinerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrefixEqualityColumns) > 0 {
		dAtA25 := make([]byte, len(m.PrefixEqualityColumns)*10)
		var j24 int
		for _, num := range m.PrefixEqualityColumns {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x4a
	}
	i--
	if m.OutputGroupContinuationForLeftRow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.MaintainOrdering {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x30
	{
		size, err := m.OnExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.InvertedExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IndexIdx))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InvertedFiltererSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedFiltererSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvertedFiltererSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreFiltererSpec != nil {
		{
			size, err := m.PreFiltererSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.InvertedExpr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.InvertedColIdx))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvertedFiltererSpec_PreFiltererSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvertedFiltererSpec_PreFiltererSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutputOrdering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x28
	if len(m.OrderedGroupCols) > 0 {
		dAtA35 := make([]byte, len(m.OrderedGroupCols)*10)
		var j34 int
		for _, num := range m.OrderedGroupCols {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aggregations) > 0 {
		for iNdEx := len(m.Aggregations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aggregations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GroupCols) > 0 {
		dAtA37 := make([]byte, len(m.GroupCols)*10)
		var j36 int
		for _, num := range m.GroupCols {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintProcessorsSql(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AggregatorSpec_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatorSpec_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregatorSpec_Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Arguments) > 0 {
		for iNdEx := len(m.Arguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Arguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ColIdx) > 0 {
		for iNdEx := len(m.ColIdx) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.ColIdx[iNdEx]))
			i--
			dAtA[i] = 0x28
		}
	}
	if m.FilterColIdx != nil {
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.FilterColIdx))
		i--
		dAtA[i] = 0x20
	}
	i--
	if m.Distinct {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Func))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ProjectSetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSetSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectSetSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NumColsPerGen) > 0 {
		for iNdEx := len(m.NumColsPerGen) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.NumColsPerGen[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for iNdEx := len(m.GeneratedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GeneratedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WindowerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WindowFns) > 0 {
		for iNdEx := len(m.WindowFns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WindowFns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.PartitionBy[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *WindowerSpec_Func) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Func) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec_Func) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WindowFunc != nil {
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.WindowFunc))
		i--
		dAtA[i] = 0x10
	}
	if m.AggregateFunc != nil {
		i = encodeVarintProcessorsSql(dAtA, i, uint64(*m.AggregateFunc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WindowerSpec_Frame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec_Frame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Exclusion))
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Bounds.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.Mode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *WindowerSpec_Frame_Bound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec_Frame_Bound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OffsetType.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.TypedOffset != nil {
		i -= len(m.TypedOffset)
		copy(dAtA[i:], m.TypedOffset)
		i = encodeVarintProcessorsSql(dAtA, i, uint64(len(m.TypedOffset)))
		i--
		dAtA[i] = 0x1a
	}
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.IntOffset))
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.BoundType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *WindowerSpec_Frame_Bounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_Frame_Bounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec_Frame_Bounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WindowerSpec_WindowFn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowerSpec_WindowFn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowerSpec_WindowFn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.OutputColIdx))
	i--
	dAtA[i] = 0x40
	if len(m.ArgsIdxs) > 0 {
		for iNdEx := len(m.ArgsIdxs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsSql(dAtA, i, uint64(m.ArgsIdxs[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	i = encodeVarintProcessorsSql(dAtA, i, uint64(m.FilterColIdx))
	i--
	dAtA[i] = 0x30
	if m.Frame != nil {
		{
			size, err := m.Frame.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Ordering.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsSql(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsSql(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsSql(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ValuesCoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.RawBytes) > 0 {
		for _, b := range m.RawBytes {
			l = len(b)
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.NumRows))
	return n
}

func (m *TableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	n += 2
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.LimitHint))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 1 + sovProcessorsSql(uint64(m.MaxTimestampAgeNanos))
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	n += 2
	n += 2
	if len(m.NeededColumns) > 0 {
		for _, e := range m.NeededColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if m.VirtualColumn != nil {
		l = m.VirtualColumn.Size()
		n += 2 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *FiltererSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Filter.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *IndexSkipTableReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	return n
}

func (m *JoinReaderSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	if len(m.LookupColumns) > 0 {
		l = 0
		for _, e := range m.LookupColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 1 + sovProcessorsSql(uint64(m.Visibility))
	n += 2
	n += 1 + sovProcessorsSql(uint64(m.LockingStrength))
	n += 1 + sovProcessorsSql(uint64(m.LockingWaitPolicy))
	n += 2
	n += 2
	n += 2
	n += 2
	l = m.LookupExpr.Size()
	n += 2 + l + sovProcessorsSql(uint64(l))
	l = m.RemoteLookupExpr.Size()
	n += 2 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *SorterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutputOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.OrderingMatchLen))
	return n
}

func (m *DistinctSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OrderedColumns) > 0 {
		for _, e := range m.OrderedColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.DistinctColumns) > 0 {
		for _, e := range m.DistinctColumns {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	n += 2
	l = len(m.ErrorOnDup)
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OutputOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *OrdinalitySpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ZigzagJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.EqColumns) > 0 {
		for _, e := range m.EqColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.IndexOrdinals) > 0 {
		l = 0
		for _, e := range m.IndexOrdinals {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if len(m.FixedValues) > 0 {
		for _, e := range m.FixedValues {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	return n
}

func (m *MergeJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.RightOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *HashJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LeftEqColumns) > 0 {
		l = 0
		for _, e := range m.LeftEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.RightEqColumns) > 0 {
		l = 0
		for _, e := range m.RightEqColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	return n
}

func (m *InvertedJoinerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.IndexIdx))
	l = m.InvertedExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.OnExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Type))
	n += 2
	n += 2
	if len(m.PrefixEqualityColumns) > 0 {
		l = 0
		for _, e := range m.PrefixEqualityColumns {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	return n
}

func (m *InvertedFiltererSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.InvertedColIdx))
	l = m.InvertedExpr.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.PreFiltererSpec != nil {
		l = m.PreFiltererSpec.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *InvertedFiltererSpec_PreFiltererSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Expression.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *AggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupCols) > 0 {
		l = 0
		for _, e := range m.GroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.OrderedGroupCols) > 0 {
		l = 0
		for _, e := range m.OrderedGroupCols {
			l += sovProcessorsSql(uint64(e))
		}
		n += 1 + sovProcessorsSql(uint64(l)) + l
	}
	n += 1 + sovProcessorsSql(uint64(m.Type))
	l = m.OutputOrdering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *AggregatorSpec_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Func))
	n += 2
	if m.FilterColIdx != nil {
		n += 1 + sovProcessorsSql(uint64(*m.FilterColIdx))
	}
	if len(m.ColIdx) > 0 {
		for _, e := range m.ColIdx {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *ProjectSetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.GeneratedColumns) > 0 {
		for _, e := range m.GeneratedColumns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	if len(m.NumColsPerGen) > 0 {
		for _, e := range m.NumColsPerGen {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	return n
}

func (m *WindowerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	if len(m.WindowFns) > 0 {
		for _, e := range m.WindowFns {
			l = e.Size()
			n += 1 + l + sovProcessorsSql(uint64(l))
		}
	}
	return n
}

func (m *WindowerSpec_Func) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.AggregateFunc))
	}
	if m.WindowFunc != nil {
		n += 1 + sovProcessorsSql(uint64(*m.WindowFunc))
	}
	return n
}

func (m *WindowerSpec_Frame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.Mode))
	l = m.Bounds.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	n += 1 + sovProcessorsSql(uint64(m.Exclusion))
	return n
}

func (m *WindowerSpec_Frame_Bound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsSql(uint64(m.BoundType))
	n += 1 + sovProcessorsSql(uint64(m.IntOffset))
	if m.TypedOffset != nil {
		l = len(m.TypedOffset)
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	l = m.OffsetType.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	return n
}

func (m *WindowerSpec_Frame_Bounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	return n
}

func (m *WindowerSpec_WindowFn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Func.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	l = m.Ordering.Size()
	n += 1 + l + sovProcessorsSql(uint64(l))
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovProcessorsSql(uint64(l))
	}
	n += 1 + sovProcessorsSql(uint64(m.FilterColIdx))
	if len(m.ArgsIdxs) > 0 {
		for _, e := range m.ArgsIdxs {
			n += 1 + sovProcessorsSql(uint64(e))
		}
	}
	n += 1 + sovProcessorsSql(uint64(m.OutputColIdx))
	return n
}

func sovProcessorsSql(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessorsSql(x uint64) (n int) {
	return sovProcessorsSql(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WindowerSpec_Func) GetValue() interface{} {
	if this.AggregateFunc != nil {
		return this.AggregateFunc
	}
	if this.WindowFunc != nil {
		return this.WindowFunc
	}
	return nil
}

func (this *WindowerSpec_Func) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *AggregatorSpec_Func:
		this.AggregateFunc = vt
	case *WindowerSpec_WindowFunc:
		this.WindowFunc = vt
	default:
		return false
	}
	return true
}
func (m *ValuesCoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValuesCoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValuesCoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, DatumInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes, make([]byte, postIndex-iNdEx))
			copy(m.RawBytes[len(m.RawBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			m.NumRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitHint", wireType)
			}
			m.LimitHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitHint |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCheck = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= ScanVisibility(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestampAgeNanos", wireType)
			}
			m.MaxTimestampAgeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestampAgeNanos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= descpb.ScanLockingStrength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= descpb.ScanLockingWaitPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Parallelize = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasSystemColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasSystemColumns = bool(v != 0)
		case 15:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NeededColumns = append(m.NeededColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NeededColumns) == 0 {
					m.NeededColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NeededColumns = append(m.NeededColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NeededColumns", wireType)
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualColumn == nil {
				m.VirtualColumn = &descpb.ColumnDescriptor{}
			}
			if err := m.VirtualColumn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiltererSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FiltererSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FiltererSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexSkipTableReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexSkipTableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= ScanVisibility(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= descpb.ScanLockingStrength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= descpb.ScanLockingWaitPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinReaderSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LookupColumns = append(m.LookupColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LookupColumns) == 0 {
					m.LookupColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LookupColumns = append(m.LookupColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumns", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= descpb.JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= ScanVisibility(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LookupColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingStrength", wireType)
			}
			m.LockingStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingStrength |= descpb.ScanLockingStrength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingWaitPolicy", wireType)
			}
			m.LockingWaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockingWaitPolicy |= descpb.ScanLockingWaitPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainOrdering = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasSystemColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasSystemColumns = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoinWithPairedJoiner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftJoinWithPairedJoiner = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputGroupContinuationForLeftRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputGroupContinuationForLeftRow = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LookupExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteLookupExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoteLookupExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SorterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SorterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SorterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderingMatchLen", wireType)
			}
			m.OrderingMatchLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderingMatchLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistinctSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistinctSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistinctSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedColumns = append(m.OrderedColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedColumns) == 0 {
					m.OrderedColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedColumns = append(m.OrderedColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DistinctColumns = append(m.DistinctColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DistinctColumns) == 0 {
					m.DistinctColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DistinctColumns = append(m.DistinctColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctColumns", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullsAreDistinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullsAreDistinct = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorOnDup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorOnDup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrdinalitySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrdinalitySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrdinalitySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZigzagJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZigzagJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, descpb.TableDescriptor{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqColumns = append(m.EqColumns, Columns{})
			if err := m.EqColumns[len(m.EqColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexOrdinals = append(m.IndexOrdinals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexOrdinals) == 0 {
					m.IndexOrdinals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexOrdinals = append(m.IndexOrdinals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexOrdinals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedValues = append(m.FixedValues, &ValuesCoreSpec{})
			if err := m.FixedValues[len(m.FixedValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= descpb.JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= descpb.JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullEquality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullEquality = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeftEqColumns = append(m.LeftEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeftEqColumns) == 0 {
					m.LeftEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeftEqColumns = append(m.LeftEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumns", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RightEqColumns = append(m.RightEqColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RightEqColumns) == 0 {
					m.RightEqColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RightEqColumns = append(m.RightEqColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumns", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= descpb.JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeftEqColumnsAreKey = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightEqColumnsAreKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightEqColumnsAreKey = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedJoinerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedJoinerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedJoinerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InvertedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= descpb.JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintainOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaintainOrdering = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputGroupContinuationForLeftRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputGroupContinuationForLeftRow = bool(v != 0)
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrefixEqualityColumns = append(m.PrefixEqualityColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrefixEqualityColumns) == 0 {
					m.PrefixEqualityColumns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrefixEqualityColumns = append(m.PrefixEqualityColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixEqualityColumns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedFiltererSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvertedFiltererSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvertedFiltererSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedColIdx", wireType)
			}
			m.InvertedColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedColIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InvertedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreFiltererSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreFiltererSpec == nil {
				m.PreFiltererSpec = &InvertedFiltererSpec_PreFiltererSpec{}
			}
			if err := m.PreFiltererSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvertedFiltererSpec_PreFiltererSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreFiltererSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreFiltererSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupCols = append(m.GroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupCols) == 0 {
					m.GroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupCols = append(m.GroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, AggregatorSpec_Aggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderedGroupCols = append(m.OrderedGroupCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderedGroupCols) == 0 {
					m.OrderedGroupCols = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderedGroupCols = append(m.OrderedGroupCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedGroupCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AggregatorSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutputOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatorSpec_Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			m.Func = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Func |= AggregatorSpec_Func(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distinct = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterColIdx = &v
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColIdx = append(m.ColIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColIdx) == 0 {
					m.ColIdx = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColIdx = append(m.ColIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, Expression{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, Expression{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedColumns = append(m.GeneratedColumns, &types.T{})
			if err := m.GeneratedColumns[len(m.GeneratedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NumColsPerGen = append(m.NumColsPerGen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NumColsPerGen) == 0 {
					m.NumColsPerGen = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NumColsPerGen = append(m.NumColsPerGen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColsPerGen", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionBy = append(m.PartitionBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionBy) == 0 {
					m.PartitionBy = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionBy = append(m.PartitionBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowFns = append(m.WindowFns, WindowerSpec_WindowFn{})
			if err := m.WindowFns[len(m.WindowFns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Func) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Func: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Func: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateFunc", wireType)
			}
			var v AggregatorSpec_Func
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= AggregatorSpec_Func(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AggregateFunc = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFunc", wireType)
			}
			var v WindowerSpec_WindowFunc
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WindowerSpec_WindowFunc(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowFunc = &v
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= WindowerSpec_Frame_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusion", wireType)
			}
			m.Exclusion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exclusion |= WindowerSpec_Frame_Exclusion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundType", wireType)
			}
			m.BoundType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoundType |= WindowerSpec_Frame_BoundType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntOffset", wireType)
			}
			m.IntOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypedOffset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypedOffset = append(m.TypedOffset[:0], dAtA[iNdEx:postIndex]...)
			if m.TypedOffset == nil {
				m.TypedOffset = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OffsetType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_Frame_Bounds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &WindowerSpec_Frame_Bound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowerSpec_WindowFn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowFn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowFn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ordering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &WindowerSpec_Frame{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdx", wireType)
			}
			m.FilterColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsIdxs = append(m.ArgsIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsSql
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsSql
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsIdxs) == 0 {
					m.ArgsIdxs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsSql
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsIdxs = append(m.ArgsIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsIdxs", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputColIdx", wireType)
			}
			m.OutputColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputColIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsSql(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsSql
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsSql(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsSql
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsSql
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsSql
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsSql
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsSql
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsSql        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsSql          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsSql = fmt.Errorf("proto: unexpected end of group")
)
