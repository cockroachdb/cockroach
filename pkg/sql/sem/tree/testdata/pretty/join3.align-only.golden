// Code generated by TestPretty. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
1:
-
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

9:
---------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		) AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

10:
----------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	) AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

13:
-------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         )
			AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN
			(
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
			) AS i
         ON
			ct.oid
			= i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON
			ci.oid
			= i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON
			ci.relam
			= am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

15:
---------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON
			ct.oid
			= i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON
			ci.oid
			= i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON
			ci.relam
			= am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

18:
------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON
			ci.relam
			= am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

20:
--------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON ci.relam
            = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

24:
------------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON ci.relam
            = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

25:
-------------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON
			ct.relnamespace
			= n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON ci.relam
            = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

27:
---------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON ci.relam
            = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname
			= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

29:
-----------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN
			pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

30:
------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid
            = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

31:
-------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

32:
--------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN
			pg_catalog.pg_class
				AS ci
         ON ci.oid
            = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname
			= 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

33:
---------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class
				AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

34:
----------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace
            = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class
				AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

35:
-----------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT
					i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
				FROM
					pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class
				AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am
				AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

36:
------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN
			pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class
				AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

37:
-------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class
				AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

39:
---------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

40:
----------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique
			AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

41:
-----------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace
				AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

42:
------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index
						AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

47:
-----------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

50:
--------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

55:
-------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am
         ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

57:
---------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       )
						AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

58:
----------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
         AND n.nspname = 'public'
         AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

59:
-----------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci
         ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

64:
----------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

66:
------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n
         ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

69:
---------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

74:
--------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(
						i.indkey
				       ) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

75:
---------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

79:
-------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

89:
-----------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

90:
------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

110:
--------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

138:
------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid,
				       i.indrelid,
				       i.indoption,
				       i.indisunique,
				       i.indisclustered,
				       i.indpred,
				       i.indexprs,
				       information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

170:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys
				  FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

200:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (
				SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i
              ) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

205:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
         ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

228:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
         JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
         JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid
         JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
         JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

420:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

626:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1154:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j' ORDER BY non_unique, type, index_name, ordinal_position


