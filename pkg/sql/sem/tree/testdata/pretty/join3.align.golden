1:
-
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

9:
---------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		) AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

10:
----------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	) AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

11:
-----------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true
       THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       )
		AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1
       THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

13:
-------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true
       THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1
       THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

15:
---------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true
       THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1
       THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

20:
--------------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true
       THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1
       THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

22:
----------------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true
       THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace
	   = n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

23:
-----------------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace
	   = n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
	     ) AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

24:
------------------------
SELECT NULL
		AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash'
       THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END
		AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid
        = i.indrelid
     JOIN
		pg_catalog.pg_class
			AS ci
     ON ci.oid
        = i.indexrelid
     JOIN
		pg_catalog.pg_am
			AS am
     ON ci.relam
        = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

25:
-------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid
        = i.indrelid
     JOIN
		pg_catalog.pg_class
			AS ci
     ON ci.oid
        = i.indexrelid
     JOIN
		pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname
		= 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

26:
--------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid
        = i.indrelid
     JOIN
		pg_catalog.pg_class
			AS ci
     ON ci.oid
        = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

27:
---------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END
		AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages
		AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN
		pg_catalog.pg_class
			AS ci
     ON ci.oid
        = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

28:
----------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN
		pg_catalog.pg_class
			AS ci
     ON ci.oid
        = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

29:
-----------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       )
		AS filter_condition
FROM pg_catalog.pg_class
		AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class
			AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname
		= 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

30:
------------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL
		AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace
        = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class
			AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

31:
-------------------------------
SELECT NULL AS table_cat,
       n.nspname
		AS table_schem,
       ct.relname
		AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname
		AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class
			AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am
			AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

32:
--------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN
		pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class
			AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

33:
---------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples
		AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class
			AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

35:
-----------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

36:
------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n
		AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace
			AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

38:
--------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique
		AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

39:
---------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index
					AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

41:
-----------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1]
       & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

48:
------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am
     ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

53:
-----------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

54:
------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

55:
-------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname
       WHEN 'hash' THEN 2
       ELSE 3
       END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true
      AND n.nspname = 'public'
      AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

56:
--------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci
     ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

60:
------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

62:
--------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n
     ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

65:
-----------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

71:
-----------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
       ) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

72:
------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1
       WHEN 1 THEN 'D'
       ELSE 'A'
       END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

77:
-----------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true
       THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

87:
---------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
       ) AS column_name,
       CASE am.amcanorder
       WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

88:
----------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered
       WHEN true THEN 1
       ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
       END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder
       WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

108:
------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder
       WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
       ELSE NULL
       END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

136:
----------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

166:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys
			FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

196:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (
			SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i
          ) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

201:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
     ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

224:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
     JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
     JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid
     JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
     JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

416:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
       n.nspname AS table_schem,
       ct.relname AS table_name,
       NOT i.indisunique AS non_unique,
       NULL AS index_qualifier,
       ci.relname AS index_name,
       CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
       (i.keys).n AS ordinal_position,
       btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
       CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
       ci.reltuples AS cardinality,
       ci.relpages AS pages,
       pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

624:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1098:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1154:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j' ORDER BY non_unique, type, index_name, ordinal_position
