// Code generated by TestPretty. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
1:
-
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

19:
-------------------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

20:
--------------------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

22:
----------------------
SELECT
	NULL AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

24:
------------------------
SELECT
	NULL AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

25:
-------------------------
SELECT
	NULL AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

26:
--------------------------
SELECT
	NULL AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

28:
----------------------------
SELECT
	NULL AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

29:
-----------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

30:
------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid = i.indexrelid
	JOIN
		pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

31:
-------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

32:
--------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

33:
---------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN
		pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

34:
----------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

35:
-----------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

36:
------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN
		pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

37:
-------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

40:
----------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

45:
---------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

49:
-------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

50:
--------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am
	ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

52:
----------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname
	WHEN 'hash' THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

53:
-----------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true
	AND n.nspname = 'public'
	AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

54:
------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci
	ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

59:
-----------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

60:
------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

62:
--------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n
	ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

64:
----------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey)
					AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

68:
--------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

69:
---------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1
	WHEN 1 THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

74:
--------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

84:
------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		AS column_name,
	CASE am.amcanorder
	WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

85:
-------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered
	WHEN true THEN 1
	ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	END
		AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder
	WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

105:
---------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder
	WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

133:
-------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

163:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(
			SELECT
				i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys
			FROM
				pg_catalog.pg_index AS i
		)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

194:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i)
			AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

199:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN
		(SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

200:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
	ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

223:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct
	JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid
	JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

415:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat,
	n.nspname AS table_schem,
	ct.relname AS table_name,
	NOT i.indisunique AS non_unique,
	NULL AS index_qualifier,
	ci.relname AS index_name,
	CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	(i.keys).n AS ordinal_position,
	btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	ci.reltuples AS cardinality,
	ci.relpages AS pages,
	pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

621:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT
	NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM
	pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE
	true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY
	non_unique, type, index_name, ordinal_position

1154:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j' ORDER BY non_unique, type, index_name, ordinal_position


