1:
-
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

10:
----------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

11:
-----------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true
	   THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1
	   THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON
		ct.oid
		= i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON
		ci.oid
		= i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

13:
-------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true
	   THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1
	   THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON
		ci.relam
		= am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

15:
---------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true
	   THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1
	   THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

20:
--------------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true
	   THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1
	   THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON
		ct.relnamespace
		= n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

22:
----------------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true
	   THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace
	   = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

23:
-----------------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN
		pg_catalog.pg_namespace
			AS n
	ON ct.relnamespace
	   = n.oid
	JOIN
		(
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i
	ON ct.oid
	   = i.indrelid
	JOIN
		pg_catalog.pg_class
			AS ci
	ON ci.oid
	   = i.indexrelid
	JOIN
		pg_catalog.pg_am
			AS am
	ON ci.relam
	   = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

24:
------------------------
SELECT NULL
		   AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash'
	   THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid
		= i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid
		= i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam
		= am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

25:
-------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid
		= i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid
		= i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname
		  = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

26:
--------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid
		= i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid
		= i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

27:
---------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages
		   AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid
		= i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

28:
----------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid
		= i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

29:
-----------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class
		 AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid = i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname
		  = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

30:
------------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL
		   AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace
		= n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid = i.indexrelid
	 JOIN
		 pg_catalog.pg_am
			 AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

31:
-------------------------------
SELECT NULL AS table_cat,
	   n.nspname
		   AS table_schem,
	   ct.relname
		   AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname
		   AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid = i.indexrelid
	 JOIN
		 pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

32:
--------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT
				 i.indexrelid,
				 i.indrelid,
				 i.indoption,
				 i.indisunique,
				 i.indisclustered,
				 i.indpred,
				 i.indexprs,
				 information_schema._pg_expandarray(
					 i.indkey
				 )
					 AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

33:
---------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class
			 AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

34:
----------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples
		   AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN
		 pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

35:
-----------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace
			 AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM
				 pg_catalog.pg_index
					 AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

37:
-------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n
		   AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN
		 pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index
					  AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

38:
--------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique
		   AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index
					  AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

39:
---------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index
					  AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

42:
------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1]
	   & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

48:
------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(
		   i.indpred,
		   i.indrelid
	   )
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

52:
----------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am
	 ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

53:
-----------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique,
		 type,
		 index_name,
		 ordinal_position

55:
-------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname
	   WHEN 'hash' THEN 2
	   ELSE 3
	   END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true
	  AND n.nspname = 'public'
	  AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

56:
--------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci
	 ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

60:
------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(
						i.indkey
					)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

64:
----------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(
			   ci.oid,
			   (i.keys).n,
			   false
		   ),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n
	 ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

65:
-----------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(
		   pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
		   '"'
	   )
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid)
		   AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey)
						AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

72:
------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1
	   WHEN 1 THEN 'D'
	   ELSE 'A'
	   END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

77:
-----------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true
	   THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

87:
---------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"')
		   AS column_name,
	   CASE am.amcanorder
	   WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

88:
----------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered
	   WHEN true THEN 1
	   ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
	   END
		   AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder
	   WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

108:
------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder
	   WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
	   ELSE NULL
	   END
		   AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

136:
----------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid,
					i.indrelid,
					i.indoption,
					i.indisunique,
					i.indisclustered,
					i.indpred,
					i.indexprs,
					information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

167:
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (
			 SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys
			 FROM pg_catalog.pg_index AS i
		 )
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

195:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i)
			 AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

200:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN
		 (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

201:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i
	 ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

224:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct
	 JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
	 JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid
	 JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
	 JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

416:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat,
	   n.nspname AS table_schem,
	   ct.relname AS table_name,
	   NOT i.indisunique AS non_unique,
	   NULL AS index_qualifier,
	   ci.relname AS index_name,
	   CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
	   (i.keys).n AS ordinal_position,
	   btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
	   CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
	   ci.reltuples AS cardinality,
	   ci.relpages AS pages,
	   pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

624:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1098:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1154:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j' ORDER BY non_unique, type, index_name, ordinal_position
