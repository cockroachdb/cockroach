// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package builtins_test

import (
	"context"
	gosql "database/sql"
	"net/url"
	"testing"

	"github.com/cockroachdb/cockroach/pkg/base"
	"github.com/cockroachdb/cockroach/pkg/jobs"
	"github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	"github.com/cockroachdb/cockroach/pkg/security/username"
	"github.com/cockroachdb/cockroach/pkg/spanconfig"
	"github.com/cockroachdb/cockroach/pkg/testutils/serverutils"
	"github.com/cockroachdb/cockroach/pkg/testutils/sqlutils"
	"github.com/cockroachdb/cockroach/pkg/upgrade/upgradebase"
	"github.com/cockroachdb/cockroach/pkg/util/leaktest"
	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/cockroachdb/cockroach/pkg/util/protoutil"
	"github.com/cockroachdb/cockroach/pkg/util/timeutil"
	"github.com/stretchr/testify/assert"
)

var _ jobs.Resumer = &fakeResumer{}

type fakeResumer struct {
}

// Resume implements the jobs.Resumer interface.
func (*fakeResumer) Resume(ctx context.Context, execCtx interface{}) error {
	return nil
}

// Resume implements the jobs.Resumer interface.
func (*fakeResumer) OnFailOrCancel(ctx context.Context, execCtx interface{}, jobErr error) error {
	return jobErr
}

// TestJobsGeneratorBuiltinMirrorsSystemJobsTable asserts that
// entries created in system.jobs exactly match the results generated by
// crdb_internal.jobs. This test also asserts that the columns match.
func TestJobsGeneratorBuiltinMirrorsSystemJobsTable(t *testing.T) {
	defer leaktest.AfterTest(t)()
	defer log.Scope(t).Close(t)

	s, db, _ := serverutils.StartServer(t, base.TestServerArgs{
		Knobs: base.TestingKnobs{
			// Because this test modifies system.jobs and asserts its contents,
			// we should disable jobs from being adopted and disable automatic jobs
			// from being created.
			JobsTestingKnobs: &jobs.TestingKnobs{
				DisableAdoptions: true,
			},
			// DisableAdoptions needs this.
			UpgradeManager: &upgradebase.TestingKnobs{
				DontUseJobs: true,
			},
			SpanConfig: &spanconfig.TestingKnobs{
				ManagerDisableJobCreation: true,
			},
		},
	})
	ctx := context.Background()
	defer s.Stopper().Stop(ctx)
	tdb := sqlutils.MakeSQLRunner(db)

	payload := jobspb.Payload{
		Details:       jobspb.WrapPayloadDetails(jobspb.ImportDetails{}),
		UsernameProto: username.RootUserName().EncodeProto(),
	}
	payloadBytes, err := protoutil.Marshal(&payload)
	assert.NoError(t, err)

	tdb.Exec(t,
		"INSERT INTO system.jobs (id, status, created, payload) values ($1, $2, $3, $4)",
		1, jobs.StatusRunning, timeutil.Now(), payloadBytes,
	)

	tdb.Exec(t,
		"INSERT INTO system.jobs values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)",
		2, jobs.StatusRunning, timeutil.Now(), payloadBytes, []byte("progress"), "created by", 2, []byte("claim session id"),
		2, 2, timeutil.Now(),
	)

	res := tdb.QueryStr(t, "SELECT * FROM system.jobs ORDER BY id")
	tdb.CheckQueryResults(t, `SELECT * FROM crdb_internal.system_jobs() ORDER BY id`, res)
	tdb.CheckQueryResults(t, `
			SELECT id, status, created, payload, progress, created_by_type, created_by_id, claim_session_id, claim_instance_id, num_runs, last_run
			FROM crdb_internal.system_jobs() ORDER BY id`,
		res,
	)
	tdb.CheckQueryResults(t, `
			SELECT id, status, created, payload, progress, created_by_type, created_by_id, claim_session_id, claim_instance_id, num_runs, last_run
			FROM system.jobs ORDER BY id`,
		res,
	)
}

// TestJobsGeneratorBuiltinJobAccess asserts which entries a user can query
// based on their grants and role options.
func TestJobsGeneratorBuiltinJobAccess(t *testing.T) {
	defer leaktest.AfterTest(t)()
	defer log.Scope(t).Close(t)

	s, db, _ := serverutils.StartServer(t, base.TestServerArgs{})
	ctx := context.Background()
	defer s.Stopper().Stop(ctx)
	rootDB := sqlutils.MakeSQLRunner(db)

	// Even though this test modifies the system.jobs table and asserts its contents, we
	// do not disable background job creation or job adoption. This is because creating
	// users requires jobs to be created and run. Thus, this test only creates jobs of type
	// jobspb.TypeImport and overrides the import resumer.
	registry := s.JobRegistry().(*jobs.Registry)
	registry.TestingResumerCreationKnobs = map[jobspb.Type]func(raw jobs.Resumer) jobs.Resumer{}
	registry.TestingResumerCreationKnobs[jobspb.TypeImport] = func(r jobs.Resumer) jobs.Resumer {
		return &fakeResumer{}
	}

	asUser := func(user string, f func(userDB *sqlutils.SQLRunner)) {
		pgURL := url.URL{
			Scheme: "postgres",
			User:   url.UserPassword(user, "test"),
			Host:   s.SQLAddr(),
			Path:   `d`,
		}
		db2, err := gosql.Open("postgres", pgURL.String())
		assert.NoError(t, err)
		defer db2.Close()
		userDB := sqlutils.MakeSQLRunner(db2)

		f(userDB)
	}

	rootDB.Exec(t, "CREATE USER user1 WITH CONTROLJOB PASSWORD 'test'")
	rootDB.Exec(t, "CREATE USER user2 WITH PASSWORD 'test'")

	// Create a job with user1 as the owner.
	user1Payload := jobspb.Payload{
		Details:       jobspb.WrapPayloadDetails(jobspb.ImportDetails{}),
		UsernameProto: username.MakeSQLUsernameFromPreNormalizedString("user1").EncodeProto(),
	}
	user1PayloadBytes, err := protoutil.Marshal(&user1Payload)
	rootDB.Exec(t,
		"INSERT INTO system.jobs (id, status, created, payload) values ($1, $2, $3, $4)",
		1, jobs.StatusRunning, timeutil.Now(), user1PayloadBytes,
	)
	assert.NoError(t, err)

	// Create a job with user2 as the owner.
	user2Payload := jobspb.Payload{
		Details:       jobspb.WrapPayloadDetails(jobspb.ImportDetails{}),
		UsernameProto: username.MakeSQLUsernameFromPreNormalizedString("user2").EncodeProto(),
	}
	user2PayloadBytes, err := protoutil.Marshal(&user2Payload)
	rootDB.Exec(t,
		"INSERT INTO system.jobs (id, status, created, payload) values ($1, $2, $3, $4)",
		2, jobs.StatusRunning, timeutil.Now(), user2PayloadBytes,
	)
	assert.NoError(t, err)

	// user1 can see all jobs because they have the CONTROLJOB role option.
	asUser("user1", func(userDB *sqlutils.SQLRunner) {
		userDB.CheckQueryResults(t, "SELECT count(*) FROM crdb_internal.system_jobs() WHERE id IN (1,2)", [][]string{{"2"}})
	})

	// user2 can only see their own job
	asUser("user2", func(userDB *sqlutils.SQLRunner) {
		userDB.CheckQueryResults(t, "SELECT id FROM crdb_internal.system_jobs() WHERE id IN (1,2)", [][]string{{"2"}})
	})

	// Admins can see all jobs.
	rootDB.CheckQueryResults(t, "SELECT count(*) FROM crdb_internal.system_jobs() WHERE id IN (1,2)", [][]string{{"2"}})
}
