// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/distsqlpb/processors_table_stats.proto

package distsqlpb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_cockroachdb_cockroach_pkg_sql_sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SketchType int32

const (
	// This is the github.com/axiomhq/hyperloglog binary format (as of commit
	// 730eea1) for a sketch with precision 14. Values are encoded using their key
	// encoding, except integers which are encoded in 8 bytes (little-endian).
	SketchType_HLL_PLUS_PLUS_V1 SketchType = 0
)

var SketchType_name = map[int32]string{
	0: "HLL_PLUS_PLUS_V1",
}
var SketchType_value = map[string]int32{
	"HLL_PLUS_PLUS_V1": 0,
}

func (x SketchType) Enum() *SketchType {
	p := new(SketchType)
	*p = x
	return p
}
func (x SketchType) String() string {
	return proto.EnumName(SketchType_name, int32(x))
}
func (x *SketchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SketchType_value, data, "SketchType")
	if err != nil {
		return err
	}
	*x = SketchType(value)
	return nil
}
func (SketchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_table_stats_4211d5915a2d9dbf, []int{0}
}

// SketchSpec contains the specification for a generated statistic.
type SketchSpec struct {
	SketchType SketchType `protobuf:"varint,1,opt,name=sketch_type,json=sketchType,enum=cockroach.sql.distsqlrun.SketchType" json:"sketch_type"`
	// Each value is an index identifying a column in the input stream.
	// TODO(radu): currently only one column is supported.
	Columns []uint32 `protobuf:"varint,2,rep,name=columns" json:"columns,omitempty"`
	// If set, we generate a histogram for the first column in the sketch.
	// Only used by the SampleAggregator.
	GenerateHistogram bool `protobuf:"varint,3,opt,name=generate_histogram,json=generateHistogram" json:"generate_histogram"`
	// Controls the maximum number of buckets in the histogram.
	// Only used by the SampleAggregator.
	HistogramMaxBuckets uint32 `protobuf:"varint,4,opt,name=histogram_max_buckets,json=histogramMaxBuckets" json:"histogram_max_buckets"`
	// Only used by the SampleAggregator.
	StatName             string   `protobuf:"bytes,5,opt,name=stat_name,json=statName" json:"stat_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
}

func (m *SketchSpec) Reset()         { *m = SketchSpec{} }
func (m *SketchSpec) String() string { return proto.CompactTextString(m) }
func (*SketchSpec) ProtoMessage()    {}
func (*SketchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_table_stats_4211d5915a2d9dbf, []int{0}
}
func (m *SketchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SketchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SketchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SketchSpec.Merge(dst, src)
}
func (m *SketchSpec) XXX_Size() int {
	return m.Size()
}
func (m *SketchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SketchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SketchSpec proto.InternalMessageInfo

// SamplerSpec is the specification of a "sampler" processor which
// returns a sample (random subset) of the input columns and computes
// cardinality estimation sketches on sets of columns.
//
// The sampler is configured with a sample size and sets of columns
// for the sketches. It produces one row with global statistics, one
// row with sketch information for each sketch plus at most
// sample_size sampled rows.
//
// The following method is used to do reservoir sampling: we generate a
// "rank" for each row, which is just a random, uniformly distributed
// 64-bit value. The rows with the smallest <sample_size> ranks are selected.
// This method is chosen because it allows to combine sample sets very easily.
//
// The internal schema of the processor is formed of two column
// groups:
//   1. sampled row columns:
//       - columns that map 1-1 to the columns in the input (same
//         schema as the input).
//       - an INT column with the "rank" of the row; this is a random value
//         associated with the row (necessary for combining sample sets).
//   2. sketch columns:
//       - an INT column indicating the sketch index
//         (0 to len(sketches) - 1).
//       - an INT column indicating the number of rows processed
//       - an INT column indicating the number of NULL values
//         on the first column of the sketch.
//       - a BYTES column with the binary sketch data (format
//         dependent on the sketch type).
// Rows have NULLs on either all the sampled row columns or on all the
// sketch columns.
type SamplerSpec struct {
	Sketches   []SketchSpec `protobuf:"bytes,1,rep,name=sketches" json:"sketches"`
	SampleSize uint32       `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// Setting this value enables throttling; this is the fraction of time that
	// the sampler processors will be idle when the recent CPU usage is high. The
	// throttling is adaptive so the actual idle fraction will depend on CPU
	// usage; this value is a ceiling.
	//
	// Currently, this field is set only for automatic statistics based on the
	// value of the cluster setting
	// sql.stats.automatic_collection.max_fraction_idle.
	MaxFractionIdle      float64  `protobuf:"fixed64,3,opt,name=max_fraction_idle,json=maxFractionIdle" json:"max_fraction_idle"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
}

func (m *SamplerSpec) Reset()         { *m = SamplerSpec{} }
func (m *SamplerSpec) String() string { return proto.CompactTextString(m) }
func (*SamplerSpec) ProtoMessage()    {}
func (*SamplerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_table_stats_4211d5915a2d9dbf, []int{1}
}
func (m *SamplerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SamplerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SamplerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SamplerSpec.Merge(dst, src)
}
func (m *SamplerSpec) XXX_Size() int {
	return m.Size()
}
func (m *SamplerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SamplerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SamplerSpec proto.InternalMessageInfo

// SampleAggregatorSpec is the specification of a processor that aggregates the
// results from multiple sampler processors and writes out the statistics to
// system.table_statistics.
//
// The input schema it expects matches the output schema of a sampler spec (see
// the comment for SamplerSpec for all the details):
//  1. sampled row columns:
//    - sampled columns
//    - row rank
//  2. sketch columns:
//    - sketch index
//    - number of rows processed
//    - number of NULL values encountered on the first column of the sketch
//    - binary sketch data
type SampleAggregatorSpec struct {
	Sketches []SketchSpec `protobuf:"bytes,1,rep,name=sketches" json:"sketches"`
	// The processor merges reservoir sample sets into a single
	// sample set of this size. This must match the sample size
	// used for each Sampler.
	SampleSize uint32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// The i-th value indicates the ColumnID of the i-th sampled row column.
	// These are necessary for writing out the statistic data.
	SampledColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID `protobuf:"varint,3,rep,name=sampled_column_ids,json=sampledColumnIds,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ColumnID" json:"sampled_column_ids,omitempty"`
	TableID          github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID         `protobuf:"varint,4,opt,name=table_id,json=tableId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"table_id"`
	// JobID is the id of the CREATE STATISTICS job.
	JobID int64 `protobuf:"varint,6,opt,name=job_id,json=jobId" json:"job_id"`
	// The total number of rows expected in the table based on previous runs of
	// CREATE STATISTICS. Used for progress reporting. If rows expected is 0,
	// reported progress is 0 until the very end.
	RowsExpected         uint64   `protobuf:"varint,7,opt,name=rows_expected,json=rowsExpected" json:"rows_expected"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
}

func (m *SampleAggregatorSpec) Reset()         { *m = SampleAggregatorSpec{} }
func (m *SampleAggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*SampleAggregatorSpec) ProtoMessage()    {}
func (*SampleAggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_table_stats_4211d5915a2d9dbf, []int{2}
}
func (m *SampleAggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleAggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SampleAggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleAggregatorSpec.Merge(dst, src)
}
func (m *SampleAggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *SampleAggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleAggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SampleAggregatorSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SketchSpec)(nil), "cockroach.sql.distsqlrun.SketchSpec")
	proto.RegisterType((*SamplerSpec)(nil), "cockroach.sql.distsqlrun.SamplerSpec")
	proto.RegisterType((*SampleAggregatorSpec)(nil), "cockroach.sql.distsqlrun.SampleAggregatorSpec")
	proto.RegisterEnum("cockroach.sql.distsqlrun.SketchType", SketchType_name, SketchType_value)
}
func (m *SketchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SketchSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SketchType))
	if len(m.Columns) > 0 {
		for _, num := range m.Columns {
			dAtA[i] = 0x10
			i++
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x18
	i++
	if m.GenerateHistogram {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.HistogramMaxBuckets))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(len(m.StatName)))
	i += copy(dAtA[i:], m.StatName)
	return i, nil
}

func (m *SamplerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SamplerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, msg := range m.Sketches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SampleSize))
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFractionIdle))))
	i += 8
	return i, nil
}

func (m *SampleAggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleAggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, msg := range m.Sketches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SampleSize))
	if len(m.SampledColumnIDs) > 0 {
		for _, num := range m.SampledColumnIDs {
			dAtA[i] = 0x18
			i++
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.TableID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.JobID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.RowsExpected))
	return i, nil
}

func encodeVarintProcessorsTableStats(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SketchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsTableStats(uint64(m.SketchType))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			n += 1 + sovProcessorsTableStats(uint64(e))
		}
	}
	n += 2
	n += 1 + sovProcessorsTableStats(uint64(m.HistogramMaxBuckets))
	l = len(m.StatName)
	n += 1 + l + sovProcessorsTableStats(uint64(l))
	return n
}

func (m *SamplerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, e := range m.Sketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.SampleSize))
	n += 9
	return n
}

func (m *SampleAggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, e := range m.Sketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.SampleSize))
	if len(m.SampledColumnIDs) > 0 {
		for _, e := range m.SampledColumnIDs {
			n += 1 + sovProcessorsTableStats(uint64(e))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.TableID))
	n += 1 + sovProcessorsTableStats(uint64(m.JobID))
	n += 1 + sovProcessorsTableStats(uint64(m.RowsExpected))
	return n
}

func sovProcessorsTableStats(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessorsTableStats(x uint64) (n int) {
	return sovProcessorsTableStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SketchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SketchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SketchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SketchType", wireType)
			}
			m.SketchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SketchType |= (SketchType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsTableStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenerateHistogram = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramMaxBuckets", wireType)
			}
			m.HistogramMaxBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistogramMaxBuckets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SamplerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sketches = append(m.Sketches, SketchSpec{})
			if err := m.Sketches[len(m.Sketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFractionIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFractionIdle = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleAggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleAggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleAggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sketches = append(m.Sketches, SketchSpec{})
			if err := m.Sketches[len(m.Sketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SampledColumnIDs = append(m.SampledColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SampledColumnIDs) == 0 {
					m.SampledColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsTableStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SampledColumnIDs = append(m.SampledColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SampledColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsExpected", wireType)
			}
			m.RowsExpected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsExpected |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsTableStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsTableStats
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessorsTableStats(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessorsTableStats = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsTableStats   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/distsqlpb/processors_table_stats.proto", fileDescriptor_processors_table_stats_4211d5915a2d9dbf)
}

var fileDescriptor_processors_table_stats_4211d5915a2d9dbf = []byte{
	// 610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0x3f, 0x73, 0xd3, 0x3e,
	0x18, 0x8e, 0x9a, 0xa4, 0x49, 0x95, 0x5f, 0x7e, 0xa4, 0xa2, 0xdc, 0xf9, 0x7a, 0x9c, 0x63, 0x72,
	0xe5, 0x30, 0x1d, 0x6c, 0xa0, 0x0b, 0x8c, 0x84, 0xd0, 0xab, 0x4b, 0xe1, 0x20, 0x29, 0x0c, 0x2c,
	0x3a, 0xd9, 0x12, 0x8e, 0x1b, 0x3b, 0x72, 0x24, 0xe5, 0x48, 0xbb, 0x30, 0xb1, 0xf3, 0x49, 0xf8,
	0x0c, 0x8c, 0x19, 0x3b, 0x32, 0xe5, 0x20, 0xfd, 0x16, 0x9d, 0x38, 0xff, 0x89, 0x29, 0x03, 0xc7,
	0x31, 0xb1, 0xf8, 0xa4, 0xf7, 0x79, 0x9f, 0xe7, 0x7d, 0xf4, 0x4a, 0xaf, 0xe1, 0xae, 0x9c, 0x84,
	0x36, 0x0d, 0xa4, 0x92, 0x93, 0x30, 0x76, 0xed, 0x58, 0x70, 0x8f, 0x49, 0xc9, 0x85, 0xc4, 0x8a,
	0xb8, 0x21, 0xc3, 0x52, 0x11, 0x25, 0xad, 0x58, 0x70, 0xc5, 0x91, 0xe6, 0x71, 0x6f, 0x24, 0x38,
	0xf1, 0x86, 0x96, 0x9c, 0x84, 0x56, 0xce, 0x12, 0xd3, 0xf1, 0xf6, 0xcd, 0x44, 0x45, 0x4e, 0x42,
	0x97, 0x48, 0x66, 0x4b, 0x25, 0xa6, 0x9e, 0x9a, 0x0a, 0x46, 0x33, 0xde, 0xf6, 0x96, 0xcf, 0x7d,
	0x9e, 0x2e, 0xed, 0x64, 0x95, 0x45, 0x3b, 0x1f, 0xd7, 0x20, 0x1c, 0x8c, 0x98, 0xf2, 0x86, 0x83,
	0x98, 0x79, 0xe8, 0x19, 0x6c, 0xc8, 0x74, 0x87, 0xd5, 0x69, 0xcc, 0x34, 0x60, 0x00, 0xf3, 0xff,
	0x07, 0x3b, 0xd6, 0xef, 0x4a, 0x5a, 0x19, 0xf5, 0xf8, 0x34, 0x66, 0xdd, 0xca, 0x7c, 0xd1, 0x2e,
	0xf5, 0xa1, 0x2c, 0x22, 0x48, 0x83, 0x35, 0x8f, 0x87, 0xd3, 0x68, 0x2c, 0xb5, 0x35, 0xa3, 0x6c,
	0x36, 0xfb, 0xab, 0x2d, 0xda, 0x83, 0xc8, 0x67, 0x63, 0x26, 0x88, 0x62, 0x78, 0x18, 0x48, 0xc5,
	0x7d, 0x41, 0x22, 0xad, 0x6c, 0x00, 0xb3, 0x9e, 0xeb, 0x6c, 0xae, 0xf0, 0x83, 0x15, 0x8c, 0x1e,
	0xc2, 0x1b, 0x45, 0x2e, 0x8e, 0xc8, 0x0c, 0xbb, 0x53, 0x6f, 0xc4, 0x94, 0xd4, 0x2a, 0x06, 0x30,
	0x9b, 0x39, 0xef, 0x7a, 0x91, 0xf2, 0x9c, 0xcc, 0xba, 0x59, 0x02, 0xba, 0x05, 0x37, 0x92, 0x0e,
	0xe2, 0x31, 0x89, 0x98, 0x56, 0x35, 0x80, 0xb9, 0x91, 0x67, 0xd7, 0x93, 0xf0, 0x0b, 0x12, 0xb1,
	0xce, 0x67, 0x00, 0x1b, 0x03, 0x12, 0xc5, 0x21, 0x13, 0x69, 0x23, 0xf6, 0x61, 0x3d, 0x3b, 0x09,
	0x93, 0x1a, 0x30, 0xca, 0x66, 0xe3, 0xcf, 0x5d, 0x48, 0x78, 0x85, 0x6e, 0xce, 0x45, 0xb7, 0x61,
	0x43, 0xa6, 0xb2, 0x58, 0x06, 0x67, 0x4c, 0x5b, 0xbb, 0x62, 0x15, 0x66, 0xc0, 0x20, 0x38, 0x63,
	0xe8, 0x1e, 0xdc, 0x4c, 0x4e, 0xf4, 0x4e, 0x10, 0x4f, 0x05, 0x7c, 0x8c, 0x03, 0x1a, 0xb2, 0xb4,
	0x1f, 0x20, 0x4f, 0xbe, 0x16, 0x91, 0xd9, 0x7e, 0x8e, 0x3a, 0x34, 0x64, 0x9d, 0x2f, 0x65, 0xb8,
	0x95, 0x19, 0x7e, 0xec, 0xfb, 0x82, 0xf9, 0x44, 0xf1, 0x7f, 0xe2, 0xfc, 0x03, 0x44, 0xd9, 0x8e,
	0xe2, 0xec, 0x76, 0x71, 0x40, 0xa5, 0x56, 0x4e, 0xee, 0xbb, 0xfb, 0x6a, 0xb9, 0x68, 0xb7, 0x32,
	0x93, 0xf4, 0x49, 0x0a, 0x3a, 0x3d, 0x79, 0xb9, 0x68, 0x3f, 0xf2, 0x03, 0x35, 0x9c, 0xba, 0x96,
	0xc7, 0x23, 0xbb, 0xb0, 0x46, 0xdd, 0x9f, 0x6b, 0x3b, 0x1e, 0xf9, 0xf6, 0x95, 0xd7, 0x6c, 0xad,
	0xd8, 0xfd, 0x96, 0xfc, 0x45, 0x8e, 0x4a, 0x44, 0x60, 0x3d, 0x1b, 0x92, 0x80, 0xe6, 0x2f, 0x61,
	0x3f, 0x31, 0xb9, 0x5c, 0xb4, 0x6b, 0xc7, 0x49, 0xdc, 0xe9, 0x5d, 0x2e, 0xda, 0x7b, 0x7f, 0x5d,
	0xd1, 0xe9, 0xf5, 0x6b, 0xa9, 0xae, 0x43, 0xd1, 0x0e, 0x5c, 0x3f, 0xe1, 0x6e, 0x52, 0x60, 0xdd,
	0x00, 0x66, 0xb9, 0xdb, 0xcc, 0x0b, 0x54, 0x0f, 0xb9, 0xeb, 0xf4, 0xfa, 0xd5, 0x13, 0xee, 0x3a,
	0x14, 0xdd, 0x85, 0x4d, 0xc1, 0xdf, 0x4b, 0xcc, 0x66, 0x31, 0xf3, 0x14, 0xa3, 0x5a, 0xcd, 0x00,
	0x66, 0x25, 0x6f, 0xd9, 0x7f, 0x09, 0xf4, 0x34, 0x47, 0x0e, 0x2b, 0xf5, 0x6a, 0x6b, 0x7d, 0xb7,
	0xb3, 0x1a, 0xbd, 0x74, 0x5a, 0xb6, 0x60, 0xeb, 0xe0, 0xe8, 0x08, 0xbf, 0x3c, 0x7a, 0x3d, 0xc8,
	0x3e, 0x6f, 0xee, 0xb7, 0x4a, 0xdd, 0x3b, 0xf3, 0xef, 0x7a, 0x69, 0xbe, 0xd4, 0xc1, 0xf9, 0x52,
	0x07, 0x5f, 0x97, 0x3a, 0xf8, 0xb6, 0xd4, 0xc1, 0xa7, 0x0b, 0xbd, 0x74, 0x7e, 0xa1, 0x97, 0xde,
	0x6e, 0x14, 0xff, 0x8c, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x6c, 0x9f, 0xa6, 0x68, 0x43, 0x04,
	0x00, 0x00,
}
