// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/distsqlpb/processors_bulk_io.proto

package distsqlpb

/*
	Beware! This package name must not be changed, even though it doesn't match
	the Go package name, because it defines the Protobuf message names which
	can't be changed without breaking backward compatibility.
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import time "time"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type BackfillerSpec_Type int32

const (
	BackfillerSpec_Invalid BackfillerSpec_Type = 0
	BackfillerSpec_Column  BackfillerSpec_Type = 1
	BackfillerSpec_Index   BackfillerSpec_Type = 2
)

var BackfillerSpec_Type_name = map[int32]string{
	0: "Invalid",
	1: "Column",
	2: "Index",
}
var BackfillerSpec_Type_value = map[string]int32{
	"Invalid": 0,
	"Column":  1,
	"Index":   2,
}

func (x BackfillerSpec_Type) Enum() *BackfillerSpec_Type {
	p := new(BackfillerSpec_Type)
	*p = x
	return p
}
func (x BackfillerSpec_Type) String() string {
	return proto.EnumName(BackfillerSpec_Type_name, int32(x))
}
func (x *BackfillerSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BackfillerSpec_Type_value, data, "BackfillerSpec_Type")
	if err != nil {
		return err
	}
	*x = BackfillerSpec_Type(value)
	return nil
}
func (BackfillerSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{0, 0}
}

// BackfillerSpec is the specification for a "schema change backfiller".
// The created backfill processor runs a backfill for the first mutations in
// the table descriptor mutation list with the same mutation id and type.
// A backfiller processor performs KV operations to retrieve rows for a
// table and backfills the new indexes/columns contained in the table
// descriptor. It checkpoints its progress by updating the table
// descriptor in the database, and doesn't emit any rows nor support
// any post-processing.
type BackfillerSpec struct {
	Type  BackfillerSpec_Type     `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.BackfillerSpec_Type" json:"type"`
	Table sqlbase.TableDescriptor `protobuf:"bytes,2,opt,name=table" json:"table"`
	// Sections of the table to be backfilled.
	Spans []TableReaderSpan `protobuf:"bytes,3,rep,name=spans" json:"spans"`
	// Run the backfill for approximately this duration.
	// The backfill will always process at least one backfill chunk.
	Duration time.Duration `protobuf:"varint,4,opt,name=duration,casttype=time.Duration" json:"duration"`
	// The backfill involves a complete table scan in chunks,
	// where each chunk is a transactional read of a set of rows
	// along with a backfill for the rows. This is the maximum number
	// of entries backfilled per chunk.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// Any other (leased) table descriptors necessary for the
	// backfiller to do its job, such as the descriptors for tables with fk
	// relationships to the table being modified.
	OtherTables []sqlbase.TableDescriptor `protobuf:"bytes,6,rep,name=other_tables,json=otherTables" json:"other_tables"`
	// The timestamp to perform index backfill historical scans at.
	ReadAsOf hlc.Timestamp `protobuf:"bytes,7,opt,name=readAsOf" json:"readAsOf"`
}

func (m *BackfillerSpec) Reset()         { *m = BackfillerSpec{} }
func (m *BackfillerSpec) String() string { return proto.CompactTextString(m) }
func (*BackfillerSpec) ProtoMessage()    {}
func (*BackfillerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{0}
}
func (m *BackfillerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackfillerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillerSpec.Merge(dst, src)
}
func (m *BackfillerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackfillerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillerSpec proto.InternalMessageInfo

// JobProgress identifies the job to report progress on. This reporting
// happens outside this package.
type JobProgress struct {
	JobID int64 `protobuf:"varint,1,opt,name=job_id,json=jobId" json:"job_id"`
	// contribution is the percent of work of the total this processor will
	// process.
	Contribution float32 `protobuf:"fixed32,2,opt,name=contribution" json:"contribution"`
	// slot is the index into the job details for this processor's completion.
	Slot int32 `protobuf:"varint,3,opt,name=slot" json:"slot"`
}

func (m *JobProgress) Reset()         { *m = JobProgress{} }
func (m *JobProgress) String() string { return proto.CompactTextString(m) }
func (*JobProgress) ProtoMessage()    {}
func (*JobProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{1}
}
func (m *JobProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobProgress.Merge(dst, src)
}
func (m *JobProgress) XXX_Size() int {
	return m.Size()
}
func (m *JobProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_JobProgress.DiscardUnknown(m)
}

var xxx_messageInfo_JobProgress proto.InternalMessageInfo

type ReadImportDataSpec struct {
	Format roachpb.IOFileFormat `protobuf:"bytes,8,opt,name=format" json:"format"`
	// sample_size is the rate at which to output rows, based on an input row's size.
	SampleSize int32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// tables supports input formats that can read multiple tables. If it is
	// non-empty, the keys specify the names of tables for which the processor
	// should read and emit data (ignoring data for any other tables that is
	// present in the input).
	//
	// TODO(dt): If a key has a nil value, the schema for that table should be
	// determined from the input on-the-fly (e.g. by parsing a CREATE TABLE in a
	// dump file) and the processor should emit a key/value for the generated
	// TableDescriptor with the corresponding descriptor ID key. If tables is
	// empty (and table_desc above is not specified), the processor should read
	// all tables in the input, determining their schemas on the fly.
	Tables map[string]*ReadImportDataSpec_ImportTable `protobuf:"bytes,9,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// uri is a storageccl.ExportStorage URI pointing to the CSV files to be
	// read. The map key must be unique across the entire IMPORT job.
	Uri                    map[int32]string `protobuf:"bytes,7,rep,name=uri" json:"uri,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Progress               JobProgress      `protobuf:"bytes,6,opt,name=progress" json:"progress"`
	SkipMissingForeignKeys bool             `protobuf:"varint,10,opt,name=skip_missing_foreign_keys,json=skipMissingForeignKeys" json:"skip_missing_foreign_keys"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,11,opt,name=walltimeNanos" json:"walltimeNanos"`
	// ingestDirectly specifies that this reader should bulk-ingest the kvs it
	// reads rather than emitting them to its output (and instead should emit a
	// single row containing an encoded BulkOpSummary).
	IngestDirectly bool `protobuf:"varint,12,opt,name=ingestDirectly" json:"ingestDirectly"`
}

func (m *ReadImportDataSpec) Reset()         { *m = ReadImportDataSpec{} }
func (m *ReadImportDataSpec) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec) ProtoMessage()    {}
func (*ReadImportDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{2}
}
func (m *ReadImportDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ReadImportDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec.Merge(dst, src)
}
func (m *ReadImportDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec proto.InternalMessageInfo

type ReadImportDataSpec_ImportTable struct {
	Desc *sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// targetCols is used to store the target columns for each existing table
	// being imported into. These are the columns for which the processor should
	// read and emit data (ignoring data for any other tables or columns outside
	// of the targetCols, that is present in the input).
	TargetCols []string `protobuf:"bytes,2,rep,name=targetCols" json:"targetCols,omitempty"`
}

func (m *ReadImportDataSpec_ImportTable) Reset()         { *m = ReadImportDataSpec_ImportTable{} }
func (m *ReadImportDataSpec_ImportTable) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec_ImportTable) ProtoMessage()    {}
func (*ReadImportDataSpec_ImportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{2, 0}
}
func (m *ReadImportDataSpec_ImportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ReadImportDataSpec_ImportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.Merge(dst, src)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec_ImportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec_ImportTable proto.InternalMessageInfo

// SSTWriterSpec is the specification for a processor that consumes rows, uses
// tempStorage to sort them, then writes them to SST files at uri. walltime is
// used as the MVCC timestamp. It outputs one row per span containing the file
// name, size, checksum, observed start and end keys. See ccs/sqlccl/csv.go
// for implementation.
type SSTWriterSpec struct {
	// destination as a storageccl.ExportStorage URI pointing to an export store
	// location (directory).
	Destination string `protobuf:"bytes,1,opt,name=destination" json:"destination"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,3,opt,name=walltimeNanos" json:"walltimeNanos"`
	// spans is an array of span boundaries and corresponding filenames.
	Spans    []SSTWriterSpec_SpanName `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	Progress JobProgress              `protobuf:"bytes,5,opt,name=progress" json:"progress"`
}

func (m *SSTWriterSpec) Reset()         { *m = SSTWriterSpec{} }
func (m *SSTWriterSpec) String() string { return proto.CompactTextString(m) }
func (*SSTWriterSpec) ProtoMessage()    {}
func (*SSTWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{3}
}
func (m *SSTWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSTWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SSTWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSTWriterSpec.Merge(dst, src)
}
func (m *SSTWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SSTWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SSTWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SSTWriterSpec proto.InternalMessageInfo

type SSTWriterSpec_SpanName struct {
	// name is the file name that will be written by the export store.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// end is the end key of a span.
	End []byte `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *SSTWriterSpec_SpanName) Reset()         { *m = SSTWriterSpec_SpanName{} }
func (m *SSTWriterSpec_SpanName) String() string { return proto.CompactTextString(m) }
func (*SSTWriterSpec_SpanName) ProtoMessage()    {}
func (*SSTWriterSpec_SpanName) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{3, 0}
}
func (m *SSTWriterSpec_SpanName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSTWriterSpec_SpanName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SSTWriterSpec_SpanName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSTWriterSpec_SpanName.Merge(dst, src)
}
func (m *SSTWriterSpec_SpanName) XXX_Size() int {
	return m.Size()
}
func (m *SSTWriterSpec_SpanName) XXX_DiscardUnknown() {
	xxx_messageInfo_SSTWriterSpec_SpanName.DiscardUnknown(m)
}

var xxx_messageInfo_SSTWriterSpec_SpanName proto.InternalMessageInfo

// CSVWriterSpec is the specification for a processor that consumes rows and
// writes them to CSV files at uri. It outputs a row per file written with
// the file name, row count and byte size.
type CSVWriterSpec struct {
	// destination as a storageccl.ExportStorage URI pointing to an export store
	// location (directory).
	Destination string             `protobuf:"bytes,1,opt,name=destination" json:"destination"`
	NamePattern string             `protobuf:"bytes,2,opt,name=name_pattern,json=namePattern" json:"name_pattern"`
	Options     roachpb.CSVOptions `protobuf:"bytes,3,opt,name=options" json:"options"`
	// chunk_rows is num rows to write per file. 0 = no limit.
	ChunkRows int64 `protobuf:"varint,4,opt,name=chunk_rows,json=chunkRows" json:"chunk_rows"`
}

func (m *CSVWriterSpec) Reset()         { *m = CSVWriterSpec{} }
func (m *CSVWriterSpec) String() string { return proto.CompactTextString(m) }
func (*CSVWriterSpec) ProtoMessage()    {}
func (*CSVWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{4}
}
func (m *CSVWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CSVWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CSVWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CSVWriterSpec.Merge(dst, src)
}
func (m *CSVWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *CSVWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CSVWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CSVWriterSpec proto.InternalMessageInfo

// BulkRowWriterSpec is the specification for a processor that consumes rows and
// writes them to a target table using AddSSTable. It outputs a BulkOpSummary.
type BulkRowWriterSpec struct {
	Table sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
}

func (m *BulkRowWriterSpec) Reset()         { *m = BulkRowWriterSpec{} }
func (m *BulkRowWriterSpec) String() string { return proto.CompactTextString(m) }
func (*BulkRowWriterSpec) ProtoMessage()    {}
func (*BulkRowWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_processors_bulk_io_e2ef37cb0efbd656, []int{5}
}
func (m *BulkRowWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkRowWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BulkRowWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkRowWriterSpec.Merge(dst, src)
}
func (m *BulkRowWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *BulkRowWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkRowWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BulkRowWriterSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BackfillerSpec)(nil), "cockroach.sql.distsqlrun.BackfillerSpec")
	proto.RegisterType((*JobProgress)(nil), "cockroach.sql.distsqlrun.JobProgress")
	proto.RegisterType((*ReadImportDataSpec)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec")
	proto.RegisterMapType((map[string]*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.TablesEntry")
	proto.RegisterMapType((map[int32]string)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.UriEntry")
	proto.RegisterType((*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ImportTable")
	proto.RegisterType((*SSTWriterSpec)(nil), "cockroach.sql.distsqlrun.SSTWriterSpec")
	proto.RegisterType((*SSTWriterSpec_SpanName)(nil), "cockroach.sql.distsqlrun.SSTWriterSpec.SpanName")
	proto.RegisterType((*CSVWriterSpec)(nil), "cockroach.sql.distsqlrun.CSVWriterSpec")
	proto.RegisterType((*BulkRowWriterSpec)(nil), "cockroach.sql.distsqlrun.BulkRowWriterSpec")
	proto.RegisterEnum("cockroach.sql.distsqlrun.BackfillerSpec_Type", BackfillerSpec_Type_name, BackfillerSpec_Type_value)
}
func (m *BackfillerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Table.Size()))
	n1, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Duration))
	dAtA[i] = 0x28
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	if len(m.OtherTables) > 0 {
		for _, msg := range m.OtherTables {
			dAtA[i] = 0x32
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReadAsOf.Size()))
	n2, err := m.ReadAsOf.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *JobProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	dAtA[i] = 0x15
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Contribution))))
	i += 4
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Slot))
	return i, nil
}

func (m *ReadImportDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x10
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SampleSize))
	dAtA[i] = 0x32
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Progress.Size()))
	n3, err := m.Progress.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Uri) > 0 {
		keysForUri := make([]int32, 0, len(m.Uri))
		for k := range m.Uri {
			keysForUri = append(keysForUri, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForUri)
		for _, k := range keysForUri {
			dAtA[i] = 0x3a
			i++
			v := m.Uri[int32(k)]
			mapSize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Format.Size()))
	n4, err := m.Format.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Tables) > 0 {
		keysForTables := make([]string, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTables)
		for _, k := range keysForTables {
			dAtA[i] = 0x4a
			i++
			v := m.Tables[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovProcessorsBulkIo(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + msgSize
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	dAtA[i] = 0x50
	i++
	if m.SkipMissingForeignKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	dAtA[i] = 0x60
	i++
	if m.IngestDirectly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ReadImportDataSpec_ImportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec_ImportTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Desc.Size()))
		n6, err := m.Desc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SSTWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSTWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Destination)))
	i += copy(dAtA[i:], m.Destination)
	dAtA[i] = 0x18
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Progress.Size()))
	n7, err := m.Progress.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *SSTWriterSpec_SpanName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSTWriterSpec_SpanName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.End != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *CSVWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSVWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Destination)))
	i += copy(dAtA[i:], m.Destination)
	dAtA[i] = 0x12
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NamePattern)))
	i += copy(dAtA[i:], m.NamePattern)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Options.Size()))
	n8, err := m.Options.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x20
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkRows))
	return i, nil
}

func (m *BulkRowWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkRowWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Table.Size()))
	n9, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func encodeVarintProcessorsBulkIo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BackfillerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.Type))
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.Duration))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	if len(m.OtherTables) > 0 {
		for _, e := range m.OtherTables {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = m.ReadAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *JobProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 5
	n += 1 + sovProcessorsBulkIo(uint64(m.Slot))
	return n
}

func (m *ReadImportDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.SampleSize))
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Uri) > 0 {
		for k, v := range m.Uri {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProcessorsBulkIo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	n += 2
	return n
}

func (m *ReadImportDataSpec_ImportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *SSTWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *SSTWriterSpec_SpanName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if m.End != nil {
		l = len(m.End)
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	return n
}

func (m *CSVWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.NamePattern)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Options.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkRows))
	return n
}

func (m *BulkRowWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func sovProcessorsBulkIo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProcessorsBulkIo(x uint64) (n int) {
	return sovProcessorsBulkIo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackfillerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (BackfillerSpec_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (time.Duration(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherTables = append(m.OtherTables, sqlbase.TableDescriptor{})
			if err := m.OtherTables[len(m.OtherTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Contribution = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadImportDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadImportDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uri[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*ReadImportDataSpec_ImportTable)
			}
			var mapkey string
			var mapvalue *ReadImportDataSpec_ImportTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReadImportDataSpec_ImportTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMissingForeignKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMissingForeignKeys = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestDirectly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec_ImportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &sqlbase.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSTWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSTWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSTWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, SSTWriterSpec_SpanName{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSTWriterSpec_SpanName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSVWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSVWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSVWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkRows", wireType)
			}
			m.ChunkRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkRows |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkRowWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkRowWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkRowWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsBulkIo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsBulkIo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProcessorsBulkIo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProcessorsBulkIo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsBulkIo   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("sql/distsqlpb/processors_bulk_io.proto", fileDescriptor_processors_bulk_io_e2ef37cb0efbd656)
}

var fileDescriptor_processors_bulk_io_e2ef37cb0efbd656 = []byte{
	// 1057 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x16, 0x45, 0x52, 0x96, 0x46, 0x76, 0xa0, 0xdf, 0x22, 0xbf, 0x80, 0x35, 0x5a, 0x59, 0x50,
	0xfe, 0x54, 0x4d, 0x1b, 0xaa, 0x35, 0xd0, 0x22, 0x28, 0x10, 0xa4, 0x95, 0x1d, 0x1b, 0x52, 0x5b,
	0x3b, 0x90, 0x5c, 0x07, 0xe8, 0x45, 0x58, 0x92, 0x6b, 0x79, 0x2d, 0x8a, 0x4b, 0xef, 0x2e, 0xe3,
	0x2a, 0x4f, 0xd1, 0xc7, 0x29, 0xd0, 0x6b, 0x0f, 0x3e, 0xe6, 0x98, 0x93, 0xd1, 0xda, 0x6f, 0x91,
	0x53, 0xb1, 0x4b, 0xd2, 0xa5, 0x12, 0xe8, 0xe0, 0xf4, 0x22, 0x2d, 0x76, 0x66, 0xbe, 0xfd, 0xe6,
	0x9b, 0xd9, 0x59, 0xc2, 0x03, 0x71, 0x1a, 0x76, 0x03, 0x2a, 0xa4, 0x38, 0x0d, 0x63, 0xaf, 0x1b,
	0x73, 0xe6, 0x13, 0x21, 0x18, 0x17, 0x63, 0x2f, 0x09, 0xa7, 0x63, 0xca, 0xdc, 0x98, 0x33, 0xc9,
	0x90, 0xe3, 0x33, 0x7f, 0xca, 0x19, 0xf6, 0x8f, 0x5d, 0x71, 0x1a, 0xba, 0x59, 0x04, 0x4f, 0xa2,
	0xf5, 0x3b, 0x27, 0xcc, 0x13, 0x5d, 0xf5, 0x13, 0x7b, 0xfa, 0x2f, 0x8d, 0x58, 0x77, 0xb4, 0x77,
	0xec, 0x75, 0x29, 0x7b, 0x74, 0xc4, 0xf8, 0x0c, 0xcb, 0xdc, 0xf2, 0xb1, 0x3a, 0x53, 0x9c, 0x86,
	0x1e, 0x16, 0xa4, 0x2b, 0x24, 0x4f, 0x7c, 0x99, 0x70, 0x12, 0x64, 0xd6, 0xbb, 0xcb, 0x19, 0x61,
	0x41, 0x72, 0xf0, 0x44, 0xd2, 0xb0, 0x7b, 0x1c, 0xfa, 0x5d, 0x49, 0x67, 0x44, 0x48, 0x3c, 0x8b,
	0x33, 0xcb, 0xed, 0x09, 0x9b, 0x30, 0xbd, 0xec, 0xaa, 0x55, 0xba, 0xdb, 0x7e, 0x6b, 0xc2, 0xad,
	0x1e, 0xf6, 0xa7, 0x47, 0x34, 0x0c, 0x09, 0x1f, 0xc5, 0xc4, 0x47, 0xbb, 0x60, 0xc9, 0x79, 0x4c,
	0x1c, 0xa3, 0x65, 0x74, 0x6e, 0x6d, 0x3e, 0x72, 0x97, 0x25, 0xe8, 0x2e, 0xc6, 0xb9, 0x07, 0xf3,
	0x98, 0xf4, 0xac, 0xf3, 0x8b, 0x8d, 0xd2, 0x50, 0x03, 0xa0, 0x1e, 0xd8, 0x12, 0x7b, 0x21, 0x71,
	0xca, 0x2d, 0xa3, 0x53, 0xdf, 0x7c, 0xf0, 0x0e, 0x52, 0x96, 0xa8, 0x7b, 0xa0, 0x7c, 0xb6, 0x89,
	0xf0, 0x39, 0x8d, 0x25, 0xe3, 0x19, 0x44, 0x1a, 0x8a, 0x9e, 0x81, 0x2d, 0x62, 0x1c, 0x09, 0xc7,
	0x6c, 0x99, 0x9d, 0xfa, 0xe6, 0x67, 0xcb, 0xd9, 0x68, 0x98, 0x21, 0xc1, 0x81, 0xa2, 0x83, 0xa3,
	0x1c, 0x46, 0x47, 0xa3, 0xaf, 0xa0, 0x1a, 0x24, 0x1c, 0x4b, 0xca, 0x22, 0xc7, 0x6a, 0x19, 0x1d,
	0xb3, 0xf7, 0x7f, 0x65, 0x7e, 0x7b, 0xb1, 0xb1, 0xa6, 0x74, 0x72, 0xb7, 0x33, 0xe3, 0xf0, 0xda,
	0x0d, 0xdd, 0x05, 0xf0, 0x8f, 0x93, 0x68, 0x3a, 0x16, 0xf4, 0x15, 0x71, 0x6c, 0x1d, 0x94, 0x62,
	0xd6, 0xf4, 0xfe, 0x88, 0xbe, 0x22, 0x68, 0x1f, 0x56, 0x99, 0x3c, 0x26, 0x7c, 0xac, 0xd9, 0x0a,
	0xa7, 0xa2, 0x59, 0xde, 0x2c, 0xd3, 0xba, 0x46, 0xd0, 0x36, 0x81, 0x9e, 0x42, 0x95, 0x13, 0x1c,
	0x7c, 0x2f, 0xf6, 0x8f, 0x9c, 0x15, 0x2d, 0xdb, 0x27, 0x05, 0x30, 0x55, 0x5c, 0xf7, 0x38, 0xf4,
	0xdd, 0x83, 0xbc, 0xb8, 0x19, 0xc6, 0x75, 0x50, 0xfb, 0x21, 0x58, 0xaa, 0x10, 0xa8, 0x0e, 0x2b,
	0xfd, 0xe8, 0x25, 0x0e, 0x69, 0xd0, 0x28, 0x21, 0x80, 0xca, 0x16, 0x0b, 0x93, 0x59, 0xd4, 0x30,
	0x50, 0x0d, 0xec, 0x7e, 0x14, 0x90, 0x5f, 0x1b, 0xe5, 0xf6, 0x19, 0xd4, 0x07, 0xcc, 0x7b, 0xce,
	0xd9, 0x84, 0x13, 0x21, 0xd0, 0x3d, 0xa8, 0x9c, 0x30, 0x6f, 0x4c, 0x03, 0x5d, 0x7a, 0xb3, 0xb7,
	0xa6, 0xa0, 0x2f, 0x2f, 0x36, 0xec, 0x01, 0xf3, 0xfa, 0xdb, 0x43, 0xfb, 0x84, 0x79, 0xfd, 0x00,
	0x75, 0x60, 0xd5, 0x67, 0x91, 0xe4, 0xd4, 0x4b, 0xb4, 0x9c, 0xaa, 0xb8, 0xe5, 0x8c, 0xc6, 0x82,
	0x05, 0x39, 0x60, 0x89, 0x90, 0x49, 0xc7, 0x6c, 0x19, 0x1d, 0x3b, 0xef, 0x0c, 0xb5, 0xd3, 0xfe,
	0xa3, 0x02, 0x48, 0x95, 0xaa, 0x3f, 0x8b, 0x19, 0x97, 0xdb, 0x58, 0x62, 0xdd, 0x79, 0xf7, 0xa1,
	0x2e, 0xf0, 0x2c, 0x0e, 0x49, 0xaa, 0x79, 0xb9, 0x10, 0x07, 0xa9, 0x41, 0x8b, 0xbe, 0x0b, 0xd5,
	0x38, 0xe3, 0xec, 0x54, 0xb4, 0x46, 0xf7, 0x97, 0xb7, 0x45, 0x21, 0xc1, 0x5c, 0xab, 0x3c, 0x18,
	0xed, 0x82, 0x99, 0x70, 0xea, 0xac, 0xe8, 0xa2, 0x7d, 0xbd, 0x1c, 0xe3, 0x7d, 0xaa, 0xee, 0xcf,
	0x9c, 0x3e, 0x8b, 0x24, 0x9f, 0x0f, 0x15, 0x02, 0x7a, 0x02, 0x95, 0xf4, 0x26, 0x3b, 0x55, 0xcd,
	0x67, 0xa3, 0x80, 0x95, 0xdd, 0x76, 0xb7, 0xbf, 0xbf, 0x43, 0x43, 0xb2, 0xa3, 0xdd, 0x32, 0x26,
	0x59, 0x10, 0x3a, 0x84, 0x4a, 0xd6, 0x3f, 0x35, 0x4d, 0xe5, 0xf1, 0x8d, 0xa8, 0xa4, 0x9d, 0xa3,
	0xd9, 0x68, 0x5c, 0x63, 0x98, 0xa1, 0xa1, 0xa7, 0xf0, 0x91, 0x98, 0xd2, 0x78, 0x3c, 0xa3, 0x42,
	0xd0, 0x68, 0x32, 0x3e, 0x62, 0x9c, 0xd0, 0x49, 0x34, 0x9e, 0x92, 0xb9, 0x70, 0xa0, 0x65, 0x74,
	0xaa, 0x19, 0x91, 0x3b, 0xca, 0xed, 0xa7, 0xd4, 0x6b, 0x27, 0x75, 0xfa, 0x81, 0xcc, 0x05, 0x7a,
	0x08, 0x6b, 0x67, 0x38, 0x0c, 0xd5, 0x15, 0xd9, 0xc3, 0x11, 0x13, 0x4e, 0xbd, 0x70, 0x0d, 0x16,
	0x4d, 0xe8, 0x0b, 0xb8, 0x45, 0xa3, 0x09, 0x11, 0x72, 0x9b, 0x72, 0xe2, 0xcb, 0x70, 0xee, 0xac,
	0x16, 0x4e, 0x78, 0xc7, 0xb6, 0x9e, 0x40, 0x3d, 0x4d, 0x43, 0xb3, 0x47, 0xdf, 0x81, 0x15, 0x10,
	0xe1, 0xeb, 0xc6, 0xbb, 0xd9, 0xfd, 0x31, 0x86, 0x3a, 0x12, 0xdd, 0x03, 0x90, 0x98, 0x4f, 0x88,
	0xdc, 0x62, 0xa1, 0x70, 0xca, 0x2d, 0xb3, 0x53, 0xcb, 0xec, 0x85, 0xfd, 0x75, 0x01, 0xf5, 0x82,
	0x5c, 0xa8, 0x01, 0xe6, 0x94, 0xcc, 0xf5, 0xa9, 0xb5, 0xa1, 0x5a, 0xa2, 0x3d, 0xb0, 0x5f, 0xe2,
	0x30, 0xc9, 0x67, 0xd6, 0xcd, 0x2a, 0x51, 0xc8, 0x68, 0x98, 0xc2, 0x7c, 0x5b, 0x7e, 0x6c, 0xac,
	0x7f, 0x03, 0xd5, 0xbc, 0x5d, 0x8a, 0x27, 0xda, 0xe9, 0x89, 0xb7, 0x8b, 0x27, 0xd6, 0x0a, 0x71,
	0x03, 0xab, 0x6a, 0x34, 0xca, 0x03, 0xab, 0x6a, 0x36, 0xac, 0x81, 0x55, 0xb5, 0x1a, 0xf6, 0xc0,
	0xaa, 0xda, 0x8d, 0x4a, 0xfb, 0xf7, 0x32, 0xac, 0x8d, 0x46, 0x07, 0x2f, 0x38, 0x95, 0xd9, 0xc8,
	0x7e, 0x00, 0xf5, 0x80, 0x08, 0x49, 0xa3, 0x74, 0xc2, 0xe9, 0x7c, 0xf2, 0xe9, 0x52, 0x30, 0xbc,
	0x5f, 0x4f, 0x73, 0x79, 0x3d, 0x7f, 0xcc, 0x27, 0xaf, 0xa5, 0x7b, 0xf2, 0xcb, 0xe5, 0x4a, 0x2c,
	0x70, 0x71, 0xd5, 0xf0, 0xdd, 0xc3, 0x33, 0xb2, 0x38, 0x80, 0x8b, 0x77, 0xd6, 0xfe, 0x0f, 0x77,
	0x56, 0x89, 0x99, 0x9f, 0xa0, 0x06, 0x4c, 0x84, 0x67, 0x64, 0x21, 0x5f, 0xbd, 0xa3, 0x64, 0x26,
	0x51, 0xa0, 0x25, 0x5d, 0x1d, 0xaa, 0xe5, 0xc0, 0xaa, 0x96, 0x1b, 0x66, 0xfb, 0x4f, 0x03, 0xd6,
	0xb6, 0x46, 0x87, 0x1f, 0x20, 0xdd, 0xa7, 0xb0, 0xaa, 0x90, 0xc7, 0x31, 0x96, 0x92, 0xf0, 0x74,
	0xec, 0x5d, 0x3b, 0x2a, 0xcb, 0xf3, 0xd4, 0x80, 0x9e, 0xc0, 0x0a, 0x8b, 0x55, 0x48, 0xaa, 0xee,
	0xe2, 0x00, 0xcf, 0x87, 0xc1, 0xd6, 0xe8, 0x70, 0x3f, 0x75, 0xca, 0x20, 0xf2, 0x98, 0x7f, 0x9f,
	0x1d, 0xce, 0xce, 0x44, 0xf6, 0x56, 0x15, 0x9f, 0x9d, 0x21, 0x3b, 0x13, 0xed, 0x17, 0xf0, 0xbf,
	0x5e, 0x12, 0xaa, 0x75, 0x21, 0x93, 0xeb, 0xe7, 0xd6, 0xf8, 0xe0, 0xe7, 0xb6, 0xf7, 0xf9, 0xf9,
	0xdf, 0xcd, 0xd2, 0xf9, 0x65, 0xd3, 0x78, 0x7d, 0xd9, 0x34, 0xde, 0x5c, 0x36, 0x8d, 0xbf, 0x2e,
	0x9b, 0xc6, 0x6f, 0x57, 0xcd, 0xd2, 0xeb, 0xab, 0x66, 0xe9, 0xcd, 0x55, 0xb3, 0xf4, 0x4b, 0xed,
	0xfa, 0x0b, 0xe4, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdf, 0x37, 0xea, 0x27, 0x23, 0x09, 0x00,
	0x00,
}
