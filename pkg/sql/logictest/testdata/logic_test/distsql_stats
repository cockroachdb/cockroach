# LogicTest: 5node

# Disable histogram collection.
statement ok
SET CLUSTER SETTING sql.stats.histogram_collection.enabled = false

statement ok
CREATE TABLE data (a INT, b INT, c FLOAT, d DECIMAL, e BOOL, PRIMARY KEY (a, b, c, d), INDEX c_idx (c, d))

let $t_id
SELECT id FROM system.namespace WHERE name='data'

# Split into ten parts.
statement ok
ALTER TABLE data SPLIT AT SELECT i FROM generate_series(1, 9) AS g(i)

# Relocate the ten parts to the five nodes.
statement ok
ALTER TABLE data EXPERIMENTAL_RELOCATE
  SELECT ARRAY[i%5+1], i FROM generate_series(0, 9) AS g(i)

# Generate all combinations of values 1 to 4.
statement ok
INSERT INTO data SELECT a, b, c::FLOAT, d::DECIMAL, (a+b+c+d) % 2 = 0 FROM
   generate_series(1, 4) AS a(a),
   generate_series(1, 4) AS b(b),
   generate_series(1, 4) AS c(c),
   generate_series(1, 4) AS d(d)

# Verify data placement.
query TTTI colnames,rowsort
SELECT start_key, end_key, replicas, lease_holder FROM [SHOW RANGES FROM TABLE data WITH DETAILS]
----
start_key           end_key       replicas  lease_holder
<before:/Table/62>  …/1/1         {1}       1
…/1/1               …/1/2         {2}       2
…/1/2               …/1/3         {3}       3
…/1/3               …/1/4         {4}       4
…/1/4               …/1/5         {5}       5
…/1/5               …/1/6         {1}       1
…/1/6               …/1/7         {2}       2
…/1/7               …/1/8         {3}       3
…/1/8               …/1/9         {4}       4
…/1/9               <after:/Max>  {5}       5

# Turn feature flag off and verify errors.
statement ok
SET CLUSTER SETTING feature.stats.enabled = FALSE

statement error pq: feature ANALYZE/CREATE STATISTICS was disabled by the database administrator
CREATE STATISTICS s1 ON a FROM data

statement error pq: feature ANALYZE/CREATE STATISTICS was disabled by the database administrator
ANALYZE data

statement ok
SET CLUSTER SETTING feature.stats.enabled = TRUE

statement ok
CREATE STATISTICS s1 ON a FROM data

query TTIIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, histogram_id
FROM [SHOW STATISTICS FOR TABLE data]
----
statistics_name  column_names  row_count  distinct_count  null_count  histogram_id
s1               {a}           256        4               0           NULL

statement ok
SET CLUSTER SETTING sql.stats.histogram_collection.enabled = true

statement ok
CREATE STATISTICS s1 ON a FROM data

query TTIIIB colnames
SELECT
	statistics_name,
	column_names,
	row_count,
	distinct_count,
	null_count,
	histogram_id IS NOT NULL AS has_histogram
FROM
	[SHOW STATISTICS FOR TABLE data];
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
s1               {a}           256        4               0           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE data] WHERE statistics_name = 's1'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    64
2            0           0                    64
3            0           0                    64
4            0           0                    64

statement ok
CREATE STATISTICS "" ON b FROM data

query TTIIIB colnames
SELECT
	statistics_name,
	column_names,
	row_count,
	distinct_count,
	null_count,
	histogram_id IS NOT NULL AS has_histogram
FROM
	[SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
NULL             {b}           256        4               0           true
s1               {a}           256        4               0           true

# Verify that we can package statistics into a json object and later restore them.
let $json_stats
SHOW STATISTICS USING JSON FOR TABLE data

# Verify that we can control the number of samples and buckets collected.
statement ok
SET CLUSTER SETTING sql.stats.histogram_buckets.count = 2

statement ok
CREATE STATISTICS s2 ON a FROM data

let $hist_id_2
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE data] WHERE statistics_name = 's2'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_2
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    64
4            128         2                    64

# We can also control this with a table setting.
statement ok
ALTER TABLE data SET (sql_stats_histogram_buckets_count = 3)

statement ok
CREATE STATISTICS s3 ON a FROM data

let $hist_id_3
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE data] WHERE statistics_name = 's3'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_3
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    64
3            64          1                    64
4            0           0                    64

statement ok
ALTER TABLE data RESET (sql_stats_histogram_buckets_count)

# We can verify the number of samples collected based on the number of
# buckets produced.
statement ok
SET CLUSTER SETTING sql.stats.histogram_buckets.count = 20000

statement ok
SET CLUSTER SETTING sql.stats.histogram_samples.count = 20000

statement ok
CREATE TABLE big (i INT PRIMARY KEY);
INSERT INTO big SELECT generate_series(1, 20000)

statement ok
CREATE STATISTICS s20000 FROM big

let $hist_id_20000
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE big] WHERE statistics_name = 's20000'

query I
SELECT count(*) FROM [SHOW HISTOGRAM $hist_id_20000]
----
20000

# We can also control this with a table setting.
statement ok
ALTER TABLE big SET (sql_stats_histogram_samples_count = 500)

statement ok
CREATE STATISTICS s500 FROM big

let $hist_id_500
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE big] WHERE statistics_name = 's500'

# Perform integer division by 10 because there may be 2 extra buckets added
# on either end of the histogram to account for the 20000 distinct values.
query I
SELECT (count(*) // 10) * 10 FROM [SHOW HISTOGRAM $hist_id_500]
----
500

statement ok
RESET CLUSTER SETTING sql.stats.histogram_buckets.count

statement ok
RESET CLUSTER SETTING sql.stats.histogram_samples.count

# ANALYZE is syntactic sugar for CREATE STATISTICS with default columns.
statement ok
ANALYZE data

query TTIIIB colnames
SELECT
	statistics_name,
	column_names,
	row_count,
	distinct_count,
	null_count,
	histogram_id IS NOT NULL AS has_histogram
FROM
	[SHOW STATISTICS FOR TABLE data]
ORDER BY column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
NULL             {a,b,c,d}     256        256             0           false
NULL             {a,b,c}       256        64              0           false
NULL             {a,b}         256        16              0           false
NULL             {a}           256        4               0           true
NULL             {b}           256        4               0           true
NULL             {c,d}         256        16              0           false
NULL             {c}           256        4               0           true
NULL             {d}           256        4               0           true
NULL             {e}           256        2               0           true

statement ok
DELETE FROM system.table_statistics

# Restore the old stats.
statement ok
ALTER TABLE data INJECT STATISTICS '$json_stats'

query TTIIIB colnames
SELECT
	statistics_name,
	column_names,
	row_count,
	distinct_count,
	null_count,
	histogram_id IS NOT NULL AS has_histogram
FROM
	[SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
NULL             {b}           256        4               0           true
s1               {a}           256        4               0           true

# Verify that any other statistics are blown away when we INJECT.
statement ok
CREATE STATISTICS s3 ON c FROM data

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
NULL             {b}           256        4               0
s1               {a}           256        4               0
s3               {c}           256        4               0

statement ok
ALTER TABLE data INJECT STATISTICS '$json_stats'

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
NULL             {b}           256        4               0
s1               {a}           256        4               0

# Ignore stats with non-existent columns.
query T noticetrace
ALTER TABLE data INJECT STATISTICS '[
    {
        "columns": ["z"],
        "created_at": "2018-05-01 1:00:00.00000+00:00",
        "row_count": 10,
        "distinct_count": 2
    },
    {
        "columns": ["a", "z"],
        "created_at": "2018-05-01 1:00:00.00000+00:00",
        "row_count": 10,
        "distinct_count": 2
    },
    {
        "columns": ["a"],
        "created_at": "2018-05-01 1:00:00.00000+00:00",
        "row_count": 10,
        "distinct_count": 2
    }
]'
----
NOTICE: column "z" does not exist
NOTICE: column "z" does not exist

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
NULL             {a}           10         2               0

# Test AS OF SYSTEM TIME

# We're reading from timestamps that precede the GC thresholds, disable strict
# enforcement.
statement ok
SET CLUSTER SETTING kv.gc_ttl.strict_enforcement.enabled = false

statement error pgcode 3D000 database "test" does not exist
CREATE STATISTICS s2 ON a FROM data AS OF SYSTEM TIME '2017'

statement ok
CREATE STATISTICS s2 ON a FROM data AS OF SYSTEM TIME '-1us'

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
s2               {a}           256        4               0

#
# Test default column statistics
#

# Disable multi-column stats to start.
statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = false

statement ok
CREATE STATISTICS s3 FROM data

query TIIIB colnames
SELECT column_names, row_count, distinct_count, null_count, histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE data]
WHERE statistics_name = 's3'
ORDER BY column_names::STRING
----
column_names  row_count  distinct_count  null_count  has_histogram
{a}           256        4               0           true
{b}           256        4               0           true
{c}           256        4               0           true
{d}           256        4               0           true
{e}           256        2               0           true


# Re-enable multi-column stats.
statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = true

# Add indexes, including duplicate index on column c and columns (a, b).
statement ok
CREATE INDEX ON data (c DESC, b ASC); CREATE INDEX ON data (b DESC, a);

statement ok
CREATE STATISTICS s4 FROM data

# Check that stats are only collected once per column.
query TIII colnames
SELECT column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
WHERE statistics_name = 's4'
ORDER BY column_names::STRING
----
column_names  row_count  distinct_count  null_count
{a,b,c,d}     256        256             0
{a,b,c}       256        64              0
{a,b}         256        16              0
{a}           256        4               0
{b,c}         256        16              0
{b}           256        4               0
{c,d}         256        16              0
{c}           256        4               0
{d}           256        4               0
{e}           256        2               0

statement ok
DROP INDEX data@c_idx; DROP INDEX data@data_c_b_idx

statement ok
CREATE STATISTICS s5 FROM [$t_id]

query TIII colnames
SELECT column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
WHERE statistics_name = 's5'
ORDER BY column_names::STRING
----
column_names  row_count  distinct_count  null_count
{a,b,c,d}     256        256             0
{a,b,c}       256        64              0
{a,b}         256        16              0
{a}           256        4               0
{b}           256        4               0
{c}           256        4               0
{d}           256        4               0
{e}           256        2               0

# Table with a hidden primary key and no other indexes.
statement ok
CREATE TABLE simple (x INT, y INT)

statement ok
CREATE STATISTICS default_stat1 FROM simple

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE simple]
ORDER BY column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
default_stat1    {rowid}       0          0               0
default_stat1    {x}           0          0               0
default_stat1    {y}           0          0               0

# Add one null row.
statement ok
INSERT INTO simple VALUES (DEFAULT, DEFAULT)

# Add an index.
statement ok
CREATE UNIQUE INDEX ON simple (y) STORING (x)

statement ok
CREATE STATISTICS default_stat2 FROM simple

# Now stats are collected on the index column y before column x.
query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE simple]
ORDER BY column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
default_stat2    {rowid}       1          1               0
default_stat2    {x}           1          1               1
default_stat2    {y}           1          1               1

# Add a few more rows.
statement ok
INSERT INTO simple VALUES (DEFAULT, DEFAULT);
INSERT INTO simple VALUES (0, DEFAULT);
INSERT INTO simple VALUES (DEFAULT, 0);
INSERT INTO simple VALUES (0, 1);

# Add an index.
statement ok
CREATE INDEX ON simple (x, y)

statement ok
CREATE STATISTICS default_stat3 FROM simple

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE simple]
ORDER BY column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
default_stat3    {rowid}       5          5               0
default_stat3    {x,y}         5          4               2
default_stat3    {x}           5          2               3
default_stat3    {y}           5          3               3

let $hist_id_3
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE simple]
WHERE statistics_name = 'default_stat3' AND column_names = '{y}'

# The counts in each bucket should not include null values.
query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_3
----
upper_bound  range_rows  distinct_range_rows  equal_rows
0            0           0                    1
1            0           0                    1

#
# Test numeric references
#

statement ok
CREATE STATISTICS s6 ON a FROM [$t_id]

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
s4               {b,c}         256        16              0
s4               {c,d}         256        16              0
s5               {a,b,c,d}     256        256             0
s5               {a,b,c}       256        64              0
s5               {a,b}         256        16              0
s5               {b}           256        4               0
s5               {c}           256        4               0
s5               {d}           256        4               0
s5               {e}           256        2               0
s6               {a}           256        4               0

# Combine default columns and numeric reference.
statement ok
CREATE STATISTICS __auto__ FROM [$t_id]

query TIII colnames
SELECT column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE data]
WHERE statistics_name = '__auto__'
ORDER BY column_names::STRING
----
column_names  row_count  distinct_count  null_count
{a,b,c,d}     256        256             0
{a,b,c}       256        64              0
{a,b}         256        16              0
{a}           256        4               0
{b}           256        4               0
{c}           256        4               0
{d}           256        4               0
{e}           256        2               0

#
# Test delete stats
#

statement ok
DROP INDEX data@data_b_a_idx

statement ok
CREATE STATISTICS __auto__ FROM [$t_id];
CREATE STATISTICS __auto__ FROM [$t_id];
CREATE STATISTICS __auto__ FROM [$t_id];
CREATE STATISTICS __auto__ FROM [$t_id];
CREATE STATISTICS __auto__ FROM [$t_id];
CREATE STATISTICS __auto__ FROM [$t_id];

# Only the last 4-5 automatic stats should remain for each column.
query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
s4               {b,c}
s4               {c,d}

statement ok
CREATE STATISTICS s7 ON a FROM [$t_id]

query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
s4               {b,c}
s4               {c,d}
s7               {a}

statement ok
CREATE STATISTICS s8 ON a FROM [$t_id]

# s7 is deleted but the automatic stats remain.
query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
s4               {b,c}
s4               {c,d}
s8               {a}

# Try forecasting stats.
query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data WITH FORECAST]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__auto__         {e}
__forecast__     {a,b,c,d}
__forecast__     {a,b,c}
__forecast__     {a,b}
__forecast__     {a}
__forecast__     {b}
__forecast__     {c}
__forecast__     {d}
__forecast__     {e}
s4               {b,c}
s4               {c,d}
s8               {a}

# Test deletion of old non-default stats.

statement ok
SET CLUSTER SETTING sql.stats.non_default_columns.min_retention_period = '0s'

statement ok
CREATE STATISTICS s9 ON e FROM data;
ALTER TABLE data DROP COLUMN e

# Collecting stats on a specific column should not cause deletion of other stats.
statement ok
CREATE STATISTICS s10 ON a FROM data

query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}
s10              {a}
s4               {b,c}
s4               {c,d}

# Stats for column e still exist. (We cannot use SHOW STATISTICS to see them
# since stats from deleted columns are filtered out.)
query T
SELECT name
FROM system.table_statistics
  WHERE NOT EXISTS (
    SELECT * FROM crdb_internal.table_columns
    WHERE "tableID" = descriptor_id
    AND "columnIDs" @> array[column_id]
    AND descriptor_name = 'data'
  )
  AND EXISTS (
    SELECT * FROM crdb_internal.table_columns
    WHERE "tableID" = descriptor_id
    AND descriptor_name = 'data'
  )
  ORDER BY name
----
__auto__
__auto__
__auto__
__auto__
s9

# Collecting stats on default columns should cause deletion of other stats.
statement ok
ANALYZE data

# Stats for column e no longer exist.
query T
SELECT name
FROM system.table_statistics
  WHERE NOT EXISTS (
    SELECT * FROM crdb_internal.table_columns
    WHERE "tableID" = descriptor_id
    AND "columnIDs" @> array[column_id]
    AND descriptor_name = 'data'
  )
  AND EXISTS (
    SELECT * FROM crdb_internal.table_columns
    WHERE "tableID" = descriptor_id
    AND descriptor_name = 'data'
  )
----

# Stats on {c,b} and {c,d} are also deleted.
query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE data] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
NULL             {a,b,c,d}
NULL             {a,b,c}
NULL             {a,b}
NULL             {a}
NULL             {b}
NULL             {c}
NULL             {d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c,d}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b,c}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a,b}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {a}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {b}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {c}
__auto__         {d}
__auto__         {d}
__auto__         {d}
__auto__         {d}

statement ok
RESET CLUSTER SETTING sql.stats.non_default_columns.min_retention_period

# Regression test for #33195.
statement ok
CREATE TABLE t (x int); INSERT INTO t VALUES (1); ALTER TABLE t DROP COLUMN x

# Ensure that creating stats on a table with no columns does not cause a panic.
statement ok
CREATE STATISTICS s FROM t

# Arrays are supported.
statement ok
CREATE TABLE arr (x INT[])

statement ok
INSERT INTO arr VALUES (ARRAY[1,2]), (ARRAY[1,2]), (ARRAY[3,4]), (NULL)

statement ok
CREATE STATISTICS arr_stats FROM arr

query TTIII colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count
FROM [SHOW STATISTICS FOR TABLE arr] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count
arr_stats        {rowid}       4          4               0
arr_stats        {x}           4          3               1

# Regression test for #46964 (however we have added array histogram
# support since this).
statement ok
CREATE STATISTICS arr_stats_x ON x FROM arr

query TTIIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  distinct_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE arr]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
arr_stats        {rowid}       4          4               0           true
arr_stats_x      {x}           4          3               1           true

# Test that enum columns always have histograms collected for them.
statement ok
CREATE TYPE e AS ENUM ('hello', 'howdy', 'hi');

statement ok
CREATE TABLE et (x e, y e, PRIMARY KEY (x));

statement ok
INSERT INTO et VALUES ('hello', 'hello'), ('howdy', 'howdy'), ('hi', 'hi');

statement ok
CREATE STATISTICS s FROM et

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE et]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {x}           3          0           true
s                {y}           3          0           true

# JSON and other inverted-index columns. See also #35150.
statement ok
CREATE TABLE groups (data JSON); INSERT INTO groups VALUES ('{"data": {"domain": "github.com"}}')

# JSON can be specified.
statement ok
CREATE STATISTICS s ON data FROM groups

query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE groups] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
s                {data}

# JSON is auto-included.
statement ok
CREATE STATISTICS s FROM groups

query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE groups] ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names
s                {data}
s                {rowid}

# See #35764
statement ok
CREATE TABLE users (
  profile_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  last_updated TIMESTAMP DEFAULT now(),
  user_profile JSONB,
  INVERTED INDEX user_details (user_profile)
)

statement ok
INSERT INTO users (user_profile) VALUES
  ('{"first_name": "Lola", "last_name": "Dog", "location": "NYC", "online" : true, "friends" : 547}'),
  ('{"first_name": "Ernie", "status": "Looking for treats", "location" : "Brooklyn"}'),
  ('{"first_name": "Ernie", "status": "Looking for treats", "location" : "Brooklyn"}'),
  (NULL),
  ('{"first_name": "Carl", "last_name": "Kimball", "location": "NYC", "breed": "Boston Terrier"}'
)

# Ensure that trying to create statistics with default columns does not fail
# when there is an inverted index.
statement ok
CREATE STATISTICS s FROM users

query TTIIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  distinct_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE users]
ORDER BY
  statistics_name, column_names
----
statistics_name  column_names    row_count  distinct_count  null_count  has_histogram
s                {last_updated}  5          1               0           true
s                {profile_id}    5          5               0           true
s                {user_profile}  5          4               1           true


# Test that individual columns in primary keys always have histograms collected
# for them, with up to 200 buckets.

statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = false

statement ok
CREATE TABLE prim (a INT, b INT, c INT, PRIMARY KEY (a, b, c));

statement ok
INSERT INTO prim VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);

statement ok
CREATE STATISTICS s FROM prim

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE prim]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a}           3          0           true
s                {b}           3          0           true
s                {c}           3          0           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE prim]
WHERE statistics_name = 's' AND column_names = '{a}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    1
2            0           0                    1
3            0           0                    1

# Test that individual columns in secondary indexes always have histograms
# collected for them, with up to 200 buckets.
statement ok
CREATE TABLE sec (a INT, b INT, c INT, INDEX (a, b, c));

statement ok
INSERT INTO sec VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);

statement ok
CREATE STATISTICS s FROM sec

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE sec]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a}           3          0           true
s                {b}           3          0           true
s                {c}           3          0           true
s                {rowid}       3          0           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE sec]
WHERE statistics_name = 's' AND column_names = '{a}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    1
2            0           0                    1
3            0           0                    1

# Test that columns referenced in partial index predicates always have
# histograms collected for them, with up to 200 buckets.
statement ok
CREATE TABLE partial (
  a INT,
  b INT,
  c INT,
  d INT,
  j JSON,
  INDEX (a) WHERE b > 0 OR c > 0,
  INVERTED INDEX (j) WHERE d = 10
);

statement ok
INSERT INTO partial VALUES (1, 1, 1, 1, '{"a": "b"}'), (2, 2, 2, 10, '{"c": "d"}'), (3, 3, 3, 1, '{"e": "f"}');

statement ok
CREATE STATISTICS s FROM partial

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE partial]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a}           3          0           true
s                {b}           3          0           true
s                {c}           3          0           true
s                {d}           3          0           true
s                {j}           3          0           true
s                {rowid}       3          0           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE partial]
WHERE statistics_name = 's' AND column_names = '{a}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    1
2            0           0                    1
3            0           0                    1

# Test that stats are not collected for virtual columns.
statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = true

statement ok
CREATE TABLE virt (
  a INT,
  b INT,
  v INT AS (a + 10) VIRTUAL,
  INDEX (v),
  INDEX (a, v),
  INDEX (a, v, b),
  INDEX (a) WHERE v > 0
)

statement ok
INSERT INTO virt VALUES (1), (2), (3)

statement ok
CREATE STATISTICS s FROM virt

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE virt]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a,b}         3          0           false
s                {a}           3          0           true
s                {b}           3          3           true
s                {rowid}       3          0           true

# Test that stats are not collect for inaccessible virtual columns that
# represent expression indexes.
statement ok
CREATE TABLE expression (
  a INT,
  b INT,
  j JSON,
  INDEX a_plus_b ((a + b)),
  INDEX a_a_plus_b (a, (a + b)),
  INVERTED INDEX j_a ((j->'a')),
  INVERTED INDEX a_j_a (a, (j->'a'))
);

statement ok
INSERT INTO expression VALUES (1, 1, '{"a": "b"}'), (2, 10, '{"c": "d"}'), (3, 1, '{"e": "f"}');

statement ok
CREATE STATISTICS s FROM expression

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE expression]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a}           3          0           true
s                {b}           3          0           true
s                {j}           3          0           true
s                {rowid}       3          0           true

# Test that non-index columns have histograms collected for them, with
# up to 2 buckets.
statement ok
CREATE TABLE noind (a INT, b INT, c INT);

statement ok
INSERT INTO noind VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);

statement ok
CREATE STATISTICS s FROM noind

query TTIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE noind]
ORDER BY
  column_names::STRING, created
----
statistics_name  column_names  row_count  null_count  has_histogram
s                {a}           3          0           true
s                {b}           3          0           true
s                {c}           3          0           true
s                {rowid}       3          0           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE noind]
WHERE statistics_name = 's' AND column_names = '{a}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
1            0           0                    1
3            1           1                    1

# Verify that having 0, 1, or 2 inverted indexes on geo types works.
statement ok
CREATE TABLE geo_table (
   id INT8 PRIMARY KEY,
   geog GEOGRAPHY(GEOMETRY,4326) NULL,
   geom GEOMETRY(GEOMETRY,3857) NULL
);

statement ok
INSERT INTO geo_table VALUES (1, 'LINESTRING(0 0, 100 100)', ST_GeomFromText('LINESTRING(0 0, 100 100)', 3857));

statement ok
CREATE STATISTICS s FROM geo_table;

query TB colnames
SELECT
  column_names,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE geo_table]
ORDER BY
  column_names::STRING, created
----
column_names  has_histogram
{geog}        false
{geom}        false
{id}          true

statement ok
CREATE INDEX geom_idx_1 ON geo_table USING GIST(geom) WITH (geometry_min_x=0, s2_max_level=15);

statement ok
CREATE INDEX geog_idx_1 ON geo_table USING GIST(geog) WITH (s2_level_mod=3);

statement ok
CREATE STATISTICS s FROM geo_table;

query TB colnames
SELECT
  column_names,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE geo_table]
ORDER BY
  column_names::STRING, created
----
column_names  has_histogram
{geog}        true
{geom}        true
{id}          true

statement ok
CREATE INDEX geom_idx_2 ON geo_table USING GIST(geom) WITH (geometry_min_x=5);

statement ok
CREATE INDEX geog_idx_2 ON geo_table USING GIST(geog);

statement ok
CREATE STATISTICS s FROM geo_table;

query TB colnames
SELECT
  column_names,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE geo_table]
ORDER BY
  column_names::STRING, created
----
column_names  has_histogram
{geog}        true
{geom}        true
{id}          true

# Demonstrate that buckets change when the first chosen index is dropped.
let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE geo_table]
WHERE statistics_name = 's' AND column_names = '{geog}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound                                                                                 range_rows  distinct_range_rows  equal_rows
'\x42fd1000000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1
'\x42fd5000000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1

statement ok
DROP INDEX geo_table@geog_idx_1;

statement ok
CREATE STATISTICS s FROM geo_table;

# Demonstrate that buckets change when the first chosen index is dropped.
let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE geo_table]
WHERE statistics_name = 's' AND column_names = '{geog}'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound                                                                                 range_rows  distinct_range_rows  equal_rows
'\x42fd1000000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1
'\x42fd4500000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1
'\x42fd4700000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1
'\x42fd5ad4000000000000000000000000000000bcc00000000000003ffbecde5da115a83ff661bdc396bcdc'  0           0                    1

# Stats for multi-column inverted indexes.
statement ok
CREATE TABLE multi_col (
  id INT PRIMARY KEY,
  s STRING,
  j JSON,
  INVERTED INDEX (s, j)
);

statement ok
INSERT INTO multi_col VALUES (1, 'foo', '{"a": "b"}');

statement ok
CREATE STATISTICS s FROM multi_col;

query TB colnames
SELECT
  column_names,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE multi_col]
ORDER BY
  column_names::STRING, created
----
column_names  has_histogram
{id}          true
{j}           true
{s,j}         false
{s}           true

statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = true

statement ok
CREATE STATISTICS s FROM multi_col;

# Do not create multi-column stats with an invertable column.
query TB colnames
SELECT
  column_names,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE multi_col]
ORDER BY
  column_names::STRING, created
----
column_names  has_histogram
{id}          true
{j}           true
{s,j}         false
{s}           true

statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = false

# Regression test for #56356. Histograms on all-null columns should not cause
# an error.
statement ok
CREATE TABLE all_null (k INT PRIMARY KEY, c INT);

statement ok
INSERT INTO all_null VALUES (1, NULL);

statement ok
CREATE STATISTICS s FROM all_null

query T
SELECT jsonb_pretty(COALESCE(json_agg(stat), '[]'))
  FROM (
SELECT json_array_elements(statistics) - 'created_at' AS stat
FROM [SHOW STATISTICS USING JSON FOR TABLE all_null]
)
----
[
    {
        "avg_size": 1,
        "columns": [
            "k"
        ],
        "distinct_count": 1,
        "histo_buckets": [
            {
                "distinct_range": 0,
                "num_eq": 1,
                "num_range": 0,
                "upper_bound": "1"
            }
        ],
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "s",
        "null_count": 0,
        "row_count": 1
    },
    {
        "avg_size": 0,
        "columns": [
            "c"
        ],
        "distinct_count": 1,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "s",
        "null_count": 1,
        "row_count": 1
    }
]

statement ok
SELECT * FROM all_null WHERE c IS NOT NULL

# Regression for 58220.
statement ok
CREATE TYPE greeting AS ENUM ('hello', 'howdy', 'hi');

statement ok
CREATE TABLE greeting_stats (x greeting PRIMARY KEY);

statement ok
INSERT INTO greeting_stats VALUES ('hi');

statement ok
CREATE STATISTICS s FROM greeting_stats

query T
SELECT jsonb_pretty(COALESCE(json_agg(stat), '[]'))
  FROM (
SELECT json_array_elements(statistics) - 'created_at' AS stat
FROM [SHOW STATISTICS USING JSON FOR TABLE greeting_stats]
)
----
[
    {
        "avg_size": 4,
        "columns": [
            "x"
        ],
        "distinct_count": 1,
        "histo_buckets": [
            {
                "distinct_range": 0,
                "num_eq": 1,
                "num_range": 0,
                "upper_bound": "hi"
            }
        ],
        "histo_col_type": "test.public.greeting",
        "histo_version": 2,
        "name": "s",
        "null_count": 0,
        "row_count": 1
    }
]

# Check that we can inject the statistics back into the table as well.
let $stats
SHOW STATISTICS USING JSON FOR TABLE greeting_stats

statement ok
ALTER TABLE greeting_stats INJECT STATISTICS '$stats'

# Validate that the schema_change_successful metric
query T
SELECT feature_name FROM crdb_internal.feature_usage
WHERE feature_name in ('job.typedesc_schema_change.successful',
'job.schema_change.successful',
'job.create_stats.successful',
'job.auto_create_stats.successful') AND
usage_count > 0
ORDER BY feature_name DESC
----
job.typedesc_schema_change.successful
job.schema_change.successful
job.create_stats.successful
job.auto_create_stats.successful

# Regression test for #63387. Stats collection should succeed when partial index
# predicates reference inverted-type columns.
statement ok
CREATE TABLE t63387 (
    i INT,
    j JSONB,
    INDEX (i) WHERE j->>'a' = 'b'
);

statement ok
INSERT INTO t63387 VALUES (1, '{}');

statement ok
CREATE STATISTICS s FROM t63387;

# Regression test for #71080. Stats collection should succeed on tables with NOT
# NULL virtual columns.
statement ok
SET CLUSTER SETTING sql.stats.multi_column_collection.enabled = true

statement ok
CREATE TABLE t71080 (
  k INT PRIMARY KEY,
  a INT,
  b INT NOT NULL AS (a + 10) VIRTUAL,
  INDEX (a, b)
);

statement ok
INSERT INTO t71080 VALUES (1, 2);

statement ok
CREATE STATISTICS s FROM t71080;

statement error cannot create statistics on virtual column \"b\"
CREATE STATISTICS s ON b FROM t71080;

statement error cannot create statistics on virtual column \"b\"
CREATE STATISTICS s ON a, b FROM t71080;

# Regression test for #76867. Do not attempt to collect empty multi-column stats
# when there are indexes on columns that are all virtual.
statement ok
CREATE TABLE t76867 (
  a INT,
  b INT AS (a + 1) VIRTUAL,
  c INT AS (a + 2) VIRTUAL,
  INDEX (b, c)
)

statement ok
ANALYZE t76867

# Regression tests for #80123. Collecting stats on system tables is allowed.
statement ok
ANALYZE system.locations

# EXPLAIN output should indicate stats collected on system.locations.
query T retry
SELECT * FROM [EXPLAIN SELECT * FROM system.locations] OFFSET 2
----
·
• scan
  estimated row count: 5 (100% of the table; stats collected <hidden> ago)
  table: locations@primary
  spans: FULL SCAN

# Collecting stats on system.lease is disallowed.
statement error pq: cannot create statistics on system.lease
ANALYZE system.lease

# Collecting stats on system.table_statistics is disallowed.
statement error pq: cannot create statistics on system.table_statistics
ANALYZE system.table_statistics

# Collecting stats on system.jobs is disallowed.
statement error pq: cannot create statistics on system.jobs
ANALYZE system.jobs

# Collecting stats on system.scheduled_jobs is disallowed.
statement error pq: cannot create statistics on system.scheduled_jobs
ANALYZE system.scheduled_jobs

# Collecting stats on empty tables should result in empty (but not NULL)
# histograms.
statement ok
CREATE TABLE tabula (r INT, a INT, sa INT, PRIMARY KEY (r), INDEX (a, sa))

statement ok
CREATE STATISTICS aristotle FROM tabula

query TTIB colnames
SELECT statistics_name, column_names, row_count, histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE tabula]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  has_histogram
aristotle        {a,sa}        0          false
aristotle        {a}           0          true
aristotle        {r}           0          true
aristotle        {sa}          0          true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE tabula]
WHERE statistics_name = 'aristotle' AND column_names = '{a}'

# This histogram should be empty.
query TIRI colnames
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows

query T
SELECT jsonb_pretty(COALESCE(json_agg(stat), '[]'))
  FROM (SELECT json_array_elements(statistics) - 'created_at' AS stat
        FROM [SHOW STATISTICS USING JSON FOR TABLE tabula])
----
[
    {
        "avg_size": 0,
        "columns": [
            "r"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "aristotle",
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "a"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "aristotle",
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "a",
            "sa"
        ],
        "distinct_count": 0,
        "histo_col_type": "",
        "name": "aristotle",
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "sa"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "aristotle",
        "null_count": 0,
        "row_count": 0
    }
]

# Collecting stats on columns with all NULL values should also result in empty
# (but not NULL) histograms.
statement ok
INSERT INTO tabula VALUES (11, 12, NULL)

statement ok
CREATE STATISTICS locke FROM tabula

query TTIIB colnames
SELECT statistics_name, column_names, row_count, null_count, histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE tabula]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  null_count  has_histogram
locke            {a,sa}        1          0           false
locke            {a}           1          0           true
locke            {r}           1          0           true
locke            {sa}          1          1           true

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE tabula]
WHERE statistics_name = 'locke' AND column_names = '{a}'

# This histogram should *not* be empty.
query TIRI colnames
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
12           0           0                    1

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE tabula]
WHERE statistics_name = 'locke' AND column_names = '{sa}'

# This histogram *should* be empty.
query TIRI colnames
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows

query T
SELECT jsonb_pretty(COALESCE(json_agg(stat), '[]'))
  FROM (SELECT json_array_elements(statistics) - 'created_at' - 'avg_size' AS stat
        FROM [SHOW STATISTICS USING JSON FOR TABLE tabula])
----
[
    {
        "columns": [
            "r"
        ],
        "distinct_count": 1,
        "histo_buckets": [
            {
                "distinct_range": 0,
                "num_eq": 1,
                "num_range": 0,
                "upper_bound": "11"
            }
        ],
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "locke",
        "null_count": 0,
        "row_count": 1
    },
    {
        "columns": [
            "a"
        ],
        "distinct_count": 1,
        "histo_buckets": [
            {
                "distinct_range": 0,
                "num_eq": 1,
                "num_range": 0,
                "upper_bound": "12"
            }
        ],
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "locke",
        "null_count": 0,
        "row_count": 1
    },
    {
        "columns": [
            "a",
            "sa"
        ],
        "distinct_count": 1,
        "histo_col_type": "",
        "name": "locke",
        "null_count": 0,
        "row_count": 1
    },
    {
        "columns": [
            "sa"
        ],
        "distinct_count": 1,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "name": "locke",
        "null_count": 1,
        "row_count": 1
    }
]

# Regression test for #76573
statement ok
CREATE TABLE t1 (a INT, b INT, c INT)

statement ok
ANALYZE t1

statement ok
CREATE STATISTICS t1_ab ON a,b FROM t1

statement ok
CREATE STATISTICS t1_ac ON a,c FROM t1

statement ok
CREATE STATISTICS t1_bc ON b,c FROM t1

statement ok
ALTER TABLE t1 drop column c

statement ok
show statistics for table t1

query TTIIIB colnames
SELECT
  statistics_name,
  column_names,
  row_count,
  distinct_count,
  null_count,
  histogram_id IS NOT NULL AS has_histogram
FROM
  [SHOW STATISTICS FOR TABLE t1]
ORDER BY statistics_name, column_names::STRING
----
statistics_name  column_names  row_count  distinct_count  null_count  has_histogram
NULL             {a}           0          0               0           true
NULL             {b}           0          0               0           true
NULL             {rowid}       0          0               0           true
t1_ab            {a,b}         0          0               0           false

query T
SELECT jsonb_pretty(COALESCE(json_agg(stat), '[]'))
  FROM (
SELECT json_array_elements(statistics) - 'created_at' AS stat
FROM [SHOW STATISTICS USING JSON FOR TABLE t1]
)
----
[
    {
        "avg_size": 0,
        "columns": [
            "a"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "b"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "rowid"
        ],
        "distinct_count": 0,
        "histo_col_type": "INT8",
        "histo_version": 2,
        "null_count": 0,
        "row_count": 0
    },
    {
        "avg_size": 0,
        "columns": [
            "a",
            "b"
        ],
        "distinct_count": 0,
        "histo_col_type": "",
        "name": "t1_ab",
        "null_count": 0,
        "row_count": 0
    }
]

# Check that column_names of multi-column stats are always sorted the same way.
statement ok
CREATE TABLE u (d INT, c INT, b INT, a INT, PRIMARY KEY (a, b), INDEX (c, d, a, b));

statement ok
CREATE STATISTICS u_defaults FROM u;

statement ok
CREATE STATISTICS u_a_b ON a, b FROM u;

statement ok
CREATE STATISTICS u_b_a ON b, a FROM u;

statement ok
CREATE STATISTICS u_c_d_b ON c, d, b FROM u;

query TT colnames
SELECT statistics_name, column_names
FROM [SHOW STATISTICS FOR TABLE u]
ORDER BY column_names, statistics_name
----
statistics_name  column_names
u_defaults       {a}
u_defaults       {b}
u_b_a            {b,a}
u_defaults       {c}
u_defaults       {d}
u_defaults       {d,c}
u_defaults       {d,c,a}
u_c_d_b          {d,c,b}
u_defaults       {d,c,b,a}

# Make sure that we can properly collect statistics on an array column that's
# both forward and inverted indexable.

statement ok
CREATE TABLE indexed_arr(a INT[]);
CREATE INDEX ON indexed_arr(a)

statement ok
INSERT INTO indexed_arr SELECT ARRAY[g] FROM generate_series(1,10000) g(g)

statement ok
ANALYZE indexed_arr

query TTIB
SELECT statistics_name, column_names, row_count, histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE indexed_arr]
ORDER BY statistics_name, column_names::STRING
----
NULL  {a}      10000  true
NULL  {rowid}  10000  true

statement ok
CREATE INDEX ON indexed_arr USING GIN (a)

query T
SELECT * FROM indexed_arr WHERE a = ARRAY[100]
----
{100}

query T
SELECT * FROM indexed_arr WHERE a @> ARRAY[100]
----
{100}

statement ok
ANALYZE indexed_arr

query TTIB
SELECT statistics_name, column_names, row_count, histogram_id IS NOT NULL AS has_histogram
FROM [SHOW STATISTICS FOR TABLE indexed_arr]
ORDER BY statistics_name, column_names::STRING
----
NULL  {a}      10000  true
NULL  {rowid}  10000  true

query T
SELECT * FROM indexed_arr WHERE a = ARRAY[100]
----
{100}

query T
SELECT * FROM indexed_arr WHERE a @> ARRAY[100]
----
{100}

# Test single column partial statistics creation.

statement ok
CREATE TABLE abcd (a INT PRIMARY KEY, b INT, c INT, d INT, INDEX (c, d));

statement ok
CREATE TABLE xy (x INT, y INT, INDEX (x, y))

statement ok
INSERT INTO xy VALUES (0, 10), (1, 11), (2, 12), (3, 13)

statement ok
INSERT INTO abcd VALUES
(1, 10, 100, 1000),
(2, 20, 200, 2000),
(3, 30, 300, 3000),
(4, 40, 400, 4000),
(5, 50, 500, 5000),
(6, 60, 600, 6000),
(7, 70, 700, 7000),
(8, 80, 800, 8000);

statement ok
CREATE STATISTICS abcd_a ON a FROM abcd;

statement ok
CREATE STATISTICS abcd_c ON c FROM abcd;

statement ok
CREATE STATISTICS xy_x ON x FROM xy;

# insert values at the extremes of column a and c.
statement ok
INSERT INTO abcd VALUES
(-2, -20, 900, 9000),
(-1, -10, 920, 9200),
(0, -9, 920, 9300);

# insert values at the extremes of column x.
statement ok
INSERT INTO xy VALUES (-1, 9), (-2, 8), (5, 15), (6, 16)

statement error pgcode 0A000 creating partial statistics with a WHERE clause is not yet supported
CREATE STATISTICS abcd_a_partial ON a FROM abcd WHERE a > 1;

statement error pgcode 0A000 creating partial statistics at extremes is not yet supported
CREATE STATISTICS abcd_a_partial ON a FROM abcd USING EXTREMES;

statement ok
SET enable_create_stats_using_extremes = on

statement ok
CREATE STATISTICS abcd_a_partial ON a FROM abcd USING EXTREMES;

statement ok
CREATE STATISTICS abcd_c_partial ON c FROM abcd USING EXTREMES;

statement ok
CREATE STATISTICS xy_x_partial ON x FROM xy USING EXTREMES;

let $hist_abcd_a_partial
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE abcd] WHERE statistics_name = 'abcd_a_partial';

let $hist_abcd_c_partial
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE abcd] WHERE statistics_name = 'abcd_c_partial';

let $hist_xy_x_partial
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE xy] WHERE statistics_name = 'xy_x_partial';

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_abcd_a_partial
----
upper_bound  range_rows  distinct_range_rows  equal_rows
-2           0           0                    1
-1           0           0                    1
0            0           0                    1

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_abcd_c_partial
----
upper_bound  range_rows  distinct_range_rows  equal_rows
900          0           0                    1
920          0           0                    2

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_xy_x_partial
----
upper_bound  range_rows  distinct_range_rows  equal_rows
-2           0           0                    1
-1           0           0                    1
5            0           0                    1
6            0           0                    1

query TT colnames
SELECT "name", "partialPredicate" FROM system.table_statistics WHERE name='abcd_a_partial';
----
name            partialPredicate
abcd_a_partial  (a IS NULL) OR ((a < 1:::INT8) OR (a > 8:::INT8))

query TT colnames
SELECT "name", "partialPredicate" FROM system.table_statistics WHERE name='abcd_c_partial';
----
name            partialPredicate
abcd_c_partial  (c IS NULL) OR ((c < 100:::INT8) OR (c > 800:::INT8))

query TT colnames
SELECT "name", "partialPredicate" FROM system.table_statistics WHERE name='xy_x_partial';
----
name          partialPredicate
xy_x_partial  (x IS NULL) OR ((x < 0:::INT8) OR (x > 3:::INT8))

# Test if requesting a partial stat again uses the previous full stat and not the previous partial stat.
statement ok
CREATE STATISTICS xy_x_partial_2 ON x FROM xy USING EXTREMES

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE xy]
ORDER BY statistics_name
----
statistics_name  partial_predicate                                  row_count  null_count
xy_x             NULL                                               4          0
xy_x_partial     (x IS NULL) OR ((x < 0:::INT8) OR (x > 3:::INT8))  4          0
xy_x_partial_2   (x IS NULL) OR ((x < 0:::INT8) OR (x > 3:::INT8))  4          0

# Verify that the full_histogram_id of the partial statistic
# is the statistics_id (or the histogram_id which is the same
# as the statistics_id) of the full statistic it was built from.
let $statistics_id
SELECT "histogram_id" FROM [SHOW STATISTICS FOR TABLE xy] WHERE "statistics_name" = 'xy_x'

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE xy]
WHERE full_histogram_id = '$statistics_id'
ORDER BY statistics_name
----
statistics_name  partial_predicate                                  row_count  null_count
xy_x_partial     (x IS NULL) OR ((x < 0:::INT8) OR (x > 3:::INT8))  4          0
xy_x_partial_2   (x IS NULL) OR ((x < 0:::INT8) OR (x > 3:::INT8))  4          0

# Test null values.
statement ok
CREATE TABLE a_null (a INT, INDEX (a));

statement ok
INSERT INTO a_null VALUES (NULL), (1), (2);

statement ok
CREATE STATISTICS a_null_stat ON a FROM a_null;

let $a_null_stats
SHOW STATISTICS USING JSON FOR TABLE a_null

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE a_null INJECT STATISTICS '$a_null_stats'

statement ok
INSERT INTO a_null VALUES (NULL), (NULL), (NULL);

statement ok
CREATE STATISTICS a_null_stat_partial ON a FROM a_null USING EXTREMES;

let $hist_a_null_stat_partial
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE a_null] WHERE statistics_name = 'a_null_stat_partial';

query TIRI colnames
SHOW HISTOGRAM $hist_a_null_stat_partial
----
upper_bound  range_rows  distinct_range_rows  equal_rows

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE a_null]
ORDER BY statistics_name
----
statistics_name      partial_predicate                                  row_count  null_count
a_null_stat          NULL                                               3          1
a_null_stat_partial  (a IS NULL) OR ((a < 1:::INT8) OR (a > 2:::INT8))  4          4

# Test descending indexes.
statement ok
CREATE TABLE d_desc (a INT, b INT, index (a DESC, b));

statement ok
INSERT INTO d_desc VALUES (1, 10), (2, 20), (3, 30), (4, 40);

statement ok
CREATE STATISTICS sd ON a FROM d_desc;

let $d_desc_stats
SHOW STATISTICS USING JSON FOR TABLE d_desc;

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE d_desc INJECT STATISTICS '$d_desc_stats'

statement ok
INSERT INTO d_desc VALUES (0, 0), (5, 50);

statement ok
CREATE STATISTICS sdp ON a FROM d_desc USING EXTREMES;

let $hist_d_desc
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE d_desc] WHERE statistics_name = 'sdp';

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_d_desc
----
upper_bound  range_rows  distinct_range_rows  equal_rows
0            0           0                    1
5            0           0                    1

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE d_desc]
ORDER BY statistics_name
----
statistics_name  partial_predicate                                  row_count  null_count
sd               NULL                                               4          0
sdp              (a IS NULL) OR ((a < 1:::INT8) OR (a > 4:::INT8))  2          0

# Test descending index with NULL
statement ok
INSERT INTO d_desc VALUES (NULL, NULL), (NULL, 2);

statement ok
CREATE STATISTICS sdn ON a FROM d_desc;

let $d_desc_null_stats
SHOW STATISTICS USING JSON FOR TABLE d_desc;

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE d_desc INJECT STATISTICS '$d_desc_null_stats'

statement ok
CREATE STATISTICS sdnp ON a FROM d_desc USING EXTREMES;

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE d_desc]
ORDER BY statistics_name
----
statistics_name  partial_predicate                                  row_count  null_count
sdn              NULL                                               8          2
sdnp             (a IS NULL) OR ((a < 0:::INT8) OR (a > 5:::INT8))  2          2

# Verify errors.
statement error pq: cannot process multiple partial statistics at once
CREATE STATISTICS abcd_defaults FROM abcd USING EXTREMES;

statement error pq: multi-column partial statistics are not currently supported
CREATE STATISTICS abcd_a_b ON a, c FROM abcd USING EXTREMES;

# Verify that a non-inverted index string column with a string histogram
# can have partial statistics
statement ok
CREATE TABLE s (s STRING, INDEX (s));

statement ok
INSERT INTO s VALUES ('c'), ('d'), ('e');

statement ok
CREATE STATISTICS str ON s FROM s;

let $s_stats
SHOW STATISTICS USING JSON FOR TABLE s;

statement ok
INSERT INTO s VALUES ('a'), ('b'), ('f');

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE s INJECT STATISTICS '$s_stats'

statement ok
CREATE STATISTICS s_partial ON s FROM s USING EXTREMES;

query TTII colnames
SELECT "statistics_name", "partial_predicate", "row_count", "null_count"
FROM [SHOW STATISTICS FOR TABLE s]
ORDER BY statistics_name
----
statistics_name  partial_predicate                                          row_count  null_count
s_partial        (s IS NULL) OR ((s < 'c':::STRING) OR (s > 'e':::STRING))  3          0
str              NULL                                                       3          0

# Verify that inverted index columns return an error.
statement ok
CREATE TABLE j (j JSONB, INVERTED INDEX (j));

statement ok
INSERT INTO j VALUES ('{"1":"10"}'), ('{"2":"20"}'),  ('{"3":"30"}');

statement ok
CREATE STATISTICS j_full ON j FROM j;

let $j_stats
SHOW STATISTICS USING JSON FOR TABLE j;

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE j INJECT STATISTICS '$j_stats'

statement error pq: table j does not contain a non-partial forward index with j as a prefix column
CREATE STATISTICS j_partial ON j FROM j USING EXTREMES;

statement ok
CREATE TABLE xyz (x INT, y INT, z INT, INDEX (x, y));

statement error pq: column x does not have a prior statistic
CREATE STATISTICS xyz_x ON x FROM xyz USING EXTREMES;

statement error pq: the latest full statistic for column a has no histogram
CREATE STATISTICS u_partial ON a FROM u USING EXTREMES;

statement error pq: table xy does not contain a non-partial forward index with y as a prefix column
CREATE STATISTICS xy_y_partial ON y FROM xy USING EXTREMES;

statement ok
CREATE TABLE only_null (a INT, INDEX (a));

statement ok
INSERT INTO only_null VALUES (NULL), (NULL), (NULL);

statement ok
CREATE STATISTICS only_null_stat ON a FROM only_null;

let $only_null_stat
SHOW STATISTICS USING JSON FOR TABLE only_null;

# Inject statistics so that the current stats
# cache is invalidated and creating partial
# statistics has access to the latest full
# statistic.
statement ok
ALTER TABLE only_null INJECT STATISTICS '$only_null_stat';

statement error pq: only NULL values exist in the index, so partial stats cannot be collected
CREATE STATISTICS only_null_partial ON a FROM only_null USING EXTREMES;

statement ok
CREATE INDEX ON xy (y) WHERE y > 5;

statement error pq: table xy does not contain a non-partial forward index with y as a prefix column
CREATE STATISTICS xy_partial_idx ON y FROM xy USING EXTREMES;

# Regression test for #100909. Ensure enum is hydrated in SHOW HISTOGRAM.
statement ok
CREATE TYPE enum1 as ENUM ('hello', 'hi');
CREATE TABLE t100909 (x int, y enum1);
INSERT INTO t100909 VALUES (1, 'hello'), (2, 'hello'), (3, 'hi');

statement ok
CREATE STATISTICS s1 ON y FROM t100909;

let $hist_id_1
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE t100909] WHERE statistics_name = 's1'

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_id_1
----
upper_bound  range_rows  distinct_range_rows  equal_rows
'hello'      0           0                    2
'hi'         0           0                    1
