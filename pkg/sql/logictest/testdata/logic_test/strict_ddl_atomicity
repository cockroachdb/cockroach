# Default behavior, where atomicity violations are allowed

statement ok
CREATE TABLE testing (k int, v string);
  INSERT INTO testing (k,v) VALUES (1, 'a'), (2, 'b'), (3, 'a'), (4, 'b');
  CREATE TABLE unrelated(x INT)


statement ok
BEGIN

statement ok
ALTER TABLE testing ADD CONSTRAINT "unique_values" UNIQUE(v)

statement ok
INSERT INTO testing (k,v) VALUES (5, 'c');
INSERT INTO unrelated(x) VALUES (1);


statement error pgcode XXA00 violates unique constraint.*\n.*\n.*\n.*\n.*issue.*42061
COMMIT

# oops!
query IT rowsort
SELECT * FROM testing
----
1  a
2  b
3  a
4  b
5  c

# oops again!
query I
SELECT * FROM unrelated
----
1

statement ok
DELETE FROM testing WHERE k = 5

# Now try again with the strict setting
statement ok
SET strict_ddl_atomicity = true

statement ok
BEGIN

statement error unimplemented: cannot run this DDL statement inside a multi-statement transaction as its atomicity cannot be guaranteed.*\n.*\n.*issue-v/42061
ALTER TABLE testing ADD CONSTRAINT "unique_values" UNIQUE(v)

statement ok
ROLLBACK

skipif config local-read-committed
statement error unimplemented: cannot run this DDL statement inside a multi-statement transaction as its atomicity cannot be guaranteed.*\n.*\n.*issue-v/42061
SELECT 1; ALTER TABLE testing ADD CONSTRAINT "unique_values" UNIQUE(v)

onlyif config local-read-committed
statement error to use multi-statement transactions involving a schema change under weak isolation levels, enable the autocommit_before_ddl setting
SELECT 1; ALTER TABLE testing ADD CONSTRAINT "unique_values" UNIQUE(v)
