# LogicTest: default parallel-stmts distsql

statement ok
CREATE TABLE t (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  d INT,
  INDEX b (b),
  UNIQUE INDEX c (c),
  FAMILY (a),
  FAMILY (b),
  FAMILY (c),
  FAMILY (d)
)

statement ok
INSERT INTO t VALUES (1, 2, 3, 4), (5, 6, 7, 8)

query ITTT
EXPLAIN SELECT * FROM t WHERE b = 2
----
0  index-join  (empty)  (empty)    
1  scan        (empty)  (empty)    
1  (empty)     table    t@b        
1  (empty)     spans    /2-/3      
1  scan        (empty)  (empty)    
1  (empty)     table    t@primary  

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT * FROM t WHERE b = 2]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /t/b/2/1 -> NULL
fetched: /t/primary/1 -> NULL
fetched: /t/primary/1/b -> 2
fetched: /t/primary/1/c -> 3
fetched: /t/primary/1/d -> 4
output row: [1 2 3 4]

query IIII
SELECT * FROM t WHERE b = 2
----
1 2 3 4

query ITTT
EXPLAIN SELECT * FROM t WHERE c = 6
----
0  index-join  (empty)  (empty)    
1  scan        (empty)  (empty)    
1  (empty)     table    t@c        
1  (empty)     spans    /6-/7      
1  scan        (empty)  (empty)    
1  (empty)     table    t@primary  

query T
SELECT message FROM [SHOW KV TRACE FOR SELECT * FROM t WHERE c = 7]
 WHERE message LIKE 'fetched:%' OR message LIKE 'output row%'
----
fetched: /t/c/7 -> /5
fetched: /t/primary/5 -> NULL
fetched: /t/primary/5/b -> 6
fetched: /t/primary/5/c -> 7
fetched: /t/primary/5/d -> 8
output row: [5 6 7 8]

query IIII
SELECT * FROM t WHERE c = 7
----
5 6 7 8

query ITTTTT
EXPLAIN (METADATA) SELECT * FROM t WHERE c > 0 ORDER BY c DESC
----
0  index-join  (empty)  (empty)    (a, b, c, d)                             -c,unique  
1  revscan     (empty)  (empty)    (a, b[omitted], c[omitted], d[omitted])  -c,unique  
1  (empty)     table    t@c        (empty)                                  (empty)    
1  (empty)     spans    /1-        (empty)                                  (empty)    
1  scan        (empty)  (empty)    (a, b, c, d)                             (empty)    
1  (empty)     table    t@primary  (empty)                                  (empty)    

query IIII
SELECT * FROM t WHERE c > 0 ORDER BY c DESC
----
5 6 7 8
1 2 3 4

query ITTT
EXPLAIN SELECT * FROM t WHERE c > 0 ORDER BY c
----
0  index-join  (empty)  (empty)    
1  scan        (empty)  (empty)    
1  (empty)     table    t@c        
1  (empty)     spans    /1-        
1  scan        (empty)  (empty)    
1  (empty)     table    t@primary  

query IIII
SELECT * FROM t WHERE c > 0 AND d = 8
----
5 6 7 8

query ITTT
EXPLAIN SELECT * FROM t WHERE c > 0 AND d = 8
----
0  index-join  (empty)  (empty)    
1  scan        (empty)  (empty)    
1  (empty)     table    t@c        
1  (empty)     spans    /1-        
1  scan        (empty)  (empty)    
1  (empty)     table    t@primary  

# The following testcases verify that when we have a small limit, we prefer an
# order-matching index.

query ITTT
EXPLAIN SELECT * FROM t ORDER BY c
----
0  sort     (empty)  (empty)    
0  (empty)  order    +c         
1  scan     (empty)  (empty)    
1  (empty)  table    t@primary  
1  (empty)  spans    ALL        

query ITTT
EXPLAIN SELECT * FROM t ORDER BY c LIMIT 5
----
0  limit       (empty)  (empty)    
1  index-join  (empty)  (empty)    
2  scan        (empty)  (empty)    
2  (empty)     table    t@c        
2  (empty)     spans    ALL        
2  (empty)     limit    5          
2  scan        (empty)  (empty)    
2  (empty)     table    t@primary  

query ITTT
EXPLAIN (EXPRS) SELECT * FROM t ORDER BY c OFFSET 5
----
0  limit    (empty)  (empty)    
0  (empty)  offset   5          
1  sort     (empty)  (empty)    
1  (empty)  order    +c         
2  scan     (empty)  (empty)    
2  (empty)  table    t@primary  
2  (empty)  spans    ALL        

query ITTT
EXPLAIN (EXPRS) SELECT * FROM t ORDER BY c LIMIT 5 OFFSET 5
----
0  limit       (empty)  (empty)    
0  (empty)     count    5          
0  (empty)     offset   5          
1  index-join  (empty)  (empty)    
2  scan        (empty)  (empty)    
2  (empty)     table    t@c        
2  (empty)     spans    ALL        
2  (empty)     limit    10         
2  scan        (empty)  (empty)    
2  (empty)     table    t@primary  

query ITTT
EXPLAIN (EXPRS) SELECT * FROM t ORDER BY c LIMIT 1000000
----
0  limit    (empty)   (empty)      
0  (empty)  count     1000000      
1  sort     (empty)   (empty)      
1  (empty)  order     +c           
1  (empty)  strategy  top 1000000  
2  scan     (empty)   (empty)      
2  (empty)  table     t@primary    
2  (empty)  spans     ALL          

