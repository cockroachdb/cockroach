# LogicTest: default parallel-stmts distsql

query I colnames
SELECT * FROM GENERATE_SERIES(1, 3)
----
generate_series
1
2
3

query II colnames
SELECT * FROM GENERATE_SERIES(1, 2), GENERATE_SERIES(1, 2)
----
generate_series  generate_series
1                1
1                2
2                1
2                2

query I
SELECT * FROM GENERATE_SERIES(3, 1, -1)
----
3
2
1

query I
SELECT * FROM GENERATE_SERIES(3, 1)
----

query error step cannot be 0
SELECT * FROM GENERATE_SERIES(1, 3, 0)

query I
SELECT * FROM PG_CATALOG.GENERATE_SERIES(1, 3)
----
1
2
3

query I colnames
SELECT * FROM GENERATE_SERIES(1, 1) AS c(x)
----
x
1

query II colnames
SELECT * FROM GENERATE_SERIES(1, 1) WITH ORDINALITY
----
generate_series  ordinality
1                1

query II colnames
SELECT * FROM GENERATE_SERIES(1, 1) WITH ORDINALITY AS c(x, y)
----
x y
1 1

query error argument of LIMIT must be type int, not type setof
SELECT * FROM (VALUES (1)) LIMIT GENERATE_SERIES(1, 3)

query I colnames
SELECT GENERATE_SERIES(1, 2)
----
generate_series
1
2

query II colnames
SELECT GENERATE_SERIES(1, 2), GENERATE_SERIES(3, 4)
----
generate_series             generate_series
1                           3
1                           4
2                           3
2                           4

statement ok
CREATE TABLE t (a string)

statement ok
CREATE TABLE u (b string)

statement ok
INSERT INTO t VALUES ('cat')

statement ok
INSERT INTO u VALUES ('bird')

# The following two queries should have the same result. This exercises the
# transformation that moves generator expressions in render positions to cross
# joins.
query TTII
SELECT t.*, u.*, generate_series(1,2), generate_series(3, 4) FROM t, u
----
cat  bird  1  3
cat  bird  1  4
cat  bird  2  3
cat  bird  2  4

query TTII
SELECT t.*, u.*, a.*, b.* FROM t, u, generate_series(1, 2) AS a, generate_series(3, 4) AS b
----
cat  bird  1  3
cat  bird  1  4
cat  bird  2  3
cat  bird  2  4

query I
SELECT 3 + x FROM generate_series(1,2) AS a(x)
----
4
5


query I colnames
SELECT 3 + generate_series(1,2)
----
3 + generate_series(1, 2)
4
5

query I
SELECT 3 + (3 * generate_series(1,3))
----
6
9
12

query I
SELECT * from unnest(ARRAY[1,2])
----
1
2

query IT
SELECT unnest(ARRAY[1,2]), unnest(ARRAY['a', 'b'])
----
1  a
1  b
2  a
2  b

query I
SELECT unnest(ARRAY[3,4]) - 2
----
1
2

query II
SELECT 1 + generate_series(0, 1), unnest(ARRAY[2, 4]) - 1
----
1  1
1  3
2  1
2  3

query I
SELECT ascii(unnest(ARRAY['a', 'b', 'c']));
----
97
98
99

query error pq: cannot specify two set-returning functions in the same SELECT expression
SELECT generate_series(generate_series(1, 3), 3)

query error pq: cannot specify two set-returning functions in the same SELECT expression
SELECT generate_series(1, 3) + generate_series(1, 3)

query error pq: column name "generate_series" not found
SELECT generate_series(1, 3) FROM t WHERE generate_series > 3

# Regressions for #15900: ensure that null parameters to generate_series don't
# cause issues.

query T
SELECT * from generate_series(1, (select * from generate_series(1, 0)))
----

# The following query is designed to produce a null array argument to unnest
# in a way that the type system can't detect before evaluation.
query T
SELECT unnest((select current_schemas((select isnan((select round(3.4, (select generate_series(1, 0)))))))));
----
