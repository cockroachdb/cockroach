statement ok
CREATE TABLE t1 (a INT, b INT, c INT);
CREATE TABLE t2 (a INT, b INT, d INT);
INSERT INTO t1 VALUES (1, 11, 111), (2, 22, 222), (3, 33, 333);
INSERT INTO t2 VALUES (1, 11, 111), (2, 22, 222), (3, 33, 333);

statement ok
CREATE FUNCTION get_body_str(fn_name STRING) RETURNS STRING
LANGUAGE SQL
AS $$
  SELECT crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor', descriptor, false
  )->'function'->'functionBody'
  FROM system.descriptor WHERE id = fn_name::regproc::int - 100000;
$$;

# Make sure that unqualified columns names are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT a FROM t1 WHERE b > 20 ORDER BY b;
$$

# Make sure table names are rewritten.
query T
SELECT get_body_str('f');
----
"SELECT a FROM {TABLE:106} WHERE b > 20 ORDER BY b;"

# Make sure show create function deserializes it.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT a FROM test.public.t1 WHERE b > 20 ORDER BY b;
$$

# Make sure function is still executable.
query I
SELECT f()
----
2

# Make sure that qualified column names are rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t1.a FROM t1 WHERE t1.b > 20 ORDER BY t1.b;
$$

# Make sure table names are rewritten.
query T
SELECT get_body_str('f');
----
"SELECT {TABLE:106}.a FROM {TABLE:106} WHERE {TABLE:106}.b > 20 ORDER BY {TABLE:106}.b;"

# Make sure show create function deserializes it.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a FROM test.public.t1 WHERE test.public.t1.b > 20 ORDER BY test.public.t1.b;
$$

query I
SELECT f()
----
2

# Make sure that column names from subquery are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t.a FROM (SELECT a FROM t1 WHERE b > 20 ORDER BY b) t WHERE t.a > 1 ORDER BY t.a;
$$

query T
SELECT get_body_str('f');
----
"SELECT t.a FROM (SELECT a FROM {TABLE:106} WHERE b > 20 ORDER BY b) AS t WHERE t.a > 1 ORDER BY t.a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT t.a FROM (SELECT a FROM test.public.t1 WHERE b > 20 ORDER BY b) AS t WHERE t.a > 1 ORDER BY t.a;
$$

query I
SELECT f()
----
2

# Make sure that "ORDER BY star" and "GROUP BY star" are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f_order_star() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT *
  FROM t1 JOIN t2 ON c = d
  GROUP BY t1.*, t2.*
  ORDER BY t1.*, t2.*;
$$

query T
SELECT get_body_str('f_order_star');
----
"SELECT {TABLE:106}.a, {TABLE:106}.b, {TABLE:106}.c, {TABLE:107}.a, {TABLE:107}.b, {TABLE:107}.d FROM {TABLE:106} JOIN {TABLE:107} ON c = d GROUP BY t1.*, t2.* ORDER BY t1.*, t2.*;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_order_star]
----
CREATE FUNCTION public.f_order_star()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a, test.public.t1.b, test.public.t1.c, test.public.t2.a, test.public.t2.b, test.public.t2.d FROM test.public.t1 JOIN test.public.t2 ON c = d GROUP BY t1.*, t2.* ORDER BY t1.*, t2.*;
$$

query T
SELECT f_order_star()
----
(1,11,111,1,11,111)

# Make sure that SRF column in ORDER BY is not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f_order_srf() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT (pg_get_keywords()).* ORDER BY word LIMIT 1
$$

query T
SELECT get_body_str('f_order_srf');
----
"SELECT (pg_get_keywords()).word, (pg_get_keywords()).catcode, (pg_get_keywords()).catdesc ORDER BY word LIMIT 1;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_order_star]
----
CREATE FUNCTION public.f_order_star()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a, test.public.t1.b, test.public.t1.c, test.public.t2.a, test.public.t2.b, test.public.t2.d FROM test.public.t1 JOIN test.public.t2 ON c = d GROUP BY t1.*, t2.* ORDER BY t1.*, t2.*;
$$

query T
SELECT f_order_srf()
----
(abort,U,unreserved)

# Make sure qualified column names in JOIN, GROUP BY, HAVING are rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t1.a + t2.a
  FROM t1
  JOIN t2 ON t1.b = t2.b
  GROUP BY t1.a + t2.a
  HAVING t1.a + t2.a > 1
  ORDER BY t1.a + t2.a;
$$

query T
SELECT get_body_str('f');
----
"SELECT {TABLE:106}.a + {TABLE:107}.a FROM {TABLE:106} JOIN {TABLE:107} ON {TABLE:106}.b = {TABLE:107}.b GROUP BY {TABLE:106}.a + {TABLE:107}.a HAVING ({TABLE:106}.a + {TABLE:107}.a) > 1 ORDER BY {TABLE:106}.a + {TABLE:107}.a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a + test.public.t2.a FROM test.public.t1 JOIN test.public.t2 ON {TABLE:106}.b = {TABLE:107}.b GROUP BY test.public.t1.a + test.public.t2.a HAVING (test.public.t1.a + test.public.t2.a) > 1 ORDER BY test.public.t1.a + test.public.t2.a;
$$

query I
SELECT f()
----
2

# Make sure unqualified column names in JOIN, GROUP BY, HAVING are not
# rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT c + d
  FROM t1
  JOIN t2 ON c = d
  GROUP BY c + d
  HAVING c + d > 1
  ORDER BY c + d;
$$

query T
SELECT get_body_str('f');
----
"SELECT c + d FROM {TABLE:106} JOIN {TABLE:107} ON c = d GROUP BY c + d HAVING (c + d) > 1 ORDER BY c + d;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT c + d FROM test.public.t1 JOIN test.public.t2 ON c = d GROUP BY c + d HAVING (c + d) > 1 ORDER BY c + d;
$$

query I
SELECT f()
----
222

# Make sure JOIN USING is not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t1.a + t2.a
  FROM t1
  JOIN t2 USING (a)
$$

query T
SELECT get_body_str('f');
----
"SELECT {TABLE:106}.a + {TABLE:107}.a FROM {TABLE:106} JOIN {TABLE:107} USING (a);"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a + test.public.t2.a FROM test.public.t1 JOIN test.public.t2 USING (a);
$$

# Make sure table aliases are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT p.a + q.a
  FROM t1 as p
  JOIN t2 as q ON p.b = q.b
  GROUP BY p.a + q.a
  HAVING p.a + q.a > 1
  ORDER BY p.a + q.a;
$$

query T
SELECT get_body_str('f');
----
"SELECT p.a + q.a FROM {TABLE:106} AS p JOIN {TABLE:107} AS q ON p.b = q.b GROUP BY p.a + q.a HAVING (p.a + q.a) > 1 ORDER BY p.a + q.a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT p.a + q.a FROM test.public.t1 AS p JOIN test.public.t2 AS q ON p.b = q.b GROUP BY p.a + q.a HAVING (p.a + q.a) > 1 ORDER BY p.a + q.a;
$$

query I
SELECT f()
----
2

# Make sure unqualified DISTINCT ON columns are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT DISTINCT ON (a) b FROM t1 ORDER BY a;
$$

query T
SELECT get_body_str('f');
----
"SELECT DISTINCT ON (a) b FROM {TABLE:106} ORDER BY a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT DISTINCT ON (a) b FROM test.public.t1 ORDER BY a;
$$

query I
SELECT f()
----
11

# Make sure qualified DISTINCT ON columns are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT DISTINCT ON (t1.a) t1.b FROM t1 ORDER BY a;
$$

query T
SELECT get_body_str('f');
----
"SELECT DISTINCT ON ({TABLE:106}.a) {TABLE:106}.b FROM {TABLE:106} ORDER BY a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT DISTINCT ON (test.public.t1.a) test.public.t1.b FROM test.public.t1 ORDER BY a;
$$

query I
SELECT f()
----
11

# Make sure * expanded columns are rewritten.
statement ok
CREATE OR REPLACE FUNCTION f_expand() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT *, a FROM t1;
$$

query T
SELECT get_body_str('f_expand');
----
"SELECT {TABLE:106}.a, {TABLE:106}.b, {TABLE:106}.c, a FROM {TABLE:106};"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_expand]
----
CREATE FUNCTION public.f_expand()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a, test.public.t1.b, test.public.t1.c, a FROM test.public.t1;
$$

query T
SELECT f_expand()
----
(1,11,111,1)

# Make sure * expanded columns are only rewritten for columns from non-aliased source.
statement ok
CREATE OR REPLACE FUNCTION f_expand() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT * FROM (SELECT *, a FROM t1) t;
$$

query T
SELECT get_body_str('f_expand');
----
"SELECT t.a, t.b, t.c, t.a FROM (SELECT {TABLE:106}.a, {TABLE:106}.b, {TABLE:106}.c, a FROM {TABLE:106}) AS t;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_expand]
----
CREATE FUNCTION public.f_expand()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT t.a, t.b, t.c, t.a FROM (SELECT test.public.t1.a, test.public.t1.b, test.public.t1.c, a FROM test.public.t1) AS t;
$$

query T
SELECT f_expand()
----
(1,11,111,1)
