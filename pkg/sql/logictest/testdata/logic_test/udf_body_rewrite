statement ok
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
INSERT INTO t1 VALUES (1, 11), (2, 22), (3, 33);
INSERT INTO t2 VALUES (1, 11), (2, 22), (4, 44);

statement ok
CREATE FUNCTION get_body_str(fn_name STRING) RETURNS STRING
LANGUAGE SQL
AS $$
  SELECT crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor', descriptor, false
  )->'function'->'functionBody'
  FROM system.descriptor WHERE id = fn_name::regproc::int - 100000;
$$;

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT a FROM t1 WHERE b > 20 ORDER BY b;
$$

# Make sure table names are rewritten.
query T
SELECT get_body_str('f');
----
"SELECT {TABLE:106}.a FROM {TABLE:106} WHERE {TABLE:106}.b > 20 ORDER BY {TABLE:106}.b;"

# Make sure show create function deserializes it.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a FROM test.public.t1 WHERE test.public.t1.b > 20 ORDER BY test.public.t1.b;
$$

# Make sure function is still executable.
query I
SELECT f()
----
2

# Make sure that sub-query round trip well.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t.a FROM (SELECT a FROM t1 WHERE b > 20 ORDER BY b) t WHERE t.a > 1;
$$

query T
SELECT get_body_str('f');
----
"SELECT t.a FROM (SELECT {TABLE:106}.a FROM {TABLE:106} WHERE {TABLE:106}.b > 20 ORDER BY {TABLE:106}.b) AS t WHERE t.a > 1;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT t.a FROM (SELECT test.public.t1.a FROM test.public.t1 WHERE test.public.t1.b > 20 ORDER BY test.public.t1.b) AS t WHERE t.a > 1;
$$

query I
SELECT f()
----
2

# Make sure JOIN, GROUP BY, HAVING are all handled.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT t1.a + t2.a
  FROM t1
  JOIN t2 ON t1.b = t2.b
  GROUP BY t1.a + t2.a
  HAVING t1.a + t2.a > 1
  ORDER BY t1.a + t2.a;
$$

query T
SELECT get_body_str('f');
----
"SELECT {TABLE:106}.a + {TABLE:107}.a FROM {TABLE:106} JOIN {TABLE:107} ON {TABLE:106}.b = {TABLE:107}.b GROUP BY {TABLE:106}.a + {TABLE:107}.a HAVING ({TABLE:106}.a + {TABLE:107}.a) > 1 ORDER BY {TABLE:106}.a + {TABLE:107}.a;"

# TODO(chengxiong): #102032, table ids in JOIN ON condition should be
# deserialized.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a + test.public.t2.a FROM test.public.t1 JOIN test.public.t2 ON {TABLE:106}.b = {TABLE:107}.b GROUP BY test.public.t1.a + test.public.t2.a HAVING (test.public.t1.a + test.public.t2.a) > 1 ORDER BY test.public.t1.a + test.public.t2.a;
$$

query I
SELECT f()
----
2

# Make sure table aliases are not rewritten.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT p.a + q.a
  FROM t1 as p
  JOIN t2 as q ON p.b = q.b
  GROUP BY p.a + q.a
  HAVING p.a + q.a > 1
  ORDER BY p.a + q.a;
$$

query T
SELECT get_body_str('f');
----
"SELECT p.a + q.a FROM {TABLE:106} AS p JOIN {TABLE:107} AS q ON p.b = q.b GROUP BY p.a + q.a HAVING (p.a + q.a) > 1 ORDER BY p.a + q.a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT p.a + q.a FROM test.public.t1 AS p JOIN test.public.t2 AS q ON p.b = q.b GROUP BY p.a + q.a HAVING (p.a + q.a) > 1 ORDER BY p.a + q.a;
$$

query I
SELECT f()
----
2

# Make sure DISTINCT ON is handled
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT
LANGUAGE SQL
AS $$
  SELECT DISTINCT ON (a) b FROM t1 ORDER BY a;
$$

query T
SELECT get_body_str('f');
----
"SELECT DISTINCT ON ({TABLE:106}.a) {TABLE:106}.b FROM {TABLE:106} ORDER BY {TABLE:106}.a;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f]
----
CREATE FUNCTION public.f()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT DISTINCT ON (test.public.t1.a) test.public.t1.b FROM test.public.t1 ORDER BY test.public.t1.a;
$$

query I
SELECT f()
----
11

# Make sure * expanded columns are rewritten.
statement ok
CREATE OR REPLACE FUNCTION f_expand() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT *, a FROM t1;
$$

query T
SELECT get_body_str('f_expand');
----
"SELECT {TABLE:106}.a, {TABLE:106}.b, {TABLE:106}.a FROM {TABLE:106};"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_expand]
----
CREATE FUNCTION public.f_expand()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT test.public.t1.a, test.public.t1.b, test.public.t1.a FROM test.public.t1;
$$

query T
SELECT f_expand()
----
(1,11,1)

# Make sure * expanded columns are only rewritten for columns from non-aliased source.
statement ok
CREATE OR REPLACE FUNCTION f_expand() RETURNS RECORD
LANGUAGE SQL
AS $$
  SELECT * FROM (SELECT *, a FROM t1) t;
$$

query T
SELECT get_body_str('f_expand');
----
"SELECT t.a, t.b, t.a FROM (SELECT {TABLE:106}.a, {TABLE:106}.b, {TABLE:106}.a FROM {TABLE:106}) AS t;"

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f_expand]
----
CREATE FUNCTION public.f_expand()
  RETURNS RECORD
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT t.a, t.b, t.a FROM (SELECT test.public.t1.a, test.public.t1.b, test.public.t1.a FROM test.public.t1) AS t;
$$

query T
SELECT f_expand()
----
(1,11,1)
