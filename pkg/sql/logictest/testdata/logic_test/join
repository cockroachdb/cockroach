# LogicTest: default parallel-stmts distsql distsql-disk

# The join condition logic is tricky to get right with NULL
# values. Simple implementations can deal well with NULLs on the first
# or last row but fail to handle them in the middle. So the test table
# must contain at least 3 rows with a null in the middle. This test
# table also contains the pair 44/42 so that a test with a non-trivial
# ON condition can be written.
statement ok
CREATE TABLE onecolumn (x INT); INSERT INTO onecolumn(x) VALUES (44), (NULL), (42)

query II colnames,rowsort
SELECT * FROM onecolumn AS a(x) CROSS JOIN onecolumn AS b(y)
----
   x     y
  44    44
  44  NULL
  44    42
NULL    44
NULL  NULL
NULL    42
  42    44
  42  NULL
  42    42

# Check that name resolution chokes on ambiguity when it needs to.
query error column reference "x" is ambiguous \(candidates: a.x, b.x\)
SELECT x FROM onecolumn AS a, onecolumn AS b

query II colnames,rowsort
SELECT * FROM onecolumn AS a(x) JOIN onecolumn AS b(y) ON a.x = b.y
----
 x  y
44 44
42 42

query I colnames
SELECT * FROM onecolumn AS a JOIN onecolumn as b USING(x) ORDER BY x
----
 x
42
44

query I colnames,rowsort
SELECT * FROM onecolumn AS a NATURAL JOIN onecolumn as b
----
 x
44
42

query II colnames,rowsort
SELECT * FROM onecolumn AS a(x) LEFT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----
   x     y
  44    44
NULL  NULL
  42    42

query I colnames
SELECT * FROM onecolumn AS a LEFT OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
   x
NULL
  42
  44

# Check that ORDER BY chokes on ambiguity if no table less columns
# were introduced by USING. (#12239)
query error ORDER BY "x" is ambiguous
SELECT * FROM onecolumn AS a, onecolumn AS b ORDER BY x

query I colnames,rowsort
SELECT * FROM onecolumn AS a NATURAL LEFT OUTER JOIN onecolumn AS b
----
   x
  44
NULL
  42

query II colnames,rowsort
SELECT * FROM onecolumn AS a(x) RIGHT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----
   x     y
  44    44
  42    42
NULL  NULL

query I colnames
SELECT * FROM onecolumn AS a RIGHT OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
   x
NULL
  42
  44

query I colnames,rowsort
SELECT * FROM onecolumn AS a NATURAL RIGHT OUTER JOIN onecolumn AS b
----
   x
  44
  42
NULL

statement ok
CREATE TABLE onecolumn_w(w INT); INSERT INTO onecolumn_w(w) VALUES (42),(43)

query II colnames,rowsort
SELECT * FROM onecolumn AS a NATURAL JOIN onecolumn_w as b
----
   x  w
  44  42
  44  43
NULL  42
NULL  43
  42  42
  42  43

statement ok
CREATE TABLE othercolumn (x INT); INSERT INTO othercolumn(x) VALUES (43),(42),(16)

query II colnames
SELECT * FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b ON a.x = b.x ORDER BY a.x,b.x
----
x    x
NULL NULL
NULL 16
NULL 43
42   42
44   NULL

query I colnames
SELECT * FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b USING(x) ORDER BY x
----
x
NULL
16
42
43
44

# Check that the source columns can be selected separately from the
# USING column (#12033).
query III colnames
SELECT x AS s, a.x, b.x FROM onecolumn AS a FULL OUTER JOIN othercolumn AS b USING(x) ORDER BY s
----
   s      x      x
NULL   NULL   NULL
  16   NULL     16
  42     42     42
  43   NULL     43
  44     44   NULL

query I colnames
SELECT * FROM onecolumn AS a NATURAL FULL OUTER JOIN othercolumn AS b ORDER BY x
----
x
NULL
16
42
43
44

# Check that a limit on the JOIN's result do not cause rows from the
# JOIN operands to become invisible to the JOIN.
query I colnames
SELECT * FROM (SELECT x FROM onecolumn ORDER BY x DESC) NATURAL JOIN (VALUES (42)) AS v(x) LIMIT 1
----
x
42

statement ok
CREATE TABLE empty (x INT)

query II
SELECT * FROM onecolumn AS a(x) CROSS JOIN empty AS b(y)
----

query II
SELECT * FROM empty AS a CROSS JOIN onecolumn AS b
----

query II
SELECT * FROM onecolumn AS a(x) JOIN empty AS b(y) ON a.x = b.y
----

query I
SELECT * FROM onecolumn AS a JOIN empty AS b USING(x)
----

query II
SELECT * FROM empty AS a(x) JOIN onecolumn AS b(y) ON a.x = b.y
----

query I
SELECT * FROM empty AS a JOIN onecolumn AS b USING(x)
----

query II colnames
SELECT * FROM onecolumn AS a(x) LEFT OUTER JOIN empty AS b(y) ON a.x = b.y ORDER BY a.x
----
x     y
NULL  NULL
42    NULL
44    NULL

query I colnames
SELECT * FROM onecolumn AS a LEFT OUTER JOIN empty AS b USING(x) ORDER BY x
----
x
NULL
42
44

query II
SELECT * FROM empty AS a(x) LEFT OUTER JOIN onecolumn AS b(y) ON a.x = b.y
----

query I
SELECT * FROM empty AS a LEFT OUTER JOIN onecolumn AS b USING(x)
----

query II
SELECT * FROM onecolumn AS a(x) RIGHT OUTER JOIN empty AS b(y) ON a.x = b.y
----

query I
SELECT * FROM onecolumn AS a RIGHT OUTER JOIN empty AS b USING(x)
----

query II colnames
SELECT * FROM empty AS a(x) FULL OUTER JOIN onecolumn AS b(y) ON a.x = b.y ORDER BY b.y
----
x     y
NULL  NULL
NULL  42
NULL  44

query I colnames
SELECT * FROM empty AS a FULL OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
x
NULL
42
44

query II colnames
SELECT * FROM onecolumn AS a(x) FULL OUTER JOIN empty AS b(y) ON a.x = b.y ORDER BY a.x
----
x     y
NULL  NULL
42    NULL
44    NULL

query I colnames
SELECT * FROM onecolumn AS a FULL OUTER JOIN empty AS b USING(x) ORDER BY x
----
x
NULL
42
44

query II colnames
SELECT * FROM empty AS a(x) FULL OUTER JOIN onecolumn AS b(y) ON a.x = b.y ORDER BY b.y
----
x     y
NULL  NULL
NULL  42
NULL  44

query I colnames
SELECT * FROM empty AS a FULL OUTER JOIN onecolumn AS b USING(x) ORDER BY x
----
x
NULL
42
44

statement ok
CREATE TABLE twocolumn (x INT, y INT); INSERT INTO twocolumn(x, y) VALUES (44,51), (NULL,52), (42,53), (45,45)

# Natural joins with partial match
query II colnames,rowsort
SELECT * FROM onecolumn NATURAL JOIN twocolumn
----
x    y
44   51
42   53

query IIII rowsort
SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = a.y
----
45  45  44    51
45  45  NULL  52
45  45  42    53
45  45  45    45

# Inner join with filter predicate
query II
SELECT o.x, t.y FROM onecolumn o INNER JOIN twocolumn t ON (o.x=t.x AND t.y=53)
----
42   53

# Outer joins with filter predicate
query II rowsort
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND t.y=53)
----
44   NULL
NULL NULL
42   53

query II rowsort
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND o.x=44)
----
44   51
NULL NULL
42   NULL

query II rowsort
SELECT o.x, t.y FROM onecolumn o LEFT OUTER JOIN twocolumn t ON (o.x=t.x AND t.x=44)
----
44   51
NULL NULL
42   NULL

## Simple test cases for inner, left, right, and outer joins

statement ok
CREATE TABLE a (i int); INSERT INTO a VALUES (1), (2), (3)

statement ok
CREATE TABLE b (i int, b bool); INSERT INTO b VALUES (2, true), (3, true), (4, false)

query IIB rowsort
SELECT * FROM a INNER JOIN b ON a.i = b.i
----
2 2 true
3 3 true

query IIB rowsort
SELECT * FROM a LEFT OUTER JOIN b ON a.i = b.i
----
1 NULL NULL
2 2    true
3 3    true

query IIB rowsort
SELECT * FROM a RIGHT OUTER JOIN b ON a.i = b.i
----
2    2    true
3    3    true
NULL 4    false

query IIB rowsort
SELECT * FROM a FULL OUTER JOIN b ON a.i = b.i
----
1    NULL NULL
2    2    true
3    3    true
NULL 4    false

# Full outer join with filter predicate
query IIB
SELECT * FROM a FULL OUTER JOIN b ON (a.i = b.i and a.i>2) ORDER BY a.i, b.i
----
NULL 2    true
NULL 4    false
1    NULL NULL
2    NULL NULL
3    3    true

# Duplicate right matches for a single left row
statement ok
INSERT INTO b VALUES (3, false)

query IIB
SELECT * FROM a RIGHT OUTER JOIN b ON a.i=b.i ORDER BY b.i, b.b
----
2    2 true
3    3 false
3    3 true
NULL 4 false

query IIB
SELECT * FROM a FULL OUTER JOIN b ON a.i=b.i ORDER BY b.i, b.b
----
1    NULL NULL
2    2    true
3    3    false
3    3    true
NULL 4    false


# Check column orders and names.
query IIIIII colnames
SELECT * FROM (onecolumn CROSS JOIN twocolumn JOIN onecolumn AS a(b) ON a.b=twocolumn.x JOIN twocolumn AS c(d,e) ON a.b=c.d AND c.d=onecolumn.x) ORDER BY 1 LIMIT 1
----
x  x  y  b  d  e
42 42 53 42 42 53


# Check EXPLAIN.
query TTT
EXPLAIN (EXPRS) SELECT * FROM onecolumn JOIN twocolumn USING(x)
----
render          ·         ·
 │              render 0  x
 │              render 1  y
 └── join       ·         ·
      │         type      inner
      │         equality  (x) = (x)
      ├── scan  ·         ·
      │         table     onecolumn@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     twocolumn@primary
·               spans     ALL

# Check EXPLAIN.
query TTT
EXPLAIN (EXPRS) SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = b.y
----
render          ·         ·
 │              render 0  x
 │              render 1  y
 │              render 2  x
 │              render 3  y
 └── join       ·         ·
      │         type      inner
      │         equality  (x) = (y)
      ├── scan  ·         ·
      │         table     twocolumn@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     twocolumn@primary
·               spans     ALL

# Check EXPLAIN.
query TTT
EXPLAIN (EXPRS) SELECT * FROM twocolumn AS a JOIN twocolumn AS b ON a.x = 44
----
render          ·         ·
 │              render 0  x
 │              render 1  y
 │              render 2  x
 │              render 3  y
 └── join       ·         ·
      │         type      cross
      ├── scan  ·         ·
      │         table     twocolumn@primary
      │         spans     ALL
      │         filter    x = 44
      └── scan  ·         ·
·               table     twocolumn@primary
·               spans     ALL

# Check EXPLAIN.
query TTT
EXPLAIN (EXPRS) SELECT * FROM onecolumn AS a JOIN twocolumn AS b ON ((a.x)) = ((b.y))
----
render          ·         ·
 │              render 0  x
 │              render 1  x
 │              render 2  y
 └── join       ·         ·
      │         type      inner
      │         equality  (x) = (y)
      ├── scan  ·         ·
      │         table     onecolumn@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     twocolumn@primary
·               spans     ALL

# Check EXPLAIN.
query TTT
EXPLAIN (EXPRS) SELECT * FROM onecolumn JOIN twocolumn ON onecolumn.x = twocolumn.y
----
render          ·         ·
 │              render 0  x
 │              render 1  x
 │              render 2  y
 └── join       ·         ·
      │         type      inner
      │         equality  (x) = (y)
      ├── scan  ·         ·
      │         table     onecolumn@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     twocolumn@primary
·               spans     ALL


query TTT
EXPLAIN (EXPRS) SELECT * FROM (onecolumn CROSS JOIN twocolumn JOIN onecolumn AS a(b) ON a.b=twocolumn.x JOIN twocolumn AS c(d,e) ON a.b=c.d AND c.d=onecolumn.x) LIMIT 1
----
limit                          ·         ·
 │                             count     1
 └── render                    ·         ·
      │                        render 0  x
      │                        render 1  x
      │                        render 2  y
      │                        render 3  b
      │                        render 4  d
      │                        render 5  e
      └── join                 ·         ·
           │                   type      inner
           │                   equality  (b, x) = (d, d)
           ├── join            ·         ·
           │    │              type      inner
           │    │              equality  (x) = (b)
           │    ├── join       ·         ·
           │    │    │         type      cross
           │    │    ├── scan  ·         ·
           │    │    │         table     onecolumn@primary
           │    │    │         spans     ALL
           │    │    └── scan  ·         ·
           │    │              table     twocolumn@primary
           │    │              spans     ALL
           │    └── scan       ·         ·
           │                   table     onecolumn@primary
           │                   spans     ALL
           └── scan            ·         ·
·                              table     twocolumn@primary
·                              spans     ALL

# Check sub-queries in ON conditions.
query III colnames
SELECT * FROM onecolumn JOIN twocolumn ON twocolumn.x = onecolumn.x AND onecolumn.x IN (SELECT x FROM twocolumn WHERE y >= 52)
----
x    x    y
42   42   53

# Check sub-queries as data sources.
query I colnames
SELECT * FROM onecolumn JOIN (VALUES (41),(42),(43)) AS a(x) USING(x)
----
x
42

query I colnames
SELECT * FROM onecolumn JOIN (SELECT x + 2 AS x FROM onecolumn) USING(x)
----
x
44

# Check that a single column can have multiple table aliases.
query IIII colnames
SELECT * FROM (twocolumn AS a JOIN twocolumn AS b USING(x) JOIN twocolumn AS c USING(x)) ORDER BY x LIMIT 1
----
x  y  y  y
42 53 53 53

query IIIIII colnames
SELECT a.x AS s, b.x, c.x, a.y, b.y, c.y FROM (twocolumn AS a JOIN twocolumn AS b USING(x) JOIN twocolumn AS c USING(x)) ORDER BY s
----
 s   x   x   y   y   y
 42  42  42  53  53  53
 44  44  44  51  51  51
 45  45  45  45  45  45

query error pgcode 42703 column "y" specified in USING clause does not exist
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b USING(y))

query error pgcode 42701 column "x" appears more than once in USING clause
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b USING(x, x))

statement ok
CREATE TABLE othertype (x TEXT)

query error pgcode 42804 JOIN/USING types.*cannot be matched
SELECT * FROM (onecolumn AS a JOIN othertype AS b USING(x))

query error cannot join columns from the same source name "onecolumn"
SELECT * FROM (onecolumn JOIN onecolumn USING(x))

query error cannot join columns from the same source name "onecolumn"
SELECT * FROM (onecolumn JOIN twocolumn USING(x) JOIN onecolumn USING(x))

# Check that star expansion works across anonymous sources.
query II rowsort
SELECT * FROM (SELECT * FROM onecolumn), (SELECT * FROM onecolumn)
----
  42     42
  42     44
  42   NULL
  44     42
  44     44
  44   NULL
NULL     42
NULL     44
NULL   NULL

# Check that anonymous sources are properly looked up without ambiguity.
query I
SELECT x FROM (onecolumn JOIN othercolumn USING (x)) JOIN (onecolumn AS a JOIN othercolumn AS b USING(x)) USING(x)
----
42

# Check that multiple anonymous sources cause proper ambiguity errors.
query error column reference "x" is ambiguous \(candidates: <anonymous>\.x\)
SELECT x FROM (SELECT * FROM onecolumn), (SELECT * FROM onecolumn)

query error column reference "x" is ambiguous \(candidates: a\.x, b\.x\)
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b ON x > 32)

query error column name "a.y" not found
SELECT * FROM (onecolumn AS a JOIN onecolumn AS b ON a.y > y)

statement ok
CREATE TABLE s(x INT); INSERT INTO s(x) VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10)

# THe following queries verify that only the necessary columns are scanned.
query TITTTTT
EXPLAIN (METADATA) SELECT a.x, b.y FROM twocolumn AS a, twocolumn AS b
----
render          0  render  ·      ·                  (x, y)                                                                        ·
 └── join       1  join    ·      ·                  (x, y[omitted], rowid[hidden,omitted], x[omitted], y, rowid[hidden,omitted])  ·
      │         1  ·       type   cross              ·                                                                             ·
      ├── scan  2  scan    ·      ·                  (x, y[omitted], rowid[hidden,omitted])                                        rowid!=NULL; key(rowid)
      │         2  ·       table  twocolumn@primary  ·                                                                             ·
      │         2  ·       spans  ALL                ·                                                                             ·
      └── scan  2  scan    ·      ·                  (x[omitted], y, rowid[hidden,omitted])                                        rowid!=NULL; key(rowid)
·               2  ·       table  twocolumn@primary  ·                                                                             ·
·               2  ·       spans  ALL                ·                                                                             ·

query TITTTTT
EXPLAIN (METADATA) SELECT b.y FROM (twocolumn AS a JOIN twocolumn AS b USING(x))
----
render          0  render  ·         ·                  (y)                                                                                    ·
 └── join       1  join    ·         ·                  (x[omitted], y[omitted], rowid[hidden,omitted], x[omitted], y, rowid[hidden,omitted])  ·
      │         1  ·       type      inner              ·                                                                                      ·
      │         1  ·       equality  (x) = (x)          ·                                                                                      ·
      ├── scan  2  scan    ·         ·                  (x, y[omitted], rowid[hidden,omitted])                                                 rowid!=NULL; key(rowid)
      │         2  ·       table     twocolumn@primary  ·                                                                                      ·
      │         2  ·       spans     ALL                ·                                                                                      ·
      └── scan  2  scan    ·         ·                  (x, y, rowid[hidden,omitted])                                                          rowid!=NULL; key(rowid)
·               2  ·       table     twocolumn@primary  ·                                                                                      ·
·               2  ·       spans     ALL                ·                                                                                      ·

query TITTTTT
EXPLAIN (METADATA) SELECT b.y FROM (twocolumn AS a JOIN twocolumn AS b ON a.x = b.x)
----
render          0  render  ·         ·                  (y)                                                                                    ·
 └── join       1  join    ·         ·                  (x[omitted], y[omitted], rowid[hidden,omitted], x[omitted], y, rowid[hidden,omitted])  ·
      │         1  ·       type      inner              ·                                                                                      ·
      │         1  ·       equality  (x) = (x)          ·                                                                                      ·
      ├── scan  2  scan    ·         ·                  (x, y[omitted], rowid[hidden,omitted])                                                 rowid!=NULL; key(rowid)
      │         2  ·       table     twocolumn@primary  ·                                                                                      ·
      │         2  ·       spans     ALL                ·                                                                                      ·
      └── scan  2  scan    ·         ·                  (x, y, rowid[hidden,omitted])                                                          rowid!=NULL; key(rowid)
·               2  ·       table     twocolumn@primary  ·                                                                                      ·
·               2  ·       spans     ALL                ·                                                                                      ·

query TITTTTT
EXPLAIN (METADATA) SELECT a.x FROM (twocolumn AS a JOIN twocolumn AS b ON a.x < b.y)
----
render          0  render  ·      ·                  (x)                                                                                    ·
 └── join       1  join    ·      ·                  (x, y[omitted], rowid[hidden,omitted], x[omitted], y[omitted], rowid[hidden,omitted])  ·
      │         1  ·       type   inner              ·                                                                                      ·
      ├── scan  2  scan    ·      ·                  (x, y[omitted], rowid[hidden,omitted])                                                 rowid!=NULL; key(rowid)
      │         2  ·       table  twocolumn@primary  ·                                                                                      ·
      │         2  ·       spans  ALL                ·                                                                                      ·
      └── scan  2  scan    ·      ·                  (x[omitted], y, rowid[hidden,omitted])                                                 rowid!=NULL; key(rowid)
·               2  ·       table  twocolumn@primary  ·                                                                                      ·
·               2  ·       spans  ALL                ·                                                                                      ·

# Ensure that the ordering information for the result of joins is sane. (#12037)
query TITTTTT
EXPLAIN (METADATA) SELECT * FROM (SELECT * FROM (VALUES (9, 1), (8, 2)) AS a (u, k) ORDER BY k)
                INNER JOIN (VALUES (1, 1), (2, 2)) AS b (k, w) USING (k) ORDER BY u
----
sort                             0  sort    ·         ·                  (k, u, w)                     +u
 │                               0  ·       order     +u                 ·                             ·
 └── render                      1  render  ·         ·                  (k, u, w)                     ·
      └── render                 2  render  ·         ·                  (k, u, k[hidden,omitted], w)  ·
           └── join              3  join    ·         ·                  (u, k, k[omitted], w)         ·
                │                3  ·       type      inner              ·                             ·
                │                3  ·       equality  (k) = (k)          ·                             ·
                ├── sort         4  sort    ·         ·                  (u, k)                        +k
                │    │           4  ·       order     +k                 ·                             ·
                │    └── values  5  values  ·         ·                  (u, k)                        ·
                │                5  ·       size      2 columns, 2 rows  ·                             ·
                └── values       4  values  ·         ·                  (column1, column2)            ·
·                                4  ·       size      2 columns, 2 rows  ·                             ·

# Ensure that large cross-joins are optimized somehow (#10633)
statement ok
CREATE TABLE customers(id INT PRIMARY KEY NOT NULL); CREATE TABLE orders(id INT, cust INT REFERENCES customers(id))

query ITTT
SELECT "Level", "Type", "Field", "Description" FROM [EXPLAIN (VERBOSE) SELECT
       NULL::text  AS pktable_cat,
       pkn.nspname AS pktable_schem,
       pkc.relname AS pktable_name,
       pka.attname AS pkcolumn_name,
       NULL::text  AS fktable_cat,
       fkn.nspname AS fktable_schem,
       fkc.relname AS fktable_name,
       fka.attname AS fkcolumn_name,
       pos.n       AS key_seq,
       CASE con.confupdtype
            WHEN 'c' THEN 0
            WHEN 'n' THEN 2
            WHEN 'd' THEN 4
            WHEN 'r' THEN 1
            WHEN 'a' THEN 3
            ELSE NULL
       END AS update_rule,
       CASE con.confdeltype
            WHEN 'c' THEN 0
            WHEN 'n' THEN 2
            WHEN 'd' THEN 4
            WHEN 'r' THEN 1
            WHEN 'a' THEN 3
            ELSE NULL
       END          AS delete_rule,
       con.conname  AS fk_name,
       pkic.relname AS pk_name,
       CASE
            WHEN con.condeferrable
            AND      con.condeferred THEN 5
            WHEN con.condeferrable THEN 6
            ELSE 7
       END AS deferrability
  FROM     pg_catalog.pg_namespace pkn,
       pg_catalog.pg_class pkc,
       pg_catalog.pg_attribute pka,
       pg_catalog.pg_namespace fkn,
       pg_catalog.pg_class fkc,
       pg_catalog.pg_attribute fka,
       pg_catalog.pg_constraint con,
       pg_catalog.generate_series(1, 32) pos(n),
       pg_catalog.pg_depend dep,
       pg_catalog.pg_class pkic
  WHERE    pkn.oid = pkc.relnamespace
  AND      pkc.oid = pka.attrelid
  AND      pka.attnum = con.confkey[pos.n]
  AND      con.confrelid = pkc.oid
  AND      fkn.oid = fkc.relnamespace
  AND      fkc.oid = fka.attrelid
  AND      fka.attnum = con.conkey[pos.n]
  AND      con.conrelid = fkc.oid
  AND      con.contype = 'f'
  AND      con.oid = dep.objid
  AND      pkic.oid = dep.refobjid
  AND      pkic.relkind = 'i'
  AND      dep.classid = 'pg_constraint'::regclass::oid
  AND      dep.refclassid = 'pg_class'::regclass::oid
  AND      fkn.nspname = 'public'
  AND      fkc.relname = 'orders'
  ORDER BY pkn.nspname,
           pkc.relname,
           con.conname,
           pos.n
  ] WHERE "Type" <> 'values' AND "Field" <> 'size'
----
0   sort       ·          ·
0   ·          order      +pktable_schem,+pktable_name,+fk_name,+key_seq
1   render     ·          ·
1   ·          render 0   NULL
1   ·          render 1   pkn.nspname
1   ·          render 2   pkc.relname
1   ·          render 3   pka.attname
1   ·          render 4   NULL
1   ·          render 5   fkn.nspname
1   ·          render 6   fkc.relname
1   ·          render 7   fka.attname
1   ·          render 8   pos.n
1   ·          render 9   CASE con.confupdtype WHEN 'c' THEN 0 WHEN 'n' THEN 2 WHEN 'd' THEN 4 WHEN 'r' THEN 1 WHEN 'a' THEN 3 ELSE NULL END
1   ·          render 10  CASE con.confdeltype WHEN 'c' THEN 0 WHEN 'n' THEN 2 WHEN 'd' THEN 4 WHEN 'r' THEN 1 WHEN 'a' THEN 3 ELSE NULL END
1   ·          render 11  con.conname
1   ·          render 12  pkic.relname
1   ·          render 13  CASE WHEN con.condeferrable AND con.condeferred THEN 5 WHEN con.condeferrable THEN 6 ELSE 7 END
2   join       ·          ·
2   ·          type       inner
2   ·          equality   (oid) = (relnamespace)
3   join       ·          ·
3   ·          type       inner
3   ·          equality   (oid, oid) = (attrelid, confrelid)
4   join       ·          ·
4   ·          type       inner
4   ·          pred       pka.attnum = con.confkey[pos.n]
5   join       ·          ·
5   ·          type       inner
5   ·          equality   (oid) = (relnamespace)
6   filter     ·          ·
6   ·          filter     fkn.nspname = 'public'
6   join       ·          ·
6   ·          type       inner
6   ·          equality   (oid, oid) = (attrelid, conrelid)
7   filter     ·          ·
7   ·          filter     fkc.relname = 'orders'
7   join       ·          ·
7   ·          type       inner
7   ·          pred       fka.attnum = con.conkey[pos.n]
8   join       ·          ·
8   ·          type       inner
8   ·          equality   (oid) = (objid)
9   filter     ·          ·
9   ·          filter     con.contype = 'f'
9   join       ·          ·
9   ·          type       cross
10  generator  ·          ·
10  ·          expr       generate_series(1, 32)
10  join       ·          ·
10  ·          type       inner
10  ·          equality   (refobjid) = (oid)
11  filter     ·          ·
11  ·          filter     (dep.classid = 4061301040) AND (dep.refclassid = 2431470471)
11  filter     ·          ·
11  ·          filter     pkic.relkind = 'i'

query TTTTTTTTIIITTI
SELECT     NULL::text  AS pktable_cat,
       pkn.nspname AS pktable_schem,
       pkc.relname AS pktable_name,
       pka.attname AS pkcolumn_name,
       NULL::text  AS fktable_cat,
       fkn.nspname AS fktable_schem,
       fkc.relname AS fktable_name,
       fka.attname AS fkcolumn_name,
       pos.n       AS key_seq,
       CASE con.confupdtype
            WHEN 'c' THEN 0
            WHEN 'n' THEN 2
            WHEN 'd' THEN 4
            WHEN 'r' THEN 1
            WHEN 'a' THEN 3
            ELSE NULL
       END AS update_rule,
       CASE con.confdeltype
            WHEN 'c' THEN 0
            WHEN 'n' THEN 2
            WHEN 'd' THEN 4
            WHEN 'r' THEN 1
            WHEN 'a' THEN 3
            ELSE NULL
       END          AS delete_rule,
       con.conname  AS fk_name,
       pkic.relname AS pk_name,
       CASE
            WHEN con.condeferrable
            AND      con.condeferred THEN 5
            WHEN con.condeferrable THEN 6
            ELSE 7
       END AS deferrability
  FROM     pg_catalog.pg_namespace pkn,
       pg_catalog.pg_class pkc,
       pg_catalog.pg_attribute pka,
       pg_catalog.pg_namespace fkn,
       pg_catalog.pg_class fkc,
       pg_catalog.pg_attribute fka,
       pg_catalog.pg_constraint con,
       pg_catalog.generate_series(1, 32) pos(n),
       pg_catalog.pg_depend dep,
       pg_catalog.pg_class pkic
  WHERE    pkn.oid = pkc.relnamespace
  AND      pkc.oid = pka.attrelid
  AND      pka.attnum = con.confkey[pos.n]
  AND      con.confrelid = pkc.oid
  AND      fkn.oid = fkc.relnamespace
  AND      fkc.oid = fka.attrelid
  AND      fka.attnum = con.conkey[pos.n]
  AND      con.conrelid = fkc.oid
  AND      con.contype = 'f'
  AND      con.oid = dep.objid
  AND      pkic.oid = dep.refobjid
  AND      pkic.relkind = 'i'
  AND      dep.classid = 'pg_constraint'::regclass::oid
  AND      dep.refclassid = 'pg_class'::regclass::oid
  AND      fkn.nspname = 'public'
  AND      fkc.relname = 'orders'
  ORDER BY pkn.nspname,
       pkc.relname,
       con.conname,
       pos.n
----
NULL  public  customers  id  NULL  public  orders  cust  1  3  3  fk_cust_ref_customers  primary  7


# Tests for filter propagation through joins.

statement ok
CREATE TABLE square (n INT PRIMARY KEY, sq INT)

statement ok
INSERT INTO square VALUES (1,1), (2,4), (3,9), (4,16), (5,25), (6,36)

statement ok
CREATE TABLE pairs (a INT, b INT)

statement ok
INSERT INTO pairs VALUES (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (2,3), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6), (4,5), (4,6)

# The filter expression becomes an equality constraint.
query TTT
EXPLAIN SELECT * FROM pairs, square WHERE pairs.b = square.n
----
render          ·         ·
 └── join       ·         ·
      │         type      inner
      │         equality  (b) = (n)
      ├── scan  ·         ·
      │         table     pairs@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     square@primary
·               spans     ALL

query IIII rowsort
SELECT * FROM pairs, square WHERE pairs.b = square.n
----
1  1  1  1
1  2  2  4
1  3  3  9
1  4  4  16
1  5  5  25
1  6  6  36
2  3  3  9
2  4  4  16
2  5  5  25
2  6  6  36
3  4  4  16
3  5  5  25
3  6  6  36
4  5  5  25
4  6  6  36

# The filter expression becomes an ON predicate.
query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pairs, square WHERE pairs.a + pairs.b = square.sq
----
render          0  render  ·         ·                                                                    (a, b, n, sq)                         ·
 │              0  ·       render 0  test.public.pairs.a                                                  ·                                     ·
 │              0  ·       render 1  test.public.pairs.b                                                  ·                                     ·
 │              0  ·       render 2  test.public.square.n                                                 ·                                     ·
 │              0  ·       render 3  test.public.square.sq                                                ·                                     ·
 └── join       1  join    ·         ·                                                                    (a, b, rowid[hidden,omitted], n, sq)  ·
      │         1  ·       type      inner                                                                ·                                     ·
      │         1  ·       pred      (test.public.pairs.a + test.public.pairs.b) = test.public.square.sq  ·                                     ·
      ├── scan  2  scan    ·         ·                                                                    (a, b, rowid[hidden,omitted])         rowid!=NULL; key(rowid)
      │         2  ·       table     pairs@primary                                                        ·                                     ·
      │         2  ·       spans     ALL                                                                  ·                                     ·
      └── scan  2  scan    ·         ·                                                                    (n, sq)                               n!=NULL; key(n)
·               2  ·       table     square@primary                                                       ·                                     ·
·               2  ·       spans     ALL                                                                  ·                                     ·

query IIII rowsort
SELECT * FROM pairs, square WHERE pairs.a + pairs.b = square.sq
----
1  3  2  4
3  6  3  9
4  5  3  9

# Query similar to the one above, but the filter refers to a rendered
# expression and can't "break through". See the comment for propagateFilters
# in fitler_opt.go for all the details.
query TITTTTT
EXPLAIN (VERBOSE) SELECT a, b, n, sq FROM (SELECT a, b, a + b AS sum, n, sq FROM pairs, square) WHERE sum = sq
----
render                    0  render  ·         ·                                          (a, b, n, sq)                         sq!=NULL
 │                        0  ·       render 0  a                                          ·                                     ·
 │                        0  ·       render 1  b                                          ·                                     ·
 │                        0  ·       render 2  n                                          ·                                     ·
 │                        0  ·       render 3  sq                                         ·                                     ·
 └── filter               1  filter  ·         ·                                          (a, b, sum, n, sq)                    sum=sq; sum!=NULL; sq!=NULL
      │                   1  ·       filter    sum = sq                                   ·                                     ·
      └── render          2  render  ·         ·                                          (a, b, sum, n, sq)                    ·
           │              2  ·       render 0  test.public.pairs.a                        ·                                     ·
           │              2  ·       render 1  test.public.pairs.b                        ·                                     ·
           │              2  ·       render 2  test.public.pairs.a + test.public.pairs.b  ·                                     ·
           │              2  ·       render 3  test.public.square.n                       ·                                     ·
           │              2  ·       render 4  test.public.square.sq                      ·                                     ·
           └── join       3  join    ·         ·                                          (a, b, rowid[hidden,omitted], n, sq)  ·
                │         3  ·       type      cross                                      ·                                     ·
                ├── scan  4  scan    ·         ·                                          (a, b, rowid[hidden,omitted])         rowid!=NULL; key(rowid)
                │         4  ·       table     pairs@primary                              ·                                     ·
                │         4  ·       spans     ALL                                        ·                                     ·
                └── scan  4  scan    ·         ·                                          (n, sq)                               n!=NULL; key(n)
·                         4  ·       table     square@primary                             ·                                     ·
·                         4  ·       spans     ALL                                        ·                                     ·

query IIII rowsort
SELECT a, b, n, sq FROM (SELECT a, b, a + b AS sum, n, sq FROM pairs, square) WHERE sum = sq
----
1  3  2  4
3  6  3  9
4  5  3  9

# The filter expression must stay on top of the outer join.
query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq
----
render          0  render  ·         ·                                                                    (a, b, n, sq)                         ·
 │              0  ·       render 0  test.public.pairs.a                                                  ·                                     ·
 │              0  ·       render 1  test.public.pairs.b                                                  ·                                     ·
 │              0  ·       render 2  test.public.square.n                                                 ·                                     ·
 │              0  ·       render 3  test.public.square.sq                                                ·                                     ·
 └── join       1  join    ·         ·                                                                    (a, b, rowid[hidden,omitted], n, sq)  ·
      │         1  ·       type      full outer                                                           ·                                     ·
      │         1  ·       pred      (test.public.pairs.a + test.public.pairs.b) = test.public.square.sq  ·                                     ·
      ├── scan  2  scan    ·         ·                                                                    (a, b, rowid[hidden,omitted])         rowid!=NULL; key(rowid)
      │         2  ·       table     pairs@primary                                                        ·                                     ·
      │         2  ·       spans     ALL                                                                  ·                                     ·
      └── scan  2  scan    ·         ·                                                                    (n, sq)                               n!=NULL; key(n)
·               2  ·       table     square@primary                                                       ·                                     ·
·               2  ·       spans     ALL                                                                  ·                                     ·

query IIII rowsort
SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq
----
1     1     NULL  NULL
1     2     NULL  NULL
1     3     2     4
1     4     NULL  NULL
1     5     NULL  NULL
1     6     NULL  NULL
2     3     NULL  NULL
2     4     NULL  NULL
2     5     NULL  NULL
2     6     NULL  NULL
3     4     NULL  NULL
3     5     NULL  NULL
3     6     3     9
4     5     3     9
4     6     NULL  NULL
NULL  NULL  1     1
NULL  NULL  4     16
NULL  NULL  5     25
NULL  NULL  6     36

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq WHERE pairs.b%2 <> square.sq%2
----
render               0  render  ·         ·                                                                    (a, b, n, sq)                         b!=NULL; sq!=NULL
 │                   0  ·       render 0  test.public.pairs.a                                                  ·                                     ·
 │                   0  ·       render 1  test.public.pairs.b                                                  ·                                     ·
 │                   0  ·       render 2  test.public.square.n                                                 ·                                     ·
 │                   0  ·       render 3  test.public.square.sq                                                ·                                     ·
 └── filter          1  filter  ·         ·                                                                    (a, b, rowid[hidden,omitted], n, sq)  b!=NULL; sq!=NULL
      │              1  ·       filter    (test.public.pairs.b % 2) != (test.public.square.sq % 2)             ·                                     ·
      └── join       2  join    ·         ·                                                                    (a, b, rowid[hidden,omitted], n, sq)  ·
           │         2  ·       type      full outer                                                           ·                                     ·
           │         2  ·       pred      (test.public.pairs.a + test.public.pairs.b) = test.public.square.sq  ·                                     ·
           ├── scan  3  scan    ·         ·                                                                    (a, b, rowid[hidden,omitted])         rowid!=NULL; key(rowid)
           │         3  ·       table     pairs@primary                                                        ·                                     ·
           │         3  ·       spans     ALL                                                                  ·                                     ·
           └── scan  3  scan    ·         ·                                                                    (n, sq)                               n!=NULL; key(n)
·                    3  ·       table     square@primary                                                       ·                                     ·
·                    3  ·       spans     ALL                                                                  ·                                     ·

query IIII rowsort
SELECT * FROM pairs FULL OUTER JOIN square ON pairs.a + pairs.b = square.sq WHERE pairs.b%2 <> square.sq%2
----
1     3     2     4
3     6     3     9

# Filter propagation through outer joins.

query IIII rowsort
SELECT *
  FROM (SELECT * FROM pairs LEFT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE b > 1 AND (n IS NULL OR n > 1) AND (n IS NULL OR a  < sq)
----
1  2  NULL  NULL
1  3  NULL  NULL
1  4  NULL  NULL
1  5  NULL  NULL
1  6  NULL  NULL
2  3  NULL  NULL
2  4  2     4
2  5  NULL  NULL
2  6  NULL  NULL
3  4  2     4
3  5  NULL  NULL
3  6  NULL  NULL
4  5  NULL  NULL
4  6  NULL  NULL

query TTT
EXPLAIN(EXPRS)
SELECT *
  FROM (SELECT * FROM pairs LEFT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE b > 1 AND (n IS NULL OR n > 1) AND (n IS NULL OR a  < sq)
----
render               ·         ·
 │                   render 0  a
 │                   render 1  b
 │                   render 2  n
 │                   render 3  sq
 └── filter          ·         ·
      │              filter    ((n IS NULL) OR (n > 1)) AND ((n IS NULL) OR (a < sq))
      └── join       ·         ·
           │         type      left outer
           │         equality  (b) = (sq)
           │         pred      test.public.pairs.a > 1
           ├── scan  ·         ·
           │         table     pairs@primary
           │         spans     ALL
           │         filter    b > 1
           └── scan  ·         ·
·                    table     square@primary
·                    spans     -/5/#
·                    filter    sq > 1

query IIII rowsort
SELECT *
  FROM (SELECT * FROM pairs RIGHT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE (a IS NULL OR a > 2) AND n > 1 AND (a IS NULL OR a < sq)
----
3     4     2  4
NULL  NULL  3  9
NULL  NULL  4  16
NULL  NULL  5  25
NULL  NULL  6  36

query TTT
EXPLAIN(EXPRS)
SELECT *
  FROM (SELECT * FROM pairs RIGHT JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE (a IS NULL OR a > 2) AND n > 1 AND (a IS NULL OR a < sq)
----
render               ·         ·
 │                   render 0  a
 │                   render 1  b
 │                   render 2  n
 │                   render 3  sq
 └── filter          ·         ·
      │              filter    ((a IS NULL) OR (a > 2)) AND ((a IS NULL) OR (a < sq))
      └── join       ·         ·
           │         type      right outer
           │         equality  (b) = (sq)
           │         pred      test.public.square.n < 6
           ├── scan  ·         ·
           │         table     pairs@primary
           │         spans     ALL
           │         filter    a > 1
           └── scan  ·         ·
·                    table     square@primary
·                    spans     /2-

# The simpler plan for an inner join, to compare.
query TTT
EXPLAIN(EXPRS)
SELECT *
  FROM (SELECT * FROM pairs JOIN square ON b = sq AND a > 1 AND n < 6)
 WHERE (a IS NULL OR a > 2) AND n > 1 AND (a IS NULL OR a < sq)
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  n
 │              render 3  sq
 └── join       ·         ·
      │         type      inner
      │         equality  (b) = (sq)
      ├── scan  ·         ·
      │         table     pairs@primary
      │         spans     ALL
      │         filter    ((a > 1) AND ((a IS NULL) OR (a > 2))) AND ((a IS NULL) OR (a < b))
      └── scan  ·         ·
·               table     square@primary
·               spans     /2-/5/#


statement ok
CREATE TABLE t1 (col1 INT, x INT, col2 INT, y INT)

statement ok
CREATE TABLE t2 (col3 INT, y INT, x INT, col4 INT)

statement ok
INSERT INTO t1 VALUES (10, 1, 11, 1), (20, 2, 21, 1), (30, 3, 31, 1)

statement ok
INSERT INTO t2 VALUES (100, 1, 1, 101), (200, 1, 201, 2), (400, 1, 401, 4)

query IIIIIII
SELECT * FROM t1 JOIN t2 USING(x)
----
1    10    11    1    100    1    101

query IIIIII
SELECT * FROM t1 NATURAL JOIN t2
----
1    1    10    11    100    101

query IIIIIIII
SELECT * FROM t1 JOIN t2 ON t2.x=t1.x
----
10    1    11    1    100    1    1    101

query IIIIIII rowsort
SELECT * FROM t1 FULL OUTER JOIN t2 USING(x)
----
   1      10      11       1     100       1     101
   2      20      21       1    NULL    NULL    NULL
   3      30      31       1    NULL    NULL    NULL
 201    NULL    NULL    NULL     200       1       2
 401    NULL    NULL    NULL     400       1       4

query IIIIII rowsort
SELECT * FROM t1 NATURAL FULL OUTER JOIN t2
----
  1    1      10      11     100     101
  2    1      20      21    NULL    NULL
  3    1      30      31    NULL    NULL
201    1    NULL    NULL     200       2
401    1    NULL    NULL     400       4

query IIIIIIII rowsort
SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.x=t2.x
----
  10       1      11       1     100       1       1     101
  20       2      21       1    NULL    NULL    NULL    NULL
  30       3      31       1    NULL    NULL    NULL    NULL
NULL    NULL    NULL    NULL     200       1     201       2
NULL    NULL    NULL    NULL     400       1     401       4

query III
SELECT t2.x, t1.x, x FROM t1 JOIN t2 USING(x)
----
1    1    1

query III rowsort
SELECT t2.x, t1.x, x FROM t1 FULL OUTER JOIN t2 USING(x)
----
   1       1      1
NULL       2      2
NULL       3      3
 201    NULL    201
 401    NULL    401

# Test for #19536.
query I
SELECT x FROM t1 NATURAL JOIN (SELECT * FROM t2)
----
1

query TITTTTT
EXPLAIN (VERBOSE) SELECT x FROM t1 NATURAL JOIN (SELECT * FROM t2)
----
render                    0  render  ·         ·                 (x)                                                                                                                                       ·
 │                        0  ·       render 0  test.public.t1.x  ·                                                                                                                                         ·
 └── render               1  render  ·         ·                 (x, y[omitted], col1[omitted], col2[omitted], rowid[hidden,omitted], col3[omitted], y[hidden,omitted], x[hidden,omitted], col4[omitted])  ·
      │                   1  ·       render 0  test.public.t1.x  ·                                                                                                                                         ·
      │                   1  ·       render 1  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 2  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 3  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 4  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 5  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 6  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 7  NULL              ·                                                                                                                                         ·
      │                   1  ·       render 8  NULL              ·                                                                                                                                         ·
      └── join            2  join    ·         ·                 (col1[omitted], x, col2[omitted], y[omitted], rowid[hidden,omitted], col3[omitted], y[omitted], x[omitted], col4[omitted])                ·
           │              2  ·       type      inner             ·                                                                                                                                         ·
           │              2  ·       equality  (x, y) = (x, y)   ·                                                                                                                                         ·
           ├── scan       3  scan    ·         ·                 (col1[omitted], x, col2[omitted], y, rowid[hidden,omitted])                                                                               rowid!=NULL; key(rowid)
           │              3  ·       table     t1@primary        ·                                                                                                                                         ·
           │              3  ·       spans     ALL               ·                                                                                                                                         ·
           └── render     3  render  ·         ·                 (col3[omitted], y, x, col4[omitted])                                                                                                      ·
                │         3  ·       render 0  NULL              ·                                                                                                                                         ·
                │         3  ·       render 1  test.public.t2.y  ·                                                                                                                                         ·
                │         3  ·       render 2  test.public.t2.x  ·                                                                                                                                         ·
                │         3  ·       render 3  NULL              ·                                                                                                                                         ·
                └── scan  4  scan    ·         ·                 (col3[omitted], y, x, col4[omitted], rowid[hidden,omitted])                                                                               rowid!=NULL; key(rowid)
·                         4  ·       table     t2@primary        ·                                                                                                                                         ·
·                         4  ·       spans     ALL               ·                                                                                                                                         ·

# Tests for merge join ordering information.
statement ok
CREATE TABLE pkBA (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a))

statement ok
CREATE TABLE pkBC (a INT, b INT, c INT, d INT, PRIMARY KEY(b,c))

statement ok
CREATE TABLE pkBAC (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a,c))

statement ok
CREATE TABLE pkBAD (a INT, b INT, c INT, d INT, PRIMARY KEY(b,a,d))

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pkBA AS l JOIN pkBC AS r ON l.a = r.a AND l.b = r.b AND l.c = r.c
----
join       0  join  ·               ·                      (a, b, c, d, a, b, c, d)  a=a; b=b; c=c; a!=NULL; b!=NULL; c!=NULL; key(a,b); key(b,c)
 │         0  ·     type            inner                  ·                         ·
 │         0  ·     equality        (a, b, c) = (a, b, c)  ·                         ·
 │         0  ·     mergeJoinOrder  +"(b=b)"               ·                         ·
 ├── scan  1  scan  ·               ·                      (a, b, c, d)              a!=NULL; b!=NULL; key(a,b); +b
 │         1  ·     table           pkba@primary           ·                         ·
 │         1  ·     spans           ALL                    ·                         ·
 └── scan  1  scan  ·               ·                      (a, b, c, d)              b!=NULL; c!=NULL; key(b,c); +b
·          1  ·     table           pkbc@primary           ·                         ·
·          1  ·     spans           ALL                    ·                         ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pkBA NATURAL JOIN pkBAD
----
render          0  render  ·               ·                            (a, b, c, d)                                                  a!=NULL; b!=NULL; c!=NULL; d!=NULL; key(a,b)
 │              0  ·       render 0        test.public.pkba.a           ·                                                             ·
 │              0  ·       render 1        test.public.pkba.b           ·                                                             ·
 │              0  ·       render 2        test.public.pkba.c           ·                                                             ·
 │              0  ·       render 3        test.public.pkba.d           ·                                                             ·
 └── join       1  join    ·               ·                            (a, b, c, d, a[omitted], b[omitted], c[omitted], d[omitted])  a=a; b=b; c=c; d=d; a!=NULL; b!=NULL; c!=NULL; d!=NULL; key(a,b)
      │         1  ·       type            inner                        ·                                                             ·
      │         1  ·       equality        (a, b, c, d) = (a, b, c, d)  ·                                                             ·
      │         1  ·       mergeJoinOrder  +"(b=b)",+"(a=a)",+"(d=d)"   ·                                                             ·
      ├── scan  2  scan    ·               ·                            (a, b, c, d)                                                  a!=NULL; b!=NULL; key(a,b); +b,+a
      │         2  ·       table           pkba@primary                 ·                                                             ·
      │         2  ·       spans           ALL                          ·                                                             ·
      └── scan  2  scan    ·               ·                            (a, b, c, d)                                                  a!=NULL; b!=NULL; d!=NULL; key(a,b,d); +b,+a,+d
·               2  ·       table           pkbad@primary                ·                                                             ·
·               2  ·       spans           ALL                          ·                                                             ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pkBAC AS l JOIN pkBAC AS r USING(a, b, c)
----
render          0  render  ·               ·                           (a, b, c, d, d)                                      a!=NULL; b!=NULL; c!=NULL; key(a,b,c)
 │              0  ·       render 0        l.a                         ·                                                    ·
 │              0  ·       render 1        l.b                         ·                                                    ·
 │              0  ·       render 2        l.c                         ·                                                    ·
 │              0  ·       render 3        l.d                         ·                                                    ·
 │              0  ·       render 4        r.d                         ·                                                    ·
 └── join       1  join    ·               ·                           (a, b, c, d, a[omitted], b[omitted], c[omitted], d)  a=a; b=b; c=c; a!=NULL; b!=NULL; c!=NULL; key(a,b,c)
      │         1  ·       type            inner                       ·                                                    ·
      │         1  ·       equality        (a, b, c) = (a, b, c)       ·                                                    ·
      │         1  ·       mergeJoinOrder  +"(b=b)",+"(a=a)",+"(c=c)"  ·                                                    ·
      ├── scan  2  scan    ·               ·                           (a, b, c, d)                                         a!=NULL; b!=NULL; c!=NULL; key(a,b,c); +b,+a,+c
      │         2  ·       table           pkbac@primary               ·                                                    ·
      │         2  ·       spans           ALL                         ·                                                    ·
      └── scan  2  scan    ·               ·                           (a, b, c, d)                                         a!=NULL; b!=NULL; c!=NULL; key(a,b,c); +b,+a,+c
·               2  ·       table           pkbac@primary               ·                                                    ·
·               2  ·       spans           ALL                         ·                                                    ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM pkBAC AS l JOIN pkBAD AS r ON l.c = r.d AND l.a = r.a AND l.b = r.b
----
join       0  join  ·               ·                           (a, b, c, d, a, b, c, d)  a=a; b=b; c=d; a!=NULL; b!=NULL; c!=NULL; key(a,b,c)
 │         0  ·     type            inner                       ·                         ·
 │         0  ·     equality        (c, a, b) = (d, a, b)       ·                         ·
 │         0  ·     mergeJoinOrder  +"(b=b)",+"(a=a)",+"(c=d)"  ·                         ·
 ├── scan  1  scan  ·               ·                           (a, b, c, d)              a!=NULL; b!=NULL; c!=NULL; key(a,b,c); +b,+a,+c
 │         1  ·     table           pkbac@primary               ·                         ·
 │         1  ·     spans           ALL                         ·                         ·
 └── scan  1  scan  ·               ·                           (a, b, c, d)              a!=NULL; b!=NULL; d!=NULL; key(a,b,d); +b,+a,+d
·          1  ·     table           pkbad@primary               ·                         ·
·          1  ·     spans           ALL                         ·                         ·

# Tests with joins with merged columns of collated string type.
statement ok
CREATE TABLE str1 (a INT PRIMARY KEY, s STRING COLLATE en_u_ks_level1)

statement ok
INSERT INTO str1 VALUES (1, 'a' COLLATE en_u_ks_level1), (2, 'A' COLLATE en_u_ks_level1), (3, 'c' COLLATE en_u_ks_level1), (4, 'D' COLLATE en_u_ks_level1)

statement ok
CREATE TABLE str2 (a INT PRIMARY KEY, s STRING COLLATE en_u_ks_level1)

statement ok
INSERT INTO str2 VALUES (1, 'A' COLLATE en_u_ks_level1), (2, 'B' COLLATE en_u_ks_level1), (3, 'C' COLLATE en_u_ks_level1), (4, 'E' COLLATE en_u_ks_level1)

query TITTTTT
EXPLAIN (VERBOSE) SELECT s, str1.s, str2.s FROM str1 INNER JOIN str2 USING(s)
----
render               0  render  ·         ·                   (s, s, s)                               s=s
 │                   0  ·       render 0  test.public.str1.s  ·                                       ·
 │                   0  ·       render 1  test.public.str1.s  ·                                       ·
 │                   0  ·       render 2  test.public.str2.s  ·                                       ·
 └── render          1  render  ·         ·                   (s, a[omitted], a[omitted], s[hidden])  ·
      │              1  ·       render 0  test.public.str1.s  ·                                       ·
      │              1  ·       render 1  NULL                ·                                       ·
      │              1  ·       render 2  NULL                ·                                       ·
      │              1  ·       render 3  test.public.str2.s  ·                                       ·
      └── join       2  join    ·         ·                   (a[omitted], s, a[omitted], s)          ·
           │         2  ·       type      inner               ·                                       ·
           │         2  ·       equality  (s) = (s)           ·                                       ·
           ├── scan  3  scan    ·         ·                   (a[omitted], s)                         a!=NULL; key(a)
           │         3  ·       table     str1@primary        ·                                       ·
           │         3  ·       spans     ALL                 ·                                       ·
           └── scan  3  scan    ·         ·                   (a[omitted], s)                         a!=NULL; key(a)
·                    3  ·       table     str2@primary        ·                                       ·
·                    3  ·       spans     ALL                 ·                                       ·

query TTT rowsort
SELECT s, str1.s, str2.s FROM str1 INNER JOIN str2 USING(s)
----
a  a  A
A  A  A
c  c  C

query TITTTTT
EXPLAIN (VERBOSE) SELECT s, str1.s, str2.s FROM str1 LEFT OUTER JOIN str2 USING(s)
----
render               0  render  ·         ·                   (s, s, s)                               s=s
 │                   0  ·       render 0  test.public.str1.s  ·                                       ·
 │                   0  ·       render 1  test.public.str1.s  ·                                       ·
 │                   0  ·       render 2  test.public.str2.s  ·                                       ·
 └── render          1  render  ·         ·                   (s, a[omitted], a[omitted], s[hidden])  ·
      │              1  ·       render 0  test.public.str1.s  ·                                       ·
      │              1  ·       render 1  NULL                ·                                       ·
      │              1  ·       render 2  NULL                ·                                       ·
      │              1  ·       render 3  test.public.str2.s  ·                                       ·
      └── join       2  join    ·         ·                   (a[omitted], s, a[omitted], s)          ·
           │         2  ·       type      left outer          ·                                       ·
           │         2  ·       equality  (s) = (s)           ·                                       ·
           ├── scan  3  scan    ·         ·                   (a[omitted], s)                         a!=NULL; key(a)
           │         3  ·       table     str1@primary        ·                                       ·
           │         3  ·       spans     ALL                 ·                                       ·
           └── scan  3  scan    ·         ·                   (a[omitted], s)                         a!=NULL; key(a)
·                    3  ·       table     str2@primary        ·                                       ·
·                    3  ·       spans     ALL                 ·                                       ·

query TTT rowsort
SELECT s, str1.s, str2.s FROM str1 LEFT OUTER JOIN str2 USING(s)
----
a  a  A
A  A  A
c  c  C
D  D  NULL

query TITTTTT
EXPLAIN (VERBOSE) SELECT s, str1.s, str2.s FROM str1 RIGHT OUTER JOIN str2 USING(s)
----
render               0  render  ·         ·                                               (s, s, s)                                          ·
 │                   0  ·       render 0  s                                               ·                                                  ·
 │                   0  ·       render 1  test.public.str1.s                              ·                                                  ·
 │                   0  ·       render 2  test.public.str2.s                              ·                                                  ·
 └── render          1  render  ·         ·                                               (s, a[omitted], s[hidden], a[omitted], s[hidden])  ·
      │              1  ·       render 0  IFNULL(test.public.str1.s, test.public.str2.s)  ·                                                  ·
      │              1  ·       render 1  NULL                                            ·                                                  ·
      │              1  ·       render 2  test.public.str1.s                              ·                                                  ·
      │              1  ·       render 3  NULL                                            ·                                                  ·
      │              1  ·       render 4  test.public.str2.s                              ·                                                  ·
      └── join       2  join    ·         ·                                               (a[omitted], s, a[omitted], s)                     ·
           │         2  ·       type      right outer                                     ·                                                  ·
           │         2  ·       equality  (s) = (s)                                       ·                                                  ·
           ├── scan  3  scan    ·         ·                                               (a[omitted], s)                                    a!=NULL; key(a)
           │         3  ·       table     str1@primary                                    ·                                                  ·
           │         3  ·       spans     ALL                                             ·                                                  ·
           └── scan  3  scan    ·         ·                                               (a[omitted], s)                                    a!=NULL; key(a)
·                    3  ·       table     str2@primary                                    ·                                                  ·
·                    3  ·       spans     ALL                                             ·                                                  ·


query TTT rowsort
SELECT s, str1.s, str2.s FROM str1 RIGHT OUTER JOIN str2 USING(s)
----
a  a     A
A  A     A
c  c     C
B  NULL  B
E  NULL  E

query TITTTTT
EXPLAIN (VERBOSE) SELECT s, str1.s, str2.s FROM str1 FULL OUTER JOIN str2 USING(s)
----
render               0  render  ·         ·                                               (s, s, s)                                          ·
 │                   0  ·       render 0  s                                               ·                                                  ·
 │                   0  ·       render 1  test.public.str1.s                              ·                                                  ·
 │                   0  ·       render 2  test.public.str2.s                              ·                                                  ·
 └── render          1  render  ·         ·                                               (s, a[omitted], s[hidden], a[omitted], s[hidden])  ·
      │              1  ·       render 0  IFNULL(test.public.str1.s, test.public.str2.s)  ·                                                  ·
      │              1  ·       render 1  NULL                                            ·                                                  ·
      │              1  ·       render 2  test.public.str1.s                              ·                                                  ·
      │              1  ·       render 3  NULL                                            ·                                                  ·
      │              1  ·       render 4  test.public.str2.s                              ·                                                  ·
      └── join       2  join    ·         ·                                               (a[omitted], s, a[omitted], s)                     ·
           │         2  ·       type      full outer                                      ·                                                  ·
           │         2  ·       equality  (s) = (s)                                       ·                                                  ·
           ├── scan  3  scan    ·         ·                                               (a[omitted], s)                                    a!=NULL; key(a)
           │         3  ·       table     str1@primary                                    ·                                                  ·
           │         3  ·       spans     ALL                                             ·                                                  ·
           └── scan  3  scan    ·         ·                                               (a[omitted], s)                                    a!=NULL; key(a)
·                    3  ·       table     str2@primary                                    ·                                                  ·
·                    3  ·       spans     ALL                                             ·                                                  ·

query TTT rowsort
SELECT s, str1.s, str2.s FROM str1 FULL OUTER JOIN str2 USING(s)
----
a  a     A
A  A     A
c  c     C
D  D     NULL
E  NULL  E
B  NULL  B

# Verify that we resolve the merged column a to str2.a but use IFNULL for
# column s which is a collated string.
query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM str1 RIGHT OUTER JOIN str2 USING(a, s)
----
render               0  render  ·               ·                                               (a, s)                                                           ·
 │                   0  ·       render 0        test.public.str2.a                              ·                                                                ·
 │                   0  ·       render 1        s                                               ·                                                                ·
 └── render          1  render  ·               ·                                               (a, s, a[hidden,omitted], s[hidden,omitted], s[hidden,omitted])  ·
      │              1  ·       render 0        test.public.str2.a                              ·                                                                ·
      │              1  ·       render 1        IFNULL(test.public.str1.s, test.public.str2.s)  ·                                                                ·
      │              1  ·       render 2        NULL                                            ·                                                                ·
      │              1  ·       render 3        NULL                                            ·                                                                ·
      │              1  ·       render 4        NULL                                            ·                                                                ·
      └── join       2  join    ·               ·                                               (a[omitted], s, a, s)                                            ·
           │         2  ·       type            right outer                                     ·                                                                ·
           │         2  ·       equality        (a, s) = (a, s)                                 ·                                                                ·
           │         2  ·       mergeJoinOrder  +"(a=a)"                                        ·                                                                ·
           ├── scan  3  scan    ·               ·                                               (a, s)                                                           a!=NULL; key(a); +a
           │         3  ·       table           str1@primary                                    ·                                                                ·
           │         3  ·       spans           ALL                                             ·                                                                ·
           └── scan  3  scan    ·               ·                                               (a, s)                                                           a!=NULL; key(a); +a
·                    3  ·       table           str2@primary                                    ·                                                                ·
·                    3  ·       spans           ALL                                             ·                                                                ·


statement ok
CREATE TABLE xyu (x INT, y INT, u INT, PRIMARY KEY(x,y,u))

statement ok
INSERT INTO xyu VALUES (0, 0, 0), (1, 1, 1), (3, 1, 31), (3, 2, 32), (4, 4, 44)

statement ok
CREATE TABLE xyv (x INT, y INT, v INT, PRIMARY KEY(x,y,v))

statement ok
INSERT INTO xyv VALUES (1, 1, 1), (2, 2, 2), (3, 1, 31), (3, 3, 33), (5, 5, 55)

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu INNER JOIN xyv USING(x, y) WHERE x > 2
----
render          0  render  ·               ·                  (x, y, u, v)                          x!=NULL; y!=NULL
 │              0  ·       render 0        test.public.xyu.x  ·                                     ·
 │              0  ·       render 1        test.public.xyu.y  ·                                     ·
 │              0  ·       render 2        test.public.xyu.u  ·                                     ·
 │              0  ·       render 3        test.public.xyv.v  ·                                     ·
 └── join       1  join    ·               ·                  (x, y, u, x[omitted], y[omitted], v)  x=x; y=y; x!=NULL; y!=NULL
      │         1  ·       type            inner              ·                                     ·
      │         1  ·       equality        (x, y) = (x, y)    ·                                     ·
      │         1  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                     ·
      ├── scan  2  scan    ·               ·                  (x, y, u)                             x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
      │         2  ·       table           xyu@primary        ·                                     ·
      │         2  ·       spans           /3-                ·                                     ·
      └── scan  2  scan    ·               ·                  (x, y, v)                             x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·               2  ·       table           xyv@primary        ·                                     ·
·               2  ·       spans           /3-                ·                                     ·

query IIII
SELECT * FROM xyu INNER JOIN xyv USING(x, y) WHERE x > 2
----
3  1  31  31

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu LEFT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
render          0  render  ·               ·                  (x, y, u, v)                          ·
 │              0  ·       render 0        test.public.xyu.x  ·                                     ·
 │              0  ·       render 1        test.public.xyu.y  ·                                     ·
 │              0  ·       render 2        test.public.xyu.u  ·                                     ·
 │              0  ·       render 3        test.public.xyv.v  ·                                     ·
 └── join       1  join    ·               ·                  (x, y, u, x[omitted], y[omitted], v)  ·
      │         1  ·       type            left outer         ·                                     ·
      │         1  ·       equality        (x, y) = (x, y)    ·                                     ·
      │         1  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                     ·
      ├── scan  2  scan    ·               ·                  (x, y, u)                             x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
      │         2  ·       table           xyu@primary        ·                                     ·
      │         2  ·       spans           /3-                ·                                     ·
      └── scan  2  scan    ·               ·                  (x, y, v)                             x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·               2  ·       table           xyv@primary        ·                                     ·
·               2  ·       spans           /3-                ·                                     ·

query IIII rowsort
SELECT * FROM xyu LEFT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
3  1  31  31
3  2  32  NULL
4  4  44  NULL

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu RIGHT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
render               0  render  ·               ·                  (x, y, u, v)                                        ·
 │                   0  ·       render 0        test.public.xyv.x  ·                                                   ·
 │                   0  ·       render 1        test.public.xyv.y  ·                                                   ·
 │                   0  ·       render 2        test.public.xyu.u  ·                                                   ·
 │                   0  ·       render 3        test.public.xyv.v  ·                                                   ·
 └── render          1  render  ·               ·                  (x, y, x[hidden,omitted], y[hidden,omitted], u, v)  ·
      │              1  ·       render 0        test.public.xyv.x  ·                                                   ·
      │              1  ·       render 1        test.public.xyv.y  ·                                                   ·
      │              1  ·       render 2        NULL               ·                                                   ·
      │              1  ·       render 3        NULL               ·                                                   ·
      │              1  ·       render 4        test.public.xyu.u  ·                                                   ·
      │              1  ·       render 5        test.public.xyv.v  ·                                                   ·
      └── join       2  join    ·               ·                  (x[omitted], y[omitted], u, x, y, v)                ·
           │         2  ·       type            right outer        ·                                                   ·
           │         2  ·       equality        (x, y) = (x, y)    ·                                                   ·
           │         2  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                                   ·
           ├── scan  3  scan    ·               ·                  (x, y, u)                                           x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
           │         3  ·       table           xyu@primary        ·                                                   ·
           │         3  ·       spans           /3-                ·                                                   ·
           └── scan  3  scan    ·               ·                  (x, y, v)                                           x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·                    3  ·       table           xyv@primary        ·                                                   ·
·                    3  ·       spans           /3-                ·                                                   ·

query IIII rowsort
SELECT * FROM xyu RIGHT OUTER JOIN xyv USING(x, y) WHERE x > 2
----
3  1  31    31
3  3  NULL  33
5  5  NULL  55

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu FULL OUTER JOIN xyv USING(x, y) WHERE x > 2
----
render                    0  render  ·               ·                                             (x, y, u, v)                                                                              x!=NULL
 │                        0  ·       render 0        x                                             ·                                                                                         ·
 │                        0  ·       render 1        y                                             ·                                                                                         ·
 │                        0  ·       render 2        test.public.xyu.u                             ·                                                                                         ·
 │                        0  ·       render 3        test.public.xyv.v                             ·                                                                                         ·
 └── filter               1  filter  ·               ·                                             (x, y, x[hidden,omitted], y[hidden,omitted], u, x[hidden,omitted], y[hidden,omitted], v)  x!=NULL
      │                   1  ·       filter          x > 2                                         ·                                                                                         ·
      └── render          2  render  ·               ·                                             (x, y, x[hidden,omitted], y[hidden,omitted], u, x[hidden,omitted], y[hidden,omitted], v)  ·
           │              2  ·       render 0        IFNULL(test.public.xyu.x, test.public.xyv.x)  ·                                                                                         ·
           │              2  ·       render 1        IFNULL(test.public.xyu.y, test.public.xyv.y)  ·                                                                                         ·
           │              2  ·       render 2        NULL                                          ·                                                                                         ·
           │              2  ·       render 3        NULL                                          ·                                                                                         ·
           │              2  ·       render 4        test.public.xyu.u                             ·                                                                                         ·
           │              2  ·       render 5        NULL                                          ·                                                                                         ·
           │              2  ·       render 6        NULL                                          ·                                                                                         ·
           │              2  ·       render 7        test.public.xyv.v                             ·                                                                                         ·
           └── join       3  join    ·               ·                                             (x, y, u, x, y, v)                                                                        ·
                │         3  ·       type            full outer                                    ·                                                                                         ·
                │         3  ·       equality        (x, y) = (x, y)                               ·                                                                                         ·
                │         3  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"                             ·                                                                                         ·
                ├── scan  4  scan    ·               ·                                             (x, y, u)                                                                                 x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
                │         4  ·       table           xyu@primary                                   ·                                                                                         ·
                │         4  ·       spans           ALL                                           ·                                                                                         ·
                └── scan  4  scan    ·               ·                                             (x, y, v)                                                                                 x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·                         4  ·       table           xyv@primary                                   ·                                                                                         ·
·                         4  ·       spans           ALL                                           ·                                                                                         ·

query IIII rowsort
SELECT * FROM xyu FULL OUTER JOIN xyv USING(x, y) WHERE x > 2
----
3  1  31    31
3  2  32    NULL
4  4  44    NULL
3  3  NULL  33
5  5  NULL  55

# Verify that we transfer constraints between the two sides.
query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y WHERE xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                  (x, y, u, x, y, v)  x=x; y=y; x=CONST; y!=NULL
 │         0  ·     type            inner              ·                   ·
 │         0  ·     equality        (x, y) = (x, y)    ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                   ·
 ├── scan  1  scan  ·               ·                  (x, y, u)           x=CONST; y!=NULL; u!=NULL; key(y,u); +y
 │         1  ·     table           xyu@primary        ·                   ·
 │         1  ·     spans           /1-/1/10           ·                   ·
 └── scan  1  scan  ·               ·                  (x, y, v)           x=CONST; y!=NULL; v!=NULL; key(y,v); +y
·          1  ·     table           xyv@primary        ·                   ·
·          1  ·     spans           /1-/1/10           ·                   ·

query IIIIII
SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y WHERE xyu.x = 1 AND xyu.y < 10
----
1  1  1  1  1  1

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                  (x, y, u, x, y, v)  x=x; y=y; x=CONST; y!=NULL
 │         0  ·     type            inner              ·                   ·
 │         0  ·     equality        (x, y) = (x, y)    ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                   ·
 ├── scan  1  scan  ·               ·                  (x, y, u)           x=CONST; y!=NULL; u!=NULL; key(y,u); +y
 │         1  ·     table           xyu@primary        ·                   ·
 │         1  ·     spans           /1-/1/10           ·                   ·
 └── scan  1  scan  ·               ·                  (x, y, v)           x=CONST; y!=NULL; v!=NULL; key(y,v); +y
·          1  ·     table           xyv@primary        ·                   ·
·          1  ·     spans           /1-/1/10           ·                   ·

query IIIIII
SELECT * FROM xyu INNER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
1  1  1  1  1  1

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu LEFT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                                                     (x, y, u, x, y, v)  ·
 │         0  ·     type            left outer                                            ·                   ·
 │         0  ·     equality        (x, y) = (x, y)                                       ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"                                     ·                   ·
 │         0  ·     pred            (test.public.xyu.x = 1) AND (test.public.xyu.y < 10)  ·                   ·
 ├── scan  1  scan  ·               ·                                                     (x, y, u)           x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
 │         1  ·     table           xyu@primary                                           ·                   ·
 │         1  ·     spans           ALL                                                   ·                   ·
 └── scan  1  scan  ·               ·                                                     (x, y, v)           x=CONST; y!=NULL; v!=NULL; key(y,v); +y
·          1  ·     table           xyv@primary                                           ·                   ·
·          1  ·     spans           /1-/1/10                                              ·                   ·

query IIIIII rowsort
SELECT * FROM xyu LEFT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
0  0  0   NULL  NULL  NULL
1  1  1   1     1     1
3  1  31  NULL  NULL  NULL
3  2  32  NULL  NULL  NULL
4  4  44  NULL  NULL  NULL

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu RIGHT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                                                     (x, y, u, x, y, v)  ·
 │         0  ·     type            right outer                                           ·                   ·
 │         0  ·     equality        (x, y) = (x, y)                                       ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"                                     ·                   ·
 │         0  ·     pred            (test.public.xyv.x = 1) AND (test.public.xyv.y < 10)  ·                   ·
 ├── scan  1  scan  ·               ·                                                     (x, y, u)           x=CONST; y!=NULL; u!=NULL; key(y,u); +y
 │         1  ·     table           xyu@primary                                           ·                   ·
 │         1  ·     spans           /1-/1/10                                              ·                   ·
 └── scan  1  scan  ·               ·                                                     (x, y, v)           x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·          1  ·     table           xyv@primary                                           ·                   ·
·          1  ·     spans           ALL                                                   ·                   ·

query IIIIII rowsort
SELECT * FROM xyu RIGHT OUTER JOIN xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
1     1     1     1  1  1
NULL  NULL  NULL  3  1  31
NULL  NULL  NULL  3  3  33
NULL  NULL  NULL  5  5  55
NULL  NULL  NULL  2  2  2


# Test OUTER joins that are run in the distSQL merge joiner

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
render          0  render  ·               ·                  (x, y, u, v)                          ·
 │              0  ·       render 0        xyu.x              ·                                     ·
 │              0  ·       render 1        xyu.y              ·                                     ·
 │              0  ·       render 2        xyu.u              ·                                     ·
 │              0  ·       render 3        xyv.v              ·                                     ·
 └── join       1  join    ·               ·                  (x, y, u, x[omitted], y[omitted], v)  ·
      │         1  ·       type            left outer         ·                                     ·
      │         1  ·       equality        (x, y) = (x, y)    ·                                     ·
      │         1  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                     ·
      ├── scan  2  scan    ·               ·                  (x, y, u)                             x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
      │         2  ·       table           xyu@primary        ·                                     ·
      │         2  ·       spans           /3-                ·                                     ·
      └── scan  2  scan    ·               ·                  (x, y, v)                             x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·               2  ·       table           xyv@primary        ·                                     ·
·               2  ·       spans           /3-                ·                                     ·

query IIII rowsort
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
3  1  31  31
3  2  32  NULL
4  4  44  NULL

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
render               0  render  ·               ·                  (x, y, u, v)                                        ·
 │                   0  ·       render 0        xyv.x              ·                                                   ·
 │                   0  ·       render 1        xyv.y              ·                                                   ·
 │                   0  ·       render 2        xyu.u              ·                                                   ·
 │                   0  ·       render 3        xyv.v              ·                                                   ·
 └── render          1  render  ·               ·                  (x, y, x[hidden,omitted], y[hidden,omitted], u, v)  ·
      │              1  ·       render 0        xyv.x              ·                                                   ·
      │              1  ·       render 1        xyv.y              ·                                                   ·
      │              1  ·       render 2        NULL               ·                                                   ·
      │              1  ·       render 3        NULL               ·                                                   ·
      │              1  ·       render 4        xyu.u              ·                                                   ·
      │              1  ·       render 5        xyv.v              ·                                                   ·
      └── join       2  join    ·               ·                  (x[omitted], y[omitted], u, x, y, v)                ·
           │         2  ·       type            right outer        ·                                                   ·
           │         2  ·       equality        (x, y) = (x, y)    ·                                                   ·
           │         2  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                                   ·
           ├── scan  3  scan    ·               ·                  (x, y, u)                                           x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
           │         3  ·       table           xyu@primary        ·                                                   ·
           │         3  ·       spans           /3-                ·                                                   ·
           └── scan  3  scan    ·               ·                  (x, y, v)                                           x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·                    3  ·       table           xyv@primary        ·                                                   ·
·                    3  ·       spans           /3-                ·                                                   ·

query IIII rowsort
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
3  1  31    31
3  3  NULL  33
5  5  NULL  55

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu FULL OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
render                    0  render  ·               ·                     (x, y, u, v)                                                                              x!=NULL
 │                        0  ·       render 0        x                     ·                                                                                         ·
 │                        0  ·       render 1        y                     ·                                                                                         ·
 │                        0  ·       render 2        xyu.u                 ·                                                                                         ·
 │                        0  ·       render 3        xyv.v                 ·                                                                                         ·
 └── filter               1  filter  ·               ·                     (x, y, x[hidden,omitted], y[hidden,omitted], u, x[hidden,omitted], y[hidden,omitted], v)  x!=NULL
      │                   1  ·       filter          x > 2                 ·                                                                                         ·
      └── render          2  render  ·               ·                     (x, y, x[hidden,omitted], y[hidden,omitted], u, x[hidden,omitted], y[hidden,omitted], v)  ·
           │              2  ·       render 0        IFNULL(xyu.x, xyv.x)  ·                                                                                         ·
           │              2  ·       render 1        IFNULL(xyu.y, xyv.y)  ·                                                                                         ·
           │              2  ·       render 2        NULL                  ·                                                                                         ·
           │              2  ·       render 3        NULL                  ·                                                                                         ·
           │              2  ·       render 4        xyu.u                 ·                                                                                         ·
           │              2  ·       render 5        NULL                  ·                                                                                         ·
           │              2  ·       render 6        NULL                  ·                                                                                         ·
           │              2  ·       render 7        xyv.v                 ·                                                                                         ·
           └── join       3  join    ·               ·                     (x, y, u, x, y, v)                                                                        ·
                │         3  ·       type            full outer            ·                                                                                         ·
                │         3  ·       equality        (x, y) = (x, y)       ·                                                                                         ·
                │         3  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"     ·                                                                                         ·
                ├── scan  4  scan    ·               ·                     (x, y, u)                                                                                 x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
                │         4  ·       table           xyu@primary           ·                                                                                         ·
                │         4  ·       spans           ALL                   ·                                                                                         ·
                └── scan  4  scan    ·               ·                     (x, y, v)                                                                                 x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·                         4  ·       table           xyv@primary           ·                                                                                         ·
·                         4  ·       spans           ALL                   ·                                                                                         ·

query IIII rowsort
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu FULL OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv USING(x, y) WHERE x > 2
----
3  1  31    31
3  2  32    NULL
4  4  44    NULL
3  3  NULL  33
5  5  NULL  55

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                             (x, y, u, x, y, v)  ·
 │         0  ·     type            left outer                    ·                   ·
 │         0  ·     equality        (x, y) = (x, y)               ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"             ·                   ·
 │         0  ·     pred            (xyu.x = 1) AND (xyu.y < 10)  ·                   ·
 ├── scan  1  scan  ·               ·                             (x, y, u)           x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
 │         1  ·     table           xyu@primary                   ·                   ·
 │         1  ·     spans           ALL                           ·                   ·
 └── scan  1  scan  ·               ·                             (x, y, v)           x=CONST; y!=NULL; v!=NULL; key(y,v); +y
·          1  ·     table           xyv@primary                   ·                   ·
·          1  ·     spans           /1-/1/10                      ·                   ·

query IIIIII rowsort
SELECT * FROM (SELECT * FROM xyu ORDER BY x, y) AS xyu LEFT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
0  0  0   NULL  NULL  NULL
1  1  1   1     1     1
3  1  31  NULL  NULL  NULL
3  2  32  NULL  NULL  NULL
4  4  44  NULL  NULL  NULL

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
join       0  join  ·               ·                             (x, y, u, x, y, v)  ·
 │         0  ·     type            right outer                   ·                   ·
 │         0  ·     equality        (x, y) = (x, y)               ·                   ·
 │         0  ·     mergeJoinOrder  +"(x=x)",+"(y=y)"             ·                   ·
 │         0  ·     pred            (xyv.x = 1) AND (xyv.y < 10)  ·                   ·
 ├── scan  1  scan  ·               ·                             (x, y, u)           x=CONST; y!=NULL; u!=NULL; key(y,u); +y
 │         1  ·     table           xyu@primary                   ·                   ·
 │         1  ·     spans           /1-/1/10                      ·                   ·
 └── scan  1  scan  ·               ·                             (x, y, v)           x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·          1  ·     table           xyv@primary                   ·                   ·
·          1  ·     spans           ALL                           ·                   ·

query IIIIII rowsort
SELECT * FROM xyu RIGHT OUTER JOIN (SELECT * FROM xyv ORDER BY x, y) AS xyv ON xyu.x = xyv.x AND xyu.y = xyv.y AND xyu.x = 1 AND xyu.y < 10
----
1     1     1     1  1  1
NULL  NULL  NULL  3  1  31
NULL  NULL  NULL  3  3  33
NULL  NULL  NULL  5  5  55
NULL  NULL  NULL  2  2  2

# Regression test for #20472: break up tuple inequalities.
query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM xyu JOIN xyv USING(x, y) WHERE (x, y, u) > (1, 2, 3)
----
render          0  render  ·               ·                  (x, y, u, v)                          x!=NULL; y!=NULL
 │              0  ·       render 0        test.public.xyu.x  ·                                     ·
 │              0  ·       render 1        test.public.xyu.y  ·                                     ·
 │              0  ·       render 2        test.public.xyu.u  ·                                     ·
 │              0  ·       render 3        test.public.xyv.v  ·                                     ·
 └── join       1  join    ·               ·                  (x, y, u, x[omitted], y[omitted], v)  x=x; y=y; x!=NULL; y!=NULL
      │         1  ·       type            inner              ·                                     ·
      │         1  ·       equality        (x, y) = (x, y)    ·                                     ·
      │         1  ·       mergeJoinOrder  +"(x=x)",+"(y=y)"  ·                                     ·
      ├── scan  2  scan    ·               ·                  (x, y, u)                             x!=NULL; y!=NULL; u!=NULL; key(x,y,u); +x,+y
      │         2  ·       table           xyu@primary        ·                                     ·
      │         2  ·       spans           /1/2/4-            ·                                     ·
      └── scan  2  scan    ·               ·                  (x, y, v)                             x!=NULL; y!=NULL; v!=NULL; key(x,y,v); +x,+y
·               2  ·       table           xyv@primary        ·                                     ·
·               2  ·       spans           /1/2-              ·                                     ·


# Regression test for #20858.

statement ok
CREATE TABLE l (a INT PRIMARY KEY)

statement ok
CREATE TABLE r (a INT PRIMARY KEY)

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM l LEFT OUTER JOIN r USING(a) WHERE a = 3;
----
render          0  render  ·               ·                (a)              ·
 │              0  ·       render 0        test.public.l.a  ·                ·
 └── join       1  join    ·               ·                (a, a[omitted])  ·
      │         1  ·       type            left outer       ·                ·
      │         1  ·       equality        (a) = (a)        ·                ·
      │         1  ·       mergeJoinOrder  +"(a=a)"         ·                ·
      ├── scan  2  scan    ·               ·                (a)              a=CONST; key()
      │         2  ·       table           l@primary        ·                ·
      │         2  ·       spans           /3-/3/#          ·                ·
      └── scan  2  scan    ·               ·                (a)              a=CONST; key()
·               2  ·       table           r@primary        ·                ·
·               2  ·       spans           /3-/3/#          ·                ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM l LEFT OUTER JOIN r ON l.a = r.a WHERE l.a = 3;
----
join       0  join  ·               ·           (a, a)  ·
 │         0  ·     type            left outer  ·       ·
 │         0  ·     equality        (a) = (a)   ·       ·
 │         0  ·     mergeJoinOrder  +"(a=a)"    ·       ·
 ├── scan  1  scan  ·               ·           (a)     a=CONST; key()
 │         1  ·     table           l@primary   ·       ·
 │         1  ·     spans           /3-/3/#     ·       ·
 └── scan  1  scan  ·               ·           (a)     a=CONST; key()
·          1  ·     table           r@primary   ·       ·
·          1  ·     spans           /3-/3/#     ·       ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM l RIGHT OUTER JOIN r USING(a) WHERE a = 3;
----
render               0  render  ·               ·                (a)                     ·
 │                   0  ·       render 0        test.public.r.a  ·                       ·
 └── render          1  render  ·               ·                (a, a[hidden,omitted])  ·
      │              1  ·       render 0        test.public.r.a  ·                       ·
      │              1  ·       render 1        NULL             ·                       ·
      └── join       2  join    ·               ·                (a[omitted], a)         ·
           │         2  ·       type            right outer      ·                       ·
           │         2  ·       equality        (a) = (a)        ·                       ·
           │         2  ·       mergeJoinOrder  +"(a=a)"         ·                       ·
           ├── scan  3  scan    ·               ·                (a)                     a=CONST; key()
           │         3  ·       table           l@primary        ·                       ·
           │         3  ·       spans           /3-/3/#          ·                       ·
           └── scan  3  scan    ·               ·                (a)                     a=CONST; key()
·                    3  ·       table           r@primary        ·                       ·
·                    3  ·       spans           /3-/3/#          ·                       ·

query TITTTTT
EXPLAIN (VERBOSE) SELECT * FROM l RIGHT OUTER JOIN r ON l.a = r.a WHERE r.a = 3;
----
join       0  join  ·               ·            (a, a)  ·
 │         0  ·     type            right outer  ·       ·
 │         0  ·     equality        (a) = (a)    ·       ·
 │         0  ·     mergeJoinOrder  +"(a=a)"     ·       ·
 ├── scan  1  scan  ·               ·            (a)     a=CONST; key()
 │         1  ·     table           l@primary    ·       ·
 │         1  ·     spans           /3-/3/#      ·       ·
 └── scan  1  scan  ·               ·            (a)     a=CONST; key()
·          1  ·     table           r@primary    ·       ·
·          1  ·     spans           /3-/3/#      ·       ·

statement ok
INSERT INTO l VALUES (1), (2), (3)

statement ok
INSERT INTO r VALUES (2), (3), (4)

query I
SELECT * FROM l LEFT OUTER JOIN r USING(a) WHERE a = 1
----
1

query I
SELECT * FROM l LEFT OUTER JOIN r USING(a) WHERE a = 2
----
2

query I
SELECT * FROM l RIGHT OUTER JOIN r USING(a) WHERE a = 3
----
3

query I
SELECT * FROM l RIGHT OUTER JOIN r USING(a) WHERE a = 4
----
4

# Regression tests for #21243
statement ok
CREATE TABLE abcdef (
  a INT NOT NULL,
  b INT NOT NULL,
  c INT NOT NULL,
  d INT NOT NULL,
  e INT NULL,
  f INT NULL,
  PRIMARY KEY (a ASC, b ASC, c DESC, d ASC)
)

statement ok
CREATE TABLE abg (
  a INT NOT NULL,
  b INT NOT NULL,
  g INT NULL,
  PRIMARY KEY (a ASC, b ASC)
);

query TTT
EXPLAIN SELECT * FROM abcdef join (select * from abg) USING (a,b) WHERE ((a,b)>(1,2) OR ((a,b)=(1,2) AND c < 6) OR ((a,b,c)=(1,2,6) AND d > 8))
----
render          ·               ·
 └── join       ·               ·
      │         type            inner
      │         equality        (a, b) = (a, b)
      │         mergeJoinOrder  +"(a=a)",+"(b=b)"
      ├── scan  ·               ·
      │         table           abcdef@primary
      │         spans           /1/2/6/9-
      └── scan  ·               ·
·               table           abg@primary
·               spans           /1/2-

# Regression tests for mixed-type equality columns (#22514).
statement ok
CREATE TABLE foo (
  a INT,
  b INT,
  c FLOAT,
  d FLOAT
)

statement ok
INSERT INTO foo VALUES
  (1, 1, 1, 1),
  (2, 2, 2, 2),
  (3, 3, 3, 3)

statement ok
CREATE TABLE bar (
  a INT,
  b FLOAT,
  c FLOAT,
  d INT
)

statement ok
INSERT INTO bar VALUES
  (1, 1, 1, 1),
  (2, 2, 2, 2),
  (3, 3, 3, 3)

# Only a and c can be equality columns.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo NATURAL JOIN bar
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a, c) = (a, c)
      │         pred      (test.public.foo.b = test.public.bar.b) AND (test.public.foo.d = test.public.bar.d)
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRR rowsort
SELECT * FROM foo NATURAL JOIN bar
----
1  1  1  1
2  2  2  2
3  3  3  3

# b can't be an equality column.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar USING (b)
----
render               ·         ·
 │                   render 0  b
 │                   render 1  a
 │                   render 2  c
 │                   render 3  d
 │                   render 4  a
 │                   render 5  c
 │                   render 6  d
 └── render          ·         ·
      │              render 0  b
      │              render 1  a
      │              render 2  c
      │              render 3  d
      │              render 4  NULL
      │              render 5  a
      │              render 6  NULL
      │              render 7  c
      │              render 8  d
      │              render 9  NULL
      └── join       ·         ·
           │         type      inner
           │         pred      test.public.foo.b = test.public.bar.b
           ├── scan  ·         ·
           │         table     foo@primary
           │         spans     ALL
           └── scan  ·         ·
·                    table     bar@primary
·                    spans     ALL

query IIRRIRI rowsort
SELECT * FROM foo JOIN bar USING (b)
----
1  1  1  1  1  1  1
2  2  2  2  2  2  2
3  3  3  3  3  3  3

# Only a can be an equality column.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar USING (a, b)
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  c
 │              render 5  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a) = (a)
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRRI rowsort
SELECT * FROM foo JOIN bar USING (a, b)
----
1  1  1  1  1  1
2  2  2  2  2  2
3  3  3  3  3  3

# Only a and c can be equality columns.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar USING (a, b, c)
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a, c) = (a, c)
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRI rowsort
SELECT * FROM foo JOIN bar USING (a, b, c)
----
1  1  1  1  1
2  2  2  2  2
3  3  3  3  3

# b can't be an equality column.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar ON foo.b = bar.b
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  a
 │              render 5  b
 │              render 6  c
 │              render 7  d
 └── join       ·         ·
      │         type      inner
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRIRRI rowsort
SELECT * FROM foo JOIN bar ON foo.b = bar.b
----
1  1  1  1  1  1  1  1
2  2  2  2  2  2  2  2
3  3  3  3  3  3  3  3

# Only a can be an equality column.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar ON foo.a = bar.a AND foo.b = bar.b
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  a
 │              render 5  b
 │              render 6  c
 │              render 7  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a) = (a)
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRIRRI rowsort
SELECT * FROM foo JOIN bar ON foo.a = bar.a AND foo.b = bar.b
----
1  1  1  1  1  1  1  1
2  2  2  2  2  2  2  2
3  3  3  3  3  3  3  3

query TTT
EXPLAIN (EXPRS) SELECT * FROM foo, bar WHERE foo.b = bar.b
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  a
 │              render 5  b
 │              render 6  c
 │              render 7  d
 └── join       ·         ·
      │         type      inner
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRIRRI rowsort
SELECT * FROM foo, bar WHERE foo.b = bar.b
----
1  1  1  1  1  1  1  1
2  2  2  2  2  2  2  2
3  3  3  3  3  3  3  3

# Only a can be an equality column.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo, bar WHERE foo.a = bar.a AND foo.b = bar.b
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  a
 │              render 5  b
 │              render 6  c
 │              render 7  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a) = (a)
      │         pred      test.public.foo.b = test.public.bar.b
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRIRRI rowsort
SELECT * FROM foo, bar WHERE foo.a = bar.a AND foo.b = bar.b
----
1  1  1  1  1  1  1  1
2  2  2  2  2  2  2  2
3  3  3  3  3  3  3  3

# Only a and c can be equality columns.
query TTT
EXPLAIN (EXPRS) SELECT * FROM foo JOIN bar USING (a,b) WHERE foo.c = bar.c AND foo.d = bar.d
----
render          ·         ·
 │              render 0  a
 │              render 1  b
 │              render 2  c
 │              render 3  d
 │              render 4  c
 │              render 5  d
 └── join       ·         ·
      │         type      inner
      │         equality  (a, c) = (a, c)
      │         pred      (test.public.foo.b = test.public.bar.b) AND (test.public.foo.d = test.public.bar.d)
      ├── scan  ·         ·
      │         table     foo@primary
      │         spans     ALL
      └── scan  ·         ·
·               table     bar@primary
·               spans     ALL

query IIRRRI rowsort
SELECT * FROM foo JOIN bar USING (a, b) WHERE foo.c = bar.c AND foo.d = bar.d
----
1  1  1  1  1  1
2  2  2  2  2  2
3  3  3  3  3  3

# Regression test for 23664.
query III rowsort
SELECT * FROM onecolumn AS a(x) RIGHT JOIN twocolumn ON false
----
NULL  44    51
NULL  NULL  52
NULL  42    53
NULL  45    45

# Regression test for #23609: make sure that the type of the merged column
# is int (not unknown).
query TT colnames
SELECT "Type", "Columns" FROM [EXPLAIN (TYPES)
  SELECT column1, column1+1
  FROM
    (SELECT * FROM
      (VALUES (NULL, NULL)) AS t
        NATURAL FULL OUTER JOIN
      (VALUES (1, 1)) AS u)]
WHERE "Type" != ''
----
Type    Columns
render  (column1 int, "column1 + 1" int)
render  (column1 int, column2[omitted] int)
render  (column1 int, column2[omitted] int, column1[hidden,omitted] unknown, column2[hidden,omitted] unknown, column1[hidden,omitted] int, column2[hidden,omitted] int)
join    (column1 unknown, column2[omitted] unknown, column1 int, column2[omitted] int)
values  (column1 unknown, column2 unknown)
values  (column1 int, column2 int)

query II rowsort
SELECT column1, column1+1
FROM
  (SELECT * FROM
    (VALUES (NULL, NULL)) AS t
      NATURAL FULL OUTER JOIN
    (VALUES (1, 1)) AS u)
----
1     2
NULL  NULL
