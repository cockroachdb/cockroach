statement ok
CREATE TABLE a (a INT PRIMARY KEY, b INT);
INSERT INTO a VALUES (1, 2), (2, 2)

statement error DECLARE CURSOR can only be used in transaction blocks
DECLARE foo CURSOR FOR SELECT * FROM a

statement error cursor \"foo\" does not exist
CLOSE foo

statement error cursor \"foo\" does not exist
FETCH 2 foo

statement ok
BEGIN

statement error cursor \"foo\" does not exist
FETCH 2 foo

statement ok
ROLLBACK;
BEGIN;

statement ok
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

query II
FETCH 1 foo
----
1  2

query II
FETCH 1 foo
----
2  2

query II
FETCH 2 foo
----

statement ok
CLOSE foo

statement ok
COMMIT;

statement error cursor \"foo\" does not exist
BEGIN;
CLOSE foo

statement ok
ROLLBACK;
BEGIN;
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

# Test "cursor sensitivity". All Postgres cursors are "insensitive", meaning
# that mutations to the underlying data that occur after a cursor is declared
# are not visible to the cursor. We mimic this behavior.

statement ok
INSERT INTO a VALUES(3, 2)

query II
FETCH 3 foo
----
1  2
2  2

statement ok
CLOSE foo;
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

query II
FETCH 3 foo
----
1  2
2  2
3  2

statement ok
COMMIT

# Test cursor fetch directions.
statement ok
BEGIN;
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

query II
FETCH ALL foo
----
1  2
2  2
3  2

query II
FETCH ALL foo
----

statement ok
CLOSE foo;
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

query II
FETCH FORWARD ALL foo
----
1  2
2  2
3  2

query II
FETCH FORWARD ALL foo
----

statement ok
COMMIT;
INSERT INTO a SELECT g,g+1 FROM generate_series(4, 100) g(g);
BEGIN;
DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a

query II
FETCH 0 foo
----

query II
FETCH FIRST foo
----
1  2

query II
FETCH FIRST foo
----
1  2

query II
FETCH NEXT foo
----
2  2

query II
FETCH NEXT foo
----
3  2

query II
FETCH FORWARD 3 foo
----
4  5
5  6
6  7

query II
FETCH FORWARD 3 foo
----
7  8
8  9
9  10

query II
FETCH RELATIVE 3 foo
----
12  13

query II
FETCH FORWARD foo
----
13  14

query II
FETCH ABSOLUTE 13 foo
----
13  14

query II
FETCH ABSOLUTE 14 foo
----
14  15

query II
FETCH ABSOLUTE 14 foo
----
14  15

query II
FETCH ABSOLUTE 16 foo
----
16  17

query II
FETCH ABSOLUTE 100 foo
----
100 101

query II
FETCH ABSOLUTE 101 foo
----

query II
FETCH ABSOLUTE 102 foo
----

statement ok
COMMIT

# Test error cases (Backward iteration)
# It's annoying to test these because each will cause an error, which will
# require a new transaction. That's why all the long statements.

statement error cursor can only scan forward
BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH -1 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH BACKWARD 1 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH FORWARD -1 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH LAST foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH LAST foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH 10 foo;
FETCH ABSOLUTE 9 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH 10 foo;
FETCH RELATIVE -1 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH 10 foo;
FETCH FIRST foo;

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH ABSOLUTE -1 foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH PRIOR foo

statement error cursor can only scan forward
ROLLBACK; BEGIN; DECLARE foo CURSOR FOR SELECT * FROM a ORDER BY a;
FETCH BACKWARD ALL foo
