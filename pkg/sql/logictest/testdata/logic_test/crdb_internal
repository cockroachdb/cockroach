# 3node-tenant is blocked from running this file due to heavy reliance on
# unavailable node IDs in this test.
# LogicTest: !3node-tenant-default-configs

query error database "crdb_internal" does not exist
ALTER DATABASE crdb_internal RENAME TO not_crdb_internal

statement error schema cannot be modified: "crdb_internal"
CREATE TABLE crdb_internal.t (x INT)

query error database "crdb_internal" does not exist
DROP DATABASE crdb_internal

query TTTTIT
SHOW TABLES FROM crdb_internal
----
crdb_internal  active_range_feeds                      table  admin  NULL  NULL
crdb_internal  backward_dependencies                   table  admin  NULL  NULL
crdb_internal  builtin_functions                       table  admin  NULL  NULL
crdb_internal  cluster_contended_indexes               view   admin  NULL  NULL
crdb_internal  cluster_contended_keys                  view   admin  NULL  NULL
crdb_internal  cluster_contended_tables                view   admin  NULL  NULL
crdb_internal  cluster_contention_events               table  admin  NULL  NULL
crdb_internal  cluster_database_privileges             table  admin  NULL  NULL
crdb_internal  cluster_distsql_flows                   table  admin  NULL  NULL
crdb_internal  cluster_execution_insights              table  admin  NULL  NULL
crdb_internal  cluster_inflight_traces                 table  admin  NULL  NULL
crdb_internal  cluster_locks                           table  admin  NULL  NULL
crdb_internal  cluster_queries                         table  admin  NULL  NULL
crdb_internal  cluster_sessions                        table  admin  NULL  NULL
crdb_internal  cluster_settings                        table  admin  NULL  NULL
crdb_internal  cluster_statement_statistics            table  admin  NULL  NULL
crdb_internal  cluster_transaction_statistics          table  admin  NULL  NULL
crdb_internal  cluster_transactions                    table  admin  NULL  NULL
crdb_internal  cluster_txn_execution_insights          table  admin  NULL  NULL
crdb_internal  create_function_statements              table  admin  NULL  NULL
crdb_internal  create_schema_statements                table  admin  NULL  NULL
crdb_internal  create_statements                       table  admin  NULL  NULL
crdb_internal  create_type_statements                  table  admin  NULL  NULL
crdb_internal  cross_db_references                     table  admin  NULL  NULL
crdb_internal  databases                               table  admin  NULL  NULL
crdb_internal  default_privileges                      table  admin  NULL  NULL
crdb_internal  feature_usage                           table  admin  NULL  NULL
crdb_internal  forward_dependencies                    table  admin  NULL  NULL
crdb_internal  gossip_alerts                           table  admin  NULL  NULL
crdb_internal  gossip_liveness                         table  admin  NULL  NULL
crdb_internal  gossip_network                          table  admin  NULL  NULL
crdb_internal  gossip_nodes                            table  admin  NULL  NULL
crdb_internal  index_columns                           table  admin  NULL  NULL
crdb_internal  index_spans                             table  admin  NULL  NULL
crdb_internal  index_usage_statistics                  table  admin  NULL  NULL
crdb_internal  invalid_objects                         table  admin  NULL  NULL
crdb_internal  jobs                                    table  admin  NULL  NULL
crdb_internal  kv_catalog_comments                     table  admin  NULL  NULL
crdb_internal  kv_catalog_descriptor                   table  admin  NULL  NULL
crdb_internal  kv_catalog_namespace                    table  admin  NULL  NULL
crdb_internal  kv_catalog_zones                        table  admin  NULL  NULL
crdb_internal  kv_dropped_relations                    view   admin  NULL  NULL
crdb_internal  kv_node_liveness                        table  admin  NULL  NULL
crdb_internal  kv_node_status                          table  admin  NULL  NULL
crdb_internal  kv_store_status                         table  admin  NULL  NULL
crdb_internal  leases                                  table  admin  NULL  NULL
crdb_internal  lost_descriptors_with_data              table  admin  NULL  NULL
crdb_internal  node_build_info                         table  admin  NULL  NULL
crdb_internal  node_contention_events                  table  admin  NULL  NULL
crdb_internal  node_distsql_flows                      table  admin  NULL  NULL
crdb_internal  node_execution_insights                 table  admin  NULL  NULL
crdb_internal  node_inflight_trace_spans               table  admin  NULL  NULL
crdb_internal  node_memory_monitors                    table  admin  NULL  NULL
crdb_internal  node_metrics                            table  admin  NULL  NULL
crdb_internal  node_queries                            table  admin  NULL  NULL
crdb_internal  node_runtime_info                       table  admin  NULL  NULL
crdb_internal  node_sessions                           table  admin  NULL  NULL
crdb_internal  node_statement_statistics               table  admin  NULL  NULL
crdb_internal  node_tenant_capabilities_cache          table  admin  NULL  NULL
crdb_internal  node_transaction_statistics             table  admin  NULL  NULL
crdb_internal  node_transactions                       table  admin  NULL  NULL
crdb_internal  node_txn_execution_insights             table  admin  NULL  NULL
crdb_internal  node_txn_stats                          table  admin  NULL  NULL
crdb_internal  partitions                              table  admin  NULL  NULL
crdb_internal  pg_catalog_table_is_implemented         table  admin  NULL  NULL
crdb_internal  ranges                                  view   admin  NULL  NULL
crdb_internal  ranges_no_leases                        table  admin  NULL  NULL
crdb_internal  regions                                 table  admin  NULL  NULL
crdb_internal  schema_changes                          table  admin  NULL  NULL
crdb_internal  session_trace                           table  admin  NULL  NULL
crdb_internal  session_variables                       table  admin  NULL  NULL
crdb_internal  statement_activity                      view   admin  NULL  NULL
crdb_internal  statement_statistics                    view   admin  NULL  NULL
crdb_internal  statement_statistics_persisted          view   admin  NULL  NULL
crdb_internal  statement_statistics_persisted_v22_2    view   admin  NULL  NULL
crdb_internal  super_regions                           table  admin  NULL  NULL
crdb_internal  system_jobs                             table  admin  NULL  NULL
crdb_internal  table_columns                           table  admin  NULL  NULL
crdb_internal  table_indexes                           table  admin  NULL  NULL
crdb_internal  table_row_statistics                    table  admin  NULL  NULL
crdb_internal  table_spans                             table  admin  NULL  NULL
crdb_internal  tables                                  table  admin  NULL  NULL
crdb_internal  tenant_usage_details                    view   admin  NULL  NULL
crdb_internal  transaction_activity                    view   admin  NULL  NULL
crdb_internal  transaction_contention_events           table  admin  NULL  NULL
crdb_internal  transaction_statistics                  view   admin  NULL  NULL
crdb_internal  transaction_statistics_persisted        view   admin  NULL  NULL
crdb_internal  transaction_statistics_persisted_v22_2  view   admin  NULL  NULL
crdb_internal  zones                                   table  admin  NULL  NULL

statement ok
CREATE DATABASE testdb; CREATE TABLE testdb.foo(x INT)

let $testdb_id
SELECT id FROM system.namespace WHERE name = 'testdb'

let $testdb_foo_id
SELECT 'testdb.foo'::regclass::int

query TIT
SELECT t.name, t.version, t.state FROM crdb_internal.tables AS t JOIN system.namespace AS n ON (n.id = t.parent_id and n.name = 'testdb');
----
foo  1  PUBLIC

# Ensure there is a lease taken on foo.
query I
SELECT * FROM testdb.foo
----

# Check the lease.
query T
SELECT l.name FROM crdb_internal.leases AS l JOIN system.namespace AS n ON (n.id = l.table_id and n.name = 'foo');
----
foo

# We merely check the column list for schema_changes.
query IITTITTT colnames
SELECT * FROM crdb_internal.schema_changes
----
table_id parent_id name type target_id target_name state direction

# We don't select the modification time as it does not remain contant.
query IITTITTTTTTTI colnames
SELECT
  table_id,
  parent_id,
  name,
  database_name,
  version,
  format_version,
  state,
  sc_lease_node_id,
  sc_lease_expiration_time,
  drop_time,
  audit_mode,
  schema_name,
  parent_schema_id
FROM crdb_internal.tables WHERE NAME = 'descriptor'
----
table_id  parent_id  name        database_name  version  format_version            state   sc_lease_node_id  sc_lease_expiration_time  drop_time  audit_mode  schema_name  parent_schema_id
3         1          descriptor  system         1        InterleavedFormatVersion  PUBLIC  NULL              NULL                      NULL       DISABLED    public       29

query TB colnames
SELECT * FROM crdb_internal.pg_catalog_table_is_implemented
----
name                             implemented
pg_aggregate                     false
pg_am                            false
pg_amop                          true
pg_amproc                        true
pg_attrdef                       false
pg_attribute                     false
pg_auth_members                  false
pg_authid                        false
pg_available_extension_versions  true
pg_available_extensions          true
pg_cast                          false
pg_class                         false
pg_collation                     false
pg_config                        true
pg_constraint                    false
pg_conversion                    true
pg_cursors                       false
pg_database                      false
pg_db_role_setting               false
pg_default_acl                   false
pg_depend                        false
pg_description                   false
pg_enum                          false
pg_event_trigger                 true
pg_extension                     true
pg_file_settings                 true
pg_foreign_data_wrapper          true
pg_foreign_server                true
pg_foreign_table                 true
pg_group                         true
pg_hba_file_rules                true
pg_index                         false
pg_indexes                       false
pg_inherits                      true
pg_init_privs                    true
pg_language                      true
pg_largeobject                   true
pg_largeobject_metadata          true
pg_locks                         true
pg_matviews                      false
pg_namespace                     false
pg_opclass                       true
pg_operator                      false
pg_opfamily                      true
pg_partitioned_table             true
pg_policies                      true
pg_policy                        true
pg_prepared_statements           false
pg_prepared_xacts                true
pg_proc                          false
pg_publication                   true
pg_publication_rel               true
pg_publication_tables            true
pg_range                         true
pg_replication_origin            true
pg_replication_origin_status     true
pg_replication_slots             true
pg_rewrite                       false
pg_roles                         false
pg_rules                         true
pg_seclabel                      true
pg_seclabels                     true
pg_sequence                      false
pg_sequences                     false
pg_settings                      false
pg_shadow                        false
pg_shdepend                      false
pg_shdescription                 false
pg_shmem_allocations             true
pg_shseclabel                    true
pg_stat_activity                 true
pg_stat_all_indexes              true
pg_stat_all_tables               true
pg_stat_archiver                 true
pg_stat_bgwriter                 true
pg_stat_database                 true
pg_stat_database_conflicts       true
pg_stat_gssapi                   true
pg_stat_progress_analyze         true
pg_stat_progress_basebackup      true
pg_stat_progress_cluster         true
pg_stat_progress_create_index    true
pg_stat_progress_vacuum          true
pg_stat_replication              true
pg_stat_slru                     true
pg_stat_ssl                      true
pg_stat_subscription             true
pg_stat_sys_indexes              true
pg_stat_sys_tables               true
pg_stat_user_functions           true
pg_stat_user_indexes             true
pg_stat_user_tables              true
pg_stat_wal_receiver             true
pg_stat_xact_all_tables          true
pg_stat_xact_sys_tables          true
pg_stat_xact_user_functions      true
pg_stat_xact_user_tables         true
pg_statio_all_indexes            true
pg_statio_all_sequences          true
pg_statio_all_tables             true
pg_statio_sys_indexes            true
pg_statio_sys_sequences          true
pg_statio_sys_tables             true
pg_statio_user_indexes           true
pg_statio_user_sequences         true
pg_statio_user_tables            true
pg_statistic                     true
pg_statistic_ext                 false
pg_statistic_ext_data            true
pg_stats                         true
pg_stats_ext                     true
pg_subscription                  true
pg_subscription_rel              true
pg_tables                        false
pg_tablespace                    false
pg_timezone_abbrevs              true
pg_timezone_names                false
pg_transform                     true
pg_trigger                       true
pg_ts_config                     true
pg_ts_config_map                 true
pg_ts_dict                       true
pg_ts_parser                     true
pg_ts_template                   true
pg_type                          false
pg_user                          false
pg_user_mapping                  true
pg_user_mappings                 true
pg_views                         false

# Verify that table names are not double escaped.

statement ok
CREATE TABLE testdb." ""\'" (i int)

query T
SELECT NAME from crdb_internal.tables WHERE DATABASE_NAME = 'testdb'
----
foo
 "\'

query TT colnames
SELECT field, value FROM crdb_internal.node_build_info WHERE field ILIKE 'name'
----
field value
Name  CockroachDB

query T rowsort
SELECT field FROM crdb_internal.node_build_info
----
Name
Build
ClusterID
Organization
Version
Channel


# The validity of the rows in this table are tested elsewhere; we merely assert the columns.
query ITTTTTTTTTTTRTTIITTITT colnames
SELECT * FROM crdb_internal.jobs WHERE false
----
job_id  job_type  description  statement  user_name  descriptor_ids  status  running_status  created  started  finished  modified  fraction_completed  high_water_timestamp  error  coordinator_id  trace_id  last_run  next_run  num_runs  execution_errors execution_events

query IITTITTT colnames
SELECT * FROM crdb_internal.schema_changes WHERE table_id < 0
----
table_id  parent_id  name  type  target_id  target_name  state  direction

query IITITB colnames
SELECT * FROM crdb_internal.leases WHERE node_id < 0
----
node_id  table_id  name  parent_id  expiration  deleted

query ITTTTTIIITTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRBBTTTTTRRRRR colnames
SELECT * FROM crdb_internal.node_statement_statistics WHERE node_id < 0
----
node_id  application_name  flags  statement_id  key  anonymized  count  first_attempt_count  max_retries  last_error  last_error_code  rows_avg  rows_var  idle_lat_avg  idle_lat_var  parse_lat_avg  parse_lat_var  plan_lat_avg  plan_lat_var  run_lat_avg  run_lat_var  service_lat_avg  service_lat_var  overhead_lat_avg  overhead_lat_var  bytes_read_avg  bytes_read_var  rows_read_avg  rows_read_var  rows_written_avg  rows_written_var  network_bytes_avg  network_bytes_var  network_msgs_avg  network_msgs_var  max_mem_usage_avg  max_mem_usage_var  max_disk_usage_avg  max_disk_usage_var  contention_time_avg  contention_time_var  cpu_sql_nanos_avg  cpu_sql_nanos_var  mvcc_step_avg  mvcc_step_var  mvcc_step_internal_avg  mvcc_step_internal_var  mvcc_seek_avg  mvcc_seek_var  mvcc_seek_internal_avg  mvcc_seek_internal_var  mvcc_block_bytes_avg  mvcc_block_bytes_var  mvcc_block_bytes_in_cache_avg  mvcc_block_bytes_in_cache_var  mvcc_key_bytes_avg  mvcc_key_bytes_var  mvcc_value_bytes_avg  mvcc_value_bytes_var  mvcc_point_count_avg  mvcc_point_count_var  mvcc_points_covered_by_range_tombstones_avg  mvcc_points_covered_by_range_tombstones_var  mvcc_range_key_count_avg  mvcc_range_key_count_var  mvcc_range_key_contained_points_avg  mvcc_range_key_contained_points_var  mvcc_range_key_skipped_points_avg  mvcc_range_key_skipped_points_var  implicit_txn  full_scan  sample_plan  database_name  exec_node_ids  txn_fingerprint_id  index_recommendations  latency_seconds_min  latency_seconds_max  latency_seconds_p50  latency_seconds_p90  latency_seconds_p99

query ITTTIIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR colnames
SELECT * FROM crdb_internal.node_transaction_statistics WHERE node_id < 0
----
node_id  application_name  key  statement_ids  count  max_retries  service_lat_avg  service_lat_var  retry_lat_avg  retry_lat_var  commit_lat_avg  commit_lat_var  idle_lat_avg  idle_lat_var  rows_read_avg  rows_read_var  network_bytes_avg  network_bytes_var  network_msgs_avg  network_msgs_var  max_mem_usage_avg  max_mem_usage_var  max_disk_usage_avg  max_disk_usage_var  contention_time_avg  contention_time_var  cpu_sql_nanos_avg  cpu_sql_nanos_var  mvcc_step_avg  mvcc_step_var  mvcc_step_internal_avg  mvcc_step_internal_var  mvcc_seek_avg  mvcc_seek_var  mvcc_seek_internal_avg  mvcc_seek_internal_var  mvcc_block_bytes_avg  mvcc_block_bytes_var  mvcc_block_bytes_in_cache_avg  mvcc_block_bytes_in_cache_var  mvcc_key_bytes_avg  mvcc_key_bytes_var  mvcc_value_bytes_avg  mvcc_value_bytes_var  mvcc_point_count_avg  mvcc_point_count_var  mvcc_points_covered_by_range_tombstones_avg  mvcc_points_covered_by_range_tombstones_var  mvcc_range_key_count_avg  mvcc_range_key_count_var  mvcc_range_key_contained_points_avg  mvcc_range_key_contained_points_var  mvcc_range_key_skipped_points_avg  mvcc_range_key_skipped_points_var

query IITTTTTTT colnames
SELECT * FROM crdb_internal.session_trace WHERE span_idx < 0
----
span_idx  message_idx  timestamp  duration  operation  loc  tag  message age

query TTTBT colnames
SELECT * FROM crdb_internal.cluster_settings WHERE variable = ''
----
variable  value  type  public  description

query TI colnames
SELECT * FROM crdb_internal.feature_usage WHERE feature_name = ''
----
feature_name  usage_count

query TTB colnames
SELECT * FROM crdb_internal.session_variables WHERE variable = ''
----
variable  value  hidden

query TTITTTTTTBTBTT colnames
SELECT * FROM crdb_internal.node_queries WHERE node_id < 0
----
query_id  txn_id  node_id  session_id  user_name  start  query  client_address  application_name  distributed  phase  full_scan  plan_gist  database

query TTITTTTTTBTBTT colnames
SELECT * FROM crdb_internal.cluster_queries WHERE node_id < 0
----
query_id  txn_id  node_id  session_id  user_name  start  query  client_address  application_name  distributed  phase  full_scan  plan_gist  database

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.node_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.cluster_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

# Accessing the tables should error for a user without a privilege.
user testuser

statement error user testuser does not have VIEWACTIVITY or VIEWACTIVITYREDACTED privilege
SELECT  * FROM crdb_internal.node_transactions WHERE node_id < 0

statement error user testuser does not have VIEWACTIVITY or VIEWACTIVITYREDACTED privilege
SELECT  * FROM crdb_internal.cluster_transactions WHERE node_id < 0

user root

statement ok
GRANT SYSTEM VIEWACTIVITY TO testuser

# Now testuser can query transactions since it has the VIEWACTIVITY privilege.
user testuser

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.node_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.cluster_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

user root

statement ok
REVOKE SYSTEM VIEWACTIVITY FROM testuser

statement ok
GRANT SYSTEM VIEWACTIVITYREDACTED TO testuser

# testuser can query transactions since it has the VIEWACTIVITYREDACTED privilege.
user testuser

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.node_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

query TITTTTIIIT colnames
SELECT  * FROM crdb_internal.cluster_transactions WHERE node_id < 0
----
id  node_id  session_id  start  txn_string  application_name  num_stmts  num_retries  num_auto_retries  last_auto_retry_reason

user root

statement ok
REVOKE SYSTEM VIEWACTIVITYREDACTED FROM testuser

query ITTTTTTTTTTTTTT colnames
SELECT * FROM crdb_internal.node_sessions WHERE node_id < 0
----
node_id  session_id  user_name  client_address  application_name  active_queries  last_active_query  num_txns_executed  session_start  active_query_start  kv_txn  alloc_bytes  max_alloc_bytes  status  session_end

query ITTTTTTTTTTTTTT colnames
SELECT * FROM crdb_internal.cluster_sessions WHERE node_id < 0
----
node_id  session_id  user_name  client_address  application_name  active_queries  last_active_query  num_txns_executed  session_start  active_query_start  kv_txn  alloc_bytes  max_alloc_bytes  status  session_end

query IIITTTI colnames
SELECT * FROM crdb_internal.node_contention_events WHERE table_id < 0
----
table_id  index_id  num_contention_events  cumulative_contention_time  key  txn_id  count

query IIITTTI colnames
SELECT * FROM crdb_internal.cluster_contention_events WHERE table_id < 0
----
table_id  index_id  num_contention_events  cumulative_contention_time  key  txn_id  count

query TTTTT colnames
SELECT * FROM crdb_internal.builtin_functions WHERE function = ''
----
function  signature  category  details  schema

query ITTITTTTTTTTBBBB colnames
SELECT * FROM crdb_internal.create_statements WHERE database_name = ''
----
database_id  database_name  schema_name  descriptor_id  descriptor_type  descriptor_name  create_statement  state  create_nofks  alter_statements  validate_statements  create_redactable  has_partitions  is_multi_region  is_virtual  is_temporary

query ITITTBTB colnames
SELECT * FROM crdb_internal.table_columns WHERE descriptor_name = ''
----
descriptor_id  descriptor_name  column_id  column_name  column_type  nullable  default_expr  hidden

query ITITTBBBBITT colnames
SELECT * FROM crdb_internal.table_indexes WHERE descriptor_name = ''
----
descriptor_id  descriptor_name  index_id  index_name  index_type  is_unique  is_inverted  is_sharded  is_visible  shard_bucket_count  created_at  create_statement

query ITITTITTB colnames
SELECT * FROM crdb_internal.index_columns WHERE descriptor_name = ''
----
descriptor_id  descriptor_name  index_id  index_name  column_type  column_id  column_name  column_direction  implicit

query ITIIITITT colnames
SELECT * FROM crdb_internal.backward_dependencies WHERE descriptor_name = ''
----
descriptor_id  descriptor_name  index_id  column_id  dependson_id  dependson_type  dependson_index_id  dependson_name  dependson_details

query ITIITITT colnames
SELECT * FROM crdb_internal.forward_dependencies WHERE descriptor_name = ''
----
descriptor_id  descriptor_name  index_id  dependedonby_id  dependedonby_type  dependedonby_index_id  dependedonby_name  dependedonby_details

query IITTTTTTTTTTTT colnames
SELECT * FROM crdb_internal.zones WHERE false
----
zone_id  subzone_id  target  range_name  database_name  schema_name  table_name  index_name  partition_name
raw_config_yaml  raw_config_sql  raw_config_protobuf full_config_yaml full_config_sql


query IITTT colnames
SELECT * FROM crdb_internal.cluster_inflight_traces WHERE trace_id=123
----
trace_id  node_id  root_op_name  trace_str  jaeger_json

statement error pgcode 0A000 a trace_id value needs to be specified
SELECT * FROM crdb_internal.cluster_inflight_traces

query IIIIBTIT colnames
SELECT * FROM crdb_internal.node_inflight_trace_spans WHERE span_id < 0
----
trace_id  parent_span_id  span_id  goroutine_id  finished  start_time  duration  operation

query ITTTTITTTTTTI colnames
SELECT * FROM crdb_internal.ranges WHERE range_id < 0
----
range_id  start_key  start_pretty  end_key  end_pretty  replicas  replica_localities  voting_replicas  non_voting_replicas  learner_replicas  split_enforced_until  lease_holder  range_size

query ITTTTTTTTTT colnames
SELECT * FROM crdb_internal.ranges_no_leases WHERE range_id < 0
----
range_id  start_key  start_pretty  end_key  end_pretty  replicas  replica_localities  voting_replicas  non_voting_replicas  learner_replicas  split_enforced_until

query TTTBTTTTTIITITTTTTITT colnames
SELECT * FROM crdb_internal.cluster_txn_execution_insights WHERE query = ''
----
txn_id  txn_fingerprint_id  query  implicit_txn  session_id  start_time  end_time  user_name  app_name  rows_read  rows_written  priority  retries  last_retry_reason  contention  problems  causes  stmt_execution_ids cpu_sql_nanos last_error_code status


query TTTBTTTTTIITITTTTTITT colnames
SELECT * FROM crdb_internal.node_txn_execution_insights WHERE query = ''
----
txn_id  txn_fingerprint_id  query  implicit_txn  session_id  start_time  end_time  user_name  app_name  rows_read  rows_written  priority  retries  last_retry_reason  contention  problems  causes  stmt_execution_ids cpu_sql_nanos last_error_code status


statement ok
CREATE SCHEMA schema; CREATE TABLE schema.bar (y INT PRIMARY KEY)

let $schema_bar_id
SELECT 'schema.bar'::regclass::int

statement ok
INSERT INTO system.zones (id, config) VALUES
  (18, (SELECT raw_config_protobuf FROM crdb_internal.zones WHERE zone_id = 0)),
  ($testdb_id, (SELECT raw_config_protobuf FROM crdb_internal.zones WHERE zone_id = 0)),
  ($testdb_foo_id, (SELECT raw_config_protobuf FROM crdb_internal.zones WHERE zone_id = 0)),
  ($schema_bar_id, (SELECT raw_config_protobuf FROM crdb_internal.zones WHERE zone_id = 0))

query IT
SELECT zone_id, target FROM crdb_internal.zones ORDER BY 1
----
0    RANGE default
1    DATABASE system
16   RANGE meta
17   RANGE system
18   RANGE timeseries
22   RANGE liveness
25   TABLE system.public.replication_constraint_stats
27   TABLE system.public.replication_stats
42   TABLE system.public.statement_statistics
43   TABLE system.public.transaction_statistics
45   TABLE system.public.tenant_usage
57   TABLE system.public.span_stats_tenant_boundaries
60   TABLE system.public.statement_activity
61   TABLE system.public.transaction_activity
106  DATABASE testdb
108  TABLE testdb.public.foo
111  TABLE test.schema.bar

query T
SELECT quote_literal(raw_config_yaml) FROM crdb_internal.zones WHERE zone_id = 0
----
e'range_min_bytes: 134217728\nrange_max_bytes: 536870912\ngc:\n  ttlseconds: 14400\nglobal_reads: null\nnum_replicas: 3\nnum_voters: null\nconstraints: []\nvoter_constraints: []\nlease_preferences: []\n'

query T
SELECT raw_config_sql FROM crdb_internal.zones WHERE zone_id = 0
----
ALTER RANGE default CONFIGURE ZONE USING
  range_min_bytes = 134217728,
  range_max_bytes = 536870912,
  gc.ttlseconds = 14400,
  num_replicas = 3,
  constraints = '[]',
  lease_preferences = '[]'

query error pq: foo
SELECT crdb_internal.force_error('', 'foo')

query error pgcode FOOYAA pq: foo
SELECT crdb_internal.force_error('FOOYAA', 'foo')

query I
select crdb_internal.force_retry(interval '0s')
----
0

query error pq: crdb_internal.set_vmodule\(\): syntax error: expect comma-separated list of filename=N
select crdb_internal.set_vmodule('not anything reasonable')

query I
select crdb_internal.set_vmodule('doesntexist=2,butitsok=4')
----
0

query T
select crdb_internal.get_vmodule()
----
doesntexist=2,butitsok=4

query I
select crdb_internal.set_vmodule('')
----
0

query T
select crdb_internal.get_vmodule()
----
·

query T
select regexp_replace(crdb_internal.node_executable_version()::string, '(-\d+)?$', '');
----
23.1

query ITTT colnames
select node_id, component, field, regexp_replace(regexp_replace(value, '^\d+$', '<port>'), e':\\d+', ':<port>') as value from crdb_internal.node_runtime_info
----
node_id  component  field   value
1        DB         URL     postgresql://root@127.0.0.1:<port>/defaultdb?sslcert=test_certs%2Fclient.root.crt&sslkey=test_certs%2Fclient.root.key&sslmode=verify-full&sslrootcert=test_certs%2Fca.crt
1        DB         Scheme  postgresql
1        DB         User    root
1        DB         Host    127.0.0.1
1        DB         Port    <port>
1        DB         URI     /defaultdb?sslcert=test_certs%2Fclient.root.crt&sslkey=test_certs%2Fclient.root.key&sslmode=verify-full&sslrootcert=test_certs%2Fca.crt
1        UI         URL     https://127.0.0.1:<port>
1        UI         Scheme  https
1        UI         User    ·
1        UI         Host    127.0.0.1
1        UI         Port    <port>
1        UI         URI     /

query ITTTTT colnames
SELECT node_id, network, regexp_replace(address, '\d+$', '<port>') as address, attrs, locality, regexp_replace(server_version, '^\d+\.\d+(-\d+)?$', '<server_version>') as server_version FROM crdb_internal.gossip_nodes WHERE node_id = 1
----
node_id  network  address           attrs  locality            server_version
1        tcp      127.0.0.1:<port>  []     region=test,dc=dc1  <server_version>

query ITTBBT colnames
SELECT node_id, regexp_replace(epoch::string, '^\d+$', '<epoch>') as epoch, regexp_replace(expiration, '^(\d+\.)?\d+,\d+$', '<timestamp>') as expiration, draining, decommissioning, membership FROM crdb_internal.gossip_liveness WHERE node_id = 1
----
node_id  epoch        expiration    draining  decommissioning     membership
1        <epoch>      <timestamp>   false     false               active

query ITTTTTT colnames
SELECT node_id, network, regexp_replace(address, '\d+$', '<port>') as address, attrs, locality, regexp_replace(server_version, '^\d+\.\d+(-\d+)?$', '<server_version>') as server_version, regexp_replace(go_version, '^go.+$', '<go_version>') as go_version
FROM crdb_internal.kv_node_status WHERE node_id = 1
----
node_id  network  address           attrs  locality            server_version    go_version
1        tcp      127.0.0.1:<port>  []     region=test,dc=dc1  <server_version>  <go_version>

query IITI colnames
SELECT node_id, store_id, attrs, used
FROM crdb_internal.kv_store_status WHERE node_id = 1
----
node_id  store_id  attrs  used
1        1         []     0

statement ok
CREATE TABLE foo (a INT PRIMARY KEY, INDEX idx(a)); INSERT INTO foo VALUES(1)

statement ok
ALTER TABLE foo SPLIT AT VALUES(2)

query TTT colnames
SELECT start_pretty, end_pretty, split_enforced_until FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty    end_pretty  split_enforced_until
/Table/112/1/2  /Max        2262-04-11 23:47:16.854776 +0000 +0000

query TTT colnames
SELECT start_key, end_key, split_enforced_until FROM [SHOW RANGES FROM TABLE foo] WHERE split_enforced_until IS NOT NULL
----
start_key  end_key       split_enforced_until
…/1/2      <after:/Max>  2262-04-11 23:47:16.854776 +0000 +0000

statement ok
ALTER TABLE foo UNSPLIT AT VALUES(2)

query TT colnames
SELECT start_key, end_key FROM [SHOW RANGES FROM TABLE foo] WHERE split_enforced_until IS NOT NULL
----
start_key  end_key

statement ok
ALTER TABLE foo SPLIT AT VALUES(2) WITH EXPIRATION '2200-01-01 00:00:00.0'

query TTT colnames
SELECT start_key, end_key, split_enforced_until FROM [SHOW RANGES FROM TABLE foo] WHERE split_enforced_until IS NOT NULL
----
start_key  end_key       split_enforced_until
…/1/2      <after:/Max>  2200-01-01 00:00:00 +0000 +0000

statement ok
ALTER TABLE foo SPLIT AT VALUES (1), (2), (3)

statement ok
ALTER TABLE foo UNSPLIT ALL

query TT colnames
SELECT start_pretty, end_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty  end_pretty

query TT colnames
SELECT start_pretty, end_pretty FROM crdb_internal.ranges_no_leases WHERE split_enforced_until IS NOT NULL
----
start_pretty  end_pretty

# Make sure that the cluster id isn't unset.
query B
select crdb_internal.cluster_id() != '00000000-0000-0000-0000-000000000000' FROM foo
----
true

# Check that privileged builtins are only allowed for 'root'
user testuser

query error insufficient privilege
select crdb_internal.force_panic('foo')

query error insufficient privilege
select crdb_internal.force_log_fatal('foo')

query error insufficient privilege
select crdb_internal.set_vmodule('')

query error insufficient privilege
select crdb_internal.get_vmodule()

query error pq: only users with the admin role are allowed to access the node runtime information
select * from crdb_internal.node_runtime_info

query error pq: only users with the VIEWACTIVITY or VIEWACTIVITYREDACTED or ZONECONFIG privilege or the admin role can read crdb_internal.ranges_no_leases
select * from crdb_internal.ranges

query error pq: only users with the VIEWACTIVITY or VIEWACTIVITYREDACTED or ZONECONFIG privilege or the admin role can read crdb_internal.ranges_no_leases
SHOW RANGES FROM TABLE foo

query error pq: only users with the admin role are allowed to read crdb_internal.gossip_nodes
select * from crdb_internal.gossip_nodes

query error pq: only users with the admin role are allowed to read crdb_internal.gossip_liveness
select * from crdb_internal.gossip_liveness

query error pq: only users with the admin role are allowed to read crdb_internal.node_metrics
select * from crdb_internal.node_metrics

query error pq: only users with the admin role are allowed to read crdb_internal.kv_node_status
select * from crdb_internal.kv_node_status

query error pq: only users with the admin role are allowed to read crdb_internal.kv_store_status
select * from crdb_internal.kv_store_status

query error pq: only users with the admin role are allowed to read crdb_internal.gossip_alerts
select * from crdb_internal.gossip_alerts

query error pq: only users with the admin role are allowed to read crdb_internal.node_inflight_trace_spans
select * from crdb_internal.node_inflight_trace_spans

query error pq: crdb_internal.check_consistency requires admin privileges
SELECT * FROM crdb_internal.check_consistency(true, b'\x02', b'\x04')

# Anyone can see the executable version.
query T
select regexp_replace(crdb_internal.node_executable_version()::string, '(-\d+)?$', '');
----
23.1

user root

# Regression test for #34441
query T
SELECT crdb_internal.pretty_key(e'\\xa82a00918ed9':::BYTES, (-5096189069466142898):::INT8);
----
/Table/32/???/9/6/81

subtest max_retry_counter
# Verify that the max_retry counter in statement stats actually increases with retries.

statement ok
SET application_name = 'test_max_retry'

# Make the statement retry, to ensure max_retries increases to
# become different from 0.
statement OK
CREATE SEQUENCE s;

statement OK
SELECT IF(nextval('s')<3, crdb_internal.force_retry('1h'::INTERVAL), 0);

statement OK
DROP SEQUENCE s

statement OK
RESET application_name

# Note: in the following test, three rows of output are expected:
# - one for the SELECT statements that failed with a retry error,
# - one for the final SELECT retry attempt that succeeded without an error,
# - one for the RESET statement.
#
# We expect the first two entries to have max_retries > 0 because
# auto-retries are expected by the server.
# We also expect the RESET statement to have max_retries = 0, because
# RESET never retries. This tests that the retry counter is properly
# reset to 0 between statements - a naive implementation could make
# the counter increase forever, even between statements.
#
# TODO(radu): there should be a single fingerprint, with ::INTERVAL. The
# different fingerprint on retries is caused by in-place mutation of the AST
# (#22847).
#
query TIB
SELECT key, max_retries, flags LIKE '!%' AS f
  FROM crdb_internal.node_statement_statistics
 WHERE application_name = 'test_max_retry'
ORDER BY key, f
----
CREATE SEQUENCE s                                                         0  false
DROP SEQUENCE s                                                           0  false
RESET application_name                                                    0  false
SELECT IF(nextval('_') < _, crdb_internal.force_retry('_'::INTERVAL), _)  0  true
SELECT IF(nextval(_) < _, crdb_internal.force_retry(_), _)                2  false
SELECT IF(nextval(_) < _, crdb_internal.force_retry(_), _)                1  true

query T
SELECT database_name FROM crdb_internal.node_statement_statistics limit 1
----
test

# Testing split_enforced_until when truncating and dropping.
statement ok
ALTER TABLE foo SPLIT AT VALUES (1), (2), (3)

statement ok
ALTER INDEX foo@idx SPLIT AT VALUES (1), (2), (3)

query TT colnames
SELECT start_pretty, end_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty    end_pretty
/Table/112/1/1  /Table/112/1/2
/Table/112/1/2  /Table/112/1/3
/Table/112/1/3  /Table/112/2/1
/Table/112/2/1  /Table/112/2/2
/Table/112/2/2  /Table/112/2/3
/Table/112/2/3  /Max

# The cleanup we expect in the following truncate requires that the GCJob runs.
# To avoid this taking 30 seconds, we lower the job adoption interval.
statement ok
SET CLUSTER SETTING jobs.registry.interval.adopt = '1s'

statement ok
TRUNCATE TABLE foo

# Ensure that there are no longer any splits left over on the original indexes.
# TRUNCATE will have created equivalent splits points on the new indexes, so
# this test just checks that there are no more on the old indexes.
query TT retry
SELECT start_pretty, end_pretty FROM crdb_internal.ranges
WHERE split_enforced_until IS NOT NULL
AND (start_pretty LIKE '/Table/112/1%' OR start_pretty LIKE '/Table/112/2%')
----

statement ok
ALTER TABLE foo SPLIT AT VALUES (1), (2), (3)

statement ok
ALTER INDEX foo@idx SPLIT AT VALUES (1), (2), (3)

query TT colnames,retry
SELECT start_pretty, end_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty    end_pretty
/Table/112/3/1  /Table/112/3/2
/Table/112/3/2  /Table/112/3/3
/Table/112/3/3  /Table/112/4/1
/Table/112/4/1  /Table/112/4/2
/Table/112/4/2  /Table/112/4/3
/Table/112/4/3  /Max

statement ok
DROP TABLE foo

query TT colnames,retry
SELECT start_pretty, end_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty   end_pretty

statement ok
CREATE TABLE foo (a INT PRIMARY KEY, INDEX idx(a)); INSERT INTO foo VALUES(1)

statement ok
ALTER TABLE foo SPLIT AT VALUES (1), (2), (3)

statement ok
ALTER INDEX foo@idx SPLIT AT VALUES (1), (2), (3)

query TT colnames,retry
SELECT start_pretty, end_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty    end_pretty
/Table/114/1/1  /Table/114/1/2
/Table/114/1/2  /Table/114/1/3
/Table/114/1/3  /Table/114/2/1
/Table/114/2/1  /Table/114/2/2
/Table/114/2/2  /Table/114/2/3
/Table/114/2/3  /Max

statement ok
DROP INDEX foo@idx

# Verify only the start keys of the manually split ranges because the merge queue could merge the
# ranges [/Table/58/1/3, /Table/58/2/1) with its right neighbors.
query T colnames,retry
SELECT start_pretty FROM crdb_internal.ranges WHERE split_enforced_until IS NOT NULL
----
start_pretty
/Table/114/1/1
/Table/114/1/2
/Table/114/1/3

query T
SELECT crdb_internal.cluster_name()
----
testclustername

# Regression for 41834.
statement ok
CREATE TABLE table41834 ();
SELECT
	crdb_internal.encode_key(
		-8912529861854991652,
		0,
		CASE
		WHEN false THEN (NULL,)
		ELSE (NULL,)
		END
	)
FROM
	table41834;

# Compact a range at this node, store.
query II colnames
SELECT node_id, store_id FROM crdb_internal.kv_store_status ORDER BY (node_id, store_id) LIMIT 1
----
node_id  store_id
1        1

# Do the compaction.
query B colnames
SELECT crdb_internal.compact_engine_span(1, 1, raw_start_key, raw_end_key)
FROM [SHOW RANGES FROM TABLE foo WITH KEYS]
LIMIT 1
----
crdb_internal.compact_engine_span
true

# Failed compaction due to unknown node.
query error could not dial node ID 153
SELECT crdb_internal.compact_engine_span(153, 1, decode('c08989', 'hex'), decode('c0898a', 'hex'))

# Failed compaction due to unknown store.
query error store 23 was not found
SELECT crdb_internal.compact_engine_span(1, 23, decode('c08989', 'hex'), decode('c0898a', 'hex'))

# Failed compaction due to invalid range.
query error is not less than end
SELECT crdb_internal.compact_engine_span(1, 1, decode('c0898a', 'hex'), decode('c08989', 'hex'))

user testuser
query error crdb_internal.compact_engine_span\(\): insufficient privilege
SELECT crdb_internal.compact_engine_span(1, 1, decode('c08989', 'hex'), decode('c0898a', 'hex'))

subtest builtin_is_admin

user root

query B
SELECT crdb_internal.is_admin()
----
true

user testuser

query B
SELECT crdb_internal.is_admin()
----
false

user root

# Test the crdb_internal.create_type_statements table.
statement ok
CREATE TYPE enum1 AS ENUM ('hello', 'hi');
CREATE TYPE enum2 AS ENUM ()

query ITTITTT
SELECT * FROM crdb_internal.create_type_statements
----
104  test  public  116  enum1  CREATE TYPE public.enum1 AS ENUM ('hello', 'hi')  {hello,hi}
104  test  public  118  enum2  CREATE TYPE public.enum2 AS ENUM ()               {}

# Test the virtual index as well.

query ITTITTT
SELECT * FROM crdb_internal.create_type_statements WHERE descriptor_id = (('enum1'::regtype::oid::int) - 100000)::oid
----
104  test  public  116  enum1  CREATE TYPE public.enum1 AS ENUM ('hello', 'hi')  {hello,hi}

query ITTITTT
SELECT * FROM crdb_internal.create_type_statements WHERE descriptor_id = 'foo'::regclass::oid
----

statement ok
SET application_name = "test_txn_statistics"

statement ok
CREATE TABLE t_53504()

statement ok
BEGIN; SELECT * FROM t_53504; SELECT * FROM t_53504; SELECT * FROM t_53504; COMMIT;

statement ok
BEGIN; SELECT * FROM t_53504; SELECT * FROM t_53504; COMMIT;

statement ok
BEGIN; SELECT * FROM t_53504; SELECT * FROM t_53504; COMMIT;

statement ok
BEGIN; SELECT * FROM t_53504; COMMIT;

statement ok
SELECT * FROM t_53504

query ITTTI colnames
SELECT node_id, application_name, key, statement_ids, count FROM crdb_internal.node_transaction_statistics where application_name = 'test_txn_statistics'
----
node_id  application_name     key                   statement_ids                                                  count
1        test_txn_statistics  10922505138341351577  {4104808689124681542}                                          1
1        test_txn_statistics  12762606372390135532  {8833422719858486605,8833422719858486605,8833422719858486605}  1
1        test_txn_statistics  15417266716795083410  {8833422719858486605}                                          1
1        test_txn_statistics  15417266716795083422  {8833422719858486593}                                          1
1        test_txn_statistics  17236010932163349339  {8833422719858486605,8833422719858486605}                      2

## crdb_internal.cluster_database_privileges
subtest cluster_database_privileges

statement ok
CREATE DATABASE other_db; SET DATABASE = other_db

query TTTT colnames
SELECT * FROM crdb_internal.cluster_database_privileges
----
database_name  grantee  privilege_type  is_grantable
other_db       admin    ALL             YES
other_db       public   CONNECT         NO
other_db       root     ALL             YES

statement ok
GRANT CONNECT ON DATABASE other_db TO testuser;
GRANT DROP ON DATABASE other_db TO testuser

query TTTT colnames
SELECT * FROM crdb_internal.cluster_database_privileges
----
database_name  grantee   privilege_type  is_grantable
other_db       admin     ALL             YES
other_db       public    CONNECT         NO
other_db       root      ALL             YES
other_db       testuser  CONNECT         NO
other_db       testuser  DROP            NO

statement ok
SET DATABASE = test

## crdb_internal.invalid_objects
subtest invalid_objects

query ITTTT colnames
SELECT * FROM crdb_internal.invalid_objects
----
id  database_name  schema_name  obj_name  error

# corrupt the namespace table
statement ok
SELECT crdb_internal.unsafe_upsert_namespace_entry(0, 0, 'baddb', 500, true);
SELECT crdb_internal.unsafe_upsert_namespace_entry(1, 0, 'badschema', 501, true);
SELECT crdb_internal.unsafe_upsert_namespace_entry(1, 29, 'badobj', 502, true);
SELECT crdb_internal.unsafe_upsert_namespace_entry(1, 404, 'badobj', 503, true);

query ITTTT colnames
SELECT * FROM "".crdb_internal.invalid_objects
----
id   database_name  schema_name  obj_name  error
500  baddb          ·            ·         referenced descriptor not found
501  system         badschema    ·         referenced descriptor not found
502  system         public       badobj    referenced descriptor not found
503  system         [404]        badobj    referenced descriptor not found

statement ok
SELECT crdb_internal.unsafe_delete_namespace_entry(0, 0, 'baddb', 500, true);
SELECT crdb_internal.unsafe_delete_namespace_entry(1, 0, 'badschema', 501, true);
SELECT crdb_internal.unsafe_delete_namespace_entry(1, 29, 'badobj', 502, true);
SELECT crdb_internal.unsafe_delete_namespace_entry(1, 404, 'badobj', 503, true);

query ITTTT colnames
SELECT * FROM crdb_internal.invalid_objects
----
id  database_name  schema_name  obj_name  error

# crdb_internal can be used with the anonymous database.
# It should show information across all databases.
subtest anonymous_database

query TTTT colnames
SELECT * FROM "".crdb_internal.cluster_database_privileges ORDER BY 1,2,3
----
database_name  grantee   privilege_type  is_grantable
defaultdb      admin     ALL             YES
defaultdb      public    CONNECT         NO
defaultdb      root      ALL             YES
other_db       admin     ALL             YES
other_db       public    CONNECT         NO
other_db       root      ALL             YES
other_db       testuser  CONNECT         NO
other_db       testuser  DROP            NO
postgres       admin     ALL             YES
postgres       public    CONNECT         NO
postgres       root      ALL             YES
system         admin     CONNECT         YES
system         root      CONNECT         YES
test           admin     ALL             YES
test           public    CONNECT         NO
test           root      ALL             YES
testdb         admin     ALL             YES
testdb         public    CONNECT         NO
testdb         root      ALL             YES

statement ok
SET DATABASE = "";

query TTTT colnames
SELECT * FROM crdb_internal.cluster_database_privileges ORDER BY 1,2,3
----
database_name  grantee   privilege_type  is_grantable
defaultdb      admin     ALL             YES
defaultdb      public    CONNECT         NO
defaultdb      root      ALL             YES
other_db       admin     ALL             YES
other_db       public    CONNECT         NO
other_db       root      ALL             YES
other_db       testuser  CONNECT         NO
other_db       testuser  DROP            NO
postgres       admin     ALL             YES
postgres       public    CONNECT         NO
postgres       root      ALL             YES
system         admin     CONNECT         YES
system         root      CONNECT         YES
test           admin     ALL             YES
test           public    CONNECT         NO
test           root      ALL             YES
testdb         admin     ALL             YES
testdb         public    CONNECT         NO
testdb         root      ALL             YES

statement ok
SET DATABASE = test

# Test crdb_internal.create_statements functionality.

statement ok
CREATE TABLE normal_table()

query B
SELECT is_virtual FROM crdb_internal.create_statements WHERE descriptor_name = 'normal_table'
----
false

query B
SELECT is_virtual FROM crdb_internal.create_statements WHERE descriptor_name = 'pg_views'
----
true

query B
SELECT is_temporary FROM crdb_internal.create_statements WHERE descriptor_name = 'normal_table'
----
false

statement ok
SET experimental_enable_temp_tables = 'on';
CREATE TEMPORARY TABLE temp()

query B
SELECT is_temporary FROM crdb_internal.create_statements WHERE descriptor_name = 'temp'
----
true

query TT
SELECT * FROM crdb_internal.regions ORDER BY 1
----
test  {}

# Regression test for incorrectly handling tree.DOidWrappers by some builtins
# (#69684).
statement ok
CREATE TABLE t69684(a NAME);
INSERT INTO t69684 VALUES ('foo');
SELECT * FROM t69684 WHERE crdb_internal.increment_feature_counter(a)

# Just verify that crdb_internal.probe_ranges doesn't error when called.
# The output is non-deterministic.
statement ok
SELECT crdb_internal.probe_ranges(INTERVAL '1000ms', 'write')

# Regression test for not handling NULL values correctly by an internal builtin
# (#82056 and #95671).
query I
SELECT crdb_internal.num_inverted_index_entries(NULL::STRING, 0)
----
0

query I
SELECT crdb_internal.num_inverted_index_entries(NULL::TSVECTOR, NULL::INT8)
----
0

# Exercise unsafe gossip builtin functions.
query B
SELECT crdb_internal.unsafe_clear_gossip_info('unknown key')
----
false

# Verify users with VIEWCLUSTERSETTING, MODIFYCLUSTERSETTING or MODIFYSQLCLUSTERSETTING can view non sql.defaults cluster settings.

user root

statement ok
GRANT SYSTEM VIEWCLUSTERSETTING TO testuser

user testuser

query T
SELECT value FROM crdb_internal.cluster_settings WHERE variable IN ('diagnostics.reporting.enabled')
----
true

user root

statement ok
REVOKE SYSTEM VIEWCLUSTERSETTING FROM testuser

statement ok
GRANT SYSTEM MODIFYCLUSTERSETTING TO testuser

user testuser

query T
SELECT value FROM crdb_internal.cluster_settings WHERE variable IN ('diagnostics.reporting.enabled')
----
true

user root

statement ok
REVOKE SYSTEM MODIFYCLUSTERSETTING FROM testuser

query TT
SELECT crdb_internal.humanize_bytes(NULL), crdb_internal.humanize_bytes(102400)
----
NULL 100 KiB

# Sanity checks of the crdb_internal.node_memory_monitors table.

# The root monitor has a standalone budget, so its 'used' field is zero.
query BB
SELECT used = 0, reserved_used > 0 FROM crdb_internal.node_memory_monitors WHERE name = 'root'
----
true true

query B
SELECT used > 0 FROM crdb_internal.node_memory_monitors WHERE name = 'sql'
----
true

# Run a query on one connection and observe it from another.
user testuser

statement async sleepQuery count 1
SELECT pg_sleep(3)

user root

query B
SELECT count(*) > 0 FROM crdb_internal.node_memory_monitors WHERE name LIKE '%flow%'
----
true

user testuser

awaitstatement sleepQuery

user root

statement ok
GRANT SYSTEM MODIFYSQLCLUSTERSETTING TO testuser

user testuser

query T
SELECT value FROM crdb_internal.cluster_settings WHERE variable IN ('diagnostics.reporting.enabled')
----
true

user root

statement ok
REVOKE SYSTEM MODIFYSQLCLUSTERSETTING FROM testuser

# test privileges/roles for contention related tables
user testuser

statement error pq: user testuser does not have VIEWACTIVITY or VIEWACTIVITYREDACTED privilege
SELECT * FROM crdb_internal.node_contention_events

statement error pq: user testuser does not have VIEWACTIVITY or VIEWACTIVITYREDACTED privilege
SELECT * FROM crdb_internal.transaction_contention_events

statement error pq: user testuser does not have VIEWACTIVITY or VIEWACTIVITYREDACTED privilege
SELECT * FROM crdb_internal.cluster_locks

user root

statement ok
GRANT SYSTEM VIEWACTIVITYREDACTED TO testuser

user testuser

statement ok
SELECT * FROM crdb_internal.node_contention_events

statement ok
SELECT * FROM crdb_internal.transaction_contention_events

statement ok
SELECT * FROM crdb_internal.cluster_locks

user root

statement ok
REVOKE SYSTEM VIEWACTIVITYREDACTED FROM testuser

statement ok
GRANT SYSTEM VIEWACTIVITY TO testuser

user testuser

statement ok
SELECT * FROM crdb_internal.node_contention_events

statement ok
SELECT * FROM crdb_internal.transaction_contention_events

statement ok
SELECT * FROM crdb_internal.cluster_locks

user root

statement ok
REVOKE SYSTEM VIEWACTIVITY FROM testuser
