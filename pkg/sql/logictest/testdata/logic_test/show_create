statement ok
SET experimental_enable_unique_without_index_constraints = true

statement ok
CREATE TABLE c (
  a INT NOT NULL,
  b INT NULL,
  INDEX c_a_b_idx (a ASC, b ASC),
  UNIQUE WITHOUT INDEX (a, b),
  CONSTRAINT unique_a_partial UNIQUE WITHOUT INDEX (a) WHERE b > 0,
  FAMILY fam_0_a_rowid (a, rowid),
  FAMILY fam_1_b (b)
)

statement ok
COMMENT ON TABLE c IS 'table'

statement ok
COMMENT ON COLUMN c.a IS 'column'

statement ok
COMMENT ON INDEX c_a_b_idx IS 'index'

statement ok
CREATE TABLE d (d INT PRIMARY KEY)

query TT colnames
SHOW CREATE c
----
table_name  create_statement
c           CREATE TABLE public.c (
              a INT8 NOT NULL,
              b INT8 NULL,
              rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
              CONSTRAINT c_pkey PRIMARY KEY (rowid ASC),
              INDEX c_a_b_idx (a ASC, b ASC),
              FAMILY fam_0_a_rowid (a, rowid),
              FAMILY fam_1_b (b),
              CONSTRAINT unique_a_b UNIQUE WITHOUT INDEX (a, b),
              CONSTRAINT unique_a_partial UNIQUE WITHOUT INDEX (a) WHERE b > 0:::INT8
            );
            COMMENT ON TABLE public.c IS 'table';
            COMMENT ON COLUMN public.c.a IS 'column';
            COMMENT ON INDEX public.c@c_a_b_idx IS 'index'

statement ok
ALTER TABLE c ADD CONSTRAINT check_b CHECK (b IN (1, 2, 3)) NOT VALID;
ALTER TABLE c ADD CONSTRAINT fk_a FOREIGN KEY (a) REFERENCES d (d) NOT VALID;
ALTER TABLE c ADD CONSTRAINT unique_a UNIQUE (a);
ALTER TABLE c ADD CONSTRAINT unique_b UNIQUE WITHOUT INDEX (b) NOT VALID;
ALTER TABLE c ADD CONSTRAINT unique_b_partial UNIQUE WITHOUT INDEX (b) WHERE a > 0 NOT VALID;

query TT
SHOW CREATE c
----
c  CREATE TABLE public.c (
     a INT8 NOT NULL,
     b INT8 NULL,
     rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
     CONSTRAINT c_pkey PRIMARY KEY (rowid ASC),
     CONSTRAINT fk_a FOREIGN KEY (a) REFERENCES public.d(d) NOT VALID,
     INDEX c_a_b_idx (a ASC, b ASC),
     UNIQUE INDEX unique_a (a ASC),
     FAMILY fam_0_a_rowid (a, rowid),
     FAMILY fam_1_b (b),
     CONSTRAINT check_b CHECK (b IN (1:::INT8, 2:::INT8, 3:::INT8)) NOT VALID,
     CONSTRAINT unique_a_b UNIQUE WITHOUT INDEX (a, b),
     CONSTRAINT unique_a_partial UNIQUE WITHOUT INDEX (a) WHERE b > 0:::INT8,
     CONSTRAINT unique_b UNIQUE WITHOUT INDEX (b) NOT VALID,
     CONSTRAINT unique_b_partial UNIQUE WITHOUT INDEX (b) WHERE a > 0:::INT8 NOT VALID
   );
   COMMENT ON TABLE public.c IS 'table';
   COMMENT ON COLUMN public.c.a IS 'column';
   COMMENT ON INDEX public.c@c_a_b_idx IS 'index'

statement ok
ALTER TABLE c VALIDATE CONSTRAINT check_b;
ALTER TABLE c VALIDATE CONSTRAINT fk_a;
ALTER TABLE c VALIDATE CONSTRAINT unique_a;
ALTER TABLE c VALIDATE CONSTRAINT unique_b;
ALTER TABLE c VALIDATE CONSTRAINT unique_a_b;
ALTER TABLE c VALIDATE CONSTRAINT unique_b_partial;

query TT
SHOW CREATE c
----
c  CREATE TABLE public.c (
     a INT8 NOT NULL,
     b INT8 NULL,
     rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
     CONSTRAINT c_pkey PRIMARY KEY (rowid ASC),
     CONSTRAINT fk_a FOREIGN KEY (a) REFERENCES public.d(d),
     INDEX c_a_b_idx (a ASC, b ASC),
     UNIQUE INDEX unique_a (a ASC),
     FAMILY fam_0_a_rowid (a, rowid),
     FAMILY fam_1_b (b),
     CONSTRAINT check_b CHECK (b IN (1:::INT8, 2:::INT8, 3:::INT8)),
     CONSTRAINT unique_a_b UNIQUE WITHOUT INDEX (a, b),
     CONSTRAINT unique_a_partial UNIQUE WITHOUT INDEX (a) WHERE b > 0:::INT8,
     CONSTRAINT unique_b UNIQUE WITHOUT INDEX (b),
     CONSTRAINT unique_b_partial UNIQUE WITHOUT INDEX (b) WHERE a > 0:::INT8
   );
   COMMENT ON TABLE public.c IS 'table';
   COMMENT ON COLUMN public.c.a IS 'column';
   COMMENT ON INDEX public.c@c_a_b_idx IS 'index'

query TT
SHOW CREATE c WITH REDACT
----
c  CREATE TABLE public.c (
     a INT8 NOT NULL,
     b INT8 NULL,
     rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
     CONSTRAINT c_pkey PRIMARY KEY (rowid ASC),
     CONSTRAINT fk_a FOREIGN KEY (a) REFERENCES public.d(d),
     INDEX c_a_b_idx (a ASC, b ASC),
     UNIQUE INDEX unique_a (a ASC),
     FAMILY fam_0_a_rowid (a, rowid),
     FAMILY fam_1_b (b),
     CONSTRAINT check_b CHECK (b IN (‹×›:::INT8, ‹×›:::INT8, ‹×›:::INT8)),
     CONSTRAINT unique_a_b UNIQUE WITHOUT INDEX (a, b),
     CONSTRAINT unique_a_partial UNIQUE WITHOUT INDEX (a) WHERE b > ‹×›:::INT8,
     CONSTRAINT unique_b UNIQUE WITHOUT INDEX (b),
     CONSTRAINT unique_b_partial UNIQUE WITHOUT INDEX (b) WHERE a > ‹×›:::INT8
   );
   COMMENT ON TABLE public.c IS 'table';
   COMMENT ON COLUMN public.c.a IS 'column';
   COMMENT ON INDEX public.c@c_a_b_idx IS 'index'

subtest alter_column_type_not_break_show_create

statement ok
SET enable_experimental_alter_column_type_general = true;

statement ok
CREATE TABLE t (c INT);

statement ok
COMMENT ON COLUMN t.c IS 'first comment';

query T
SELECT create_statement FROM [SHOW CREATE TABLE t];
----
CREATE TABLE public.t (
  c INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t_pkey PRIMARY KEY (rowid ASC)
);
COMMENT ON COLUMN public.t.c IS 'first comment'

statement ok
ALTER TABLE t ALTER COLUMN c TYPE character varying;

query T
SELECT create_statement FROM [SHOW CREATE TABLE t];
----
CREATE TABLE public.t (
  c VARCHAR NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t_pkey PRIMARY KEY (rowid ASC)
);
COMMENT ON COLUMN public.t.c IS 'first comment'

query T
SELECT create_statement FROM [SHOW CREATE TABLE t WITH REDACT];
----
CREATE TABLE public.t (
  c VARCHAR NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t_pkey PRIMARY KEY (rowid ASC)
);
COMMENT ON COLUMN public.t.c IS 'first comment'


statement ok
CREATE TABLE t1 (
  k INT PRIMARY KEY,
  a INT UNIQUE,
  b STRING,
  INDEX (a, b)
)

query TT
SELECT * FROM [SHOW CREATE INDEXES FROM t1] ORDER BY index_name
----
t1_a_b_idx  CREATE INDEX t1_a_b_idx ON public.t1 (a ASC, b ASC)
t1_a_key    CREATE UNIQUE INDEX t1_a_key ON public.t1 (a ASC)
t1_pkey     CREATE UNIQUE INDEX t1_pkey ON public.t1 (k ASC)

query TT
SELECT * FROM [SHOW CREATE SECONDARY INDEXES FROM t1] ORDER BY index_name
----
t1_a_b_idx  CREATE INDEX t1_a_b_idx ON public.t1 (a ASC, b ASC)
t1_a_key    CREATE UNIQUE INDEX t1_a_key ON public.t1 (a ASC)

statement error relation "nonexistent" does not exist
SHOW CREATE INDEXES FROM nonexistent

statement error relation "nonexistent" does not exist
SHOW CREATE SECONDARY INDEXES FROM nonexistent
