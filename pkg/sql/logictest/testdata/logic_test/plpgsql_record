# LogicTest: !local-mixed-23.1

subtest simple_return

# Infer return type for a single return statement.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW(0);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(0)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW(0.0124::DECIMAL);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(0.0124)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW(False);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(f)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW('abcdef');
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(abcdef)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW('2001-01-01'::TIMESTAMP);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
("2001-01-01 00:00:00")

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN ROW(NULL);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
()

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  BEGIN
    RETURN NULL;
  END
$$ LANGUAGE PLpgSQL;

# TODO(drewk): Postgres returns NULL, not a tuple with a NULL element.
query T
SELECT f();
----
()

subtest non_constant

# Infer type for non-constant expressions.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  DECLARE
    x INT := 100;
  BEGIN
    RETURN ROW(x);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(100)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  DECLARE
    x INT := 100;
    y INT := 200;
  BEGIN
    RETURN ROW(x+y);
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
(300)

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS RECORD AS $$
  DECLARE
    x INT := 100;
    y INT := 200;
  BEGIN
    RETURN ROW(format('%L + %L', x, y));
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
("'100' + '200'")

subtest multiple_returns

# Infer return type for multiple returns.
statement ok
DROP FUNCTION f(INT);
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  BEGIN
    IF n = 0 THEN
      RETURN ROW(1);
    ELSE
      RETURN ROW(2);
    END IF;
  END
$$ LANGUAGE PLpgSQL;

query TT
SELECT f(0), f(1);
----
(1)  (2)

statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  BEGIN
    IF n = 0 THEN
      RETURN ROW(True);
    ELSE
      RETURN ROW(False);
    END IF;
  END
$$ LANGUAGE PLpgSQL;

query TT
SELECT f(0), f(1);
----
(t)  (f)

# Infer type with one NULL branch.
statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  BEGIN
    IF n = 0 THEN
      RETURN ROW(100);
    ELSE
      RETURN NULL;
    END IF;
  END
$$ LANGUAGE PLpgSQL;

query TT
SELECT f(0), f(1);
----
(100)  NULL

statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  BEGIN
    IF n = 0 THEN
      RETURN NULL;
    ELSE
      RETURN ROW(100);
    END IF;
  END
$$ LANGUAGE PLpgSQL;

query TT
SELECT f(0), f(1);
----
NULL  (100)

subtest infer_loops

# Test interaction with loops.
statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  DECLARE
    i INT := 0;
  BEGIN
    WHILE i < 5 LOOP
      IF i = n THEN
        RETURN ROW(i);
      END IF;
      i := i + 1;
    END LOOP;
    RETURN ROW(100);
  END
$$ LANGUAGE PLpgSQL;

query TTTTT
SELECT f(0), f(1), f(3), f(5), f(10);
----
(0)  (1)  (3)  (100)  (100)

statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS RECORD AS $$
  DECLARE
    i INT := 0;
  BEGIN
    WHILE i < 5 LOOP
      IF i = n THEN
        RETURN ROW(i::TEXT);
      END IF;
      i := i + 1;
    END LOOP;
    RETURN ROW('f');
  END
$$ LANGUAGE PLpgSQL;

query TTTTT
SELECT f(0), f(1), f(3), f(5), f(10);
----
(0)  (1)  (3)  (f)  (f)

subtest end
