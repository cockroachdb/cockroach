# LogicTest: local

# Test that unique indexes work correctly with swap mutations.

statement ok
CREATE TABLE xyz (
  x INT PRIMARY KEY,
  y INT,
  z INT,
  UNIQUE INDEX (y),
  FAMILY (x, y, z)
)

statement ok
INSERT INTO xyz VALUES (1, 1, 1), (2, 2, 2)

# This statement should fail with a dupe key error.

statement error duplicate key value violates unique constraint "xyz_y_key"
UPDATE xyz SET y = 1 WHERE x = 2 AND y = 2 AND z = 2

query III
SELECT * FROM xyz ORDER BY x
----
1  1  1
2  2  2

# This statement should succeed and modify 0 rows, because no rows have z = 3.

statement ok
UPDATE xyz SET y = 1 WHERE x = 2 AND y = 2 AND z = 3

query III
SELECT * FROM xyz ORDER BY x
----
1  1  1
2  2  2

# Test rollback of swap mutations.

statement ok
BEGIN

statement ok
UPDATE xyz SET z = 11 WHERE x = 1 AND y = 1 AND z = 1

query III
SELECT * FROM xyz ORDER BY x
----
1  1  11
2  2  2

statement ok
SAVEPOINT a

statement ok
UPDATE xyz SET z = 12 WHERE x = 2 AND y = 2 AND z = 2

query III
SELECT * FROM xyz ORDER BY x
----
1  1  11
2  2  12

statement ok
ROLLBACK TO a

statement ok
UPDATE xyz SET z = 21 WHERE x = 1 AND y = 1 AND z = 11

query III
SELECT * FROM xyz ORDER BY x
----
1  1  21
2  2  2

statement ok
SAVEPOINT b

# This should do nothing.

statement ok
UPDATE xyz SET z = 31 WHERE x = 1 AND y = 1 AND z = 11

query III
SELECT * FROM xyz ORDER BY x
----
1  1  21
2  2  2

statement ok
ROLLBACK TO b

query III
SELECT * FROM xyz ORDER BY x
----
1  1  21
2  2  2

statement ok
ROLLBACK TO a

query III
SELECT * FROM xyz ORDER BY x
----
1  1  11
2  2  2

# This should do nothing.

statement ok
UPDATE xyz SET z = 31 WHERE x = 1 AND y = 1 AND z = 21

query III
SELECT * FROM xyz ORDER BY x
----
1  1  11
2  2  2

statement ok
COMMIT

query III
SELECT * FROM xyz ORDER BY x
----
1  1  11
2  2  2

statement ok
CREATE TABLE mno (m INT PRIMARY KEY, n INT, o INT NOT NULL, UNIQUE INDEX (o), INDEX (n), FAMILY (m, n, o))

statement ok
INSERT INTO mno VALUES (3, 3, 3), (4, 4, 4)

statement error pq: duplicate key value violates unique constraint "mno_o_key"\nDETAIL: Key \(o\)=\(4\) already exists\.
UPDATE mno SET o = 4 WHERE m = 3 AND n IS NOT DISTINCT FROM 3 AND o IS NOT DISTINCT FROM 3

query III
SELECT * FROM mno ORDER BY m
----
3  3  3
4  4  4

# The failure of the CPut of the primary index should trump the failure of the
# CPut of the secondary index, meaning the end result should be 0 rows updated
# instead of a dupe key error.
statement ok
UPDATE mno SET o = 4 WHERE m = 3 AND n IS NOT DISTINCT FROM 4 AND o IS NOT DISTINCT FROM 3

query III
SELECT * FROM mno ORDER BY m
----
3  3  3
4  4  4

statement ok
ALTER TABLE mno ADD COLUMN p INT

statement ok
ALTER TABLE mno DROP COLUMN p

statement error pq: duplicate key value violates unique constraint "mno_o_key"\nDETAIL: Key \(o\)=\(4\) already exists\.
UPDATE mno SET o = 4 WHERE m = 3 AND n IS NOT DISTINCT FROM 3 AND o IS NOT DISTINCT FROM 3

query III
SELECT * FROM mno ORDER BY m
----
3  3  3
4  4  4

# Like above, even with the primary index ordered after the unique secondary
# index, the failure of the CPut of the primary index should trump the failure
# of the CPut of the secondary index, so the end result should be 0 rows updated
# instead of a dupe key error.
statement ok
UPDATE mno SET o = 4 WHERE m = 3 AND n IS NOT DISTINCT FROM 4 AND o IS NOT DISTINCT FROM 3

query III
SELECT * FROM mno ORDER BY m
----
3  3  3
4  4  4
