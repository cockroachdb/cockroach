# LogicTest: !local-mixed-23.1

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  i INT,
  s STRING
)

statement ok
CREATE PROCEDURE my_upsert(arg_k INT, new_i INT, new_s STRING) AS $$
  DECLARE
    c INT;
  BEGIN
    SELECT count(*) INTO c FROM t WHERE k = arg_k;
    IF c > 0 THEN
      UPDATE t SET i = new_i, s = new_s WHERE k = arg_k;
    ELSE
      INSERT INTO t VALUES (arg_k, new_i, new_s);
    END IF;
  END
$$ LANGUAGE PLpgSQL

statement ok
CALL my_upsert(1, 10, 'foo')

statement ok
CALL my_upsert(2, 20, 'bar')

query IIT rowsort
SELECT * FROM t
----
1  10  foo
2  20  bar

statement ok
CALL my_upsert(1, 100, 'baz')

query IIT rowsort
SELECT * FROM t
----
1  100  baz
2  20   bar

subtest composite_into

# Regression test for #114683 - if the target of a SELECT INTO statement is a
# single composite-typed variable, the columns will be wrapped with a tuple,
# which will be assigned to the variable.
statement ok
CREATE TABLE t114683 (x INT, y INT);
INSERT INTO t114683 (SELECT t, t%6 FROM generate_series(1, 13) g(t));

statement ok
CREATE OR REPLACE PROCEDURE get_rows() LANGUAGE PLpgSQL AS $$
  DECLARE
    v t114683;
    n INT;
    i INT := 0;
  BEGIN
    n := (SELECT count(*) FROM t114683);
    WHILE i < n LOOP
      SELECT x, y INTO v FROM t114683 ORDER BY y, x OFFSET i;
      RAISE NOTICE 'v: %', v;
      i := i + 1;
    END LOOP;
  END
$$;

query T noticetrace
CALL get_rows();
----
NOTICE: v: (6,0)
NOTICE: v: (12,0)
NOTICE: v: (1,1)
NOTICE: v: (7,1)
NOTICE: v: (13,1)
NOTICE: v: (2,2)
NOTICE: v: (8,2)
NOTICE: v: (3,3)
NOTICE: v: (9,3)
NOTICE: v: (4,4)
NOTICE: v: (10,4)
NOTICE: v: (5,5)
NOTICE: v: (11,5)

statement ok
DROP PROCEDURE get_rows();

statement ok
CREATE OR REPLACE PROCEDURE get_rows() LANGUAGE PLpgSQL AS $$
  DECLARE
    v t114683;
    n INT;
    i INT := 0;
  BEGIN
    n := (SELECT count(*) FROM t114683);
    WHILE i < n LOOP
      SELECT ROW(x, y) INTO v FROM t114683 ORDER BY y, x OFFSET i;
      RAISE NOTICE 'v: %', v;
      i := i + 1;
    END LOOP;
  END
$$;

# TODO(drewk): This should fail because of the doubly-wrapped tuple.
# This should be fixed when #112816 merges along with #114683.
query T noticetrace
CALL get_rows();
----
NOTICE: v: (6,0)
NOTICE: v: (12,0)
NOTICE: v: (1,1)
NOTICE: v: (7,1)
NOTICE: v: (13,1)
NOTICE: v: (2,2)
NOTICE: v: (8,2)
NOTICE: v: (3,3)
NOTICE: v: (9,3)
NOTICE: v: (4,4)
NOTICE: v: (10,4)
NOTICE: v: (5,5)
NOTICE: v: (11,5)

statement ok
CREATE OR REPLACE PROCEDURE get_rows() LANGUAGE PLpgSQL AS $$
  DECLARE
    v t114683;
    n INT;
    i INT := 0;
  BEGIN
    n := (SELECT count(*) FROM t114683);
    WHILE i < n LOOP
      SELECT ROW(x, y) INTO v FROM t114683 ORDER BY y, x OFFSET i;
      RAISE NOTICE 'v: %', v::TEXT::t114683;
      i := i + 1;
    END LOOP;
  END
$$;

statement error pgcode 22P02 could not parse
CALL get_rows();

# The target of a FETCH statement has the same behavior as above.
statement ok
CREATE OR REPLACE PROCEDURE foo() LANGUAGE PLpgSQL AS $$
  DECLARE
    curs CURSOR FOR SELECT 1, 2;
    v t114683;
  BEGIN
    OPEN curs;
    FETCH curs INTO v;
    RAISE NOTICE '%', v;
  END
$$;

query T noticetrace
CALL foo();
----
NOTICE: (1,2)

statement ok
CREATE OR REPLACE PROCEDURE foo() LANGUAGE PLpgSQL AS $$
  DECLARE
    curs CURSOR FOR SELECT ROW(1, 2);
    v t114683;
  BEGIN
    OPEN curs;
    FETCH curs INTO v;
    RAISE NOTICE '%', v;
  END
$$;

statement error pgcode 42846 invalid cast
CALL foo();

subtest end
