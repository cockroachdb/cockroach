# LogicTest: !local-prepared

statement ok
DROP TABLE IF EXISTS canary_table;

# To avoid test flake.
statement ok
SET create_table_with_schema_locked=false

statement ok
CREATE TABLE canary_table (x int primary key, y int, FAMILY (x, y)) WITH (sql_stats_canary_window = '20s');
INSERT INTO canary_table VALUES (1, 1);

query TT
SHOW CREATE TABLE canary_table
----
canary_table  CREATE TABLE public.canary_table (
                x INT8 NOT NULL,
                y INT8 NULL,
                CONSTRAINT canary_table_pkey PRIMARY KEY (x ASC),
                FAMILY fam_0_x_y (x, y)
              ) WITH (sql_stats_canary_window = '20s');

let $table_creation_ts
SELECT now()

statement ok
ALTER TABLE canary_table SET (sql_stats_canary_window = '30s');

query TT
SHOW CREATE TABLE canary_table
----
canary_table  CREATE TABLE public.canary_table (
                x INT8 NOT NULL,
                y INT8 NULL,
                CONSTRAINT canary_table_pkey PRIMARY KEY (x ASC),
                FAMILY fam_0_x_y (x, y)
              ) WITH (sql_stats_canary_window = '30s');

query T
SELECT create_statement FROM crdb_internal.create_statements AS OF SYSTEM TIME '$table_creation_ts' WHERE descriptor_name = 'canary_table';
----
CREATE TABLE public.canary_table (
  x INT8 NOT NULL,
  y INT8 NULL,
  CONSTRAINT canary_table_pkey PRIMARY KEY (x ASC),
  FAMILY fam_0_x_y (x, y)
) WITH (sql_stats_canary_window = '20s')

subtest canary_stats_with_query_cache

# Test with stable stats, which should have the normal usage of query cache.
statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='0';

statement ok
SET TRACING = "on", cluster;

statement ok
SELECT * FROM canary_table;

statement ok
SET TRACING = "off";

# The first execution should miss the query cache.
query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%';
----
query cache miss
query cache add

statement ok
SET TRACING = "on", cluster;

statement ok
SELECT * FROM canary_table;

statement ok
SET TRACING = "off";

# The second execution should hit the query cache.
query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%';
----
query cache hit

# Now we test the case where always use canary stats, which doesn't
# interact with query cache at all.
statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='1.0';

statement ok
SET TRACING = "on", cluster;

statement ok
SELECT * FROM canary_table;

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%';
----
not using query cache

statement ok
SET TRACING = "on", cluster;

statement ok
SELECT * FROM canary_table;

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%';
----
not using query cache

# Switching back to using stable stats, and the same query should still be
# able to hit the query cache.
statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='0.0';

statement ok
SET TRACING = "on", cluster;

statement ok
SELECT * FROM canary_table;

statement ok
SET TRACING = "off";

# We should see the original cache is still there.
query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%';
----
query cache hit

subtest end

subtest prepared_statements

statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='1.0';

statement ok
PREPARE p1 AS SELECT * FROM canary_table WHERE x = $1;

query II
EXECUTE p1(1);
----
1  1

# Test with prepared statement without placeholder.
statement ok
PREPARE p2 AS SELECT * FROM canary_table WHERE x = 1;

query II
EXECUTE p2;
----
1  1

statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='0';

subtest end

subtest prepared_statements_with_query_cache

statement ok
DEALLOCATE ALL;

statement ok
SELECT crdb_internal.clear_query_plan_cache();

statement ok
SET TRACING = "on", cluster;

# We are using stable stats for every query, so the query cache should be used.
statement ok
PREPARE p1 AS SELECT * from canary_table;
PREPARE p2 AS SELECT * from canary_table;
PREPARE p3 AS SELECT * from canary_table WHERE x = $1;
PREPARE p4 AS SELECT * from canary_table WHERE x = $1;

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%' OR message LIKE '%cached memo%';
----
query cache miss (prepare)
query cache hit (prepare)
query cache miss (prepare)
query cache hit (prepare)

statement ok
SET TRACING = "on", cluster;

statement ok
EXECUTE p1;
EXECUTE p2;
EXECUTE p3(1);
EXECUTE p3(1);
EXECUTE p4(1);
EXECUTE p4(1);

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%' OR message LIKE '%cached memo%';
----
reusing cached memo
reusing cached memo
reusing cached memo
reusing cached memo
reusing cached memo
reusing cached memo

# We are using canary stats for all queries now, but we don't roll the dice
# for prepared statement. I.e. the prepare stmt would still be cached,
# and memo would still be built with stable stats and cached within the prepared
# statement.
statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='1.0';

statement ok
SET TRACING = "on", cluster;

# p5, p6 are based on the same queries as p1, p3 respectively, so they
# should hit the query cache. p7 is a new query so it should see a query
# cache miss, but itself would be cached. p8 is based on the same query as
# p7, so it should hit the query cache.
statement ok
PREPARE p5 AS SELECT * from canary_table;
PREPARE p6 AS SELECT * from canary_table WHERE x = $1;
PREPARE p7 AS SELECT * from canary_table WHERE y = $1;
PREPARE p8 AS SELECT * from canary_table WHERE y = $1;

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%' OR message LIKE '%cached memo%';
----
query cache hit (prepare)
query cache hit (prepare)
query cache miss (prepare)
query cache hit (prepare)

statement ok
SET TRACING = "on", cluster;

# For execution, we roll the dice for every one. Since we have canary_fraction=1.0,
# all execution will not use the query cache nor the cached memo within
# the prepared statement. Thus we should see "not using query cache" for all executions.
statement ok
EXECUTE p5;
EXECUTE p5;
EXECUTE p6(1);
EXECUTE p6(1);
EXECUTE p3(1);
EXECUTE p3(1);
EXECUTE p7(1);
EXECUTE p7(1);
EXECUTE p8(1);
EXECUTE p8(1);

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%' OR message LIKE '%cached memo%';
----
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache
not using query cache

# We now switch back to the "everyone use stable stats" mode. At this moment
# executing a prepared stmt that is created while canary_fration == 1.0 should
# still be able to use the cached memo.
statement ok
SET CLUSTER SETTING sql.stats.canary_fraction='0';

statement ok
SET TRACING = "on", cluster;

statement ok
EXECUTE p7(1);
EXECUTE p7(1);
EXECUTE p8(1);
EXECUTE p8(1);

statement ok
SET TRACING = "off";

query T
SELECT split_part(message, ':', 1) FROM [SHOW TRACE FOR SESSION] WHERE message LIKE '%query cache%' OR message LIKE '%cached memo%';
----
reusing cached memo
reusing cached memo
reusing cached memo
reusing cached memo

subtest end
