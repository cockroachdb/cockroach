# Tests for assignment casts.
subtest assignment_casts

statement ok
CREATE TABLE assn_cast (
  c CHAR,
  vc VARCHAR(1),
  qc "char",
  b BIT,
  i INT,
  t timestamp
)

statement ok
INSERT INTO assn_cast(c) VALUES ('a')

statement error value too long for type CHAR
INSERT INTO assn_cast(c) VALUES ('abc')

query T
INSERT INTO assn_cast(c) VALUES (1) RETURNING c
----
1

statement error value too long for type CHAR
INSERT INTO assn_cast(c) VALUES (123)

statement ok
INSERT INTO assn_cast(vc) VALUES ('a')

statement error value too long for type VARCHAR\(1\)
INSERT INTO assn_cast(vc) VALUES ('abc')

query T
INSERT INTO assn_cast(c) VALUES (1) RETURNING c
----
1

statement error value too long for type CHAR
INSERT INTO assn_cast(c) VALUES (123)

statement ok
INSERT INTO assn_cast(qc) VALUES ('a')

query T
INSERT INTO assn_cast(qc) VALUES ('abc') RETURNING qc
----
a

# Note: This statement fails in Postgres because the default integer type is an
# INT4, and the INT4 -> "char" cast is explicit. Our default integer type
# is an INT8 and INT8 -> "char" is an assignment cast.
#
# TODO(mgartner): This should return '{'.
query T
INSERT INTO assn_cast(qc) VALUES (123) RETURNING qc
----
1

# TODO(mgartner): This should be an out of range error.
statement ok
INSERT INTO assn_cast(qc) VALUES (1234)

statement ok
INSERT into assn_cast(b) VALUES ('1')

# TODO(mgartner): To match Postgres behavior, this statement should fail with
# the message "value too long for type BIT".
statement ok
INSERT into assn_cast(b) VALUES ('01')

statement error value type int doesn't match type bit of column \"b\"
INSERT into assn_cast(b) VALUES (1)

statement ok
INSERT INTO assn_cast(i) VALUES ('1')

statement error value type string doesn't match type int of column \"i\"
INSERT INTO assn_cast(i) VALUES ('1'::STRING)

statement ok
INSERT INTO assn_cast(t) VALUES ('1970-01-01'::timestamptz)

subtest regressions

statement ok
CREATE TABLE t45837 AS SELECT 1.25::decimal AS d

# Test that decimals get rounded when casting.
query T
SELECT d::decimal(10,1) FROM t45837
----
1.3

statement ok
CREATE TABLE t2 AS SELECT 18446744073709551616::FLOAT AS f

statement error pgcode 22003 integer out of range
SELECT f::int FROM t2

statement error integer out of range
SELECT 23414123414::int2

# Regression test for #47327. Test that negative intervals are correctly
# cast to a decimal.
statement ok
CREATE TABLE t0(c0 DECIMAL UNIQUE); INSERT INTO t0(c0) VALUES(0);

statement ok
CREATE TABLE t1(c0 DECIMAL); INSERT INTO t1(c0) VALUES(0);

# Both of these queries should return no rows.
query T
SELECT t0.c0 FROM t0 WHERE t0.c0 BETWEEN t0.c0 AND INTERVAL '-1'::DECIMAL
----

query T
SELECT t1.c0 FROM t1 WHERE t1.c0 BETWEEN t1.c0 AND INTERVAL '-1'::DECIMAL
----

# Regression test for incorrectly casting integers out of range (#64429).
statement ok
CREATE TABLE t64429 (_int8 INT8, _int4 INT4);
INSERT INTO t64429 VALUES (3000000000, 300000);

statement error integer out of range for type int2
SELECT _int8::INT2 FROM t64429

statement error integer out of range for type int4
SELECT _int8::INT4 FROM t64429

statement error integer out of range for type int2
SELECT _int4::INT2 FROM t64429

# Also check the negative overflow.
statement ok
DELETE FROM t64429 WHERE true;
INSERT INTO t64429 VALUES (-3000000000, -300000);

statement error integer out of range for type int2
SELECT _int8::INT2 FROM t64429

statement error integer out of range for type int4
SELECT _int8::INT4 FROM t64429

statement error integer out of range for type int2
SELECT _int4::INT2 FROM t64429

# Regression test for #66067. Ensure that there is no correctness bug due to
# improper casting of CHAR and VARCHAR.
statement ok
CREATE TABLE t66067_a (
  a INT,
  c CHAR(26),
  CONSTRAINT c UNIQUE (c)
);
CREATE TABLE t66067_b (
  a INT,
  v VARCHAR(40)
);
INSERT INTO t66067_a VALUES (1, 'foo');
INSERT INTO t66067_b VALUES (1, 'bar');

query ITIT
SELECT * FROM t66067_b b
INNER LOOKUP JOIN t66067_a a ON b.a = a.a
WHERE b.v = 'bar' AND a.c = 'foo'
----
1  bar  1  foo
