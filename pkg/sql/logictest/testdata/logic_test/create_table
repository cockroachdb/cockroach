subtest regression_42858

statement ok
CREATE TABLE TEST2 (COL1 SERIAL PRIMARY KEY, COL2 INT8)

statement error pq: duplicate constraint name: "duplicate_name"
CREATE TABLE TEST1 (COL1 SERIAL PRIMARY KEY, COL2 INT8, COL3 INT8, CONSTRAINT duplicate_name FOREIGN KEY (col2) REFERENCES TEST2(COL1), CONSTRAINT duplicate_name FOREIGN KEY (col3) REFERENCES TEST2(COL1))

statement ok
DROP TABLE TEST2

# Regression for #43894
subtest regression_43894
statement ok
CREATE TABLE IF NOT EXISTS t43894 (PRIMARY KEY (a), a UUID NOT NULL, b JSONB NOT NULL DEFAULT '5')

subtest telemetry_tests

statement ok
CREATE TABLE new_table (a timetz(3))

statement ok
ALTER TABLE new_table ADD COLUMN c timetz(4)

# Cannot really get more exact than this (i.e. looking at usage_count), as it increments on each run.
query T
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name IN ('sql.schema.new_column_type.timetz_3_', 'sql.schema.new_column_type.timetz_4_') AND usage_count > 0 ORDER BY feature_name
----
sql.schema.new_column_type.timetz_3_
sql.schema.new_column_type.timetz_4_

statement ok
SET autocommit_before_ddl = false

statement ok
CREATE TABLE sec_col_fam(x INT, y INT, z INT, FAMILY (x), FAMILY (y), FAMILY (z), INDEX (x) STORING (y, z));
CREATE INDEX ON sec_col_fam (x) STORING (y, z)

query T
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name = 'sql.schema.secondary_index_column_families' AND usage_count >= 2
----
sql.schema.secondary_index_column_families

statement ok
RESET autocommit_before_ddl

statement ok
set require_explicit_primary_keys=true

statement error pq: no primary key specified for table t \(require_explicit_primary_keys = true\)
CREATE TABLE t (x INT, y INT)

# Make sure the setting does not block a table that _does_ have a PK.
statement ok
CREATE TABLE t (x INT PRIMARY KEY, y INT)

# Regression for #45496.
statement ok
reset require_explicit_primary_keys;

statement ok
DROP TABLE IF EXISTS t;

statement ok
CREATE TABLE t (rowid INT, rowid_1 INT, FAMILY (rowid, rowid_1))

query T rowsort
SELECT column_name FROM [SHOW COLUMNS FROM t]
----
rowid
rowid_1
rowid_2

query TT rowsort
SELECT index_name, column_name FROM [SHOW INDEXES FROM t]
----
t_pkey  rowid_2
t_pkey  rowid_1
t_pkey  rowid

query TT
SHOW CREATE t
----
t  CREATE TABLE public.t (
     rowid INT8 NULL,
     rowid_1 INT8 NULL,
     rowid_2 INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
     CONSTRAINT t_pkey PRIMARY KEY (rowid_2 ASC),
     FAMILY fam_0_rowid_rowid_1_rowid_2 (rowid, rowid_1, rowid_2)
   )

subtest regression_qualification_feature_counts

statement ok
CREATE TABLE telemetry_test (a int DEFAULT 1, b int UNIQUE CHECK(b > 1), c int AS (a + b) STORED)

query T rowsort
SELECT feature_name FROM crdb_internal.feature_usage
WHERE feature_name IN (
  'sql.schema.new_column.qualification.computed',
  'sql.schema.new_column.qualification.default_expr',
  'sql.schema.new_column.qualification.unique'
)
----
sql.schema.new_column.qualification.unique
sql.schema.new_column.qualification.computed
sql.schema.new_column.qualification.default_expr

statement ok
DROP TABLE telemetry_test

statement ok
CREATE TABLE telemetry (
  x INT PRIMARY KEY,
  y INT,
  z JSONB,
  v VECTOR(3),
  INVERTED INDEX (z),
  INDEX (y) USING HASH WITH (bucket_count=4),
  VECTOR INDEX (v)
)

query T rowsort
SELECT feature_name FROM crdb_internal.feature_usage
WHERE feature_name IN (
  'sql.schema.inverted_index',
  'sql.schema.hash_sharded_index',
  'sql.schema.vector_index'
)
----
sql.schema.inverted_index
sql.schema.hash_sharded_index
sql.schema.vector_index

subtest like_table

# Test the CREATE TABLE LIKE functionality.

statement ok
SET experimental_enable_unique_without_index_constraints = true

statement ok
CREATE TABLE like_table (
  a INT CHECK (a > 3),
  b STRING DEFAULT 'foo' NOT NULL,
  c DECIMAL AS (a+3) STORED,
  h INT,
  j JSON,
  k INT UNIQUE WITHOUT INDEX,
  t TIMESTAMPTZ DEFAULT current_timestamp() - '5s'::interval ON UPDATE current_timestamp(),
  v VECTOR(3),
  PRIMARY KEY (a, b),
  UNIQUE INDEX foo (b DESC, c),
  INDEX (c) STORING (j),
  INVERTED INDEX (j),
  UNIQUE WITHOUT INDEX (h),
  UNIQUE WITHOUT INDEX (h) WHERE h > 0,
  VECTOR INDEX (v)
)

statement ok
CREATE TABLE like_none (LIKE like_table)

query TT
SHOW CREATE TABLE like_none
----
like_none  CREATE TABLE public.like_none (
             a INT8 NOT NULL,
             b STRING NOT NULL,
             c DECIMAL NULL,
             h INT8 NULL,
             j JSONB NULL,
             k INT8 NULL,
             t TIMESTAMPTZ NULL,
             v VECTOR(3) NULL,
             rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
             CONSTRAINT like_none_pkey PRIMARY KEY (rowid ASC)
           )

statement ok
CREATE TABLE like_constraints (LIKE like_table INCLUDING CONSTRAINTS)

query TT
SHOW CREATE TABLE like_constraints
----
like_constraints  CREATE TABLE public.like_constraints (
                    a INT8 NOT NULL,
                    b STRING NOT NULL,
                    c DECIMAL NULL,
                    h INT8 NULL,
                    j JSONB NULL,
                    k INT8 NULL,
                    t TIMESTAMPTZ NULL,
                    v VECTOR(3) NULL,
                    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                    CONSTRAINT like_constraints_pkey PRIMARY KEY (rowid ASC),
                    CONSTRAINT check_a CHECK (a > 3:::INT8),
                    CONSTRAINT unique_k UNIQUE WITHOUT INDEX (k),
                    CONSTRAINT unique_h UNIQUE WITHOUT INDEX (h),
                    CONSTRAINT unique_h_1 UNIQUE WITHOUT INDEX (h) WHERE h > 0:::INT8
                  )

statement ok
CREATE TABLE like_indexes (LIKE like_table INCLUDING INDEXES)

query TT
SHOW CREATE TABLE like_indexes
----
like_indexes  CREATE TABLE public.like_indexes (
                a INT8 NOT NULL,
                b STRING NOT NULL,
                c DECIMAL NULL,
                h INT8 NULL,
                j JSONB NULL,
                k INT8 NULL,
                t TIMESTAMPTZ NULL,
                v VECTOR(3) NULL,
                CONSTRAINT like_table_pkey PRIMARY KEY (a ASC, b ASC),
                UNIQUE INDEX foo (b DESC, c ASC),
                INDEX like_table_c_idx (c ASC) STORING (j),
                INVERTED INDEX like_table_j_idx (j),
                VECTOR INDEX like_table_v_idx (v)
              )

# INCLUDING GENERATED adds "generated columns", aka stored columns.
statement ok
CREATE TABLE like_generated (LIKE like_table INCLUDING GENERATED)

query TT
SHOW CREATE TABLE like_generated
----
like_generated  CREATE TABLE public.like_generated (
                  a INT8 NOT NULL,
                  b STRING NOT NULL,
                  c DECIMAL NULL AS (a + 3:::DECIMAL) STORED,
                  h INT8 NULL,
                  j JSONB NULL,
                  k INT8 NULL,
                  t TIMESTAMPTZ NULL,
                  v VECTOR(3) NULL,
                  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                  CONSTRAINT like_generated_pkey PRIMARY KEY (rowid ASC)
                )

statement ok
CREATE TABLE like_defaults (LIKE like_table INCLUDING DEFAULTS)

query TT
SHOW CREATE TABLE like_defaults
----
like_defaults  CREATE TABLE public.like_defaults (
                 a INT8 NOT NULL,
                 b STRING NOT NULL DEFAULT 'foo':::STRING,
                 c DECIMAL NULL,
                 h INT8 NULL,
                 j JSONB NULL,
                 k INT8 NULL,
                 t TIMESTAMPTZ NULL DEFAULT current_timestamp():::TIMESTAMPTZ - '00:00:05':::INTERVAL ON UPDATE current_timestamp():::TIMESTAMPTZ,
                 v VECTOR(3) NULL,
                 rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                 CONSTRAINT like_defaults_pkey PRIMARY KEY (rowid ASC)
               )

statement ok
CREATE TABLE like_all (LIKE like_table INCLUDING ALL)

query TT
SHOW CREATE TABLE like_all
----
like_all  CREATE TABLE public.like_all (
            a INT8 NOT NULL,
            b STRING NOT NULL DEFAULT 'foo':::STRING,
            c DECIMAL NULL AS (a + 3:::DECIMAL) STORED,
            h INT8 NULL,
            j JSONB NULL,
            k INT8 NULL,
            t TIMESTAMPTZ NULL DEFAULT current_timestamp():::TIMESTAMPTZ - '00:00:05':::INTERVAL ON UPDATE current_timestamp():::TIMESTAMPTZ,
            v VECTOR(3) NULL,
            CONSTRAINT like_table_pkey PRIMARY KEY (a ASC, b ASC),
            UNIQUE INDEX foo (b DESC, c ASC),
            INDEX like_table_c_idx (c ASC) STORING (j),
            INVERTED INDEX like_table_j_idx (j),
            VECTOR INDEX like_table_v_idx (v),
            CONSTRAINT check_a CHECK (a > 3:::INT8),
            CONSTRAINT unique_k UNIQUE WITHOUT INDEX (k),
            CONSTRAINT unique_h UNIQUE WITHOUT INDEX (h),
            CONSTRAINT unique_h_1 UNIQUE WITHOUT INDEX (h) WHERE h > 0:::INT8
          )

statement ok
CREATE TABLE like_mixed (LIKE like_table INCLUDING ALL EXCLUDING GENERATED EXCLUDING CONSTRAINTS INCLUDING GENERATED)

# We expect that this table will be missing the check constraint from the first
# table, but will include everything else.
query TT
SHOW CREATE TABLE like_mixed
----
like_mixed  CREATE TABLE public.like_mixed (
              a INT8 NOT NULL,
              b STRING NOT NULL DEFAULT 'foo':::STRING,
              c DECIMAL NULL AS (a + 3:::DECIMAL) STORED,
              h INT8 NULL,
              j JSONB NULL,
              k INT8 NULL,
              t TIMESTAMPTZ NULL DEFAULT current_timestamp():::TIMESTAMPTZ - '00:00:05':::INTERVAL ON UPDATE current_timestamp():::TIMESTAMPTZ,
              v VECTOR(3) NULL,
              CONSTRAINT like_table_pkey PRIMARY KEY (a ASC, b ASC),
              UNIQUE INDEX foo (b DESC, c ASC),
              INDEX like_table_c_idx (c ASC) STORING (j),
              INVERTED INDEX like_table_j_idx (j),
              VECTOR INDEX like_table_v_idx (v)
            )

statement ok
CREATE TABLE like_no_pk_table (
  a INT, b INT
)

statement ok
CREATE TABLE like_no_pk_rowid_hidden (LIKE like_no_pk_table INCLUDING INDEXES)

query TT
SHOW CREATE TABLE like_no_pk_rowid_hidden
----
like_no_pk_rowid_hidden  CREATE TABLE public.like_no_pk_rowid_hidden (
                           a INT8 NULL,
                           b INT8 NULL,
                           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                           CONSTRAINT like_no_pk_rowid_hidden_pkey PRIMARY KEY (rowid ASC)
                         )

statement error duplicate column name
CREATE TABLE duplicate_column (LIKE like_table, c DECIMAL)

statement ok
CREATE TABLE other_table (blah INT)

# Test that mixing normal specifiers and LIKE specifiers works as expected. We
# expect that the column ordering depends on the order of the LIKE specifiers.
statement ok
CREATE TABLE like_more_specifiers (LIKE like_table, z DECIMAL, INDEX(a,blah,z), LIKE other_table)

query TT
SHOW CREATE TABLE like_more_specifiers
----
like_more_specifiers  CREATE TABLE public.like_more_specifiers (
                        a INT8 NOT NULL,
                        b STRING NOT NULL,
                        c DECIMAL NULL,
                        h INT8 NULL,
                        j JSONB NULL,
                        k INT8 NULL,
                        t TIMESTAMPTZ NULL,
                        v VECTOR(3) NULL,
                        z DECIMAL NULL,
                        blah INT8 NULL,
                        rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                        CONSTRAINT like_more_specifiers_pkey PRIMARY KEY (rowid ASC),
                        INDEX like_more_specifiers_a_blah_z_idx (a ASC, blah ASC, z ASC)
                      )

statement ok
CREATE TABLE like_hash_base (a INT, INDEX (a) USING HASH WITH (bucket_count=4))

statement ok
CREATE TABLE like_hash (LIKE like_hash_base INCLUDING INDEXES)

query TT
SHOW CREATE TABLE like_hash
----
like_hash  CREATE TABLE public.like_hash (
             a INT8 NULL,
             crdb_internal_a_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a))), 4:::INT8)) VIRTUAL,
             rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
             CONSTRAINT like_hash_pkey PRIMARY KEY (rowid ASC),
             INDEX like_hash_base_a_idx (a ASC) USING HASH WITH (bucket_count=4)
           )

statement ok
DROP TABLE like_hash;

statement ok
CREATE TABLE like_hash (LIKE like_hash_base INCLUDING ALL)

query TT
SHOW CREATE TABLE like_hash
----
like_hash  CREATE TABLE public.like_hash (
             a INT8 NULL,
             crdb_internal_a_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a))), 4:::INT8)) VIRTUAL,
             rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
             CONSTRAINT like_hash_pkey PRIMARY KEY (rowid ASC),
             INDEX like_hash_base_a_idx (a ASC) USING HASH WITH (bucket_count=4)
           )

statement ok
CREATE TABLE regression_67196 (pk INT PRIMARY KEY, hidden INT NOT VISIBLE);

statement ok
CREATE TABLE regression_67196_like (LIKE regression_67196)

query TT
SHOW CREATE TABLE regression_67196_like
----
regression_67196_like  CREATE TABLE public.regression_67196_like (
                         pk INT8 NOT NULL,
                         hidden INT8 NOT VISIBLE NULL,
                         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                         CONSTRAINT regression_67196_like_pkey PRIMARY KEY (rowid ASC)
                       )

statement error unimplemented
CREATE TABLE error (LIKE like_hash_base INCLUDING COMMENTS)

statement error unimplemented
CREATE TABLE error (LIKE like_hash_base INCLUDING STATISTICS)

statement error unimplemented
CREATE TABLE error (LIKE like_hash_base INCLUDING STORAGE)

subtest unique_without_index

statement ok
SET experimental_enable_unique_without_index_constraints = false

statement error pgcode 0A000 unique constraints without an index are not yet supported
CREATE TABLE unique_without_index (a INT UNIQUE WITHOUT INDEX)

statement error pgcode 0A000 unique constraints without an index are not yet supported
CREATE TABLE unique_without_index (a INT, b INT, UNIQUE WITHOUT INDEX (a, b))

statement ok
SET experimental_enable_unique_without_index_constraints = true

statement ok
CREATE TABLE unique_without_index (a INT UNIQUE WITHOUT INDEX)

statement ok
CREATE TABLE unique_without_index1 (a INT, b INT, CONSTRAINT ab UNIQUE WITHOUT INDEX (a, b))

query TTTTB colnames
SELECT * FROM [SHOW CONSTRAINTS FROM unique_without_index] ORDER BY constraint_name
----
table_name            constraint_name            constraint_type  details                   validated
unique_without_index  unique_a                   UNIQUE           UNIQUE WITHOUT INDEX (a)  true
unique_without_index  unique_without_index_pkey  PRIMARY KEY      PRIMARY KEY (rowid ASC)   true

query TTTTB colnames
SELECT * FROM [SHOW CONSTRAINTS FROM unique_without_index1] ORDER BY constraint_name
----
table_name             constraint_name             constraint_type  details                      validated
unique_without_index1  ab                          UNIQUE           UNIQUE WITHOUT INDEX (a, b)  true
unique_without_index1  unique_without_index1_pkey  PRIMARY KEY      PRIMARY KEY (rowid ASC)      true

# Unique constraints without an index use the same name generation logic as
# check constraints. A named constraint following an anonymous constraint
# can cause a duplicate name error.
statement error pgcode 42710 duplicate constraint name: \"unique_a\"
CREATE TABLE error (a INT UNIQUE WITHOUT INDEX, CONSTRAINT unique_a UNIQUE WITHOUT INDEX (a))

statement error pgcode 42710 duplicate constraint name: \"check_a\"
CREATE TABLE error (a INT CHECK (a > 5), CONSTRAINT check_a CHECK (a > 5))

statement error pgcode 0A000 unique constraints without an index cannot store columns
CREATE TABLE error (a INT, b INT, UNIQUE WITHOUT INDEX (a) STORING (b))

statement error pgcode 0A000 partitioned unique constraints without an index are not supported
CREATE TABLE error (a INT, b INT, UNIQUE WITHOUT INDEX (a) PARTITION BY LIST (b) (
  PARTITION p1 VALUES IN (1)
))

# The unique constraint predicate must be valid. It cannot reference
# non-existent columns.
# TODO(mgartner): If we ever decide to make UNIQUE WITHOUT INDEX available
# without the experimental setting, we should test that other types of invalid
# predicates produce errors. There are similar tests in the partial_index
# logictests that would be a good starting point.
statement error column "c" does not exist
CREATE TABLE unique_without_index_partial (a INT, b INT, UNIQUE WITHOUT INDEX (a) WHERE c > 0)

statement ok
CREATE TABLE unique_without_index_partial (a INT, b INT, UNIQUE WITHOUT INDEX (a) WHERE b > 5)

subtest regression_57630

statement error pgcode 42P07 duplicate index name: \"idx\"
CREATE TABLE error (a INT, b INT, INDEX idx (a), INDEX idx (b))

subtest duplicate_index_name_unique_index

statement error pgcode 42P07 duplicate index name: \"idx\"
CREATE TABLE error (a INT, b INT, INDEX idx (a), UNIQUE INDEX idx (b))

statement error pgcode 42P07 duplicate index name: \"idx\"
CREATE TABLE error (a INT, b INT, UNIQUE INDEX idx (a), UNIQUE INDEX idx (b))

statement ok
CREATE TABLE ctas1 AS (SELECT * FROM crdb_internal.node_statement_statistics);

statement ok
CREATE TABLE ctas2 AS (SELECT * FROM crdb_internal.node_transaction_statistics);

statement ok
CREATE TABLE ctas3 AS (SELECT * FROM crdb_internal.node_txn_stats);

subtest generated_as_identity
statement ok
CREATE TABLE generated_always_t (
  a INT UNIQUE,
  b INT GENERATED ALWAYS AS IDENTITY,
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE generated_always_t
----
generated_always_t  CREATE TABLE public.generated_always_t (
                      a INT8 NULL,
                      b INT8 NOT NULL GENERATED ALWAYS AS IDENTITY,
                      rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                      CONSTRAINT generated_always_t_pkey PRIMARY KEY (rowid ASC),
                      UNIQUE INDEX generated_always_t_a_key (a ASC),
                      FAMILY f1 (a, b, rowid)
                    )

statement ok
CREATE TABLE generated_by_default_t (
  a INT UNIQUE,
  b INT GENERATED BY DEFAULT AS IDENTITY,
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE generated_by_default_t
----
generated_by_default_t  CREATE TABLE public.generated_by_default_t (
                          a INT8 NULL,
                          b INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
                          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                          CONSTRAINT generated_by_default_t_pkey PRIMARY KEY (rowid ASC),
                          UNIQUE INDEX generated_by_default_t_a_key (a ASC),
                          FAMILY f1 (a, b, rowid)
                        )

statement ok
CREATE TABLE generated_always_t_notnull (a INT UNIQUE, b INT NOT NULL GENERATED ALWAYS AS IDENTITY)

statement ok
CREATE TABLE generated_by_default_t_notnull (a INT UNIQUE, b INT NOT NULL GENERATED BY DEFAULT AS IDENTITY)

statement ok
CREATE TYPE regression_72804_enum AS ENUM ()

statement error pgcode 22023 identity column type must be an INT
CREATE TABLE regression_72804 (
  a INT,
  b regression_72804_enum GENERATED ALWAYS AS IDENTITY
)

statement error pgcode 22023 identity column type must be an INT
CREATE TABLE regression_72804 (
  a INT,
  c regression_72804_enum GENERATED BY DEFAULT AS IDENTITY,
)

subtest generated_as_identity_with_seq_option
statement ok
CREATE TABLE gen_always_as_id_seqopt (
  a INT UNIQUE,
  b INT GENERATED ALWAYS AS IDENTITY (START 2 INCREMENT 3),
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE gen_always_as_id_seqopt
----
gen_always_as_id_seqopt  CREATE TABLE public.gen_always_as_id_seqopt (
                           a INT8 NULL,
                           b INT8 NOT NULL GENERATED ALWAYS AS IDENTITY (START 2 INCREMENT 3),
                           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                           CONSTRAINT gen_always_as_id_seqopt_pkey PRIMARY KEY (rowid ASC),
                           UNIQUE INDEX gen_always_as_id_seqopt_a_key (a ASC),
                           FAMILY f1 (a, b, rowid)
                         )

statement ok
CREATE TABLE gen_always_as_id_seqopt_cache (
  a INT UNIQUE,
  b INT GENERATED ALWAYS AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE gen_always_as_id_seqopt_cache
----
gen_always_as_id_seqopt_cache  CREATE TABLE public.gen_always_as_id_seqopt_cache (
                                 a INT8 NULL,
                                 b INT8 NOT NULL GENERATED ALWAYS AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
                                 rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                                 CONSTRAINT gen_always_as_id_seqopt_cache_pkey PRIMARY KEY (rowid ASC),
                                 UNIQUE INDEX gen_always_as_id_seqopt_cache_a_key (a ASC),
                                 FAMILY f1 (a, b, rowid)
                               )

statement ok
CREATE TABLE gen_by_default_as_id_seqopt (
  a INT UNIQUE,
  b INT GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3),
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE gen_by_default_as_id_seqopt
----
gen_by_default_as_id_seqopt  CREATE TABLE public.gen_by_default_as_id_seqopt (
                               a INT8 NULL,
                               b INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3),
                               rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                               CONSTRAINT gen_by_default_as_id_seqopt_pkey PRIMARY KEY (rowid ASC),
                               UNIQUE INDEX gen_by_default_as_id_seqopt_a_key (a ASC),
                               FAMILY f1 (a, b, rowid)
                             )

statement ok
CREATE TABLE gen_by_default_as_id_seqopt_cache (
  a INT UNIQUE,
  b INT GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  FAMILY f1 (a, b)
)

query TT
SHOW CREATE TABLE gen_by_default_as_id_seqopt_cache
----
gen_by_default_as_id_seqopt_cache  CREATE TABLE public.gen_by_default_as_id_seqopt_cache (
                                     a INT8 NULL,
                                     b INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
                                     rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                                     CONSTRAINT gen_by_default_as_id_seqopt_cache_pkey PRIMARY KEY (rowid ASC),
                                     UNIQUE INDEX gen_by_default_as_id_seqopt_cache_a_key (a ASC),
                                     FAMILY f1 (a, b, rowid)
                                   )

statement ok
CREATE SEQUENCE serial_test_sequence start 1 increment 1

statement notice NOTICE: using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/(v\d+\.\d+)|(dev)/serial.html
CREATE TABLE serial_test1 (id INT PRIMARY KEY DEFAULT nextval('serial_test_sequence'), temp string)

statement notice NOTICE: using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/(v\d+\.\d+)|(dev)/serial.html
CREATE TABLE serial_test2 (id SERIAL PRIMARY KEY, temp string)

statement notice NOTICE: using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/(v\d+\.\d+)|(dev)/serial.html
CREATE TABLE serial_test3 (id SERIAL, temp string, PRIMARY KEY (id))

statement notice NOTICE: upgrading the column id to INT8 to utilize the session serial_normalization setting\nHINT: change the serial_normalization to sql_sequence or sql_sequence_cached if you wish to use a smaller sized serial column at the cost of performance. See https://www.cockroachlabs.com/docs/(v\d+\.\d+)|(dev)/serial.html
CREATE TABLE serial_test4 (id SERIAL4, temp string)

statement ok
CREATE TABLE regression_73648 AS select * from [SHOW CLUSTER QUERIES]

# Test sequence is drop when a owner table/column is dropped
subtest test_serial_ownership_create_table

statement ok
SET serial_normalization = sql_sequence;

statement error "fillfactor" must be between 0 and 100
CREATE TABLE test_ownership_invalid_fillfactor (
        a INT PRIMARY KEY,
        b SERIAL
) with (fillfactor = 70000)

statement ok
CREATE TABLE test_serial (
	a INT PRIMARY KEY,
	b SERIAL
);

query ITTT colnames,rowsort
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name               state   refobjid
162       test_serial_b_seq  PUBLIC  161
161       test_serial        PUBLIC  NULL

statement ok
DROP TABLE test_serial;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name  state  refobjid

statement ok
CREATE TABLE test_serial (
	a INT PRIMARY KEY,
	b SERIAL
);

query ITTT colnames,rowsort
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name               state   refobjid
164       test_serial_b_seq  PUBLIC  163
163       test_serial        PUBLIC  NULL

statement ok
ALTER TABLE test_serial DROP COLUMN b;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name         state   refobjid
163       test_serial  PUBLIC  NULL

statement ok
DROP TABLE test_serial;

subtest test_storage_params_validation

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT PRIMARY KEY WITH (s2_max_level=20)
);

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT PRIMARY KEY USING HASH WITH (s2_max_level=20)
);

statement error pq: "bucket_count" storage param should only be set with "USING HASH" for hash sharded index
CREATE TABLE t_bad_param (
  a INT PRIMARY KEY WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage parameter and "BUCKET_COUNT" cannot be set at the same time
CREATE TABLE t_bad_param (
  a INT PRIMARY KEY USING HASH WITH BUCKET_COUNT = 5 WITH (bucket_count=5)
);

statement error pq: hash sharded index bucket count must be in range \[2, 2048\], got NULL
CREATE TABLE t_bad_param (
  a INT PRIMARY KEY USING HASH WITH BUCKET_COUNT = NULL
);

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  PRIMARY KEY (a) WITH (s2_max_level=20)
);

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  PRIMARY KEY (a) USING HASH WITH (s2_max_level=20)
);

statement error pq: "bucket_count" storage param should only be set with "USING HASH" for hash sharded index
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  PRIMARY KEY (a) WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage parameter and "BUCKET_COUNT" cannot be set at the same time
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  PRIMARY KEY (a) USING HASH WITH BUCKET_COUNT = 5 WITH (bucket_count=5)
);

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  CONSTRAINT t_bad_param_pkey PRIMARY KEY (a) WITH (s2_max_level=20)
);

statement error pq: invalid storage param "s2_max_level" on primary key
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  CONSTRAINT t_bad_param_pkey PRIMARY KEY (a) USING HASH WITH (s2_max_level=20)
);

statement error pq: "bucket_count" storage param should only be set with "USING HASH" for hash sharded index
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  CONSTRAINT t_bad_param_pkey PRIMARY KEY (a) WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage parameter and "BUCKET_COUNT" cannot be set at the same time
CREATE TABLE t_bad_param (
  a INT NOT NULL,
  CONSTRAINT t_bad_param_pkey PRIMARY KEY (a) USING HASH WITH BUCKET_COUNT = 5 WITH (bucket_count=5)
);

statement error pq: invalid storage param "s2_max_level" on unique index
CREATE TABLE t_bad_param (
  a INT,
  UNIQUE INDEX (a) WITH (s2_max_level=20)
);

statement error pq: invalid storage param "s2_max_level" on unique index
CREATE TABLE t_bad_param (
  a INT,
  UNIQUE INDEX (a) USING HASH WITH (s2_max_level=20)
);

statement error pq: "bucket_count" storage param should only be set with "USING HASH" for hash sharded index
CREATE TABLE t_bad_param (
  a INT,
  UNIQUE INDEX (a) WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage parameter and "BUCKET_COUNT" cannot be set at the same time
CREATE TABLE t_bad_param (
  a INT,
  UNIQUE INDEX (a) USING HASH WITH BUCKET_COUNT = 5 WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage param should only be set with "USING HASH" for hash sharded index
CREATE TABLE t_bad_param (
  a INT,
  INDEX (a) WITH (bucket_count=5)
);

statement error pq: "bucket_count" storage parameter and "BUCKET_COUNT" cannot be set at the same time
CREATE TABLE t_bad_param (
  a INT,
  INDEX (a) USING HASH WITH BUCKET_COUNT = 5 WITH (bucket_count=5)
);

statement ok
CREATE TABLE t_source (
  a INT PRIMARY KEY
);

statement error pq: storage parameters are not supported on primary key for CREATE TABLE...AS... statement
CREATE TABLE t_bad_param (
  a PRIMARY KEY WITH (s2_max_level=20)
) AS SELECT * FROM t_source;

statement error pq: storage parameters are not supported on primary key for CREATE TABLE...AS... statement
CREATE TABLE t_bad_param (
  a,
  PRIMARY KEY (a) WITH (s2_max_level=20)
) AS SELECT * FROM t_source;

subtest test_old_bucket_count_syntax

statement ok
CREATE TABLE t_good_hash_indexes_1 (
 a INT PRIMARY KEY USING HASH WITH BUCKET_COUNT = 5,
 b INT,
 c INT,
 INDEX (b) USING HASH WITH BUCKET_COUNT = 5,
 FAMILY "primary" (a, b, c)
);

query T
SELECT create_statement FROM [SHOW CREATE TABLE t_good_hash_indexes_1];
----
CREATE TABLE public.t_good_hash_indexes_1 (
  crdb_internal_a_shard_5 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a))), 5:::INT8)) VIRTUAL,
  a INT8 NOT NULL,
  b INT8 NULL,
  c INT8 NULL,
  crdb_internal_b_shard_5 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(b))), 5:::INT8)) VIRTUAL,
  CONSTRAINT t_good_hash_indexes_1_pkey PRIMARY KEY (a ASC) USING HASH WITH (bucket_count=5),
  INDEX t_good_hash_indexes_1_b_idx (b ASC) USING HASH WITH (bucket_count=5)
)

statement ok
CREATE TABLE t_good_hash_indexes_2 (
 a INT,
 PRIMARY KEY (a) USING HASH WITH BUCKET_COUNT = 5
);

query T
SELECT create_statement FROM [SHOW CREATE TABLE t_good_hash_indexes_2];
----
CREATE TABLE public.t_good_hash_indexes_2 (
  a INT8 NOT NULL,
  crdb_internal_a_shard_5 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a))), 5:::INT8)) VIRTUAL,
  CONSTRAINT t_good_hash_indexes_2_pkey PRIMARY KEY (a ASC) USING HASH WITH (bucket_count=5)
)

subtest table_settings

statement ok
CREATE TABLE t1 (a int) WITH (sql_stats_automatic_collection_enabled = true)

# Verify automatic collection is enabled.
query T
SELECT
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor',
                              d.descriptor, false)->'table'->>'autoStatsSettings'
FROM
    crdb_internal.tables AS tbl
    INNER JOIN system.descriptor AS d ON d.id = tbl.table_id
WHERE
    tbl.name = 't1'
    AND tbl.drop_time IS NULL
----
{"enabled": true}

statement ok
DROP TABLE t1

statement ok
CREATE TABLE t1 (a int) WITH (sql_stats_automatic_collection_fraction_stale_rows = 0.5,
                              sql_stats_automatic_collection_min_stale_rows = 4000)

# Verify settings
query T
SELECT
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor',
                              d.descriptor, false)->'table'->>'autoStatsSettings'
FROM
    crdb_internal.tables AS tbl
    INNER JOIN system.descriptor AS d ON d.id = tbl.table_id
WHERE
    tbl.name = 't1'
    AND tbl.drop_time IS NULL
----
{"fractionStaleRows": 0.5, "minStaleRows": "4000"}

query T
SELECT create_statement FROM [SHOW CREATE TABLE t1]
----
CREATE TABLE public.t1 (
  a INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t1_pkey PRIMARY KEY (rowid ASC)
) WITH (sql_stats_automatic_collection_min_stale_rows = 4000, sql_stats_automatic_collection_fraction_stale_rows = 0.5)

statement ok
CREATE TABLE t11 (a int) WITH (sql_stats_automatic_collection_enabled = true,
                               sql_stats_automatic_collection_fraction_stale_rows = 1.797693134862315708145274237317043567981e+308,
                               sql_stats_automatic_collection_min_stale_rows = 9223372036854775807)

# Using max values for auto stats table settings
query T
SELECT create_statement FROM [SHOW CREATE TABLE t11]
----
CREATE TABLE public.t11 (
  a INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t11_pkey PRIMARY KEY (rowid ASC)
) WITH (sql_stats_automatic_collection_enabled = true, sql_stats_automatic_collection_min_stale_rows = 9223372036854775807, sql_stats_automatic_collection_fraction_stale_rows = 1.7976931348623157e+308)

statement error pq: invalid float value for sql_stats_automatic_collection_fraction_stale_rows: cannot set to a negative value: -1.000000
CREATE TABLE t22 (a int) WITH (sql_stats_automatic_collection_fraction_stale_rows = -1.0)

statement error pq: invalid integer value for sql_stats_automatic_collection_min_stale_rows: cannot be set to a negative value: -1
CREATE TABLE t22 (a int) WITH (sql_stats_automatic_collection_min_stale_rows = -1)

subtest sequence_is_referenced_by_ID

statement ok
CREATE SEQUENCE IF NOT EXISTS s

statement ok
DROP TABLE IF EXISTS tbl

statement ok
CREATE TABLE tbl (i INT PRIMARY KEY, j INT NOT NULL ON UPDATE nextval('s'), FAMILY f1 (i, j))

query TT
SHOW CREATE TABLE tbl
----
tbl  CREATE TABLE public.tbl (
       i INT8 NOT NULL,
       j INT8 NOT NULL ON UPDATE nextval('public.s'::REGCLASS),
       CONSTRAINT tbl_pkey PRIMARY KEY (i ASC),
       FAMILY f1 (i, j)
     )

statement ok
CREATE SEQUENCE IF NOT EXISTS s1

statement ok
CREATE SEQUENCE IF NOT EXISTS s2

statement ok
DROP TABLE IF EXISTS tbl

statement ok
CREATE TABLE tbl (i INT PRIMARY KEY, j INT NOT NULL DEFAULT nextval('s1') ON UPDATE nextval('s2'), FAMILY f1 (i, j))

query TT
SHOW CREATE TABLE tbl
----
tbl  CREATE TABLE public.tbl (
       i INT8 NOT NULL,
       j INT8 NOT NULL DEFAULT nextval('public.s1'::REGCLASS) ON UPDATE nextval('public.s2'::REGCLASS),
       CONSTRAINT tbl_pkey PRIMARY KEY (i ASC),
       FAMILY f1 (i, j)
     )

# We should propagate the type of the column into the sequence (#110352), instead
# of always using INT8 for them.
subtest validate_serial_seq_type

statement ok
CREATE TABLE gen_by_default_int2 (
  a INT UNIQUE,
  b INT4 GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  c INT2 GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  d INT GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  FAMILY f1 (a, b)
)

statement ok
SET default_int_size=4;

statement ok
CREATE TABLE gen_by_default_int3 (
  a INT UNIQUE,
  b INT4 GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  c INT2 GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  d INT GENERATED BY DEFAULT AS IDENTITY (START 2 INCREMENT 3 CACHE 10),
  FAMILY f1 (a, b)
)

statement ok
SET default_int_size=8;

# Validate the sequence type matches based on the defintion
query TTT rowsort
SELECT
  sequence_schema, sequence_name,
  data_type AS type
FROM information_schema.sequences
JOIN pg_namespace AS ns ON ns.nspname = sequence_schema
JOIN pg_class AS cls ON cls.relnamespace = ns.oid AND cls.relname = sequence_name;
----
public  gen_by_default_int3_d_seq                INT4
public  gen_by_default_int3_c_seq                INT2
public  gen_by_default_int3_b_seq                INT4
public  gen_by_default_int2_d_seq                INT8
public  gen_by_default_int2_c_seq                INT2
public  gen_by_default_int2_b_seq                INT4
public  s2                                       INT8
public  s1                                       INT8
public  s                                        INT8
public  serial_test_sequence                     INT8
public  gen_by_default_as_id_seqopt_cache_b_seq  INT8
public  gen_by_default_as_id_seqopt_b_seq        INT8
public  gen_always_as_id_seqopt_cache_b_seq      INT8
public  gen_always_as_id_seqopt_b_seq            INT8
public  generated_by_default_t_notnull_b_seq     INT8
public  generated_always_t_notnull_b_seq         INT8
public  generated_by_default_t_b_seq             INT8
public  generated_always_t_b_seq                 INT8

subtest end

# This subtest ensures we can create not valid unique-without-index constraint
# during table creation, which will be treated as a "normal"
# unique-without-index constraint (meaning the NOT VALID will be dropped).
subtest 115352

statement ok
SET experimental_enable_unique_without_index_constraints = true

statement ok
CREATE TABLE t_115352 (i INT, UNIQUE WITHOUT INDEX (i) NOT VALID);

# NOT VALID constraint specified within `CREATE TABLE` is a no-op and does not
# skip validation.
query T
SELECT create_statement FROM [SHOW CREATE t_115352];
----
CREATE TABLE public.t_115352 (
    i INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    CONSTRAINT t_115352_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT unique_i UNIQUE WITHOUT INDEX (i)
)

subtest end


statement ok

subtest 125619

statement ok
SET inject_retry_errors_enabled=true

statement ok
CREATE TABLE t_125619 (i INT8, j INT8, INDEX ((i + j)));

statement ok
ALTER TABLE t_125619 ADD CONSTRAINT uni UNIQUE ((i + j + i))

statement ok
SET inject_retry_errors_enabled=false

subtest end


# Addresses a bug where parsing nextval expressions with extra values could end
# end up with a panic when rewriting sequence expressions.
subtest 133399

statement ok
CREATE TABLE v_133399 (c01 INT);

statement error pgcode 42804 could not find matching function overload for given arguments
CREATE TABLE t_133399 AS (SELECT * FROM v_133399 WINDOW window_name AS (ROWS c01 BETWEEN nextval ('abc', 'abc', 'abc') AND c01 PRECEDING));

subtest end

subtest create_table_as_notice

statement ok
CREATE TABLE IF NOT EXISTS t1 (
  id1 UUID NOT NULL DEFAULT gen_random_uuid(),
  id2 UUID NOT NULL DEFAULT gen_random_uuid(),
  ts TIMESTAMPTZ NOT NULL DEFAULT statement_timestamp(),
  val JSONB,
  PRIMARY KEY(id1, id2)
);

# Ignore weaker isolation levels, since that will cause additional NOTICEs that we don't want to check in this test.
skipif config weak-iso-level-configs
query T noticetrace
CREATE TABLE t2 AS SELECT * FROM t1;
----
NOTICE: CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column

subtest end

subtest create_table_with_duplicate_storage_params

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE create_table_with_duplicate_storage_params_a (
  a INT PRIMARY KEY,
  b TEXT NOT NULL
) WITH (fillfactor=10, fillfactor=15);

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE IF NOT EXISTS create_table_with_duplicate_storage_params_b (
  a INT
) WITH (fillfactor=10, fillfactor=20);

subtest end

subtest create_table_with_as_duplicate_storage_params

statement ok
CREATE TABLE create_table_with_as_duplicate_storage_params_a (a INT);

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE create_table_with_as_duplicate_storage_params_b (a) WITH (fillfactor=10, fillfactor=20) AS (SELECT * FROM create_table_with_as_duplicate_storage_params_a);

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE IF NOT EXISTS create_table_with_as_duplicate_storage_params_c (a) WITH (fillfactor=10, fillfactor=20) AS (SELECT * FROM create_table_with_as_duplicate_storage_params_a);

subtest end

subtest create_table_primary_key_with_duplicate_storage_params

# only bucket_count is a valid storage param, so USING HASH must be added
statement error pgcode 22023 pq: parameter "bucket_count" specified more than once
CREATE TABLE create_table_primary_key_with_duplicate_storage_params_a (a INT PRIMARY KEY USING HASH WITH (bucket_count=10, bucket_count=20));

subtest end

subtest create_table_index_elem_duplicate_storage_params

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE create_table_index_elem_duplicate_storage_params_a (
  a INT PRIMARY KEY,
  b INT,
  INDEX (b) WITH (fillfactor=10, fillfactor=20)
);

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE create_table_index_elem_duplicate_storage_params_b (
  a INT PRIMARY KEY,
  b INT,
  INDEX b_idx (b) WITH (fillfactor=10, fillfactor=20)
);

statement error pgcode 22023 pq: parameter "bucket_count" specified more than once
CREATE TABLE create_table_index_elem_duplicate_storage_params_c (
  a INT PRIMARY KEY,
  b INT,
  UNIQUE INDEX (b) USING HASH WITH (bucket_count=10, bucket_count=20)
);

statement error pgcode 22023 pq: parameter "fillfactor" specified more than once
CREATE TABLE create_table_index_elem_duplicate_storage_params_d (
  a INT PRIMARY KEY,
  b JSONB,
  INVERTED INDEX (b) WITH (fillfactor=10, fillfactor=20)
);

statement error pgcode 22023 pq: parameter "bucket_count" specified more than once
CREATE TABLE create_table_index_elem_duplicate_storage_params_e (
  a INT,
  PRIMARY KEY (a) USING HASH WITH (bucket_count=10, bucket_count=20)
);

subtest end

statement error pq: unimplemented: column col2 has type refcursor, which is not indexable\nHINT: You have attempted to use a feature that is not yet implemented.\nSee: https://go.crdb.dev/issue-v/35730/dev
CREATE TABLE not_indexable (COL1 INT PRIMARY KEY, COL2 REFCURSOR, COL3 REFCURSOR, INDEX (COL2, COL3))
