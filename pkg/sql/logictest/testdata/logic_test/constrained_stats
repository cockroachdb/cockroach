# LogicTest: local fakedist

# Tests for creating partial table statistics with a WHERE clause.

statement ok
SET CLUSTER SETTING sql.stats.automatic_collection.enabled = false

statement ok
CREATE TABLE products (
    id INT PRIMARY KEY,
    category_id INT,
    price DECIMAL,
    status STRING,
    created_at TIMESTAMP,
    INDEX idx_category (category_id),
    INDEX idx_price (price),
    INDEX idx_status (status),
    INDEX idx_composite (category_id, price)
)

statement ok
INSERT INTO products VALUES
(1, 1, 10.00, 'active', '2025-01-01'),
(2, 1, 15.00, 'active', '2025-01-02'),
(3, 2, 20.00, 'inactive', '2025-01-03'),
(4, 2, 25.00, 'active', '2025-01-04'),
(5, 3, 30.00, 'inactive', '2025-01-05'),
(6, 1, 35.00, 'active', '2025-01-06'),
(7, 2, 40.00, 'active', '2025-01-07'),
(8, 3, 45.00, 'inactive', '2025-01-08'),
(9, 1, 50.00, 'active', '2025-01-09'),
(10, 2, 55.00, 'active', '2025-01-10')

statement ok
CREATE STATISTICS full_stat FROM products;

# Clear the stat cache so that creating partial statistics has access to the
# latest full statistic.
statement ok
SELECT crdb_internal.clear_table_stats_cache();

# Test stats collections with WHERE expressions
statement ok
CREATE STATISTICS stat_expensive_products ON price FROM products WHERE price > 30.00

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_expensive_products'
----
statistics_name          column_names  row_count  distinct_count  null_count  partial_predicate
stat_expensive_products  {price}       5          5               0           price > 30.00

let $hist_stat_expensive_products
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE products] WHERE statistics_name = 'stat_expensive_products';

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_stat_expensive_products
----
upper_bound  range_rows  distinct_range_rows  equal_rows
35.00        0           0                    1
40.00        0           0                    1
45.00        0           0                    1
50.00        0           0                    1
55.00        0           0                    1

statement ok
CREATE STATISTICS stat_price_ranges ON price FROM products WHERE price <= 20.00 OR price > 40.00

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_price_ranges'
----
statistics_name    column_names  row_count  distinct_count  null_count  partial_predicate
stat_price_ranges  {price}       6          6               0           (price <= 20.00) OR (price > 40.00)

let $hist_stat_price_ranges
SELECT histogram_id FROM [SHOW STATISTICS FOR TABLE products] WHERE statistics_name = 'stat_price_ranges';

query TIRI colnames,nosort
SHOW HISTOGRAM $hist_stat_price_ranges
----
upper_bound  range_rows  distinct_range_rows  equal_rows
10.00        0           0                    1
15.00        0           0                    1
20.00        0           0                    1
45.00        0           0                    1
50.00        0           0                    1
55.00        0           0                    1

statement ok
CREATE STATISTICS stat_active_products ON status FROM products WHERE status = 'active'

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_active_products'
----
statistics_name       column_names  row_count  distinct_count  null_count  partial_predicate
stat_active_products  {status}      7          1               0           status = 'active'

statement ok
CREATE STATISTICS stat_mid_range_products ON category_id FROM products WHERE category_id BETWEEN 1 AND 2

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_mid_range_products'
----
statistics_name          column_names   row_count  distinct_count  null_count  partial_predicate
stat_mid_range_products  {category_id}  8          2               0           category_id BETWEEN 1 AND 2

statement ok
CREATE STATISTICS stat_specific_categories ON category_id FROM products WHERE category_id IN (1, 3)

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_specific_categories'
----
statistics_name           column_names   row_count  distinct_count  null_count  partial_predicate
stat_specific_categories  {category_id}  6          2               0           category_id IN (1, 3)

# Verify error cases
statement error pq: partial statistics with WHERE must be on a single column
CREATE STATISTICS stat_multi_col ON category_id, price FROM products WHERE status = 'active'

statement error pq: partial statistics WHERE filter can only reference a single column
CREATE STATISTICS stat_multi_outer_col ON price FROM products WHERE status = 'active' AND price > 20.00

statement error pq: WHERE filter must be on the same column as the one specified in the column list
CREATE STATISTICS stat_wrong_col ON price FROM products WHERE category_id = 1

statement error pq: filter cannot be a contradiction
CREATE STATISTICS stat_contradiction ON price FROM products WHERE price < 10 AND price > 10

statement error pq: table products does not contain a non-partial forward index with created_at as a prefix column
CREATE STATISTICS stat_created_at ON created_at FROM products WHERE created_at > '2025-01-05'

statement error column "nonexistent" does not exist
CREATE STATISTICS stat_nonexistent ON price FROM products WHERE nonexistent > 10

statement error pq: predicate could not become a constrained scan of an index
CREATE STATISTICS stat_subquery ON category_id FROM products WHERE category_id IN (SELECT id FROM products LIMIT 1)

statement error pq: predicate could not become a constrained scan of an index
CREATE STATISTICS stat_func ON status FROM products WHERE length(status) > 6

statement error syntax error
CREATE STATISTICS stat_error2 ON price FROM products WHERE price >

statement error could not parse
CREATE STATISTICS stat_error3 ON price FROM products WHERE price = 'invalid_number'

# Test stats collections with predicates containing NULL
statement ok
INSERT INTO products VALUES (11, NULL, 60.00, 'active', '2025-01-11')

statement ok
CREATE STATISTICS stat_null_category ON category_id FROM products WHERE category_id IS NULL

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_null_category'
----
statistics_name     column_names   row_count  distinct_count  null_count  partial_predicate
stat_null_category  {category_id}  1          1               1           category_id IS NULL

statement ok
CREATE STATISTICS stat_not_null_category ON category_id FROM products WHERE category_id IS NOT NULL

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_not_null_category'
----
statistics_name        column_names    row_count  distinct_count  null_count  partial_predicate
stat_not_null_category {category_id}   10         3               0           category_id IS NOT NULL

# Test stats collections with predicates on computed columns and descending indexes
statement ok
ALTER TABLE products ADD COLUMN discount_price INT AS (price::INT - 10) STORED

statement ok
CREATE INDEX discount_idx ON products(discount_price DESC);

statement ok
CREATE STATISTICS products_full FROM products;

# Clear the stat cache so that creating partial statistics has access to the
# latest full statistic.
statement ok
SELECT crdb_internal.clear_table_stats_cache();

statement ok
CREATE STATISTICS stat_discount ON discount_price FROM products WHERE discount_price > 30

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_discount'
----
statistics_name  column_names      row_count  distinct_count  null_count  partial_predicate
stat_discount    {discount_price}  4          4               0           discount_price > 30

# Test stats collections with predicates resulting in empty stats
statement ok
CREATE STATISTICS stat_empty ON price FROM products WHERE price > 1000.00

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stat_empty'
----
statistics_name  column_names  row_count  distinct_count  null_count  partial_predicate
stat_empty       {price}       0          0               0           price > 1000.00

let $products_t_id
SELECT id FROM system.namespace WHERE name='products'

statement ok
CREATE STATISTICS stats_from_table_id ON price FROM [$products_t_id] WHERE price > 10

query TTIIIT colnames
SELECT statistics_name, column_names, row_count, distinct_count, null_count, partial_predicate
FROM [SHOW STATISTICS FOR TABLE products]
WHERE statistics_name = 'stats_from_table_id'
----
statistics_name      column_names  row_count  distinct_count  null_count  partial_predicate
stats_from_table_id  {price}       10         10              0           price > 10

# Verify error when creating stats that could use an index inferred from the predicate
statement ok
CREATE TABLE infer (x INT NOT NULL, y INT NOT NULL AS (x % 5) STORED, PRIMARY KEY (y, x));

statement error pq: table infer does not contain a non-partial forward index with x as a prefix column
CREATE STATISTICS inferred_stat ON x FROM infer WHERE x = 100;
