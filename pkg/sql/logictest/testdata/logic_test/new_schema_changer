subtest add_column

statement ok
SET use_declarative_schema_changer = 'on'

statement ok
CREATE TABLE foo (i INT PRIMARY KEY)

statement ok
EXPLAIN (DDL) ALTER TABLE foo ADD COLUMN j INT

statement ok
SET use_declarative_schema_changer = 'unsafe'

query T
EXPLAIN (DDL, VERBOSE) ALTER TABLE foo ADD COLUMN j INT
----
• Schema change plan for ALTER TABLE ‹test›.public.‹foo› ADD COLUMN ‹j› INT8;
│
├── • StatementPhase
│   │
│   └── • Stage 1 of 1 in StatementPhase
│       │
│       ├── • 4 elements transitioning toward PUBLIC
│       │   │
│       │   ├── • Column:{DescID: 106, ColumnID: 2}
│       │   │     ABSENT → DELETE_ONLY
│       │   │
│       │   ├── • ColumnName:{DescID: 106, Name: j, ColumnID: 2}
│       │   │   │ ABSENT → PUBLIC
│       │   │   │
│       │   │   └── • SameStagePrecedence dependency from DELETE_ONLY Column:{DescID: 106, ColumnID: 2}
│       │   │         rule: "column name set right after column existence"
│       │   │         rule: "column existence precedes column dependents"
│       │   │
│       │   ├── • ColumnType:{DescID: 106, ColumnFamilyID: 0, ColumnID: 2}
│       │   │   │ ABSENT → PUBLIC
│       │   │   │
│       │   │   └── • Precedence dependency from PUBLIC ColumnName:{DescID: 106, Name: j, ColumnID: 2}
│       │   │         rule: "column named before column type becomes public"
│       │   │
│       │   └── • IndexColumn:{DescID: 106, ColumnID: 2, IndexID: 1}
│       │       │ ABSENT → PUBLIC
│       │       │
│       │       ├── • Precedence dependency from DELETE_ONLY Column:{DescID: 106, ColumnID: 2}
│       │       │     rule: "column existence precedes column dependents"
│       │       │
│       │       ├── • Precedence dependency from PUBLIC ColumnName:{DescID: 106, Name: j, ColumnID: 2}
│       │       │     rule: "column name and type to public after all index column to public"
│       │       │
│       │       └── • Precedence dependency from PUBLIC ColumnType:{DescID: 106, ColumnFamilyID: 0, ColumnID: 2}
│       │             rule: "column name and type to public after all index column to public"
│       │
│       └── • 5 Mutation operations
│           │
│           ├── • MakeAddedColumnDeleteOnly
│           │     Column:
│           │       ColumnID: 2
│           │       PgAttributeNum: 2
│           │       TableID: 106
│           │
│           ├── • LogEvent
│           │     Element:
│           │       Column:
│           │         columnId: 2
│           │         pgAttributeNum: 2
│           │         tableId: 106
│           │     EventBase:
│           │       Authorization:
│           │         UserName: root
│           │       Statement: ALTER TABLE ‹test›.public.‹foo› ADD COLUMN ‹j› INT8
│           │       StatementTag: ALTER TABLE
│           │       TargetMetadata:
│           │         SourceElementID: 1
│           │         SubWorkID: 1
│           │     TargetStatus: 2
│           │
│           ├── • SetColumnName
│           │     ColumnID: 2
│           │     Name: j
│           │     TableID: 106
│           │
│           ├── • SetAddedColumnType
│           │     ColumnType:
│           │       ColumnID: 2
│           │       IsNullable: true
│           │       TableID: 106
│           │       TypeT:
│           │         Type:
│           │           family: IntFamily
│           │           oid: 20
│           │           width: 64
│           │
│           └── • scop.AddColumnToIndex
│                 ColumnID: 2
│                 IndexID: 1
│                 Kind: 2
│                 TableID: 106
│
├── • PreCommitPhase
│   │
│   └── • Stage 1 of 1 in PreCommitPhase
│       │
│       └── • 2 Mutation operations
│           │
│           ├── • SetJobStateOnDescriptor
│           │     DescriptorID: 106
│           │     Initialize: true
│           │
│           └── • CreateSchemaChangerJob
│                 Authorization:
│                   UserName: root
│                 DescriptorIDs:
│                 - 106
│                 JobID: 1
│                 RunningStatus: PostCommitPhase stage 1 of 2 with 1 MutationType op pending
│                 Statements:
│                 - statement: ALTER TABLE foo ADD COLUMN j INT8
│                   redactedstatement: ALTER TABLE ‹test›.public.‹foo› ADD COLUMN ‹j› INT8
│                   statementtag: ALTER TABLE
│
└── • PostCommitPhase
    │
    ├── • Stage 1 of 2 in PostCommitPhase
    │   │
    │   ├── • 1 element transitioning toward PUBLIC
    │   │   │
    │   │   └── • Column:{DescID: 106, ColumnID: 2}
    │   │         DELETE_ONLY → WRITE_ONLY
    │   │
    │   └── • 3 Mutation operations
    │       │
    │       ├── • MakeAddedColumnDeleteAndWriteOnly
    │       │     ColumnID: 2
    │       │     TableID: 106
    │       │
    │       ├── • SetJobStateOnDescriptor
    │       │     DescriptorID: 106
    │       │
    │       └── • UpdateSchemaChangerJob
    │             JobID: 1
    │             RunningStatus: PostCommitPhase stage 2 of 2 with 2 MutationType ops pending
    │
    └── • Stage 2 of 2 in PostCommitPhase
        │
        ├── • 1 element transitioning toward PUBLIC
        │   │
        │   └── • Column:{DescID: 106, ColumnID: 2}
        │         WRITE_ONLY → PUBLIC
        │
        └── • 4 Mutation operations
            │
            ├── • MakeColumnPublic
            │     ColumnID: 2
            │     EventBase:
            │       Authorization:
            │         UserName: root
            │       Statement: ALTER TABLE ‹test›.public.‹foo› ADD COLUMN ‹j› INT8
            │       StatementTag: ALTER TABLE
            │       TargetMetadata:
            │         SourceElementID: 1
            │         SubWorkID: 1
            │     TableID: 106
            │
            ├── • RefreshStats
            │     TableID: 106
            │
            ├── • RemoveJobStateFromDescriptor
            │     DescriptorID: 106
            │     JobID: 1
            │
            └── • UpdateSchemaChangerJob
                  IsNonCancelable: true
                  JobID: 1
                  RunningStatus: all stages completed

statement ok
ALTER TABLE foo ADD COLUMN j INT

statement ok
INSERT INTO foo VALUES (1, 1)

query II rowsort
SELECT * FROM foo
----
1  1

statement ok
DROP TABLE foo;

subtest multi_add_column

statement ok
CREATE TABLE foo (i INT PRIMARY KEY)

statement ok
SET use_declarative_schema_changer = 'unsafe_always'

statement ok
BEGIN

statement ok
ALTER TABLE foo ADD COLUMN j INT

statement ok
ALTER TABLE foo ADD COLUMN k INT

statement ok
COMMIT

statement ok
INSERT INTO foo VALUES (1, 2, 3)

query III rowsort
SELECT * FROM foo
----
1  2  3

statement ok
SET use_declarative_schema_changer = 'unsafe'

statement ok
DROP TABLE foo;

subtest add_column_default

statement ok
CREATE TABLE foo (i INT PRIMARY KEY)

statement ok
INSERT INTO foo(i) VALUES (0)

query I rowsort
SELECT * FROM foo
----
0

statement ok
ALTER TABLE foo ADD COLUMN j INT DEFAULT 1

statement ok
INSERT INTO foo VALUES (1, 1)

statement ok
INSERT INTO foo(i) VALUES (2)

query II rowsort
SELECT * FROM foo
----
0  1
1  1
2  1

statement ok
DROP TABLE foo

subtest add_column_computed

statement ok
CREATE TABLE foo (i INT PRIMARY KEY)

statement ok
INSERT INTO foo VALUES (0);

statement ok
ALTER TABLE foo ADD COLUMN j INT AS (i+1) STORED

statement ok
INSERT INTO foo(i) VALUES (1)

query II rowsort
SELECT * FROM foo
----
0  1
1  2

statement ok
DROP TABLE foo

subtest add_column_families

statement ok
CREATE TABLE foo (i INT PRIMARY KEY)

statement ok
ALTER TABLE foo ADD COLUMN j INT CREATE FAMILY f2

statement ok
ALTER TABLE foo ADD COLUMN k INT FAMILY f2

statement ok
INSERT INTO foo VALUES (1, 2, 3)

query III rowsort
SELECT * FROM foo
----
1  2  3

statement ok
DROP TABLE foo

subtest multi_table

statement ok
CREATE TABLE foo (i INT PRIMARY KEY);
CREATE TABLE bar (j INT PRIMARY KEY);

statement ok
SET use_declarative_schema_changer = 'unsafe_always'

statement ok
BEGIN

statement ok
ALTER TABLE foo ADD COLUMN a INT

statement ok
ALTER TABLE bar ADD COLUMN b INT

statement ok
COMMIT

statement ok
INSERT INTO foo VALUES (1, 2)

query II colnames,rowsort
SELECT * FROM foo
----
i  a
1  2

statement ok
INSERT INTO bar VALUES (3, 4)

query II colnames,rowsort
SELECT * FROM bar
----
j  b
3  4

statement ok
SET use_declarative_schema_changer = 'unsafe'

statement error pgcode 0A000 cannot explain a statement which is not supported by the declarative schema changer
EXPLAIN (DDL) ALTER TABLE bar ALTER COLUMN j TYPE BOOL

statement ok
DROP TABLE foo, bar

# Sequence sanity tests
statement ok
CREATE SEQUENCE sq1;

statement ok
CREATE TABLE blog_posts (id INT PRIMARY KEY, val int DEFAULT nextval('sq1'), title text);

statement ok
CREATE TABLE blog_posts2 (id INT PRIMARY KEY, val int DEFAULT nextval('sq1'), title text);

# Failure without cascade
statement error pq: cannot drop sequence sq1 because other objects depend on it
EXPLAIN (DDL) DROP SEQUENCE sq1;

query T
EXPLAIN (DDL, VERBOSE) DROP SEQUENCE sq1 CASCADE;
----
• Schema change plan for DROP SEQUENCE ‹test›.public.‹sq1› CASCADE;
│
├── • StatementPhase
│   │
│   └── • Stage 1 of 1 in StatementPhase
│       │
│       ├── • 1 element transitioning toward ABSENT
│       │   │
│       │   └── • Sequence:{DescID: 113}
│       │         PUBLIC → OFFLINE
│       │
│       └── • 1 Mutation operation
│           │
│           └── • MarkDescriptorAsOffline
│                 DescID: 113
│                 Reason: DROP SEQUENCE test.public.sq1 CASCADE
│
├── • PreCommitPhase
│   │
│   └── • Stage 1 of 1 in PreCommitPhase
│       │
│       └── • 4 Mutation operations
│           │
│           ├── • SetJobStateOnDescriptor
│           │     DescriptorID: 113
│           │     Initialize: true
│           │
│           ├── • SetJobStateOnDescriptor
│           │     DescriptorID: 114
│           │     Initialize: true
│           │
│           ├── • SetJobStateOnDescriptor
│           │     DescriptorID: 115
│           │     Initialize: true
│           │
│           └── • CreateSchemaChangerJob
│                 Authorization:
│                   UserName: root
│                 DescriptorIDs:
│                 - 113
│                 - 114
│                 - 115
│                 JobID: 1
│                 NonCancelable: true
│                 RunningStatus: PostCommitNonRevertiblePhase stage 1 of 2 with 7 MutationType ops pending
│                 Statements:
│                 - statement: DROP SEQUENCE sq1 CASCADE
│                   redactedstatement: DROP SEQUENCE ‹test›.public.‹sq1› CASCADE
│                   statementtag: DROP SEQUENCE
│
└── • PostCommitNonRevertiblePhase
    │
    ├── • Stage 1 of 2 in PostCommitNonRevertiblePhase
    │   │
    │   ├── • 8 elements transitioning toward ABSENT
    │   │   │
    │   │   ├── • Namespace:{DescID: 113, Name: sq1, ReferencedDescID: 104}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   └── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │         rule: "descriptor drop right before dependent element removal"
    │   │   │
    │   │   ├── • Owner:{DescID: 113}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   ├── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │   │     rule: "descriptor drop right before dependent element removal"
    │   │   │   │
    │   │   │   └── • skip PUBLIC → ABSENT operations
    │   │   │         rule: "skip element removal ops on descriptor drop"
    │   │   │
    │   │   ├── • UserPrivileges:{DescID: 113, Name: admin}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   ├── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │   │     rule: "descriptor drop right before dependent element removal"
    │   │   │   │
    │   │   │   └── • skip PUBLIC → ABSENT operations
    │   │   │         rule: "skip element removal ops on descriptor drop"
    │   │   │
    │   │   ├── • UserPrivileges:{DescID: 113, Name: root}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   ├── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │   │     rule: "descriptor drop right before dependent element removal"
    │   │   │   │
    │   │   │   └── • skip PUBLIC → ABSENT operations
    │   │   │         rule: "skip element removal ops on descriptor drop"
    │   │   │
    │   │   ├── • Sequence:{DescID: 113}
    │   │   │     OFFLINE → DROPPED
    │   │   │
    │   │   ├── • ObjectParent:{DescID: 113, ReferencedDescID: 105}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   └── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │         rule: "descriptor drop right before dependent element removal"
    │   │   │
    │   │   ├── • ColumnDefaultExpression:{DescID: 114, ColumnID: 2}
    │   │   │   │ PUBLIC → ABSENT
    │   │   │   │
    │   │   │   └── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │   │         rule: "descriptor drop right before removing dependent with expr ref"
    │   │   │
    │   │   └── • ColumnDefaultExpression:{DescID: 115, ColumnID: 2}
    │   │       │ PUBLIC → ABSENT
    │   │       │
    │   │       └── • SameStagePrecedence dependency from DROPPED Sequence:{DescID: 113}
    │   │             rule: "descriptor drop right before removing dependent with expr ref"
    │   │
    │   └── • 11 Mutation operations
    │       │
    │       ├── • MarkDescriptorAsDropped
    │       │     DescID: 113
    │       │
    │       ├── • RemoveAllTableComments
    │       │     TableID: 113
    │       │
    │       ├── • RemoveColumnDefaultExpression
    │       │     ColumnID: 2
    │       │     TableID: 114
    │       │
    │       ├── • UpdateBackReferencesInSequences
    │       │     BackReferencedColumnID: 2
    │       │     BackReferencedTableID: 114
    │       │     SequenceIDs:
    │       │     - 113
    │       │
    │       ├── • RemoveColumnDefaultExpression
    │       │     ColumnID: 2
    │       │     TableID: 115
    │       │
    │       ├── • UpdateBackReferencesInSequences
    │       │     BackReferencedColumnID: 2
    │       │     BackReferencedTableID: 115
    │       │     SequenceIDs:
    │       │     - 113
    │       │
    │       ├── • DrainDescriptorName
    │       │     Namespace:
    │       │       DatabaseID: 104
    │       │       DescriptorID: 113
    │       │       Name: sq1
    │       │       SchemaID: 105
    │       │
    │       ├── • SetJobStateOnDescriptor
    │       │     DescriptorID: 113
    │       │
    │       ├── • SetJobStateOnDescriptor
    │       │     DescriptorID: 114
    │       │
    │       ├── • SetJobStateOnDescriptor
    │       │     DescriptorID: 115
    │       │
    │       └── • UpdateSchemaChangerJob
    │             IsNonCancelable: true
    │             JobID: 1
    │             RunningStatus: PostCommitNonRevertiblePhase stage 2 of 2 with 2 MutationType ops pending
    │
    └── • Stage 2 of 2 in PostCommitNonRevertiblePhase
        │
        ├── • 1 element transitioning toward ABSENT
        │   │
        │   └── • Sequence:{DescID: 113}
        │         DROPPED → ABSENT
        │
        └── • 6 Mutation operations
            │
            ├── • LogEvent
            │     Element:
            │       Sequence:
            │         sequenceId: 113
            │     EventBase:
            │       Authorization:
            │         UserName: root
            │       Statement: DROP SEQUENCE ‹test›.public.‹sq1› CASCADE
            │       StatementTag: DROP SEQUENCE
            │       TargetMetadata:
            │         SourceElementID: 1
            │         SubWorkID: 1
            │     TargetStatus: 1
            │
            ├── • CreateGcJobForTable
            │     StatementForDropJob:
            │       Statement: DROP SEQUENCE test.public.sq1 CASCADE
            │     TableID: 113
            │
            ├── • RemoveJobStateFromDescriptor
            │     DescriptorID: 113
            │     JobID: 1
            │
            ├── • RemoveJobStateFromDescriptor
            │     DescriptorID: 114
            │     JobID: 1
            │
            ├── • RemoveJobStateFromDescriptor
            │     DescriptorID: 115
            │     JobID: 1
            │
            └── • UpdateSchemaChangerJob
                  IsNonCancelable: true
                  JobID: 1
                  RunningStatus: all stages completed

# Success with cascade
statement ok
DROP SEQUENCE IF EXISTS doesnotexist, sq1 CASCADE;

# Tables should be safe to drop since references are fixed.
statement ok
DROP TABLE blog_posts;

statement ok
DROP TABLE blog_posts2;

# Test that user defined types used in views are tracked.
subtest view_user_defined_types

statement ok
CREATE TYPE typ AS ENUM('a')

statement ok
CREATE VIEW v AS (SELECT 'a'::typ::string AS k)

statement error cannot drop type "typ" because other objects \(\[test.public.v\]\) still depend on it
DROP TYPE typ

statement ok
DROP VIEW v

statement ok
CREATE VIEW v AS (WITH r AS (SELECT 'a'::typ < 'a'::typ AS k) SELECT k FROM r)

statement error cannot drop type "typ" because other objects \(\[test.public.v\]\) still depend on it
DROP TYPE typ

statement ok
DROP VIEW v

statement ok
CREATE TABLE t (i INT, k STRING AS ('a'::typ::string) STORED)

statement ok
CREATE VIEW v AS (SELECT i FROM t)

# Note that v does not depend on typ since it does not use column k.
statement error cannot drop type "typ" because other objects \(\[test.public.t\]\) still depend on it
DROP TYPE typ

statement ok
CREATE VIEW v_dep AS (SELECT k FROM t)

# Since v_dep depends on t.k which uses type typ, v_dep has a dependency to typ.
statement error cannot drop type "typ" because other objects \(\[test.public.t test.public.v_dep\]\) still depend on it
DROP TYPE typ

statement ok
CREATE TYPE typ2 AS ENUM('a')

statement ok
CREATE VIEW v3 AS (SELECT 'a'::typ2::string AS k)

statement error cannot drop type "typ2" because other objects \(\[test.public.v3\]\) still depend on it
DROP TYPE typ2

statement ok
CREATE OR REPLACE VIEW v3 AS (SELECT 'a' AS k)

statement ok
DROP TYPE typ2

statement ok
CREATE TYPE typ2 AS ENUM('a')

statement ok
CREATE OR REPLACE VIEW v3 AS (SELECT 'a'::typ2::string AS k)

statement error cannot drop type "typ2" because other objects \(\[test.public.v3\]\) still depend on it
DROP TYPE typ2

statement ok
ALTER TYPE typ2 RENAME TO typ3

statement error cannot drop type "typ3" because other objects \(\[test.public.v3\]\) still depend on it
DROP TYPE typ3

statement ok
CREATE TYPE typ4 AS ENUM('a')

statement ok
CREATE TABLE t4 (i INT, j typ4)

statement ok
CREATE VIEW v4 AS (SELECT i FROM t4)

# Note that v4 does not depend on typ4.
statement error cannot drop type "typ4" because other objects \(\[test.public.t4\]\) still depend on it
DROP TYPE typ4

statement ok
ALTER TABLE t4 DROP COLUMN j

statement ok
DROP TYPE typ4

statement ok
CREATE TYPE typ4 AS ENUM('a')

statement ok
ALTER TABLE t4 ADD COLUMN j typ4

statement ok
CREATE VIEW v4_dep AS (SELECT j FROM t4)

# Since v4_dep depends on t4.j which is of type typ4, v4_dep has a dependency to typ4.
statement error cannot drop type "typ4" because other objects \(\[test.public.t4 test.public.v4_dep\]\) still depend on it
DROP type typ4

statement ok
CREATE TYPE typ5 AS ENUM('a')

statement ok
CREATE TABLE t5 (i INT, j STRING DEFAULT 'a'::typ5::string)

# Note that v5 does not depend on typ5.
statement ok
CREATE VIEW v5 AS (SELECT i FROM t5)

statement error cannot drop type "typ5" because other objects \(\[test.public.t5\]\) still depend on it
DROP TYPE typ5

statement ok
CREATE VIEW v5_dep AS (SELECT j FROM t5)

# Since v5_dep depends on t5.j which uses type typ5, v5_dep has a dependency to typ5.
statement error cannot drop type "typ5" because other objects \(\[test.public.t5 test.public.v5_dep\]\) still depend on it
DROP TYPE typ5

statement ok
CREATE VIEW v6 AS (SELECT j FROM v4_dep)

# v6 depends on v4_dep.j, which depends on t4.j, which depends on typ4, so v6 also depends on typ4.
statement error cannot drop type "typ4" because other objects \(\[test.public.t4 test.public.v4_dep test.public.v6\]\) still depend on it
DROP TYPE typ4

statement ok
CREATE TYPE typ6 AS ENUM('a');
CREATE TABLE t6 (i INT, k typ6);
CREATE INDEX idx ON t6 (i) WHERE k < 'a'::typ6

statement ok
CREATE VIEW v7 AS (SELECT i FROM t6)

# Note that v7 does not depend on t6.
statement error cannot drop type "typ6" because other objects \(\[test.public.t6\]\) still depend on it
DROP TYPE typ6

statement ok
CREATE VIEW v7_dep AS (SELECT i FROM t6@idx WHERE k < 'a'::typ6)

# v7_dep depends on typ6 now.
statement error annot drop type "typ6" because other objects \(\[test.public.t6 test.public.v7_dep\]\) still depend on it
DROP TYPE typ6


subtest view_sanity

statement ok
CREATE TABLE t1 (id INT PRIMARY KEY, name varchar(256));

statement ok
CREATE VIEW v1Dep AS (SELECT name FROM t1);

statement ok
CREATE VIEW v2Dep AS (SELECT name AS N1, name AS N2 FROM v1Dep);

statement ok
CREATE VIEW v3Dep AS (SELECT name, n1 FROM v1Dep, v2Dep);

statement ok
CREATE VIEW v4Dep AS (SELECT n2, n1 FROM v2Dep);

query T
EXPLAIN (DDL) DROP VIEW v1Dep CASCADE;
----
Schema change plan for DROP VIEW ‹test›.public.‹v1dep› CASCADE;
 ├── StatementPhase
 │    └── Stage 1 of 1 in StatementPhase
 │         ├── 19 elements transitioning toward ABSENT
 │         │    ├── PUBLIC → OFFLINE    View:{DescID: 147}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 147, ColumnID: 1}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 147, ColumnID: 4294967295}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 147, ColumnID: 4294967294}
 │         │    ├── PUBLIC → OFFLINE    View:{DescID: 148}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 148, ColumnID: 1}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 148, ColumnID: 2}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 148, ColumnID: 4294967295}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 148, ColumnID: 4294967294}
 │         │    ├── PUBLIC → OFFLINE    View:{DescID: 149}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 149, ColumnID: 1}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 149, ColumnID: 2}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 149, ColumnID: 4294967295}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 149, ColumnID: 4294967294}
 │         │    ├── PUBLIC → OFFLINE    View:{DescID: 150}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 150, ColumnID: 1}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 150, ColumnID: 2}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 150, ColumnID: 4294967295}
 │         │    └── PUBLIC → WRITE_ONLY Column:{DescID: 150, ColumnID: 4294967294}
 │         └── 4 Mutation operations
 │              ├── MarkDescriptorAsOffline {"DescID":147,"Reason":"DROP VIEW test.p..."}
 │              ├── MarkDescriptorAsOffline {"DescID":148,"Reason":"DROP VIEW test.p..."}
 │              ├── MarkDescriptorAsOffline {"DescID":149,"Reason":"DROP VIEW test.p..."}
 │              └── MarkDescriptorAsOffline {"DescID":150,"Reason":"DROP VIEW test.p..."}
 ├── PreCommitPhase
 │    └── Stage 1 of 1 in PreCommitPhase
 │         └── 6 Mutation operations
 │              ├── SetJobStateOnDescriptor {"DescriptorID":146,"Initialize":true}
 │              ├── SetJobStateOnDescriptor {"DescriptorID":147,"Initialize":true}
 │              ├── SetJobStateOnDescriptor {"DescriptorID":148,"Initialize":true}
 │              ├── SetJobStateOnDescriptor {"DescriptorID":149,"Initialize":true}
 │              ├── SetJobStateOnDescriptor {"DescriptorID":150,"Initialize":true}
 │              └── CreateSchemaChangerJob {"NonCancelable":true,"RunningStatus":"PostCommitNonRev..."}
 └── PostCommitNonRevertiblePhase
      ├── Stage 1 of 2 in PostCommitNonRevertiblePhase
      │    ├── 69 elements transitioning toward ABSENT
      │    │    ├── PUBLIC     → ABSENT      Namespace:{DescID: 147, Name: v1dep, ReferencedDescID: 104}
      │    │    ├── PUBLIC     → ABSENT      Owner:{DescID: 147}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 147, Name: admin}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 147, Name: root}
      │    │    ├── OFFLINE    → DROPPED     View:{DescID: 147}
      │    │    ├── PUBLIC     → ABSENT      ObjectParent:{DescID: 147, ReferencedDescID: 105}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 147, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 147, Name: name, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 147, ColumnFamilyID: 0, ColumnID: 1}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 147, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 147, Name: crdb_internal_mvcc_timestamp, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 147, ColumnFamilyID: 0, ColumnID: 4294967295}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 147, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 147, Name: tableoid, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 147, ColumnFamilyID: 0, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      Namespace:{DescID: 148, Name: v2dep, ReferencedDescID: 104}
      │    │    ├── PUBLIC     → ABSENT      Owner:{DescID: 148}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 148, Name: admin}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 148, Name: root}
      │    │    ├── OFFLINE    → DROPPED     View:{DescID: 148}
      │    │    ├── PUBLIC     → ABSENT      ObjectParent:{DescID: 148, ReferencedDescID: 105}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 148, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 148, Name: n1, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 148, ColumnFamilyID: 0, ColumnID: 1}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 148, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 148, Name: n2, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 148, ColumnFamilyID: 0, ColumnID: 2}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 148, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 148, Name: crdb_internal_mvcc_timestamp, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 148, ColumnFamilyID: 0, ColumnID: 4294967295}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 148, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 148, Name: tableoid, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 148, ColumnFamilyID: 0, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      Namespace:{DescID: 149, Name: v3dep, ReferencedDescID: 104}
      │    │    ├── PUBLIC     → ABSENT      Owner:{DescID: 149}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 149, Name: admin}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 149, Name: root}
      │    │    ├── OFFLINE    → DROPPED     View:{DescID: 149}
      │    │    ├── PUBLIC     → ABSENT      ObjectParent:{DescID: 149, ReferencedDescID: 105}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 149, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 149, Name: name, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 149, ColumnFamilyID: 0, ColumnID: 1}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 149, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 149, Name: n1, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 149, ColumnFamilyID: 0, ColumnID: 2}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 149, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 149, Name: crdb_internal_mvcc_timestamp, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 149, ColumnFamilyID: 0, ColumnID: 4294967295}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 149, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 149, Name: tableoid, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 149, ColumnFamilyID: 0, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      Namespace:{DescID: 150, Name: v4dep, ReferencedDescID: 104}
      │    │    ├── PUBLIC     → ABSENT      Owner:{DescID: 150}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 150, Name: admin}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 150, Name: root}
      │    │    ├── OFFLINE    → DROPPED     View:{DescID: 150}
      │    │    ├── PUBLIC     → ABSENT      ObjectParent:{DescID: 150, ReferencedDescID: 105}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 150, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 150, Name: n2, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 150, ColumnFamilyID: 0, ColumnID: 1}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 150, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 150, Name: n1, ColumnID: 2}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 150, ColumnFamilyID: 0, ColumnID: 2}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 150, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 150, Name: crdb_internal_mvcc_timestamp, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 150, ColumnFamilyID: 0, ColumnID: 4294967295}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 150, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 150, Name: tableoid, ColumnID: 4294967294}
      │    │    └── PUBLIC     → ABSENT      ColumnType:{DescID: 150, ColumnFamilyID: 0, ColumnID: 4294967294}
      │    └── 22 Mutation operations
      │         ├── MarkDescriptorAsDropped {"DescID":147}
      │         ├── RemoveViewBackReferencesInRelations {"BackReferencedViewID":147}
      │         ├── RemoveAllTableComments {"TableID":147}
      │         ├── MarkDescriptorAsDropped {"DescID":148}
      │         ├── RemoveViewBackReferencesInRelations {"BackReferencedViewID":148}
      │         ├── RemoveAllTableComments {"TableID":148}
      │         ├── MarkDescriptorAsDropped {"DescID":149}
      │         ├── RemoveViewBackReferencesInRelations {"BackReferencedViewID":149}
      │         ├── RemoveAllTableComments {"TableID":149}
      │         ├── MarkDescriptorAsDropped {"DescID":150}
      │         ├── RemoveViewBackReferencesInRelations {"BackReferencedViewID":150}
      │         ├── RemoveAllTableComments {"TableID":150}
      │         ├── DrainDescriptorName {"Namespace":{"DatabaseID":104,"DescriptorID":147,"Name":"v1dep","SchemaID":105}}
      │         ├── DrainDescriptorName {"Namespace":{"DatabaseID":104,"DescriptorID":148,"Name":"v2dep","SchemaID":105}}
      │         ├── DrainDescriptorName {"Namespace":{"DatabaseID":104,"DescriptorID":149,"Name":"v3dep","SchemaID":105}}
      │         ├── DrainDescriptorName {"Namespace":{"DatabaseID":104,"DescriptorID":150,"Name":"v4dep","SchemaID":105}}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":146}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":147}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":148}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":149}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":150}
      │         └── UpdateSchemaChangerJob {"IsNonCancelable":true,"RunningStatus":"PostCommitNonRev..."}
      └── Stage 2 of 2 in PostCommitNonRevertiblePhase
           ├── 19 elements transitioning toward ABSENT
           │    ├── DROPPED     → ABSENT View:{DescID: 147}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 147, ColumnID: 1}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 147, ColumnID: 4294967295}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 147, ColumnID: 4294967294}
           │    ├── DROPPED     → ABSENT View:{DescID: 148}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 148, ColumnID: 1}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 148, ColumnID: 2}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 148, ColumnID: 4294967295}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 148, ColumnID: 4294967294}
           │    ├── DROPPED     → ABSENT View:{DescID: 149}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 149, ColumnID: 1}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 149, ColumnID: 2}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 149, ColumnID: 4294967295}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 149, ColumnID: 4294967294}
           │    ├── DROPPED     → ABSENT View:{DescID: 150}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 150, ColumnID: 1}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 150, ColumnID: 2}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 150, ColumnID: 4294967295}
           │    └── DELETE_ONLY → ABSENT Column:{DescID: 150, ColumnID: 4294967294}
           └── 29 Mutation operations
                ├── LogEvent {"TargetStatus":1}
                ├── DeleteDescriptor {"DescriptorID":147}
                ├── MakeColumnAbsent {"ColumnID":1,"TableID":147}
                ├── MakeColumnAbsent {"ColumnID":4294967295,"TableID":147}
                ├── MakeColumnAbsent {"ColumnID":4294967294,"TableID":147}
                ├── LogEvent {"TargetStatus":1}
                ├── DeleteDescriptor {"DescriptorID":148}
                ├── MakeColumnAbsent {"ColumnID":1,"TableID":148}
                ├── MakeColumnAbsent {"ColumnID":2,"TableID":148}
                ├── MakeColumnAbsent {"ColumnID":4294967295,"TableID":148}
                ├── MakeColumnAbsent {"ColumnID":4294967294,"TableID":148}
                ├── LogEvent {"TargetStatus":1}
                ├── DeleteDescriptor {"DescriptorID":149}
                ├── MakeColumnAbsent {"ColumnID":1,"TableID":149}
                ├── MakeColumnAbsent {"ColumnID":2,"TableID":149}
                ├── MakeColumnAbsent {"ColumnID":4294967295,"TableID":149}
                ├── MakeColumnAbsent {"ColumnID":4294967294,"TableID":149}
                ├── LogEvent {"TargetStatus":1}
                ├── DeleteDescriptor {"DescriptorID":150}
                ├── MakeColumnAbsent {"ColumnID":1,"TableID":150}
                ├── MakeColumnAbsent {"ColumnID":2,"TableID":150}
                ├── MakeColumnAbsent {"ColumnID":4294967295,"TableID":150}
                ├── MakeColumnAbsent {"ColumnID":4294967294,"TableID":150}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":146}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":147}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":148}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":149}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":150}
                └── UpdateSchemaChangerJob {"IsNonCancelable":true,"RunningStatus":"all stages compl..."}

statement error pq: cannot drop relation "v1dep" because view "v3dep" depends on it
DROP VIEW v1Dep RESTRICT;

statement error pq: "v1dep" is not a materialized view
DROP MATERIALIZED VIEW v1Dep

statement ok
DROP VIEW v1Dep CASCADE;

statement error pq: relation "v4dep" does not exist
SELECT * FROM v4Dep;

statement error pq: relation "v3dep" does not exist
SELECT * FROM v3Dep;

statement error pq: relation "v2dep" does not exist
SELECT * FROM v2Dep;

statement error pq: relation "v1dep" does not exist
SELECT * FROM v1Dep;

statement ok
CREATE MATERIALIZED VIEW mv AS SELECT name FROM t1

statement error pq: "mv" is a materialized view
DROP VIEW mv

statement ok
DROP MATERIALIZED VIEW mv

statement ok
CREATE TABLE defaultdb.customers (id INT PRIMARY KEY, email STRING UNIQUE);

statement ok
CREATE TABLE IF NOT EXISTS defaultdb.orders (
    id INT PRIMARY KEY,
    customer INT UNIQUE NOT NULL REFERENCES defaultdb.customers (id),
    orderTotal DECIMAL(9,2),
    INDEX (customer)
  );

statement ok
CREATE SEQUENCE defaultdb.sq2;

statement ok
CREATE TABLE defaultdb.shipments (
    tracking_number UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    carrier STRING,
    status STRING,
    customer_id INT,
    rand_col INT DEFAULT nextval('defaultdb.sq2'),
    CONSTRAINT fk_customers FOREIGN KEY (customer_id) REFERENCES defaultdb.customers(id),
    CONSTRAINT fk_orders FOREIGN KEY (customer_id) REFERENCES defaultdb.orders(customer)
 );

statement error "customers" is referenced by foreign key from table "shipments"
DROP TABLE defaultdb.customers;

statement ok
CREATE SEQUENCE defaultdb.sq1 OWNED BY defaultdb.shipments.carrier;

statement ok
CREATE TABLE defaultdb.sq1dep (
	rand_col INT8 DEFAULT nextval('defaultdb.sq1')
);

statement error cannot drop table shipments because other objects depend on it
DROP TABLE defaultdb.shipments;

statement ok
DROP TABLE defaultdb.sq1dep;
DROP TABLE defaultdb.shipments;

statement ok
CREATE TABLE defaultdb.shipments (
    tracking_number UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    carrier STRING,
    status STRING,
    customer_id INT,
    rand_col INT DEFAULT nextval('defaultdb.sq2'),
    CONSTRAINT fk_customers FOREIGN KEY (customer_id) REFERENCES defaultdb.customers(id),
    CONSTRAINT fk_orders FOREIGN KEY (customer_id) REFERENCES defaultdb.orders(customer)
 );

statement ok
CREATE VIEW defaultdb.v1 as (select customer_id, carrier from defaultdb.shipments);

statement error pq: cannot drop relation "shipments" because view "v1" depends on it
DROP TABLE defaultdb.shipments;

statement ok
DROP TABLE defaultdb.shipments CASCADE;

# Back references for shipments should be cleaned up for any foreign
# keys so dropping customers and orders should be safe.
statement ok
DROP TABLE defaultdb.customers CASCADE;

statement ok
CREATE TABLE p2 (i INT PRIMARY KEY, s STRING)

statement ok
SET use_declarative_schema_changer = 'unsafe_always'

statement ok
SET use_declarative_schema_changer = 'unsafe'

# Basic test -- create and drop a type.
statement ok
CREATE TYPE typ8 AS ENUM ('hello');
DROP TYPE typ8

statement ok
CREATE TYPE typ8 AS ENUM ('hello');

# Now check all of the fun cases around object dependencies.
# Test a simple column dependency.
statement ok
CREATE TABLE t8 (x typ8)

statement error cannot drop type "typ8" because other objects \(\[test.public.t8\]\) still depend on it
DROP TYPE typ8

# Now add a column with the using the type.
statement ok
ALTER TABLE t8 ADD COLUMN y typ8

statement error cannot drop type "typ8" because other objects \(\[test.public.t8\]\) still depend on it
DROP TYPE typ8

# If we drop the original column x, t8 should still depend on t.
statement ok
ALTER TABLE t8 DROP COLUMN x

statement error cannot drop type "typ8" because other objects \(\[test.public.t8\]\) still depend on it
DROP TYPE typ8

# Now remove the other column.
statement ok
ALTER TABLE t8 DROP COLUMN y

statement ok
DROP TYPE typ8

# Ensure that references to the array type are tracked.
statement ok
CREATE TYPE typ8 AS ENUM ('hello');
ALTER TABLE t8 ADD COLUMN x typ8[]

statement error cannot drop type "typ8" because other objects \(\[test.public.t8\]\) still depend on it
DROP TYPE typ8

statement ok
ALTER TABLE t8 DROP COLUMN x;

statement ok
DROP TYPE typ8

subtest drop_type_in_single_transaction

statement ok
CREATE TYPE defaultdb.typ AS ENUM('a');

statement ok
CREATE TABLE defaultdb.ttyp (id INT PRIMARY KEY, name varchar(256), x defaultdb.typ);

statement ok
BEGIN;

statement ok;
DROP TABLE defaultdb.ttyp;

statement ok
DROP TYPE defaultdb.typ;

statement ok
COMMIT;

# Drop schema testing
subtest drop_schema

statement ok
CREATE DATABASE db1;

statement ok
CREATE SCHEMA db1.sc1

statement ok
CREATE SEQUENCE db1.sc1.sq1

statement ok
CREATE TABLE db1.sc1.t1 (id INT PRIMARY KEY, name varchar(256), val int DEFAULT nextval('db1.sc1.sq1'))

statement ok
CREATE VIEW db1.sc1.v1 AS (SELECT name FROM db1.sc1.t1)

statement ok
CREATE VIEW db1.sc1.v2 AS (SELECT name AS n1, name AS n2 FROM db1.sc1.v1)

statement ok
CREATE VIEW db1.sc1.v3 AS (SELECT name, n1 FROM db1.sc1.v1, db1.sc1.v2);

statement ok
CREATE VIEW db1.sc1.v4 AS (SELECT n2, n1 FROM db1.sc1.v2);

statement ok
CREATE TYPE db1.sc1.typ AS ENUM('a')

statement ok
CREATE VIEW db1.sc1.v5 AS (SELECT 'a'::db1.sc1.typ::string AS k, n2, n1 from db1.sc1.v4)

statement ok
CREATE SCHEMA sc2

statement ok
CREATE TYPE sc2.typ AS ENUM('a')

# Cross-database type references are not allowed.
statement error cross database type references are not supported: test.sc2.typ
CREATE VIEW db1.sc1.v6 AS (SELECT 'a'::sc2.typ::string AS k, n2, n1 from db1.sc1.v4)

statement ok
DROP SCHEMA db1.sc1 CASCADE

statement ok
DROP SCHEMA sc2 CASCADE

statement ok
DROP DATABASE db1 CASCADE

# Drop database testing
subtest drop_database

statement ok
CREATE ROLE test_set_role;

statement ok
CREATE DATABASE db1;

statement ok
ALTER ROLE test_set_role SET application_name = 'a';
ALTER ROLE test_set_role IN DATABASE db1 SET application_name = 'b';
ALTER ROLE ALL IN DATABASE db1 SET application_name = 'c';
ALTER ROLE ALL SET application_name = 'd';
ALTER ROLE test_set_role SET custom_option.setting = 'e'

statement ok
CREATE SCHEMA db1.sc1

statement ok
CREATE SEQUENCE db1.public.sq1

statement ok
CREATE SEQUENCE db1.sc1.sq1

statement ok
CREATE TABLE db1.sc1.t1 (id INT PRIMARY KEY, name varchar(256), val int DEFAULT nextval('db1.sc1.sq1'))

statement ok
CREATE TABLE db1.public.t1 (id INT PRIMARY KEY, name varchar(256), val int DEFAULT nextval('db1.public.sq1'))

statement ok
CREATE VIEW db1.sc1.v1 AS (SELECT name FROM db1.sc1.t1)

statement ok
CREATE VIEW db1.sc1.v2 AS (SELECT name AS n1, name AS n2 FROM db1.sc1.v1)

statement ok
CREATE VIEW db1.sc1.v3 AS (SELECT name, n1 FROM db1.sc1.v1, db1.sc1.v2);

statement ok
CREATE VIEW db1.sc1.v4 AS (SELECT n2, n1 FROM db1.sc1.v2);

statement ok
CREATE INDEX tmp_idx ON db1.sc1.t1(name)

statement ok
use db1;
COMMENT ON DATABASE db1 IS 'BLAH';
COMMENT ON SCHEMA sc1 IS 'BLAH2';
COMMENT ON TABLE db1.sc1.t1 IS 'BLAH3';
COMMENT ON COLUMN db1.sc1.t1.id IS 'BLAH4';
COMMENT ON INDEX db1.sc1.tmp_idx IS 'BLAH5';
use test;

statement ok
CREATE TYPE db1.sc1.typ AS ENUM('a')

statement ok
CREATE VIEW db1.sc1.v5 AS (SELECT 'a'::db1.sc1.typ::string AS k, n2, n1 from db1.sc1.v4)

statement ok
CREATE SCHEMA sc2

statement ok
CREATE TYPE sc2.typ AS ENUM('a')

# Cross-database type references are not allowed.
statement error cross database type references are not supported: test.sc2.typ
CREATE VIEW db1.sc1.v6 AS (SELECT 'a'::sc2.typ::string AS k, n2, n1 from db1.sc1.v4)

# Confirm comments exist.
query T
SELECT comment FROM system.comments ORDER BY comment ASC
----
BLAH
BLAH2
BLAH3
BLAH4
BLAH5

# Verify that the current set of role settings.
# Note that the NULL name corresponds the ALL DATABASES configurations.
query TTT colnames
  SELECT name, role_name, settings
    FROM system.database_role_settings
         LEFT JOIN system.namespace AS ns ON database_id = ns.id
ORDER BY name, role_name;
----
name  role_name      settings
NULL  ·              {application_name=d}
NULL  test_set_role  {application_name=a,custom_option.setting=e}
db1   ·              {application_name=c}
db1   test_set_role  {application_name=b}

statement error schema "sc1" is not empty and CASCADE was not specified
DROP SCHEMA db1.sc1

statement error database "db1" is not empty and RESTRICT was specified
DROP DATABASE db1 RESTRICT

statement ok
SET use_declarative_schema_changer = 'unsafe_always'

# Sanity check: Things are properly executed in post rollback. We should
# be able to select from tables/views/sequences still
statement ok
BEGIN

statement ok
DROP DATABASE db1 CASCADE

statement error database "db1" is offline: DROP DATABASE db1 CASCADE
SELECT * from db1.sc1.v1

statement ok
ROLLBACK

statement ok
SELECT * from db1.sc1.v1

statement ok
SELECT * from db1.sc1.t1

statement ok
SELECT * from db1.sc1.sq1

statement ok
SELECT 'a'::db1.sc1.typ::string

statement ok
SET use_declarative_schema_changer = 'unsafe'

let $desc_count_pre_drop
select count(*) from system.descriptor

# Actually drop the database now.
statement ok
DROP DATABASE db1 CASCADE

statement ok
DROP SCHEMA sc2 CASCADE

# No comments should be left after.
query T
SELECT comment FROM system.comments ORDER BY comment ASC
----

# Verify that the remaining set of role settings
query OTT colnames
SELECT database_id, role_name, settings FROM system.database_role_settings ORDER BY 1, 2
----
database_id  role_name      settings
0            ·              {application_name=d}
0            test_set_role  {application_name=a,custom_option.setting=e}

let $desc_count_post_drop
select count(*) from system.descriptor

# Excluding anything that needs GC, we should drop by 13 (4 types [array and
# normal], 4 schemas, and 5 views)
query I
select $desc_count_pre_drop-$desc_count_post_drop
----
13

# Tests for computed column rewrites.
statement ok
CREATE TABLE trewrite(k INT PRIMARY KEY, ts TIMESTAMPTZ, FAMILY (k,ts))

statement error context-dependent operators are not allowed in computed column
ALTER TABLE trewrite ADD COLUMN c STRING AS (ts::STRING) STORED

statement ok
SET experimental_computed_column_rewrites = "(ts :: STRING) -> (to_char(ts AT TIME ZONE 'utc'))";

statement ok
ALTER TABLE trewrite ADD COLUMN c STRING AS (ts::STRING) STORED

query T
SELECT create_statement FROM [SHOW CREATE TABLE trewrite]
----
CREATE TABLE public.trewrite (
   k INT8 NOT NULL,
   ts TIMESTAMPTZ NULL,
   c STRING NULL AS (to_char(timezone('utc':::STRING, ts))) STORED,
   CONSTRAINT trewrite_pkey PRIMARY KEY (k ASC),
   FAMILY fam_0_k_ts (k, ts, c)
)

subtest create-index

statement ok
CREATE TABLE tIndex (
  a INT PRIMARY KEY,
  b INT,
  FAMILY (a),
  FAMILY (b)
)

statement ok
INSERT INTO tIndex VALUES (1,1)

user root

statement ok
CREATE INDEX foo ON tIndex (b)

statement error index with name "foo" already exists
CREATE INDEX foo ON tIndex (a)

statement error column "c" does not exist
CREATE INDEX bar ON tIndex (c)

statement error index \"bar\" contains duplicate column \"b\"
CREATE INDEX bar ON tIndex (b, b);

statement ok
CREATE INDEX bar ON tIndex ((a+b))

statement ok
CREATE INDEX bar2 ON tIndex (abs(b))

statement ok
CREATE UNIQUE INDEX bar3 ON tIndex (abs(b))

statement ok
CREATE INVERTED INDEX bar4 ON tIndex ((ARRAY[a,b]))

statement ok
CREATE TABLE tIndx2 (a INT PRIMARY KEY, b INT, INDEX ((a+b)))

statement ok
CREATE TABLE tIndx3 (a INT PRIMARY KEY, b INT, INVERTED INDEX ((ARRAY[a,b])))

query TTBITTBB colnames
SHOW INDEXES FROM tIndex
----
table_name  index_name   non_unique  seq_in_index  column_name               direction  storing  implicit
tindex      bar          true        1             crdb_internal_idx_expr    ASC        false    false
tindex      bar          true        2             a                         ASC        false    true
tindex      bar2         true        1             crdb_internal_idx_expr_1  ASC        false    false
tindex      bar2         true        2             a                         ASC        false    true
tindex      bar3         false       1             crdb_internal_idx_expr_2  ASC        false    false
tindex      bar3         false       2             a                         ASC        true     true
tindex      bar4         true        1             crdb_internal_idx_expr_3  ASC        false    false
tindex      bar4         true        2             a                         ASC        false    true
tindex      foo          true        1             b                         ASC        false    false
tindex      foo          true        2             a                         ASC        false    true
tindex      tindex_pkey  false       1             a                         ASC        false    false
tindex      tindex_pkey  false       2             b                         N/A        true     false

statement error  duplicate key value violates unique constraint "bar3"
INSERT INTO tIndex VALUES (2,1)

statement ok
INSERT INTO tIndex VALUES (20000,10000)

# FIXME: Disabled until rollback is supported
#statement error pgcode 23505 violates unique constraint "bar"
#CREATE UNIQUE INDEX bar ON tIndex (b)

query TTBITTBB colnames
SHOW INDEXES FROM tIndex
----
table_name  index_name   non_unique  seq_in_index  column_name               direction  storing  implicit
tindex      bar          true        1             crdb_internal_idx_expr    ASC        false    false
tindex      bar          true        2             a                         ASC        false    true
tindex      bar2         true        1             crdb_internal_idx_expr_1  ASC        false    false
tindex      bar2         true        2             a                         ASC        false    true
tindex      bar3         false       1             crdb_internal_idx_expr_2  ASC        false    false
tindex      bar3         false       2             a                         ASC        true     true
tindex      bar4         true        1             crdb_internal_idx_expr_3  ASC        false    false
tindex      bar4         true        2             a                         ASC        false    true
tindex      foo          true        1             b                         ASC        false    false
tindex      foo          true        2             a                         ASC        false    true
tindex      tindex_pkey  false       1             a                         ASC        false    false
tindex      tindex_pkey  false       2             b                         N/A        true     false

# test for DESC index

statement ok
DROP TABLE tIndex

statement ok
CREATE TABLE tIndx (
  a INT PRIMARY KEY,
  b INT,
  c INT
)

statement ok
INSERT INTO tIndx VALUES (1,1,1), (2,2,2)

statement ok
CREATE INDEX b_desc ON tIndx (b DESC)

statement ok
CREATE INDEX b_asc ON tIndx (b ASC, c DESC)

query TTBITTBB colnames
SHOW INDEXES FROM tIndx
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
tindx       b_asc       true        1             b            ASC        false    false
tindx       b_asc       true        2             c            DESC       false    false
tindx       b_asc       true        3             a            ASC        false    true
tindx       b_desc      true        1             b            DESC       false    false
tindx       b_desc      true        2             a            ASC        false    true
tindx       tindx_pkey  false       1             a            ASC        false    false
tindx       tindx_pkey  false       2             b            N/A        true     false
tindx       tindx_pkey  false       3             c            N/A        true     false

statement error pgcode 42P01 relation "foo" does not exist
CREATE INDEX fail ON foo (b DESC)

statement ok
CREATE VIEW vIndx AS SELECT a,b FROM tIndx

statement error pgcode 42809 "vindx" is not an indexable table or a materialized view
CREATE INDEX failview ON vIndx (b DESC)

statement ok
CREATE TABLE privs (a INT PRIMARY KEY, b INT)

user testuser

statement error user testuser does not have CREATE privilege on relation privs
CREATE INDEX foo ON privs (b)

user root

query TTBITTBB colnames
SHOW INDEXES FROM privs
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
privs       privs_pkey  false       1             a            ASC        false    false
privs       privs_pkey  false       2             b            N/A        true     false

statement ok
GRANT CREATE ON privs TO testuser

user testuser

statement ok
CREATE INDEX foo ON privs (b)

query TTBITTBB colnames
SHOW INDEXES FROM privs
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
privs       foo         true        1             b            ASC        false    false
privs       foo         true        2             a            ASC        false    true
privs       privs_pkey  false       1             a            ASC        false    false
privs       privs_pkey  false       2             b            N/A        true     false

user root

statement ok
CREATE TABLE telemetry (
  x INT PRIMARY KEY,
  y INT,
  z JSONB
)

# Test that creating an index on a column which is currently being dropped
# causes an error.
subtest create_index_on_dropping_column

statement ok
CREATE TABLE create_idx_drop_column (c0 INT PRIMARY KEY, c1 INT);

statement ok
begin; ALTER TABLE create_idx_drop_column DROP COLUMN c1;

statement error column "c1" does not exist
CREATE INDEX idx_create_idx_drop_column ON create_idx_drop_column (c1);

statement ok
ROLLBACK;

statement ok
DROP TABLE create_idx_drop_column;

# Sanity test that dropping table descriptors
# with the wrong type specified is correctly blocked.
subtest drop-type-sanity

statement ok
CREATE TABLE t1dr(name varchar(256));

statement ok
CREATE VIEW v1dr as (select name from t1dr);

statement ok
CREATE SEQUENCE s1dr;

statement error pq: "t1dr" is not a view
DROP VIEW t1dr;

statement error pq: "t1dr" is not a sequence
DROP SEQUENCE t1dr;

statement error pq: "v1dr" is not a table
DROP TABLE v1dr

statement error pq: "v1dr" is not a sequence
DROP SEQUENCE v1dr;

statement error pq: "s1dr" is not a view
DROP VIEW s1dr

statement error pq: "s1dr" is not a table
DROP TABLE s1dr;

# Event log related subtest
subtest event-log

statement ok
SET use_declarative_schema_changer = 'unsafe'

statement ok
set sql_safe_updates=false;

statement ok
CREATE TABLE t1ev(name varchar(256));

statement ok
CREATE TABLE t2ev(name varchar(256));

statement ok
CREATE VIEW v1ev AS (SELECT name FROM t1ev);

statement ok
CREATE VIEW v2ev AS (SELECT name FROM t2ev);

statement ok
CREATE VIEW v4ev AS (SELECT name FROM V1EV);

statement ok
CREATE VIEW v3ev AS (SELECT name FROM V2EV);

statement ok
DELETE FROM system.eventlog;

statement ok
DROP VIEW v1ev CASCADE;

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog;
----
1  {"CascadeDroppedViews": ["test.public.v4ev"], "EventType": "drop_view", "Statement": "DROP VIEW test.public.v1ev CASCADE", "Tag": "DROP VIEW", "User": "root", "ViewName": "test.public.v1ev"}

statement ok
CREATE VIEW v1ev AS (SELECT name FROM T1EV);

statement ok
CREATE VIEW v4ev AS (SELECT name FROM V1EV);

statement ok
DELETE FROM system.eventlog;

statement ok
DROP TABLE t1ev,t2ev CASCADE;

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
ORDER BY timestamp, info DESC;
----
1  {"CascadeDroppedViews": ["test.public.v2ev", "test.public.v3ev"], "EventType": "drop_table", "Statement": "DROP TABLE test.public.t1ev, test.public.t2ev CASCADE", "TableName": "test.public.t2ev", "Tag": "DROP TABLE", "User": "root"}
1  {"CascadeDroppedViews": ["test.public.v1ev", "test.public.v4ev"], "EventType": "drop_table", "Statement": "DROP TABLE test.public.t1ev, test.public.t2ev CASCADE", "TableName": "test.public.t1ev", "Tag": "DROP TABLE", "User": "root"}

statement ok
CREATE TABLE fooev (i INT PRIMARY KEY);

statement ok
DELETE FROM system.eventlog;

statement ok
ALTER TABLE fooev ADD COLUMN j INT

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
ORDER BY timestamp, info DESC;
----
1  {"EventType": "alter_table", "MutationID": 1, "Statement": "ALTER TABLE test.public.fooev ADD COLUMN j INT8", "TableName": "test.public.fooev", "Tag": "ALTER TABLE", "User": "root"}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}

subtest names-with-escaped-chars

# We are intentionally injecting characters that might get escaped due to
# incorrect string conversion functions. As a result if descriptors look
# ups use these incorrectly escaped strings we would be in trouble.
statement ok
CREATE DATABASE "'db1-a'";

statement ok
CREATE SCHEMA "'db1-a'".sc1;

statement ok
CREATE SCHEMA "'db1-a'".sc2;

statement ok
CREATE DATABASE db2;

statement ok
CREATE SCHEMA db2.sc3;

# Similarly try using special characters making an index for a new table, we
# will attempt to recreate it and expect the look up to find the old one.
statement ok
CREATE TABLE "'db1-a'"."'t1-esc'"(name int);

statement ok
CREATE INDEX "'t1-esc-index'" ON "'db1-a'"."'t1-esc'"(name)

statement error index with name "'t1-esc-index'" already exists
CREATE INDEX "'t1-esc-index'" ON "'db1-a'"."'t1-esc'"(name)

statement ok
delete from system.eventlog;

statement ok
DROP DATABASE "'db1-a'" cascade;

statement ok
DROP DATABASE db2 cascade;

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
ORDER BY timestamp, info DESC;
----
1  {"DatabaseName": "'db1-a'", "DroppedSchemaObjects": ["\"'db1-a'\".public.\"'t1-esc'\""], "EventType": "drop_database", "Statement": "DROP DATABASE \"'db1-a'\" CASCADE", "Tag": "DROP DATABASE", "User": "root"}
1  {"DatabaseName": "db2", "EventType": "drop_database", "Statement": "DROP DATABASE db2 CASCADE", "Tag": "DROP DATABASE", "User": "root"}

# Sanity: Dropping multiple objects in the builder or resolving any dependencies
# should function fine.
subtest drop-multiple-in-builder

statement ok
CREATE TABLE multi_t1 (name INTEGER PRIMARY KEY);
CREATE TABLE multi_t2 (name INTEGER, other INTEGER, FOREIGN KEY (other) REFERENCES multi_t1(name));
CREATE VIEW multi_v1 AS (SELECT name FROM multi_t1);
CREATE VIEW multi_v2 AS (SELECT name FROM multi_v1);

statement ok
CREATE SEQUENCE multi_sq1

statement ok
DROP VIEW multi_v1, multi_v2

statement ok
DROP TABLE multi_t1,multi_t2

statement ok
DROP SEQUENCE multi_sq1, multi_sq1

# Sequence related back ref test
subtest seq-back-ref

statement ok
CREATE SEQUENCE sqbf1;

statement ok
CREATE TABLE sbt1 (test INT not null, value INT not null DEFAULT nextval('sqbf1'))

statement ok
CREATE VIEW sbv1 AS SELECT  nextval('sqbf1')

statement ok
INSERT into sbt1 VALUES(1)

statement ok
select * from sbv1

statement ok
DROP SEQUENCE sqbf1 CASCADE

# Default expression is dropped so this should error out.
statement error null value in column "value" violates not-null constraint
INSERT into sbt1 VALUES(1)

# View referencing it should also be cleaned up.
statement error relation "sbv1" does not exist
select * from sbv1

subtest fk-backref-cleanup
statement ok
CREATE TABLE IF NOT EXISTS defaultdb.orders (
    id INT PRIMARY KEY,
    customer INT UNIQUE NOT NULL REFERENCES defaultdb.customers (id),
    orderTotal DECIMAL(9,2),
    INDEX (customer)
  );

statement ok
CREATE TABLE defaultdb.customers (id INT PRIMARY KEY, email STRING UNIQUE);

statement ok
CREATE TABLE defaultdb.shipments (
    tracking_number UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    carrier STRING,
    status STRING,
    customer_id INT,
    rand_col INT DEFAULT nextval('defaultdb.sq2'),
    CONSTRAINT fk_customers FOREIGN KEY (customer_id) REFERENCES defaultdb.customers(id),
    CONSTRAINT fk_orders FOREIGN KEY (customer_id) REFERENCES defaultdb.orders(customer)
 );

 statement ok
 DROP TABLE defaultdb.customers CASCADE;

 statement ok
 DROP TABLE defaultdb.orders CASCADE;

 # Foreign key back constraints should be cleaned up.
 statement ok
INSERT into  defaultdb.shipments values ( gen_random_uuid(), 'a', 'b', 10842)

statement ok
DROP TABLE defaultdb.shipments CASCADE;

subtest validate-drops-with-multiple-constraints

# When decomposing and dropping this table we will have multiple
# constraints that need to be cleaned up.
statement ok
CREATE TABLE const (a INT, b INT,
CONSTRAINT id_unique UNIQUE (a),
CONSTRAINT b_unique UNIQUE (b)
);

statement ok
DROP TABLE const

subtest schema-dep-sanity

# Test that we can drop multiple schemas as part of a single DROP statement,with
# interleaved dependencies between schemas. As a result some child elements will
# be added by a different schema due to cascaded drop behavior. i.e. Cross
# schema behavior for views and tables.
statement ok
CREATE SCHEMA scdrop1;
CREATE SCHEMA scdrop2;
CREATE SCHEMA scdrop3;
CREATE TABLE scdrop1.scdrop1_t1 (x INT);
CREATE TABLE scdrop1.scdrop1_t2 (x INT);
CREATE TABLE scdrop2.scdrop2_t1 (x INT);
CREATE VIEW scdrop2.scdrop2_v1 AS SELECT x FROM scdrop1.scdrop1_t1;
CREATE VIEW scdrop3.scdrop3_v1 AS SELECT x FROM scdrop2.scdrop2_v1;

statement ok
DROP SCHEMA scdrop1, scdrop2, scdrop3 CASCADE

# Validates that if an owned by sequence is dropped, then the back reference
# inside the table gets cleaned up.
subtest validate-sequence-owner

statement ok
CREATE TABLE seqowner(name int);

statement ok
CREATE SEQUENCE seqowned OWNED BY seqowner.name;

statement ok
DROP SEQUENCE seqowned;

# Reference to the sequences should have been removed.
statement ok
DROP TABLE seqowner;

subtest drop-type-closure

# Tables with expressions and different varieties of type
# referecnes.
statement ok
CREATE TYPE d_tc AS ENUM ('hello');
CREATE TYPE d2_tc AS ENUM ('howdy');
CREATE TABLE ttc1 (x d_tc);
CREATE TABLE ttc2 (y d_tc[]);
CREATE TABLE ttc3 (
  x BOOL DEFAULT ('hello'::d_tc = 'hello'::d_tc),
  y STRING AS ('howdy'::d2_tc::STRING) STORED,
  CHECK ('hello'::d_tc::string = 'hello'),
  INDEX i(y) WHERE ('hello'::d_tc = 'hello'::d_tc)
);

statement error cannot drop type "d_tc" because other objects \(\[test.public.ttc1 test.public.ttc2 test.public.ttc3\]\) still depend on it
DROP TYPE d_tc;

statement ok
DROP TABLE ttc1;

statement error cannot drop type "d_tc" because other objects \(\[test.public.ttc2 test.public.ttc3\]\) still depend on it
DROP TYPE d_tc;

statement ok
DROP TABLE ttc2;

statement error cannot drop type "d_tc" because other objects \(\[test.public.ttc3\]\) still depend on it
DROP TYPE d_tc;

statement ok
DROP TABLE ttc3;

statement ok
DROP TYPE d_tc;

subtest empty-database

statement error empty database name
DROP DATABASE ""

subtest schema-permission-error

user root

statement ok
CREATE SCHEMA sc1;

statement ok
CREATE DATABASE db1;

user testuser

statement ok
SET use_declarative_schema_changer = 'on'

statement error must be owner of schema sc1
DROP SCHEMA sc1;

statement error user testuser does not have DROP privilege on database db1
DROP DATABASE db1;

subtest sc-job-eager-descriptor-id-removal

statement ok
CREATE TABLE parent (k INT PRIMARY KEY, v STRING NOT NULL);

statement ok
CREATE UNIQUE INDEX idx ON parent (v)

statement ok
CREATE VIEW child AS SELECT count(*) FROM parent@idx

statement ok
SET use_declarative_schema_changer = 'unsafe'

statement error pgcode 2BP01 cannot drop index "parent@idx" because view "child" depends on it
DROP INDEX parent@idx

query T
EXPLAIN (DDL) DROP INDEX parent@idx CASCADE;
----
Schema change plan for DROP INDEX ‹test›.public.‹parent›@‹idx› CASCADE;
 ├── StatementPhase
 │    └── Stage 1 of 1 in StatementPhase
 │         ├── 6 elements transitioning toward ABSENT
 │         │    ├── PUBLIC → VALIDATED  SecondaryIndex:{DescID: 265, IndexID: 2, ConstraintID: 2}
 │         │    ├── PUBLIC → ABSENT     IndexName:{DescID: 265, Name: idx, IndexID: 2}
 │         │    ├── PUBLIC → OFFLINE    View:{DescID: 266}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 266, ColumnID: 1}
 │         │    ├── PUBLIC → WRITE_ONLY Column:{DescID: 266, ColumnID: 4294967295}
 │         │    └── PUBLIC → WRITE_ONLY Column:{DescID: 266, ColumnID: 4294967294}
 │         └── 3 Mutation operations
 │              ├── MakeDroppedNonPrimaryIndexDeleteAndWriteOnly {"IndexID":2,"TableID":265}
 │              ├── SetIndexName {"IndexID":2,"Name":"crdb_internal_in...","TableID":265}
 │              └── MarkDescriptorAsOffline {"DescID":266,"Reason":"DROP INDEX test...."}
 ├── PreCommitPhase
 │    └── Stage 1 of 1 in PreCommitPhase
 │         └── 3 Mutation operations
 │              ├── SetJobStateOnDescriptor {"DescriptorID":265,"Initialize":true}
 │              ├── SetJobStateOnDescriptor {"DescriptorID":266,"Initialize":true}
 │              └── CreateSchemaChangerJob {"NonCancelable":true,"RunningStatus":"PostCommitNonRev..."}
 └── PostCommitNonRevertiblePhase
      ├── Stage 1 of 2 in PostCommitNonRevertiblePhase
      │    ├── 19 elements transitioning toward ABSENT
      │    │    ├── PUBLIC     → ABSENT      IndexColumn:{DescID: 265, ColumnID: 2, IndexID: 2}
      │    │    ├── PUBLIC     → ABSENT      IndexColumn:{DescID: 265, ColumnID: 1, IndexID: 2}
      │    │    ├── VALIDATED  → DELETE_ONLY SecondaryIndex:{DescID: 265, IndexID: 2, ConstraintID: 2}
      │    │    ├── PUBLIC     → ABSENT      Namespace:{DescID: 266, Name: child, ReferencedDescID: 104}
      │    │    ├── PUBLIC     → ABSENT      Owner:{DescID: 266}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 266, Name: admin}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 266, Name: root}
      │    │    ├── PUBLIC     → ABSENT      UserPrivileges:{DescID: 266, Name: testuser}
      │    │    ├── OFFLINE    → DROPPED     View:{DescID: 266}
      │    │    ├── PUBLIC     → ABSENT      ObjectParent:{DescID: 266, ReferencedDescID: 105}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 266, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 266, Name: count, ColumnID: 1}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 266, ColumnFamilyID: 0, ColumnID: 1}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 266, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 266, Name: crdb_internal_mvcc_timestamp, ColumnID: 4294967295}
      │    │    ├── PUBLIC     → ABSENT      ColumnType:{DescID: 266, ColumnFamilyID: 0, ColumnID: 4294967295}
      │    │    ├── WRITE_ONLY → DELETE_ONLY Column:{DescID: 266, ColumnID: 4294967294}
      │    │    ├── PUBLIC     → ABSENT      ColumnName:{DescID: 266, Name: tableoid, ColumnID: 4294967294}
      │    │    └── PUBLIC     → ABSENT      ColumnType:{DescID: 266, ColumnFamilyID: 0, ColumnID: 4294967294}
      │    └── 10 Mutation operations
      │         ├── MarkDescriptorAsDropped {"DescID":266}
      │         ├── RemoveViewBackReferencesInRelations {"BackReferencedViewID":266}
      │         ├── RemoveAllTableComments {"TableID":266}
      │         ├── MakeDroppedIndexDeleteOnly {"IndexID":2,"TableID":265}
      │         ├── DrainDescriptorName {"Namespace":{"DatabaseID":104,"DescriptorID":266,"Name":"child","SchemaID":105}}
      │         ├── scop.RemoveColumnFromIndex {"ColumnID":2,"IndexID":2,"TableID":265}
      │         ├── scop.RemoveColumnFromIndex {"ColumnID":1,"IndexID":2,"Kind":1,"TableID":265}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":265}
      │         ├── SetJobStateOnDescriptor {"DescriptorID":266}
      │         └── UpdateSchemaChangerJob {"IsNonCancelable":true,"RunningStatus":"PostCommitNonRev..."}
      └── Stage 2 of 2 in PostCommitNonRevertiblePhase
           ├── 5 elements transitioning toward ABSENT
           │    ├── DELETE_ONLY → ABSENT SecondaryIndex:{DescID: 265, IndexID: 2, ConstraintID: 2}
           │    ├── DROPPED     → ABSENT View:{DescID: 266}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 266, ColumnID: 1}
           │    ├── DELETE_ONLY → ABSENT Column:{DescID: 266, ColumnID: 4294967295}
           │    └── DELETE_ONLY → ABSENT Column:{DescID: 266, ColumnID: 4294967294}
           └── 11 Mutation operations
                ├── LogEvent {"TargetStatus":1}
                ├── CreateGcJobForIndex {"IndexID":2,"TableID":265}
                ├── MakeIndexAbsent {"IndexID":2,"TableID":265}
                ├── LogEvent {"TargetStatus":1}
                ├── DeleteDescriptor {"DescriptorID":266}
                ├── MakeColumnAbsent {"ColumnID":1,"TableID":266}
                ├── MakeColumnAbsent {"ColumnID":4294967295,"TableID":266}
                ├── MakeColumnAbsent {"ColumnID":4294967294,"TableID":266}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":265}
                ├── RemoveJobStateFromDescriptor {"DescriptorID":266}
                └── UpdateSchemaChangerJob {"IsNonCancelable":true,"RunningStatus":"all stages compl..."}


statement ok
SET use_declarative_schema_changer = 'on'

subtest drop-database-cascade

user root

statement ok
DROP DATABASE test CASCADE

statement ok
CREATE DATABASE test;
USE test

subtest add_multiple_columns_in_transaction

statement ok
CREATE TABLE t (i INT PRIMARY KEY);
INSERT INTO t VALUES (1), (2), (3)

statement ok
SET use_declarative_schema_changer = 'unsafe_always';

statement ok
BEGIN

statement ok
ALTER TABLE t ADD COLUMN k INT AS (i + 3) STORED NOT NULL UNIQUE;
ALTER TABLE t ADD COLUMN j INT DEFAULT 42;

statement ok
COMMIT

query T
SELECT create_statement FROM [SHOW CREATE TABLE t]
----
CREATE TABLE public.t (
   i INT8 NOT NULL,
   k INT8 NOT NULL AS (i + 3:::INT8) STORED,
   j INT8 NULL DEFAULT 42:::INT8,
   CONSTRAINT t_pkey PRIMARY KEY (i ASC),
   UNIQUE INDEX t_expr_key (k ASC)
)

query III rowsort
SELECT * FROM t
----
1  4  42
2  5  42
3  6  42
