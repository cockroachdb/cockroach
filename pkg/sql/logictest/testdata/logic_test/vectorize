# LogicTest: local local-vec

# Disable automatic stats.
statement ok
SET CLUSTER SETTING sql.stats.automatic_collection.enabled = false

statement ok
CREATE TABLE a (a INT, b INT, c INT4, PRIMARY KEY (a, b))

statement ok
INSERT INTO a SELECT g//2, g, g FROM generate_series(0,2000) g(g)

query II
SELECT a, CASE WHEN a = 0 THEN 0 WHEN a = 1 THEN 3 ELSE 5 END FROM a LIMIT 6
----
0  0
0  0
1  3
1  3
2  5
2  5

# Regression test for 40574.
statement ok
CREATE TABLE t40574(pk INTEGER PRIMARY KEY, col0 INTEGER, col1 FLOAT, col2 TEXT, col3 INTEGER, col4 FLOAT, col5 TEXT)

query I
SELECT pk FROM t40574 WHERE (col0 > 9 AND (col1 <= 6.38 OR col0 =5) AND (col0 = 7 OR col4 = 7))
----

# OR expression as projection.
query IB
SELECT b, b = 0 OR b = 2 FROM a WHERE b < 4
----
0  true
1  false
2  true
3  false

# OR expression as selection.
query I
SELECT b FROM a WHERE b = 0 OR b = 2
----
0
2

# Check that the right side of an OR isn't evaluated if the left side is true.
query I
SELECT b FROM a WHERE b = 0 OR 1/b = 1
----
0
1

statement ok
CREATE TABLE bools (b BOOL, i INT, PRIMARY KEY (b, i)); INSERT INTO bools VALUES (true, 0), (false, 1), (true, 2), (false, 3);

statement ok
CREATE TABLE nulls (a INT, b INT)

statement ok
INSERT INTO nulls VALUES (NULL, NULL), (NULL, 1), (1, NULL), (1, 1)

query I
SELECT count(*) FROM a
----
2001

query I
SELECT count(*) FROM (SELECT DISTINCT a FROM a)
----
1001

query III
SELECT * FROM a LIMIT 10
----
0  0  0
0  1  1
1  2  2
1  3  3
2  4  4
2  5  5
3  6  6
3  7  7
4  8  8
4  9  9

query II
SELECT DISTINCT(a), b FROM a LIMIT 10
----
0  0
0  1
1  2
1  3
2  4
2  5
3  6
3  7
4  8
4  9

# Simple filter.
query I
SELECT b FROM a WHERE b < 3
----
0
1
2

# Mixed type comparison
query IB
SELECT c, c > 1 FROM a LIMIT 3
----
0  false
1  false
2  true

# Simple filter with nulls.
query I
SELECT a FROM nulls WHERE a < 2
----
1
1

query II
SELECT a, b FROM nulls WHERE a <= b
----
1 1


# Filter on the result of a projection.
query II
SELECT a, b FROM a WHERE a * 2 < b LIMIT 5
----
0  1
1  3
2  5
3  7
4  9

# Simple projection.
query I
SELECT b + 1 FROM a WHERE b < 3
----
1
2
3

# Simple projection with nulls.
query I rowsort
SELECT b + 1 FROM nulls
----
NULL
NULL
2
2

query III rowsort
SELECT a, b, a + b FROM nulls
----
NULL NULL NULL
NULL 1    NULL
1    NULL NULL
1    1    2

# Multiple step projection.
query III
SELECT a, b, (a + 1) * (b + 2) FROM a WHERE a < 3
----
0  0  2
0  1  3
1  2  8
1  3  10
2  4  18
2  5  21

# Mismatched constant type in projection. Not handled yet but should fall back
# gracefully.
query I
SELECT (a + 1.0::DECIMAL)::INT FROM a LIMIT 1
----
1

# Operations with constants on the left work.
query I
SELECT 5 - a FROM a LIMIT 3
----
5
5
4

# Constant projections.
query II
SELECT 5, a FROM a LIMIT 3
----
5  0
5  0
5  1

# Filter on a boolean column.

query BI
SELECT * FROM bools WHERE b
----
true 0
true 2

# Mismatched column types in projection. Not handled yet but should fall back
# gracefully.
statement ok
CREATE TABLE intdecfloat (a INT, b DECIMAL, c INT4, d INT2, e FLOAT8)

statement ok
INSERT INTO intdecfloat VALUES (1, 2.0, 3, 4, 3.5)

query I
SELECT (a + b)::INT FROM intdecfloat
----
3

statement ok
SET vectorize = experimental_always

query BB
SELECT b > a, e < b FROM intdecfloat
----
true  false

query IR
SELECT a, b FROM intdecfloat WHERE a < b;
----
1  2.0

query RIRRI
SELECT a+b, a+c, b+c, b+d, c+d FROM intdecfloat
----
3.0  4  5.0  6.0  7

query RIRRI
SELECT a-b, a-c, b-c, b-d, c-d FROM intdecfloat
----
-1.0  -2  -1.0  -2.0  -1

query RIRRI
SELECT a*b, a*c, b*c, b*d, c*d FROM intdecfloat
----
2.0  3  6.0  8.0  12

query RRRRR
SELECT a/b, a/c, b/c, b/d, c/d FROM intdecfloat
----
0.5  0.33333333333333333333  0.66666666666666666667  0.5  0.75

statement ok
RESET vectorize

# vectorized decimal arithmetic
statement ok
CREATE table decimals (a DECIMAL, b DECIMAL)

statement ok
INSERT INTO decimals VALUES(123.0E200, 12.3)

statement ok
SET vectorize = experimental_always

query R
SELECT a*b FROM decimals
----
1.51290E+203

query R
SELECT a/b FROM decimals
----
1.0E+201

query R
SELECT a+b FROM decimals
----
12300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012.3

query R
SELECT a-b FROM decimals
----
12299999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999987.7

statement ok
RESET vectorize

# AND expressions.
query IIBB
SELECT a, b, a < 2 AND b > 0 AND a * b != 3, a < 2 AND b < 2 FROM a WHERE a < 2 AND b > 0 AND a * b != 3
----
0  1  true  true
1  2  true  false

statement ok
CREATE TABLE b (a INT, b STRING, PRIMARY KEY (b,a))

statement ok
INSERT INTO b VALUES
  (0, 'a'),
  (1, 'a'),
  (0, 'b'),
  (1, 'b')

query IT
SELECT sum_int(a), b from b group by b
----
1 a
1 b

# Test that lookup joins run fine through columnar execution.

statement ok
CREATE TABLE c (a INT, b INT, c INT, d INT, PRIMARY KEY (a, c), INDEX sec (b))

statement ok
CREATE TABLE d (a INT, b INT, PRIMARY KEY (b, a))

statement ok
INSERT INTO c VALUES (1, 1, 1, 0), (2, 1, 2, 0)

statement ok
INSERT INTO d VALUES (1, 1), (1, 2)

statement ok
ALTER TABLE c INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1,
    "distinct_count": 1
  }
]'

statement ok
SET optimizer = on

# Ensure that a lookup join is used.
query I
SELECT count(*) FROM [EXPLAIN SELECT c.a FROM c JOIN d ON d.b = c.b] WHERE tree LIKE '%lookup-join%'
----
1

statement ok
SET vectorize = experimental_always

# Simple lookup join.
query I
SELECT c.a FROM c JOIN d ON d.b = c.b
----
1
2

# Index join.
query I
SELECT c.d FROM c@sec
----
0
0

# Lookup join on secondary index, requires an index join into the primary
# index. Both of these should be wrapped and work fine.
query I
SELECT c.d FROM c@sec JOIN d ON d.b = c.b
----
0
0

# Ordinality operator with a filter and limit.
query IIII
SELECT * FROM a WITH ORDINALITY WHERE a > 1 LIMIT 6
----
2  4  4  5
2  5  5  6
3  6  6  7
3  7  7  8
4  8  8  9
4  9  9  10

# Ensure that lookup joins properly get their postprocessing to select needed
# columns.

query I
SELECT c.a FROM c INNER LOOKUP JOIN c@sec AS s ON c.b=s.b
----
1
1
2
2

# Test that LIKE expressions are properly handled by vectorized execution.
statement ok
RESET vectorize

statement ok
CREATE TABLE e (x TEXT)

statement ok
INSERT INTO e VALUES ('abc'), ('xyz'), (NULL)

statement ok
SET vectorize = experimental_always

query T
SELECT * FROM e WHERE x LIKE ''
----

query T
SELECT * FROM e WHERE x NOT LIKE '' ORDER BY 1
----
abc
xyz

query T
SELECT * FROM e WHERE x LIKE '%' ORDER BY 1
----
abc
xyz

query T
SELECT * FROM e WHERE x NOT LIKE '%'
----

query T
SELECT * FROM e WHERE x LIKE 'ab%'
----
abc

query T
SELECT * FROM e WHERE x NOT LIKE 'ab%'
----
xyz

query T
SELECT * FROM e WHERE x LIKE '%bc'
----
abc

query T
SELECT * FROM e WHERE x NOT LIKE '%bc'
----
xyz

query T
SELECT * FROM e WHERE x LIKE 'a%c'
----
abc

query T
SELECT * FROM e WHERE x NOT LIKE 'a%c'
----
xyz

query TBBBBBBBB
SELECT x, x LIKE '%', x NOT LIKE '%', x LIKE 'ab%', x NOT LIKE 'ab%', x LIKE '%bc', x NOT LIKE '%bc', x LIKE 'a%c', x NOT LIKE 'a%c' FROM e ORDER BY x
----
NULL  NULL  NULL   NULL   NULL   NULL   NULL   NULL   NULL
abc   true  false  true   false  true   false  true   false
xyz   true  false  false  true   false  true   false  true

# Test that vectorized stats are collected correctly.
statement ok
SET vectorize = experimental_on

statement ok
SET distsql = on

statement ok
SET vectorize_row_count_threshold = 0

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT a FROM a]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyMkMFO4zAQhu_7FNZ_2pW8kHACn1pBkCKFtjQ9AFUObjIqkdzY2BNEVeXdUeIe4IDEcb75Zux_TghvBgplVmS3G9F7I-7XywexzZ5WxTxfiPliXjy_ZOLvXV5uysfinzirOoq6gkRnG1roAwWoLVJUEs7bmkKwfkSnScibD6hEou1czyOuJGrrCeoEbtkQFDZ6Z2hNuiF_mUCiIdatmdY63x60P840JEqnu6DEf0gse1ZilkJip7l-pSBsz26EV5Dg3pmvKElGM5Chmtv3lo9KJBc31yNjbYzg9kBKJAHVIBGnzj8NrPcElQ7y92nWFJztAn0L8tPmZKgkqNlTvFiwva9p5W09PRPL5TQ3gYYCx24ai7yLraEa_nwGAAD__86elhA=

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c JOIN d ON d.b = c.b]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJykkk-P0zAQxe98itGcQDIl6dESUisoUlYhWdoegFUOrj1aDK4dPA50VeW7o_wRtEigRRz95r2Z-Y18Rv7qUOJuU25e7aGLDt5s67dwt3l_W66LCtbVuvzwcQNPXxe7_e5d-Qxmq16oyarhpi4qMFBXYBYHeAl6cWhQoA-GKnUkRnmHOTYC2xg0MYc4SOfRUJgTykyg9W2XBrkRqEMklGdMNjlCiXt1cLQlZSi-yFCgoaSsG9sy6ZVGgbtWeZbwHAXWXZKwysVqiQIPKulPxBC61A56jgJT17oLabAxOdLJfrPpQUK2yIYpnJRzkOyRJGSMTS9wisxbclL3hDLvxeNJboL1M0h-DdJGe1TxYWVQYBnCl66Fz8F6CF7CSDJj_R8TnUh3yQb_i0tgDN8ZIikz5665ByBDJ7hw5T_FR95o-S832hK3wTNd3edPnbO-EUjmnqYfxaGLmm5j0OOY6VmPuVEwxGmq5tOj8FNpWPAynP81vPwt3PRPfgQAAP__vR0M5w==

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c INNER MERGE JOIN d ON c.a = d.b]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJy8klFr2zAUhd_3Ky73qWVaartvgkLC5g2XxO6cPGwrflCku1SgWJ4kj5aQ_z4sF9aUbCVj9M06Op-kc6536H8Y5LjM5_n7FfTOwMe6WsBt_uVmPitKmJWz-ddvOZx9KJar5ef5OTxa5USMVglFWeY1LPL6Uw7XVVGCgqqMhitQk3WDDFurqBRb8shvMcWGYeesJO-tG6RdNBTqHnnCULddHwa5YSitI-Q7DDoYQo4rsTZUk1DkLhJkqCgIbeKxndNb4R6mEhkuO9F6Du-QYdUHDtMUGa5FkHfkwfahG8RBC31nnkgZMvRkSAb9U4cHDskkGa7xQRgDQW-JQ-Kx2TMckcdn-iA2hDzds3-Lkh6Poo5FyV4lSvbHKL8T9K11ihypg9c3A_mS5UgfC3Ibura6JXeRHfZh6Hs4m6Zvz6-c3tyNn_9rtHRPsg_ati93cnnKeGvynW09Pe_m6MnJUAipDY0Fe9s7STfOynjNuKwiFwVFPoy72bgo2rgV_7-ncHoCnD2Hs7_Clwdwsm_2b34FAAD__9y3YyI=

statement ok
RESET optimizer; RESET vectorize; RESET distsql; RESET vectorize_row_count_threshold

# Regression test for composite null handling
# https://github.com/cockroachdb/cockroach/issues/37358
statement ok
CREATE TABLE composite (d DECIMAL, INDEX d_idx (d))

statement ok
INSERT INTO composite VALUES (NULL), (1), (1.0), (1.00)

query T rowsort
SELECT d FROM composite@primary
----
NULL
1
1.0
1.00

query T rowsort
SELECT d FROM composite@d_idx
----
NULL
1
1.0
1.00

# Test unhandled type conversion. (Should fall back to distsql.)
query T
SELECT ARRAY(SELECT 1) FROM a LIMIT 1
----
{1}

# Regression test for decoding OID type.
statement ok
CREATE TABLE t38754 (a OID PRIMARY KEY)

statement ok
INSERT INTO t38754 VALUES (1)

query O
SELECT * FROM t38754
----
1

# Test integer division.
query T
SELECT a/b FROM a WHERE b = 2
----
0.5

# Test mixed types comparison.
query I
SELECT b FROM a WHERE b < 0.5
----
0

# Test unsupported scrub (should fall back to distsql).
statement ok
CREATE TABLE t38626 (id int PRIMARY KEY, name STRING, CONSTRAINT abc CHECK (name > 'he'))

statement ok
INSERT INTO t38626 VALUES (1, 'hello')

statement ok
EXPERIMENTAL SCRUB TABLE t38626

# Regression test for issue with reading from system tables that have no
# sentinel keys.
query T
SELECT "hashedPassword" FROM system.users LIMIT 1
----
·

query IITI
SELECT * FROM system.namespace LIMIT 1
----
0  0 defaultdb  50

# Regression test for issue with fetching from unique indexes with embedded
# nulls.
statement ok
CREATE TABLE t38753 (x INT PRIMARY KEY, y INT, UNIQUE INDEX (y)); INSERT INTO t38753 VALUES (0, NULL)

query II
SELECT * FROM t38753 ORDER BY y;
----
0  NULL

# Regression test for #38752.
query IIBB
SELECT count(*), count(*) + 1, count(*) > 4, count(*) + 1 > 4 FROM b
----
4  5  false  true

query I
SELECT * FROM (SELECT count(*) AS x FROM b) WHERE x > 0;
----
4

# Regression test for #38908
statement ok
CREATE TABLE t38908 (x INT)

statement ok
INSERT INTO t38908 VALUES (1)

statement ok
SET vectorize=experimental_always

query I
SELECT * FROM t38908 WHERE x IN (1, 2)
----
1

statement ok
RESET vectorize

# Test that an aggregate with no aggregate functions is handled correctly.
query III
SELECT 0, 1 + 2, 3 * 4 FROM a HAVING true
----
0 3 12

# Testing some builtin functions.
statement ok
CREATE TABLE builtin_test (x STRING, y INT)

statement ok
INSERT INTO builtin_test VALUES ('Hello', 3), ('There', 2)

query T
SELECT substring(x, 1, y) FROM builtin_test
----
Hel
Th

query T
SELECT substring(x, 1, abs(y)) FROM builtin_test
----
Hel
Th

# Regression test for #44625.
statement error negative substring length -1 not allowed
SELECT substring(x, 0, -1) FROM builtin_test

query I
SELECT abs(y) FROM builtin_test
----
3
2

statement ok
CREATE TABLE extract_test (x DATE)

statement ok
INSERT INTO extract_test VALUES ('2017-01-01')

query R
SELECT EXTRACT(YEAR FROM x) FROM extract_test
----
2017

# Regression test for #38937
statement ok
CREATE TABLE t38937 (_int2) AS SELECT 1::INT2

query I
SELECT sum_int(_int2) FROM t38937
----
1

# Regression tests for #38959

statement ok
CREATE TABLE t38959 (a INT PRIMARY KEY, b INT, c INT, d INT, INDEX b_idx (b) STORING (c, d), UNIQUE INDEX c_idx (c) STORING (b, d))

statement ok
INSERT INTO t38959 VALUES (1, 2, 3, 4)

statement ok
SET tracing=on,kv,results

query IIII
SELECT * FROM t38959@c_idx
----
1 2 3 4

statement ok
SET tracing=off

statement ok
CREATE TABLE t38959_2 (x INT PRIMARY KEY, y INT, z FLOAT, INDEX xy (x, y), INDEX zyx (z, y, x), FAMILY (x), FAMILY (y), FAMILY (z))

statement ok
INSERT INTO t38959_2 VALUES (1, 2, 3.0), (4, 5, 6.0), (7, NULL, 8.0)

statement ok
SET tracing=on,kv,results

query I
SELECT min(x) FROM t38959_2 WHERE (y, z) = (2, 3.0)
----
1

statement ok
SET tracing=off

# Making sure that colBatchScan operator can parallelize scans.
# This test is similar to that in testplannerlogic/select
statement ok
CREATE TABLE tpar (a INT PRIMARY KEY, item STRING, price FLOAT, UNIQUE INDEX item (item), UNIQUE INDEX p (price))

statement ok
ALTER TABLE tpar SPLIT AT VALUES(5)

# Run a select to prime the range cache to simplify the trace below.
statement ok
SELECT * FROM tpar

# Make sure that the scan actually gets parallelized.
statement ok
SET tracing = on; SELECT * FROM tpar WHERE a = 0 OR a = 10; SET tracing = off

# The span "sending partial batch" means that the scan was parallelized.
# Note that table ID here is hardcoded, so if a new table is created before
# tpar, this query will need an adjustment.
query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message IN 
    ('querying next range at /Table/73/1/0',
     'querying next range at /Table/73/1/10',
     '=== SPAN START: kv.DistSender: sending partial batch ==='
    )
----
querying next range at /Table/73/1/0
=== SPAN START: kv.DistSender: sending partial batch ===
querying next range at /Table/73/1/10

# Test for #38858 -- handle aggregates correctly on an empty table.
statement ok
CREATE TABLE empty (a INT PRIMARY KEY, b FLOAT)

# GROUP BY is omitted, so aggregates are in scalar context.
query IIIIIRR
SELECT count(*), count(a), sum_int(a), min(a), max(a), sum(b), avg(b) FROM empty
----
0  0  NULL  NULL  NULL  NULL  NULL

 # GROUP BY is present, so aggregates are in non-scalar context.
query IIIIIRR
SELECT count(*), count(a), sum_int(a), min(a), max(a), sum(b), avg(b) FROM empty GROUP BY a
----


statement ok
CREATE TABLE t_38995 (a INT PRIMARY KEY)

statement ok
INSERT INTO t_38995 VALUES (1), (2), (3)

query II
SELECT a, ordinality*2 FROM t_38995 WITH ORDINALITY
----
1 2
2 4
3 6

# Test for #39827, top k sort with bytes.
statement ok
CREATE TABLE t_39827 (a STRING)

statement ok
INSERT INTO t_39827 VALUES ('hello'), ('world'), ('a'), ('foo')

query T
SELECT a FROM t_39827 ORDER BY a LIMIT 2
----
a
foo

# Regression test for #40227, an issue with flat bytes implementation.
statement ok
CREATE TABLE t_40227 AS SELECT g FROM generate_series(0, 5) AS g

statement ok
SELECT '' FROM t_40227 AS t1 JOIN t_40227 AS t2 ON true

# Tests for #39417
statement ok
CREATE TABLE t39417 (x int8)

statement ok
INSERT INTO t39417 VALUES (10)

query R
select (x/1) from t39417
----
10

# Regression tests for #39540, an issue caused by shallow copying decimals.
statement ok
CREATE TABLE IF NOT EXISTS t_39540 AS
	SELECT
		g % 2 = 0 AS _bool, g::DECIMAL AS _decimal
	FROM
		generate_series(0, 5) AS g

query R rowsort
SELECT
	tab_426212._decimal - tab_426216._decimal
FROM
	t_39540 AS tab_426212,
	t_39540 AS tab_426214,
	t_39540
	RIGHT JOIN t_39540 AS tab_426216 ON true
ORDER BY
	tab_426214._bool ASC
----
1296 values hashing to cad02075a867c3c0564bf80fe665eed6

# Regression test for #40372.
statement ok
CREATE TABLE t40372_1 (
  a INT,
  b INT,
  c FLOAT,
  d FLOAT
)

statement ok
INSERT INTO t40372_1 VALUES
  (1, 1, 1, 1),
  (2, 2, 2, 2),
  (3, 3, 3, 3)

statement ok
CREATE TABLE t40372_2 (
  a INT,
  b FLOAT,
  c FLOAT,
  d INT
)

statement ok
INSERT INTO t40372_2 VALUES
  (1, 1, 1, 1),
  (2, 2, 2, 2),
  (3, 3, 3, 3)

query IIRR rowsort
SELECT * FROM t40372_1 NATURAL JOIN t40372_2
----
1  1  1  1
2  2  2  2
3  3  3  3

# Test that comparison against a null value selects the value out.
statement ok
CREATE TABLE tnull(a INT, b INT)

statement ok
INSERT INTO tnull VALUES(NULL, 238)

query I rowsort
SELECT a FROM tnull WHERE (a<=b OR a>=b)
----

# Test that AND'ing a true value with another true value while one of them is
# actually NULL returns NULL.
statement ok
CREATE TABLE t1(a INTEGER, b INTEGER, c INTEGER)

statement ok
INSERT INTO t1 VALUES(NULL,2,1)

# We need both parenthesis in WHERE clause so that the AND operation under test
# is not optimized out.
query I
SELECT CASE WHEN a <= b THEN 1 ELSE 2 END
  FROM t1
 WHERE (a > b - 2 AND a < b + 2) OR (c > a AND c < b)
----

# Regression tests for NULL expression handling.
statement ok
CREATE TABLE t_case_null (x INT)

statement ok
INSERT INTO t_case_null VALUES (0)

query I
SELECT CASE WHEN x = 0 THEN 0 ELSE NULL END FROM t_case_null
----
0

query I
SELECT CASE WHEN x = 0 THEN NULL ELSE 0 END FROM t_case_null
----
NULL

query I
SELECT CASE WHEN x = 1 THEN 1 ELSE NULL END FROM t_case_null
----
NULL

query I
SELECT * FROM t_case_null WHERE NULL AND NULL
----

query I
SELECT * FROM t_case_null WHERE NULL AND x = 0
----

query I
SELECT * FROM t_case_null WHERE x = 0 AND NULL
----

# Regression test for #40732.
statement ok
CREATE TABLE t40732 AS SELECT g::INT8 AS _int8,
                              g::FLOAT8 AS _float8,
                              '2001-01-01'::DATE
                              + g AS _date,
                              g % 2 = 1 AS _bool,
                              g::DECIMAL AS _decimal,
                              g::STRING AS _string,
                              g::STRING::BYTES AS _bytes
                         FROM generate_series(1, 5) AS g

statement ok
INSERT INTO t40732 DEFAULT VALUES

query I
SELECT *
  FROM (
          SELECT tab_1541._int8 AS col_2976
            FROM t40732 AS tab_1538
            JOIN t40732 AS tab_1539
            JOIN t40732 AS tab_1540 ON
                  tab_1539._float8 = tab_1540._float8
            JOIN t40732 AS tab_1541 ON
                  tab_1540._int8 = tab_1541._int8 ON
                  tab_1538._float8 = tab_1540._float8,
                 t40732 AS tab_1542
           WHERE tab_1542._bool > tab_1540._bool
       )
ORDER BY col_2976
----
2
2
2
4
4
4

query T
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name='sql.exec.query.is-vectorized' AND usage_count > 0
----
sql.exec.query.is-vectorized

# Test IS NULL (and alike) projections.
query IBBIBB rowsort
SELECT a, a IS NULL, a IS NOT NULL, b, b IS NOT DISTINCT FROM NULL, b IS DISTINCT FROM NULL FROM nulls
----
NULL  true   false  NULL  true   false
NULL  true   false  1     false  true
1     false  true   NULL  true   false
1     false  true   1     false  true

# Test IS NULL (and alike) selections.
query II rowsort
SELECT a, b FROM nulls WHERE a IS NULL
----
NULL NULL
NULL 1

query II rowsort
SELECT a, b FROM nulls WHERE a IS NOT NULL
----
1 NULL
1 1

query II rowsort
SELECT a, b FROM nulls WHERE a IS NOT DISTINCT FROM NULL
----
NULL NULL
NULL 1

query II rowsort
SELECT a, b FROM nulls WHERE a IS DISTINCT FROM NULL
----
1 NULL
1 1

query III rowsort
SELECT
	a,
	b,
	CASE
	WHEN a IS NOT NULL AND b IS NULL THEN 0
	WHEN a IS NULL THEN 1
	WHEN b IS NOT NULL THEN 2
	END
FROM
	nulls
----
NULL  NULL  1
NULL  1     1
1     NULL  0
1     1     2

# Regression test for #42816 - top K sort when K is greated than
# coldata.BatchSize().
statement ok
CREATE TABLE t_42816 (a int); INSERT INTO t_42816 SELECT * FROM generate_series(0, 1025)

query I
SELECT * FROM t_42816 ORDER BY a OFFSET 1020 LIMIT 10
----
1020
1021
1022
1023
1024
1025

# Regression tests for #42994
statement ok
CREATE TABLE t42994 (a INT PRIMARY KEY, b BIT, INDEX i (a, b));
INSERT INTO t42994 VALUES (1, 1::BIT);

query I
SELECT a FROM t42994@i
----
1

statement ok
CREATE TABLE t42994_2 (a BIT PRIMARY KEY, b INT, UNIQUE INDEX i (b));
INSERT INTO t42994_2 VALUES (1::BIT, NULL);

query I
SELECT b FROM t42994_2@i
----
NULL

# Regression test for zeroing out an aggregate value when NULLs are present.
statement ok
SELECT
	max(s)
FROM
	(
		SELECT
			s, i
		FROM
			(VALUES ('1', 1), (NULL, 2)) AS t (s, i)
	)
GROUP BY
	i

statement ok
CREATE TABLE t43550(a INT2 PRIMARY KEY); INSERT INTO t43550 VALUES (1)

query I
SELECT CASE WHEN a = 0 THEN a ELSE 1:::INT8 END FROM t43550
----
1

# Regression test for #43855.
statement ok
CREATE TABLE t43855(o OID, r REGPROCEDURE)

query i
SELECT CASE WHEN o = 0 THEN 0:::OID ELSE r END FROM t43855
----

# Regression test for an aggregate that has output type different from its
# input type (INT4 is input whereas output is INT). Currently such query is not
# supported through vectorized engine, but we will get a plan with wrapped
# rowexec.orderedAggregator.
query I
SELECT max(c) FROM a
----
2000

# Regression test for starting wrapped processors multiple times.
statement ok
CREATE TABLE t44133_0(c0 STRING); CREATE TABLE t44133_1(c0 STRING UNIQUE NOT NULL)

statement ok
SELECT * FROM t44133_0, t44133_1 WHERE t44133_0.c0 NOT BETWEEN t44133_1.c0 AND '' AND (t44133_1.c0 IS NULL)

# Regression test for CASE operator with unhandled output type.
statement ok
CREATE TABLE t44304(c0 INT); INSERT INTO t44304 VALUES (0)

query I
SELECT * FROM t44304 WHERE CASE WHEN t44304.c0 > 0 THEN NULL END
----

# Regression test for CASE operator and flat bytes.
statement ok
CREATE TABLE t44624(c0 STRING, c1 BOOL); INSERT INTO t44624(rowid, c0, c1) VALUES (0, '', true), (1, '', NULL)

query TB
SELECT * FROM t44624 ORDER BY CASE WHEN c1 IS NULL THEN c0 WHEN true THEN c0 END
----
·  true
·  NULL

# Regression test for 44726 (unknown WHEN expression type).
statement ok
CREATE TABLE t44726(c0 INT); INSERT INTO t44726(c0) VALUES (0)

query I
SELECT * FROM t44726 WHERE 0 > (CASE WHEN nullif(NULL, ilike_escape('', current_user(), '')) THEN 0 ELSE t44726.c0 END)
----
