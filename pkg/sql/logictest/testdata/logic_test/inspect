# fakedist* configs are skipped because SetupAllNodesPlanning requires a
# non-nil txn, which is not available in job-based flows like INSPECT. Using
# them causes a nil pointer panic in the span resolver setup.
#
# LogicTest: !fakedist !fakedist-vec-off !fakedist-disk !local-mixed-25.2 !local-mixed-25.3


# Helper view to show the most recent INSPECT job.
# We order by job ID (not creation time) because jobs run with AS OF SYSTEM
# TIME use the AOST value as their creation timestamp rather than the current
# time.
statement ok
CREATE VIEW last_inspect_job AS
SELECT status, jsonb_array_length(
    crdb_internal.pb_to_json('cockroach.sql.jobs.jobspb.Payload', payload)->'inspectDetails'->'checks'
  ) AS num_checks
FROM crdb_internal.system_jobs
WHERE job_type = 'INSPECT'
ORDER BY id DESC
LIMIT 1

# Make job adoption faster. This is needed to speed up DETACHED jobs.
statement ok
SET CLUSTER SETTING jobs.registry.interval.adopt = '500ms';

statement ok
CREATE TABLE foo (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));

let $foo_created_ts
SELECT now()

statement error pq: INSPECT is an experimental feature and is disabled by default
INSPECT TABLE foo;

statement error pq: INSPECT is an experimental feature and is disabled by default
INSPECT DATABASE test;

statement ok
SET enable_inspect_command = true;

subtest transaction_behavior

# Test that regular INSPECT cannot run within a transaction.
statement ok
BEGIN;

statement error pq: cannot run within a multi-statement transaction
INSPECT TABLE foo;

statement ok
ROLLBACK;

statement notice NOTICE: INSPECT job [0-9]+ running in the background
INSPECT TABLE foo WITH OPTIONS DETACHED

# Wait for the detached job to eventually succeed.
query T retry
SELECT status FROM last_inspect_job
----
succeeded

# Test that DETACHED INSPECT can run inside a transaction.
statement ok
BEGIN;

statement notice NOTICE: INSPECT job [0-9]+ queued; will start after the current transaction commits
INSPECT TABLE foo WITH OPTIONS DETACHED

# Verify the job isn't committed yet. It will stay in the running stage because we haven't committed it yet.
query T
SELECT status FROM last_inspect_job
----
running

statement ok
COMMIT;

# Wait for the new job to eventually succeed.
query T retry
SELECT status FROM last_inspect_job
----
succeeded

subtest end

subtest inspect_options

# Test DETACHED option validation.

# Failure if both DETACHED and DETACHED = FALSE are specified.
statement error pq: conflicting INSPECT options: DETACHED specified with different values
INSPECT TABLE foo WITH OPTIONS DETACHED, DETACHED = FALSE

# DETACHED = TRUE is the same as DETACHED.
# Both should check all indexes (2 total: idx_c1 and idx_c2).
statement notice NOTICE: INSPECT job [0-9]+ running in the background
INSPECT TABLE foo WITH OPTIONS DETACHED = TRUE

query TI retry
SELECT * FROM last_inspect_job
----
succeeded  2

statement notice NOTICE: INSPECT job [0-9]+ running in the background
INSPECT TABLE foo WITH OPTIONS DETACHED

query TI retry
SELECT * FROM last_inspect_job
----
succeeded  2

# DETACHED = TRUE with a specific index (verify the number of checks).
statement notice NOTICE: INSPECT job [0-9]+ running in the background
INSPECT TABLE foo WITH OPTIONS DETACHED = TRUE, INDEX (idx_c1)

query TI retry
SELECT * FROM last_inspect_job
----
succeeded  1

# Test regular (non-detached) inspect operations.

statement notice NOTICE: waiting for INSPECT job to complete: [0-9]+\nIf the statement is canceled, the job will continue in the background.
INSPECT TABLE foo;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c1);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  1

# Names are quietly deduplicated.
statement ok
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c1, foo@idx_c1);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  1

statement ok
INSPECT TABLE foo AS OF SYSTEM TIME '$foo_created_ts' WITH OPTIONS INDEX (idx_c1,idx_c2);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement error pq: index "idx_c3" does not exist
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c3);

statement ok
INSPECT TABLE foo WITH OPTIONS INDEX ALL;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
INSPECT DATABASE test;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  28

statement error index "idx_c3" does not exist
INSPECT DATABASE test WITH OPTIONS INDEX (idx_c1, idx_c3);

statement ok
CREATE TABLE bar (c1 INT, c3 INT);

statement ok
INSPECT TABLE bar;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  NULL

statement ok
CREATE INDEX idx_c1 ON bar (c1);
CREATE INDEX idx_c3 ON bar (c3);

statement error pq: index "bar@idx_c1" is not on table "test.public.foo"
INSPECT TABLE foo WITH OPTIONS INDEX (bar@idx_c1);

statement error pq: index "dbfake.foo.idx_c1" is not in database "test"
INSPECT DATABASE test WITH OPTIONS INDEX (dbfake.foo.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in test.public.foo and test.public.bar\)
INSPECT DATABASE test WITH OPTIONS INDEX (idx_c1, idx_c3);

statement ok
INSPECT DATABASE test WITH OPTIONS INDEX (foo@idx_c1, test.public.bar@idx_c1, test.idx_c3);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  3

subtest end

subtest permissions

statement ok
CREATE USER testuser2;

user testuser2

statement ok
SET enable_inspect_command = true;

statement error pq: user testuser2 does not have INSPECT privilege
INSPECT TABLE foo;

statement error pq: user testuser2 does not have INSPECT privilege
INSPECT DATABASE test;

user root

statement ok
GRANT SYSTEM INSPECT TO testuser2;

user testuser2

statement ok
SET enable_inspect_command = true;

statement ok
INSPECT TABLE foo;

statement ok
INSPECT DATABASE test;

subtest end

subtest inspect_unsupported_indexes

user root

# Test that unsupported indexes (hash-sharded, expression) are skipped.
# Table has both unsupported indexes and two regular indexes.
statement ok
CREATE TABLE t2 (
    x INT, y INT, z INT,
    j JSONB NULL,
    INDEX hash_idx (x) USING HASH,
    INDEX expr_idx ((y + z)),
    INDEX regular_idx_y (y),
    INDEX regular_idx_z (z),
    VECTOR INDEX vector_idx ((CAST(j->>'v' AS VECTOR(3)))),
    INDEX partial_idx (j) WHERE 1=1,
    INVERTED INDEX inverted_idx (j)
);

statement ok
INSERT INTO t2 (x, y, z) VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);

# Should succeed, checking only the regular index.
statement ok
INSPECT TABLE t2 AS OF SYSTEM TIME '-1us';

# Verify only two checks were created (for the regular indexes).
query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement error pq: index "t2_pkey" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (t2@t2_pkey);

statement error pq: index "hash_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (hash_idx);

statement error pq: index "expr_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (expr_idx);

statement error pq: index "vector_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (vector_idx);

statement error pq: index "partial_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (partial_idx);

statement error pq: index "inverted_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (inverted_idx);

# Confirm no jobs were run.
query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
DROP TABLE t2;

subtest end

subtest database_resolve_indexes

statement ok
CREATE DATABASE dbfoo;
CREATE TABLE dbfoo.public.t2 (c1 INT, INDEX idx_c1 (c1));
CREATE TABLE dbfoo.public.t1 (c1 INT, INDEX idx_c1 (c1));


statement ok
SET enable_inspect_command = true;

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (t2@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (public.t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.t2@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.public.t1@idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (public.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.public.idx_c1);

statement ok
DROP DATABASE dbfoo;

subtest schema_catalog_collision

statement ok
CREATE DATABASE ambiguous;
CREATE SCHEMA ambiguous.ambiguous;
CREATE TABLE ambiguous.ambiguous.t1 (c1 INT, INDEX idx_c1 (c1));

# The duplicated names of the schema and the catalog means the database parameter doesn't help with resolution.
statement error pq: index "idx_c1" does not exist
INSPECT DATABASE ambiguous WITH OPTIONS INDEX (ambiguous.idx_c1);

statement ok
DROP DATABASE ambiguous;
subtest end

subtest end

subtest table_resolve_indexes

statement ok
CREATE DATABASE dbfoo;
CREATE DATABASE dbbar;
CREATE SCHEMA dbfoo.s1;
CREATE TABLE dbfoo.public.t1 (c1 INT, INDEX idx_c1 (c1));
CREATE TABLE dbfoo.s1.t1 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));
CREATE TABLE dbbar.public.t1 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));
CREATE TABLE dbbar.public.t2 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));

statement ok
SET enable_inspect_command = true;

subtest all_forms

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (t1@idx_c1);

statement error pq: index "s1.t1@idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement error pq: index "dbfoo.s1.t1@idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (idx_c1);

statement error pq: index "s1.idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.idx_c1);

statement error pq: index "dbfoo.s1.idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.s1.idx_c1);

subtest end

statement ok
DROP DATABASE dbfoo;

subtest end

subtest refcursor_stored_column

statement ok
CREATE TABLE refcursor_tbl (id INT PRIMARY KEY, a INT, c REFCURSOR);

statement ok
INSERT INTO refcursor_tbl VALUES (1, 10, 'cursor1'), (2, 20, 'cursor2');

# Verify that we cannot index the refcursor. They can only be included
# in an index as stored columns.
statement error pq: unimplemented: column c has type refcursor, which is not indexable
CREATE INDEX idx_refcursor ON refcursor_tbl (c);

statement ok
CREATE INDEX idx_refcursor ON refcursor_tbl (a) STORING (c);

statement ok
INSPECT TABLE refcursor_tbl WITH OPTIONS INDEX ALL;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  1

statement ok
DROP TABLE refcursor_tbl;

subtest end

subtest inspect_old_aost

let $inspect_old_ts
SELECT now()

statement ok
CREATE TABLE t_aost (c1 INT, INDEX idx_c1 (c1));

statement ok
INSERT INTO t_aost VALUES (1), (2), (3);

# Test INSPECT with an AOST that predates the table.
# This should fail because the table descriptor doesn't exist at that timestamp.
statement error pq: relation "t_aost" does not exist
INSPECT TABLE t_aost AS OF SYSTEM TIME '$inspect_old_ts' WITH OPTIONS INDEX (idx_c1);

statement ok
DROP TABLE t_aost;

subtest end
