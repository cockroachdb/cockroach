# fakedist* configs are skipped because SetupAllNodesPlanning requires a
# non-nil txn, which is not available in job-based flows like INSPECT. Using
# them causes a nil pointer panic in the span resolver setup.
#
# LogicTest: !fakedist !fakedist-vec-off !fakedist-disk !local-mixed-25.2 !local-mixed-25.3


statement ok
CREATE VIEW last_inspect_job AS
SELECT status, jsonb_array_length(
    crdb_internal.pb_to_json('cockroach.sql.jobs.jobspb.Payload', payload)->'inspectDetails'->'checks'
  ) AS num_checks
FROM crdb_internal.system_jobs
WHERE job_type = 'INSPECT'
ORDER BY created DESC
LIMIT 1

statement ok
CREATE TABLE foo (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));

statement error pq: INSPECT is an experimental feature and is disabled by default
INSPECT TABLE foo;

statement error pq: INSPECT is an experimental feature and is disabled by default
INSPECT DATABASE test;

statement ok
SET enable_inspect_command = true;

statement ok
BEGIN;

statement error pq: cannot run within a multi-statement transaction
INSPECT TABLE foo;

statement ok
ROLLBACK;

statement ok
INSPECT TABLE foo;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c1);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  1

# Names are quietly deduplicated.
statement ok
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c1, foo@idx_c1);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  1

statement ok
INSPECT TABLE foo AS OF SYSTEM TIME 1 WITH OPTIONS INDEX (idx_c1,idx_c2);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement error pq: index "idx_c3" does not exist
INSPECT TABLE foo WITH OPTIONS INDEX (idx_c3);

statement ok
INSPECT TABLE foo WITH OPTIONS INDEX ALL;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
INSPECT DATABASE test;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  28

statement error index "idx_c3" does not exist
INSPECT DATABASE test WITH OPTIONS INDEX (idx_c1, idx_c3);

statement ok
CREATE TABLE bar (c1 INT, c3 INT);

statement ok
INSPECT TABLE bar;

query TI
SELECT * FROM last_inspect_job;
----
succeeded  NULL

statement ok
CREATE INDEX idx_c1 ON bar (c1);
CREATE INDEX idx_c3 ON bar (c3);

statement error pq: index "bar@idx_c1" is not on table "test.public.foo"
INSPECT TABLE foo WITH OPTIONS INDEX (bar@idx_c1);

statement error pq: index "dbfake.foo.idx_c1" is not in database "test"
INSPECT DATABASE test WITH OPTIONS INDEX (dbfake.foo.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in test.public.foo and test.public.bar\)
INSPECT DATABASE test WITH OPTIONS INDEX (idx_c1, idx_c3);

statement ok
INSPECT DATABASE test WITH OPTIONS INDEX (foo@idx_c1, test.public.bar@idx_c1, test.idx_c3);

query TI
SELECT * FROM last_inspect_job;
----
succeeded  3

subtest permissions

statement ok
CREATE USER testuser2;

user testuser2

statement ok
SET enable_inspect_command = true;

statement error pq: user testuser2 does not have INSPECT privilege
INSPECT TABLE foo;

statement error pq: user testuser2 does not have INSPECT privilege
INSPECT DATABASE test;

user root

statement ok
GRANT SYSTEM INSPECT TO testuser2;

user testuser2

statement ok
SET enable_inspect_command = true;

statement ok
INSPECT TABLE foo;

statement ok
INSPECT DATABASE test;

subtest end

subtest inspect_unsupported_indexes

user root

# Test that unsupported indexes (hash-sharded, expression) are skipped.
# Table has both unsupported indexes and two regular indexes.
statement ok
CREATE TABLE t2 (
    x INT, y INT, z INT,
    j JSONB NULL,
    INDEX hash_idx (x) USING HASH,
    INDEX expr_idx ((y + z)),
    INDEX regular_idx_y (y),
    INDEX regular_idx_z (z),
    VECTOR INDEX vector_idx ((CAST(j->>'v' AS VECTOR(3)))),
    INDEX partial_idx (j) WHERE 1=1,
    INVERTED INDEX inverted_idx (j)
);

statement ok
INSERT INTO t2 (x, y, z) VALUES (1, 1, 1), (2, 2, 2), (3, 3, 3);

# Should succeed, checking only the regular index.
statement ok
INSPECT TABLE t2 AS OF SYSTEM TIME '-1us';

# Verify only two checks were created (for the regular indexes).
query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement error pq: index "t2_pkey" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (t2@t2_pkey);

statement error pq: index "hash_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (hash_idx);

statement error pq: index "expr_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (expr_idx);

statement error pq: index "vector_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (vector_idx);

statement error pq: index "partial_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (partial_idx);

statement error pq: index "inverted_idx" on table "t2" is not supported for index consistency checking
INSPECT TABLE t2 WITH OPTIONS INDEX (inverted_idx);

# Confirm no jobs were run.
query TI
SELECT * FROM last_inspect_job;
----
succeeded  2

statement ok
DROP TABLE t2;

subtest end

subtest database_resolve_indexes

statement ok
CREATE DATABASE dbfoo;
CREATE TABLE dbfoo.public.t2 (c1 INT, INDEX idx_c1 (c1));
CREATE TABLE dbfoo.public.t1 (c1 INT, INDEX idx_c1 (c1));


statement ok
SET enable_inspect_command = true;

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (t2@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (public.t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.t2@idx_c1);

statement ok
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.public.t1@idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (public.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.idx_c1);

statement error pq: index name "idx_c1" is ambiguous \(found in dbfoo.public.t2 and dbfoo.public.t1\)
INSPECT DATABASE dbfoo WITH OPTIONS INDEX (dbfoo.public.idx_c1);

statement ok
DROP DATABASE dbfoo;

subtest schema_catalog_collision

statement ok
CREATE DATABASE ambiguous;
CREATE SCHEMA ambiguous.ambiguous;
CREATE TABLE ambiguous.ambiguous.t1 (c1 INT, INDEX idx_c1 (c1));

# The duplicated names of the schema and the catalog means the database parameter doesn't help with resolution.
statement error pq: index "idx_c1" does not exist
INSPECT DATABASE ambiguous WITH OPTIONS INDEX (ambiguous.idx_c1);

statement ok
DROP DATABASE ambiguous;
subtest end

subtest end

subtest table_resolve_indexes

statement ok
CREATE DATABASE dbfoo;
CREATE DATABASE dbbar;
CREATE SCHEMA dbfoo.s1;
CREATE TABLE dbfoo.public.t1 (c1 INT, INDEX idx_c1 (c1));
CREATE TABLE dbfoo.s1.t1 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));
CREATE TABLE dbbar.public.t1 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));
CREATE TABLE dbbar.public.t2 (c1 INT, c2 INT, INDEX idx_c1 (c1), INDEX idx_c2 (c2));

statement ok
SET enable_inspect_command = true;

subtest all_forms

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (t1@idx_c1);

statement error pq: index "s1.t1@idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement error pq: index "dbfoo.s1.t1@idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (idx_c1);

statement error pq: index "s1.idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.idx_c1);

statement error pq: index "dbfoo.s1.idx_c1" is not on table "dbfoo.public.t1"
INSPECT TABLE dbfoo.t1 WITH OPTIONS INDEX (dbfoo.s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.s1.t1@idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (s1.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.idx_c1);

statement ok
INSPECT TABLE dbfoo.s1.t1 WITH OPTIONS INDEX (dbfoo.s1.idx_c1);

subtest end

statement ok
DROP DATABASE dbfoo;

subtest end
