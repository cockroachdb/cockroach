
statement ok
CREATE TABLE other (b INT PRIMARY KEY)

statement ok
INSERT INTO other VALUES (9)

statement ok
CREATE TABLE t (a INT PRIMARY KEY CHECK(a > 0), f INT REFERENCES other, INDEX (f))

statement ok
INSERT INTO t VALUES (1, 9)

statement error at or near "\*": syntax error
ALTER TABLE t RENAME TO t.*

statement ok
ALTER TABLE t ADD b INT

query TTBTTTB colnames
SHOW COLUMNS FROM t
----
column_name  data_type  is_nullable  column_default  generation_expression  indices           is_hidden
a            INT8       false        NULL            ·                      {t_f_idx,t_pkey}  false
f            INT8       true         NULL            ·                      {t_f_idx,t_pkey}  false
b            INT8       true         NULL            ·                      {t_pkey}          false

statement ok
ALTER TABLE t ADD CONSTRAINT foo UNIQUE (b)

statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS foo UNIQUE (b)

statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS foo UNIQUE (f)

query TTTTRT
SELECT job_type, description, user_name, status, fraction_completed, error
FROM crdb_internal.jobs
WHERE job_type = 'SCHEMA CHANGE'
ORDER BY created DESC
LIMIT 1
----
SCHEMA CHANGE  ALTER TABLE test.public.t ADD CONSTRAINT foo UNIQUE (b)  root  succeeded  1  ·

statement error pgcode 42710 constraint with name \"foo\" already exists
ALTER TABLE t ADD CONSTRAINT foo UNIQUE (b)

statement error pq: multiple primary keys for table "t" are not allowed
ALTER TABLE t ADD CONSTRAINT bar PRIMARY KEY (b)

query TTBITTBB colnames
SHOW INDEXES FROM t
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
t           foo         false       1             b            ASC        false    false
t           foo         false       2             a            ASC        true     true
t           t_f_idx     true        1             f            ASC        false    false
t           t_f_idx     true        2             a            ASC        false    true
t           t_pkey      false       1             a            ASC        false    false
t           t_pkey      false       2             f            N/A        true     false
t           t_pkey      false       3             b            N/A        true     false

query III
SELECT * FROM t
----
1 9 NULL

statement ok
ALTER TABLE t ADD c INT

statement ok
INSERT INTO t VALUES (2, 9, 1, 1), (3, 9, 2, 1)

statement error pgcode 23505 violates unique constraint "bar"
ALTER TABLE t ADD CONSTRAINT bar UNIQUE (c)

statement error pgcode 42703 column "dne" does not exist
ALTER TABLE t ADD CONSTRAINT dne_unique UNIQUE (dne)

# Test that rollback was successful
#
# We ignore the job status because GC for temporary indexes used
# during backfills may already running rather than waiting for the GC
# TTL depending on the timing.
query TTT
SELECT job_type, regexp_replace(description, 'JOB \d+', 'JOB ...'), user_name
FROM crdb_internal.jobs
WHERE job_type = 'SCHEMA CHANGE' OR job_type = 'SCHEMA CHANGE GC'
ORDER BY created DESC
LIMIT 3
----
SCHEMA CHANGE GC  GC for temporary index used during index backfill                           root
SCHEMA CHANGE GC  GC for ROLLBACK of ALTER TABLE test.public.t ADD CONSTRAINT bar UNIQUE (c)  root
SCHEMA CHANGE     ALTER TABLE test.public.t ADD CONSTRAINT bar UNIQUE (c)                     root

query IIII colnames,rowsort
SELECT * FROM t
----
a f b    c
1 9 NULL NULL
2 9 1    1
3 9 2    1

query TTTTB colnames
SHOW CONSTRAINTS FROM t
----
table_name  constraint_name  constraint_type  details                              validated
t           check_a          CHECK            CHECK ((a > 0))                      true
t           foo              UNIQUE           UNIQUE (b ASC)                       true
t           t_f_fkey         FOREIGN KEY      FOREIGN KEY (f) REFERENCES other(b)  true
t           t_pkey           PRIMARY KEY      PRIMARY KEY (a ASC)                  true

statement error CHECK
INSERT INTO t (a, f) VALUES (-2, 9)

statement ok
ALTER TABLE t DROP CONSTRAINT check_a

statement ok
INSERT INTO t (a, f) VALUES (-2, 9)

statement error validation of CHECK "a > 0:::INT8" failed on row: a=-2, f=9, b=NULL, c=NULL
ALTER TABLE t ADD CONSTRAINT check_a CHECK (a > 0)

statement ok
DELETE FROM t WHERE a = -2

statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS check_a CHECK (a > 0)

statement error CHECK
INSERT INTO t (a) VALUES (-3)

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_a   CHECK        CHECK ((a > 0))                      true
t  foo       UNIQUE       UNIQUE (b ASC)                       true
t  t_f_fkey  FOREIGN KEY  FOREIGN KEY (f) REFERENCES other(b)  true
t  t_pkey    PRIMARY KEY  PRIMARY KEY (a ASC)                  true

statement error duplicate constraint name
ALTER TABLE t ADD CONSTRAINT check_a CHECK (a > 0)

statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS check_a CHECK (a < 0)

statement error duplicate constraint name
ALTER TABLE t ADD CONSTRAINT t_f_fkey FOREIGN KEY (a) REFERENCES other (b)

# Should be a no-op.
statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS t_f_fkey FOREIGN KEY (a) REFERENCES other (b)

# Should be a no-op.
statement ok
ALTER TABLE t ADD CONSTRAINT IF NOT EXISTS t_f_fkey CHECK (a < 0)

# added constraints with generated names avoid name collisions.
statement ok
ALTER TABLE t ADD CHECK (a > 0)

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_a   CHECK        CHECK ((a > 0))                      true
t  check_a1  CHECK        CHECK ((a > 0))                      true
t  foo       UNIQUE       UNIQUE (b ASC)                       true
t  t_f_fkey  FOREIGN KEY  FOREIGN KEY (f) REFERENCES other(b)  true
t  t_pkey    PRIMARY KEY  PRIMARY KEY (a ASC)                  true

statement error constraint "typo" of relation "t" does not exist
ALTER TABLE t VALIDATE CONSTRAINT typo

# TODO(erik): re-enable test when unvalidated checks can be added
#statement error validation of CHECK "a > 0" failed on row: a=-2, f=9, b=NULL, c=NULL
#ALTER TABLE t VALIDATE CONSTRAINT check_a

#statement ok
#DELETE FROM t WHERE a = -2

statement ok
ALTER TABLE t VALIDATE CONSTRAINT check_a

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_a   CHECK        CHECK ((a > 0))                      true
t  check_a1  CHECK        CHECK ((a > 0))                      true
t  foo       UNIQUE       UNIQUE (b ASC)                       true
t  t_f_fkey  FOREIGN KEY  FOREIGN KEY (f) REFERENCES other(b)  true
t  t_pkey    PRIMARY KEY  PRIMARY KEY (a ASC)                  true

statement ok
ALTER TABLE t DROP CONSTRAINT check_a, DROP CONSTRAINT check_a1

statement error pgcode 42703 column "d" does not exist
ALTER TABLE t DROP d

statement ok
ALTER TABLE t DROP IF EXISTS d

statement error column "a" is referenced by the primary key
ALTER TABLE t DROP a

statement error constraint "bar" of relation "t" does not exist
ALTER TABLE t DROP CONSTRAINT bar

statement ok
ALTER TABLE t DROP CONSTRAINT IF EXISTS bar

statement error cannot drop UNIQUE constraint \"foo\" using ALTER TABLE DROP CONSTRAINT, use DROP INDEX CASCADE instead
ALTER TABLE t DROP CONSTRAINT foo

statement ok
DROP INDEX foo CASCADE

query TTTTTRT
SELECT job_type, description, user_name, status, running_status, fraction_completed, error
FROM crdb_internal.jobs
WHERE job_type = 'SCHEMA CHANGE' OR job_type = 'SCHEMA CHANGE GC'
ORDER BY created DESC
LIMIT 2
----
SCHEMA CHANGE GC  GC for DROP INDEX test.public.t@foo CASCADE  root  running    waiting for GC TTL  0  ·
SCHEMA CHANGE     DROP INDEX test.public.t@foo CASCADE         root  succeeded  NULL                1  ·

query TTBITTBB colnames
SHOW INDEXES FROM t
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
t           t_f_idx     true        1             f            ASC        false    false
t           t_f_idx     true        2             a            ASC        false    true
t           t_pkey      false       1             a            ASC        false    false
t           t_pkey      false       2             f            N/A        true     false
t           t_pkey      false       3             b            N/A        true     false
t           t_pkey      false       4             c            N/A        true     false

statement ok
ALTER TABLE t DROP b, DROP c

query II rowsort
SELECT * FROM t
----
1  9
2  9
3  9

statement ok
ALTER TABLE t ADD d INT UNIQUE

statement ok
INSERT INTO t VALUES (4, 9, 1)

statement error duplicate key value violates unique constraint \"t_d_key\"\nDETAIL: Key \(d\)=\(1\) already exists\.
INSERT INTO t VALUES (5, 9, 1)

# Add a column with no default value
statement ok
ALTER TABLE t ADD COLUMN x DECIMAL

# Add a non NULL column with a default value
statement ok
ALTER TABLE t ADD COLUMN y DECIMAL NOT NULL DEFAULT (DECIMAL '1.3')

statement error could not parse "1-3" as type decimal
ALTER TABLE t ADD COLUMN p DECIMAL NOT NULL DEFAULT (DECIMAL '1-3')

# Add a non NULL column with no default value
statement error pgcode 23502 null value in column \"q\" violates not-null constraint
ALTER TABLE t ADD COLUMN q DECIMAL NOT NULL

statement ok
ALTER TABLE t ADD COLUMN z DECIMAL DEFAULT (DECIMAL '1.4')

statement ok
INSERT INTO t VALUES (11, 9, 12, DECIMAL '1.0')

statement ok
INSERT INTO t (a, d) VALUES (13, 14)

statement ok
INSERT INTO t (a, d, y) VALUES (21, 22, DECIMAL '1.0')

statement ok
INSERT INTO t (a, d) VALUES (23, 24)

statement error foreign key
INSERT INTO t VALUES (31, 7, 32)

statement ok
ALTER TABLE t DROP CONSTRAINT t_f_fkey

statement  ok
INSERT INTO t VALUES (31, 7, 32)

statement ok
INSERT INTO t (a, d, x, y, z) VALUES (33, 34, DECIMAL '2.0', DECIMAL '2.1', DECIMAL '2.2')

statement ok
DROP INDEX t@t_f_idx

query TTTTTRT
SELECT job_type, description, user_name, status, running_status, fraction_completed, error
FROM crdb_internal.jobs
WHERE job_type = 'SCHEMA CHANGE' OR job_type = 'SCHEMA CHANGE GC'
ORDER BY created DESC
LIMIT 2
----
SCHEMA CHANGE GC  GC for DROP INDEX test.public.t@t_f_idx  root  running    waiting for GC TTL  0  ·
SCHEMA CHANGE     DROP INDEX test.public.t@t_f_idx         root  succeeded  NULL                1  ·

statement ok
ALTER TABLE t DROP COLUMN f

query IITTT colnames,rowsort
SELECT * FROM t
----
a   d     x     y     z
1   NULL  NULL  1.3   1.4
2   NULL  NULL  1.3   1.4
3   NULL  NULL  1.3   1.4
4   1     NULL  1.3   1.4
11  12    1.0   1.3   1.4
13  14    NULL  1.3   1.4
21  22    NULL  1.0   1.4
23  24    NULL  1.3   1.4
31  32    NULL  1.3   1.4
33  34    2.0   2.1   2.2

statement ok
ALTER TABLE t DROP COLUMN d

statement ok
ALTER TABLE t ADD COLUMN e INT; ALTER TABLE t ADD COLUMN d INT

statement ok
CREATE VIEW v AS SELECT x, y FROM t WHERE e > 5

statement error cannot drop column "x" because view "v" depends on it
ALTER TABLE t DROP COLUMN x

statement error cannot drop column "y" because view "v" depends on it
ALTER TABLE t DROP COLUMN y

statement error cannot drop column "e" because view "v" depends on it
ALTER TABLE t DROP COLUMN e

statement ok
ALTER TABLE t DROP COLUMN e CASCADE

statement ok
ALTER TABLE t ADD COLUMN e INT

statement ok
CREATE VIEW v AS SELECT x, y FROM t WHERE e > 5

statement ok
ALTER TABLE t DROP COLUMN IF EXISTS q

statement error cannot drop column "e" because view "v" depends on it
ALTER TABLE t DROP COLUMN IF EXISTS e

statement ok
ALTER TABLE t DROP COLUMN IF EXISTS e CASCADE

statement ok
ALTER TABLE t ADD COLUMN g INT UNIQUE

statement ok
CREATE TABLE o (gf INT REFERENCES t (g), h INT, i INT, INDEX oi (i), INDEX oh (h), INDEX oih (i) STORING (h))

statement error "t_g_key" is referenced by foreign key from table "o"
ALTER TABLE t DROP COLUMN g

statement ok
ALTER TABLE t DROP COLUMN g CASCADE

# Dropping columns that are indexed or stored in indexes drops those indexes
# too.
statement ok
ALTER TABLE o DROP COLUMN h

query TTBITTBB colnames
SHOW INDEXES FROM o
----
table_name  index_name  non_unique  seq_in_index  column_name  direction  storing  implicit
o           o_pkey      false       1             rowid        ASC        false    false
o           o_pkey      false       2             gf           N/A        true     false
o           o_pkey      false       3             i            N/A        true     false
o           oi          true        1             i            ASC        false    false
o           oi          true        2             rowid        ASC        false    true

statement ok
ALTER TABLE t ADD f INT CHECK (f > 1)

statement ok
ALTER TABLE t ADD g INT DEFAULT 1 CHECK (g > 0)

statement ok
ALTER TABLE t ADD h INT CHECK (h > 0) CHECK (h < 10) UNIQUE

statement error pq: validation of CHECK "i < 0:::INT8" failed on row:.* i=1
ALTER TABLE t ADD i INT DEFAULT 1 CHECK (i < 0)

statement error pq: validation of CHECK "i < g" failed on row:.* g=1.* i=1
ALTER TABLE t ADD i INT DEFAULT 1 CHECK (i < g)

statement error pq: validation of CHECK "i > 0:::INT8" failed on row:.* g=1.* i=0
ALTER TABLE t ADD i INT AS (g - 1) STORED CHECK (i > 0)

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_f   CHECK        CHECK ((f > 1))      true
t  check_g   CHECK        CHECK ((g > 0))      true
t  check_h   CHECK        CHECK ((h > 0))      true
t  check_h1  CHECK        CHECK ((h < 10))     true
t  t_h_key   UNIQUE       UNIQUE (h ASC)       true
t  t_pkey    PRIMARY KEY  PRIMARY KEY (a ASC)  true

statement ok
DROP TABLE t

# Test that more than one column with constraints can be added in the same
# statement. The constraints added here are on columns that are new and both
# columns and constraints run through the schema change process together.

statement ok
CREATE TABLE t (a INT PRIMARY KEY)

statement ok
INSERT INTO t VALUES (1)

# Check references column added in same statement
statement ok
ALTER TABLE t ADD b INT DEFAULT 1, ADD c INT DEFAULT 2 CHECK (c > b)

statement ok
ALTER TABLE t ADD d INT UNIQUE, ADD e INT UNIQUE, ADD f INT

# Check references column added in same statement
statement error pq: validation of CHECK "g = h" failed on row:.* g=3.* h=2
ALTER TABLE t ADD g INT DEFAULT 3, ADD h INT DEFAULT 2 CHECK (g = h)

# Multiple unique columns can be added, followed by other commands (#35011)
statement ok
ALTER TABLE t ADD COLUMN u INT UNIQUE, ADD COLUMN v INT UNIQUE, ADD CONSTRAINT ck CHECK (a > 0);

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_c_b  CHECK        CHECK ((c > b))      true
t  ck         CHECK        CHECK ((a > 0))      true
t  t_d_key    UNIQUE       UNIQUE (d ASC)       true
t  t_e_key    UNIQUE       UNIQUE (e ASC)       true
t  t_pkey     PRIMARY KEY  PRIMARY KEY (a ASC)  true
t  t_u_key    UNIQUE       UNIQUE (u ASC)       true
t  t_v_key    UNIQUE       UNIQUE (v ASC)       true

statement ok
DROP TABLE t

# Subsequent operations succeed because the table is empty
statement ok
CREATE TABLE tt (a INT PRIMARY KEY)

statement ok
ALTER TABLE tt ADD COLUMN q DECIMAL NOT NULL

statement ok
ALTER table tt ADD COLUMN r DECIMAL

# Ensure that a UNIQUE NOT NULL COLUMN can be added when there is no data in
# the table.
statement ok
ALTER TABLE tt ADD COLUMN s DECIMAL UNIQUE NOT NULL

statement ok
ALTER TABLE tt ADD t DECIMAL UNIQUE DEFAULT 4.0

query TTBTTTB colnames
SHOW COLUMNS FROM tt
----
column_name  data_type  is_nullable  column_default  generation_expression  indices                      is_hidden
a            INT8       false        NULL            ·                      {tt_pkey,tt_s_key,tt_t_key}  false
q            DECIMAL    false        NULL            ·                      {tt_pkey}                    false
r            DECIMAL    true         NULL            ·                      {tt_pkey}                    false
s            DECIMAL    false        NULL            ·                      {tt_pkey,tt_s_key}           false
t            DECIMAL    true         4.0:::DECIMAL   ·                      {tt_pkey,tt_t_key}           false

# Default values can be added and changed after table creation.
statement ok
CREATE TABLE add_default (a int primary key, b int not null)

statement error null value in column "b" violates not-null constraint
INSERT INTO add_default (a) VALUES (1)

statement ok
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT 42

# query TTBTTTB colnames
# SHOW COLUMNS FROM add_default
# ----
# column_name  data_type  is_nullable  column_default  generation_expression  indices                      is_hidden

statement ok
INSERT INTO add_default (a) VALUES (2)

statement ok
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT 10

statement error pgcode 42804 expected DEFAULT expression to have type int, but ''i'::STRING' has type string
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT 'i'::string

statement ok
INSERT INTO add_default (a) VALUES (3)

statement error could not parse "foo" as type int
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT 'foo'

statement error variable sub-expressions are not allowed in DEFAULT
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT c

statement error variable sub-expressions are not allowed in DEFAULT
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT (SELECT 1)

statement ok
ALTER TABLE add_default ALTER COLUMN b DROP DEFAULT

statement error null value in column "b" violates not-null constraint
INSERT INTO add_default (a) VALUES (4)

statement ok
ALTER TABLE add_default ALTER COLUMN b SET DEFAULT NULL

statement error null value in column "b" violates not-null constraint
INSERT INTO add_default (a) VALUES (4)

# Each row gets the default value from the time it was inserted.
query II rowsort
SELECT * FROM add_default
----
2 42
3 10

statement ok
ALTER TABLE add_default ALTER b DROP NOT NULL

statement ok
INSERT INTO add_default (a) VALUES (5)

query II
SELECT * from add_default WHERE a=5
----
5 NULL

# Add a column with a default current_timestamp()
statement ok
ALTER TABLE add_default ADD COLUMN c TIMESTAMP DEFAULT current_timestamp()

query II rowsort
SELECT a,b FROM add_default WHERE current_timestamp > c AND current_timestamp() - c < interval '10s'
----
2 42
3 10
5 NULL

# Add a column with a default transaction_timestamp()
statement ok
ALTER TABLE add_default ADD COLUMN d TIMESTAMP DEFAULT transaction_timestamp()

query II rowsort
SELECT a,b FROM add_default WHERE d > c AND d - c < interval '10s'
----
2 42
3 10
5 NULL

# Add a column with a default statement_timestamp()
statement ok
ALTER TABLE add_default ADD COLUMN e TIMESTAMP DEFAULT statement_timestamp()

query II rowsort
SELECT a,b FROM add_default WHERE e > d AND e - d < interval '10s'
----
2 42
3 10
5 NULL

# Add a column with a null-default statement_timestamp()
statement ok
ALTER TABLE add_default ADD COLUMN f TIMESTAMP DEFAULT NULL

query IIS rowsort
SELECT a,b,f FROM add_default
----
2 42   NULL
3 10   NULL
5 NULL NULL

# Adding a unique column to an existing table with data with a default value
# is illegal
statement error pgcode 23505 violates unique constraint \"add_default_g_key\"
ALTER TABLE add_default ADD g INT UNIQUE DEFAULT 1

# various default evaluation errors

statement ok
CREATE SEQUENCE initial_seq

statement error pgcode 0A000 cannot evaluate scalar expressions containing sequence operations in this context
ALTER TABLE add_default ADD g INT DEFAULT nextval('initial_seq')

statement error pgcode 22C01 cannot evaluate scalar expressions using table lookups in this context
ALTER TABLE add_default ADD g OID DEFAULT 'foo'::regclass::oid

statement error pgcode 22C01 cannot evaluate scalar expressions using table lookups in this context
ALTER TABLE add_default ADD g INT DEFAULT 'foo'::regtype::INT

subtest 26422

statement ok
BEGIN

statement ok
ALTER TABLE add_default ADD fee FLOAT NOT NULL DEFAULT 2.99

statement ok
ALTER TABLE add_default ALTER COLUMN fee DROP DEFAULT

statement error pgcode XXA00 null value in column "fee" violates not-null constraint
COMMIT

query T rowsort
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name = 'sql.schema.change_in_explicit_txn'
----
sql.schema.change_in_explicit_txn

statement error pgcode 42703 column "fee" does not exist
ALTER TABLE add_default DROP fee

# Multiple columns can be added at once with heterogeneous DEFAULT usage
statement ok
CREATE TABLE d (a INT PRIMARY KEY)

statement ok
INSERT INTO d VALUES (1), (2)

statement ok
ALTER TABLE d ADD COLUMN c INT, ADD COLUMN b INT DEFAULT 7

statement ok
INSERT INTO d (a, c) VALUES (3, 4)

query III rowsort
SELECT * FROM d
----
1 NULL 7
2 NULL 7
3 4    7

# Test privileges.

statement ok
CREATE TABLE privs (a INT PRIMARY KEY, b INT)

statement ok
INSERT INTO privs VALUES (1)

user testuser

query T
SHOW DATABASE
----
test

statement error pq: must be owner of table privs or have CREATE privilege on table privs
ALTER TABLE privs ADD c INT

statement error pq: must be owner of table privs or have CREATE privilege on table privs
ALTER TABLE privs ADD CONSTRAINT foo UNIQUE (b)

user root

query TTBTTTB colnames
SHOW COLUMNS FROM privs
----
column_name  data_type  is_nullable  column_default  generation_expression  indices       is_hidden
a            INT8       false        NULL            ·                      {privs_pkey}  false
b            INT8       true         NULL            ·                      {privs_pkey}  false

statement ok
GRANT CREATE ON privs TO testuser

user testuser

statement ok
ALTER TABLE privs ADD c INT

statement ok
ALTER TABLE privs ADD CONSTRAINT foo UNIQUE (b)

query TTBTTTB colnames
SHOW COLUMNS FROM privs
----
column_name  data_type  is_nullable  column_default  generation_expression  indices           is_hidden
a            INT8       false        NULL            ·                      {foo,privs_pkey}  false
b            INT8       true         NULL            ·                      {foo,privs_pkey}  false
c            INT8       true         NULL            ·                      {privs_pkey}      false

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER TABLE nonexistent SPLIT AT VALUES (42)

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER INDEX nonexistent@noindex SPLIT AT VALUES (42)

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER TABLE nonexistent UNSPLIT AT VALUES (42)

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER INDEX nonexistent@noindex UNSPLIT AT VALUES (42)

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER TABLE nonexistent UNSPLIT ALL

statement error pgcode 42P01 relation "nonexistent" does not exist
ALTER INDEX nonexistent@noindex UNSPLIT ALL

user root

statement ok
CREATE VIEW privsview AS SELECT a,b,c FROM privs

statement error pgcode 42809 "privsview" is not a table
ALTER TABLE privsview ADD d INT

statement error pgcode 42809 "privsview" is not a table
ALTER TABLE privsview SPLIT AT VALUES (42)

statement error pgcode 42809 "privsview" is not a table
ALTER TABLE privsview UNSPLIT AT VALUES (42)

statement error pgcode 42809 "privsview" is not a table
ALTER TABLE privsview UNSPLIT ALL

# Verify that impure defaults are evaluated separately on each row
# (#14352)
statement ok
CREATE TABLE impure (x INT); INSERT INTO impure(x) VALUES (1), (2), (3);

statement ok
ALTER TABLE impure ADD COLUMN a INT DEFAULT unique_rowid();

query I
SELECT count(distinct a) FROM impure
----
3

# No orphaned schema change jobs.
query I
SELECT count(*) FROM crdb_internal.jobs
WHERE job_type = 'SCHEMA CHANGE' AND status = 'pending' OR status = 'started'
----
0

# Verify that ALTER TABLE statements are rolled back properly when a DEFAULT expression returns
# an error.

statement ok
CREATE TABLE default_err_test (foo text)

statement ok
INSERT INTO default_err_test VALUES ('foo'), ('bar'), ('baz')

statement error some_msg
ALTER TABLE default_err_test ADD COLUMN id int DEFAULT crdb_internal.force_error('foo', 'some_msg')

query T
SELECT * from default_err_test ORDER BY foo
----
bar
baz
foo

# Create a table with a computed column that we'll de-compute
statement ok
CREATE TABLE decomputed_column (a INT PRIMARY KEY, b INT AS ( a + 1 ) STORED, FAMILY "primary" (a, b))

statement ok
INSERT INTO decomputed_column VALUES (1), (2)

statement error cannot write directly to computed column
INSERT INTO decomputed_column VALUES (3, NULL), (4, 99)

statement ok
ALTER TABLE decomputed_column ALTER COLUMN b DROP STORED

statement error pq: column "a" is not a computed column
ALTER TABLE decomputed_column ALTER COLUMN a DROP STORED

statement error pq: column "b" is not a computed column
ALTER TABLE decomputed_column ALTER COLUMN b DROP STORED

# Verify that the computation is dropped and that we can mutate the column
statement ok
INSERT INTO decomputed_column VALUES (3, NULL), (4, 99)

query II
select a, b from decomputed_column order by a
----
1 2
2 3
3 NULL
4 99

query TT
show create table decomputed_column
----
decomputed_column  CREATE TABLE public.decomputed_column (
                   a INT8 NOT NULL,
                   b INT8 NULL,
                   CONSTRAINT decomputed_column_pkey PRIMARY KEY (a ASC)
)

# Test for https://github.com/cockroachdb/cockroach/issues/26483
# We try to create a unique column on an un-indexable type.
statement ok
CREATE TABLE b26483()

# Verify that auditing can be enabled by root, and cannot be disabled by non-root.

statement ok
CREATE TABLE audit(x INT); ALTER TABLE audit EXPERIMENTAL_AUDIT SET READ WRITE;

query T
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name = 'sql.schema.set_audit_mode.read_write'
----
sql.schema.set_audit_mode.read_write

# The user must be able to issue ALTER for this test to be meaningful.
statement ok
GRANT CREATE ON audit TO testuser

user testuser

# Check the user can indeed change the table
statement ok
ALTER TABLE audit ADD COLUMN y INT

# But not the audit settings.
statement error change auditing settings on a table
ALTER TABLE audit EXPERIMENTAL_AUDIT SET OFF

user root

statement ok
ALTER TABLE audit EXPERIMENTAL_AUDIT SET OFF

query T
SELECT feature_name FROM crdb_internal.feature_usage WHERE feature_name = 'sql.schema.set_audit_mode.off'
----
sql.schema.set_audit_mode.off

# Check column backfill in the presence of fks
subtest 27402

statement ok
CREATE TABLE users (
    id INT NOT NULL,
    city STRING NOT NULL,
    name STRING NULL,
    CONSTRAINT "primary" PRIMARY KEY (city ASC, id ASC)
)

statement ok
CREATE TABLE vehicles (
    id INT NOT NULL,
    city STRING NOT NULL,
    type STRING NULL,
    owner_id INT NULL,
    mycol STRING NULL,
    CONSTRAINT "primary" PRIMARY KEY (city ASC, id ASC),
    INDEX vehicles_auto_index_fk_city_ref_users (city ASC, owner_id ASC)
)

statement ok
CREATE TABLE rides (
    id INT NOT NULL,
    city STRING NOT NULL,
    vehicle_city STRING NULL,
    rider_id INT NULL,
    vehicle_id INT NULL,
    CONSTRAINT "primary" PRIMARY KEY (city ASC, id ASC),
    INDEX rides_auto_index_fk_city_ref_users (city ASC, rider_id ASC),
    INDEX rides_auto_index_fk_vehicle_city_ref_vehicles (vehicle_city ASC, vehicle_id ASC),
    CONSTRAINT check_vehicle_city_city CHECK (vehicle_city = city)
)

statement ok
ALTER TABLE vehicles ADD CONSTRAINT fk_city_ref_users FOREIGN KEY (city, owner_id) REFERENCES users (city, id)

statement ok
ALTER TABLE rides ADD CONSTRAINT fk_city_ref_users FOREIGN KEY (city, rider_id) REFERENCES users (city, id)

statement ok
ALTER TABLE rides ADD CONSTRAINT fk_vehicle_city_ref_vehicles FOREIGN KEY (vehicle_city, vehicle_id) REFERENCES vehicles (city, id)


statement ok
INSERT INTO users VALUES (10, 'lagos', 'chimamanda')

statement ok
INSERT INTO vehicles VALUES (100, 'lagos', 'toyota', 10, 'mycol')

statement ok
INSERT INTO rides VALUES (567, 'lagos', 'lagos', 10, 100)

statement ok
ALTER TABLE vehicles DROP COLUMN mycol;

# check that adding a reference on a column still being backfilled fails.
# fix through #32917

statement ok
CREATE TABLE t32917 (a INT PRIMARY KEY)

statement ok
INSERT INTO t32917 VALUES (1), (2), (3)

statement ok
CREATE TABLE t32917_2 (b INT PRIMARY KEY)

statement ok
INSERT INTO t32917_2 VALUES (1), (2), (3)

# Test SET NOT NULL
statement ok
CREATE TABLE t (a INT)

statement ok
INSERT INTO t VALUES (1), (NULL)

statement error validation of NOT NULL constraint failed: validation of CHECK "a IS NOT NULL" failed
ALTER TABLE t ALTER COLUMN a SET NOT NULL

statement ok
DELETE FROM t WHERE a IS NULL

statement ok
ALTER TABLE t ALTER COLUMN a SET NOT NULL

statement error null value in column "a" violates not-null constraint
INSERT INTO t VALUES (NULL)

query TTTTB
SHOW CONSTRAINTS FROM t
----

statement ok
ALTER TABLE t ALTER COLUMN a DROP NOT NULL

statement ok
INSERT INTO t VALUES (NULL)

statement ok
DROP TABLE t

# Test interaction of SET NOT NULL with other constraints
statement ok
CREATE TABLE t (a INT)

statement ok
INSERT INTO t VALUES (1)

# Check for name collisions with the auto-generated NOT NULL check constraint name
statement ok
ALTER TABLE t ADD CONSTRAINT a_auto_not_null CHECK (a IS NOT NULL)

statement ok
ALTER TABLE t ADD CONSTRAINT a_auto_not_null1 CHECK (a IS NOT NULL), ALTER COLUMN a SET NOT NULL

statement error null value in column "a" violates not-null constraint
INSERT INTO t VALUES (NULL)

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  a_auto_not_null   CHECK  CHECK ((a IS NOT NULL))  true
t  a_auto_not_null1  CHECK  CHECK ((a IS NOT NULL))  true

statement ok
DROP TABLE t

# Check for adding constraints NOT VALID
statement ok
CREATE TABLE t (a int);

statement ok
INSERT INTO t VALUES (10), (15), (17)

statement error pq: validation of CHECK "a < 16:::INT8" failed on row: a=17
ALTER TABLE t ADD CHECK (a < 16)

statement ok
ALTER TABLE t ADD CHECK (a < 100)

statement ok
ALTER TABLE t ADD CHECK (a < 16) NOT VALID

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_a   CHECK  CHECK ((a < 100))           true
t  check_a1  CHECK  CHECK ((a < 16)) NOT VALID  false

query error pq: failed to satisfy CHECK constraint \(a < 16:::INT8\)
INSERT INTO t VALUES (20)

statement error pq: validation of CHECK "a < 16:::INT8" failed on row: a=17
ALTER TABLE t VALIDATE CONSTRAINT check_a1

statement ok
DELETE FROM t WHERE a = 17

statement ok
ALTER TABLE t VALIDATE CONSTRAINT check_a1

query TTTTB
SHOW CONSTRAINTS FROM t
----
t  check_a   CHECK  CHECK ((a < 100))  true
t  check_a1  CHECK  CHECK ((a < 16))   true

subtest regression_42858

statement ok
CREATE TABLE TEST2 (COL1 SERIAL PRIMARY KEY, COL2 INT8)

statement ok
CREATE TABLE TEST1 (COL1 SERIAL PRIMARY KEY, COL2 INT8, COL3 INT8)

statement ok
ALTER TABLE TEST1 ADD CONSTRAINT duplicate_name FOREIGN KEY (COL2) REFERENCES TEST2 (COL1)

statement error pq: duplicate constraint name: "duplicate_name"
ALTER TABLE TEST1 ADD CONSTRAINT duplicate_name FOREIGN KEY (COL3) REFERENCES TEST2 (COL1)

statement ok
DROP TABLE test1; DROP TABLE test2

subtest multiple_set_drop_not_null_inside_txn

statement ok
CREATE TABLE t1(x INT, y INT);

statement ok
BEGIN;
ALTER TABLE t1 ALTER COLUMN x SET NOT NULL;
ALTER TABLE t1 ALTER COLUMN y SET NOT NULL;
COMMIT

statement ok
BEGIN;
ALTER TABLE t1 ALTER COLUMN x DROP NOT NULL;
ALTER TABLE t1 ALTER COLUMN y DROP NOT NULL;
COMMIT

statement ok
DROP TABLE t1

subtest regression_43092

statement ok
CREATE TABLE t43092(x INT PRIMARY KEY)

statement error pgcode 42P16 column "x" is in a primary index
ALTER TABLE t43092 ALTER COLUMN x DROP NOT NULL

statement ok
DROP TABLE t43092

subtest regression_qualification_feature_counts

statement ok
CREATE TABLE telemetry_test (d int);
ALTER TABLE telemetry_test
  ADD COLUMN a int DEFAULT 1,
  ADD COLUMN b int UNIQUE CHECK(b > 1),
  ADD COLUMN c int AS (a + b) STORED

query T rowsort
SELECT feature_name FROM crdb_internal.feature_usage
WHERE feature_name IN (
  'sql.schema.new_column.qualification.computed',
  'sql.schema.new_column.qualification.default_expr',
  'sql.schema.new_column.qualification.unique'
)
----
sql.schema.new_column.qualification.unique
sql.schema.new_column.qualification.computed
sql.schema.new_column.qualification.default_expr

statement ok
DROP TABLE telemetry_test

# Disable stats injection in explicit transactions.
statement ok
BEGIN

statement ok
CREATE TABLE inject_stats (k CHAR PRIMARY KEY, v TIMESTAMPTZ)

statement error pq: cannot inject statistics in an explicit transaction
ALTER TABLE inject_stats INJECT STATISTICS '[]'

statement ok
ROLLBACK

subtest regression_47141

statement ok
CREATE TABLE regression_47141(a time(3), b bytea)

# Regression for #26045.
statement ok
CREATE TABLE t25045 (x INT, y INT AS (x+1) STORED)

statement error pq: column \"x\" is referenced by computed column \"y\"
ALTER TABLE t25045 DROP COLUMN x

subtest add_col_references

statement ok
DROP TABLE IF EXISTS t1, t2;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (y INT)

statement ok
ALTER TABLE t2 ADD COLUMN x INT REFERENCES t1 (x)

statement ok
INSERT INTO t1 VALUES (1)

statement error pq: insert on table "t2" violates foreign key constraint "t2_x_fkey"
INSERT INTO t2 VALUES (2, 2)

statement ok
INSERT INTO t2 VALUES (1, 1)

# Check that the foreign key was indeed added.
query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x)
)

# Test that only one index gets created when adding a column
# with references and unique.
statement ok
CREATE TABLE t3 (y INT)

statement ok
ALTER TABLE t3 ADD COLUMN x INT UNIQUE REFERENCES t1 (x)

query TT
SHOW CREATE t3
----
t3  CREATE TABLE public.t3 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t3_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t3_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x),
    UNIQUE INDEX t3_x_key (x ASC)
)

# We allowed the foreign key validation code to look into the mutations
# list to validate what columns / indexes can be used for foreign keys.
# Ensure that we still have the correct restrictions.
statement ok
DROP TABLE t1, t2 CASCADE;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (x INT, y INT, INDEX i (x))

statement error pq: column \"x\" does not exist
BEGIN;
ALTER TABLE t2 DROP COLUMN x;
ALTER TABLE t2 ADD FOREIGN KEY (x) REFERENCES t1(x);

statement ok
ROLLBACK

statement ok
INSERT INTO t2 VALUES (1, 2)

# Test using ADD COL REFERENCES in a self referencing constraint.
statement ok
DROP TABLE t1 CASCADE;
CREATE TABLE t1 (x INT PRIMARY KEY);
ALTER TABLE t1 ADD COLUMN x2 INT REFERENCES t1 (x)

query TT
SHOW CREATE t1
----
t1  CREATE TABLE public.t1 (
    x INT8 NOT NULL,
    x2 INT8 NULL,
    CONSTRAINT t1_pkey PRIMARY KEY (x ASC),
    CONSTRAINT t1_x2_fkey FOREIGN KEY (x2) REFERENCES public.t1(x)
)

statement error pq: insert on table "t1" violates foreign key constraint "t1_x2_fkey"
INSERT INTO t1 VALUES (1, 2)

# Test ADD COL REFERENCES on a new table in the same txn.
statement ok
DROP TABLE t1, t2 CASCADE

statement ok
BEGIN;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (y INT);
ALTER TABLE t2 ADD COLUMN x INT REFERENCES t1 (x);
COMMIT

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x) NOT VALID
)

# Test that we can also add a column and then an FK in the same txn.
statement ok
DROP TABLE t1, t2 CASCADE

statement ok
BEGIN;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (y INT);
ALTER TABLE t2 ADD COLUMN x INT;
ALTER TABLE t2 ADD FOREIGN KEY (x) REFERENCES t1 (x);
COMMIT

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x) NOT VALID
)

# Test that we can add a column and an index to an FK in the same txn.
statement ok
DROP TABLE t1, t2 CASCADE

statement ok
BEGIN;
CREATE TABLE t1 (x INT PRIMARY KEY);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (y INT);
INSERT INTO t2 VALUES (2);
ALTER TABLE t2 ADD COLUMN x INT;
CREATE INDEX ON t2 (x);
ALTER TABLE t2 ADD FOREIGN KEY (x) REFERENCES t1 (x);
COMMIT

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x) NOT VALID,
    INDEX t2_x_idx (x ASC)
)

# Test the above on a table not created in the same txn.
statement ok
DROP TABLE t1, t2 CASCADE;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (y INT)

statement ok
BEGIN;
ALTER TABLE t2 ADD COLUMN x INT;
CREATE INDEX ON t2 (x);
ALTER TABLE t2 ADD FOREIGN KEY (x) REFERENCES t1 (x);
COMMIT

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x),
    INDEX t2_x_idx (x ASC)
)

# Test that an FK can use a newly created index.
statement ok
DROP TABLE t1, t2 CASCADE;
CREATE TABLE t1 (x INT PRIMARY KEY);
CREATE TABLE t2 (x INT)

statement ok
BEGIN;
CREATE INDEX ON t2 (x);
ALTER TABLE t2 ADD FOREIGN KEY (x) REFERENCES t1 (x);
COMMIT

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    x INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x),
    INDEX t2_x_idx (x ASC)
)

# Test when default column value leads to an FK violation.
statement ok
DROP TABLE t1, t2 CASCADE

statement ok
CREATE TABLE t1 (x INT PRIMARY KEY);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (y INT);
INSERT INTO t2 VALUES (2)

statement error pq: foreign key violation
ALTER TABLE t2 ADD COLUMN x INT DEFAULT 2 UNIQUE REFERENCES t1 (x)

# Test that it works with an appropriate default.
statement ok
ALTER TABLE t2 ADD COLUMN x INT DEFAULT 1 UNIQUE REFERENCES t1 (x)

query TT
SHOW CREATE t2
----
t2  CREATE TABLE public.t2 (
    y INT8 NULL,
    rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
    x INT8 NULL DEFAULT 1:::INT8,
    CONSTRAINT t2_pkey PRIMARY KEY (rowid ASC),
    CONSTRAINT t2_x_fkey FOREIGN KEY (x) REFERENCES public.t1(x),
    UNIQUE INDEX t2_x_key (x ASC)
)

# Regression 50069, computed exprs must only refer to columns inside the
# current table.
statement ok
CREATE TABLE t50069_a (x INT);
CREATE TABLE t50069_b (x INT);

statement error pq: no data source matches prefix: t50069_b in this context
ALTER TABLE t50069_a ADD COLUMN y INT AS (t50069_b.x + 1) STORED

statement ok
CREATE DATABASE d;
CREATE TABLE d.public.t50069_a (x INT);

statement error pq: no data source matches prefix: d.public.t50069_a in this context
ALTER TABLE t50069_a ADD COLUMN y INT AS (d.public.t50069_a.x + 1) STORED

# Dropping a column with a foreign key should delete the column and the FK.
statement ok
DROP TABLE IF EXISTS parent, child;
CREATE TABLE parent (p INT PRIMARY KEY);
CREATE TABLE child (c INT PRIMARY KEY, p INT REFERENCES parent(p), FAMILY (c, p));
ALTER TABLE child DROP COLUMN p

query TT
SHOW CREATE child
----
child  CREATE TABLE public.child (
       c INT8 NOT NULL,
       CONSTRAINT child_pkey PRIMARY KEY (c ASC),
       FAMILY fam_0_c_p (c)
)

# Regression test for #52816.
statement ok
CREATE TABLE t52816 (x INT, y INT);
ALTER TABLE t52816 RENAME COLUMN x TO x2, RENAME COLUMN y TO y;
SELECT x2, y FROM t52816

# Regression test for #54196.
statement ok
CREATE TABLE IF NOT EXISTS regression_54196 (
	col1 int,
	col2 int,
	col3 int,
	INDEX (col1, col2),
	INDEX (col1, col3),
	INDEX (col2, col3)
); ALTER TABLE regression_54196 DROP COLUMN col1

query TT
SELECT index_name, column_name FROM [SHOW INDEXES FROM regression_54196]
ORDER BY index_name, column_name ASC
----
regression_54196_col2_col3_idx  col2
regression_54196_col2_col3_idx  col3
regression_54196_col2_col3_idx  rowid
regression_54196_pkey           col2
regression_54196_pkey           col3
regression_54196_pkey           rowid

# Test to ensure that renaming a constraint on top of an existing index
# fails with the correct error.

statement ok
CREATE TABLE t_cannot_rename_constraint_over_index (
    k INT PRIMARY KEY,
    v INT,
    CONSTRAINT v_unique UNIQUE (v),
    INDEX idx_v (v)
);

statement error relation idx_v already exists
ALTER TABLE t_cannot_rename_constraint_over_index RENAME CONSTRAINT v_unique TO idx_v;

statement error relation idx_v already exists
ALTER TABLE t_cannot_rename_constraint_over_index RENAME CONSTRAINT "t_cannot_rename_constraint_over_index_pkey" TO idx_v;

subtest unique_without_index

statement error pq: unique constraints without an index are not yet supported
CREATE TABLE unique_without_index_error (
  a INT UNIQUE WITHOUT INDEX
)

statement ok
CREATE TABLE unique_without_index_error (
  a INT
)

statement error pq: unique constraints without an index are not yet supported
ALTER TABLE unique_without_index_error ADD CONSTRAINT a_key UNIQUE WITHOUT INDEX (a)

statement ok
SET experimental_enable_unique_without_index_constraints = true

statement ok
CREATE TABLE unique_without_index (
  a INT,
  b INT UNIQUE WITHOUT INDEX,
  c INT UNIQUE,
  d INT UNIQUE WITHOUT INDEX,
  e INT,
  UNIQUE WITHOUT INDEX (b),
  UNIQUE WITHOUT INDEX (a, b),
  UNIQUE WITHOUT INDEX (c),
  UNIQUE WITHOUT INDEX (d, e)
)

statement ok
CREATE TABLE uwi_child (
  d INT REFERENCES unique_without_index (d),
  e INT,
  CONSTRAINT fk_d_e FOREIGN KEY (d, e) REFERENCES unique_without_index (d, e),
  CONSTRAINT fk_e_d FOREIGN KEY (e, d) REFERENCES unique_without_index (e, d)
)

# We don't yet support adding a column marked as UNIQUE WITHOUT INDEX after a
# table is created. (The full error message includes a hint with a workaround.)
statement error pgcode 0A000 pq: adding a column marked as UNIQUE WITHOUT INDEX is unsupported
ALTER TABLE unique_without_index ADD COLUMN f INT UNIQUE WITHOUT INDEX

# To add a UNIQUE WITHOUT INDEX column, first add the column, then add the
# constraint.
statement ok
ALTER TABLE unique_without_index ADD COLUMN f INT;
ALTER TABLE unique_without_index ADD CONSTRAINT my_unique_f UNIQUE WITHOUT INDEX (f);
ALTER TABLE unique_without_index ADD CONSTRAINT my_partial_unique_f UNIQUE WITHOUT INDEX (f) WHERE f > 0

# The unique constraint predicate must be valid. It cannot reference
# non-existent columns.
# TODO(mgartner): If we ever decide to make UNIQUE WITHOUT INDEX available
# without the experimental setting, we should test that other types of invalid
# predicates produce errors. There are similar tests in the partial_index
# logictests that would be a good starting point.
statement error column "g" does not exist
ALTER TABLE unique_without_index ADD CONSTRAINT bad_partial_unique UNIQUE WITHOUT INDEX (f) WHERE g > 0

# The unique constraint prevents new duplicate values.
statement error pgcode 23505 pq: duplicate key value violates unique constraint "my_unique_f"\nDETAIL: Key \(f\)=\(1\) already exists\.
INSERT INTO unique_without_index (f) VALUES (1), (1)

# There is no unique constraint on e, yet, so this insert succeeds.
statement ok
INSERT INTO unique_without_index (e, f) VALUES (1, 1), (1, 2)

# But trying to add a unique constraint now fails.
statement error pgcode 23505 pq: could not create unique constraint "my_unique_e"\nDETAIL: Key \(e\)=\(1\) is duplicated\.
ALTER TABLE unique_without_index ADD CONSTRAINT my_unique_e UNIQUE WITHOUT INDEX (e)

# We can create not-valid constraints, however.
statement ok
ALTER TABLE unique_without_index ADD CONSTRAINT my_unique_e UNIQUE WITHOUT INDEX (e) NOT VALID;
ALTER TABLE unique_without_index ADD CONSTRAINT my_unique_e2 UNIQUE WITHOUT INDEX (e) NOT VALID

# Trying to validate one of the constraints will fail.
statement error pgcode 23505 pq: could not create unique constraint "my_unique_e"\nDETAIL: Key \(e\)=\(1\) is duplicated\.
ALTER TABLE unique_without_index VALIDATE CONSTRAINT my_unique_e

# But after we delete a row, validation should succeed.
statement ok
DELETE FROM unique_without_index WHERE e = 1 AND f = 1;
ALTER TABLE unique_without_index VALIDATE CONSTRAINT my_unique_e

# All these constraints are already valid, so validation should succeed.
statement ok
ALTER TABLE unique_without_index VALIDATE CONSTRAINT unique_b;
ALTER TABLE unique_without_index VALIDATE CONSTRAINT unique_a_b;
ALTER TABLE unique_without_index VALIDATE CONSTRAINT unique_without_index_c_key

statement ok
CREATE TABLE unique_without_index_partial (
  a INT,
  b INT,
  c INT
);
INSERT INTO unique_without_index_partial VALUES
  (1, 1, 1),
  (2, 2, 2),
  (1, 3, -3),
  (2, -2, -2),
  (NULL, 4, 4),
  (NULL, 5, 5);

# Trying to add a partial unique constraint fails when there are duplicates.
statement error pgcode 23505 pq: could not create unique constraint "uniq_a_1"\nDETAIL: Key \(a\)=\(1\) is duplicated\.
ALTER TABLE unique_without_index_partial ADD CONSTRAINT uniq_a_1 UNIQUE WITHOUT INDEX (a) WHERE b > 0 OR c > 0

# We can create not-valid constraints, however.
statement ok
ALTER TABLE unique_without_index_partial ADD CONSTRAINT uniq_a_1 UNIQUE WITHOUT INDEX (a) WHERE b > 0 OR c > 0 NOT VALID

# Trying to validate the constraint will fail.
statement error pgcode 23505 pq: could not create unique constraint "uniq_a_1"\nDETAIL: Key \(a\)=\(1\) is duplicated\.
ALTER TABLE unique_without_index_partial VALIDATE CONSTRAINT uniq_a_1

# But after we delete a row, validation should succeed.
statement ok
DELETE FROM unique_without_index_partial WHERE a = 1 AND b = 3 AND c = -3;
ALTER TABLE unique_without_index_partial VALIDATE CONSTRAINT uniq_a_1;

# Creating a new validated constraint should also succeed.
statement ok
ALTER TABLE unique_without_index_partial ADD CONSTRAINT uniq_a_2 UNIQUE WITHOUT INDEX (a) WHERE b > 0 OR c > 0

query TTTTB colnames
SHOW CONSTRAINTS FROM unique_without_index
----
table_name            constraint_name             constraint_type  details                                 validated
unique_without_index  my_partial_unique_f         UNIQUE           UNIQUE WITHOUT INDEX (f) WHERE (f > 0)  true
unique_without_index  my_unique_e                 UNIQUE           UNIQUE WITHOUT INDEX (e)                true
unique_without_index  my_unique_e2                UNIQUE           UNIQUE WITHOUT INDEX (e) NOT VALID      false
unique_without_index  my_unique_f                 UNIQUE           UNIQUE WITHOUT INDEX (f)                true
unique_without_index  unique_a_b                  UNIQUE           UNIQUE WITHOUT INDEX (a, b)             true
unique_without_index  unique_b                    UNIQUE           UNIQUE WITHOUT INDEX (b)                true
unique_without_index  unique_b_1                  UNIQUE           UNIQUE WITHOUT INDEX (b)                true
unique_without_index  unique_c                    UNIQUE           UNIQUE WITHOUT INDEX (c)                true
unique_without_index  unique_d                    UNIQUE           UNIQUE WITHOUT INDEX (d)                true
unique_without_index  unique_d_e                  UNIQUE           UNIQUE WITHOUT INDEX (d, e)             true
unique_without_index  unique_without_index_c_key  UNIQUE           UNIQUE (c ASC)                          true

statement ok
ALTER TABLE unique_without_index RENAME COLUMN a TO aa

statement error pgcode 42704 constraint \"unique_b_2\" of relation \"unique_without_index\" does not exist
ALTER TABLE unique_without_index RENAME CONSTRAINT unique_b_2 TO unique_b_3

statement error pgcode 42710 duplicate constraint name: \"unique_b_1\"
ALTER TABLE unique_without_index RENAME CONSTRAINT unique_b TO unique_b_1

statement ok
ALTER TABLE unique_without_index RENAME CONSTRAINT unique_b TO unique_b_2

query TTTTB
SHOW CONSTRAINTS FROM unique_without_index
----
unique_without_index  my_partial_unique_f         UNIQUE  UNIQUE WITHOUT INDEX (f) WHERE (f > 0)  true
unique_without_index  my_unique_e                 UNIQUE  UNIQUE WITHOUT INDEX (e)                true
unique_without_index  my_unique_e2                UNIQUE  UNIQUE WITHOUT INDEX (e) NOT VALID      false
unique_without_index  my_unique_f                 UNIQUE  UNIQUE WITHOUT INDEX (f)                true
unique_without_index  unique_a_b                  UNIQUE  UNIQUE WITHOUT INDEX (aa, b)            true
unique_without_index  unique_b_1                  UNIQUE  UNIQUE WITHOUT INDEX (b)                true
unique_without_index  unique_b_2                  UNIQUE  UNIQUE WITHOUT INDEX (b)                true
unique_without_index  unique_c                    UNIQUE  UNIQUE WITHOUT INDEX (c)                true
unique_without_index  unique_d                    UNIQUE  UNIQUE WITHOUT INDEX (d)                true
unique_without_index  unique_d_e                  UNIQUE  UNIQUE WITHOUT INDEX (d, e)             true
unique_without_index  unique_without_index_c_key  UNIQUE  UNIQUE (c ASC)                          true

statement error pgcode 0A000 cannot drop UNIQUE constraint \"unique_without_index_c_key\"
ALTER TABLE unique_without_index DROP CONSTRAINT unique_without_index_c_key

statement error pgcode 42704 constraint \"unique_b\" of relation \"unique_without_index\" does not exist
ALTER TABLE unique_without_index DROP CONSTRAINT unique_b

# Drop a valid constraint.
statement ok
ALTER TABLE unique_without_index DROP CONSTRAINT unique_b_2

# Drop a not-valid constraint.
statement ok
ALTER TABLE unique_without_index DROP CONSTRAINT my_unique_e2

query TTTTB
SHOW CONSTRAINTS FROM unique_without_index
----
unique_without_index  my_partial_unique_f         UNIQUE  UNIQUE WITHOUT INDEX (f) WHERE (f > 0)  true
unique_without_index  my_unique_e                 UNIQUE  UNIQUE WITHOUT INDEX (e)                true
unique_without_index  my_unique_f                 UNIQUE  UNIQUE WITHOUT INDEX (f)                true
unique_without_index  unique_a_b                  UNIQUE  UNIQUE WITHOUT INDEX (aa, b)            true
unique_without_index  unique_b_1                  UNIQUE  UNIQUE WITHOUT INDEX (b)                true
unique_without_index  unique_c                    UNIQUE  UNIQUE WITHOUT INDEX (c)                true
unique_without_index  unique_d                    UNIQUE  UNIQUE WITHOUT INDEX (d)                true
unique_without_index  unique_d_e                  UNIQUE  UNIQUE WITHOUT INDEX (d, e)             true
unique_without_index  unique_without_index_c_key  UNIQUE  UNIQUE (c ASC)                          true

# Dropping a column in a unique constraint drops the constraint.
statement ok
ALTER TABLE unique_without_index DROP COLUMN b

query TTTTB
SHOW CONSTRAINTS FROM unique_without_index
----
unique_without_index  my_partial_unique_f         UNIQUE  UNIQUE WITHOUT INDEX (f) WHERE (f > 0)  true
unique_without_index  my_unique_e                 UNIQUE  UNIQUE WITHOUT INDEX (e)                true
unique_without_index  my_unique_f                 UNIQUE  UNIQUE WITHOUT INDEX (f)                true
unique_without_index  unique_c                    UNIQUE  UNIQUE WITHOUT INDEX (c)                true
unique_without_index  unique_d                    UNIQUE  UNIQUE WITHOUT INDEX (d)                true
unique_without_index  unique_d_e                  UNIQUE  UNIQUE WITHOUT INDEX (d, e)             true
unique_without_index  unique_without_index_c_key  UNIQUE  UNIQUE (c ASC)                          true

query TTTTB
SHOW CONSTRAINTS FROM uwi_child
----
uwi_child  fk_d_e            FOREIGN KEY  FOREIGN KEY (d, e) REFERENCES unique_without_index(d, e)  true
uwi_child  fk_e_d            FOREIGN KEY  FOREIGN KEY (e, d) REFERENCES unique_without_index(e, d)  true
uwi_child  uwi_child_d_fkey  FOREIGN KEY  FOREIGN KEY (d) REFERENCES unique_without_index(d)        true

# Attempting to drop a column with a foreign key reference fails.
statement error pq: "unique_d" is referenced by foreign key from table "uwi_child"
ALTER TABLE unique_without_index DROP COLUMN d

# It succeeds if we use CASCADE, and also drops the fk reference.
statement ok
ALTER TABLE unique_without_index DROP COLUMN d CASCADE

query TTTTB
SHOW CONSTRAINTS FROM unique_without_index
----
unique_without_index  my_partial_unique_f         UNIQUE  UNIQUE WITHOUT INDEX (f) WHERE (f > 0)  true
unique_without_index  my_unique_e                 UNIQUE  UNIQUE WITHOUT INDEX (e)                true
unique_without_index  my_unique_f                 UNIQUE  UNIQUE WITHOUT INDEX (f)                true
unique_without_index  unique_c                    UNIQUE  UNIQUE WITHOUT INDEX (c)                true
unique_without_index  unique_without_index_c_key  UNIQUE  UNIQUE (c ASC)                          true

query TTTTB
SHOW CONSTRAINTS FROM uwi_child
----

# Regression for #54629.
statement ok
CREATE TABLE t54629 (c INT NOT NULL, UNIQUE INDEX (c));
ALTER TABLE t54629 ADD CONSTRAINT pk PRIMARY KEY (c);
INSERT INTO t54629 VALUES (1);
DELETE FROM t54629 WHERE c = 1;

subtest regression_45985

statement ok
BEGIN;
CREATE TABLE t45985 (a INT);
ALTER TABLE t45985 ADD COLUMN b INT;
COMMIT;

query I
SELECT count(descriptor_id)
  FROM (
        SELECT json_array_elements_text(
                crdb_internal.pb_to_json('cockroach.sql.jobs.jobspb.Payload', payload)->'descriptorIds'
               )::INT8 AS descriptor_id
          FROM system.jobs
       )
 WHERE descriptor_id = ('test.public.t45985'::REGCLASS)::INT8;
----
0

# Validation for #47719 where a mutation is canceled out by a drop.
statement ok
create table tColDrop (a int);

statement ok
begin;
alter table tColDrop alter column a set not null;
alter table tColDrop drop column a;
commit;

statement ok
drop table tColDrop;

statement ok
begin;
create table tColDrop (a int);
alter table tColDrop alter column a set not null;
alter table tColDrop drop column a;
commit;

# Validate that the schema_change_successful metric
query T
SELECT feature_name FROM crdb_internal.feature_usage
WHERE feature_name IN ('job.schema_change.successful',
'job.schema_change.failed') AND
usage_count > 0
ORDER BY feature_name DESC
----
job.schema_change.successful
job.schema_change.failed

# Regression test for #61762. Do not allow adding OIDVECTOR or INT2VECTOR
# columns.
subtest regression_61762

statement ok
CREATE TABLE t61762 ()

statement error VECTOR column types are unsupported
ALTER TABLE t61762 ADD COLUMN v OIDVECTOR

statement error VECTOR column types are unsupported
ALTER TABLE t61762 ADD COLUMN v INT2VECTOR

# Regression test for #60786. Handle in-transaction constraint ADD+DROP correctly.
subtest regression_60786

statement ok
CREATE TABLE t60786(i INT PRIMARY KEY);

statement error pgcode 0A000 constraint "fk" in the middle of being added, try again later
BEGIN;
CREATE TABLE child_60786(i INT PRIMARY KEY);
ALTER TABLE t60786 ADD CONSTRAINT fk FOREIGN KEY (i) REFERENCES child_60786(i) NOT VALID;
ALTER TABLE t60786 DROP CONSTRAINT fk CASCADE

statement ok
ROLLBACK

statement error pgcode 0A000 constraint "ck" in the middle of being added, try again later
BEGIN;
ALTER TABLE t60786 ADD CONSTRAINT ck CHECK(i > 0) NOT VALID;
ALTER TABLE t60786 DROP CONSTRAINT ck CASCADE

statement ok
ROLLBACK

statement error pgcode 0A000 constraint "uq" in the middle of being added, try again later
BEGIN;
ALTER TABLE t60786 ADD CONSTRAINT uq UNIQUE WITHOUT INDEX(i) NOT VALID;
ALTER TABLE t60786 DROP CONSTRAINT uq CASCADE

statement ok
ROLLBACK

# Visible values can be added and removed after table creation.
statement ok
CREATE TABLE visible_table (a int primary key)

statement ok
ALTER TABLE visible_table ALTER COLUMN a SET VISIBLE

statement error column "non_existent_column" does not exist
ALTER TABLE visible_table ALTER COLUMN non_existent_column SET VISIBLE

query TT
SHOW CREATE TABLE visible_table
----
visible_table  CREATE TABLE public.visible_table (
               a INT8 NOT NULL,
               CONSTRAINT visible_table_pkey PRIMARY KEY (a ASC)
)

statement ok
ALTER TABLE visible_table ALTER COLUMN a SET NOT VISIBLE

query TT
SHOW CREATE TABLE visible_table
----
visible_table  CREATE TABLE public.visible_table (
               a INT8 NOT VISIBLE NOT NULL,
               CONSTRAINT visible_table_pkey PRIMARY KEY (a ASC)
)

subtest if_table_exists_already

statement ok
CREATE TABLE new_table()

query T noticetrace
CREATE TABLE IF NOT EXISTS new_table();
----
NOTICE: relation "new_table" already exists, skipping

subtest unique_index_duplicate_name

statement ok
CREATE TABLE duplicate_index_test (k INT PRIMARY KEY, v INT, INDEX idx (v));

statement error pgcode 42710 constraint with name \"idx\" already exists
ALTER TABLE duplicate_index_test ADD CONSTRAINT idx UNIQUE (v)

# Regression test for a bug which occurred when adding a foreign key
# constraint which is marked NOT VALID and is self-referencing.
subtest self_reference_fk_not_valid

statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (i INT PRIMARY KEY, j INT);
ALTER TABLE t ADD CONSTRAINT fk FOREIGN KEY (j) REFERENCES t(i) NOT VALID;

# Demonstrate that the constraint is enforced.
statement error pgcode 23503 insert on table "t" violates foreign key constraint "fk"
INSERT INTO t VALUES (1, 0)

statement ok
DROP TABLE t;

# Ensure unique constraint partial predicates are not ignored.
subtest regression_67234

statement ok
CREATE TABLE t67234 (k INT PRIMARY KEY, a INT, b INT, FAMILY (k, a, b));
ALTER TABLE t67234 ADD CONSTRAINT t67234_c1 UNIQUE (a) WHERE b > 0;
ALTER TABLE t67234 ADD CONSTRAINT t67234_c2 UNIQUE WITHOUT INDEX (b) WHERE a > 0

query T
SELECT create_statement FROM [SHOW CREATE TABLE t67234]
----
CREATE TABLE public.t67234 (
   k INT8 NOT NULL,
   a INT8 NULL,
   b INT8 NULL,
   CONSTRAINT t67234_pkey PRIMARY KEY (k ASC),
   UNIQUE INDEX t67234_c1 (a ASC) WHERE b > 0:::INT8,
   FAMILY fam_0_k_a_b (k, a, b),
   CONSTRAINT t67234_c2 UNIQUE WITHOUT INDEX (b) WHERE a > 0:::INT8
)

# Sanity: Check the number of user errors and
# database errors in the test.
query I
SELECT count(usage_count)
  FROM crdb_internal.feature_usage
 WHERE feature_name = 'sql.schema_changer.errors.constraint_violation' and usage_count >= 13;
----
1

query I
SELECT count(usage_count)
  FROM crdb_internal.feature_usage
 WHERE feature_name = 'sql.schema_changer.errors.uncategorized' and usage_count >= 4;
----
1

subtest generated_as_identity
statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (a INT UNIQUE)

statement ok
ALTER TABLE t ADD COLUMN b INT GENERATED ALWAYS AS IDENTITY

statement error pq: cannot insert into column "b"\nDETAIL: Column "b" is an identity column defined as GENERATED ALWAYS
INSERT INTO t (b) VALUES (2)

statement ok
ALTER TABLE t ADD COLUMN c INT GENERATED BY DEFAULT AS IDENTITY

query TT
SHOW CREATE TABLE t
----
t  CREATE TABLE public.t (
   a INT8 NULL,
   rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
   b INT8 NOT NULL GENERATED ALWAYS AS IDENTITY,
   c INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
   CONSTRAINT t_pkey PRIMARY KEY (rowid ASC),
   UNIQUE INDEX t_a_key (a ASC)
)

statement ok
INSERT INTO t (c) VALUES (2)

statement ok
DROP TABLE t

subtest generated_as_identity_with_seq_option
statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (a INT UNIQUE)

statement ok
ALTER TABLE t ADD COLUMN b INT GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT 3)

statement ok
ALTER TABLE t ADD COLUMN c INT GENERATED ALWAYS AS IDENTITY (START 1 INCREMENT 3
 CACHE 10)

statement ok
ALTER TABLE t DROP COLUMN c

statement ok
INSERT INTO t (a) VALUES (7), (8), (9)

query II
SELECT * FROM t ORDER BY a
----
7  1
8  4
9  7

statement error pq: cannot insert into column "b"\nDETAIL: Column "b" is an identity column defined as GENERATED ALWAYS
INSERT INTO t (a, b) VALUES (10, 2)

statement error column "b" is an identity column
ALTER TABLE t ALTER COLUMN b SET DEFAULT 10

statement error identity column type must be INT, INT2, INT4 or INT8
ALTER TABLE t ALTER COLUMN b TYPE numeric(10,2)

statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (a INT UNIQUE)

statement ok
ALTER TABLE t ADD COLUMN b INT GENERATED BY DEFAULT AS IDENTITY (START 1 INCREMENT 3)

statement ok
ALTER TABLE t ADD COLUMN c INT GENERATED BY DEFAULT AS IDENTITY (START 1 INCREMENT 3
 CACHE 10)

query TT
SHOW CREATE TABLE t
----
t  CREATE TABLE public.t (
   a INT8 NULL,
   rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
   b INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (START 1 INCREMENT 3),
   c INT8 NOT NULL GENERATED BY DEFAULT AS IDENTITY (START 1 INCREMENT 3 CACHE 10),
   CONSTRAINT t_pkey PRIMARY KEY (rowid ASC),
   UNIQUE INDEX t_a_key (a ASC)
)

statement ok
ALTER TABLE t DROP COLUMN c

statement ok
INSERT INTO t (a) VALUES (7), (8), (9)

query II
SELECT * FROM t ORDER BY a
----
7  1
8  4
9  7

statement ok
INSERT INTO t (a, b) VALUES (10, 2)

query II
SELECT * FROM t ORDER BY a
----
7   1
8   4
9   7
10  2

statement error column "b" is an identity column
ALTER TABLE t ALTER COLUMN b SET DEFAULT 10

statement error identity column type must be INT, INT2, INT4 or INT8
ALTER TABLE t ALTER COLUMN b TYPE numeric(10,2)

# Test we can assign a PRIMARY KEY overriding the existing rowid PRIMARY KEY.
statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (id INT NOT NULL)

statement ok
ALTER TABLE t ADD CONSTRAINT t_pkey PRIMARY KEY (id)

query TT
SHOW CREATE TABLE t
----
t  CREATE TABLE public.t (
   id INT8 NOT NULL,
   rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
   CONSTRAINT t_pkey PRIMARY KEY (id ASC)
)

# Table has a PRIMARY KEY named index; check it errors when assinging PRIMARY KEY to id.
statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (
  id INT NOT NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t_pk PRIMARY KEY (rowid),
  CONSTRAINT t_pkey UNIQUE (id)
)

statement error constraint with name "t_pkey" already exists
ALTER TABLE t ADD CONSTRAINT t_pkey PRIMARY KEY (id)

# Tests other cases where rowid is not implicitly added.

statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE t (
  id INT NOT NULL,
  explicit_rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT t_pk PRIMARY KEY (explicit_rowid)
)

statement error multiple primary keys for table "t" are not allowed
ALTER TABLE t ADD CONSTRAINT t_pkey PRIMARY KEY (id)

statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE public.t (
   id INT8 NOT NULL,
   rowid INT8 NOT VISIBLE NOT NULL,
   CONSTRAINT t_pkey PRIMARY KEY (id ASC)
)

statement error multiple primary keys for table "t" are not allowed
ALTER TABLE t ADD CONSTRAINT t_pkey PRIMARY KEY (id)

statement ok
DROP TABLE IF EXISTS t;
CREATE TABLE public.t (
   id INT8 NOT NULL,
   rowid INT4 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
   CONSTRAINT t_pkey PRIMARY KEY (id ASC)
)

statement error multiple primary keys for table "t" are not allowed
ALTER TABLE t ADD CONSTRAINT t_pkey PRIMARY KEY (id)

# Fixes issues 74360, 73798 which occur because we were not looking up
# the column names for non-public column mutations and only using the
# mutation ID when creating the foreign key. As a result the wrong column
# could be referenced for a foreign key (or an error could occur if the types
# of the selected column doesn't match) referenced column did not match.
subtest add_column_with_constraint

statement ok
BEGIN

statement ok
CREATE TABLE colref (id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY);
CREATE TABLE colsource (id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY);

statement ok
ALTER TABLE colsource ADD COLUMN description STRING NULL, ADD COLUMN customer_id UUID REFERENCES colref(id);

statement ok
ALTER TABLE colsource DROP COLUMN description, DROP COLUMN customer_id

statement ok
ALTER TABLE colsource ADD COLUMN customer_id UUID  REFERENCES colref(id), ADD COLUMN description STRING NULL;

statement ok
COMMIT

# Issue #75074 occurred when we added multiple columns inside a single transaction,
# where the backfill logic was completely skipped because the last added column
# did not require one. This test will add multiple columns and confirm that a
# backfill has occurred.
subtest add_multiple_in_txn

statement ok
CREATE SEQUENCE IF NOT EXISTS multipleinstmt_seq MAXVALUE 9007199254740991;

statement ok
CREATE TABLE IF NOT EXISTS multipleinstmt (
	id INT8 DEFAULT nextval('multipleinstmt_seq') PRIMARY KEY, key STRING, value STRING
);
INSERT INTO multipleinstmt (key, value) VALUES ('a', 'a');
INSERT INTO multipleinstmt (key, value) VALUES ('b', 'b');
INSERT INTO multipleinstmt (key, value) VALUES ('c', 'c');


statement ok
BEGIN;
ALTER TABLE multipleinstmt ADD COLUMN IF NOT EXISTS a BOOL DEFAULT false;
ALTER TABLE multipleinstmt ADD COLUMN IF NOT EXISTS b STRING;
COMMIT;

query ITTBT
SELECT * FROM multipleinstmt ORDER BY id ASC;
----
1  a  a  false  NULL
2  b  b  false  NULL
3  c  c  false  NULL

statement ok
ALTER TABLE multipleinstmt ADD COLUMN IF NOT EXISTS c BOOL DEFAULT true,
                           ADD COLUMN IF NOT EXISTS d STRING;

query ITTBTBT
SELECT * FROM multipleinstmt ORDER BY id ASC;
----
1  a  a  false  NULL  true  NULL
2  b  b  false  NULL  true  NULL
3  c  c  false  NULL  true  NULL

subtest storage_params

statement ok
CREATE TABLE storage_param_table()

statement error pgcode 22023 invalid storage parameter "foo"
ALTER TABLE storage_param_table SET (foo=100)

statement error parameter "fillfactor" requires a float value
ALTER TABLE storage_param_table SET (fillfactor=true)

statement error unimplemented: storage parameter "toast_tuple_target"
ALTER TABLE storage_param_table SET (toast_tuple_target=100)

query T noticetrace
ALTER TABLE storage_param_table SET (fillfactor=99.9, autovacuum_enabled = off)
----
NOTICE: storage parameter "fillfactor" is ignored
NOTICE: storage parameter "autovacuum_enabled = 'off'" is ignored

statement error parameter "autovacuum_enabled" requires a Boolean value
ALTER TABLE storage_param_table SET (autovacuum_enabled='11')

statement error parameter "exclude_data_from_backup" requires a Boolean value
ALTER TABLE storage_param_table SET (exclude_data_from_backup='11')

statement error pgcode 22023 invalid storage parameter "foo"
ALTER TABLE storage_param_table RESET (foo)

statement ok
ALTER TABLE storage_param_table RESET (fillfactor, toast_tuple_target)

# Fixes issue 75154 when dropping and re-creating a constraint in a transaction
# we incorrectly detected the primary index as being used, even if its dropped
# inside the transaction. The primary index will still exist, but will be
# disabled via the drop constraint.
subtest drop-and-add-constraint-primary-index

statement ok
BEGIN;
create table const_tbl (a int, b int, constraint "bob" primary key (a, b));
alter table const_tbl drop constraint "bob";
alter table const_tbl add constraint "bob" primary key (a, b); -- this statement
COMMIT;

statement error relation \"const_tbl\" \(\d+\): unimplemented: primary key dropped without subsequent addition of new primary key in same transaction.*
BEGIN;
alter table const_tbl drop constraint "bob";
alter table const_tbl add constraint "bob" primary key (a, b); -- this statement
alter table const_tbl drop constraint "bob";
COMMIT;

statement ok
BEGIN;
alter table const_tbl drop constraint "bob";
-- Note: Primary key must be restored first before any other command will
-- be allowed.
alter table const_tbl add constraint "steve" primary key (a, b); -- this statement

statement error pq: relation \"const_tbl\" \(\d+\): unimplemented: cannot perform other schema changes in the same transaction as a primary key change.*
alter table const_tbl add constraint "bob" CHECK (a > 100);

statement ok
rollback

statement ok
alter table const_tbl add constraint "steve" CHECK (a > 100);

statement ok
BEGIN;
alter table const_tbl drop constraint "steve";
alter table const_tbl add constraint "steve" CHECK (a > 100);
COMMIT;

statement error  pq: duplicate constraint name: "steve"
BEGIN;
alter table const_tbl drop constraint "steve";
alter table const_tbl add constraint "steve" CHECK (a > 100);
alter table const_tbl add constraint "steve" CHECK (a > 100);
COMMIT;

# This is needed for following tests not to run in the aborted transaction
# above.
statement ok
rollback

# Test sequence is drop when a owner table/column is dropped
subtest test_serial_ownership_add_column

statement ok
SET serial_normalization = sql_sequence;

statement ok
CREATE TABLE test_serial (
	a INT PRIMARY KEY
);

statement ok
ALTER TABLE test_serial ADD COLUMN b SERIAL;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name               state   refobjid
205       test_serial_b_seq  PUBLIC  204
204       test_serial        PUBLIC  NULL

statement ok
DROP TABLE test_serial;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name  state  refobjid

statement ok
CREATE TABLE test_serial (
	a INT PRIMARY KEY
);

statement ok
ALTER TABLE test_serial ADD COLUMN b SERIAL;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name               state   refobjid
207       test_serial_b_seq  PUBLIC  206
206       test_serial        PUBLIC  NULL

statement ok
ALTER TABLE test_serial DROP COLUMN b;

query ITTT colnames
SELECT l.table_id, l.name, l.state, r.refobjid
FROM (
  SELECT table_id, name, state
  FROM crdb_internal.tables WHERE name
  LIKE 'test_serial%' AND state = 'PUBLIC'
) l
LEFT JOIN pg_catalog.pg_depend r ON l.table_id = r.objid;
----
table_id  name         state   refobjid
206       test_serial  PUBLIC  NULL

statement ok
DROP TABLE test_serial;

# Tests for issue #71709, which happens when a primary index that is used to
# enforce the uniqueness of a foreign key reference is dropped.
subtest pk-swap-fk-ref

statement ok
CREATE TABLE pk_fk_src(id int8 primary key, legacy_id int8 not null);
CREATE TABLE pk_fk_ref(a_id int8 references pk_fk_src (id));

statement error "pk_fk_src_pkey" is referenced by foreign key from table "pk_fk_ref"
BEGIN;
ALTER TABLE pk_fk_src DROP CONSTRAINT "pk_fk_src_pkey";
ALTER TABLE pk_fk_src ADD CONSTRAINT "pk_fk_src_pkey" PRIMARY KEY (legacy_id);
COMMIT;

statement ok
ROLLBACK;

statement error "pk_fk_src_pkey" is referenced by foreign key from table "pk_fk_ref"
BEGIN;
ALTER TABLE pk_fk_src DROP CONSTRAINT "pk_fk_src_pkey";
ALTER TABLE pk_fk_src ADD CONSTRAINT "pk_fk_src_pkey_new" PRIMARY KEY (legacy_id);
COMMIT;

statement ok
ROLLBACK;
