# ------------------------------------------------------------------------------
# CREATE TABLE/INDEX tests.
# ------------------------------------------------------------------------------

# Simple vector index.
statement ok
CREATE TABLE simple (
  a INT PRIMARY KEY,
  vec1 VECTOR(3),
  VECTOR INDEX (vec1),
  FAMILY (a, vec1)
)

statement ok
CREATE VECTOR INDEX ON simple (vec1)

# Alternate syntax.
statement ok
CREATE INDEX ON simple USING cspann (vec1 ASC);

query TT
SHOW CREATE TABLE simple
----
simple  CREATE TABLE public.simple (
          a INT8 NOT NULL,
          vec1 VECTOR(3) NULL,
          CONSTRAINT simple_pkey PRIMARY KEY (a ASC),
          VECTOR INDEX simple_vec1_idx (vec1),
          VECTOR INDEX simple_vec1_idx1 (vec1),
          VECTOR INDEX simple_vec1_idx2 (vec1),
          FAMILY fam_0_a_vec1 (a, vec1)
        )

statement ok
SHOW INDEX FROM simple

statement ok
DROP INDEX simple@simple_vec1_idx

statement ok
DROP INDEX simple_vec1_idx2

statement ok
DROP TABLE simple

# Specify name for index.
statement ok
CREATE TABLE alt_syntax (
  a INT PRIMARY KEY,
  vec1 VECTOR(3),
  VECTOR INDEX vec_idx (vec1 ASC),
  FAMILY (a, vec1)
)

statement ok
CREATE VECTOR INDEX another_index ON alt_syntax (vec1)

query TT
SHOW CREATE TABLE alt_syntax
----
alt_syntax  CREATE TABLE public.alt_syntax (
              a INT8 NOT NULL,
              vec1 VECTOR(3) NULL,
              CONSTRAINT alt_syntax_pkey PRIMARY KEY (a ASC),
              VECTOR INDEX vec_idx (vec1),
              VECTOR INDEX another_index (vec1),
              FAMILY fam_0_a_vec1 (a, vec1)
            )

statement ok
DROP TABLE alt_syntax

# Multiple vector indexes declared on same table.
statement ok
CREATE TABLE multiple_indexes (
  a INT PRIMARY KEY,
  vec1 VECTOR(3),
  vec2 VECTOR(1000),
  VECTOR INDEX (vec1),
  VECTOR INDEX (vec2),
  FAMILY (a, vec1, vec2)
)

query TT
SHOW CREATE TABLE multiple_indexes
----
multiple_indexes  CREATE TABLE public.multiple_indexes (
                    a INT8 NOT NULL,
                    vec1 VECTOR(3) NULL,
                    vec2 VECTOR(1000) NULL,
                    CONSTRAINT multiple_indexes_pkey PRIMARY KEY (a ASC),
                    VECTOR INDEX multiple_indexes_vec1_idx (vec1),
                    VECTOR INDEX multiple_indexes_vec2_idx (vec2),
                    FAMILY fam_0_a_vec1_vec2 (a, vec1, vec2)
                  )

statement ok
DROP INDEX multiple_indexes_vec1_idx;

statement ok
DROP INDEX multiple_indexes_vec2_idx;

statement ok
DROP TABLE multiple_indexes

# Use prefix columns in the vector index.
statement ok
CREATE TABLE prefix_cols (
  a INT PRIMARY KEY,
  b INT,
  c INT,
  vec1 VECTOR(3),
  VECTOR INDEX (c DESC, b, vec1),
  FAMILY (a, b, c, vec1)
)

statement ok
CREATE VECTOR INDEX another_index ON prefix_cols (b, c DESC, vec1)

query TT
SHOW CREATE TABLE prefix_cols
----
prefix_cols  CREATE TABLE public.prefix_cols (
               a INT8 NOT NULL,
               b INT8 NULL,
               c INT8 NULL,
               vec1 VECTOR(3) NULL,
               CONSTRAINT prefix_cols_pkey PRIMARY KEY (a ASC),
               VECTOR INDEX prefix_cols_c_b_vec1_idx (c DESC, b ASC, vec1),
               VECTOR INDEX another_index (b ASC, c DESC, vec1),
               FAMILY fam_0_a_b_c_vec1 (a, b, c, vec1)
             )

statement ok
DROP TABLE prefix_cols

# Use mixed-case column for vector index.
statement ok
CREATE TABLE mixed_case (
  a INT PRIMARY KEY,
  qUuX VECTOR(3),
  VECTOR INDEX (qUuX)
)

statement ok
CREATE VECTOR INDEX ON mixed_case (qUuX)

statement ok
DROP TABLE mixed_case

# ----- CREATE TABLE errors -----

# Try to use vector in primary key.
statement error column a has type vector, which is not indexable in a non-vector index\nHINT: you may want to create a vector index instead
CREATE TABLE t (a VECTOR(3), PRIMARY KEY (a))

statement error column b has type int, which is not allowed as the last column in a vector index
CREATE TABLE t (a INT PRIMARY KEY, b INT, VECTOR INDEX (b))

statement error column c has type vector, which is only allowed as the last column in a vector index
CREATE TABLE t (a INT PRIMARY KEY, b INT, c VECTOR(3), VECTOR INDEX (c, b))

# Try to use inverted indexable type in vector index.
statement error column b has type tsvector, which is not indexable in a non-inverted index\nHINT: you may want to create an inverted index instead. See the documentation for inverted indexes: https://www.cockroachlabs.com/docs/v25.2/inverted-indexes.html
CREATE TABLE t (a INT PRIMARY KEY, b TSVECTOR, c VECTOR(3), VECTOR INDEX (b, c))

statement error the last column in a vector index cannot have the DESC option
CREATE TABLE t (a INT PRIMARY KEY, b INT, c VECTOR(3), VECTOR INDEX (b, c DESC))

statement error vector column b does not have a fixed number of dimensions, so it cannot be indexed\nDETAIL: specify the number of dimensions in the type, like VECTOR\(128\) for 128 dimensions
CREATE TABLE t (a INT PRIMARY KEY, b VECTOR, VECTOR INDEX (b))

# Try to use vector type in forward index.
statement error column c has type vector, which is not indexable in a non-vector index\nHINT: you may want to create a vector index instead
CREATE TABLE t (a INT PRIMARY KEY, b INT, c VECTOR(3), INDEX (b, c))

# ----- CREATE INDEX errors -----
statement ok
CREATE TABLE vec_errors (
  a INT PRIMARY KEY,
  b INT,
  c TSVECTOR,
  d VECTOR,
  vec1 VECTOR(3),
  FAMILY (a, b, vec1)
)

statement error column b has type int, which is not allowed as the last column in a vector index
CREATE VECTOR INDEX ON vec_errors (a, b)

statement error column vec1 has type vector, which is only allowed as the last column in a vector index
CREATE VECTOR INDEX ON vec_errors (vec1, b)

# Try to use inverted indexable type in vector index.
statement error column c has type tsvector, which is not indexable in a non-inverted index\nHINT: you may want to create an inverted index instead. See the documentation for inverted indexes: https://www.cockroachlabs.com/docs/v25.2/inverted-indexes.html
CREATE VECTOR INDEX ON vec_errors (c, vec1)

statement error the last column in a vector index cannot have the DESC option
CREATE VECTOR INDEX ON vec_errors (b, vec1 DESC)

statement error vector column d does not have a fixed number of dimensions, so it cannot be indexed\nDETAIL: specify the number of dimensions in the type, like VECTOR\(128\) for 128 dimensions
CREATE VECTOR INDEX ON vec_errors (d)

# Try to use vector type in forward index.
statement error pq: column vec1 has type vector, which is not indexable in a non-vector index\nHINT: you may want to create a vector index instead
CREATE INDEX ON vec_errors (b, vec1)

statement error vector indexes can't be unique
CREATE UNIQUE VECTOR INDEX ON vec_errors (vec1)

statement error vector indexes don't support stored columns
CREATE INDEX on vec_errors USING cspann (vec1) STORING (b);

statement error vector indexes don't support stored columns
CREATE VECTOR INDEX on vec_errors (vec1) STORING (b);

# Try to use unsupported vector index type.
statement error at or near "hnsw": syntax error: unrecognized access method: hnsw
CREATE INDEX ON vec_errors USING hnsw (vec1)

# Operator classes are not (yet) supported.
statement error operator classes are only allowed for the last column of an inverted index
CREATE INDEX ON vec_errors USING cspann (vec1 vector_l2_ops)

statement ok
DROP TABLE vec_errors

# ------------------------------------------------------------------------------
# ALTER TABLE tests.
# TODO(andyk): Move these tests to alter_primary_key when insertion is possible.
# ------------------------------------------------------------------------------

statement ok
CREATE TABLE alter_test (
  a INT PRIMARY KEY,
  b INT NOT NULL,
  vec1 VECTOR(3),
  VECTOR INDEX (vec1),
  FAMILY (a, b, vec1)
)

statement ok
ALTER TABLE alter_test ALTER PRIMARY KEY USING COLUMNS (b)

query TT
SHOW CREATE TABLE alter_test
----
alter_test  CREATE TABLE public.alter_test (
              a INT8 NOT NULL,
              b INT8 NOT NULL,
              vec1 VECTOR(3) NULL,
              CONSTRAINT alter_test_pkey PRIMARY KEY (b ASC),
              VECTOR INDEX alter_test_vec1_idx (vec1),
              UNIQUE INDEX alter_test_a_key (a ASC),
              FAMILY fam_0_a_b_vec1 (a, b, vec1)
            )

statement ok
DROP TABLE alter_test

# ------------------------------------------------------------------------------
# Execution tests.
# ------------------------------------------------------------------------------

statement ok
CREATE TABLE exec_test (
  a INT PRIMARY KEY,
  b INT,
  vec1 VECTOR(3),
  VECTOR INDEX idx1 (vec1),
  VECTOR INDEX idx2 (b, vec1)
)

statement ok
INSERT INTO exec_test (a, b, vec1) VALUES
  (1, 1, '[1, 2, 3]'),
  (2, 1, '[4, 5, 6]'),
  (3, 2, '[7, 8, 9]'),
  (4, 2, '[10, 11, 12]'),
  (5, 2, '[13, 14, 15]'),
  (6, NULL, '[16, 17, 18]'),
  (7, NULL, '[1, 1, 1]');

# TODO(143209): write a full set of tests once we can make them deterministic.
# For now, we can write tests that return every vector with a given prefix.
query I rowsort
SELECT a FROM exec_test@idx1 ORDER BY vec1 <-> '[1, 1, 2]' LIMIT 7;
----
7
1
2
3
4
5
6

query I rowsort
SELECT a FROM exec_test@idx2 WHERE b = 1 ORDER BY vec1 <-> '[1, 1, 2]' LIMIT 2;
----
1
2

query I rowsort
SELECT a FROM exec_test@idx2 WHERE b = 2 ORDER BY vec1 <-> '[1, 1, 2]' LIMIT 3;
----
3
4
5

query I rowsort
SELECT a FROM exec_test WHERE b IS NULL ORDER BY vec1 <-> '[1, 1, 2]' LIMIT 3;
----
7
6

statement ok
DROP TABLE exec_test

#
# Test backfill.
#
# The SELECT statements for these tests retrieve all the rows in the table
# because the point is to test that backfill is happening correctly and that
# we're still able to insert into and modify the index after the backfill is
# done.

subtest backfill

statement ok
CREATE TABLE backfill_test (
  id INT PRIMARY KEY,
  username STRING COLLATE en_US_u_ks_level2,
  data INT NOT NULL,
  enc VECTOR(3),
  prefix_enc VECTOR(3)
)

statement ok
INSERT INTO backfill_test VALUES
  (1, 'jack', 10, '[1.0, 2.0, 3.0]', '[3.0, 2.0, 1.0]'),
  (2, 'jill', 20, '[4.0, 5.0, 6.0]', '[6.0, 5.0, 4.0]'),
  (3, 'ash',  30, '[7.0, 8.0, 9.0]', '[9.0, 8.0, 7.0]');

statement ok
CREATE VECTOR INDEX ON backfill_test (enc)

query ITITT
SELECT * FROM backfill_test@backfill_test_enc_idx ORDER BY enc <-> '[1.0, 2.0, 3.0]' LIMIT 3
----
1  jack  10  [1,2,3]  [3,2,1]
2  jill  20  [4,5,6]  [6,5,4]
3  ash   30  [7,8,9]  [9,8,7]

statement ok
INSERT INTO backfill_test VALUES
  (4, 'jill', 40, '[1.0, 2.0, 3.5]', '[3.5, 2.0, 1.0]'),
  (5, 'jack', 50, '[4.0, 5.5, 6.0]', '[6.0, 5.5, 4.0]'),
  (6, 'ash',  60, '[7.5, 8.0, 9.0]', '[9.0, 8.0, 7.5]');

query ITITT
SELECT * FROM backfill_test@backfill_test_enc_idx ORDER BY enc <-> '[4.0, 5.0, 6.5]' LIMIT 6
----
2  jill  20  [4,5,6]    [6,5,4]
5  jack  50  [4,5.5,6]  [6,5.5,4]
3  ash   30  [7,8,9]    [9,8,7]
4  jill  40  [1,2,3.5]  [3.5,2,1]
6  ash   60  [7.5,8,9]  [9,8,7.5]
1  jack  10  [1,2,3]    [3,2,1]

statement ok
UPDATE backfill_test SET data = data + 1 WHERE id IN (SELECT id FROM backfill_test@backfill_test_enc_idx ORDER BY enc <-> '[1.0, 2.0, 3.0]' LIMIT 2)

query ITITT
SELECT * FROM backfill_test@backfill_test_enc_idx ORDER BY enc <-> '[1.0, 2.0, 3.0]' LIMIT 6
----
1  jack  11  [1,2,3]    [3,2,1]
4  jill  41  [1,2,3.5]  [3.5,2,1]
2  jill  20  [4,5,6]    [6,5,4]
5  jack  50  [4,5.5,6]  [6,5.5,4]
3  ash   30  [7,8,9]    [9,8,7]
6  ash   60  [7.5,8,9]  [9,8,7.5]

statement ok
UPDATE backfill_test SET enc = '[3.0, 2.0, 1.0]' WHERE id = 1

query ITITT
SELECT * FROM backfill_test@backfill_test_enc_idx ORDER BY enc <-> '[1.0, 2.0, 3.0]' LIMIT 6
----
4  jill  41  [1,2,3.5]  [3.5,2,1]
1  jack  11  [3,2,1]    [3,2,1]
2  jill  20  [4,5,6]    [6,5,4]
5  jack  50  [4,5.5,6]  [6,5.5,4]
3  ash   30  [7,8,9]    [9,8,7]
6  ash   60  [7.5,8,9]  [9,8,7.5]

statement ok
CREATE VECTOR INDEX ON backfill_test (username, prefix_enc)

query ITITT
SELECT * FROM backfill_test@backfill_test_username_prefix_enc_idx WHERE username = 'ash' ORDER BY prefix_enc <-> '[3.0, 2.0, 1.0]' LIMIT 2
----
3  ash  30  [7,8,9]    [9,8,7]
6  ash  60  [7.5,8,9]  [9,8,7.5]

statement ok
INSERT INTO backfill_test VALUES
  (7, 'ash',  70, '[3.0, 2.0, 1.0]', '[1.0, 2.0, 3.0]'),
  (8, 'jack', 80, '[4.0, 5.0, 6.0]', '[6.0, 5.0, 4.0]'),
  (9, 'jill', 90, '[7.0, 8.0, 9.0]', '[9.0, 8.0, 7.0]');

query ITITT
SELECT * FROM backfill_test@backfill_test_username_prefix_enc_idx WHERE username = 'ash' ORDER BY username, prefix_enc <-> '[3.0, 2.0, 1.0]' LIMIT 3
----
7  ash  70  [3,2,1]    [1,2,3]
3  ash  30  [7,8,9]    [9,8,7]
6  ash  60  [7.5,8,9]  [9,8,7.5]

statement ok
UPDATE backfill_test SET data = data - 1 WHERE id IN (SELECT id FROM backfill_test@backfill_test_username_prefix_enc_idx WHERE username = 'ash' ORDER BY username, prefix_enc <-> '[3.0, 2.0, 1.0]' LIMIT 1)

query ITITT
SELECT * FROM backfill_test@backfill_test_username_prefix_enc_idx WHERE username = 'ash' ORDER BY username, prefix_enc <-> '[3.0, 2.0, 1.0]' LIMIT 3
----
7  ash  69  [3,2,1]    [1,2,3]
3  ash  30  [7,8,9]    [9,8,7]
6  ash  60  [7.5,8,9]  [9,8,7.5]

statement ok
UPDATE backfill_test SET prefix_enc = '[3.0, 2.0, 1.0]' WHERE id = 7

query ITITT
SELECT * FROM backfill_test@backfill_test_username_prefix_enc_idx WHERE username = 'ash' ORDER BY username, prefix_enc <-> '[3.0, 2.0, 1.0]' LIMIT 3
----
7  ash  69  [3,2,1]    [3,2,1]
3  ash  30  [7,8,9]    [9,8,7]
6  ash  60  [7.5,8,9]  [9,8,7.5]

statement ok
DROP TABLE backfill_test

subtest end
