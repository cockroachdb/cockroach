# LogicTest: !3node-tenant
# The tests in this file target the legacy FK paths.
statement ok
SET optimizer_foreign_keys = false

# Disable automatic stats to avoid flakiness.
statement ok
SET CLUSTER SETTING sql.stats.automatic_collection.enabled = false

statement ok
CREATE TABLE customers (id INT PRIMARY KEY, email STRING UNIQUE, FAMILY (id), FAMILY (email))

statement ok
INSERT INTO customers VALUES (1, 'a@co.tld'), (2, 'b@co.tld')

statement ok
CREATE TABLE products (sku STRING PRIMARY KEY, upc STRING UNIQUE, vendor STRING, FAMILY (sku), FAMILY (upc, vendor))

statement ok
INSERT INTO products VALUES ('VP-W9QH-W44L', '867072000006', 'Dave'), ('780', '885155001450', 'iRobot')

statement error pgcode 42P01 relation "productz" does not exist
CREATE TABLE missing (product STRING REFERENCES productz)

statement error pgcode 42P01 relation "customerz" does not exist
CREATE TABLE missing_with_col (customer INT REFERENCES customerz (id))

statement error pgcode 42703 column "idz" does not exist
CREATE TABLE missing_col (customer INT REFERENCES customers (idz))

statement ok
CREATE TABLE unindexed (customer INT REFERENCES customers)

query TTBITTBB colnames
SHOW INDEXES FROM unindexed
----
table_name  index_name                                      non_unique  seq_in_index  column_name  direction  storing  implicit
unindexed   primary                                         false       1             rowid        ASC        false    false
unindexed   unindexed_auto_index_fk_customer_ref_customers  true        1             customer     ASC        false    false
unindexed   unindexed_auto_index_fk_customer_ref_customers  true        2             rowid        ASC        false    true

statement error there is no unique constraint matching given keys for referenced table products
CREATE TABLE non_unique (product STRING REFERENCES products (vendor))

statement error type of "customer" \(int\) does not match foreign key "customers"."email" \(string\)
CREATE TABLE mismatch (customer INT REFERENCES customers (email))

statement ok
CREATE TABLE orders (
  id INT,
  shipment INT,
  product STRING DEFAULT 'sprockets' REFERENCES products,
  customer INT CONSTRAINT valid_customer REFERENCES customers (id),
  PRIMARY KEY (id, shipment),
  INDEX (product),
  INDEX (customer),
  FAMILY (id, shipment), FAMILY (product, customer)
)

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE NO ACTION

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON UPDATE NO ACTION

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE CASCADE

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON UPDATE CASCADE

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE SET NULL

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON UPDATE SET NULL

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE SET DEFAULT

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON UPDATE SET DEFAULT

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE RESTRICT ON UPDATE NO ACTION

statement ok
ALTER TABLE orders DROP CONSTRAINT fk_product_ref_products

statement ok
ALTER TABLE orders ADD FOREIGN KEY (product) REFERENCES products ON DELETE RESTRICT ON UPDATE RESTRICT

statement ok
ALTER TABLE orders VALIDATE CONSTRAINT fk_product_ref_products

statement ok
CREATE DATABASE "user content"

# "reviews" makes "products" have multiple inbound references, as well as making
# "orders" have both directions, and makes sure that we're handling escaping and
# cross-database references.
statement ok
CREATE TABLE "user content"."customer reviews" (
  id INT PRIMARY KEY,
  product STRING NOT NULL REFERENCES products,
  customer INT,
  "order" INT,
  shipment int,
  body STRING,
  CONSTRAINT customerfk FOREIGN KEY (customer) REFERENCES customers,
  CONSTRAINT orderfk FOREIGN KEY ("order", shipment) REFERENCES orders (id, shipment),
  INDEX (product),
  INDEX (customer),
  INDEX ("order")
)

statement ok
INSERT INTO orders VALUES (1, 1, '780', 2)

statement error foreign key violation: value \['fake'\] not found in products@primary
SET tracing = on,kv,results; INSERT INTO orders VALUES (2, 2, 'fake', 2)

statement ok
SET tracing = off

query T rowsort
SELECT message FROM [SHOW KV TRACE FOR SESSION]
WHERE message LIKE 'FKScan%'
----
FKScan /Table/54/1/"fake"/{0-1}
FKScan /Table/53/1/2/{0-1}

statement error pgcode 23503 foreign key violation: values \['780'\] in columns \[sku\] referenced in table "orders"
DELETE FROM products

statement ok
INSERT INTO "user content"."customer reviews" VALUES (1, '780', 2, 1, 1, NULL)

statement error pgcode 23503 foreign key violation: value \['790'\] not found in products@primary \[sku\]
INSERT INTO "user content"."customer reviews" (id, product, body) VALUES (2, '790', 'would not buy again')

statement ok
INSERT INTO "user content"."customer reviews" (id, product, body) VALUES (2, '780', 'would not buy again')

statement ok
CREATE TABLE "user content".review_stats (
  id INT PRIMARY KEY,
  upvotes INT,
  CONSTRAINT reviewfk FOREIGN KEY (id) REFERENCES "user content"."customer reviews"
)

query TTTTB
SHOW CONSTRAINTS FROM "user content".review_stats
----
review_stats  primary   PRIMARY KEY  PRIMARY KEY (id ASC)                                true
review_stats  reviewfk  FOREIGN KEY  FOREIGN KEY (id) REFERENCES "customer reviews"(id)  true

statement error pgcode 23503 foreign key violation: value \[5\] not found in customer reviews@primary \[id\]
INSERT INTO "user content".review_stats (id, upvotes) VALUES (5, 1)

statement ok
INSERT INTO "user content".review_stats (id, upvotes) VALUES (2, 1)

statement error pgcode 23503 foreign key violation: values \[2\] in columns \[id\] referenced in table "review_stats"
DELETE FROM "user content"."customer reviews" WHERE id = 2

statement ok
ALTER TABLE "user content".review_stats DROP CONSTRAINT reviewfk

query TTTTB
SHOW CONSTRAINTS FROM "user content".review_stats
----
review_stats  primary  PRIMARY KEY  PRIMARY KEY (id ASC)  true

statement ok
DELETE FROM "user content"."customer reviews"

statement error pgcode 23503 foreign key violation: value \['790'\] not found in products@primary \[sku\]
INSERT INTO orders VALUES (2, 1, '790', 2)

statement error pgcode 23503 foreign key violation: value \[43\] not found in customers@primary \[id\]
INSERT INTO orders VALUES (2, 1, '780', 43)

statement ok
INSERT INTO orders VALUES (2, 1, '780', 1)

# Try to point to missing FK.
statement error pgcode 23503 foreign key violation: value \['790'\] not found in products@primary \[sku\]
UPDATE orders SET product = '790' WHERE id = 2

# Try to point to missing fk *while changing PK*.
statement error pgcode 23503 foreign key violation: value \['790'\] not found in products@primary \[sku\]
UPDATE orders SET id = 3, product = '790' WHERE id = 2

# Change PK while leaving everything else is fine though.
statement ok
UPDATE orders SET id = 3 WHERE id = 2

# Change PK and point to different product.
statement ok
UPDATE orders SET id = 2, product = 'VP-W9QH-W44L' WHERE id = 3

statement ok
UPDATE orders SET product = '780' WHERE id = 2

# "delivery" is interesting since it references a secondary index with different col names.
statement ok
CREATE TABLE delivery (
  ts TIMESTAMP DEFAULT now(),
  "order" int,
  shipment int,
  item STRING REFERENCES products (upc),
  FOREIGN KEY ("order", shipment) REFERENCES orders (id, shipment),
  INDEX (item),
  FAMILY "primary" (ts, "order", shipment, item, rowid)
)

query TT
SHOW CREATE TABLE delivery
----
delivery  CREATE TABLE delivery (
          ts TIMESTAMP NULL DEFAULT now():::TIMESTAMP,
          "order" INT8 NULL,
          shipment INT8 NULL,
          item STRING NULL,
          CONSTRAINT fk_order_ref_orders FOREIGN KEY ("order", shipment) REFERENCES orders(id, shipment),
          CONSTRAINT fk_item_ref_products FOREIGN KEY (item) REFERENCES products(upc),
          INDEX delivery_item_idx (item ASC),
          INDEX delivery_auto_index_fk_order_ref_orders ("order" ASC, shipment ASC),
          FAMILY "primary" (ts, "order", shipment, item, rowid)
)

statement ok
INSERT INTO delivery ("order", shipment, item) VALUES
  (1, 1, '867072000006'), (1, 1, '867072000006'), (1, 1, '885155001450'), (1, 1, '867072000006')

statement error pgcode 23503 foreign key violation: value \['missing'\] not found in products@products_upc_key \[upc\]
INSERT INTO delivery ("order", shipment, item) VALUES
  (1, 1, '867072000006'), (1, 1, 'missing'), (1, 1, '885155001450'), (1, 1, '867072000006')

statement error pgcode 23503 foreign key violation: value \[1 99\] not found in orders@primary \[id shipment\]
INSERT INTO delivery ("order", shipment, item) VALUES
  (1, 1, '867072000006'), (1, 99, '867072000006')

statement error pgcode 23503 foreign key violation: values \['867072000006'\] in columns \[upc\] referenced in table "delivery"
DELETE FROM products WHERE sku = 'VP-W9QH-W44L'

# Blanking a field nobody cares about is fine.
statement ok
UPDATE products SET vendor = '' WHERE sku = '780'

# No-op update should be fine.
statement ok
UPDATE products SET sku = '770' WHERE sku = '750'

# Changing referenced PK fails.
statement error pgcode 23503 foreign key violation: values \['780'\] in columns \[sku\] referenced in table "orders"
UPDATE products SET sku = '770' WHERE sku = '780'

# No-op change to existing data is fine.
statement ok
UPDATE products SET upc = '885155001450' WHERE sku = '780'

# Changing referenced non-pk index fails.
statement error pgcode 23503 foreign key violation: values \['885155001450'\] in columns \[upc\] referenced in table "delivery"
UPDATE products SET upc = 'blah' WHERE sku = '780'

statement ok
ALTER TABLE delivery DROP CONSTRAINT fk_item_ref_products

statement ok
UPDATE products SET upc = 'blah' WHERE sku = '780'

statement error pgcode 23503 foreign key violation: "delivery" row item='885155001450', rowid=[0-9]* has no match in "products"
ALTER TABLE delivery ADD FOREIGN KEY (item) REFERENCES products (upc)

query TTTTB
SHOW CONSTRAINTS FROM delivery
----
delivery  fk_order_ref_orders  FOREIGN KEY  FOREIGN KEY ("order", shipment) REFERENCES orders(id, shipment)  true

statement ok
UPDATE products SET upc = '885155001450' WHERE sku = '780'

statement ok
ALTER TABLE delivery ADD FOREIGN KEY (item) REFERENCES products (upc)

query TTTTB
SHOW CONSTRAINTS FROM delivery
----
delivery  fk_item_ref_products  FOREIGN KEY  FOREIGN KEY (item) REFERENCES products(upc)                      true
delivery  fk_order_ref_orders   FOREIGN KEY  FOREIGN KEY ("order", shipment) REFERENCES orders(id, shipment)  true

statement ok
ALTER TABLE "user content"."customer reviews"
  DROP CONSTRAINT orderfk

statement ok
INSERT INTO "user content"."customer reviews" (id, product, body, "order") VALUES (3, '780', 'i ordered 100 of them', 9)

statement ok
ALTER TABLE "user content"."customer reviews"
  ADD CONSTRAINT orderfk2 FOREIGN KEY ("order", shipment) REFERENCES orders (id, shipment)

# This is allowed because we match using MATCH SIMPLE.
statement ok
ALTER TABLE "user content"."customer reviews"
  VALIDATE CONSTRAINT orderfk2

# This is allowed because we match using MATCH SIMPLE.
statement ok
INSERT INTO "user content"."customer reviews" (id, product, body, "order") VALUES (4, '780', 'i ordered 101 of them', 9)

statement error pgcode 23503 foreign key violation: value \[9 1\] not found in orders@primary \[id shipment\]
INSERT INTO "user content"."customer reviews" (id, product, body, "order", shipment) VALUES (4, '780', 'i ordered 101 of them', 9, 1)

statement error pgcode 23503 foreign key violation: value \[1 9\] not found in orders@primary \[id shipment\]
INSERT INTO "user content"."customer reviews" (id, product, body, shipment, "order") VALUES (4, '780', 'i ordered 101 of them', 9, 1)

statement ok
ALTER TABLE delivery DROP CONSTRAINT fk_order_ref_orders

statement ok
TRUNCATE orders, "user content"."customer reviews"

# Changing now non-referenced and secondary field is fine.
statement ok
UPDATE products SET sku = '750', vendor = 'roomba' WHERE sku = '780'

# Changing PK and referenced secondary index is not ok.
statement error pgcode 23503 foreign key violation: values \['885155001450'\] in columns \[upc\] referenced in table "delivery"
UPDATE products SET sku = '780', upc = 'blah' WHERE sku = '750'

statement error pgcode 23503 foreign key violation: values \['885155001450'\] in columns \[upc\] referenced in table "delivery"
DELETE FROM products WHERE sku = '750'

statement error "products" is referenced by foreign key from table "orders"
TRUNCATE products

query I
SELECT count(*) FROM delivery
----
4

statement ok
TRUNCATE products CASCADE

query I
SELECT count(*) FROM delivery
----
0

statement ok
TRUNCATE delivery, products, orders, "user content"."customer reviews"

query TTTTB colnames
SHOW CONSTRAINTS FROM orders
----
table_name  constraint_name          constraint_type  details                                                                               validated
orders      fk_product_ref_products  FOREIGN KEY      FOREIGN KEY (product) REFERENCES products(sku) ON DELETE RESTRICT ON UPDATE RESTRICT  true
orders      primary                  PRIMARY KEY      PRIMARY KEY (id ASC, shipment ASC)                                                    true
orders      valid_customer           FOREIGN KEY      FOREIGN KEY (customer) REFERENCES customers(id)                                       true

statement error pq: index "products_upc_key" is in use as unique constraint
DROP INDEX products@products_upc_key

statement error pq: index "products_upc_key" is in use as unique constraint
DROP INDEX products@products_upc_key RESTRICT

statement error "products_upc_key" is referenced by foreign key from table "delivery"
ALTER TABLE products DROP COLUMN upc

statement ok
ALTER TABLE delivery DROP COLUMN "item"

statement ok
DROP INDEX products@products_upc_key CASCADE

statement error index "orders_product_idx" is in use as a foreign key constraint
DROP INDEX orders@orders_product_idx

statement error index "orders_product_idx" is in use as a foreign key constraint
DROP INDEX orders@orders_product_idx RESTRICT

statement error "products" is referenced by foreign key from table "orders"
DROP TABLE products

statement error referenced by foreign key from table "orders"
DROP TABLE products RESTRICT

statement error referenced by foreign key from table "customer reviews"
DROP TABLE orders

# reviews has a multi-col FK in which dropping one col is not allowed.
statement error column "order" is referenced by existing index "customer reviews_auto_index_orderfk"
ALTER TABLE "user content"."customer reviews" DROP COLUMN "order"

statement ok
ALTER TABLE "user content"."customer reviews" DROP COLUMN "order" CASCADE

statement ok
DROP TABLE "user content"."customer reviews"

statement ok
DROP TABLE orders

statement ok
DROP TABLE products

statement ok
CREATE TABLE parent (id int primary key)

statement ok
CREATE TABLE child (id INT PRIMARY KEY, parent_id INT UNIQUE REFERENCES parent)

statement ok
CREATE TABLE grandchild (id INT PRIMARY KEY, parent_id INT REFERENCES child (parent_id), INDEX (parent_id))

statement error "parent" is referenced by foreign key from table "child"
DROP TABLE parent

statement error "child" is referenced by foreign key from table "grandchild"
DROP TABLE child

statement error pgcode 23503 foreign key violation
INSERT INTO child VALUES (2, 2)

statement ok
DROP TABLE parent CASCADE

statement ok
INSERT INTO child VALUES (2, 2)

statement error pgcode 23503 foreign key violation
INSERT INTO grandchild VALUES (1, 1)

statement error in use as a foreign key constraint
DROP INDEX grandchild@grandchild_parent_id_idx

statement ok
DROP INDEX grandchild@grandchild_parent_id_idx CASCADE

statement ok
INSERT INTO grandchild VALUES (1, 1)

statement ok
DROP TABLE grandchild

statement ok
CREATE TABLE grandchild (id INT PRIMARY KEY, parent_id INT REFERENCES child (parent_id), INDEX (parent_id))

statement error pgcode 23503 foreign key violation
INSERT INTO grandchild VALUES (1, 1)

statement error pq: index "child_parent_id_key" is in use as unique constraint
DROP INDEX child@child_parent_id_key

statement ok
DROP INDEX child@child_parent_id_key CASCADE

statement ok
INSERT INTO grandchild VALUES (1, 1)

statement ok
CREATE TABLE employees (id INT PRIMARY KEY, manager INT REFERENCES employees, INDEX (manager))

statement ok
INSERT INTO employees VALUES (1, NULL)

statement ok
INSERT INTO employees VALUES (2, 1), (3, 1)

statement ok
INSERT INTO employees VALUES (4, 2), (5, 3)

statement error pgcode 23503 foreign key violation
DELETE FROM employees WHERE id = 2

statement error pgcode 23503 foreign key violation
DELETE FROM employees WHERE id > 1

statement ok
DROP TABLE employees

statement ok
CREATE TABLE pairs (id INT PRIMARY KEY, src INT, dest STRING, UNIQUE (src, dest))

statement ok
INSERT INTO pairs VALUES (1, 100, 'one'), (2, 200, 'two')

statement error type of "b" \(string\) does not match foreign key "pairs"."id" \(int\)
CREATE TABLE refpairs (a INT, b STRING, CONSTRAINT fk FOREIGN KEY (b) REFERENCES pairs)

statement error 2 columns must reference exactly 2 columns in referenced table \(found 1\)
CREATE TABLE refpairs (a INT, b STRING, CONSTRAINT fk FOREIGN KEY (a, b) REFERENCES pairs)

# TODO(dt): remove ordering constraint on matching index
statement ok
CREATE TABLE refpairs_wrong_order (
  a INT,
  b STRING,
  FOREIGN KEY (a, b) REFERENCES pairs (src, dest),
  INDEX (b, a)
)

query TTBITTBB colnames
SHOW INDEXES FROM refpairs_wrong_order
----
table_name            index_name                                      non_unique  seq_in_index  column_name  direction  storing  implicit
refpairs_wrong_order  primary                                         false       1             rowid        ASC        false    false
refpairs_wrong_order  refpairs_wrong_order_b_a_idx                    true        1             b            ASC        false    false
refpairs_wrong_order  refpairs_wrong_order_b_a_idx                    true        2             a            ASC        false    false
refpairs_wrong_order  refpairs_wrong_order_b_a_idx                    true        3             rowid        ASC        false    true
refpairs_wrong_order  refpairs_wrong_order_auto_index_fk_a_ref_pairs  true        1             a            ASC        false    false
refpairs_wrong_order  refpairs_wrong_order_auto_index_fk_a_ref_pairs  true        2             b            ASC        false    false
refpairs_wrong_order  refpairs_wrong_order_auto_index_fk_a_ref_pairs  true        3             rowid        ASC        false    true

statement ok
CREATE TABLE refpairs_c_between (a INT, b STRING, c INT, FOREIGN KEY (a, b) REFERENCES pairs (src, dest), INDEX (a, c, b))

query TTBITTBB colnames
SHOW INDEXES FROM refpairs_c_between
----
table_name          index_name                                    non_unique  seq_in_index  column_name  direction  storing  implicit
refpairs_c_between  primary                                       false       1             rowid        ASC        false    false
refpairs_c_between  refpairs_c_between_a_c_b_idx                  true        1             a            ASC        false    false
refpairs_c_between  refpairs_c_between_a_c_b_idx                  true        2             c            ASC        false    false
refpairs_c_between  refpairs_c_between_a_c_b_idx                  true        3             b            ASC        false    false
refpairs_c_between  refpairs_c_between_a_c_b_idx                  true        4             rowid        ASC        false    true
refpairs_c_between  refpairs_c_between_auto_index_fk_a_ref_pairs  true        1             a            ASC        false    false
refpairs_c_between  refpairs_c_between_auto_index_fk_a_ref_pairs  true        2             b            ASC        false    false
refpairs_c_between  refpairs_c_between_auto_index_fk_a_ref_pairs  true        3             rowid        ASC        false    true

statement ok
CREATE TABLE refpairs (
  a INT,
  b STRING,
  c INT,
  FOREIGN KEY (a, b) REFERENCES pairs (src, dest) ON UPDATE RESTRICT,
  INDEX (a, b, c),
  FAMILY "primary" (a, b, c, rowid)
)

query TTBITTBB colnames
SHOW INDEXES FROM refpairs
----
table_name  index_name          non_unique  seq_in_index  column_name  direction  storing  implicit
refpairs    primary             false       1             rowid        ASC        false    false
refpairs    refpairs_a_b_c_idx  true        1             a            ASC        false    false
refpairs    refpairs_a_b_c_idx  true        2             b            ASC        false    false
refpairs    refpairs_a_b_c_idx  true        3             c            ASC        false    false
refpairs    refpairs_a_b_c_idx  true        4             rowid        ASC        false    true

query TT
SHOW CREATE TABLE refpairs
----
refpairs  CREATE TABLE refpairs (
          a INT8 NULL,
          b STRING NULL,
          c INT8 NULL,
          CONSTRAINT fk_a_ref_pairs FOREIGN KEY (a, b) REFERENCES pairs(src, dest) ON UPDATE RESTRICT,
          INDEX refpairs_a_b_c_idx (a ASC, b ASC, c ASC),
          FAMILY "primary" (a, b, c, rowid)
)

statement error pgcode 23503 foreign key violation: value \[100 'two'\] not found in pairs@pairs_src_dest_key \[src dest\]
INSERT INTO refpairs VALUES (100, 'two'), (200, 'two')

statement ok
INSERT INTO refpairs VALUES (100, 'one', 3), (200, 'two', null)

statement error pgcode 23503 foreign key violation: values \[200 'two'\] in columns \[src dest\] referenced in table "refpairs"
UPDATE pairs SET dest = 'too' WHERE id = 2

statement error pgcode 23503 foreign key violation: values \[200 'two'\] in columns \[src dest\] referenced in table "refpairs"
DELETE FROM pairs WHERE id = 2

statement error pgcode 23503 foreign key violation: values \[100 'one'\] in columns \[src dest\] referenced in table "refpairs"
DELETE FROM pairs WHERE id = 1

statement error foreign key violation: values \[100 'one'\] in columns \[src dest\] referenced in table "refpairs"
SET tracing = on,kv; DELETE FROM pairs WHERE id = 1

statement ok
SET tracing=off

# Test that fk scans on indexes that are longer than the foreign key use
# PrefixEnd instead of interleave end.
query T rowsort
SELECT message FROM [SHOW KV TRACE FOR SESSION]
WHERE message LIKE 'FKScan%'
----
FKScan /Table/84/3/100/"one"{-/#}
FKScan /Table/85/3/100/"one"{-/#}
FKScan /Table/86/2/100/"one"{-/PrefixEnd}

# since PKs are handled differently than other indexes, check pk<->pk ref with no other indexes in play.
statement ok
CREATE TABLE foo (id INT PRIMARY KEY)

statement ok
CREATE TABLE bar (id INT PRIMARY KEY REFERENCES foo)

statement ok
INSERT INTO foo VALUES (2)

statement ok
INSERT INTO bar VALUES (2)

statement error pgcode 23503 foreign key violation: values \[2] in columns \[id\] referenced in table "bar"
DELETE FROM foo

statement ok
CREATE DATABASE otherdb

statement ok
CREATE TABLE otherdb.othertable (id INT PRIMARY KEY)

statement ok
CREATE TABLE crossdb (id INT PRIMARY KEY, FOREIGN KEY (id) REFERENCES otherdb.othertable)

statement error pgcode 23503 foreign key violation: value \[2\] not found in othertable@primary \[id\]
INSERT INTO crossdb VALUES (2)

statement ok
INSERT INTO otherdb.othertable VALUES (1), (2)

statement ok
INSERT INTO crossdb VALUES (2)

statement error pgcode 23503 foreign key violation: values \[2] in columns \[id\] referenced in table "crossdb"
DELETE FROM otherdb.othertable WHERE id = 2

statement error "othertable" is referenced by foreign key from table "crossdb"
DROP TABLE otherdb.othertable

statement ok
DROP TABLE otherdb.othertable, crossdb

statement ok
CREATE TABLE modules (id BIGSERIAL NOT NULL PRIMARY KEY)

statement ok
CREATE TABLE domains (id BIGSERIAL NOT NULL PRIMARY KEY)

# We'll use the unique index for the domain fk (since it is a prefix), but we
# we correctly only mark the prefix as used and thus still allow module_id to be
# used in another FK.
statement ok
CREATE TABLE domain_modules (
  id         BIGSERIAL    NOT NULL PRIMARY KEY,
  domain_id  BIGINT       NOT NULL,
  module_id  BIGINT       NOT NULL,
  CONSTRAINT domain_modules_domain_id_fk FOREIGN KEY (domain_id) REFERENCES domains (id),
  CONSTRAINT domain_modules_module_id_fk FOREIGN KEY (module_id) REFERENCES modules (id),
  CONSTRAINT domain_modules_uq UNIQUE (domain_id, module_id)
)

query TTTTB
SHOW CONSTRAINTS FROM domain_modules
----
domain_modules  domain_modules_domain_id_fk  FOREIGN KEY  FOREIGN KEY (domain_id) REFERENCES domains(id)  true
domain_modules  domain_modules_module_id_fk  FOREIGN KEY  FOREIGN KEY (module_id) REFERENCES modules(id)  true
domain_modules  domain_modules_uq            UNIQUE       UNIQUE (domain_id ASC, module_id ASC)           true
domain_modules  primary                      PRIMARY KEY  PRIMARY KEY (id ASC)                            true

statement ok
INSERT INTO modules VALUES(3)

statement error foreign key violation: value \[2\] not found in domains@primary
SET tracing = on,kv; INSERT INTO domain_modules VALUES (1, 2, 3)

statement ok
SET tracing=off

query T rowsort
SELECT message FROM [SHOW KV TRACE FOR SESSION]
WHERE message LIKE 'FKScan%'
----
FKScan /Table/93/1/2{-/#}
FKScan /Table/92/1/3{-/#}

statement ok
CREATE TABLE tx (
  id INT NOT NULL PRIMARY KEY
)

statement ok
CREATE TABLE tx_leg (
  leg_id SERIAL NOT NULL PRIMARY KEY,
  tx_id INT NOT NULL REFERENCES tx
)

statement ok
BEGIN TRANSACTION

statement ok
INSERT INTO tx VALUES (2)

statement ok
INSERT INTO tx_leg VALUES (201, 2);

statement ok
INSERT INTO tx_leg VALUES (202, 2);

statement ok
COMMIT

statement ok
BEGIN TRANSACTION

statement error pgcode 23503 foreign key violation: value \[3\] not found in tx@primary \[id\]
INSERT INTO tx_leg VALUES (302, 3);

statement ok
COMMIT

statement ok
CREATE TABLE a (id SERIAL NOT NULL, self_id INT, b_id INT NOT NULL, PRIMARY KEY (id))

statement ok
CREATE TABLE b (id SERIAL NOT NULL, PRIMARY KEY (id))

# The index needed for the fk constraint is automatically added because the table is empty
statement ok
ALTER TABLE a ADD CONSTRAINT fk_self_id FOREIGN KEY (self_id) REFERENCES a;

# The index needed for the fk constraint is automatically added because the table is empty
statement ok
ALTER TABLE a ADD CONSTRAINT fk_b FOREIGN KEY (b_id) REFERENCES b;

statement ok
INSERT INTO b VALUES (1), (2), (3);

statement ok
INSERT INTO a VALUES (1, NULL, 1)

statement ok
INSERT INTO a VALUES (2, 1, 1), (3, 1, 2)

statement ok
INSERT INTO a VALUES (4, 2, 2)

statement ok
DELETE FROM b WHERE id = 3

statement error pgcode 23503 foreign key violation
DELETE FROM b WHERE id = 2

statement error pgcode 23503 foreign key violation
DELETE FROM a WHERE id = 1

statement ok
DELETE FROM a WHERE id > 2

statement ok
DELETE FROM b WHERE id = 2

statement ok
DROP TABLE a

statement ok
DROP TABLE b

# A CREATE TABLE with a FK reference within a transaction.
statement ok
CREATE TABLE referee (id INT PRIMARY KEY);

statement ok
BEGIN TRANSACTION

statement ok
CREATE TABLE refers (
  a INT REFERENCES referee,
  b INT,
  INDEX b_idx (b),
  FAMILY "primary" (a, b, rowid)
)

# Add some schema changes within the same transaction to verify that a
# table that isn't yet public can be modified.
statement ok
CREATE INDEX foo ON refers (a)

statement ok
ALTER INDEX refers@b_idx RENAME TO another_idx

query TT
SHOW CREATE TABLE refers
----
refers  CREATE TABLE refers (
        a INT8 NULL,
        b INT8 NULL,
        CONSTRAINT fk_a_ref_referee FOREIGN KEY (a) REFERENCES referee(id),
        INDEX another_idx (b ASC),
        INDEX refers_auto_index_fk_a_ref_referee (a ASC),
        INDEX foo (a ASC),
        FAMILY "primary" (a, b, rowid)
)

statement ok
DROP INDEX refers@another_idx

# refers is not visible because it is in the ADD state.
query TTT
SHOW TABLES FROM test
----
public  bar                   table
public  child                 table
public  customers             table
public  delivery              table
public  domain_modules        table
public  domains               table
public  foo                   table
public  grandchild            table
public  modules               table
public  pairs                 table
public  referee               table
public  refpairs              table
public  refpairs_c_between    table
public  refpairs_wrong_order  table
public  tx                    table
public  tx_leg                table
public  unindexed             table

statement ok
COMMIT

# CREATE AND DROP a table with a fk in the same transaction.
statement ok
BEGIN TRANSACTION

statement ok
CREATE TABLE refers1 (a INT REFERENCES referee);

statement ok
DROP TABLE refers1

statement ok
COMMIT

# Check that removing self-ref FK correctly removed backref too, #16070.
statement ok
CREATE TABLE employee (
   id INT PRIMARY KEY,
   manager INT,
   UNIQUE (manager)
);

statement ok
ALTER TABLE employee
   ADD CONSTRAINT emp_emp
   FOREIGN KEY (manager)
   REFERENCES employee;

statement ok
ALTER TABLE employee
   DROP CONSTRAINT emp_emp;

statement ok
SHOW CREATE TABLE employee;

# Ensure that tables with an fk reference from their pk appear correctly in
# SHOW CREATE TABLE (#17596).
statement ok
CREATE TABLE pkref_a (a INT PRIMARY KEY)

statement ok
CREATE TABLE pkref_b (b INT PRIMARY KEY REFERENCES pkref_a ON UPDATE NO ACTION ON DELETE RESTRICT)

query TT
SHOW CREATE TABLE pkref_b
----
pkref_b  CREATE TABLE pkref_b (
         b INT8 NOT NULL,
         CONSTRAINT "primary" PRIMARY KEY (b ASC),
         CONSTRAINT fk_b_ref_pkref_a FOREIGN KEY (b) REFERENCES pkref_a(a) ON DELETE RESTRICT,
         FAMILY "primary" (b)
)

subtest 20042

statement ok
CREATE TABLE test20042 (
  x STRING PRIMARY KEY
 ,y STRING UNIQUE
 ,z STRING REFERENCES test20042(y)
);

statement ok
INSERT INTO test20042 (x, y, z) VALUES ('pk1', 'k1', null);

statement ok
INSERT INTO test20042 (x, y, z) VALUES ('pk2', 'k2 ', 'k1');

statement ok
DELETE FROM test20042 WHERE x = 'pk2';

statement ok
DELETE FROM test20042 WHERE x = 'pk1';

subtest 20045

statement ok
CREATE TABLE test20045 (
  x STRING PRIMARY KEY
 ,y STRING UNIQUE REFERENCES test20045(x)
 ,z STRING REFERENCES test20045(y)
);

statement ok
INSERT INTO test20045 (x, y, z) VALUES ('pk1', NULL, NULL);

statement ok
INSERT INTO test20045 (x, y, z) VALUES ('pk2', 'pk1', NULL);

statement ok
INSERT INTO test20045 (x, y, z) VALUES ('pk3', 'pk2', 'pk1');

statement ok
DELETE FROM test20045 WHERE x = 'pk3';

statement ok
DELETE FROM test20045 WHERE x = 'pk2';

statement ok
DELETE FROM test20045 WHERE x = 'pk1';

## Delete cascade without privileges

statement ok
CREATE DATABASE d;

statement ok
CREATE TABLE d.a (
  id STRING PRIMARY KEY
);

statement ok
CREATE TABLE d.b (
  id STRING PRIMARY KEY
 ,a_id STRING REFERENCES d.a ON DELETE CASCADE
);

statement ok
INSERT INTO d.a VALUES ('a1');

statement ok
INSERT INTO d.b VALUES ('b1', 'a1');

statement ok
GRANT ALL ON DATABASE d TO testuser;

statement ok
GRANT ALL ON d.a TO testuser;

user testuser

statement error user testuser does not have SELECT privilege on relation b
DELETE FROM d.a WHERE id = 'a1';

user root

statement ok
GRANT SELECT ON d.b TO testuser;

user testuser

statement error user testuser does not have DELETE privilege on relation b
DELETE FROM d.a WHERE id = 'a1';

user root

statement ok
GRANT DELETE ON d.b TO testuser;

user testuser

statement ok
DELETE FROM d.a WHERE id = 'a1';

user root

# Clean up after the test.
statement ok
DROP DATABASE d CASCADE;

subtest setNullWithNotNullConstraint
### Make sure that one cannot add a set null action on a NOT NULL column.

statement ok
CREATE TABLE a (
  id INT PRIMARY KEY
);

# Create a table with a NOT NULL column and a SET NULL action.
statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.delete_not_nullable" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,delete_not_nullable INT NOT NULL REFERENCES a ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.update_not_nullable" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,update_not_nullable INT NOT NULL REFERENCES a ON UPDATE SET NULL
);

# Create a table where the primary key has a SET NULL action.
statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  id INT PRIMARY KEY REFERENCES a ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  id INT PRIMARY KEY REFERENCES a ON UPDATE SET NULL
);

# Add a SET NULL action after the fact with a NOT NULL column.
statement ok
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,delete_not_nullable INT NOT NULL
 ,update_not_nullable INT NOT NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.delete_not_nullable" which has a NOT NULL constraint
ALTER TABLE not_null_table ADD CONSTRAINT not_null_delete_set_null
  FOREIGN KEY (delete_not_nullable) REFERENCES a (id)
  ON DELETE SET NULL;

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.update_not_nullable" which has a NOT NULL constraint
ALTER TABLE not_null_table ADD CONSTRAINT not_null_update_set_null
  FOREIGN KEY (update_not_nullable) REFERENCES a (id)
  ON UPDATE SET NULL;

# Clean up so far,
statement ok
DROP TABLE not_null_table;

# Add a SET NULL action after the fact with a primary key column.
statement ok
CREATE TABLE primary_key_table (
  id INT PRIMARY KEY
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint
ALTER TABLE primary_key_table ADD CONSTRAINT not_null_set_null
  FOREIGN KEY (id) REFERENCES a (id)
  ON DELETE SET NULL;

statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint
ALTER TABLE primary_key_table ADD CONSTRAINT not_null_set_null
  FOREIGN KEY (id) REFERENCES a (id)
  ON UPDATE SET NULL;

# Clean up the tables used so far.
statement ok
DROP TABLE primary_key_table, a;

# Now test composite foreign keys
statement ok
CREATE TABLE a (
  id1 INT
 ,id2 INT
 ,PRIMARY KEY (id2, id1)
);

# Create a table with a NOT NULL column and a SET NULL action.
statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref1" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT NOT NULL
 ,ref2 INT NOT NULL
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref1" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT NOT NULL
 ,ref2 INT NOT NULL
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref1" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT NOT NULL
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref1" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT NOT NULL
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref2" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT NOT NULL
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.not_null_table.ref2" which has a NOT NULL constraint
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT NOT NULL
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET NULL
);

# Create a table where the primary key has a SET NULL action.
statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.ref1" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  ref1 INT
 ,ref2 INT
 ,PRIMARY KEY (ref2, ref1)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET NULL
);

# Create a table where the primary key has a SET NULL action.
statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.ref1" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  ref1 INT
 ,ref2 INT
 ,PRIMARY KEY (ref2, ref1)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.ref2" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  ref1 INT
 ,ref2 INT
 ,PRIMARY KEY (ref2, ref1)
 ,FOREIGN KEY (ref2, ref1) REFERENCES a (id2, id1) ON DELETE SET NULL
);

statement error pq: cannot add a SET NULL cascading action on column "test.public.primary_key_table.ref2" which has a NOT NULL constraint
CREATE TABLE primary_key_table (
  ref1 INT
 ,ref2 INT
 ,PRIMARY KEY (ref2, ref1)
 ,FOREIGN KEY (ref2, ref1) REFERENCES a (id2, id1) ON UPDATE SET NULL
);

# Clean up after the test.
statement ok
DROP TABLE a;

subtest setDefaultWithoutDefault
### Make sure that one cannot add a SET DEFAULT action with no default values
### on a column.

statement ok
CREATE TABLE a (
  id INT PRIMARY KEY
);

# Create a table with no DEFAULT expressions column and a SET DEFAULT action.
statement ok
CREATE TABLE delete_no_default_table (
  id INT PRIMARY KEY
 ,delete_no_default INT REFERENCES a ON DELETE SET DEFAULT
);

statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.update_no_default_table.update_no_default" which has a NOT NULL constraint and a NULL default expression
CREATE TABLE update_no_default_table (
  id INT PRIMARY KEY
 ,update_no_default INT NOT NULL REFERENCES a ON UPDATE SET DEFAULT
);

# Create a table where the primary key has a SET DEFAULT action.
# Primary keys are not allowed to be NULL
statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.primary_key_table_set_default.id" which has a NOT NULL constraint and a NULL default expression
CREATE TABLE primary_key_table_set_default (
  id INT PRIMARY KEY REFERENCES a ON DELETE SET DEFAULT
);

statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint and a NULL default expression
CREATE TABLE primary_key_table (
  id INT PRIMARY KEY REFERENCES a ON UPDATE SET DEFAULT
);

# Add a SET DEFAULT action after the to a column with no DEFAULT expression.
statement ok
CREATE TABLE no_default_table (
  id INT PRIMARY KEY
 ,delete_no_default INT
 ,update_no_default INT
);

statement ok
ALTER TABLE no_default_table ADD CONSTRAINT no_default_delete_set_default
  FOREIGN KEY (delete_no_default) REFERENCES a (id)
  ON DELETE SET DEFAULT;

statement ok
ALTER TABLE no_default_table ADD CONSTRAINT no_default_update_set_default
  FOREIGN KEY (update_no_default) REFERENCES a (id)
  ON UPDATE SET DEFAULT;

# Clean up so far,
statement ok
DROP TABLE no_default_table;

# Add a SET DEFAULT action after the fact with a primary key column that has no
# DEFAULT expression.
statement ok
CREATE TABLE primary_key_table (
  id INT PRIMARY KEY
);

# id is a primary key and thus cannot be NULL
statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint and a NULL default expression
ALTER TABLE primary_key_table ADD CONSTRAINT no_default_delete_set_default
  FOREIGN KEY (id) REFERENCES a (id)
  ON DELETE SET DEFAULT;

statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.primary_key_table.id" which has a NOT NULL constraint and a NULL default expression
ALTER TABLE primary_key_table ADD CONSTRAINT no_default_update_set_default
  FOREIGN KEY (id) REFERENCES a (id)
  ON UPDATE SET DEFAULT;

# Clean up the tables used so far.
statement ok
DROP TABLE primary_key_table, delete_no_default_table, a;

# Now test composite foreign keys
statement ok
CREATE TABLE a (
  id1 INT
 ,id2 INT
 ,PRIMARY KEY (id2, id1)
);

# Create a table with a column without a DEFAULT expression and a SET DEFAULT action.
statement ok
CREATE TABLE no_default_table (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET DEFAULT
);

statement ok
INSERT INTO a VALUES (1, 2)

statement ok
INSERT INTO a VALUES (3, 4)

statement ok
INSERT INTO no_default_table VALUES (6, 2, 1)

query III colnames
SELECT * FROM no_default_table
----
id  ref1  ref2
6   2     1

statement ok
DELETE FROM a WHERE id1=1

query III colnames
SELECT * FROM no_default_table
----
id  ref1  ref2
6   NULL  NULL

statement ok
CREATE TABLE no_default_table_on_update (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET DEFAULT
);

statement ok
INSERT INTO no_default_table_on_update VALUES (0, 4, 3)

query III colnames
SELECT * FROM no_default_table_on_update
----
id  ref1  ref2
0   4     3

statement ok
UPDATE a SET id1=33, id2=44 WHERE id1=3;

query III colnames
SELECT * FROM no_default_table_on_update
----
id  ref1  ref2
0   NULL  NULL

statement ok
CREATE TABLE no_default_table_ref2_default_on_delete (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT DEFAULT 1
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET DEFAULT
);

statement ok
CREATE TABLE no_default_table_ref2_default_on_update (
  id INT PRIMARY KEY
 ,ref1 INT
 ,ref2 INT DEFAULT 1
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET DEFAULT
);

statement ok
CREATE TABLE no_default_table_ref1_default_on_delete (
  id INT PRIMARY KEY
 ,ref1 INT DEFAULT 1
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET DEFAULT
);

statement ok
CREATE TABLE no_default_table_ref1_default_on_update (
  id INT PRIMARY KEY
 ,ref1 INT DEFAULT 1
 ,ref2 INT
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON UPDATE SET DEFAULT
);

# Create a table with a NOT NULL column and a SET NULL action.
statement error pq: cannot add a SET DEFAULT cascading action on column "test.public.not_null_table.ref1" which has a NOT NULL constraint and a NULL default expression
CREATE TABLE not_null_table (
  id INT PRIMARY KEY
 ,ref1 INT NOT NULL
 ,ref2 INT NOT NULL
 ,INDEX (ref1, ref2)
 ,FOREIGN KEY (ref1, ref2) REFERENCES a (id2, id1) ON DELETE SET DEFAULT
);

# Clean up after the test.
statement ok
DROP TABLE a, no_default_table, no_default_table_on_update, no_default_table_ref2_default_on_delete,
no_default_table_ref2_default_on_update, no_default_table_ref1_default_on_delete,
no_default_table_ref1_default_on_update

subtest unvalidated_fk_plan

# To get an unvalidated foreign key for testing, use the loophole that we
# currently don't support adding a validated FK in the same transaction as
# CREATE TABLE

statement ok
CREATE TABLE a (
  x STRING NULL,
  y STRING NULL,
  z STRING NULL,
  CONSTRAINT "primary" PRIMARY KEY (z, y, x)
)

statement ok
CREATE TABLE b (
  a_y STRING NULL,
  a_x STRING NULL,
  a_z STRING NULL,
  INDEX idx (a_z, a_y, a_x)
)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y1', 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) NOT VALID

statement error pq: foreign key violation: "b" row a_z='z1', a_y='y1', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

# Verify that the optimizer doesn't use an unvalidated constraint to simplify plans.
query TTT
SELECT
  s.a_z, s.a_y, s.a_x
FROM
  (SELECT * FROM b WHERE a_z IS NOT NULL AND a_y IS NOT NULL AND a_x IS NOT NULL) AS s
  LEFT JOIN a AS t ON s.a_z = t.z AND s.a_y = t.y AND s.a_x = t.x
WHERE
  t.z IS NULL
----
z1 y1 x2

statement ok
DROP TABLE a, b

subtest Composite_Simple
# Originally from 26748.

# Test composite key with two columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (y, x)
);

statement ok
CREATE TABLE b (
 a_y STRING NULL
 ,a_x STRING NULL
 ,CONSTRAINT fk_ref FOREIGN KEY (a_y, a_x) REFERENCES a (y, x)
);

statement ok
INSERT INTO a (x, y) VALUES ('x1', 'y1')

# All of these are allowed because we do composite matching using MATCH SIMPLE.
statement ok
INSERT INTO b (a_x) VALUES ('x1')

statement ok
INSERT INTO b (a_y) VALUES ('y1')

statement ok
INSERT INTO b (a_y, a_x) VALUES ('y1', NULL)

statement ok
INSERT INTO b (a_y, a_x) VALUES (NULL, 'x1')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, NULL)

statement ok
DROP TABLE b, a

# Test composite key with three columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)
);

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# All of these are allowed because we do composite matching using MATCH SIMPLE.
statement ok
INSERT INTO b (a_x) VALUES ('x1')

statement ok
INSERT INTO b (a_y) VALUES ('y1')

statement ok
INSERT INTO b (a_z) VALUES ('z1')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', NULL)

statement ok
INSERT INTO b (a_x, a_z) VALUES ('x1', 'z1')

statement ok
INSERT INTO b (a_x, a_z) VALUES (NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_z) VALUES ('x1', NULL)

statement ok
INSERT INTO b (a_y, a_z) VALUES ('y1', 'z1')

statement ok
INSERT INTO b (a_y, a_z) VALUES (NULL, 'z1')

statement ok
INSERT INTO b (a_y, a_z) VALUES ('y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', 'z2')

statement ok
DROP TABLE b, a

subtest Composite_Simple_Add_Constraint_Valid
# Test ADD CONSTRAINT validation by inserting valid rows before the constraint is added.

statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,INDEX idx (a_z, a_y, a_x)
);

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# All of these are allowed because we do composite matching using MATCH SIMPLE.
statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', 'z2')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)

statement ok
DROP TABLE b, a

subtest Composite_Simple_Add_Constraint_Invalid
# Test ADD CONSTRAINT validation by inserting invalid rows before the constraint is added, one at a time.

statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,INDEX idx (a_z, a_y, a_x)
);

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y1', 'z1')

statement error foreign key violation: "b" row a_z='z1', a_y='y1', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z1')

statement error foreign key violation: "b" row a_z='z1', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z2')

statement error foreign key violation: "b" row a_z='z2', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)

statement ok
DROP TABLE b, a

subtest Composite_Simple_Unvalidated
# Test inserting into table with an unvalidated constraint, and running VALIDATE CONSTRAINT later

# Test composite key with two columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
);

# Add the constraint separately so that it's unvalidated, so we can test VALIDATE CONSTRAINT.
statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_y, a_x) REFERENCES a (y, x) NOT VALID

statement ok
INSERT INTO a (x, y) VALUES ('x1', 'y1')

# All of these are allowed because we do composite matching using MATCH SIMPLE.
statement ok
INSERT INTO b (a_x) VALUES ('x1')

statement ok
INSERT INTO b (a_y) VALUES ('y1')

statement ok
INSERT INTO b (a_y, a_x) VALUES ('y1', NULL)

statement ok
INSERT INTO b (a_y, a_x) VALUES (NULL, 'x1')

statement ok
INSERT INTO b (a_y, a_x) VALUES ('y2', NULL)

statement ok
INSERT INTO b (a_y, a_x) VALUES (NULL, 'x2')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, NULL)

statement ok
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
DROP TABLE b, a

# Test composite key with three columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
);

# Add the constraint separately so that it's unvalidated, so we can test VALIDATE CONSTRAINT.
statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) NOT VALID

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# All of these are allowed because we do composite matching using MATCH SIMPLE.
statement ok
INSERT INTO b (a_x) VALUES ('x1')

statement ok
INSERT INTO b (a_y) VALUES ('y1')

statement ok
INSERT INTO b (a_z) VALUES ('z1')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', NULL)

statement ok
INSERT INTO b (a_x, a_z) VALUES ('x1', 'z1')

statement ok
INSERT INTO b (a_x, a_z) VALUES (NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_z) VALUES ('x1', NULL)

statement ok
INSERT INTO b (a_y, a_z) VALUES ('y1', 'z1')

statement ok
INSERT INTO b (a_y, a_z) VALUES (NULL, 'z1')

statement ok
INSERT INTO b (a_y, a_z) VALUES ('y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', NULL)

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', NULL, 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y2', 'z2')

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
DROP TABLE b, a

#subtest Composite_Simple_Validate_Constraint_Invalid

subtest Composite_Full
# Originally from 26748.

# Test composite key with two columns.
statement ok
CREATE TABLE a (
  x STRING NULL,
  y STRING NULL,
  CONSTRAINT "primary" PRIMARY KEY (y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL,
  a_x STRING NULL
);

# Add the constraint separately so that it's unvalidated, so we can test VALIDATE CONSTRAINT.
statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_y, a_x) REFERENCES a (y, x) MATCH FULL NOT VALID

statement ok
INSERT INTO a (x, y) VALUES ('x1', 'y1')

# These statements should all fail because this uses MATCH FULL.
statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x) VALUES ('x1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y) VALUES ('y1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_y, a_x) VALUES ('y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_y, a_x) VALUES (NULL, 'x1')

# These next two statements should still be allowed.
statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, NULL)

statement ok
DROP TABLE b, a

# Test composite key with three columns.
statement ok
CREATE TABLE a (
  x STRING NULL,
  y STRING NULL,
  z STRING NULL,
  CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL,
  a_x STRING NULL,
  a_z STRING NULL
);

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# These statements should all fail because this uses MATCH FULL.
statement error missing values for columns \["a_y" "a_z"\] in multi-part foreign key
INSERT INTO b (a_x) VALUES ('x1')

statement error missing values for columns \["a_x" "a_z"\] in multi-part foreign key
INSERT INTO b (a_y) VALUES ('y1')

statement error missing values for columns \["a_x" "a_y"\] in multi-part foreign key
INSERT INTO b (a_z) VALUES ('z1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES (NULL, 'y1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES ('x1', NULL)

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES ('x1', 'z1')

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES (NULL, 'z1')

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES ('x1', NULL)

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES ('y1', 'z1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES (NULL, 'z1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES ('y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

# This statement should still be allowed.
statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
DROP TABLE b, a

subtest Composite_Full_Add_Constraint_Valid
# Test ADD CONSTRAINT validation by inserting valid rows before the constraint is added.

statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,INDEX idx (a_z, a_y, a_x)
);

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# This statement should still be allowed.
statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x)

statement ok
DROP TABLE b, a

subtest Composite_Full_Validate_Constraint_Invalid
# Test VALIDATE CONSTRAINT by inserting invalid rows before the constraint is added, one at a time.

statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,INDEX idx (a_z, a_y, a_x)
);

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y1', 'z1')

statement error foreign key violation: "b" row a_z='z1', a_y='y1', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z1')

statement error foreign key violation: "b" row a_z='z1', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
TRUNCATE b

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z2')

statement error foreign key violation: "b" row a_z='z2', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL

statement ok
DROP TABLE b, a

subtest Composite_Full_Validate_Later
# Test inserting into table with an unvalidated constraint, and running VALIDATE CONSTRAINT later

# Test composite key with two columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
);

# Add the constraint separately so that it's unvalidated, so we can test VALIDATE CONSTRAINT.
statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_y, a_x) REFERENCES a (y, x) MATCH FULL NOT VALID

statement ok
INSERT INTO a (x, y) VALUES ('x1', 'y1')

# These statements should all fail because this uses MATCH FULL.
statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x) VALUES ('x1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y) VALUES ('y1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_y, a_x) VALUES ('y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_y, a_x) VALUES (NULL, 'x1')

# These next two statements should still be allowed.
statement ok
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement ok
INSERT INTO b (a_x, a_y) VALUES (NULL, NULL)

statement ok
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
DROP TABLE b, a

# Test composite key with three columns.
statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
);

# Add the constraint separately so that it's unvalidated, so we can test VALIDATE CONSTRAINT.
statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement ok
INSERT INTO a (x, y, z) VALUES ('x1', 'y1', 'z1')

# These statements should all fail because this uses MATCH FULL.
statement error missing values for columns \["a_y" "a_z"\] in multi-part foreign key
INSERT INTO b (a_x) VALUES ('x1')

statement error missing values for columns \["a_x" "a_z"\] in multi-part foreign key
INSERT INTO b (a_y) VALUES ('y1')

statement error missing values for columns \["a_x" "a_y"\] in multi-part foreign key
INSERT INTO b (a_z) VALUES ('z1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES ('x1', 'y1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES (NULL, 'y1')

statement error missing value for column "a_z" in multi-part foreign key
INSERT INTO b (a_x, a_y) VALUES ('x1', NULL)

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES ('x1', 'z1')

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES (NULL, 'z1')

statement error missing value for column "a_y" in multi-part foreign key
INSERT INTO b (a_x, a_z) VALUES ('x1', NULL)

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES ('y1', 'z1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES (NULL, 'z1')

statement error missing value for column "a_x" in multi-part foreign key
INSERT INTO b (a_y, a_z) VALUES ('y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

# This statement should still be allowed.
statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, NULL)

statement ok
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
DROP TABLE b, a

subtest Composite_Full_Validate_Constraint_Invalid
# Test VALIDATE CONSTRAINT by inserting invalid rows before the constraint is added, one at a time.

statement ok
CREATE TABLE a (
  x STRING NULL
 ,y STRING NULL
 ,z STRING NULL
 ,CONSTRAINT "primary" PRIMARY KEY (z, y, x)
);

statement ok
CREATE TABLE b (
  a_y STRING NULL
 ,a_x STRING NULL
 ,a_z STRING NULL
 ,INDEX idx (a_z, a_y, a_x)
);

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, NULL)

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', NULL)

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, NULL, 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', 'y1', NULL)

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x1', NULL, 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES (NULL, 'y1', 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error foreign key violation: MATCH FULL does not allow mixing of null and nonnull values
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y1', 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error pq: foreign key violation: "b" row a_z='z1', a_y='y1', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z1')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error pq: foreign key violation: "b" row a_z='z1', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
TRUNCATE b

statement ok
ALTER TABLE b DROP CONSTRAINT fk_ref

statement ok
INSERT INTO b (a_x, a_y, a_z) VALUES ('x2', 'y2', 'z2')

statement ok
ALTER TABLE b ADD CONSTRAINT fk_ref FOREIGN KEY (a_z, a_y, a_x) REFERENCES a (z, y, x) MATCH FULL NOT VALID

statement error pq: foreign key violation: "b" row a_z='z2', a_y='y2', a_x='x2', rowid=[0-9]* has no match in "a"
ALTER TABLE b VALIDATE CONSTRAINT fk_ref

statement ok
DROP TABLE b, a

subtest auto_add_fk_with_composite_index_to_empty_table

statement ok
CREATE TABLE parent_composite_index (a_id INT NOT NULL, b_id INT NOT NULL, PRIMARY KEY (a_id, b_id))

statement ok
CREATE TABLE child_composite_index (id SERIAL NOT NULL, parent_a_id INT, parent_b_id INT, PRIMARY KEY (id))

# The (composite) index needed for the fk constraint is automatically added because the table is empty
statement ok
ALTER TABLE child_composite_index ADD CONSTRAINT fk_id FOREIGN KEY (parent_a_id, parent_b_id) REFERENCES parent_composite_index;

statement ok
INSERT INTO parent_composite_index VALUES (100, 200)

statement ok
INSERT INTO child_composite_index VALUES (1, 100, 200)

statement error foreign key violation: value \[100 300\] not found in parent_composite_index@primary \[a_id b_id\]
INSERT INTO child_composite_index VALUES (2, 100, 300)

statement ok
DROP TABLE child_composite_index, parent_composite_index

subtest auto_add_fk_to_nonempty_table_error

statement ok
CREATE TABLE nonempty_a (id SERIAL NOT NULL, self_id INT, b_id INT NOT NULL, PRIMARY KEY (id))

statement ok
CREATE TABLE nonempty_b (id SERIAL NOT NULL, PRIMARY KEY (id))

statement ok
INSERT INTO nonempty_b VALUES (1), (2), (3);

statement ok
INSERT INTO nonempty_a VALUES (1, NULL, 1)

# Fails because self_id is not indexed, and an index will not be automatically created because the table is nonempty
statement error foreign key requires an existing index on columns \("self_id"\)
ALTER TABLE nonempty_a ADD CONSTRAINT fk_self_id FOREIGN KEY (self_id) REFERENCES nonempty_a;

statement ok
CREATE INDEX ON nonempty_a (self_id)

# This now succeeds with the manually added index
statement ok
ALTER TABLE nonempty_a ADD CONSTRAINT fk_self_id FOREIGN KEY (self_id) REFERENCES nonempty_a;

# Fails because b_id is not indexed, and an index will not be automatically created because the table is nonempty
statement error foreign key requires an existing index on columns \("b_id"\)
ALTER TABLE nonempty_a ADD CONSTRAINT fk_b FOREIGN KEY (b_id) REFERENCES nonempty_b;

statement ok
CREATE INDEX ON nonempty_a (b_id)

# This now succeeds with the manually added index
statement ok
ALTER TABLE nonempty_a ADD CONSTRAINT fk_b FOREIGN KEY (b_id) REFERENCES nonempty_b;

statement ok
DROP TABLE nonempty_a, nonempty_b

subtest auto_add_fk_index_name_collision

statement ok
CREATE TABLE parent_name_collision (id SERIAL NOT NULL, PRIMARY KEY (id))

statement ok
CREATE TABLE child_name_collision (id SERIAL NOT NULL, parent_id INT, other_col INT)

statement ok
CREATE INDEX child_name_collision_auto_index_fk_id ON child_name_collision (other_col)

# Testing the unusual case where an index already exists that has the same name
# as the index to be auto-generated when adding a fk constraint to an empty
# table (but the existing index is not on the referencing column), in which
# case the ALTER TABLE will choose another unique name for the index.
statement ok
ALTER TABLE child_name_collision ADD CONSTRAINT fk_id FOREIGN KEY (parent_id) references parent_name_collision

subtest auto_add_fk_duplicate_cols_error

statement ok
CREATE TABLE parent (a_id INT, b_id INT, PRIMARY KEY (a_id, b_id))

statement ok
CREATE TABLE child_duplicate_cols (id INT, parent_id INT, PRIMARY KEY (id))

# The fk constraint is invalid because it has duplicate columns, so automatically adding the index fails
statement error index \"child_duplicate_cols_auto_index_fk\" contains duplicate column \"parent_id\"
ALTER TABLE child_duplicate_cols ADD CONSTRAINT fk FOREIGN KEY (parent_id, parent_id) references parent

statement ok
DROP TABLE parent, child_duplicate_cols

# Check that a FK cannot be added to a column being backfilled.
# If this behavior is changed you should create a test similar to
# TestCRUDWhileColumnBackfill to test that CRUD operations operating
# with FK relationships work correctly over NON NULL columns that
# are still being backfilled.
subtest cannot_add_fk_on_col_needing_backfill

statement ok
CREATE TABLE parentid (
    k INT NOT NULL PRIMARY KEY,
    v INT NOT NULL
);

statement ok
CREATE TABLE childid (
    id INT NOT NULL PRIMARY KEY
);

# Make tables non-empty.
statement ok
INSERT INTO parentid (k, v) VALUES (0, 1); INSERT INTO childid (id) VALUES (2);

statement error column \"id\" does not exist
BEGIN; ALTER TABLE parentid ADD id INT NOT NULL AS (k + 2) STORED; ALTER TABLE childid ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES parentid (id);

statement ok
ROLLBACK;

subtest dont_check_nulls
# Make sure that nulls are never checked while executing FK constraints.

statement ok
CREATE TABLE t1(x INT UNIQUE)

statement ok
INSERT INTO t1(x) VALUES (1), (null)

statement ok
CREATE TABLE t2(
  x INT REFERENCES t1(x)
)

statement ok
INSERT INTO t2(x) VALUES (1), (null)

statement ok
DELETE FROM t1 WHERE x IS NULL

statement ok
DROP TABLE t1, t2 CASCADE

subtest test_not_valid_fk

statement ok
CREATE TABLE person (id INT PRIMARY KEY, age INT, name STRING)

statement ok
CREATE TABLE pet (id INT PRIMARY KEY, name STRING)

statement ok
INSERT INTO pet VALUES (0, 'crookshanks')

statement error pq: foreign key violation: "pet" row id=0 has no match in "person"
ALTER TABLE pet ADD CONSTRAINT fk_constraint FOREIGN KEY (id) REFERENCES person (id)

statement ok
ALTER TABLE pet ADD CONSTRAINT fk_constraint FOREIGN KEY (id) REFERENCES person (id) NOT VALID

query TTTTB
SHOW CONSTRAINTS FROM pet
----
pet  fk_constraint  FOREIGN KEY  FOREIGN KEY (id) REFERENCES person(id)  false
pet  primary        PRIMARY KEY  PRIMARY KEY (id ASC)                    true

statement error pq: foreign key violation: "pet" row id=0 has no match in "person"
ALTER TABLE pet VALIDATE CONSTRAINT fk_constraint

statement ok
INSERT INTO person VALUES (0, 18, 'Hermione Granger')

statement ok
ALTER TABLE pet VALIDATE CONSTRAINT fk_constraint

query TTTTB
SHOW CONSTRAINTS FROM pet
----
pet  fk_constraint  FOREIGN KEY  FOREIGN KEY (id) REFERENCES person(id)  true
pet  primary        PRIMARY KEY  PRIMARY KEY (id ASC)                    true

statement ok
DROP TABLE person, pet

# Ensure FK semantics for temporary and persistent tables work correctly.
# Temporary tables can not create FK references to persistent tables, and
# persistent tables can not create FK references to temporary tables.

statement ok
SET experimental_enable_temp_tables = true

statement ok
CREATE TEMP TABLE a_temp(a INT PRIMARY KEY)

statement ok
CREATE TEMP TABLE b_temp(b INT, FOREIGN KEY(b) REFERENCES a_temp(a))

statement error pq: constraints on permanent tables may reference only permanent tables
CREATE TABLE a_persistent(a INT, FOREIGN KEY (a) REFERENCES a_temp(a))

statement ok
CREATE TABLE c_persistent(c INT PRIMARY KEY)

statement error pq: constraints on temporary tables may reference only temporary tables
CREATE TEMP TABLE c_temp(c INT, FOREIGN KEY (c) REFERENCES c_persistent(c))

# Test that when the foreign key is a primary index we only look up the primary
# family.
subtest families

statement ok
CREATE TABLE fam_parent (
  k INT PRIMARY KEY,
  a INT,
  b INT NOT NULL,
  FAMILY (k, a),
  FAMILY (b)
)

statement ok
CREATE TABLE fam_child (
  k INT PRIMARY KEY,
  fk INT REFERENCES fam_parent(k)
)

statement ok
INSERT INTO fam_parent VALUES (1, 1, 1)

statement ok
GRANT ALL ON fam_parent TO testuser;
GRANT ALL ON fam_child TO testuser;

# Open a transaction that modifies b.
statement ok
BEGIN

statement count 1
UPDATE fam_parent SET b = b+1 WHERE k = 1

user testuser

# Run an INSERT which needs to check existence of the row. If we try to scan
# the entire row, this blocks on the other transaction. We should only be
# scanning the primary column family. A critical reason why this works is
# because column b is NOT NULL, so the UPDATE statement does not read or 
# acquire FOR UPDATE locks on the primary column family because a lookup
# on b's column family is enough to determine whether the row exists or not.
statement ok
INSERT INTO fam_child VALUES (1, 1)

user root

statement ok
COMMIT

# Regression test for #42498: MATCH FULL validation should work when columns in
# a composite FK reference have different types.
subtest 42498_match_full_mixed_types

statement ok
CREATE TABLE table1_42498 (col1 REGPROC NOT NULL, col2 DATE NOT NULL)

statement ok
CREATE TABLE table2_42498 (col3 REGPROC NOT NULL, col4 DATE NOT NULL, UNIQUE (col4, col3))

statement ok
ALTER TABLE table1_42498 ADD FOREIGN KEY (col2, col1) REFERENCES table2_42498 (col4, col3) MATCH FULL

statement ok
DROP TABLE table1_42498, table2_42498 CASCADE

# Regression test for #42680: The unique index used for the referenced columns
# must index only those columns and no others, in order to enforce uniqueness
# for the FK constraint.
subtest 42680_unique_index_must_exactly_match_columns

# The table has a unique index on (a, b) but not (a).
statement ok
CREATE TABLE target (a INT, b INT, UNIQUE INDEX (a, b));

statement ok
CREATE TABLE source (a INT, INDEX (a));

statement error there is no unique constraint matching given keys for referenced table target
ALTER TABLE source ADD FOREIGN KEY (a) REFERENCES target (a);

subtest foreign_key_multiple_key_references

# Create a recursive table: messages refs good_users refs users.
# Sometimes, messages refs users directly.

statement ok
CREATE TABLE users (
  id INTEGER PRIMARY KEY
)

statement ok
CREATE TABLE good_users (
  id INTEGER PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
  id2 INTEGER UNIQUE
)

statement ok
CREATE SEQUENCE message_seq START 1 INCREMENT 1

statement ok
CREATE TABLE messages (
  message_id INT PRIMARY KEY DEFAULT nextval('message_seq'),
  user_id_1 integer REFERENCES good_users(id) ON DELETE CASCADE ON UPDATE CASCADE,
  user_id_2 integer REFERENCES good_users(id) ON DELETE CASCADE ON UPDATE CASCADE, -- this is recursive through good_users
  text string
)

# Add the same foreign key twice onto user.
statement ok
ALTER TABLE messages ADD FOREIGN KEY (user_id_1) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE

statement ok
ALTER TABLE messages ADD FOREIGN KEY (user_id_1) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE

# Insert some rows
statement ok
INSERT INTO users(id) VALUES (1), (2), (3)

statement ok
INSERT INTO good_users(id, id2) VALUES (1, 10), (2, 20), (3, 30)

statement ok
INSERT INTO messages (user_id_1, user_id_2, text) VALUES
  (1, 2, 'hi jordan'),
  (2, 1, 'hi oliver'),
  (1, 2, 'you are a good user jordan'),
  (1, 3, 'you are a good user too rohan'),
  (3, 1, 'lucy is a good user')

query error 999.*good_users
INSERT INTO messages (user_id_1, user_id_2, text) VALUES
  (999, 1, 'you are a bad user')

# Now try and update the user_id.
statement ok
update users set id = id * 10

# See that it propagates.
query I
SELECT * FROM users ORDER BY id ASC
----
10
20
30

query II
SELECT * FROM good_users ORDER BY id ASC
----
10  10
20  20
30  30

query IIIT
SELECT * FROM messages ORDER BY message_id ASC
----
1  10  20  hi jordan
2  20  10  hi oliver
3  10  20  you are a good user jordan
4  10  30  you are a good user too rohan
5  30  10  lucy is a good user

# Delete from users should work as well
statement ok
DELETE FROM users WHERE id = 30

# See that it propagates.
query I
SELECT * FROM users ORDER BY id ASC
----
10
20

query II
SELECT * FROM good_users ORDER BY id ASC
----
10  10
20  20

query IIIT
SELECT * FROM messages ORDER BY message_id ASC
----
1  10  20  hi jordan
2  20  10  hi oliver
3  10  20  you are a good user jordan

# Add a foreign key on id2, which is a different column.
# This one is restrictive on updates and deletes.
statement ok
ALTER TABLE messages ADD FOREIGN KEY (user_id_1) REFERENCES good_users(id2)

statement ok
ALTER TABLE good_users ADD FOREIGN KEY (id2) REFERENCES users(id)

# Updating should no longer work, since we have a restrict.
statement error value \[2000\] not found in good_users@good_users_id2_key \[id2\]
UPDATE users SET id = id * 100 WHERE id = 20

# Insert some more stuff -- make sure it still behaves as expected.
statement ok
INSERT INTO users VALUES (40)

statement ok
INSERT INTO good_users VALUES (40, 40)

statement ok
INSERT INTO messages (user_id_1, user_id_2, text) VALUES
  (10, 40, 'oh hi mark'),
  (40, 10, 'youre tearing me apart lisa!')

query error 999.*good_users
INSERT INTO messages (user_id_1, user_id_2, text) VALUES
  (999, 40, 'johnny is my best friend')

# And sanity check everything.
query IIIT
SELECT * FROM messages ORDER BY message_id ASC
----
1  10  20  hi jordan
2  20  10  hi oliver
3  10  20  you are a good user jordan
7  10  40  oh hi mark
8  40  10  youre tearing me apart lisa!

# Delete should still be okay since the cascade from id1 should "win".
statement ok
DELETE FROM users WHERE id = 20

query IIIT
SELECT * FROM messages ORDER BY message_id ASC
----
7  10  40  oh hi mark
8  40  10  youre tearing me apart lisa!

# Drop everything.
statement ok
DROP TABLE users CASCADE

statement ok
DROP TABLE good_users CASCADE

statement ok
DROP TABLE messages

# Test conflicting foreign keys ON DELETE and ON UPDATE - some known corner cases.
# SET NULL/SET DEFAULT/CASCADE have priority and are evaluated in order, followed
# by RESTRICT/NO ACTION.

#
# ON DELETE
#

statement ok
CREATE TABLE t1 (a INT PRIMARY KEY); CREATE TABLE t2 (a INT DEFAULT 1)

# 'ON DELETE NO ACTION', followed by 'ON DELETE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE NO ACTION; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE NO ACTION', followed by 'ON DELETE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE NO ACTION; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE RESTRICT', followed by 'ON DELETE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE RESTRICT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE RESTRICT', followed by 'ON DELETE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE RESTRICT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE CASCADE', followed by 'ON DELETE SET DEFAULT'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE CASCADE; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET DEFAULT

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE CASCADE', followed by 'ON DELETE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE CASCADE; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE SET DEFAULT', followed by 'ON DELETE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET DEFAULT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement error value \[1\] not found in t1@primary \[a\]
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----
123

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE SET DEFAULT', followed by 'ON DELETE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET DEFAULT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement error value \[1\] not found in t1@primary \[a\]
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----
123

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON DELETE SET NULL', followed by 'ON DELETE SET DEFAULT'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET NULL; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON DELETE SET DEFAULT

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
DELETE FROM t1 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

statement ok
DROP TABLE t2 CASCADE; DROP TABLE t1 CASCADE

#
# ON UPDATE
#

statement ok
CREATE TABLE t1 (a INT PRIMARY KEY); CREATE TABLE t2 (a INT DEFAULT 1)

# 'ON UPDATE NO ACTION', followed by 'ON UPDATE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE NO ACTION; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE NO ACTION', followed by 'ON UPDATE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE NO ACTION; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
2

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE RESTRICT', followed by 'ON UPDATE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE RESTRICT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE RESTRICT', followed by 'ON UPDATE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE RESTRICT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
2

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE CASCADE', followed by 'ON UPDATE SET DEFAULT'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE CASCADE; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET DEFAULT

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
2

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE CASCADE', followed by 'ON UPDATE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE CASCADE; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
2

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE SET DEFAULT', followed by 'ON UPDATE CASCADE'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET DEFAULT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE CASCADE

statement ok
insert into t1 values (123); insert into t2 values (123)

statement error value \[1\] not found in t1@primary \[a\]
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
123

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE SET DEFAULT', followed by 'ON UPDATE SET NULL'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET DEFAULT; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET NULL

statement ok
insert into t1 values (123); insert into t2 values (123)

statement error value \[1\] not found in t1@primary \[a\]
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
123

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

# 'ON UPDATE SET NULL', followed by 'ON UPDATE SET DEFAULT'
statement ok
ALTER TABLE t2 ADD CONSTRAINT fk1 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET NULL; ALTER TABLE t2 ADD CONSTRAINT fk2 FOREIGN KEY (a) REFERENCES t1 ON UPDATE SET DEFAULT

statement ok
insert into t1 values (123); insert into t2 values (123)

statement ok
UPDATE t1 SET a = 2 WHERE a = 123

query I
SELECT * FROM t2
----
NULL

statement ok
ALTER TABLE t2 DROP CONSTRAINT fk1; ALTER TABLE t2 DROP CONSTRAINT fk2; TRUNCATE TABLE t2; TRUNCATE TABLE t1

statement ok
DROP TABLE t2 CASCADE; DROP TABLE t1 CASCADE
