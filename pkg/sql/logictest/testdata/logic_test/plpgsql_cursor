statement ok
CREATE TABLE xy (x INT, y INT);
INSERT INTO xy VALUES (1, 2), (3, 4);

statement ok
CREATE TABLE kv (k INT PRIMARY KEY, v INT);
INSERT INTO kv VALUES (1, 2), (3, 4);

# Testing OPEN statements.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query I
FETCH FORWARD 3 FROM foo;
----
1

statement ok
ABORT;

statement error pgcode 34000 pq: cursor \"foo\" does not exist
FETCH FORWARD 3 FROM foo;

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    x INT := 10;
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT x;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query I
FETCH FORWARD 3 FROM foo;
----
10

# TODO(drewk): postgres returns an ambiguous column error here by default,
# although it can be configured to prefer either the variable or the column.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    x INT := 10;
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT * FROM xy WHERE xy.x = x;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query II rowsort
FETCH FORWARD 10 FROM foo;
----
1  2
3  4

statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    i INT := 3;
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT * FROM xy WHERE x = i;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query II
FETCH FORWARD 3 FROM foo;
----
3  4

# It should be possible to fetch from the cursor incrementally.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs NO SCROLL FOR SELECT * FROM (VALUES (1, 2), (3, 4), (5, 6), (7, 8)) v(a, b);
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query II rowsort
FETCH FORWARD 1 FROM foo;
----
1  2

query II rowsort
FETCH FORWARD 2 FROM foo;
----
3  4
5  6

query II rowsort
FETCH FORWARD 3 FROM foo;
----
7  8

# Cursor with NO SCROLL option.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs NO SCROLL FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query I
FETCH FORWARD 3 FROM foo;
----
1

# Cursor with empty-string name.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := '';
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query I
FETCH FORWARD 3 FROM "";
----
1

# Multiple cursors.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    curs2 STRING := 'bar';
    curs3 STRING := 'baz';
  BEGIN
    OPEN curs FOR SELECT 1;
    OPEN curs2 FOR SELECT 2;
    OPEN curs3 FOR SELECT 3;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query I
FETCH FORWARD 3 FROM foo;
----
1

query I
FETCH FORWARD 3 FROM bar;
----
2

query I
FETCH FORWARD 3 FROM baz;
----
3

# The cursor should reflect changes to the database state that occur before
# it is opened, but not those that happen after it is opened.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    curs2 STRING := 'bar';
    curs3 STRING := 'baz';
  BEGIN
    OPEN curs FOR SELECT * FROM xy WHERE x = 99;
    INSERT INTO xy VALUES (99, 99);
    OPEN curs2 FOR SELECT * FROM xy WHERE x = 99;
    UPDATE xy SET y = 100 WHERE x = 99;
    OPEN curs3 FOR SELECT * FROM xy WHERE x = 99;
    DELETE FROM xy WHERE x = 99;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
SELECT f();

query II
FETCH FORWARD 3 FROM foo;
----

query II
FETCH FORWARD 3 FROM bar;
----
99  99

query II
FETCH FORWARD 3 FROM baz;
----
99  100

query II rowsort
SELECT * FROM xy;
----
1  2
3  4

statement ok
ABORT;

# It is possible to use the OPEN statement in an implicit transaction, but the
# cursor is closed at the end of the transaction when the statement execution
# finishes. So, until FETCH is implemented, we can't actually read from the
# cursor.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
SELECT f();

statement error pgcode 34000 pq: cursor \"foo\" does not exist
FETCH FORWARD 5 FROM foo;

statement error pgcode 0A000 pq: unimplemented: DECLARE SCROLL CURSOR
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs SCROLL FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

statement error pgcode 0A000 pq: unimplemented: bound cursor declarations are not yet supported.
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs CURSOR FOR SELECT 1;
  BEGIN
    OPEN curs;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

statement error pgcode 42P11 pq: cannot open INSERT query as cursor
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR INSERT INTO xy VALUES (1, 1);
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

statement error pgcode 0A000 pq: unimplemented: CTE usage inside a function definition
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    i INT := 3;
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR WITH foo AS (SELECT * FROM xy WHERE x = i) SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

# TODO(drewk): once CTEs in routines are supported, the error should be:
# pgcode 0A000 pq: DECLARE CURSOR must not contain data-modifying statements in WITH
statement error pgcode 0A000 pq: unimplemented: CTE usage inside a function definition
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    i INT := 3;
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR WITH foo AS (INSERT INTO xy VALUES (1, 1) RETURNING x) SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

statement error pgcode 42601 pq: \"curs\" is not a known variable
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    i INT := 3;
  BEGIN
    OPEN curs FOR WITH foo AS (SELECT * FROM xy WHERE x = i) SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING;
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;

statement error pgcode 0A000 pq: unimplemented: opening an unnamed cursor is not yet supported
SELECT f();

statement ok
ABORT;

statement error pgcode 0A000 pq: unimplemented: opening a cursor in a routine with an exception block is not yet supported
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING;
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  EXCEPTION
    WHEN division_by_zero THEN
      RETURN -1;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT 1 // 0;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;

statement error pgcode 22012 pq: division by zero
SELECT f();

# Conflict with an existing cursor.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT 1;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;

statement ok
DECLARE foo CURSOR FOR SELECT 100;

statement error pgcode 42P03 pq: cursor \"foo\" already exists
SELECT f();

# Conflict between OPEN statements within the same routine.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    curs2 STRING := 'foo';
  BEGIN
    OPEN curs FOR SELECT 1;
    OPEN curs2 FOR SELECT 2;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;

statement error pgcode 42P03 pq: cursor \"foo\" already exists
SELECT f();

# Testing FETCH statements.
statement ok
ABORT;
DELETE FROM xy WHERE x >= 100;
INSERT INTO xy VALUES (5, 6);

query II rowsort
SELECT * FROM xy;
----
1  2
3  4
5  6

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
    y INT;
  BEGIN
    OPEN curs FOR SELECT * FROM xy ORDER BY x;
    FETCH curs INTO x, y;
    RAISE NOTICE 'x: %, y: %', x, y;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

query T noticetrace
SELECT f();
----
NOTICE: x: 1, y: 2

# FETCH inside a loop.
statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
    y INT;
    i INT := 0;
  BEGIN
    OPEN curs FOR SELECT * FROM xy ORDER BY x;
    WHILE i < n LOOP
      FETCH curs INTO x, y;
      RAISE NOTICE 'i: %, x: %, y: %', i, x, y;
      i := i + 1;
    END LOOP;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

query T noticetrace
SELECT f(0);
----

query T noticetrace
SELECT f(1);
----
NOTICE: i: 0, x: 1, y: 2

query T noticetrace
SELECT f(2);
----
NOTICE: i: 0, x: 1, y: 2
NOTICE: i: 1, x: 3, y: 4

query T noticetrace
SELECT f(3);
----
NOTICE: i: 0, x: 1, y: 2
NOTICE: i: 1, x: 3, y: 4
NOTICE: i: 2, x: 5, y: 6

query T noticetrace
SELECT f(4);
----
NOTICE: i: 0, x: 1, y: 2
NOTICE: i: 1, x: 3, y: 4
NOTICE: i: 2, x: 5, y: 6
NOTICE: i: 3, x: <NULL>, y: <NULL>

# Target list is smaller than the number of fetched columns.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
    i INT := 0;
  BEGIN
    OPEN curs FOR SELECT * FROM xy ORDER BY x;
    WHILE i < 5 LOOP
      FETCH curs INTO x;
      RAISE NOTICE 'i: %, x: %', i, x;
      i := i + 1;
    END LOOP;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

query T noticetrace
SELECT f();
----
NOTICE: i: 0, x: 1
NOTICE: i: 1, x: 3
NOTICE: i: 2, x: 5
NOTICE: i: 3, x: <NULL>
NOTICE: i: 4, x: <NULL>

# Target list is larger than the number of fetched columns.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
    y INT := 1000;
    i INT := 0;
  BEGIN
    OPEN curs FOR SELECT x FROM xy ORDER BY x;
    WHILE i < 5 LOOP
      FETCH curs INTO x, y;
      RAISE NOTICE 'i: %, x: %, y: %', i, x, y;
      i := i + 1;
    END LOOP;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

query T noticetrace
SELECT f();
----
NOTICE: i: 0, x: 1, y: <NULL>
NOTICE: i: 1, x: 3, y: <NULL>
NOTICE: i: 2, x: 5, y: <NULL>
NOTICE: i: 3, x: <NULL>, y: <NULL>
NOTICE: i: 4, x: <NULL>, y: <NULL>

# Fetch and Move interleaved.
statement ok
CREATE OR REPLACE FUNCTION f_fetch(curs STRING) RETURNS INT AS $$
  DECLARE
    x INT;
    y INT;
  BEGIN
    FETCH curs INTO x, y;
    RAISE NOTICE 'x: %, y: %', x, y;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
CREATE OR REPLACE FUNCTION f_move(curs STRING) RETURNS INT AS $$
  BEGIN
    MOVE curs;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;
BEGIN;
INSERT INTO xy VALUES (7, 8), (9, 10);
DECLARE foo CURSOR FOR SELECT * FROM xy ORDER BY x DESC;

statement ok
SELECT f_move('foo');

# This should fetch the (7, 8) row.
query T noticetrace
SELECT f_fetch('foo');
----
NOTICE: x: 7, y: 8

statement ok
SELECT f_move('foo');
SELECT f_move('foo');

# This should fetch the (1, 2) row.
query T noticetrace
SELECT f_fetch('foo');
----
NOTICE: x: 1, y: 2

statement ok
SELECT f_move('foo');
SELECT f_move('foo');

# The cursor has been exhausted.
query T noticetrace
SELECT f_fetch('foo');
----
NOTICE: x: <NULL>, y: <NULL>

# Fetch with different directions.
statement ok
ABORT;
CREATE OR REPLACE FUNCTION f(n INT) RETURNS INT AS $$
  DECLARE
    curs STRING := format('foo%s', n);
    x INT;
  BEGIN
    OPEN curs FOR SELECT * FROM xy ORDER BY x;
    IF n = 0 THEN
      FETCH curs INTO x;
    ELSIF n = 1 THEN
      FETCH NEXT curs INTO x;
    ELSIF n = 2 THEN
      FETCH PRIOR curs INTO x;
    ELSIF n = 3 THEN
      FETCH FIRST curs INTO x;
    ELSIF n = 4 THEN
      FETCH LAST curs INTO x;
    ELSIF n = 5 THEN
      FETCH ABSOLUTE 2 curs INTO x;
    ELSIF n = 6 THEN
      FETCH ABSOLUTE -2 curs INTO x;
    ELSIF n = 7 THEN
      FETCH RELATIVE 2 curs INTO x;
    ELSIF n = 8 THEN
      FETCH RELATIVE -2 curs INTO x;
    ELSIF n = 9 THEN
      FETCH FORWARD 2 curs INTO x;
    ELSIF n = 10 THEN
      FETCH BACKWARD 2 curs INTO x;
    END IF;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query IIIIII
SELECT f(0), f(1), f(3), f(5), f(7), f(9);
----
1  1  1  3  3  3

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(2);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(4);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(6);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(8);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(10);

# Move with different directions.
statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS INT AS $$
  DECLARE
    curs STRING := format('foo%s', n);
    x INT;
  BEGIN
    OPEN curs FOR SELECT * FROM xy ORDER BY x;
    IF n = 0 THEN
      MOVE curs;
    ELSIF n = 1 THEN
      MOVE NEXT curs;
    ELSIF n = 2 THEN
      MOVE PRIOR curs;
    ELSIF n = 3 THEN
      MOVE FIRST curs;
    ELSIF n = 4 THEN
      MOVE LAST curs;
    ELSIF n = 5 THEN
      MOVE ABSOLUTE 2 curs;
    ELSIF n = 6 THEN
      MOVE ABSOLUTE -2 curs;
    ELSIF n = 7 THEN
      MOVE RELATIVE 2 curs;
    ELSIF n = 8 THEN
      MOVE RELATIVE -2 curs;
    ELSIF n = 9 THEN
      MOVE FORWARD 2 curs;
    ELSIF n = 10 THEN
      MOVE BACKWARD 2 curs;
    ELSIF n = 11 THEN
      MOVE FORWARD ALL curs;
    ELSIF n = 12 THEN
      MOVE BACKWARD ALL curs;
    ELSIF n = 13 THEN
      MOVE ALL curs;
    END IF;
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query IIIIIIII
SELECT f(0), f(1), f(3), f(5), f(7), f(9), f(11), f(13);
----
3  3  3  5  5  5  NULL  NULL

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(2);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(4);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(6);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(8);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(10);

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(12);

# The FIRST option only works if the cursor hasn't seeked yet, since backwards
# seeking isn't yet supported.
statement ok
CREATE OR REPLACE FUNCTION f(n INT) RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    IF n = 0 THEN
      FETCH FIRST curs INTO x;
    ELSE
      MOVE FIRST curs;
    END IF;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

statement ok
BEGIN;
DECLARE foo CURSOR FOR SELECT * FROM xy ORDER BY x;

# MOVE FIRST and FETCH FIRST leave the cursor positioned at the first row.
statement ok
SELECT f(1);
SELECT f(1);
SELECT f(1);

query I
SELECT f(0);
----
1

statement ok
SELECT f(1);
SELECT f(1);

query I
SELECT f(0);
----
1

# After seeking the cursor, MOVE FIRST fails.
query II rowsort
FETCH FORWARD 2 FROM foo;
----
3  4
5  6

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(1);

# After seeking the cursor, FETCH FIRST fails.
statement ok
ABORT;
BEGIN;
DECLARE foo CURSOR FOR SELECT * FROM xy ORDER BY x;
MOVE FORWARD 2 IN foo;

statement error pgcode 55000 pq: cursor can only scan forward
SELECT f(0);

statement ok
ABORT;

# String cast to an int.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    OPEN curs FOR SELECT '1';
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query I
SELECT f();
----
1

# String cast to a bool.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS BOOL AS $$
  DECLARE
    curs STRING := 'foo';
    x BOOL;
  BEGIN
    OPEN curs FOR SELECT 'f';
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query B
SELECT f();
----
false

# String cast to Char. The string fits in the Char type.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS CHAR AS $$
  DECLARE
    curs STRING := 'foo';
    x CHAR;
  BEGIN
    OPEN curs FOR SELECT 'a';
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
a

# String cast to Bit. The string fits in the Bit type.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS BIT AS $$
  DECLARE
    curs STRING := 'foo';
    x BIT;
  BEGIN
    OPEN curs FOR SELECT '1';
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query T
SELECT f();
----
1

# Int cast to Float.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS FLOAT AS $$
  DECLARE
    curs STRING := 'foo';
    x FLOAT;
  BEGIN
    OPEN curs FOR SELECT 1;
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query R
SELECT f();
----
1

# Int cast to Decimal.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS DECIMAL AS $$
  DECLARE
    curs STRING := 'foo';
    x DECIMAL;
  BEGIN
    OPEN curs FOR SELECT 1;
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query R
SELECT f();
----
1

# Float cast to Int.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    OPEN curs FOR SELECT 1.1::FLOAT;
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query I
SELECT f();
----
1

# Decimal cast to Int.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    OPEN curs FOR SELECT 1.1::DECIMAL;
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query I
SELECT f();
----
1

# Widening Decimal to Decimal.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS DECIMAL(10, 4) AS $$
  DECLARE
    curs STRING := 'foo';
    x DECIMAL(10, 4);
  BEGIN
    OPEN curs FOR SELECT 1.11::DECIMAL(10, 2);
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query R
SELECT f();
----
1.1100

# Narrowing Decimal to Decimal.
statement ok
DROP FUNCTION f();
CREATE OR REPLACE FUNCTION f() RETURNS DECIMAL(10, 2) AS $$
  DECLARE
    curs STRING := 'foo';
    x DECIMAL(10, 2);
  BEGIN
    OPEN curs FOR SELECT 1.1111::DECIMAL(10, 4);
    FETCH curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

query R
SELECT f();
----
1.11

# Different-sized int casts.
statement ok
CREATE OR REPLACE FUNCTION f(a INT, b INT) RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x2 INT2;
    x4 INT4;
    x8 INT8;
  BEGIN
    OPEN curs FOR SELECT b;
    IF a = 2 THEN
      FETCH curs INTO x2;
    ELSIF a = 4 THEN
      FETCH curs INTO x4;
    ELSIF a = 8 THEN
      FETCH curs INTO x8;
    END IF;
    RAISE NOTICE 'x2: %, x4: %, x8: %', x2, x4, x8;
    RETURN 0;
  END
$$ LANGUAGE PLpgSQL;

query T noticetrace
SELECT f(2, 1);
----
NOTICE: x2: 1, x4: <NULL>, x8: <NULL>

query T noticetrace
SELECT f(4, 1);
----
NOTICE: x2: <NULL>, x4: 1, x8: <NULL>

query T noticetrace
SELECT f(8, 1);
----
NOTICE: x2: <NULL>, x4: <NULL>, x8: 1

statement error pgcode 22003 pq: integer out of range for type int2
SELECT f(2, 5000000000);

statement error pgcode 22003 pq: integer out of range for type int4
SELECT f(4, 5000000000);

query T noticetrace
SELECT f(8, 5000000000);
----
NOTICE: x2: <NULL>, x4: <NULL>, x8: 5000000000

statement error pgcode 0A000 pq: FETCH statement cannot return multiple rows
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    OPEN curs FOR SELECT x FROM xy ORDER BY x;
    FETCH ALL FROM curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

statement error pgcode 0A000 pq: FETCH statement cannot return multiple rows
CREATE OR REPLACE FUNCTION f() RETURNS INT AS $$
  DECLARE
    curs STRING := 'foo';
    x INT;
  BEGIN
    OPEN curs FOR SELECT x FROM xy ORDER BY x;
    FETCH BACKWARD ALL FROM curs INTO x;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;
