# LogicTest: local

# Tests for shard_columns storage parameter (issue #76798) which allows the hashed columns to be a prefix of
# the index key columns

# Set default bucket count to 8 for consistency with tests
statement ok
SET CLUSTER SETTING sql.defaults.default_hash_sharded_index_bucket_count = 8

subtest shard_columns_parsing

statement ok
CREATE TABLE shard_columns_test (
  c1 INT,
  c2 INT,
  c3 INT,
  c4 INT
)

# The shard_columns storage parameter can appear alone or in any order
statement ok
CREATE INDEX idx1 ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(c1, c2))

statement ok
CREATE INDEX idx2 ON shard_columns_test (c1, c2, c3) USING HASH WITH (shard_columns=(c1, c2), bucket_count=4)

statement ok
CREATE INDEX idx3 ON shard_columns_test (c1, c2, c3) USING HASH WITH (shard_columns=(c1, c2))

# Column names can be provided in a tuple or a single standalone column
statement ok
CREATE INDEX idx4 ON shard_columns_test (c1, c2, c3) USING HASH WITH (shard_columns=(c1))

statement ok
CREATE INDEX idx5 ON shard_columns_test (c1, c2, c3) USING HASH WITH (shard_columns=c1)

# All key columns can be provided as shard columns
statement ok
CREATE INDEX idx6 ON shard_columns_test (c1, c2, c3) USING HASH WITH (shard_columns=(c1, c2, c3))

# Verify all indexes appear in pg_indexes with correct shard_columns.
query TT
SELECT indexname, indexdef FROM pg_indexes
WHERE tablename = 'shard_columns_test' AND indexname LIKE 'idx%'
ORDER BY indexname
----
idx1  CREATE INDEX idx1 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=4, shard_columns=(c1, c2))
idx2  CREATE INDEX idx2 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=4, shard_columns=(c1, c2))
idx3  CREATE INDEX idx3 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1, c2))
idx4  CREATE INDEX idx4 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1))
idx5  CREATE INDEX idx5 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1))
idx6  CREATE INDEX idx6 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC, c3 ASC) USING HASH WITH (bucket_count=8)

statement ok
DROP TABLE shard_columns_test

# All index types in CREATE TABLE
statement ok
CREATE TABLE shard_columns_test (
  c1 INT,
  c2 INT,
  c3 INT,
  c4 INT,
  CONSTRAINT idx1 PRIMARY KEY (c1, c2) USING HASH WITH (shard_columns=(c1)),
  UNIQUE INDEX idx2 (c2, c3) USING HASH WITH (shard_columns=(c2)),
  INDEX idx3 (c3, c4) USING HASH WITH (shard_columns=(c3))
)

# Verify all indexes appear in pg_indexes with correct shard_columns
query TT
SELECT indexname, indexdef FROM pg_indexes
WHERE tablename = 'shard_columns_test' AND indexname LIKE 'idx%'
ORDER BY indexname
----
idx1  CREATE UNIQUE INDEX idx1 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1))
idx2  CREATE UNIQUE INDEX idx2 ON test.public.shard_columns_test USING btree (c2 ASC, c3 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c2))
idx3  CREATE INDEX idx3 ON test.public.shard_columns_test USING btree (c3 ASC, c4 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c3))

statement ok
DROP TABLE shard_columns_test

# Alter table
statement ok
CREATE TABLE shard_columns_test (
  c1 INT NOT NULL,
  c2 INT NOT NULL,
  c3 INT,
  c4 INT
)

statement ok
ALTER TABLE shard_columns_test ADD CONSTRAINT idx1 PRIMARY KEY (c1, c2) USING HASH WITH (shard_columns=(c1));

# Verify all indexes appear in pg_indexes with correct shard_columns
query TT
SELECT indexname, indexdef FROM pg_indexes
WHERE tablename = 'shard_columns_test' AND indexname LIKE 'idx%'
ORDER BY indexname
----
idx1  CREATE UNIQUE INDEX idx1 ON test.public.shard_columns_test USING btree (c1 ASC, c2 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1))

statement ok
DROP TABLE shard_columns_test

# Test delimited identifiers
statement ok
CREATE TABLE "MixedCase" ("Col1" INT, "Col2" INT, "Col3" INT)

statement ok
CREATE INDEX "IdX" ON "MixedCase" ("Col1", "Col2", "Col3")
  USING HASH WITH (bucket_count=4, shard_columns=("Col1", "Col2"))

query TT
SELECT tablename, indexdef FROM pg_indexes
WHERE tablename = 'MixedCase' AND indexname = 'IdX'
----
MixedCase  CREATE INDEX "IdX" ON test.public."MixedCase" USING btree ("Col1" ASC, "Col2" ASC, "Col3" ASC) USING HASH WITH (bucket_count=4, shard_columns=("Col1", "Col2"))

statement ok
DROP TABLE "MixedCase"

subtest end

# Error scenarios
subtest shard_columns_parsing_errors

statement ok
CREATE TABLE shard_columns_test (
  c1 INT,
  c2 INT,
  c3 INT,
  c4 INT
)

# Error when shard_columns references non-existent column
statement error pq: shard_columns must be a prefix of index columns; expected "c1" at position 1, got "nonexistent"
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(nonexistent))

# Error when shard_columns is not a prefix of index key columns
statement error pq: shard_columns must be a prefix of index columns; expected "c1" at position 1, got "c2"
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(c2, c3))

# Error when shard_columns is not a prefix of index key columns
statement error pq: shard_columns must be a prefix of index columns; expected "c2" at position 2, got "c3"
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(c1, c3))

# Error when shard_columns is not a prefix of index key columns - duplicate name
statement error pq: shard_columns must be a prefix of index columns; expected "c2" at position 2, got "c1"
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(c1, c1))

# Empty shard_columns
statement error pq: shard_columns must contain at least one column name
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=())

# Error when shard_columns has more columns than index
statement error pq: shard_columns cannot contain more columns than the index \(4 > 3\)
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(c1, c2, c3, c4))

# Error when column name is provided as an expression
statement error pq: shard_columns must be a column name or tuple of column names
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=('c' || '1'))

# Error when column name is provided as an expression
statement error pq: shard_columns must be a column name or tuple of column names
CREATE INDEX idx_bad ON shard_columns_test (c1, c2, c3) USING HASH WITH (bucket_count=4, shard_columns=(null))

statement ok
DROP TABLE shard_columns_test

subtest end

# Test legacy schema changer with use_declarative_schema_changer=off
subtest shard_columns_legacy

statement ok
SET use_declarative_schema_changer = 'off'

statement ok
CREATE TABLE legacy_test (
  c1 INT,
  c2 INT,
  c3 INT,
  c4 INT,
  UNIQUE INDEX idx1 (c1, c2) USING HASH WITH (shard_columns=c1)
)

# Unlock table in configs where schema_locked is enabled
skipif config schema-locked-disabled
statement ok
ALTER TABLE legacy_test SET (schema_locked = false)

statement ok
CREATE INDEX idx2 ON legacy_test (c2, c3, c4) USING HASH WITH (shard_columns=(c2, c3))

query TT
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'legacy_test' AND indexname LIKE 'idx%' ORDER BY indexname
----
idx1  CREATE UNIQUE INDEX idx1 ON test.public.legacy_test USING btree (c1 ASC, c2 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c1))
idx2  CREATE INDEX idx2 ON test.public.legacy_test USING btree (c2 ASC, c3 ASC, c4 ASC) USING HASH WITH (bucket_count=8, shard_columns=(c2, c3))

statement ok
DROP TABLE legacy_test

statement ok
SET use_declarative_schema_changer = 'on'

subtest end

# Verify hash prefix indexes can coexist with store columns
subtest shard_columns_storing

statement ok
CREATE TABLE store_columns_test (
  c1 INT,
  c2 INT,
  c3 INT,
  c4 INT
)

statement ok
CREATE INDEX idx1 ON store_columns_test (c1, c2) USING HASH STORING (c3) WITH (bucket_count=4, shard_columns=(c1))

# Insert test data and verify STORING columns work correctly
statement ok
INSERT INTO store_columns_test VALUES
  (1, 10, 100, 1000),
  (1, 20, 200, 2000),
  (2, 10, 300, 3000),
  (2, 20, 400, 4000),
  (3, 10, 500, 5000),
  (3, 20, 600, 6000)

# Query using the index with equality filter on shard column c1
query III rowsort
SELECT c1, c2, c3 FROM store_columns_test@idx1 WHERE c1 = 2
----
2  10  300
2  20  400

statement ok
DROP TABLE store_columns_test

subtest end

# General data correctness tests with shard_columns
subtest shard_columns_data_correctness

statement ok
CREATE TABLE data_test (
  id INT PRIMARY KEY,
  region STRING,
  city STRING,
  population INT,
  area_km2 INT
)

# Create index with shard_columns=(region) as prefix of (region, city)
statement ok
CREATE INDEX idx_region_city ON data_test (region, city, population)
  USING HASH WITH (bucket_count=4, shard_columns=(region))

statement ok
INSERT INTO data_test VALUES
  (1, 'west', 'seattle', 750000, 217),
  (2, 'west', 'portland', 650000, 376),
  (3, 'west', 'san_francisco', 875000, 121),
  (4, 'east', 'boston', 675000, 125),
  (5, 'east', 'new_york', 8400000, 783),
  (6, 'east', 'philadelphia', 1600000, 347),
  (7, 'central', 'chicago', 2700000, 589),
  (8, 'central', 'dallas', 1300000, 999)

# Query with equality filter on shard column
query ITTI rowsort
SELECT id, region, city, population FROM data_test WHERE region = 'west'
----
1  west  seattle        750000
2  west  portland       650000
3  west  san_francisco  875000

# Force index usage with hint to verify index works correctly with equality filter
query ITTI rowsort
SELECT id, region, city, population FROM data_test@idx_region_city WHERE region = 'west'
----
1  west  seattle        750000
2  west  portland       650000
3  west  san_francisco  875000

# Query with IN clause on shard column
query ITTI rowsort
SELECT id, region, city, population FROM data_test WHERE region IN ('east', 'central') AND population > 1000000
----
5  east     new_york      8400000
6  east     philadelphia  1600000
7  central  chicago       2700000
8  central  dallas        1300000

# Force index usage with hint to verify index works correctly with IN clause
query ITTI rowsort
SELECT id, region, city, population FROM data_test@idx_region_city
WHERE region IN ('east', 'central') AND population > 1000000
----
5  east     new_york      8400000
6  east     philadelphia  1600000
7  central  chicago       2700000
8  central  dallas        1300000

# Query with both shard and non-shard columns
query ITT rowsort
SELECT id, region, city FROM data_test WHERE region = 'east' AND city = 'boston'
----
4  east  boston

# Force index usage with hint for query with both shard and non-shard columns
query ITT rowsort
SELECT id, region, city FROM data_test@idx_region_city WHERE region = 'east' AND city = 'boston'
----
4  east  boston

# This will result in a very sub-optimal plan, but force the index to be used in a full scan
# to verify all rows are present
query ITTII rowsort
SELECT * FROM data_test@idx_region_city
----
1  west     seattle        750000   217
2  west     portland       650000   376
3  west     san_francisco  875000   121
4  east     boston         675000   125
5  east     new_york       8400000  783
6  east     philadelphia   1600000  347
7  central  chicago        2700000  589
8  central  dallas         1300000  999

statement ok
DROP TABLE data_test

subtest end

# Test UPDATE operations that move rows between buckets
subtest shard_columns_row_movement_update

statement ok
CREATE TABLE update_test (
  id INT PRIMARY KEY,
  c1 INT,
  c2 INT
)

statement ok
CREATE INDEX idx1 ON update_test (c1, c2) USING HASH WITH (bucket_count=8, shard_columns=(c1))

statement ok
INSERT INTO update_test SELECT generate_series(1,20), generate_series(21,40), generate_series(41,60)

# Verify initial data
query I rowsort
SELECT count(*) FROM update_test@idx1
----
20

# Update shard column values, moving rows to different buckets
statement ok
UPDATE update_test SET c1 = c1 + 80

# Verify data correctness after updates
query II rowsort
SELECT c1, c2 FROM update_test@idx1
----
101  41
102  42
103  43
104  44
105  45
106  46
107  47
108  48
109  49
110  50
111  51
112  52
113  53
114  54
115  55
116  56
117  57
118  58
119  59
120  60

# Query for a single value
query II rowsort
SELECT c1, c2 FROM update_test@idx1 WHERE c1 = 110
----
110  50

statement ok
DROP TABLE update_test

subtest end

# Test foreign keys where both parent and child use a hash prefix index
subtest shard_column_fk

statement ok
CREATE TABLE shard_columns_parent (
  c1 INT NOT NULL,
  c2 INT NOT NULL,
  c3 INT NOT NULL,
  c4 INT,
  PRIMARY KEY (c1, c2, c3) USING HASH WITH (bucket_count=8, shard_columns=(c1, c2))
)

statement ok
INSERT INTO shard_columns_parent
  SELECT generate_series(1,20), generate_series(1,20), generate_series(1,20), generate_series(1,20)

statement ok
CREATE TABLE shard_columns_child (
  z INT,
  y INT,
  x INT,
  w INT,
  FOREIGN KEY (z, y, x) REFERENCES shard_columns_parent(c1, c2, c3) ON DELETE CASCADE
)

statement ok
CREATE INDEX idx1 ON shard_columns_child(z, y, x) USING HASH WITH (bucket_count=8, shard_columns=(z, y))

statement ok
INSERT INTO shard_columns_child VALUES (1, 1, 1, 1), (5, 5, 5, 5), (9, 9, 9, 9), (11, 11, 11, 11)

# Error when referenced values do not exist in the parent
statement error pq: insert on table "shard_columns_child" violates foreign key constraint "shard_columns_child_z_y_x_fkey"
INSERT INTO shard_columns_child VALUES (101, 101, 101, 101)

query IIII rowsort
SELECT * FROM shard_columns_child@idx1
----
1  1  1  1
5  5  5  5
9  9  9  9
11  11  11  11

statement count 5
DELETE FROM shard_columns_parent WHERE c1 < 6

query IIII rowsort
SELECT * FROM shard_columns_child@idx1
----
9  9  9  9
11  11  11  11

statement ok
DROP TABLE shard_columns_child

statement ok
DROP TABLE shard_columns_parent

subtest end

# Rename scenario which shows column sorting behavior during hash index creation
subtest shard_columns_rename

statement ok
CREATE TABLE shard_columns_rename (
  a INT,
  b INT,
  c INT,
  d INT,
  FAMILY fam_all (a, b, c, d)
)

statement ok
CREATE INDEX idx1 ON shard_columns_rename (a, b, c) USING HASH WITH (bucket_count=4, shard_columns=(a, b))

statement ok
CREATE INDEX idx2 ON shard_columns_rename (b, a, c) USING HASH WITH (bucket_count=4, shard_columns=(b, a))

statement ok
INSERT INTO shard_columns_rename
  SELECT generate_series(1,10), generate_series(6,15), generate_series(16,25), generate_series(21,30)

query IIII
SELECT crdb_internal_a_b_shard_4, a, b, c FROM shard_columns_rename ORDER BY a
----
1  1  6  16
2  2  7  17
0  3  8  18
1  4  9  19
3  5  10  20
3  6  11  21
3  7  12  22
3  8  13  23
1  9  14  24
3  10  15  25

onlyif config schema-locked-disabled
query T
SELECT create_statement FROM [SHOW CREATE TABLE shard_columns_rename]
----
CREATE TABLE public.shard_columns_rename (
  a INT8 NULL,
  b INT8 NULL,
  c INT8 NULL,
  d INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  crdb_internal_a_b_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a, b))), 4:::INT8)) VIRTUAL,
  CONSTRAINT shard_columns_rename_pkey PRIMARY KEY (rowid ASC),
  INDEX idx1 (a ASC, b ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(a, b)),
  INDEX idx2 (b ASC, a ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(a, b)),
  FAMILY fam_all (a, b, c, d, rowid)
);

skipif config schema-locked-disabled
query T
SELECT create_statement FROM [SHOW CREATE TABLE shard_columns_rename]
----
CREATE TABLE public.shard_columns_rename (
  a INT8 NULL,
  b INT8 NULL,
  c INT8 NULL,
  d INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  crdb_internal_a_b_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(a, b))), 4:::INT8)) VIRTUAL,
  CONSTRAINT shard_columns_rename_pkey PRIMARY KEY (rowid ASC),
  INDEX idx1 (a ASC, b ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(a, b)),
  INDEX idx2 (b ASC, a ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(a, b)),
  FAMILY fam_all (a, b, c, d, rowid)
) WITH (schema_locked = true);

statement ok
ALTER TABLE shard_columns_rename RENAME COLUMN a TO x

query IIII
SELECT crdb_internal_b_x_shard_4, x, b, c FROM shard_columns_rename ORDER BY x
----
1  1  6  16
2  2  7  17
0  3  8  18
1  4  9  19
3  5  10  20
3  6  11  21
3  7  12  22
3  8  13  23
1  9  14  24
3  10  15  25

onlyif config schema-locked-disabled
query T
SELECT create_statement FROM [SHOW CREATE TABLE shard_columns_rename]
----
CREATE TABLE public.shard_columns_rename (
  x INT8 NULL,
  b INT8 NULL,
  c INT8 NULL,
  d INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  crdb_internal_b_x_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(x, b))), 4:::INT8)) VIRTUAL,
  CONSTRAINT shard_columns_rename_pkey PRIMARY KEY (rowid ASC),
  INDEX idx1 (x ASC, b ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(b, x)),
  INDEX idx2 (b ASC, x ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(b, x)),
  FAMILY fam_all (x, b, c, d, rowid)
);

skipif config schema-locked-disabled
query T
SELECT create_statement FROM [SHOW CREATE TABLE shard_columns_rename]
----
CREATE TABLE public.shard_columns_rename (
  x INT8 NULL,
  b INT8 NULL,
  c INT8 NULL,
  d INT8 NULL,
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  crdb_internal_b_x_shard_4 INT8 NOT VISIBLE NOT NULL AS (mod(fnv32(md5(crdb_internal.datums_to_bytes(x, b))), 4:::INT8)) VIRTUAL,
  CONSTRAINT shard_columns_rename_pkey PRIMARY KEY (rowid ASC),
  INDEX idx1 (x ASC, b ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(b, x)),
  INDEX idx2 (b ASC, x ASC, c ASC) USING HASH WITH (bucket_count=4, shard_columns=(b, x)),
  FAMILY fam_all (x, b, c, d, rowid)
) WITH (schema_locked = true);

statement ok
DROP TABLE shard_columns_rename

subtest end
