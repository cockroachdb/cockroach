statement error unimplemented: only simple columns are supported as index elements
CREATE TABLE err (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  INDEX ((a + b))
)

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  b INT
)

statement error unimplemented: only simple columns are supported as index elements
CREATE INDEX err ON t ((a + b))

statement ok
DROP TABLE t

statement ok
SET experimental_enable_expression_based_indexes=true

# CREATE TABLE tests.

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  c STRING,
  stor STRING AS (lower(c)) STORED,
  virt INT AS (a + 10) VIRTUAL,
  INDEX ((a + b)),
  INDEX (lower(c)),
  INDEX (lower(c), (a + b)),
  INDEX ((a + 10)),
  FAMILY (k, a, b, c, stor)
)

# TODO(mgartner): The expression should be printed in expression-based indexes
# instead of the virtual column name.
query T
SELECT create_statement FROM [SHOW CREATE TABLE t]
----
CREATE TABLE public.t (
   k INT8 NOT NULL,
   a INT8 NULL,
   b INT8 NULL,
   c STRING NULL,
   stor STRING NULL AS (lower(c)) STORED,
   virt INT8 NULL AS (a + 10:::INT8) VIRTUAL,
   crdb_idx_expr INT8 NOT VISIBLE NULL AS (a + b) VIRTUAL,
   crdb_idx_expr_1 STRING NOT VISIBLE NULL AS (lower(c)) VIRTUAL,
   CONSTRAINT "primary" PRIMARY KEY (k ASC),
   INDEX t_crdb_idx_expr_idx (crdb_idx_expr ASC),
   INDEX t_crdb_idx_expr_1_idx (crdb_idx_expr_1 ASC),
   INDEX t_crdb_idx_expr_1_crdb_idx_expr_idx (crdb_idx_expr_1 ASC, crdb_idx_expr ASC),
   INDEX t_virt_idx (virt ASC),
   FAMILY fam_0_k_a_b_c_stor (k, a, b, c, stor)
)

statement error volatile functions are not allowed in index element
CREATE TABLE err (a INT, INDEX ((a + random()::INT)))

statement error column \"z\" does not exist
CREATE TABLE err (a INT, INDEX ((a + z)))

statement error index element expression cannot reference computed columns
CREATE TABLE err (a INT, comp INT AS (a + 10) STORED, INDEX ((comp + 10)))

statement ok
DROP TABLE t

# CREATE INDEX tests.

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  b INT,
  c STRING,
  stor STRING AS (lower(c)) STORED,
  virt INT AS (a + 10) VIRTUAL,
  FAMILY (k, a, b, c, stor)
)

statement ok
CREATE INDEX t_a_plus_b_idx ON t ((a + b))

statement ok
CREATE INDEX t_lower_c_idx ON t (lower(c))

statement ok
CREATE INDEX t_lower_c_a_plus_b_idx ON t (lower(c), (a + b))

statement ok
CREATE INDEX t_a_plus_ten_idx ON t ((a + 10))

# TODO(mgartner): The expression should be printed in expression-based indexes
# instead of the virtual column name.
query T
SELECT create_statement FROM [SHOW CREATE TABLE t]
----
CREATE TABLE public.t (
   k INT8 NOT NULL,
   a INT8 NULL,
   b INT8 NULL,
   c STRING NULL,
   stor STRING NULL AS (lower(c)) STORED,
   virt INT8 NULL AS (a + 10:::INT8) VIRTUAL,
   crdb_idx_expr INT8 NOT VISIBLE NULL AS (a + b) VIRTUAL,
   crdb_idx_expr_1 STRING NOT VISIBLE NULL AS (lower(c)) VIRTUAL,
   CONSTRAINT "primary" PRIMARY KEY (k ASC),
   INDEX t_a_plus_b_idx (crdb_idx_expr ASC),
   INDEX t_lower_c_idx (crdb_idx_expr_1 ASC),
   INDEX t_lower_c_a_plus_b_idx (crdb_idx_expr_1 ASC, crdb_idx_expr ASC),
   INDEX t_a_plus_ten_idx (virt ASC),
   FAMILY fam_0_k_a_b_c_stor (k, a, b, c, stor)
)

statement error volatile functions are not allowed in index element
CREATE INDEX err ON t ((a + random()::INT))

statement error column \"z\" does not exist
CREATE INDEX err ON t ((a + z))

statement error index element expression cannot reference computed columns
CREATE INDEX err ON t ((stor + 10))

statement ok
CREATE TABLE child (
  fk INT REFERENCES t (k) ON UPDATE CASCADE,
  a INT
)

# An expression-based index cannot reference columns in other tables.
statement error no data source matches prefix: t in this context
CREATE INDEX err ON child ((t.a + 10))

# Querying expression-based indexes.

statement ok
INSERT INTO t VALUES
  (1, 10, 100, 'Foo'),
  (2, 20, 200, 'FOO'),
  (3, 10, 100, 'foo'),
  (4, 40, 400, 'BAR'),
  (5, 100, 10, 'Food')

query IIITTI colnames,rowsort
SELECT * FROM t@t_a_plus_b_idx WHERE a + b = 110
----
k  a    b    c     stor  virt
1  10   100  Foo   foo   20
3  10   100  foo   foo   20
5  100  10   Food  food  110

query IIITTI colnames,rowsort
SELECT * FROM t@t_a_plus_b_idx WHERE a + b > 110
----
k  a   b    c    stor  virt
2  20  200  FOO  foo   30
4  40  400  BAR  bar   50

query IIITTI colnames,rowsort
SELECT * FROM t@t_lower_c_idx WHERE lower(c) = 'foo'
----
k  a   b    c    stor  virt
1  10  100  Foo  foo   20
2  20  200  FOO  foo   30
3  10  100  foo  foo   20

query IIITTI colnames,rowsort
SELECT * FROM t@t_lower_c_idx WHERE lower(c) LIKE 'foo%'
----
k  a    b    c     stor  virt
1  10   100  Foo   foo   20
2  20   200  FOO   foo   30
3  10   100  foo   foo   20
5  100  10   Food  food  110

query IIITTI colnames,rowsort
SELECT * FROM t@t_lower_c_a_plus_b_idx WHERE lower(c) = 'foo' AND a + b > 110
----
k  a   b    c    stor  virt
2  20  200  FOO  foo   30

# Backfilling expression-based indexes.

statement ok
CREATE INDEX t_a_times_two_idx ON t ((a * 2))

query IIITTI colnames,rowsort
SELECT * FROM t@t_a_times_two_idx WHERE a * 2 = 20
----
k  a   b    c    stor  virt
1  10  100  Foo  foo   20
3  10  100  foo  foo   20

query IIITTI colnames,rowsort
SELECT * FROM t@t_a_times_two_idx WHERE a * 2 < 100
----
k  a   b    c    stor  virt
1  10  100  Foo  foo   20
2  20  200  FOO  foo   30
3  10  100  foo  foo   20
4  40  400  BAR  bar   50
