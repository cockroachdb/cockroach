##################
# TABLE DDL
##################

# Verify events related to roles
##################

statement ok
CREATE ROLE r

statement ok
CREATE ROLE IF NOT EXISTS r2

statement ok
ALTER ROLE r WITH CONTROLCHANGEFEED

statement ok
DROP ROLE r, r2

query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" IN ('create_role', 'drop_role', 'alter_role')
ORDER BY "timestamp", info
----
1  create_role  {"EventType": "create_role", "RoleName": "testuser", "Statement": "CREATE USER testuser", "Tag": "CREATE ROLE", "User": "root"}
1  create_role  {"EventType": "create_role", "RoleName": "r", "Statement": "CREATE ROLE r", "Tag": "CREATE ROLE", "User": "root"}
1  create_role  {"EventType": "create_role", "RoleName": "r2", "Statement": "CREATE ROLE IF NOT EXISTS r2", "Tag": "CREATE ROLE", "User": "root"}
1  alter_role   {"EventType": "alter_role", "Options": ["CONTROLCHANGEFEED"], "RoleName": "r", "Statement": "ALTER ROLE r WITH CONTROLCHANGEFEED", "Tag": "ALTER ROLE", "User": "root"}
1  drop_role    {"EventType": "drop_role", "RoleName": "r", "Statement": "DROP ROLE r, r2", "Tag": "DROP ROLE", "User": "root"}
1  drop_role    {"EventType": "drop_role", "RoleName": "r2", "Statement": "DROP ROLE r, r2", "Tag": "DROP ROLE", "User": "root"}

# Create two tables + superfluous "IF NOT EXISTS"
##################

statement ok
CREATE TABLE a (id INT PRIMARY KEY)

statement ok
CREATE TABLE IF NOT EXISTS b (id INT PRIMARY KEY)

statement ok
CREATE TABLE IF NOT EXISTS a (id INT PRIMARY KEY)


# Verify that two create tables were logged - the second
# NOT EXISTS should not result in a log message.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" = 'create_table'
ORDER BY "timestamp", info
----
1  {"EventType": "create_table", "Statement": "CREATE TABLE test.public.a (id INT8 PRIMARY KEY)", "TableName": "test.public.a", "Tag": "CREATE TABLE", "User": "root"}
1  {"EventType": "create_table", "Statement": "CREATE TABLE IF NOT EXISTS test.public.b (id INT8 PRIMARY KEY)", "TableName": "test.public.b", "Tag": "CREATE TABLE", "User": "root"}

# Verify the contents of the 'Info' field of each log message using a LIKE
# statement.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'create_table'
  AND info::JSONB->>'Statement' LIKE 'CREATE TABLE test.public.a%'
----
1  {"EventType": "create_table", "Statement": "CREATE TABLE test.public.a (id INT8 PRIMARY KEY)", "TableName": "test.public.a", "Tag": "CREATE TABLE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'create_table'
  AND info::JSONB->>'Statement' LIKE 'CREATE TABLE IF NOT EXISTS test.public.b%'
----
1  {"EventType": "create_table", "Statement": "CREATE TABLE IF NOT EXISTS test.public.b (id INT8 PRIMARY KEY)", "TableName": "test.public.b", "Tag": "CREATE TABLE", "User": "root"}

# Sanity check - check for a non-matching info value.
##################

query I
SELECT count(*)
FROM system.eventlog
WHERE "eventType" = 'create_table'
  AND info LIKE '%CREATE TABLE badtable%'
----
0

# Alter the table. Expect "alter_table" and "finish_schema_change" events.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'alter_table'
----

statement ok
ALTER TABLE a ADD val INT

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'alter_table'
----
1  {"EventType": "alter_table", "MutationID": 1, "Statement": "ALTER TABLE test.public.a ADD COLUMN val INT8", "TableName": "test.public.a", "Tag": "ALTER TABLE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'finish_schema_change'
----
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}

query I
SELECT "reportingID" FROM system.eventlog
WHERE "eventType" = 'reverse_schema_change'
----

# Verify the contents of the 'Info' field of each log message using a LIKE
# statement.
##################
query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'alter_table'
  AND info::JSONB->>'Statement' LIKE 'ALTER TABLE test.public.a%'
----
1  {"EventType": "alter_table", "MutationID": 1, "Statement": "ALTER TABLE test.public.a ADD COLUMN val INT8", "TableName": "test.public.a", "Tag": "ALTER TABLE", "User": "root"}

# Add a UNIQUE constraint to the table in a way that will ensure the schema
# change is reversed.
##################

statement ok
INSERT INTO a VALUES (1, 1), (2, 1)

statement error pgcode 23505 violates unique constraint \"foo\"
ALTER TABLE a ADD CONSTRAINT foo UNIQUE(val)

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'alter_table'
ORDER BY "timestamp", info
----
1  {"EventType": "alter_table", "MutationID": 1, "Statement": "ALTER TABLE test.public.a ADD COLUMN val INT8", "TableName": "test.public.a", "Tag": "ALTER TABLE", "User": "root"}
1  {"EventType": "alter_table", "MutationID": 2, "Statement": "ALTER TABLE test.public.a ADD CONSTRAINT foo UNIQUE (val)", "TableName": "test.public.a", "Tag": "ALTER TABLE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'  FROM system.eventlog
WHERE "eventType" = 'finish_schema_change'
----
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' - 'Error'
  FROM system.eventlog
WHERE "eventType" = 'reverse_schema_change'
----
1  {"EventType": "reverse_schema_change", "InstanceID": 1, "MutationID": 2, "SQLSTATE": "23505"}


query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'finish_schema_change_rollback'
----
1  {"EventType": "finish_schema_change_rollback", "InstanceID": 1, "MutationID": 2}

# Create an Index on the table
#################

statement ok
CREATE INDEX a_foo ON a (val)

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'create_index'
  AND info::JSONB->>'Statement' LIKE 'CREATE INDEX %a_foo%'
----
1  {"EventType": "create_index", "IndexName": "a_foo", "MutationID": 3, "Statement": "CREATE INDEX a_foo ON test.public.a (val)", "TableName": "test.public.a", "Tag": "CREATE INDEX", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'finish_schema_change'
ORDER BY "timestamp", info
----
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 3}

statement ok
CREATE INDEX ON a (val)

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'create_index'
  AND info::JSONB->>'Statement' LIKE 'CREATE INDEX ON%'
----
1  {"EventType": "create_index", "IndexName": "a_val_idx", "MutationID": 4, "Statement": "CREATE INDEX ON test.public.a (val)", "TableName": "test.public.a", "Tag": "CREATE INDEX", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'finish_schema_change'
ORDER BY "timestamp", info
----
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 3}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 4}


# Drop the index
#################

statement ok
DROP INDEX a@a_foo

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'drop_index'
  AND info::JSONB->>'Statement' LIKE 'DROP INDEX%a_foo'
----
1  {"EventType": "drop_index", "IndexName": "a_foo", "MutationID": 5, "Statement": "DROP INDEX test.public.a@a_foo", "TableName": "test.public.a", "Tag": "DROP INDEX", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID' FROM system.eventlog
WHERE "eventType" = 'finish_schema_change'
ORDER BY "timestamp", info
----
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 1}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 3}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 4}
1  {"EventType": "finish_schema_change", "InstanceID": 1, "MutationID": 5}

# Truncate a table
##################

statement ok
TRUNCATE TABLE a

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'truncate_table'
----
1  {"EventType": "truncate_table", "Statement": "TRUNCATE TABLE test.public.a", "TableName": "test.public.a", "Tag": "TRUNCATE", "User": "root"}

# Drop both tables + superfluous "IF EXISTS"
##################

statement ok
DROP TABLE a

statement ok
DROP TABLE IF EXISTS b

statement ok
DROP TABLE IF EXISTS b


# Verify that two drop table events were logged - the second IF EXISTS statement
# should have failed.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_table'
ORDER BY "timestamp", info
----
1  {"EventType": "drop_table", "Statement": "DROP TABLE test.public.a", "TableName": "test.public.a", "Tag": "DROP TABLE", "User": "root"}
1  {"EventType": "drop_table", "Statement": "DROP TABLE IF EXISTS test.public.b", "TableName": "test.public.b", "Tag": "DROP TABLE", "User": "root"}

# Verify the contents of the 'info' field of each event.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_table'
  AND info::JSONB->>'Statement' LIKE 'DROP TABLE test.public.a%'
----
1  {"EventType": "drop_table", "Statement": "DROP TABLE test.public.a", "TableName": "test.public.a", "Tag": "DROP TABLE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_table'
  AND info::JSONB->>'Statement' LIKE 'DROP TABLE IF EXISTS test.public.b%'
----
1  {"EventType": "drop_table", "Statement": "DROP TABLE IF EXISTS test.public.b", "TableName": "test.public.b", "Tag": "DROP TABLE", "User": "root"}

# Create + Rename table
##################

statement ok
CREATE TABLE toberenamed( id SERIAL PRIMARY KEY );

statement ok
ALTER TABLE toberenamed RENAME TO renamedtable;


# Verify that rename table event is logged
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'rename_table'
  AND info::JSONB->>'Statement' LIKE 'ALTER TABLE %toberenamed% RENAME TO %renamedtable%'
----
1  {"EventType": "rename_table", "NewTableName": "test.public.renamedtable", "Statement": "ALTER TABLE toberenamed RENAME TO renamedtable", "TableName": "test.public.toberenamed", "Tag": "ALTER TABLE", "User": "root"}


##################
# DATABASE DDL
##################

# Create two databases + superfluous "IF NOT EXISTS"
##################

statement ok
CREATE DATABASE eventlogtest

statement ok
CREATE DATABASE IF NOT EXISTS othereventlogtest

statement ok
CREATE DATABASE IF NOT EXISTS othereventlogtest


# Verify the two events that were logged.
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'create_database'
  AND info::JSONB->>'Statement' LIKE 'CREATE DATABASE eventlogtest%'
----
1  {"DatabaseName": "eventlogtest", "EventType": "create_database", "Statement": "CREATE DATABASE eventlogtest", "Tag": "CREATE DATABASE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'create_database'
  AND info::JSONB->>'Statement' LIKE 'CREATE DATABASE IF NOT EXISTS othereventlogtest%'
----
1  {"DatabaseName": "othereventlogtest", "EventType": "create_database", "Statement": "CREATE DATABASE IF NOT EXISTS othereventlogtest", "Tag": "CREATE DATABASE", "User": "root"}

# Add some tables to eventlogtest.
##################

statement ok
SET DATABASE = eventlogtest

statement ok
CREATE TABLE eventlogtest.testtable (id int PRIMARY KEY)

statement ok
CREATE TABLE eventlogtest.anothertesttable (id int PRIMARY KEY)

# drop both databases.
##################

statement ok
DROP DATABASE eventlogtest CASCADE

statement ok
DROP DATABASE IF EXISTS othereventlogtest CASCADE

statement ok
DROP DATABASE IF EXISTS othereventlogtest CASCADE

# verify contents of drop event
##################

# verify event is there, and cascading table drops are logged.

query IT
SELECT "reportingID",
       (info::JSONB - 'Timestamp' - 'DescriptorID')
       || (
			SELECT json_build_object(
					'DroppedSchemaObjects',
					json_agg(value ORDER BY value)
			       )
			  FROM ROWS FROM (
					json_array_elements((info::JSONB)->'DroppedSchemaObjects')
			       )
		)
  FROM system.eventlog
 WHERE "eventType" = 'drop_database'
       AND info::JSONB->>'Statement' LIKE 'DROP DATABASE eventlogtest%'
 ORDER BY "timestamp";
----
1  {"DatabaseName": "eventlogtest", "DroppedSchemaObjects": ["eventlogtest.public.anothertesttable", "eventlogtest.public.testtable"], "EventType": "drop_database", "Statement": "DROP DATABASE eventlogtest CASCADE", "Tag": "DROP DATABASE", "User": "root"}

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_database'
  AND info::JSONB->>'Statement' LIKE 'DROP DATABASE IF EXISTS othereventlogtest%'
----
1  {"DatabaseName": "othereventlogtest", "EventType": "drop_database", "Statement": "DROP DATABASE IF EXISTS othereventlogtest CASCADE", "Tag": "DROP DATABASE", "User": "root"}

statement ok
SET DATABASE = test

# Add a database.
##################

statement ok
CREATE DATABASE eventlogtorename

# rename database.
##################

statement ok
ALTER DATABASE eventlogtorename RENAME TO eventlogtonewname

# verify contents of database rename event
##################

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'rename_database'
  AND info::JSONB->>'Statement' LIKE 'ALTER DATABASE %eventlogtorename% RENAME TO %eventlogtonewname%'
----
1  {"DatabaseName": "eventlogtorename", "EventType": "rename_database", "NewDatabaseName": "eventlogtonewname", "Statement": "ALTER DATABASE eventlogtorename RENAME TO eventlogtonewname", "Tag": "ALTER DATABASE", "User": "root"}

statement ok
SET DATABASE = test

##################
# Cluster Settings
##################

# Set and unset a cluster setting
##################

skipif config 3node-tenant
statement ok
SET CLUSTER SETTING kv.allocator.load_based_lease_rebalancing.enabled = false

skipif config 3node-tenant
statement ok
SET CLUSTER SETTING kv.allocator.load_based_lease_rebalancing.enabled = DEFAULT

statement ok
PREPARE set_setting AS SET CLUSTER SETTING cluster.organization = $1

statement ok
EXECUTE set_setting('some string')

# verify setting changes are logged
##################
#
# The result differs in 3node-tenant because the
# kv.range_merge.queue_enabled cluster setting is not set.
skipif config 3node-tenant
query IIT
SELECT "targetID", "reportingID", "info"::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'set_cluster_setting'
AND info NOT LIKE '%version%' AND info NOT LIKE '%sql.defaults.distsql%' AND info NOT LIKE '%cluster.secret%'
AND info NOT LIKE '%sql.stats.automatic_collection.enabled%'
AND info NOT LIKE '%sql.defaults.vectorize%'
AND info NOT LIKE '%sql.testing%'
AND info NOT LIKE '%sql.defaults.experimental_distsql_planning%'
AND info NOT LIKE '%sql.defaults.use_declarative_schema_changer%'
ORDER BY "timestamp", info
----
0  1  {"ApplicationName": "$ internal-optInToDiagnosticsStatReporting", "EventType": "set_cluster_setting", "SettingName": "diagnostics.reporting.enabled", "Statement": "SET CLUSTER SETTING \"diagnostics.reporting.enabled\" = true", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "true"}
0  1  {"EventType": "set_cluster_setting", "SettingName": "kv.range_merge.queue_enabled", "Statement": "SET CLUSTER SETTING \"kv.range_merge.queue_enabled\" = false", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "false"}
0  1  {"EventType": "set_cluster_setting", "PlaceholderValues": ["5"], "SettingName": "sql.stats.automatic_collection.min_stale_rows", "Statement": "SET CLUSTER SETTING \"sql.stats.automatic_collection.min_stale_rows\" = $1::INT8", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "5"}
0  1  {"EventType": "set_cluster_setting", "SettingName": "sql.crdb_internal.table_row_statistics.as_of_time", "Statement": "SET CLUSTER SETTING \"sql.crdb_internal.table_row_statistics.as_of_time\" = e'-1\\u00B5s'", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "-00:00:00.000001"}
0  1  {"EventType": "set_cluster_setting", "SettingName": "kv.allocator.load_based_lease_rebalancing.enabled", "Statement": "SET CLUSTER SETTING \"kv.allocator.load_based_lease_rebalancing.enabled\" = false", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "false"}
0  1  {"EventType": "set_cluster_setting", "SettingName": "kv.allocator.load_based_lease_rebalancing.enabled", "Statement": "SET CLUSTER SETTING \"kv.allocator.load_based_lease_rebalancing.enabled\" = DEFAULT", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "DEFAULT"}
0  1  {"EventType": "set_cluster_setting", "PlaceholderValues": ["'some string'"], "SettingName": "cluster.organization", "Statement": "SET CLUSTER SETTING \"cluster.organization\" = $1", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "'some string'"}

onlyif config 3node-tenant
query IIT
SELECT "targetID", "reportingID", "info"::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'set_cluster_setting'
AND info NOT LIKE '%version%' AND info NOT LIKE '%sql.defaults.distsql%' AND info NOT LIKE '%cluster.secret%'
AND info NOT LIKE '%sql.stats.automatic_collection.enabled%'
AND info NOT LIKE '%sql.defaults.vectorize%'
AND info NOT LIKE '%sql.testing%'
AND info NOT LIKE '%sql.defaults.experimental_distsql_planning%'
AND info NOT LIKE '%sql.defaults.use_declarative_schema_changer%'
ORDER BY "timestamp", info
----
0  1  {"ApplicationName": "$ internal-optInToDiagnosticsStatReporting", "EventType": "set_cluster_setting", "SettingName": "diagnostics.reporting.enabled", "Statement": "SET CLUSTER SETTING \"diagnostics.reporting.enabled\" = true", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "true"}
0  1  {"EventType": "set_cluster_setting", "PlaceholderValues": ["5"], "SettingName": "sql.stats.automatic_collection.min_stale_rows", "Statement": "SET CLUSTER SETTING \"sql.stats.automatic_collection.min_stale_rows\" = $1::INT8", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "5"}
0  1  {"EventType": "set_cluster_setting", "SettingName": "sql.crdb_internal.table_row_statistics.as_of_time", "Statement": "SET CLUSTER SETTING \"sql.crdb_internal.table_row_statistics.as_of_time\" = e'-1\\u00B5s'", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "-00:00:00.000001"}
0  1  {"EventType": "set_cluster_setting", "PlaceholderValues": ["'some string'"], "SettingName": "cluster.organization", "Statement": "SET CLUSTER SETTING \"cluster.organization\" = $1", "Tag": "SET CLUSTER SETTING", "User": "root", "Value": "'some string'"}

# Set and unset zone configs
##################

statement ok
CREATE TABLE a (id INT PRIMARY KEY)

skipif config 3node-tenant
statement ok
ALTER TABLE a CONFIGURE ZONE USING range_max_bytes = 67108865, range_min_bytes = 16777216

skipif config 3node-tenant
statement ok
ALTER TABLE a CONFIGURE ZONE DISCARD

# verify zone config changes are logged
##################
skipif config 3node-tenant
query IT
SELECT "reportingID", "info"::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'set_zone_config'
ORDER BY "timestamp", info
----
1  {"EventType": "set_zone_config", "Options": ["range_max_bytes = 67108865", "range_min_bytes = 16777216"], "Statement": "ALTER TABLE \"\".\"\".a CONFIGURE ZONE USING range_max_bytes = 67108865, range_min_bytes = 16777216", "Tag": "CONFIGURE ZONE", "Target": "TABLE test.public.a", "User": "root"}

skipif config 3node-tenant
query IT
SELECT "reportingID", "info"::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'remove_zone_config'
ORDER BY "timestamp", info
----
1  {"EventType": "remove_zone_config", "Statement": "ALTER TABLE \"\".\"\".a CONFIGURE ZONE DISCARD", "Tag": "CONFIGURE ZONE", "Target": "TABLE test.public.a", "User": "root"}

statement ok
DROP TABLE a

# Sequences

statement ok
CREATE SEQUENCE s

statement ok
ALTER SEQUENCE s START 10

statement ok
DROP SEQUENCE s

query TIT
SELECT "eventType", "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" in ('create_sequence', 'alter_sequence', 'drop_sequence')
ORDER BY "timestamp", info
----
create_sequence  1  {"EventType": "create_sequence", "SequenceName": "test.public.s", "Statement": "CREATE SEQUENCE test.public.s", "Tag": "CREATE SEQUENCE", "User": "root"}
alter_sequence   1  {"EventType": "alter_sequence", "SequenceName": "test.public.s", "Statement": "ALTER SEQUENCE test.public.s START 10", "Tag": "ALTER SEQUENCE", "User": "root"}
drop_sequence    1  {"EventType": "drop_sequence", "SequenceName": "test.public.s", "Statement": "DROP SEQUENCE test.public.s", "Tag": "DROP SEQUENCE", "User": "root"}

# Views

statement ok
CREATE VIEW v AS SELECT 1

statement ok
DROP VIEW v

query TIT
SELECT "eventType", "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" in ('create_view', 'drop_view')
ORDER BY "timestamp", info
----
create_view  1  {"EventType": "create_view", "Statement": "CREATE VIEW \"\".\"\".v AS SELECT 1", "Tag": "CREATE VIEW", "User": "root", "ViewName": "test.public.v", "ViewQuery": "SELECT 1"}
drop_view    1  {"EventType": "drop_view", "Statement": "DROP VIEW test.public.v", "Tag": "DROP VIEW", "User": "root", "ViewName": "test.public.v"}


# Change privileges
##################

statement ok
CREATE TABLE a (id INT PRIMARY KEY)

statement ok
CREATE TABLE b (id INT PRIMARY KEY)

statement ok
CREATE VIEW c AS SELECT id FROM b

statement ok
CREATE SEQUENCE sq

statement ok
CREATE DATABASE dbt

statement ok
CREATE SCHEMA sc

statement ok
CREATE USER u

statement ok
CREATE USER v

statement ok
GRANT INSERT ON TABLE a,b TO u

statement ok
GRANT SELECT ON TABLE sq TO u

statement ok
GRANT SELECT ON TABLE c TO u

statement ok
GRANT CREATE ON DATABASE dbt TO u

statement ok
GRANT CREATE ON SCHEMA sc TO u

statement ok
REVOKE UPDATE ON TABLE a FROM u,v

statement ok
REVOKE CREATE ON SCHEMA sc FROM u,v

statement ok
REVOKE CREATE ON DATABASE dbt FROM u,v

statement ok
GRANT ALL ON * TO u

statement ok
REVOKE ALL ON * FROM u

query ITT
SELECT "reportingID", "info"::JSONB - 'Timestamp' - 'DescriptorID', "eventType"
FROM system.eventlog
WHERE "eventType" LIKE 'change_%_privilege'
ORDER BY "timestamp", info
----
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["INSERT"], "Grantee": "u", "Statement": "GRANT INSERT ON TABLE a, b TO u", "TableName": "a", "Tag": "GRANT", "User": "root"}                   change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["INSERT"], "Grantee": "u", "Statement": "GRANT INSERT ON TABLE a, b TO u", "TableName": "b", "Tag": "GRANT", "User": "root"}                   change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["SELECT"], "Grantee": "u", "Statement": "GRANT SELECT ON TABLE sq TO u", "TableName": "sq", "Tag": "GRANT", "User": "root"}                    change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["SELECT"], "Grantee": "u", "Statement": "GRANT SELECT ON TABLE c TO u", "TableName": "c", "Tag": "GRANT", "User": "root"}                      change_table_privilege
1  {"DatabaseName": "dbt", "EventType": "change_database_privilege", "GrantedPrivileges": ["CREATE"], "Grantee": "u", "Statement": "GRANT CREATE ON DATABASE dbt TO u", "Tag": "GRANT", "User": "root"}         change_database_privilege
1  {"EventType": "change_schema_privilege", "GrantedPrivileges": ["CREATE"], "Grantee": "u", "SchemaName": "sc", "Statement": "GRANT CREATE ON SCHEMA \"\".sc TO u", "Tag": "GRANT", "User": "root"}            change_schema_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["UPDATE"], "Statement": "REVOKE UPDATE ON TABLE a FROM u, v", "TableName": "a", "Tag": "REVOKE", "User": "root"}               change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "v", "RevokedPrivileges": ["UPDATE"], "Statement": "REVOKE UPDATE ON TABLE a FROM u, v", "TableName": "a", "Tag": "REVOKE", "User": "root"}               change_table_privilege
1  {"EventType": "change_schema_privilege", "Grantee": "u", "RevokedPrivileges": ["CREATE"], "SchemaName": "sc", "Statement": "REVOKE CREATE ON SCHEMA \"\".sc FROM u, v", "Tag": "REVOKE", "User": "root"}     change_schema_privilege
1  {"EventType": "change_schema_privilege", "Grantee": "v", "RevokedPrivileges": ["CREATE"], "SchemaName": "sc", "Statement": "REVOKE CREATE ON SCHEMA \"\".sc FROM u, v", "Tag": "REVOKE", "User": "root"}     change_schema_privilege
1  {"DatabaseName": "dbt", "EventType": "change_database_privilege", "Grantee": "u", "RevokedPrivileges": ["CREATE"], "Statement": "REVOKE CREATE ON DATABASE dbt FROM u, v", "Tag": "REVOKE", "User": "root"}  change_database_privilege
1  {"DatabaseName": "dbt", "EventType": "change_database_privilege", "Grantee": "v", "RevokedPrivileges": ["CREATE"], "Statement": "REVOKE CREATE ON DATABASE dbt FROM u, v", "Tag": "REVOKE", "User": "root"}  change_database_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["ALL"], "Grantee": "u", "Statement": "GRANT ALL ON TABLE * TO u", "TableName": "renamedtable", "Tag": "GRANT", "User": "root"}                 change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["ALL"], "Grantee": "u", "Statement": "GRANT ALL ON TABLE * TO u", "TableName": "a", "Tag": "GRANT", "User": "root"}                            change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["ALL"], "Grantee": "u", "Statement": "GRANT ALL ON TABLE * TO u", "TableName": "b", "Tag": "GRANT", "User": "root"}                            change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["ALL"], "Grantee": "u", "Statement": "GRANT ALL ON TABLE * TO u", "TableName": "c", "Tag": "GRANT", "User": "root"}                            change_table_privilege
1  {"EventType": "change_table_privilege", "GrantedPrivileges": ["ALL"], "Grantee": "u", "Statement": "GRANT ALL ON TABLE * TO u", "TableName": "sq", "Tag": "GRANT", "User": "root"}                           change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["ALL"], "Statement": "REVOKE ALL ON TABLE * FROM u", "TableName": "renamedtable", "Tag": "REVOKE", "User": "root"}             change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["ALL"], "Statement": "REVOKE ALL ON TABLE * FROM u", "TableName": "a", "Tag": "REVOKE", "User": "root"}                        change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["ALL"], "Statement": "REVOKE ALL ON TABLE * FROM u", "TableName": "b", "Tag": "REVOKE", "User": "root"}                        change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["ALL"], "Statement": "REVOKE ALL ON TABLE * FROM u", "TableName": "c", "Tag": "REVOKE", "User": "root"}                        change_table_privilege
1  {"EventType": "change_table_privilege", "Grantee": "u", "RevokedPrivileges": ["ALL"], "Statement": "REVOKE ALL ON TABLE * FROM u", "TableName": "sq", "Tag": "REVOKE", "User": "root"}                       change_table_privilege

statement ok
DROP DATABASE dbt

statement ok
DROP SEQUENCE sq

statement ok
DROP SCHEMA sc

statement ok
DROP VIEW c

statement ok
DROP TABLE a

statement ok
DROP TABLE b

statement ok
DROP USER u

statement ok
DROP USER v

# Schema events
##################

statement ok
CREATE SCHEMA s

statement ok
CREATE USER u

statement ok
CREATE SCHEMA AUTHORIZATION u

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'create_schema'
ORDER BY "timestamp", info
----
1  {"EventType": "create_schema", "Owner": "root", "SchemaName": "test.sc", "Statement": "CREATE SCHEMA \"\".sc", "Tag": "CREATE SCHEMA", "User": "root"}
1  {"EventType": "create_schema", "Owner": "root", "SchemaName": "test.s", "Statement": "CREATE SCHEMA \"\".s", "Tag": "CREATE SCHEMA", "User": "root"}
1  {"EventType": "create_schema", "Owner": "u", "SchemaName": "test.u", "Statement": "CREATE SCHEMA AUTHORIZATION u", "Tag": "CREATE SCHEMA", "User": "root"}

statement ok
ALTER SCHEMA u RENAME TO t

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'rename_schema'
----
1  {"EventType": "rename_schema", "NewSchemaName": "test.t", "SchemaName": "test.u", "Statement": "ALTER SCHEMA \"\".u RENAME TO t", "Tag": "ALTER SCHEMA", "User": "root"}

statement ok
DROP SCHEMA s, t

statement ok
DROP USER u

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_schema'
ORDER BY "timestamp", info
----
1  {"EventType": "drop_schema", "SchemaName": "test.sc", "Statement": "DROP SCHEMA \"\".sc", "Tag": "DROP SCHEMA", "User": "root"}
1  {"EventType": "drop_schema", "SchemaName": "test.s", "Statement": "DROP SCHEMA \"\".s, \"\".t", "Tag": "DROP SCHEMA", "User": "root"}
1  {"EventType": "drop_schema", "SchemaName": "test.t", "Statement": "DROP SCHEMA \"\".s, \"\".t", "Tag": "DROP SCHEMA", "User": "root"}


subtest eventlog_setting_disable

statement ok
SET CLUSTER SETTING server.eventlog.enabled = false

statement ok
CREATE ROLE rinvisible

statement ok
DROP ROLE rinvisible

query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" LIKE '%_role' AND info LIKE '%invisible%'
----


statement ok
SET CLUSTER SETTING server.eventlog.enabled = true



subtest alter_owner

statement ok
CREATE DATABASE atest;

statement ok
GRANT CREATE ON DATABASE atest TO testuser

user testuser

statement ok
CREATE SCHEMA atest.sc;
  CREATE TABLE atest.sc.t(x INT);
  CREATE TYPE atest.sc.ty AS ENUM ('foo');
  CREATE VIEW atest.sc.v AS SELECT x FROM atest.sc.t;
  CREATE SEQUENCE atest.sc.s

user root


# Observe the current ownership.
statement ok
PREPARE showOwners AS
  WITH db_id AS (
                SELECT id
                  FROM system.namespace
                 WHERE "parentID" = 0
                   AND "parentSchemaID" = 0
                   AND name = $1
             ),
       entities AS (
                    SELECT ns.id
                      FROM system.namespace AS ns
                      JOIN db_id ON (ns."parentID" = db_id.id)
                ),
      descs AS (
         SELECT crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor) AS jdesc
           FROM system.descriptor AS sd
           JOIN entities ON (entities.id = sd.id)
      )
SELECT jdesc->'schema'->>'name' AS schema, jdesc->'schema'->'privileges'->>'ownerProto' AS owner,
       jdesc->'type'->>'name' AS type, jdesc->'type'->'privileges'->>'ownerProto' AS owner,
       jdesc->'table'->>'name' AS object, jdesc->'table'->'privileges'->>'ownerProto' AS owner
       FROM descs
ORDER BY 1,2,3,4,5,6

query TTTTTT
EXECUTE showOwners('atest')
----
NULL    NULL      NULL  NULL      s     testuser
NULL    NULL      NULL  NULL      t     testuser
NULL    NULL      NULL  NULL      v     testuser
NULL    NULL      _ty   testuser  NULL  NULL
NULL    NULL      ty    testuser  NULL  NULL
public  admin     NULL  NULL      NULL  NULL
sc      testuser  NULL  NULL      NULL  NULL

statement ok
CREATE USER u;
  GRANT CREATE ON DATABASE atest TO u

statement ok
ALTER DATABASE atest OWNER TO u;
  ALTER SCHEMA atest.sc OWNER TO u;
  ALTER TABLE atest.sc.t OWNER TO u;
  ALTER TYPE atest.sc.ty OWNER TO u

# TODO(knz): ALTER VIEW OWNER is not supported yet
# TODO(knz): ALTER SEQUENCE OWNER is not supported yet
# See: https://github.com/cockroachdb/cockroach/issues/57965

# Observe/verify the ownership change.
query TTTTTT
EXECUTE showOwners('atest')
----
NULL    NULL   NULL  NULL  s     testuser
NULL    NULL   NULL  NULL  t     u
NULL    NULL   NULL  NULL  v     testuser
NULL    NULL   _ty   u     NULL  NULL
NULL    NULL   ty    u     NULL  NULL
public  admin  NULL  NULL  NULL  NULL
sc      u      NULL  NULL  NULL  NULL

# Verify that events were logged.
query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" LIKE '%_owner'
ORDER BY "timestamp", info
----
1  alter_database_owner  {"DatabaseName": "atest", "EventType": "alter_database_owner", "Owner": "u", "Statement": "ALTER DATABASE atest OWNER TO u", "Tag": "ALTER DATABASE OWNER", "User": "root"}
1  alter_schema_owner    {"EventType": "alter_schema_owner", "Owner": "u", "SchemaName": "atest.sc", "Statement": "ALTER SCHEMA atest.sc OWNER TO u", "Tag": "ALTER SCHEMA", "User": "root"}
1  alter_table_owner     {"EventType": "alter_table_owner", "Owner": "u", "Statement": "ALTER TABLE atest.sc.t OWNER TO u", "TableName": "atest.sc.t", "Tag": "ALTER TABLE OWNER", "User": "root"}
1  alter_type_owner      {"EventType": "alter_type_owner", "Owner": "u", "Statement": "ALTER TYPE atest.sc.ty OWNER TO u", "Tag": "ALTER TYPE", "TypeName": "atest.sc.ty", "User": "root"}
1  alter_type_owner      {"EventType": "alter_type_owner", "Owner": "u", "Statement": "ALTER TYPE atest.sc.ty OWNER TO u", "Tag": "ALTER TYPE", "TypeName": "atest.sc._ty", "User": "root"}

subtest alter_owner

statement ok
CREATE USER v;
  GRANT CREATE ON DATABASE atest TO v

statement ok
USE atest -- REASSIGN only works on the current database

statement ok
REASSIGN OWNED BY u TO testuser

statement ok
REASSIGN OWNED BY testuser TO v

# Observe/verify the ownership change.
query TTTTTT
EXECUTE showOwners('atest')
----
NULL    NULL   NULL  NULL  s     v
NULL    NULL   NULL  NULL  t     v
NULL    NULL   NULL  NULL  v     v
NULL    NULL   _ty   v     NULL  NULL
NULL    NULL   ty    v     NULL  NULL
public  admin  NULL  NULL  NULL  NULL
sc      v      NULL  NULL  NULL  NULL

# Verify that the ownership was transferred to v even including the view and sequence.
query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" LIKE '%_owner' AND info::JSONB->>'Owner' = 'v'
ORDER BY "timestamp", info
----
1  alter_database_owner  {"DatabaseName": "atest", "EventType": "alter_database_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "Tag": "REASSIGN OWNED BY", "User": "root"}
1  alter_schema_owner    {"EventType": "alter_schema_owner", "Owner": "v", "SchemaName": "atest.sc", "Statement": "REASSIGN OWNED BY testuser TO v", "Tag": "REASSIGN OWNED BY", "User": "root"}
1  alter_table_owner     {"EventType": "alter_table_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "TableName": "atest.sc.t", "Tag": "REASSIGN OWNED BY", "User": "root"}
1  alter_table_owner     {"EventType": "alter_table_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "TableName": "atest.sc.v", "Tag": "REASSIGN OWNED BY", "User": "root"}
1  alter_table_owner     {"EventType": "alter_table_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "TableName": "atest.sc.s", "Tag": "REASSIGN OWNED BY", "User": "root"}
1  alter_type_owner      {"EventType": "alter_type_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "Tag": "REASSIGN OWNED BY", "TypeName": "atest.sc.ty", "User": "root"}
1  alter_type_owner      {"EventType": "alter_type_owner", "Owner": "v", "Statement": "REASSIGN OWNED BY testuser TO v", "Tag": "REASSIGN OWNED BY", "TypeName": "atest.sc._ty", "User": "root"}

statement ok
USE defaultdb

statement ok
DROP DATABASE atest CASCADE;
 DROP USER v;
 DROP USER u

# Regression for #57734. Ensure that type names are fully qualified in the
# event log.
subtest regression_57734

statement ok
CREATE TYPE eventlog AS ENUM ('event', 'log')

query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" = 'create_type' AND info::JSONB->>'TypeName' LIKE '%eventlog'
ORDER BY "timestamp", info
----
1  create_type  {"EventType": "create_type", "Statement": "CREATE TYPE defaultdb.public.eventlog AS ENUM ('event', 'log')", "Tag": "CREATE TYPE", "TypeName": "defaultdb.public.eventlog", "User": "root"}

statement ok
ALTER TYPE eventlog ADD VALUE 'test'

statement ok
ALTER TYPE eventlog RENAME VALUE 'test' TO 'testing'

statement ok
CREATE SCHEMA testing

statement ok
ALTER TYPE eventlog SET SCHEMA testing;
ALTER TYPE testing.eventlog SET SCHEMA public

statement ok
ALTER TYPE eventlog RENAME TO eventlog_renamed

query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE ("eventType" = 'alter_type' OR "eventType" = 'rename_type') AND info::JSONB->>'TypeName' LIKE '%eventlog%'
ORDER BY "timestamp", info
----
1  alter_type   {"EventType": "alter_type", "Statement": "ALTER TYPE defaultdb.public.eventlog ADD VALUE 'test'", "Tag": "ALTER TYPE", "TypeName": "defaultdb.public.eventlog", "User": "root"}
1  alter_type   {"EventType": "alter_type", "Statement": "ALTER TYPE defaultdb.public.eventlog RENAME VALUE 'test' TO 'testing'", "Tag": "ALTER TYPE", "TypeName": "defaultdb.public.eventlog", "User": "root"}
1  alter_type   {"EventType": "alter_type", "Statement": "ALTER TYPE defaultdb.public.eventlog SET SCHEMA testing", "Tag": "ALTER TYPE", "TypeName": "defaultdb.public.eventlog", "User": "root"}
1  alter_type   {"EventType": "alter_type", "Statement": "ALTER TYPE defaultdb.testing.eventlog SET SCHEMA public", "Tag": "ALTER TYPE", "TypeName": "defaultdb.testing.eventlog", "User": "root"}
1  rename_type  {"EventType": "rename_type", "NewTypeName": "eventlog_renamed", "Statement": "ALTER TYPE defaultdb.public.eventlog RENAME TO eventlog_renamed", "Tag": "ALTER TYPE", "TypeName": "defaultdb.public.eventlog", "User": "root"}

statement ok
DROP TYPE eventlog_renamed

query ITT
SELECT "reportingID", "eventType", info::JSONB - 'Timestamp' - 'DescriptorID'
  FROM system.eventlog
 WHERE "eventType" = 'drop_type' AND info::JSONB->>'TypeName' LIKE '%eventlog%'
ORDER BY "timestamp", info
----
1  drop_type  {"EventType": "drop_type", "Statement": "DROP TYPE defaultdb.public.eventlog_renamed", "Tag": "DROP TYPE", "TypeName": "defaultdb.public.eventlog_renamed", "User": "root"}
1  drop_type  {"EventType": "drop_type", "Statement": "DROP TYPE defaultdb.public.eventlog_renamed", "Tag": "DROP TYPE", "TypeName": "defaultdb.public._eventlog_renamed", "User": "root"}


# Test the event logs generated by COMMENT ON ... commands.
subtest eventlog_comments

statement ok
CREATE TABLE a (id INT PRIMARY KEY, b INT NOT NULL)

statement ok
COMMENT ON COLUMN a.id IS 'This is a column.'

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'comment_on_column'
----
1  {"ColumnName": "id", "Comment": "This is a column.", "EventType": "comment_on_column", "Statement": "COMMENT ON COLUMN a.id IS 'This is a column.'", "TableName": "defaultdb.public.a", "Tag": "COMMENT ON COLUMN", "User": "root"}

statement ok
CREATE INDEX b_index ON a (b)

statement ok
COMMENT ON INDEX b_index IS 'This is an index.'

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'comment_on_index'
----
1  {"Comment": "This is an index.", "EventType": "comment_on_index", "IndexName": "b_index", "Statement": "COMMENT ON INDEX defaultdb.public.a@b_index IS 'This is an index.'", "TableName": "defaultdb.public.a", "Tag": "COMMENT ON INDEX", "User": "root"}

statement ok
COMMENT ON TABLE a IS 'This is a table.'

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'comment_on_table'
----
1  {"Comment": "This is a table.", "EventType": "comment_on_table", "Statement": "COMMENT ON TABLE defaultdb.public.a IS 'This is a table.'", "TableName": "defaultdb.public.a", "Tag": "COMMENT ON TABLE", "User": "root"}

# Test the event logs generated by commands that set schemas.
subtest set_schema

statement ok
ALTER TABLE a SET SCHEMA testing

statement ok
CREATE SEQUENCE s

statement ok
CREATE SCHEMA test_sc

statement ok
ALTER SEQUENCE s SET SCHEMA testing

statement ok
CREATE VIEW v AS SELECT 1

statement ok
ALTER VIEW v SET SCHEMA test_sc

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'set_schema'
ORDER BY "timestamp", info
----
1  {"DescriptorName": "defaultdb.public.eventlog", "DescriptorType": "type", "EventType": "set_schema", "NewDescriptorName": "defaultdb.testing.eventlog", "Statement": "ALTER TYPE defaultdb.public.eventlog SET SCHEMA testing", "Tag": "ALTER TYPE", "User": "root"}
1  {"DescriptorName": "defaultdb.testing.eventlog", "DescriptorType": "type", "EventType": "set_schema", "NewDescriptorName": "defaultdb.public.eventlog", "Statement": "ALTER TYPE defaultdb.testing.eventlog SET SCHEMA public", "Tag": "ALTER TYPE", "User": "root"}
1  {"DescriptorName": "defaultdb.public.a", "DescriptorType": "table", "EventType": "set_schema", "NewDescriptorName": "defaultdb.testing.a", "Statement": "ALTER TABLE a SET SCHEMA testing", "Tag": "ALTER TABLE SET SCHEMA", "User": "root"}
1  {"DescriptorName": "defaultdb.public.s", "DescriptorType": "sequence", "EventType": "set_schema", "NewDescriptorName": "defaultdb.testing.s", "Statement": "ALTER SEQUENCE s SET SCHEMA testing", "Tag": "ALTER TABLE SET SCHEMA", "User": "root"}
1  {"DescriptorName": "defaultdb.public.v", "DescriptorType": "view", "EventType": "set_schema", "NewDescriptorName": "defaultdb.test_sc.v", "Statement": "ALTER VIEW v SET SCHEMA test_sc", "Tag": "ALTER TABLE SET SCHEMA", "User": "root"}


# Test the event logs generated by commands that drop views.
subtest eventlog_dropped_views

statement ok
CREATE TABLE x (a INT PRIMARY KEY, b INT)

statement ok
CREATE VIEW y AS SELECT a FROM x

statement ok
CREATE VIEW z AS SELECT b FROM x

statement ok
DROP TABLE x CASCADE

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_table'
ORDER BY "timestamp" DESC, info
LIMIT 1
----
1  {"CascadeDroppedViews": ["defaultdb.public.y", "defaultdb.public.z"], "EventType": "drop_table", "Statement": "DROP TABLE defaultdb.public.x CASCADE", "TableName": "defaultdb.public.x", "Tag": "DROP TABLE", "User": "root"}

statement ok
CREATE TABLE t (i INT PRIMARY KEY, INDEX (i))

statement ok
CREATE VIEW v AS (SELECT i FROM t@t_i_idx)

statement ok
CREATE VIEW w AS (SELECT I FROM t@t_i_idx)

statement ok
DROP INDEX t@t_i_idx CASCADE

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'drop_index'
ORDER BY "timestamp" DESC, info
LIMIT 1
----
1  {"CascadeDroppedViews": ["defaultdb.public.v", "defaultdb.public.w"], "EventType": "drop_index", "IndexName": "t_i_idx", "MutationID": 1, "Statement": "DROP INDEX defaultdb.public.t@t_i_idx CASCADE", "TableName": "defaultdb.public.t", "Tag": "DROP INDEX", "User": "root"}

statement ok
CREATE TABLE x (a INT PRIMARY KEY, b INT)

statement ok
CREATE VIEW v AS SELECT b FROM x

statement ok
CREATE VIEW vv as SELECT b FROM x

statement ok
ALTER TABLE x DROP COLUMN b CASCADE

query IT
SELECT "reportingID", info::JSONB - 'Timestamp' - 'DescriptorID'
FROM system.eventlog
WHERE "eventType" = 'alter_table'
ORDER BY "timestamp" DESC, info
LIMIT 1
----
1  {"CascadeDroppedViews": ["defaultdb.public.v", "defaultdb.public.vv"], "EventType": "alter_table", "MutationID": 1, "Statement": "ALTER TABLE defaultdb.public.x DROP COLUMN b CASCADE", "TableName": "defaultdb.public.x", "Tag": "ALTER TABLE", "User": "root"}
