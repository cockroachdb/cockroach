# LogicTest: !local-mixed-25.4

let $canary_fraction
SHOW CLUSTER SETTING sql.stats.canary_fraction;

subtest delay_delete_with_manual_stats
# We test that for a table with canary stats rollout enabled (i.e. with
# a non-zero stats_canary_window), when a new stats is created, the
# deemed-to-be-obsolete stats will not be immediately deleted, but
# marked with delay_delete=true. The actual deletion will happen after
# another new stats is collected. Since the auto-stats collection is not
# deterministic in tests, we test with manual stats collection. If the
# existing stats are manual, collecting new stats would normally lead to
# its immediate removal. This is because we typically only retain the
# most recent 4 *auto* statistics. But with canary_window set, we should
# still see this manual stats after the new stats is collected, but
# marked with delay_delete=true.

statement ok
SET CLUSTER SETTING sql.stats.canary_fraction = 1;

statement ok
CREATE TABLE t (a INT PRIMARY KEY, b INT) WITH (sql_stats_canary_window = '15s')

statement ok
INSERT INTO t (a, b) SELECT i, i FROM generate_series(1, 1000) as g(i);
ANALYZE t;

query TTIB colnames,retry
SELECT statistics_name, column_names, row_count, delay_delete
FROM [SHOW STATISTICS FOR TABLE t] ORDER BY created DESC, statistics_name, column_names
----
statistics_name  column_names  row_count  delay_delete
NULL             {a}           1000       false
NULL             {b}           1000       false

# For a table with canary_window set, we don't immediately evict the
# existing most-recent stats (row_count=1000) right away, but mark it
# with delay_delete=true.
statement ok
INSERT INTO t (a) SELECT * FROM generate_series(1001, 2000);
ANALYZE t;

query TTIB colnames,retry
SELECT statistics_name, column_names, row_count, delay_delete
FROM [SHOW STATISTICS FOR TABLE t] ORDER BY created DESC, statistics_name, column_names
----
statistics_name  column_names  row_count  delay_delete
NULL             {a}           2000       false
NULL             {b}           2000       false
NULL             {a}           1000       true
NULL             {b}           1000       true

statement ok
INSERT INTO t (a) SELECT * FROM generate_series(2001, 3000);
CREATE STATISTICS s FROM t;

# The previously marked stats (row_count=1000) is now deleted,
# and the current most-recent stats (row_count=2000) is marked with
# delay_delete=true.
query TTIB colnames,retry
SELECT statistics_name, column_names, row_count, delay_delete
FROM [SHOW STATISTICS FOR TABLE t] ORDER BY created DESC, statistics_name, column_names
----
statistics_name  column_names  row_count  delay_delete
s                {a}           3000       false
s                {b}           3000       false
NULL             {a}           2000       true
NULL             {b}           2000       true

# Test with new stats collected only on column a, which means
# deleteOtherStats = false.
# The other column (b) should not be affected.
statement ok
INSERT INTO t (a) SELECT * FROM generate_series(3001, 4000);
CREATE STATISTICS s_a2 ON a FROM t

query TTIB colnames,retry
SELECT statistics_name, column_names, row_count, delay_delete
FROM [SHOW STATISTICS FOR TABLE t] ORDER BY created DESC, statistics_name, column_names
----
statistics_name  column_names  row_count  delay_delete
s_a2             {a}           4000       false
s                {a}           3000       true
s                {b}           3000       false
NULL             {b}           2000       true

# But such 2-phases deletion is disabled for table with canary_window unset.
statement ok
ALTER TABLE t SET (sql_stats_canary_window = '0s');

statement ok
INSERT INTO t (a) SELECT * FROM generate_series(4001, 5000);
ANALYZE t;

query TTIB colnames,retry
SELECT statistics_name, column_names, row_count, delay_delete
FROM [SHOW STATISTICS FOR TABLE t] ORDER BY created DESC, statistics_name, column_names
----
statistics_name  column_names  row_count  delay_delete
NULL             {a}           5000       false
NULL             {b}           5000       false

subtest end

statement ok
SET CLUSTER SETTING sql.stats.canary_fraction = $canary_fraction;
