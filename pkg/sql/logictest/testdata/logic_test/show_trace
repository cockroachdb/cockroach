# LogicTest: local local-opt

# Prepare a trace to be inspected below.

statement ok
SET tracing = on; BEGIN; SELECT 1; COMMIT; SELECT 2; SET tracing = off

# Inspect the trace: we exclude messages containing newlines as these
# may contain non-deterministic txn object descriptions.
# This also checks that the span column properly reports separate
# SQL transactions.
# We replace the command position because the values depend on exactly
# how many commands we ran in the session.
query ITT
SELECT
  span, regexp_replace(message, 'pos:[0-9]*', 'pos:?'), operation
FROM [SHOW TRACE FOR SESSION]
WHERE message LIKE '%SPAN START%' OR message LIKE '%pos%executing%';
----
0  === SPAN START: session recording ===                session recording
0  [NoTxn pos:?] executing ExecStmt: BEGIN TRANSACTION  session recording
1  === SPAN START: sql txn ===                          sql txn
1  [Open pos:?] executing ExecStmt: SELECT 1            sql txn
2  === SPAN START: consuming rows ===                   consuming rows
1  [Open pos:?] executing ExecStmt: COMMIT TRANSACTION  sql txn
0  [NoTxn pos:?] executing ExecStmt: SELECT 2           session recording
3  === SPAN START: sql txn ===                          sql txn
3  [Open pos:?] executing ExecStmt: SELECT 2            sql txn
4  === SPAN START: consuming rows ===                   consuming rows
0  [NoTxn pos:?] executing ExecStmt: SET TRACING = off  session recording

## TODO(tschottdorf): re-enable
# statement ok
# CREATE TABLE t.enginestats(k INT PRIMARY KEY, v INT)
#
# statement ok
# SHOW TRACE FOR SELECT * FROM t.enginestats
#
# query T
# SELECT message FROM [ SHOW TRACE FOR SESSION ] WHERE message LIKE '%InternalDelete%'
# ----
# engine stats: {InternalDeleteSkippedCount:0 TimeBoundNumSSTs:0}

# Check that we can run set tracing regardless of the current tracing state.
# This is convenient; sometimes it's unclear, for example, if you previously
# stopped tracing or not, so issuing a set tracing=off should just work.
subtest idempotent

statement ok
SET tracing = on; SET tracing = on;

statement ok
SET tracing = off; SET tracing = off;

# Check that we can run set tracing in the aborted state (this is implemented by
# making set tracing an ObserverStmt). This is very convenient for clients that
# start tracing, then might get an error, then want to stop tracing.
subtest aborted_txn

query error pq: foo
BEGIN; SELECT crdb_internal.force_error('', 'foo')

statement ok
SET tracing = off

statement ok
ROLLBACK

subtest replica

statement ok
CREATE TABLE t (a INT PRIMARY KEY)

statement ok
SET tracing = on; SELECT * FROM t; SET tracing = off

query III colnames
SELECT DISTINCT node_id, store_id, replica_id
  FROM [SHOW EXPERIMENTAL_REPLICA TRACE FOR SESSION]
----
node_id  store_id  replica_id
1        1         1
