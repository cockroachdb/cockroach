# LogicTest: !local-legacy-schema-changer !local-mixed-24.3 !local-mixed-25.1

subtest setup

let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
CREATE DATABASE db1;

statement ok
USE db1;

statement ok
GRANT ADMIN to testuser;

subtest create_drop_sanity

statement ok
CREATE TABLE sanity1();

statement ok
CREATE POLICY p1 on sanity1 USING (true);

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog order by timestamp desc limit 1;
----
create_policy

statement error pq: policy with name "p1" already exists on table "sanity1"
CREATE POLICY p1 on sanity1 WITH CHECK (true);

statement notice NOTICE: policy "p1" already exists on table "sanity1", skipping
CREATE POLICY IF NOT EXISTS p1 on sanity1;

statement ok
CREATE POLICY IF NOT EXISTS p2 on sanity1 AS PERMISSIVE WITH CHECK (true);

query TT
SHOW CREATE TABLE sanity1;
----
sanity1  CREATE TABLE public.sanity1 (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT sanity1_pkey PRIMARY KEY (rowid ASC)
         );
         CREATE POLICY p1 ON public.sanity1 AS PERMISSIVE FOR ALL TO public USING (true);
         CREATE POLICY p2 ON public.sanity1 AS PERMISSIVE FOR ALL TO public WITH CHECK (true)

statement notice NOTICE: relation "nonexist" does not exist, skipping
DROP POLICY IF EXISTS notthere on nonexist;

statement notice NOTICE: policy "notthere" for relation "sanity1" does not exist, skipping
DROP POLICY IF EXISTS notthere on sanity1;

statement error pq: policy "notthere" for table "sanity1" does not exist
DROP POLICY notthere on sanity1;

statement ok
DROP POLICY p1 on sanity1;

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog order by timestamp desc limit 1;
----
drop_policy

statement ok
DROP POLICY p2 on sanity1;

statement ok
CREATE POLICY newp1 on sanity1 AS PERMISSIVE USING (true) WITH CHECK (true);

statement ok
DROP TABLE sanity1;

subtest explicit_txn

statement ok
CREATE TABLE explicit1();

statement ok
SET use_declarative_schema_changer = 'unsafe_always';

statement ok
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

statement ok
CREATE POLICY p1 on explicit1;

statement ok
DROP POLICY p1 on explicit1;

statement ok
CREATE POLICY IF NOT EXISTS p1 on explicit1 AS PERMISSIVE USING (false);

statement ok
COMMIT;

statement ok
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

statement ok
DROP POLICY p1 on explicit1;

statement ok
CREATE POLICY p1 on explicit1 USING (false) WITH CHECK (true);

statement ok
COMMIT;

statement ok
DROP TABLE explicit1;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

subtest policy_type_and_command_ddl

statement ok
CREATE TABLE multi_pol_tab1 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy1" ON multi_pol_tab1 AS PERMISSIVE

statement ok
CREATE POLICY "policy2" ON multi_pol_tab1 AS RESTRICTIVE

statement ok
CREATE POLICY IF NOT EXISTS "policy3" ON multi_pol_tab1 FOR ALL

statement ok
CREATE POLICY "policy4" ON multi_pol_tab1 FOR INSERT

statement ok
CREATE POLICY "policy5" ON multi_pol_tab1 FOR UPDATE

statement ok
CREATE POLICY "policy6" ON multi_pol_tab1 FOR DELETE

statement ok
CREATE POLICY "policy7" ON multi_pol_tab1 FOR SELECT

statement ok
CREATE USER papa_roach

statement ok
CREATE POLICY "policy8" ON multi_pol_tab1 FOR ALL TO papa_roach, public

query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                );
                CREATE POLICY policy1 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy3 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy5 ON public.multi_pol_tab1 AS PERMISSIVE FOR UPDATE TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy
----
oid  polname  polrelid  polcmd  polpermissive  polroles       polqual  polwithcheck
1    policy1  110       *       true           {0}            NULL     NULL
2    policy2  110       *       false          {0}            NULL     NULL
3    policy3  110       *       true           {0}            NULL     NULL
4    policy4  110       a       true           {0}            NULL     NULL
5    policy5  110       w       true           {0}            NULL     NULL
6    policy6  110       d       true           {0}            NULL     NULL
7    policy7  110       r       true           {0}            NULL     NULL
8    policy8  110       *       true           {0,835509264}  NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies
----
schemaname  tablename       policyname  permissive   roles                cmd     qual  with_check
public      multi_pol_tab1  policy1     permissive   {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy2     restrictive  {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy3     permissive   {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy4     permissive   {public}             INSERT  NULL  NULL
public      multi_pol_tab1  policy5     permissive   {public}             UPDATE  NULL  NULL
public      multi_pol_tab1  policy6     permissive   {public}             DELETE  NULL  NULL
public      multi_pol_tab1  policy7     permissive   {public}             SELECT  NULL  NULL
public      multi_pol_tab1  policy8     permissive   {public,papa_roach}  ALL     NULL  NULL

query TTTTTT colnames,rowsort
SHOW POLICIES FOR multi_pol_tab1
----
name     cmd     type         roles                using_expr  with_check_expr
policy1  ALL     permissive   {public}             ·           ·
policy2  ALL     restrictive  {public}             ·           ·
policy3  ALL     permissive   {public}             ·           ·
policy4  INSERT  permissive   {public}             ·           ·
policy5  UPDATE  permissive   {public}             ·           ·
policy6  DELETE  permissive   {public}             ·           ·
policy7  SELECT  permissive   {public}             ·           ·
policy8  ALL     permissive   {public,papa_roach}  ·           ·

statement ok
CREATE DATABASE roachdb

statement ok
USE roachdb

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies
----
schemaname  tablename  policyname  permissive  roles  cmd  qual  with_check

statement ok
USE db1

statement ok
DROP DATABASE roachdb

statement ok
CREATE TABLE multi_pol_tab2 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy9" ON multi_pol_tab2 FOR ALL

statement ok
CREATE POLICY "policy10" ON multi_pol_tab2 FOR ALL

statement ok
CREATE TABLE multi_pol_tab3 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy11" ON multi_pol_tab3 FOR ALL

statement ok
CREATE POLICY "policy12" ON multi_pol_tab3 FOR ALL

skipif config fakedist-vec-off local-vec-off
query T
EXPLAIN (PLAN) select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab2'::regclass
----
distribution: local
vectorized: true
·
• render
│
└── • virtual table
      table: pg_policy@pg_policy_polrelid_idx
      spans: [/multi_pol_tab2 - /multi_pol_tab2]

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab2'::regclass
----
oid  polname   polrelid  polcmd  polpermissive  polroles  polqual  polwithcheck
1    policy9   113       *       true           {0}       NULL     NULL
2    policy10  113       *       true           {0}       NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies where tablename = 'multi_pol_tab2'
----
schemaname  tablename       policyname  permissive  roles     cmd  qual  with_check
public      multi_pol_tab2  policy9     permissive  {public}  ALL  NULL  NULL
public      multi_pol_tab2  policy10    permissive  {public}  ALL  NULL  NULL

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab3'::regclass
----
oid  polname   polrelid  polcmd  polpermissive  polroles  polqual  polwithcheck
1    policy11  114       *       true           {0}       NULL     NULL
2    policy12  114       *       true           {0}       NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies where tablename = 'multi_pol_tab3'
----
schemaname  tablename       policyname  permissive  roles     cmd  qual  with_check
public      multi_pol_tab3  policy11    permissive  {public}  ALL  NULL  NULL
public      multi_pol_tab3  policy12    permissive  {public}  ALL  NULL  NULL

query TTTTTT colnames,rowsort
SHOW POLICIES FOR multi_pol_tab2
----
name      cmd  type        roles     using_expr  with_check_expr
policy9   ALL  permissive  {public}  ·           ·
policy10  ALL  permissive  {public}  ·           ·

query TTTTTT colnames,rowsort
SHOW POLICIES FOR public.multi_pol_tab3
----
name      cmd  type        roles     using_expr  with_check_expr
policy11  ALL  permissive  {public}  ·           ·
policy12  ALL  permissive  {public}  ·           ·

statement ok
DROP POLICY "policy1" ON multi_pol_tab1

statement ok
DROP POLICY "policy3" ON multi_pol_tab1

statement ok
DROP POLICY "policy5" ON multi_pol_tab1

query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                );
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach

statement ok
DROP POLICY "policy9" ON multi_pol_tab2

statement ok
DROP POLICY "policy10" ON multi_pol_tab2

statement ok
DROP POLICY "policy11" ON multi_pol_tab3

statement ok
DROP POLICY "policy12" ON multi_pol_tab3

statement ok
DROP TABLE multi_pol_tab1

statement ok
DROP TABLE multi_pol_tab2

statement ok
DROP TABLE multi_pol_tab3

subtest drop_role_is_blocked

statement ok
CREATE TABLE drop_role_chk();

statement ok
CREATE USER fred;

statement ok
CREATE USER bob;

statement ok
CREATE POLICY p1 on drop_role_chk to fred,bob;

statement error pq: role "bob" cannot be dropped because some objects depend on it\nDETAIL: target of policy "p1" on table "drop_role_chk"
DROP ROLE bob;

statement error pq: role "fred" cannot be dropped because some objects depend on it\nDETAIL: target of policy "p1" on table "drop_role_chk"
DROP ROLE fred;

statement ok
DROP POLICY p1 on drop_role_chk;

statement ok
DROP ROLE bob,fred;

statement ok
DROP TABLE drop_role_chk;

subtest role_doesnt_exist

statement ok
CREATE TABLE role_exist_chk();

statement error pq: role/user "zeke" does not exist
CREATE POLICY IF NOT EXISTS p1 on role_exist_chk to zeke;

statement ok
CREATE USER zeke;

statement ok
CREATE POLICY p1 on role_exist_chk to zeke;

statement ok
DROP TABLE role_exist_chk;

statement ok
DROP ROLE zeke;

subtest current_session_and_user

statement ok
CREATE TABLE target();

statement ok
CREATE USER john;

statement ok
GRANT ALL ON db1.* to testuser;

statement ok
GRANT ALL ON db1.* to john;

statement ok
ALTER TABLE target OWNER TO john;

statement ok
GRANT SYSTEM MODIFYCLUSTERSETTING TO testuser;

user testuser

statement ok
USE db1;

statement ok
SET ROLE john;

query TT
SELECT current_user, session_user
----
john testuser

statement ok
CREATE POLICY pol on target TO current_user,session_user;

query TT
SHOW CREATE TABLE target
----
target  CREATE TABLE public.target (
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT target_pkey PRIMARY KEY (rowid ASC)
        );
        CREATE POLICY pol ON public.target AS PERMISSIVE FOR ALL TO john, testuser

user root

statement ok
USE db1;

query TT
SELECT current_user, session_user
----
root root

statement error pq: role "john" cannot be dropped because some objects depend on it\nDETAIL: target of policy "pol" on table "target"
DROP ROLE john;

statement error pq: role "testuser" cannot be dropped because some objects depend on it\nDETAIL: target of policy "pol" on table "target"
DROP ROLE testuser;

statement ok
DROP TABLE target;

statement ok
DROP ROLE john;

subtest udt_ref

statement ok
CREATE TYPE greeting AS ENUM ('hello', 'hi', 'howdy');

statement ok
CREATE TABLE z1 (c1 text);

statement ok
CREATE POLICY IF NOT EXISTS p1 on z1 WITH CHECK (c1::greeting = 'hi'::greeting);

query T rowsort
select polwithcheck from pg_catalog.pg_policy
----
c1::public.greeting = 'hi':::public.greeting

query T rowsort
select with_check_expr from [SHOW POLICIES FOR z1];
----
c1::public.greeting = 'hi':::public.greeting

statement error pq: cannot drop type "greeting" because other objects \(\[db1\.public\.z1\]\) still depend on it
DROP TYPE greeting;

statement ok
SET use_declarative_schema_changer = 'off';

statement error pq: cannot drop type "greeting" because other objects \(\[db1\.public\.z1\]\) still depend on it
DROP TYPE greeting;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement ok
DROP POLICY p1 on z1;

statement ok
DROP TYPE greeting;

statement error pq: type "greeting" does not exist
CREATE POLICY p1 on z1 WITH CHECK (c1::greeting = 'hi'::greeting);

statement ok
DROP TABLE z1;

subtest seq_ref

statement ok
CREATE SEQUENCE seq1;

statement ok
CREATE TABLE pws ();

statement ok
CREATE POLICY p1 on pws AS RESTRICTIVE WITH CHECK (nextval('seq1') < 100);

statement error pq: cannot drop sequence seq1 because other objects depend on it
DROP SEQUENCE seq1;

statement ok
DROP POLICY p1 on pws;

statement ok
DROP SEQUENCE seq1;

statement ok
DROP TABLE pws;

subtest func_ref

statement ok
CREATE FUNCTION is_valid(n INT) RETURNS BOOL AS $$
BEGIN
  RETURN n < 10;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TABLE funcref (c1 int);

statement ok
CREATE POLICY pol1 on funcref USING (is_valid(c1)) WITH CHECK (is_valid(c1));

query T
select polqual from pg_catalog.pg_policy
----
public.is_valid(c1)

query T rowsort
select using_expr from [SHOW POLICIES FOR funcref];
----
public.is_valid(c1)

query TT colnames,rowsort
select qual, with_check from pg_catalog.pg_policies where tablename = 'funcref'
----
qual                 with_check
public.is_valid(c1)  public.is_valid(c1)

statement error pq: cannot drop function "is_valid" because other objects \(\[db1.public.funcref\]\) still depend on it
DROP FUNCTION is_valid;

statement ok
DROP POLICY pol1 on funcref;

statement ok
DROP FUNCTION is_valid;

statement ok
DROP TABLE funcref;

subtest col_ref

statement ok
CREATE TABLE colref (rename_c1 INT, rename_c2 INT, C3 INT);

statement ok
CREATE POLICY p1 ON colref USING (rename_c1 < 10);

statement ok
CREATE POLICY p2 ON colref WITH CHECK (rename_c2 < 100);

# Attempt to alter/drop column referenced in USING expression
statement ok
ALTER TABLE colref RENAME COLUMN rename_c1 to c1;

statement error pq: cannot drop column "c1" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c1;

statement ok
SET use_declarative_schema_changer = 'off';

statement error pq: cannot drop column "c1" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c1;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement error pq: cannot alter type of column "c1" because it is referenced in a policy expression
ALTER TABLE colref ALTER COLUMN c1 SET DATA TYPE TEXT USING c1::text;

statement ok
DROP POLICY p1 ON colref;

statement ok
ALTER TABLE colref ALTER COLUMN c1 SET DATA TYPE TEXT USING c1::text;

statement ok
ALTER TABLE colref DROP COLUMN c1;

# Repeat for a column referenced with WITH CHECK expression
statement ok
ALTER TABLE colref RENAME COLUMN rename_c2 TO c2;

statement error pq: cannot drop column "c2" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c2;

statement ok
SET use_declarative_schema_changer = 'off';

statement error pq: cannot drop column "c2" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c2;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement error pq: cannot alter type of column "c2" because it is referenced in a policy expression
ALTER TABLE colref ALTER COLUMN c2 SET DATA TYPE TEXT USING c2::text;

statement ok
DROP POLICY p2 ON colref;

statement ok
ALTER TABLE colref ALTER COLUMN c2 SET DATA TYPE TEXT USING c2::text;

statement ok
ALTER TABLE colref DROP COLUMN c2;

statement ok
DROP TABLE colref;

subtest no_subvar_expr

statement ok
CREATE TABLE t1 (c1 int);

statement ok
CREATE TABLE t2 (c1 int);

statement error pq: variable sub-expressions are not allowed in POLICY USING
CREATE POLICY p1 on t1 USING (c1 < (select max(c1) from t1));

statement error pq: variable sub-expressions are not allowed in POLICY WITH CHECK
CREATE POLICY p1 on t1 WITH CHECK (c1 < (select max(c1) from t1));

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

subtest create_policy_udt_using_check

statement ok
create type roach_type as enum('flying','crawling')

statement ok
create table flying_roaches (check ('flying'::roach_type = 'crawling'::roach_type))

statement ok
create policy p1 on flying_roaches using ('flying'::roach_type = 'crawling'::roach_type)

query TT
SHOW CREATE TABLE flying_roaches
----
flying_roaches  CREATE TABLE public.flying_roaches (
                  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
                  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
                );
                CREATE POLICY p1 ON public.flying_roaches AS PERMISSIVE FOR ALL TO public USING ('flying':::public.roach_type = 'crawling':::public.roach_type)

query T
select create_statement from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
CREATE TABLE public.flying_roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
)

query T
select rls_statements from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
{"CREATE POLICY p1 ON public.flying_roaches AS PERMISSIVE FOR ALL TO public USING ('flying':::public.roach_type = 'crawling':::public.roach_type)"}

query T
select alter_statements from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
{}

statement ok
drop table flying_roaches

statement ok
drop type roach_type

subtest alter_table_rls_legacy_unimplemented

statement ok
SET use_declarative_schema_changer = 'off';

statement ok
CREATE TABLE roaches();

statement error pq: ALTER TABLE ... ROW LEVEL SECURITY is only implemented in the declarative schema changer
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

subtest alter_table_rls_enable_disable

statement ok
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY;

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         );
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY

statement ok
ALTER TABLE roaches DISABLE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  false

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         )

subtest alter_table_rls_force_no_force

statement ok
ALTER TABLE roaches FORCE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  true

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         );
         ALTER TABLE public.roaches FORCE ROW LEVEL SECURITY

statement ok
ALTER TABLE roaches NO FORCE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  false

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         )

subtest alter_table_rls_enable_force

statement ok
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         );
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  true  true

query T
select create_statement from crdb_internal.create_statements where descriptor_name='roaches'
----
CREATE TABLE public.roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
)

query TTT
select rls_statements, alter_statements, create_nofks from crdb_internal.create_statements where descriptor_name='roaches'
----
{"ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY"}  {}  CREATE TABLE public.roaches (
                                                                                          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                                                                                          CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
                                                                                        )

statement ok
ALTER TABLE roaches DISABLE ROW LEVEL SECURITY, NO FORCE ROW LEVEL SECURITY;

query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         )

query T
select rls_statements from crdb_internal.create_statements where descriptor_name='roaches'
----
{}

query T
select alter_statements from crdb_internal.create_statements where descriptor_name='roaches'
----
{}

statement ok
DROP TABLE roaches;

subtest using_expression_applied

statement ok
CREATE TYPE league AS ENUM('AL','NL');

statement ok
CREATE TABLE bbteams (team text, league league, family (team, league));

statement ok
ALTER TABLE bbteams ENABLE ROW LEVEL SECURITY;

statement ok
INSERT INTO bbteams VALUES ('jays', 'AL'), ('tigers', 'AL'), ('cardinals', 'NL'), ('orioles', 'AL'), ('nationals', 'NL');

# Confirm admin user can see all rows
query TT
select team, league from bbteams order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

statement ok
CREATE USER buck;

statement ok
GRANT ALL ON bbteams TO buck;

statement ok
set role buck

# user buck can't see anything because they aren't admin, rls is enabled and no policies are defined.
query TT
select team, league from bbteams order by league, team;
----

statement ok
set role root

# We will create a function and a sequence to include in the expression, as
# these introduce additional dependencies compared to a plain expression using
# basic types.
statement ok
CREATE FUNCTION is_valid(l league) RETURNS BOOL AS $$
BEGIN
  RETURN l = 'AL';
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE SEQUENCE seq1;

statement ok
GRANT USAGE ON seq1 TO buck;

statement ok
create policy restrict_select on bbteams for select to buck,current_user,session_user using (is_valid(league) and nextval('seq1') < 1000);

query T rowsort
select using_expr from [SHOW POLICIES FOR bbteams];
----
public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8)

# confirm admin can see all
query TT
select team, league from bbteams where team != 'cardinals' order by league, team;
----
jays AL
orioles AL
tigers AL
nationals NL

statement ok
set role buck

# Retry the same query issue before to ensure memo is properly invalidated.
query TT
select team, league from bbteams where team != 'cardinals' order by league, team;
----
jays AL
orioles AL
tigers AL

# Try another query we know isn't in the statement cache.
query TT
select team, league from bbteams where team != 'astros' order by league, team;
----
jays AL
orioles AL
tigers AL

# Verify that if admin is granted to user buck, it sees all rows because RLS is exempt.
statement ok
set role root

statement ok
GRANT admin TO buck;

statement ok
set role buck;

# This is the same query as before, but since admin changed, we will see all of the rows.
query TT
select team, league from bbteams where team != 'astros' order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

# Retry with a query never tried before so we avoid the statement cache.
query TT
select team, league from bbteams where team != 'mariners' order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

statement ok
set role root

statement ok
REVOKE admin FROM buck;

statement ok
set role buck

# Retry same query we ran before to ensure it's properly invalidated in the statement cache.
query TT
select team, league from bbteams where team != 'mariners' order by league, team;
----
jays AL
orioles AL
tigers AL

statement ok
set role root

# Add policies that apply to other commands. Only SELECT will return rows.
statement ok
CREATE POLICY restrict_insert ON bbteams FOR INSERT TO buck WITH CHECK (false);

statement ok
CREATE POLICY IF NOT EXISTS restrict_delete ON bbteams FOR DELETE TO buck USING (false);

statement ok
CREATE POLICY restrict_update ON bbteams FOR UPDATE TO buck USING (false);

statement ok
set role buck

# Verify SELECT will use the original policy that restricts rows just to AL teams
query TT
select team, league from bbteams where team != 'jays' order by league, team;
----
orioles AL
tigers AL

# Try updating a row. The policy for update will prevent us from reading the row.
statement ok
UPDATE bbteams SET team = 'blue jays' where team = 'jays';

query TT
select team, league from bbteams order by league, team;
----
jays AL
orioles AL
tigers AL

# Switch the policy to allow an update, but only for rows in the AL league.
statement ok
set role root

statement ok
DROP POLICY restrict_update on bbteams;

statement ok
create policy restrict_update on bbteams for update to buck using (is_valid(league) and nextval('seq1') < 1000);

statement ok
set role buck

# Allowed
statement ok
UPDATE bbteams SET team = 'Jays' where team = 'jays';

# Not allowed
statement ok
UPDATE bbteams SET team = 'Nationals' where team = 'nationals';

statement ok
set role root

query TT
select team, league from bbteams where team in ('jays', 'Jays', 'nationals', 'Nationals') order by league, team;
----
Jays AL
nationals NL

statement ok
set role buck

# Try to delete the row. The delete policy will prevent us from reading the row.
statement ok
DELETE FROM bbteams;

query TT
select team, league from bbteams order by league, team;
----
Jays     AL
orioles  AL
tigers   AL

# Switch the delete policy to allow deletion of only the tigers
statement ok
set role root

statement ok
DROP POLICY restrict_delete on bbteams;

statement ok
create policy restrict_delete on bbteams for delete to buck using (is_valid(league) and team = 'tigers' and nextval('seq1') < 1000);

statement ok
set role buck

statement ok
DELETE FROM bbteams WHERE team != 'pirates';

query TT
select team, league from bbteams where team != 'pirates' order by league, team;
----
Jays     AL
orioles  AL

query TT
SHOW CREATE TABLE bbteams
----
bbteams  CREATE TABLE public.bbteams (
           team STRING NULL,
           league public.league NULL,
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT bbteams_pkey PRIMARY KEY (rowid ASC),
           FAMILY fam_0_team_league_rowid (team, league, rowid)
         );
         ALTER TABLE public.bbteams ENABLE ROW LEVEL SECURITY;
         CREATE POLICY restrict_select ON public.bbteams AS PERMISSIVE FOR SELECT TO buck, root USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_insert ON public.bbteams AS PERMISSIVE FOR INSERT TO buck WITH CHECK (false);
         CREATE POLICY restrict_update ON public.bbteams AS PERMISSIVE FOR UPDATE TO buck USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_delete ON public.bbteams AS PERMISSIVE FOR DELETE TO buck USING ((public.is_valid(league) AND (team = 'tigers':::STRING)) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8))

statement ok
set role root

statement ok
DROP TABLE bbteams;

statement ok
DROP SEQUENCE seq1;

statement ok
DROP FUNCTION is_valid;

# This subtest verifies proper cleanup of policy elements when dropping with CASCADE.
subtest drop_with_cascade

statement ok
CREATE DATABASE db2;

statement ok
use db2;

statement ok
CREATE TYPE classes AS ENUM('mammals','birds', 'fish', 'reptiles', 'amphibians');

statement ok
CREATE TABLE animals (name text, class classes, family (name, class));

statement ok
ALTER TABLE animals ENABLE ROW LEVEL SECURITY;

statement ok
create policy p1 on animals for select to current_user using (class in ('mammals','birds'));

statement ok
use defaultdb;

statement ok
drop database db2 cascade;

# Ensure that functions defined with security behave as expected
subtest function_security_definer

statement ok
CREATE USER sensitive_user;

statement ok
CREATE TABLE sensitive_data_table (C1 INT);

statement ok
INSERT INTO sensitive_data_table VALUES (0),(1),(2);

statement ok
ALTER TABLE sensitive_data_table ENABLE ROW LEVEL SECURITY;

statement ok
GRANT ALL ON sensitive_data_table TO sensitive_user;

statement ok
CREATE FUNCTION my_sec_definer_reader_function() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT * FROM sensitive_data_table
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_reader_function() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT * FROM sensitive_data_table
$$;

statement ok
CREATE FUNCTION my_sec_definer_inserter_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 INSERT INTO sensitive_data_table VALUES (v)
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_inserter_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 INSERT INTO sensitive_data_table VALUES (v)
$$;


statement ok
CREATE FUNCTION my_sec_definer_updater_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 UPDATE sensitive_data_table SET c1=v*2 WHERE c1 = v
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_updater_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 UPDATE sensitive_data_table SET c1=v*2 WHERE c1 = v
$$;

statement ok
SET ROLE sensitive_user;

query I rowsort
SELECT * FROM sensitive_data_table;
----

query I
select my_sec_definer_inserter_function(10);
----
NULL

query I
select my_sec_definer_updater_function(2);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

query I rowsort
SELECT my_non_sec_definer_reader_function();
-----

statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_inserter_function(20);

# No error from the update because the lack of policies won't read any rows to
# update. We verify nothing has changed right after.
query I
select my_non_sec_definer_updater_function(4);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

statement ok
SET ROLE root

statement ok
CREATE POLICY p1 ON sensitive_data_table FOR SELECT TO sensitive_user USING (C1 != 0);

statement ok
SET ROLE sensitive_user;

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

query I rowsort
SELECT my_non_sec_definer_reader_function()
----
1
4
10

statement ok
SET ROLE root;

statement ok
CREATE POLICY p2 ON sensitive_data_table FOR INSERT TO sensitive_user WITH CHECK (C1 != 55);

statement ok
CREATE POLICY IF NOT EXISTS p3 ON sensitive_data_table FOR UPDATE TO sensitive_user USING (true) WITH CHECK (C1 >= 10);

statement ok
SET ROLE sensitive_user;

# violates new policy for insert
statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_inserter_function(55);

query I
select my_non_sec_definer_inserter_function(54);
----
NULL

# violates new policy for update
statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_updater_function(4);

query I
select my_non_sec_definer_updater_function(10);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
20
54

statement ok
SET ROLE root

statement ok
DROP FUNCTION my_sec_definer_reader_function;

statement ok
DROP FUNCTION my_non_sec_definer_reader_function;

statement ok
DROP TABLE sensitive_data_table CASCADE;

subtest alter_policy

statement ok
CREATE TABLE alter_policy_table (c1 INT NOT NULL PRIMARY KEY, c2 TEXT, FAMILY (c1, c2));

statement ok
ALTER TABLE alter_policy_table ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE ROLE alter_policy_role;

statement ok
CREATE ROLE aux1;

statement ok
CREATE USER aux2;

statement ok
CREATE SEQUENCE seq1;

statement ok
GRANT ALL ON seq1 TO alter_policy_role;

statement ok
ALTER TABLE alter_policy_table OWNER TO alter_policy_role;

statement ok
SET ROLE alter_policy_role;

statement ok
CREATE POLICY p ON alter_policy_table FOR INSERT WITH CHECK (false);

statement error pq: new row violates row-level security policy for table "alter_policy_table"
INSERT INTO alter_policy_table VALUES (1, 'one'), (2, 'two'), (3, 'three');

statement error pq: only WITH CHECK expression allowed for INSERT
ALTER POLICY p ON alter_policy_table USING (true);

statement ok
ALTER POLICY p ON alter_policy_table WITH CHECK (nextval('seq1') < 10000);

statement ok
INSERT INTO alter_policy_table VALUES (1, 'one'), (2, 'two'), (3, 'three');

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----

statement ok
ALTER POLICY p ON alter_policy_table RENAME TO p_ins;

statement ok
CREATE POLICY p ON alter_policy_table FOR SELECT TO aux1 USING (c1 > 0);

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----

statement error pq: policy "p_sel" for table "alter_policy_table" does not exist
ALTER POLICY p_sel ON alter_policy_table WITH CHECK (true);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
ALTER POLICY p ON alter_policy_table WITH CHECK (true);

statement ok
ALTER POLICY p ON alter_policy_table TO alter_policy_role,aux1,aux2 USING (c1 != 1);

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----
2
3

statement ok
ALTER POLICY p ON alter_policy_table RENAME TO p_sel;

query TT
SHOW CREATE TABLE alter_policy_table;
----
alter_policy_table  CREATE TABLE public.alter_policy_table (
                      c1 INT8 NOT NULL,
                      c2 STRING NULL,
                      CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                      FAMILY fam_0_c1_c2 (c1, c2)
                    );
                    ALTER TABLE public.alter_policy_table ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
                    CREATE POLICY p_ins ON public.alter_policy_table AS PERMISSIVE FOR INSERT TO public WITH CHECK (nextval('public.seq1'::REGCLASS) < 10000:::INT8);
                    CREATE POLICY p_sel ON public.alter_policy_table AS PERMISSIVE FOR SELECT TO aux1, alter_policy_role, aux2 USING (c1 != 1:::INT8)

query TTTTTT colnames
SELECT name,cmd,type,roles,using_expr,with_check_expr
FROM [SHOW POLICIES FOR alter_policy_table]
ORDER BY name DESC;
----
name   cmd     type        roles                          using_expr      with_check_expr
p_sel  SELECT  permissive  {alter_policy_role,aux1,aux2}  c1 != 1:::INT8  ·
p_ins  INSERT  permissive  {public}                       ·               nextval('public.seq1'::REGCLASS) < 10000:::INT8

statement ok
SET ROLE root;

statement error pq: cannot drop sequence seq1 because other objects depend on it
DROP SEQUENCE seq1;

# Change the policy so there isn't a dependency on seq1 anymore.
statement ok
ALTER POLICY p_ins ON alter_policy_table WITH CHECK (true);

statement ok
DROP SEQUENCE seq1;

statement ok
DROP TABLE alter_policy_table;

statement ok
DROP ROLE alter_policy_role, aux1, aux2;

# Verify that you need to be the table owner to do any of the RLS DDLs
subtest table_owner_and_rls_ddl

statement ok
CREATE USER tab_owner;

statement ok
CREATE USER nontab_owner;

statement ok
CREATE TABLE table_owner_test ();

statement ok
ALTER TABLE table_owner_test OWNER TO tab_owner;

statement ok
GRANT ALL ON table_owner_test TO nontab_owner;

statement ok
SET ROLE tab_owner;

statement ok
ALTER TABLE table_owner_test ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p1 on table_owner_test;

statement ok
DROP POLICY p1 on table_owner_test;

statement ok
CREATE POLICY new_p1 on table_owner_test;

statement ok
ALTER POLICY new_p1 on table_owner_test RENAME TO p1;

statement ok
ALTER POLICY p1 on table_owner_test RENAME TO new_p1;

statement ok
ALTER POLICY new_p1 on table_owner_test USING (true);

statement ok
SET ROLE nontab_owner;

statement error pq: must be owner of relation table_owner_test
ALTER TABLE table_owner_test DISABLE ROW LEVEL SECURITY;

statement error pq: must be owner of relation table_owner_test
ALTER TABLE table_owner_test NO FORCE ROW LEVEL SECURITY;

statement error pq: must be owner of relation table_owner_test
CREATE POLICY IF NOT EXISTS p2 on table_owner_test;

statement error pq: must be owner of relation table_owner_test
DROP POLICY new_p1 on table_owner_test;

statement error pq: must be owner of relation table_owner_test
ALTER POLICY new_p1 on table_owner_test WITH CHECK (true);

statement error pq: must be owner of relation table_owner_test
ALTER POLICY new_p1 on table_owner_test RENAME TO p1;

statement ok
SET ROLE root

statement ok
DROP TABLE table_owner_test;

statement ok
DROP ROLE nontab_owner, tab_owner;

subtest force

statement ok
CREATE USER forcer;

statement ok
CREATE USER funuser;

statement ok
GRANT CREATE ON DATABASE db1 TO forcer;

statement ok
set role forcer;

statement ok
CREATE TABLE force_check (c1 INT NOT NULL PRIMARY KEY, c2 TEXT);

statement ok
INSERT INTO force_check VALUES (10, 'ten'), (20, 'twenty'), (50, 'fifty')

statement ok
CREATE FUNCTION access_large_c2_as_session_user() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT c1 FROM force_check WHERE length(c2) > 3
$$;

statement ok
CREATE FUNCTION access_large_c2_as_forcer() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT c1 FROM force_check WHERE length(c2) > 3
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION insert_policy_violation_as_session_user(c1 INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO force_check VALUES (c1, 't - violated col value') RETURNING c1, c2
$$;

statement ok
CREATE FUNCTION insert_policy_violation_as_forcer(c1 INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO force_check VALUES (c1, 't - violated col value') RETURNING c1, c2
$$ SECURITY DEFINER;

statement ok
ALTER TABLE force_check ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_sel ON force_check TO forcer, funuser USING (c2 not like 't%');

# Should see only part of the rows because we are the table owner with FORCE on.
# We use different queries, all showing the same results, so that the query cache
# has multiple statements. We will retry the exact same SQL later once RLS
# settings have changed. I label each query (e.g. q1) so it can be easily
# found when its reused in this subtest.
#
# q1
query IT
SELECT c1, c2 FROM force_check ORDER BY c1;
----
50 fifty

# q2
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement error pq: new row violates row-level security policy for table "force_check"
INSERT INTO force_check VALUES (30, 'thirty')

# Verify the admin can still see everything
statement ok
SET ROLE root

# q1 - show that query reuse doesn't occur for different user
query IT
SELECT c1, c2 FROM force_check ORDER BY c1;
----
10 ten
20 twenty
50 fifty

statement ok
INSERT INTO force_check VALUES (33, 'thirty-three')

statement ok
SET ROLE forcer;

# Turn off force to ensure we can see everything again.
statement ok
ALTER TABLE force_check NO FORCE ROW LEVEL SECURITY;

statement ok
INSERT INTO force_check VALUES (30, 'thirty')

# q2 - should not reuse because table version since last use
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
10 ten
20 twenty
30 thirty
33 thirty-three
50 fifty

# Transfer ownership of force_check back to the root and attempt query from cache.
statement ok
SET ROLE root

statement ok
ALTER TABLE force_check OWNER TO root;

statement ok
GRANT ALL ON force_check TO forcer;

statement ok
SET ROLE forcer;

# q2 - should not be reused due to an ownership change, which has resulted in a
# new table version since its last use
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement ok
SET ROLE root;

# Turn on force again, but it shouldn't matter because we aren't the owner anymore
statement ok
ALTER TABLE force_check FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE forcer;

# q2 - should not reuse because table version change
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement error pq: new row violates row-level security policy for table "force_check"
INSERT INTO force_check VALUES (34, 'thirty-four')

# Transfer back to forcer and access table via functions as 'funuser'
statement ok
SET ROLE root

statement ok
ALTER TABLE force_check OWNER TO forcer;

statement ok
GRANT ALL ON force_check TO funuser;

statement ok
SET ROLE funuser;

# Since FORCE is enabled, the policies will apply both to the session user and
# when running the function as the security definer (forcer). Therefore, we
# expect the same filtered result in both cases.

query I
select * from access_large_c2_as_session_user();
----
50

query I
select * from access_large_c2_as_forcer();
----
50

# Similar for functions that add new rows

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_session_user(110);

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_forcer(111);

# Turn off FORCE and retry function access as funuser
statement ok
SET ROLE forcer;

statement ok
ALTER TABLE force_check NO FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE funuser;

# FORCE is now off. When run as funuser, the result should remain the same as
# before. However, when running the function as forcer, policies will not be
# applied since forcer is the table owner and is exempt from policy enforcement.

query I
select * from access_large_c2_as_session_user();
----
50

query I rowsort
select * from access_large_c2_as_forcer();
----
20
30
33
50

# Similar for functions that add new rows

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_session_user(111);

query IT
SELECT * FROM insert_policy_violation_as_forcer(112);
----
112  t - violated col value

statement ok
SET ROLE root

statement ok
DROP TABLE force_check CASCADE;

# Test to make sure that the scan to enforce uniqueness is done without RLS policies.
subtest uniq

statement ok
CREATE TABLE uniq (rls_col TEXT, uniq_col INT8 UNIQUE);

statement ok
CREATE USER uniq_user;

statement ok
GRANT ALL ON uniq TO uniq_user;

statement ok
ALTER TABLE uniq OWNER TO uniq_user;

statement ok
SET ROLE uniq_user;

statement ok
ALTER TABLE uniq NO FORCE ROW LEVEL SECURITY, ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY access ON uniq USING (rls_col = 'cat');

statement ok
INSERT INTO uniq VALUES ('cat', 1), ('cat', 2), ('dog', 3), ('cat', 4), ('hamster', 5);

statement ok
ALTER TABLE uniq FORCE ROW LEVEL SECURITY;

statement error pq: duplicate key value violates unique constraint "uniq_uniq_col_key"\nDETAIL: Key \(uniq_col\)=\(3\) already exists.
INSERT INTO uniq VALUES ('cat', 3);

statement ok
INSERT INTO uniq VALUES ('cat', 6);

statement error pq: new row violates row-level security policy for table "uniq"
INSERT INTO uniq VALUES ('dog', 6);

statement error pq: duplicate key value violates unique constraint "uniq_uniq_col_key"\nDETAIL: Key \(uniq_col\)=\(5\) already exists.
UPDATE uniq SET uniq_col = 5 WHERE uniq_col = 1;

statement ok
UPDATE uniq SET uniq_col = 7 WHERE uniq_col = 1;

# Ensure that any attempts to update an invisible row will be a no-op
query TI
UPDATE uniq SET uniq_col = 8 WHERE uniq_col = 5 RETURNING rls_col, uniq_col;
----

statement ok
ALTER TABLE uniq NO FORCE ROW LEVEL SECURITY;

query TI
select rls_col, uniq_col FROM uniq ORDER BY uniq_col;
----
cat      2
dog      3
cat      4
hamster  5
cat      6
cat      7

statement ok
SET ROLE root;

statement ok
DROP TABLE uniq;

statement ok
DROP USER uniq_user;

# Test to make sure that the scan to enforce foreign keys is exempt from RLS policies.
subtest fk

statement ok
CREATE TABLE parent (key INT8 NOT NULL PRIMARY KEY);

statement ok
CREATE TABLE child (
  rls_col TEXT,
  key INT8 NOT NULL,
  CONSTRAINT fk FOREIGN KEY (key) REFERENCES parent(key) ON DELETE CASCADE
);

statement ok
CREATE USER fk_user;

statement ok
GRANT ALL ON parent TO fk_user;

statement ok
GRANT ALL ON child TO fk_user;

statement ok
ALTER TABLE parent OWNER TO fk_user;

statement ok
ALTER TABLE child OWNER TO fk_user;

statement ok
SET ROLE fk_user;

statement ok
INSERT INTO parent SELECT * FROM generate_series(1,6);

statement ok
INSERT INTO child VALUES ('bedroom', 1), ('office', 2)

# Set RLS at the parent and ensure FK still enforced.
statement ok
ALTER TABLE parent ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement error pq: insert on table "child" violates foreign key constraint "fk"
INSERT INTO child VALUES ('hall', 7);

statement ok
INSERT INTO child VALUES ('hall', 3);

# mimic the FK lookup to show that the given RLS policies will hide the value
query I
SELECT 1 FROM parent WHERE key = 3;
----

query I
SELECT key FROM child ORDER BY key;
----
1
2
3

# Set RLS at the child and ensure FK still enforced
statement ok
ALTER TABLE child ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY ins1 ON child FOR INSERT WITH CHECK (rls_col = 'bedroom');

statement error pq: insert on table "child" violates foreign key constraint "fk"
INSERT INTO child VALUES ('bedroom', 7);

statement error pq: new row violates row-level security policy for table "child"
INSERT INTO child VALUES ('deck', 7);

statement ok
INSERT INTO child VALUES ('bedroom', 4);

# Disable RLS at the parent so that we can do a delete and have it cascade down
statement ok
ALTER TABLE parent NO FORCE ROW LEVEL SECURITY;

statement ok
DELETE FROM parent WHERE key = 1;

statement ok
CREATE POLICY sel1 ON child FOR SELECT USING (true);

query I
SELECT key FROM child ORDER BY key;
----
2
3
4

statement ok
SET ROLE root

statement ok
DROP TABLE child;

statement ok
DROP TABLE parent;

statement ok
DROP USER fk_user;

# Ensure CHECK constraints can work alongside RLS policies
subtest check_constraint

statement ok
CREATE TABLE rgb_only (col text, check (col = 'red' or col = 'green' or col = 'blue'));

statement ok
CREATE USER rgb_only_user;

statement ok
ALTER TABLE rgb_only OWNER TO rgb_only_user;

statement ok
SET ROLE rgb_only_user;

statement ok
ALTER TABLE rgb_only ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_sel ON rgb_only FOR SELECT USING (true);

statement ok
CREATE POLICY IF NOT EXISTS p_subset ON rgb_only FOR INSERT WITH CHECK (col = 'red' or col = 'brown');

statement ok
INSERT INTO rgb_only VALUES ('red')

# Allowed by policy, reject by CHECK constraint
statement error pq: failed to satisfy CHECK constraint \(\(\(col = 'red':::STRING\) OR \(col = 'green':::STRING\)\) OR \(col = 'blue':::STRING\)\)
INSERT INTO rgb_only VALUES ('brown')

# Disallowed by policy, accepted by CHECK constraint
statement error pq: new row violates row-level security policy for table "rgb_only"
INSERT INTO rgb_only VALUES ('green')

statement ok
DROP POLICY p_subset ON rgb_only;

statement ok
CREATE POLICY p_disjoint ON rgb_only FOR INSERT WITH CHECK (col = 'black');

# Disallowed by both.
statement error pq: new row violates row-level security policy for table "rgb_only"
INSERT INTO rgb_only VALUES ('blue')

query T
SELECT col FROM rgb_only ORDER BY col;
----
red

statement ok
SET ROLE root;

statement ok
DROP TABLE rgb_only;

statement ok
DROP USER rgb_only_user;

subtest truncate

statement ok
CREATE TYPE trunc_type AS ENUM('a', 'b', 'c');

statement ok
CREATE TABLE trunc (a INT, b trunc_type, FAMILY (a, b));

statement ok
INSERT INTO trunc VALUES (1, 'a'), (2, 'b'), (3, 'c');

statement ok
CREATE USER deleter;

statement ok
GRANT ALL ON trunc TO deleter;

statement ok
ALTER TABLE trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p1 ON trunc FOR SELECT TO deleter USING (a % 2 = 1 and b != 'b');

statement ok
CREATE POLICY p2 ON trunc FOR DELETE TO deleter USING (false);

statement ok
CREATE POLICY p3 ON trunc FOR INSERT TO deleter WITH CHECK (true);

statement ok
SET ROLE deleter;

query IT
SELECT a, b FROM trunc ORDER BY a;
----
1  a
3  c

# This should not delete anything because the expression for delete is false.
statement ok
DELETE FROM trunc;

query IT
SELECT a, b FROM trunc ORDER BY a;
----
1  a
3  c

query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       );
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true)


# Truncate should be allowed, despite the policy to prevent deletes.
statement ok
TRUNCATE TABLE trunc;

query IT
SELECT a, b FROM trunc ORDER BY a;
----

# TRUNCATE is implemented by recreating the table. Verify the same policies exist.
query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       );
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true)

# Ensure the policies are still enforced.
statement ok
INSERT INTO trunc VALUES (7, 'a'), (8, 'b'), (9, 'c');

query IT
SELECT a, b FROM trunc ORDER BY a;
----
7  a
9  c

statement ok
DELETE FROM trunc;

query IT
SELECT a, b FROM TRUNC ORDER BY a;
----
7  a
9  c

statement ok
SET ROLE root;

statement ok
DROP TABLE trunc;

statement ok
DROP USER deleter;

subtest validate_statement_cache_after_rls_changes

statement ok
CREATE TABLE rls_cache_test (c1 TEXT);

statement ok
INSERT INTO rls_cache_test VALUES ('a'), ('b'), ('c');

statement ok
CREATE USER rls_cache_user;

statement ok
GRANT ALL ON rls_cache_test TO rls_cache_user;

statement ok
SET ROLE rls_cache_user;

# Prime the cache
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
a
b
c

statement ok
SET ROLE root

statement ok
ALTER TABLE rls_cache_test ENABLE ROW LEVEL SECURITY;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----

statement ok
SET ROLE root

statement ok
CREATE POLICY IF NOT EXISTS rls_cache_policy ON rls_cache_test FOR SELECT TO rls_cache_user USING (c1 != 'a');

# Should be a no-op because the policy already exists
statement ok
CREATE POLICY IF NOT EXISTS rls_cache_policy ON rls_cache_test;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated (again)
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
b
c

statement ok
SET ROLE root

statement ok
ALTER TABLE rls_cache_test DISABLE ROW LEVEL SECURITY;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated (again)
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
a
b
c

statement ok
SET ROLE root

# Ensure that the cache is invalidated when table is dropped
statement ok
DROP TABLE rls_cache_test;

statement ok
SET ROLE rls_cache_user;

statement error pq: relation "rls_cache_test" does not exist
SELECT * FROM rls_cache_test ORDER BY c1;

statement ok
SET ROLE root

statement ok
DROP ROLE rls_cache_user;

subtest block_invalid_expressions

statement ok
CREATE TABLE blocker();

statement error pq: only WITH CHECK expression allowed for INSERT
CREATE POLICY p_insert on blocker FOR INSERT USING (1 = 1);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
CREATE POLICY p_select on blocker FOR SELECT WITH CHECK (false);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
CREATE POLICY p_delete on blocker FOR DELETE WITH CHECK (1 = 1);

statement ok
DROP TABLE blocker;

subtest block_import

statement ok
CREATE TABLE importer (c1 INT);

statement ok
ALTER TABLE importer ENABLE ROW LEVEL SECURITY;

statement ok
CREATE USER z;

statement ok
GRANT ALL ON importer TO z;

statement ok
GRANT SYSTEM EXTERNALIOIMPLICITACCESS TO z;

# Ensure non-admin's are blocked
statement ok
SET ROLE z;

let $exp_file
WITH cte AS (EXPORT INTO CSV 'nodelocal://1/rls-importer' FROM select 99 UNION ALL SELECT 98 UNION ALL SELECT 97) SELECT filename FROM cte;

statement error pq: IMPORT INTO not supported with row-level security for non-admin users
IMPORT INTO importer CSV DATA ('nodelocal://1/rls-importer/$exp_file');

# Ensure import from the admin role works
statement
SET ROLE root;

# In general, IMPORT isn't compatible with the fake span resolver. So we skip
# in those configs.
skipif config fakedist fakedist-disk fakedist-vec-off
statement ok
IMPORT INTO importer CSV DATA ('nodelocal://1/rls-importer/$exp_file');

skipif config fakedist fakedist-disk fakedist-vec-off
query I
SELECT c1 FROM importer ORDER BY c1;
----
97
98
99

statement ok
DROP TABLE importer;

statement ok
REVOKE SYSTEM EXTERNALIOIMPLICITACCESS FROM z;

statement ok
DROP USER z;

subtest rls_for_insert

statement ok
CREATE TABLE rlsInsert (c1 int not null primary key, c2 text, c3 date, family (c1,c2,c3));

statement ok
ALTER TABLE rlsInsert ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY IF NOT EXISTS p_insert ON rlsInsert AS PERMISSIVE FOR INSERT TO buck WITH CHECK (c3 not between '2012-01-01' and '2012-12-31');

statement ok
CREATE POLICY p_select ON rlsInsert AS PERMISSIVE FOR SELECT TO buck USING (true);

statement ok
GRANT ALL on rlsInsert TO buck;

# Sanity that the admin can insert anything
statement ok
INSERT INTO rlsInsert VALUES (1, 'first', '2012-06-30'),(0, 'zero', NULL);

statement ok
SET ROLE buck;

statement ok
INSERT INTO rlsInsert VALUES (2, 'second', '2010-06-30');

# Violates policy because date is in 2012.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (3, 'third', '2012-07-08');

# Violates policy because date is in 2012.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert SELECT c1 + 5, c2, c3 FROM rlsInsert;

# Violates policy because date is NULL
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (4, 'four', NULL)

statement ok
INSERT INTO rlsInsert SELECT c1 + 5, c2, c3 FROM rlsInsert WHERE c3 not between '2012-01-01' and '2012-12-31';

statement ok
SET ROLE root;

query TT
SHOW CREATE TABLE rlsInsert
----
rlsinsert  CREATE TABLE public.rlsinsert (
             c1 INT8 NOT NULL,
             c2 STRING NULL,
             c3 DATE NULL,
             CONSTRAINT rlsinsert_pkey PRIMARY KEY (c1 ASC),
             FAMILY fam_0_c1_c2_c3 (c1, c2, c3)
           );
           ALTER TABLE public.rlsinsert ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
           CREATE POLICY p_insert ON public.rlsinsert AS PERMISSIVE FOR INSERT TO buck WITH CHECK (c3 NOT BETWEEN '2012-01-01':::DATE AND '2012-12-31':::DATE);
           CREATE POLICY p_select ON public.rlsinsert AS PERMISSIVE FOR SELECT TO buck USING (true)

statement ok
DROP POLICY p_insert on rlsInsert;

statement ok
SET ROLE buck;

# There is no policy for insert, so we deny everything.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (4, 'fourth', '2022-10-08');

query I
select c1 from rlsInsert ORDER BY c1;
----
0
1
2
7

statement ok
SET ROLE root;

statement ok
DROP TABLE rlsInsert;

subtest rls_for_update

statement ok
CREATE TYPE league AS ENUM('AL','NL');

statement ok
CREATE FUNCTION al_only(l league) RETURNS BOOL AS $$
BEGIN
  RETURN l = 'AL';
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE SEQUENCE seq1;

statement ok
CREATE TABLE bbteams (team text, league league, wins int, family (team, league, wins));

statement ok
ALTER TABLE bbteams ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_update ON bbteams FOR UPDATE TO buck USING (true) WITH CHECK (league = 'AL' and nextval('seq1') < 1000);

statement ok
CREATE POLICY p_select ON bbteams FOR SELECT TO buck USING (true);

statement ok
CREATE POLICY IF NOT EXISTS p_insert ON bbteams FOR INSERT TO buck WITH CHECK (nextval('seq1') < 1000);

# Should be a no-op because policy already exists
statement ok
CREATE POLICY IF NOT EXISTS p_insert ON bbteams;

statement ok
GRANT ALL on bbteams TO buck;

statement ok
GRANT USAGE ON seq1 TO buck;

statement ok
GRANT UPDATE ON seq1 TO buck;

statement ok
SET ROLE buck;

statement ok
INSERT INTO bbteams(team, league) VALUES ('guardians', 'AL'), ('royals', 'AL'), ('expos', 'NL');

# Should be violated because expos are not in the AL league.
statement error pq: new row violates row-level security policy for table "bbteams"
UPDATE bbteams SET wins = 91 WHERE team = 'expos';

# Is allowed because league changed to AL at the same time.
statement ok
UPDATE bbteams SET wins = 87, league = 'AL' WHERE team = 'expos';

# Change the sequence so that it's value violates the WITH CHECK expression for
# the update policy.
statement ok
select setval('seq1', 1500, true);

statement error pq: new row violates row-level security policy for table "bbteams"
UPDATE bbteams SET wins = 82  WHERE team = 'royals';

statement ok
SET ROLE root

query I
SELECT nextval('seq1')
----
1502

query TTI
select team, league, wins from bbteams order by team;
----
expos      AL  87
guardians  AL  NULL
royals     AL  NULL

statement ok
DROP TABLE bbteams;

statement ok
DROP FUNCTION al_only;

statement ok
DROP SEQUENCE seq1;

subtest multiple_policies

statement ok
CREATE TABLE multip (key INT NOT NULL, value TEXT, FAMILY (key,value));

statement ok
ALTER TABLE multip ENABLE ROW LEVEL SECURITY;

# The policies will be combined as: (or1 || or2 || or3) && and1 && and2
statement ok
CREATE POLICY or1 ON multip AS PERMISSIVE USING (key = 1);

statement ok
CREATE POLICY or2 ON multip AS PERMISSIVE USING (key = 2);

statement ok
CREATE POLICY IF NOT EXISTS or3 ON multip AS PERMISSIVE USING (key = 3);

statement ok
CREATE POLICY and1 ON multip AS RESTRICTIVE USING (value not like '%sensitive%')

statement ok
CREATE POLICY and2 ON multip AS RESTRICTIVE USING (value not like '%confidential%')

statement ok
INSERT INTO multip VALUES
 (0, 'key out of bounds'),
 (1, 'okay'),
 (1, 'sensitive - filtered out'),
 (2, 'okay'),
 (2, 'confidential - filtered out'),
 (3, 'okay'),
 (2, 'sensitive - filtered out'),
 (4, 'key out of bounds'),
 (4, 'confidential');

statement ok
CREATE USER multi_user;

statement ok
GRANT ALL ON multip TO multi_user;

statement ok
SET ROLE multi_user;

query IT
select * from multip ORDER BY key, value;
----
1  okay
2  okay
3  okay

query IT
select * from multip where key >= 0 ORDER BY key, value;
----
1  okay
2  okay
3  okay

statement ok
SET ROLE root

# Ensure that if only a restrictive policy exists that all rows will be rejected
# regardless of the policy expression.
statement ok
DROP POLICY or1 ON multip;

statement ok
DROP POLICY or2 ON multip;

statement ok
DROP POLICY or3 ON multip;

statement ok
SET ROLE multi_user;

query TT
SHOW CREATE multip;
----
multip  CREATE TABLE public.multip (
          key INT8 NOT NULL,
          value STRING NULL,
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT multip_pkey PRIMARY KEY (rowid ASC),
          FAMILY fam_0_key_value_rowid (key, value, rowid)
        );
        ALTER TABLE public.multip ENABLE ROW LEVEL SECURITY;
        CREATE POLICY and1 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%sensitive%':::STRING);
        CREATE POLICY and2 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%confidential%':::STRING)

query IT
select * from multip ORDER BY key, value;
----

statement ok
SET ROLE root;

# Setup to verify the write policies.
statement ok
TRUNCATE TABLE multip;

statement ok
CREATE POLICY or1 ON multip AS PERMISSIVE USING (key = 1);

statement ok
CREATE POLICY or2 ON multip AS PERMISSIVE USING (key = 2);

statement ok
CREATE POLICY or3 ON multip AS PERMISSIVE USING (key = 3);

query TTTTT colnames,rowsort
select name, cmd, type, roles, with_check_expr from [SHOW POLICIES FOR multip];
----
name  cmd  type         roles     with_check_expr
and1  ALL  restrictive  {public}  ·
and2  ALL  restrictive  {public}  ·
or1   ALL  permissive   {public}  ·
or2   ALL  permissive   {public}  ·
or3   ALL  permissive   {public}  ·

query T rowsort
select using_expr from [SHOW POLICIES FOR multip];
----
value NOT LIKE '%sensitive%':::STRING
value NOT LIKE '%confidential%':::STRING
key = 1:::INT8
key = 2:::INT8
key = 3:::INT8

statement ok
SET ROLE multi_user;

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (0, 'key out of bounds');

statement ok
INSERT INTO multip VALUES (1, 'okay');

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (1, 'sensitive - filtered out');

statement ok
INSERT INTO multip VALUES (2, 'okay')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (2, 'confidential - filtered out')

statement ok
INSERT INTO multip VALUES (3, 'okay')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (2, 'sensitive - filtered out')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (4, 'key out of bounds')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (4, 'confidential');

statement ok
SET ROLE root;

query IT rowsort
select * FROM multip ORDER BY key, value;
----
1  okay
2  okay
3  okay

statement ok
DROP TABLE multip;

statement ok
DROP USER multi_user;

subtest show_policies_edge_cases

statement error pq: relation "nonexistent_table" does not exist
SHOW POLICIES FOR nonexistent_table;

statement ok
CREATE TABLE rls_disabled (id INT PRIMARY KEY);

statement ok
CREATE POLICY p1 ON rls_disabled USING (true);

statement ok
ALTER TABLE rls_disabled DISABLE ROW LEVEL SECURITY;

query TTTTTT colnames
SHOW POLICIES FOR rls_disabled;
----
name  cmd  type        roles     using_expr  with_check_expr
p1    ALL  permissive  {public}  true        ·

# Test case 3: Show policies for a table with no policies
statement ok
CREATE TABLE no_policies (id INT PRIMARY KEY);

statement ok
ALTER TABLE no_policies ENABLE ROW LEVEL SECURITY;

query TTTTTT
SHOW POLICIES FOR no_policies;
----

# This is another test for multiple policies. But the focus here is how multiple
# policies are applied when they apply for other commands. For example, having
# a policy that applies to SELECT and a policy that applies to DELETE.
subtest multi_policies_multi_cmd

statement ok
create table r1 (c1 int);

statement ok
alter table r1 enable row level security;

statement ok
insert into r1 values (0),(1),(2),(3),(4),(5),(22);

statement ok
create policy sel1 on r1 for select using (c1 % 2 = 0);

statement ok
create policy upd1 on r1 for update using (c1 between 0 and 20);

statement ok
create user r1_user;

statement ok
grant all on r1 to r1_user;

statement ok
set role r1_user;

# UPDATE should only apply to the combination of both policies.
statement ok
update r1 set c1 = c1 ;

query I rowsort
update r1 set c1 = c1 returning c1;
----
0
2
4

statement error pq: new row violates row-level security policy for table "r1"
update r1 set c1 = c1 + 1;

statement error pq: new row violates row-level security policy for table "r1"
update r1 set c1 = c1 + 1 where c1 between 1 and 3;

statement ok
update r1 set c1 = c1 + 2 where c1 between 1 and 10;

query I rowsort
update r1 set c1 = c1 + 2 where c1 between 1 and 10 returning c1;
----
6
8

query I
update r1 set c1 = c1 + 2 where c1 > 20 returning c1;
----

query I rowsort
SELECT * FROM r1;
----
0
6
8
22

statement ok
SET ROLE root;

query I rowsort
SELECT * FROM r1;
----
0
1
3
5
6
8
22

statement ok
DROP TABLE r1;

# Do another test of select and update policies, but use simple expressions and
# try out different combinations of those expressions.
statement ok
CREATE TABLE cnt (counter INT);

statement ok
INSERT INTO cnt VALUES (1);

statement ok
GRANT ALL ON cnt TO r1_user;

statement ok
ALTER TABLE cnt ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
ALTER TABLE cnt OWNER TO r1_user;

statement ok
SET ROLE r1_user;

statement ok
CREATE POLICY IF NOT EXISTS upd1 ON cnt FOR UPDATE USING (true);

# Only an UPDATE policy and no SELECT policy. Nothing is updated.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now create only a SELECT policy. Same behaviour as before.
statement ok
DROP POLICY upd1 ON cnt;

statement ok
CREATE POLICY sel1 ON cnt FOR SELECT USING (true);

query I
SELECT * FROM cnt;
----
1

# Any locking modes on the query will cause the UPDATE policies to be applied,
# which will filter out the row.
query I
SELECT * FROM cnt FOR UPDATE;
----


query I
SELECT * FROM cnt FOR SHARE;
----


let $cnt_oid
SELECT 'cnt'::REGCLASS::OID;

query I
SELECT * FROM [$cnt_oid as t];
----
1

query I
SELECT * FROM [$cnt_oid as t] FOR UPDATE;
----

query I
SELECT * FROM [$cnt_oid as t] FOR SHARE;
----

# Update with a SELECT policy but no UPDATE policy. Nothing should be returned.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now add a SELECT policy, but it still filters everything out.
statement ok
CREATE POLICY upd1 ON cnt FOR UPDATE USING (false);

# Same as before, no update occurs because the reading of existing rows filters
# everything out.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now alter the UPDATE policy with one that allows everything.
statement ok
ALTER POLICY upd1 ON cnt USING (true);

query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----
2

# Update the UPDATE policy so that it allows old rows but blocks all new rows.
statement ok
ALTER POLICY upd1 ON cnt USING (true) WITH CHECK (false);

# We are able to read the row but cannot write a new row as it violates the
# update policy.
statement error pq: new row violates row-level security policy for table "cnt"
UPDATE cnt SET counter = counter + 1 RETURNING counter;

# Verify that select policy (true) with no delete policy will not delete anything.
query I
delete from cnt where counter is not null returning counter;
----

statement ok
delete from cnt;

query I
select counter from cnt;
----
2

# Now change the select policy to be always false, and delete policy to be always true.
statement ok
ALTER POLICY sel1 ON cnt USING (false);

statement ok
CREATE POLICY del1 ON cnt FOR DELETE USING (true);

query I
delete from cnt where counter > 0 returning counter;
----

statement ok
delete from cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

# Drop the select policy entirely. It should be no different than a deny-all select policy.
statement ok
DROP POLICY sel1 ON cnt;

statement ok
ALTER TABLE cnt FORCE ROW LEVEL SECURITY;

query I
delete from cnt where counter > 0 returning counter;
----

statement ok
delete from cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

statement ok
ALTER TABLE cnt FORCE ROW LEVEL SECURITY;

# Now change the select policy to always return true, and delete policy to always return false.
statement ok
DROP POLICY del1 ON cnt;

statement ok
CREATE POLICY sel1 ON cnt FOR SELECT USING (true);

statement ok
CREATE POLICY IF NOT EXISTS del1 ON cnt FOR DELETE USING (false);

query I
DELETE FROM cnt WHERE counter > 0 RETURNING counter;
----

statement ok
DELETE FROM cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE root

statement ok
DROP TABLE cnt;

statement ok
DROP USER r1_user;

subtest show_policies_roles_and_users

statement ok
CREATE ROLE test_role1;

statement ok
CREATE ROLE test_role2;

statement ok
CREATE USER test_user1;

statement ok
CREATE USER test_user2;

statement ok
CREATE TABLE policy_roles_test (id INT PRIMARY KEY, val TEXT);

statement ok
CREATE POLICY mixed_policy ON policy_roles_test TO test_role1, test_user1, test_role2, test_user2;

query TTTTTT colnames
SHOW POLICIES FOR policy_roles_test
----
name          cmd  type        roles                                          using_expr  with_check_expr
mixed_policy  ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·

statement ok
CREATE POLICY users_only_policy ON policy_roles_test TO test_user1, test_user2;

query TTTTTT colnames,rowsort
SHOW POLICIES FOR policy_roles_test
----
name               cmd  type        roles                                          using_expr  with_check_expr
mixed_policy       ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·
users_only_policy  ALL  permissive  {test_user1,test_user2}                        ·           ·

statement ok
CREATE POLICY roles_only_policy ON policy_roles_test TO test_role1, test_role2;

query TTTTTT colnames,rowsort
SHOW POLICIES FOR policy_roles_test
----
name               cmd  type        roles                                          using_expr  with_check_expr
mixed_policy       ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·
roles_only_policy  ALL  permissive  {test_role1,test_role2}                        ·           ·
users_only_policy  ALL  permissive  {test_user1,test_user2}                        ·           ·

statement ok
DROP TABLE policy_roles_test;

statement ok
DROP USER test_user1;

statement ok
DROP USER test_user2;

statement ok
DROP ROLE test_role1;

statement ok
DROP ROLE test_role2;

# Ensure that if a role has the BYPASSRLS option or privilege set, that it's
# exempt from policies.
subtest bypassrls

statement ok
CREATE TABLE bypassrls (id INT PRIMARY KEY, val TEXT);

statement ok
CREATE USER bypassrls_user;

statement ok
GRANT ALL ON bypassrls TO bypassrls_user;

statement ok
ALTER TABLE bypassrls ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY pol1 ON bypassrls TO bypassrls_user USING (val like 'visible: %');

statement ok
CREATE FUNCTION insert_policy_violation_as_session_user(id INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO bypassrls VALUES (id, 'hidden: value') RETURNING id, val
$$;

# This function is like the above, except it will always be run as admin since
# it uses SECURITY DEFINER.
statement ok
CREATE FUNCTION insert_policy_violation_as_admin(id INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO bypassrls VALUES (id, 'hidden: value') RETURNING id, val
$$ SECURITY DEFINER;

statement ok
INSERT INTO bypassrls VALUES (0, 'visible: 0'), (1, 'hidden: 1'), (2, 'visible: 2');

query IT
SELECT * FROM insert_policy_violation_as_admin(10);
----
10 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(11);
----
11 hidden: value

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
1 hidden: 1
2 visible: 2
10 hidden: value
11 hidden: value

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
2 visible: 2

query IT
SELECT * FROM insert_policy_violation_as_admin(20);
----
20 hidden: value

statement error pq: new row violates row-level security policy for table "bypassrls"
SELECT * FROM insert_policy_violation_as_session_user(21);

statement ok
SET ROLE root;

statement error pq: conflicting role options
ALTER ROLE bypassrls_user BYPASSRLS NOBYPASSRLS;

statement ok
ALTER ROLE bypassrls_user BYPASSRLS;

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
1 hidden: 1
2 visible: 2
10 hidden: value
11 hidden: value
20 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_admin(30);
----
30 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(31);
----
31 hidden: value

statement ok
SET ROLE root

statement ok
ALTER ROLE bypassrls_user NOBYPASSRLS;

statement ok
GRANT SYSTEM BYPASSRLS TO bypassrls_user;

query TTB colnames
SELECT * FROM [SHOW SYSTEM GRANTS] WHERE privilege_type = 'BYPASSRLS';
----
grantee         privilege_type  is_grantable
bypassrls_user  BYPASSRLS             false

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0   visible: 0
1   hidden: 1
2   visible: 2
10  hidden: value
11  hidden: value
20  hidden: value
30  hidden: value
31  hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(40);
----
40 hidden: value

statement ok
SET ROLE root;

statement ok
REVOKE SYSTEM BYPASSRLS FROM bypassrls_user;

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
2 visible: 2

statement error pq: new row violates row-level security policy for table "bypassrls"
SELECT * FROM insert_policy_violation_as_session_user(50);

statement ok
SET ROLE root;

statement ok
DROP FUNCTION insert_policy_violation_as_admin, insert_policy_violation_as_session_user

statement ok
DROP TABLE bypassrls;

statement ok
DROP USER bypassrls_user;

subtest end
