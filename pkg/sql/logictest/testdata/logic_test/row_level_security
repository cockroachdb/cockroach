# LogicTest: !local-legacy-schema-changer !local-mixed-25.2

subtest setup

let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
CREATE DATABASE db1;

statement ok
USE db1;

statement ok
GRANT ADMIN to testuser;

subtest create_drop_sanity

statement ok
CREATE TABLE sanity1();

statement ok
CREATE POLICY p1 on sanity1 USING (true);

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog WHERE "eventType" <> 'finish_schema_change' order by timestamp desc limit 1;
----
create_policy

statement error pq: policy with name "p1" already exists on table "sanity1"
CREATE POLICY p1 on sanity1 WITH CHECK (true);

statement notice NOTICE: policy "p1" already exists on table "sanity1", skipping
CREATE POLICY IF NOT EXISTS p1 on sanity1;

statement ok
CREATE POLICY IF NOT EXISTS p2 on sanity1 AS PERMISSIVE WITH CHECK (true);

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE sanity1;
----
sanity1  CREATE TABLE public.sanity1 (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT sanity1_pkey PRIMARY KEY (rowid ASC)
         );
         CREATE POLICY p1 ON public.sanity1 AS PERMISSIVE FOR ALL TO public USING (true);
         CREATE POLICY p2 ON public.sanity1 AS PERMISSIVE FOR ALL TO public WITH CHECK (true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE sanity1;
----
sanity1  CREATE TABLE public.sanity1 (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT sanity1_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         CREATE POLICY p1 ON public.sanity1 AS PERMISSIVE FOR ALL TO public USING (true);
         CREATE POLICY p2 ON public.sanity1 AS PERMISSIVE FOR ALL TO public WITH CHECK (true);

statement notice NOTICE: relation "nonexist" does not exist, skipping
DROP POLICY IF EXISTS notthere on nonexist;

statement notice NOTICE: policy "notthere" for relation "sanity1" does not exist, skipping
DROP POLICY IF EXISTS notthere on sanity1;

statement error pq: policy "notthere" for table "sanity1" does not exist
DROP POLICY notthere on sanity1;

statement ok
DROP POLICY p1 on sanity1;

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog WHERE "eventType" <> 'finish_schema_change' order by timestamp desc limit 1;
----
drop_policy

statement ok
DROP POLICY p2 on sanity1;

statement ok
CREATE POLICY newp1 on sanity1 AS PERMISSIVE USING (true) WITH CHECK (true);

statement ok
DROP TABLE sanity1;

subtest explicit_txn

statement ok
CREATE TABLE explicit1();

statement ok
SET use_declarative_schema_changer = 'unsafe_always';

statement ok
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

statement ok
CREATE POLICY p1 on explicit1;

statement ok
DROP POLICY p1 on explicit1;

statement ok
CREATE POLICY IF NOT EXISTS p1 on explicit1 AS PERMISSIVE USING (false);

statement ok
COMMIT;

statement ok
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

statement ok
DROP POLICY p1 on explicit1;

statement ok
CREATE POLICY p1 on explicit1 USING (false) WITH CHECK (true);

statement ok
COMMIT;

statement ok
DROP TABLE explicit1;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

subtest policy_type_and_command_ddl

statement ok
CREATE TABLE multi_pol_tab1 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy1" ON multi_pol_tab1 AS PERMISSIVE

statement ok
CREATE POLICY "policy2" ON multi_pol_tab1 AS RESTRICTIVE

statement ok
CREATE POLICY IF NOT EXISTS "policy3" ON multi_pol_tab1 FOR ALL

statement ok
CREATE POLICY "policy4" ON multi_pol_tab1 FOR INSERT

statement ok
CREATE POLICY "policy5" ON multi_pol_tab1 FOR UPDATE

statement ok
CREATE POLICY "policy6" ON multi_pol_tab1 FOR DELETE

statement ok
CREATE POLICY "policy7" ON multi_pol_tab1 FOR SELECT

statement ok
CREATE USER papa_roach

statement ok
CREATE POLICY "policy8" ON multi_pol_tab1 FOR ALL TO papa_roach, public

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                );
                CREATE POLICY policy1 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy3 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy5 ON public.multi_pol_tab1 AS PERMISSIVE FOR UPDATE TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                ) WITH (schema_locked = true);
                CREATE POLICY policy1 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy3 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy5 ON public.multi_pol_tab1 AS PERMISSIVE FOR UPDATE TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach;

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy
----
oid        polname  polrelid  polcmd  polpermissive  polroles       polqual  polwithcheck
577443713  policy1  110       *       true           {0}            NULL     NULL
577443714  policy2  110       *       false          {0}            NULL     NULL
577443715  policy3  110       *       true           {0}            NULL     NULL
577443716  policy4  110       a       true           {0}            NULL     NULL
577443717  policy5  110       w       true           {0}            NULL     NULL
577443718  policy6  110       d       true           {0}            NULL     NULL
577443719  policy7  110       r       true           {0}            NULL     NULL
577443720  policy8  110       *       true           {0,835509264}  NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies
----
schemaname  tablename       policyname  permissive   roles                cmd     qual  with_check
public      multi_pol_tab1  policy1     permissive   {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy2     restrictive  {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy3     permissive   {public}             ALL     NULL  NULL
public      multi_pol_tab1  policy4     permissive   {public}             INSERT  NULL  NULL
public      multi_pol_tab1  policy5     permissive   {public}             UPDATE  NULL  NULL
public      multi_pol_tab1  policy6     permissive   {public}             DELETE  NULL  NULL
public      multi_pol_tab1  policy7     permissive   {public}             SELECT  NULL  NULL
public      multi_pol_tab1  policy8     permissive   {public,papa_roach}  ALL     NULL  NULL

query TTTTTT colnames,rowsort
SHOW POLICIES FOR multi_pol_tab1
----
name     cmd     type         roles                using_expr  with_check_expr
policy1  ALL     permissive   {public}             ·           ·
policy2  ALL     restrictive  {public}             ·           ·
policy3  ALL     permissive   {public}             ·           ·
policy4  INSERT  permissive   {public}             ·           ·
policy5  UPDATE  permissive   {public}             ·           ·
policy6  DELETE  permissive   {public}             ·           ·
policy7  SELECT  permissive   {public}             ·           ·
policy8  ALL     permissive   {public,papa_roach}  ·           ·

statement ok
CREATE DATABASE roachdb

statement ok
USE roachdb

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies
----
schemaname  tablename  policyname  permissive  roles  cmd  qual  with_check

statement ok
USE db1

statement ok
DROP DATABASE roachdb

statement ok
CREATE TABLE multi_pol_tab2 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy9" ON multi_pol_tab2 FOR ALL

statement ok
CREATE POLICY "policy10" ON multi_pol_tab2 FOR ALL

statement ok
CREATE TABLE multi_pol_tab3 (c1 INT NOT NULL PRIMARY KEY)

statement ok
CREATE POLICY "policy11" ON multi_pol_tab3 FOR ALL

statement ok
CREATE POLICY "policy12" ON multi_pol_tab3 FOR ALL

skipif config fakedist-vec-off local-vec-off
query T
EXPLAIN (PLAN) select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab2'::regclass
----
distribution: local
vectorized: true
·
• render
│
└── • virtual table
      table: pg_policy@pg_policy_polrelid_idx
      spans: [/multi_pol_tab2 - /multi_pol_tab2]

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab2'::regclass
----
oid         polname   polrelid  polcmd  polpermissive  polroles  polqual  polwithcheck
3620125326  policy9   113       *       true           {0}       NULL     NULL
3620125325  policy10  113       *       true           {0}       NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies where tablename = 'multi_pol_tab2'
----
schemaname  tablename       policyname  permissive  roles     cmd  qual  with_check
public      multi_pol_tab2  policy9     permissive  {public}  ALL  NULL  NULL
public      multi_pol_tab2  policy10    permissive  {public}  ALL  NULL  NULL

query ITITBTTT colnames,rowsort
select oid::INT, polname, polrelid::INT, polcmd, polpermissive, polroles::string, polqual, polwithcheck from pg_catalog.pg_policy WHERE polrelid = 'multi_pol_tab3'::regclass
----
oid         polname   polrelid  polcmd  polpermissive  polroles  polqual  polwithcheck
3879861597  policy11  114       *       true           {0}       NULL     NULL
3879861598  policy12  114       *       true           {0}       NULL     NULL

query TTTTTTTT colnames,rowsort
select schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check from pg_catalog.pg_policies where tablename = 'multi_pol_tab3'
----
schemaname  tablename       policyname  permissive  roles     cmd  qual  with_check
public      multi_pol_tab3  policy11    permissive  {public}  ALL  NULL  NULL
public      multi_pol_tab3  policy12    permissive  {public}  ALL  NULL  NULL

query TTTTTT colnames,rowsort
SHOW POLICIES FOR multi_pol_tab2
----
name      cmd  type        roles     using_expr  with_check_expr
policy9   ALL  permissive  {public}  ·           ·
policy10  ALL  permissive  {public}  ·           ·

query TTTTTT colnames,rowsort
SHOW POLICIES FOR public.multi_pol_tab3
----
name      cmd  type        roles     using_expr  with_check_expr
policy11  ALL  permissive  {public}  ·           ·
policy12  ALL  permissive  {public}  ·           ·

statement ok
DROP POLICY "policy1" ON multi_pol_tab1

statement ok
DROP POLICY "policy3" ON multi_pol_tab1

statement ok
DROP POLICY "policy5" ON multi_pol_tab1

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                );
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE multi_pol_tab1
----
multi_pol_tab1  CREATE TABLE public.multi_pol_tab1 (
                  c1 INT8 NOT NULL,
                  CONSTRAINT multi_pol_tab1_pkey PRIMARY KEY (c1 ASC)
                ) WITH (schema_locked = true);
                CREATE POLICY policy2 ON public.multi_pol_tab1 AS RESTRICTIVE FOR ALL TO public;
                CREATE POLICY policy4 ON public.multi_pol_tab1 AS PERMISSIVE FOR INSERT TO public;
                CREATE POLICY policy6 ON public.multi_pol_tab1 AS PERMISSIVE FOR DELETE TO public;
                CREATE POLICY policy7 ON public.multi_pol_tab1 AS PERMISSIVE FOR SELECT TO public;
                CREATE POLICY policy8 ON public.multi_pol_tab1 AS PERMISSIVE FOR ALL TO public, papa_roach;

statement ok
DROP POLICY "policy9" ON multi_pol_tab2

statement ok
DROP POLICY "policy10" ON multi_pol_tab2

statement ok
DROP POLICY "policy11" ON multi_pol_tab3

statement ok
DROP POLICY "policy12" ON multi_pol_tab3

statement ok
DROP TABLE multi_pol_tab1

statement ok
DROP TABLE multi_pol_tab2

statement ok
DROP TABLE multi_pol_tab3

subtest drop_role_is_blocked

statement ok
CREATE TABLE drop_role_chk();

statement ok
CREATE USER fred;

statement ok
CREATE USER bob;

statement ok
CREATE POLICY p1 on drop_role_chk to fred,bob;

statement error pq: role "bob" cannot be dropped because some objects depend on it\nDETAIL: target of policy "p1" on table "drop_role_chk"
DROP ROLE bob;

statement error pq: role "fred" cannot be dropped because some objects depend on it\nDETAIL: target of policy "p1" on table "drop_role_chk"
DROP ROLE fred;

statement ok
DROP POLICY p1 on drop_role_chk;

statement ok
DROP ROLE bob,fred;

statement ok
DROP TABLE drop_role_chk;

subtest role_doesnt_exist

statement ok
CREATE TABLE role_exist_chk();

statement error pq: role/user "zeke" does not exist
CREATE POLICY IF NOT EXISTS p1 on role_exist_chk to zeke;

statement ok
CREATE USER zeke;

statement ok
CREATE POLICY p1 on role_exist_chk to zeke;

statement ok
DROP TABLE role_exist_chk;

statement ok
DROP ROLE zeke;

subtest current_session_and_user

statement ok
CREATE TABLE target();

statement ok
CREATE USER john;

statement ok
GRANT ALL ON db1.* to testuser;

statement ok
GRANT ALL ON db1.* to john;

statement ok
ALTER TABLE target OWNER TO john;

statement ok
GRANT SYSTEM MODIFYCLUSTERSETTING TO testuser;

user testuser

statement ok
USE db1;

statement ok
SET ROLE john;

query TT
SELECT current_user, session_user
----
john testuser

statement ok
CREATE POLICY pol on target TO current_user,session_user;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE target
----
target  CREATE TABLE public.target (
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT target_pkey PRIMARY KEY (rowid ASC)
        );
        CREATE POLICY pol ON public.target AS PERMISSIVE FOR ALL TO john, testuser;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE target
----
target  CREATE TABLE public.target (
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT target_pkey PRIMARY KEY (rowid ASC)
        ) WITH (schema_locked = true);
        CREATE POLICY pol ON public.target AS PERMISSIVE FOR ALL TO john, testuser;

user root

statement ok
USE db1;

query TT
SELECT current_user, session_user
----
root root

statement error pq: role "john" cannot be dropped because some objects depend on it\nDETAIL: target of policy "pol" on table "target"
DROP ROLE john;

statement error pq: role "testuser" cannot be dropped because some objects depend on it\nDETAIL: target of policy "pol" on table "target"
DROP ROLE testuser;

statement ok
DROP TABLE target;

statement ok
DROP ROLE john;

subtest udt_ref

statement ok
CREATE TYPE greeting AS ENUM ('hello', 'hi', 'howdy');

statement ok
CREATE TABLE z1 (c1 text);

statement ok
CREATE POLICY IF NOT EXISTS p1 on z1 WITH CHECK (c1::greeting = 'hi'::greeting);

query T rowsort
select polwithcheck from pg_catalog.pg_policy
----
c1::public.greeting = 'hi':::public.greeting

query T rowsort
select with_check_expr from [SHOW POLICIES FOR z1];
----
c1::public.greeting = 'hi':::public.greeting

statement error pq: cannot drop type "greeting" because other objects \(\[db1\.public\.z1\]\) still depend on it
DROP TYPE greeting;

statement ok
SET use_declarative_schema_changer = 'off';

statement error pq: cannot drop type "greeting" because other objects \(\[db1\.public\.z1\]\) still depend on it
DROP TYPE greeting;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement ok
DROP POLICY p1 on z1;

statement ok
DROP TYPE greeting;

statement error pq: type "greeting" does not exist
CREATE POLICY p1 on z1 WITH CHECK (c1::greeting = 'hi'::greeting);

statement ok
DROP TABLE z1;

subtest seq_ref

statement ok
CREATE SEQUENCE seq1;

statement ok
CREATE TABLE pws ();

statement ok
CREATE POLICY p1 on pws AS RESTRICTIVE WITH CHECK (nextval('seq1') < 100);

statement error pq: cannot drop sequence seq1 because other objects depend on it
DROP SEQUENCE seq1;

statement ok
DROP POLICY p1 on pws;

statement ok
DROP SEQUENCE seq1;

statement ok
DROP TABLE pws;

subtest func_ref

statement ok
CREATE FUNCTION is_valid(n INT) RETURNS BOOL AS $$
BEGIN
  RETURN n < 10;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TABLE funcref (c1 int);

statement ok
CREATE POLICY pol1 on funcref USING (is_valid(c1)) WITH CHECK (is_valid(c1));

query T
select polqual from pg_catalog.pg_policy
----
public.is_valid(c1)

query T rowsort
select using_expr from [SHOW POLICIES FOR funcref];
----
public.is_valid(c1)

query TT colnames,rowsort
select qual, with_check from pg_catalog.pg_policies where tablename = 'funcref'
----
qual                 with_check
public.is_valid(c1)  public.is_valid(c1)

statement error pq: cannot drop function "is_valid" because other objects \(\[db1.public.funcref\]\) still depend on it
DROP FUNCTION is_valid;

statement ok
DROP POLICY pol1 on funcref;

statement ok
DROP FUNCTION is_valid;

statement ok
DROP TABLE funcref;

subtest col_ref

statement ok
CREATE TABLE colref (rename_c1 INT, rename_c2 INT, C3 INT);

statement ok
CREATE POLICY p1 ON colref USING (rename_c1 < 10);

statement ok
CREATE POLICY p2 ON colref WITH CHECK (rename_c2 < 100);

# Attempt to alter/drop column referenced in USING expression
statement ok
ALTER TABLE colref RENAME COLUMN rename_c1 to c1;

statement error pq: cannot drop column "c1" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c1;

statement ok
SET use_declarative_schema_changer = 'off';

skipif config schema-locked-disabled
statement ok
ALTER TABLE colref SET (schema_locked=false)

statement error pq: cannot drop column "c1" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c1;


skipif config schema-locked-disabled
statement ok
ALTER TABLE colref SET (schema_locked=true)

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement error pq: cannot alter type of column "c1" because it is referenced in a policy expression
ALTER TABLE colref ALTER COLUMN c1 SET DATA TYPE TEXT USING c1::text;

statement ok
DROP POLICY p1 ON colref;

statement ok
ALTER TABLE colref ALTER COLUMN c1 SET DATA TYPE TEXT USING c1::text;

statement ok
ALTER TABLE colref DROP COLUMN c1;

# Repeat for a column referenced with WITH CHECK expression
statement ok
ALTER TABLE colref RENAME COLUMN rename_c2 TO c2;

statement error pq: cannot drop column "c2" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c2;

statement ok
SET use_declarative_schema_changer = 'off';

skipif config schema-locked-disabled
statement ok
ALTER TABLE colref SET (schema_locked=false)

statement error pq: cannot drop column "c2" because it is referenced in a policy expression
ALTER TABLE colref DROP COLUMN c2;

skipif config schema-locked-disabled
statement ok
ALTER TABLE colref SET (schema_locked=true)

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement error pq: cannot alter type of column "c2" because it is referenced in a policy expression
ALTER TABLE colref ALTER COLUMN c2 SET DATA TYPE TEXT USING c2::text;

statement ok
DROP POLICY p2 ON colref;

statement ok
ALTER TABLE colref ALTER COLUMN c2 SET DATA TYPE TEXT USING c2::text;

statement ok
ALTER TABLE colref DROP COLUMN c2;

statement ok
DROP TABLE colref;

# Added for bug found in issue #147471
subtest func_ref

statement ok
CREATE FUNCTION f() RETURNS BOOL LANGUAGE SQL AS $$ SELECT true; $$;

statement ok
CREATE TABLE t (x INT, y INT, b BOOL DEFAULT f());

statement ok
CREATE POLICY p ON t USING (f());

query T
SELECT jsonb_pretty(crdb_internal.pb_to_json('descriptor', descriptor)->'function'->'dependedOnBy') as dependedOnBy
FROM system.descriptor
WHERE id = (select 'f'::REGPROC::INT - 100000);
----
[
    {
        "columnIds": [
            3
        ],
        "id": 127,
        "policyIds": [
            1
        ]
    }
]

# Function reference should be updated but still include dependency on policy.
statement ok
ALTER TABLE t DROP COLUMN b;

query T
SELECT jsonb_pretty(crdb_internal.pb_to_json('descriptor', descriptor)->'function'->'dependedOnBy') as dependedOnBy
FROM system.descriptor
WHERE id = (select 'f'::REGPROC::INT - 100000);
----
[
    {
        "id": 127,
        "policyIds": [
            1
        ]
    }
]

query B
SELECT f();
----
true

statement ok
DROP TABLE t;

statement ok
DROP FUNCTION f;

subtest no_subvar_expr

statement ok
CREATE TABLE t1 (c1 int);

statement ok
CREATE TABLE t2 (c1 int);

statement error pq: variable sub-expressions are not allowed in POLICY USING
CREATE POLICY p1 on t1 USING (c1 < (select max(c1) from t1));

statement error pq: variable sub-expressions are not allowed in POLICY WITH CHECK
CREATE POLICY p1 on t1 WITH CHECK (c1 < (select max(c1) from t1));

statement ok
DROP TABLE t1;

statement ok
DROP TABLE t2;

subtest create_policy_udt_using_check

statement ok
create type roach_type as enum('flying','crawling')

statement ok
create table flying_roaches (check ('flying'::roach_type = 'crawling'::roach_type))

statement ok
create policy p1 on flying_roaches using ('flying'::roach_type = 'crawling'::roach_type)

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE flying_roaches
----
flying_roaches  CREATE TABLE public.flying_roaches (
                  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
                  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
                );
                CREATE POLICY p1 ON public.flying_roaches AS PERMISSIVE FOR ALL TO public USING ('flying':::public.roach_type = 'crawling':::public.roach_type);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE flying_roaches
----
flying_roaches  CREATE TABLE public.flying_roaches (
                  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
                  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
                ) WITH (schema_locked = true);
                CREATE POLICY p1 ON public.flying_roaches AS PERMISSIVE FOR ALL TO public USING ('flying':::public.roach_type = 'crawling':::public.roach_type);

onlyif config schema-locked-disabled
query T
select create_statement from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
CREATE TABLE public.flying_roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
)

skipif config schema-locked-disabled
query T
select create_statement from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
CREATE TABLE public.flying_roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT flying_roaches_pkey PRIMARY KEY (rowid ASC),
  CONSTRAINT "check" CHECK ('flying':::public.roach_type = 'crawling':::public.roach_type)
) WITH (schema_locked = true)

query T
select rls_statements from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
{"CREATE POLICY p1 ON public.flying_roaches AS PERMISSIVE FOR ALL TO public USING ('flying':::public.roach_type = 'crawling':::public.roach_type)"}

query T
select fk_statements from crdb_internal.create_statements where descriptor_name='flying_roaches'
----
{}

statement ok
drop table flying_roaches

statement ok
drop type roach_type

subtest insert_returning

statement ok
CREATE TABLE ins (c1 INT);

statement ok
CREATE USER ins;

statement ok
CREATE TABLE other (k INT PRIMARY KEY);

statement ok
INSERT INTO other VALUES (99);

statement ok
GRANT ALL ON other TO ins;

statement ok
ALTER TABLE ins OWNER TO ins;

statement ok
SET ROLE ins;

statement ok
CREATE POLICY p_ins ON ins FOR INSERT WITH CHECK (c1 > 0);

statement ok
CREATE POLICY p_sel ON ins FOR SELECT USING (c1 % 2 = 0);

statement ok
ALTER TABLE ins FORCE ROW LEVEL SECURITY, ENABLE ROW LEVEL SECURITY;

# Verify that p_ins allows all positive rows to be inserted.
statement ok
INSERT INTO ins VALUES (1),(2),(3),(4);

# Verify that the same statement with RETURNING will fail because it enforces
# the SELECT policy. Unless the RETURNING clause doesn't reference any columns.
statement error pq: new row violates row-level security policy for table "ins"
INSERT INTO ins VALUES (1),(2),(3),(4) RETURNING c1;

statement error pq: new row violates row-level security policy for table "ins"
INSERT INTO ins VALUES (5) RETURNING *;

statement error pq: new row violates row-level security policy for table "ins"
INSERT INTO ins VALUES (7) RETURNING (select ins.c1);

query T
INSERT INTO ins VALUES (9) RETURNING 'foo';
----
foo

query I
INSERT INTO ins VALUES (11) RETURNING (select 1);
----
1

query I
INSERT INTO ins VALUES (13) RETURNING (SELECT k FROM other);
----
99

statement ok
CREATE FUNCTION insert_15(n INT) RETURNS INT AS $$
  INSERT INTO ins VALUES (15) RETURNING n;
$$ LANGUAGE SQL

query I
SELECT insert_15(0)
----
0

statement ok
DROP FUNCTION insert_15

# Verify that only rows that pass the USING expression are allowed (even numbers).
statement ok
INSERT INTO ins VALUES (2),(4) RETURNING c1;

# Verify that insert policy violation applies when using RETURNING
statement error pq: new row violates row-level security policy for table "ins"
INSERT INTO ins VALUES (2),(4),(-2),(-4) RETURNING c1;

statement ok
SET ROLE root;

statement ok
DROP TABLE ins;

statement ok
DROP TABLE other;

statement ok
DROP USER ins;

subtest alter_table_rls_legacy_unimplemented

statement ok
SET use_declarative_schema_changer = 'off';

statement ok
CREATE TABLE roaches()

statement ok
ALTER TABLE roaches SET (schema_locked=false);

statement error pq: ALTER TABLE ... ROW LEVEL SECURITY is only implemented in the declarative schema changer
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY;

statement ok
ALTER TABLE roaches SET (schema_locked=true);

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

subtest alter_table_rls_enable_disable

statement ok
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY;

statement ok
ALTER TABLE roaches DISABLE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  false

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

subtest alter_table_rls_force_no_force

statement ok
ALTER TABLE roaches FORCE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  true

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches FORCE ROW LEVEL SECURITY;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches FORCE ROW LEVEL SECURITY;

statement ok
ALTER TABLE roaches NO FORCE ROW LEVEL SECURITY;

query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  false  false

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

subtest alter_table_rls_enable_force

statement ok
ALTER TABLE roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);
         ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;


query TBB
select relname, relrowsecurity, relforcerowsecurity from pg_class where relname = 'roaches';
----
roaches  true  true

skipif config schema-locked-disabled
query T
select create_statement from crdb_internal.create_statements where descriptor_name='roaches'
----
CREATE TABLE public.roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
) WITH (schema_locked = true)

onlyif config schema-locked-disabled
query T
select create_statement from crdb_internal.create_statements where descriptor_name='roaches'
----
CREATE TABLE public.roaches (
  rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
  CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
) WITH (schema_locked = true)

query TTT
select rls_statements, fk_statements, create_nofks from crdb_internal.create_statements where descriptor_name='roaches'
----
{"ALTER TABLE public.roaches ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY"}  {}  CREATE TABLE public.roaches (
                                                                                          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
                                                                                          CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
                                                                                        ) WITH (schema_locked = true)

statement ok
ALTER TABLE roaches DISABLE ROW LEVEL SECURITY, NO FORCE ROW LEVEL SECURITY;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE roaches
----
roaches  CREATE TABLE public.roaches (
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT roaches_pkey PRIMARY KEY (rowid ASC)
         ) WITH (schema_locked = true);

query T
select rls_statements from crdb_internal.create_statements where descriptor_name='roaches'
----
{}

query T
select fk_statements from crdb_internal.create_statements where descriptor_name='roaches'
----
{}

statement ok
DROP TABLE roaches;

subtest using_expression_applied

statement ok
CREATE TYPE league AS ENUM('AL','NL');

statement ok
CREATE TABLE bbteams (team text, league league, family (team, league));

statement ok
ALTER TABLE bbteams ENABLE ROW LEVEL SECURITY;

statement ok
INSERT INTO bbteams VALUES ('jays', 'AL'), ('tigers', 'AL'), ('cardinals', 'NL'), ('orioles', 'AL'), ('nationals', 'NL');

# Confirm admin user can see all rows
query TT
select team, league from bbteams order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

statement ok
CREATE USER buck;

statement ok
GRANT ALL ON bbteams TO buck;

statement ok
set role buck

# user buck can't see anything because they aren't admin, rls is enabled and no policies are defined.
query TT
select team, league from bbteams order by league, team;
----

statement ok
set role root

# We will create a function and a sequence to include in the expression, as
# these introduce additional dependencies compared to a plain expression using
# basic types.
statement ok
CREATE FUNCTION is_valid(l league) RETURNS BOOL AS $$
BEGIN
  RETURN l = 'AL';
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE SEQUENCE seq1;

statement ok
GRANT USAGE ON seq1 TO buck;

statement ok
create policy restrict_select on bbteams for select to buck,current_user,session_user using (is_valid(league) and nextval('seq1') < 1000);

query T rowsort
select using_expr from [SHOW POLICIES FOR bbteams];
----
public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8)

# confirm admin can see all
query TT
select team, league from bbteams where team != 'cardinals' order by league, team;
----
jays AL
orioles AL
tigers AL
nationals NL

statement ok
set role buck

# Retry the same query issue before to ensure memo is properly invalidated.
query TT
select team, league from bbteams where team != 'cardinals' order by league, team;
----
jays AL
orioles AL
tigers AL

# Try another query we know isn't in the statement cache.
query TT
select team, league from bbteams where team != 'astros' order by league, team;
----
jays AL
orioles AL
tigers AL

# Verify that if admin is granted to user buck, it sees all rows because RLS is exempt.
statement ok
set role root

statement ok
GRANT admin TO buck;

statement ok
set role buck;

# This is the same query as before, but since admin changed, we will see all of the rows.
query TT
select team, league from bbteams where team != 'astros' order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

# Retry with a query never tried before so we avoid the statement cache.
query TT
select team, league from bbteams where team != 'mariners' order by league, team;
----
jays AL
orioles AL
tigers AL
cardinals NL
nationals NL

statement ok
set role root

statement ok
REVOKE admin FROM buck;

statement ok
set role buck

# Retry same query we ran before to ensure it's properly invalidated in the statement cache.
query TT
select team, league from bbteams where team != 'mariners' order by league, team;
----
jays AL
orioles AL
tigers AL

statement ok
set role root

# Add policies that apply to other commands. Only SELECT will return rows.
statement ok
CREATE POLICY restrict_insert ON bbteams FOR INSERT TO buck WITH CHECK (false);

statement ok
CREATE POLICY IF NOT EXISTS restrict_delete ON bbteams FOR DELETE TO buck USING (false);

statement ok
CREATE POLICY restrict_update ON bbteams FOR UPDATE TO buck USING (false);

statement ok
set role buck

# Verify SELECT will use the original policy that restricts rows just to AL teams
query TT
select team, league from bbteams where team != 'jays' order by league, team;
----
orioles AL
tigers AL

# Try updating a row. The policy for update will prevent us from reading the row.
statement ok
UPDATE bbteams SET team = 'blue jays' where team = 'jays';

query TT
select team, league from bbteams order by league, team;
----
jays AL
orioles AL
tigers AL

# Switch the policy to allow an update, but only for rows in the AL league.
statement ok
set role root

statement ok
DROP POLICY restrict_update on bbteams;

statement ok
create policy restrict_update on bbteams for update to buck using (is_valid(league) and nextval('seq1') < 1000);

statement ok
set role buck

# Allowed
statement ok
UPDATE bbteams SET team = 'Jays' where team = 'jays';

# Not allowed
statement ok
UPDATE bbteams SET team = 'Nationals' where team = 'nationals';

statement ok
set role root

query TT
select team, league from bbteams where team in ('jays', 'Jays', 'nationals', 'Nationals') order by league, team;
----
Jays AL
nationals NL

statement ok
set role buck

# Try to delete the row. The delete policy will prevent us from reading the row.
statement ok
DELETE FROM bbteams;

query TT
select team, league from bbteams order by league, team;
----
Jays     AL
orioles  AL
tigers   AL

# Switch the delete policy to allow deletion of only the tigers
statement ok
set role root

statement ok
DROP POLICY restrict_delete on bbteams;

statement ok
create policy restrict_delete on bbteams for delete to buck using (is_valid(league) and team = 'tigers' and nextval('seq1') < 1000);

statement ok
set role buck

statement ok
DELETE FROM bbteams WHERE team != 'pirates';

query TT
select team, league from bbteams where team != 'pirates' order by league, team;
----
Jays     AL
orioles  AL

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE bbteams
----
bbteams  CREATE TABLE public.bbteams (
           team STRING NULL,
           league public.league NULL,
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT bbteams_pkey PRIMARY KEY (rowid ASC),
           FAMILY fam_0_team_league_rowid (team, league, rowid)
         ) WITH (schema_locked = true);
         ALTER TABLE public.bbteams ENABLE ROW LEVEL SECURITY;
         CREATE POLICY restrict_select ON public.bbteams AS PERMISSIVE FOR SELECT TO buck, root USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_insert ON public.bbteams AS PERMISSIVE FOR INSERT TO buck WITH CHECK (false);
         CREATE POLICY restrict_update ON public.bbteams AS PERMISSIVE FOR UPDATE TO buck USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_delete ON public.bbteams AS PERMISSIVE FOR DELETE TO buck USING ((public.is_valid(league) AND (team = 'tigers':::STRING)) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE bbteams
----
bbteams  CREATE TABLE public.bbteams (
           team STRING NULL,
           league public.league NULL,
           rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
           CONSTRAINT bbteams_pkey PRIMARY KEY (rowid ASC),
           FAMILY fam_0_team_league_rowid (team, league, rowid)
         );
         ALTER TABLE public.bbteams ENABLE ROW LEVEL SECURITY;
         CREATE POLICY restrict_select ON public.bbteams AS PERMISSIVE FOR SELECT TO buck, root USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_insert ON public.bbteams AS PERMISSIVE FOR INSERT TO buck WITH CHECK (false);
         CREATE POLICY restrict_update ON public.bbteams AS PERMISSIVE FOR UPDATE TO buck USING (public.is_valid(league) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));
         CREATE POLICY restrict_delete ON public.bbteams AS PERMISSIVE FOR DELETE TO buck USING ((public.is_valid(league) AND (team = 'tigers':::STRING)) AND (nextval('public.seq1'::REGCLASS) < 1000:::INT8));

statement ok
set role root

statement ok
DROP TABLE bbteams;

statement ok
DROP SEQUENCE seq1;

statement ok
DROP FUNCTION is_valid;

# This subtest verifies proper cleanup of policy elements when dropping with CASCADE.
subtest drop_with_cascade

statement ok
CREATE DATABASE db2;

statement ok
use db2;

statement ok
CREATE TYPE classes AS ENUM('mammals','birds', 'fish', 'reptiles', 'amphibians');

statement ok
CREATE TABLE animals (name text, class classes, family (name, class));

statement ok
ALTER TABLE animals ENABLE ROW LEVEL SECURITY;

statement ok
create policy p1 on animals for select to current_user using (class in ('mammals','birds'));

statement ok
use defaultdb;

statement ok
drop database db2 cascade;

# Ensure that functions defined with security behave as expected
subtest function_security_definer

statement ok
CREATE USER sensitive_user;

statement ok
CREATE TABLE sensitive_data_table (C1 INT);

statement ok
INSERT INTO sensitive_data_table VALUES (0),(1),(2);

statement ok
ALTER TABLE sensitive_data_table ENABLE ROW LEVEL SECURITY;

statement ok
GRANT ALL ON sensitive_data_table TO sensitive_user;

statement ok
CREATE FUNCTION my_sec_definer_reader_function() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT * FROM sensitive_data_table
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_reader_function() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT * FROM sensitive_data_table
$$;

statement ok
CREATE FUNCTION my_sec_definer_inserter_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 INSERT INTO sensitive_data_table VALUES (v)
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_inserter_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 INSERT INTO sensitive_data_table VALUES (v)
$$;


statement ok
CREATE FUNCTION my_sec_definer_updater_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 UPDATE sensitive_data_table SET c1=v*2 WHERE c1 = v
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION my_non_sec_definer_updater_function(v INT) RETURNS VOID
LANGUAGE SQL AS
$$
 UPDATE sensitive_data_table SET c1=v*2 WHERE c1 = v
$$;

statement ok
SET ROLE sensitive_user;

query I rowsort
SELECT * FROM sensitive_data_table;
----

query I
select my_sec_definer_inserter_function(10);
----
NULL

query I
select my_sec_definer_updater_function(2);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

query I rowsort
SELECT my_non_sec_definer_reader_function();
-----

statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_inserter_function(20);

# No error from the update because the lack of policies won't read any rows to
# update. We verify nothing has changed right after.
query I
select my_non_sec_definer_updater_function(4);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

statement ok
SET ROLE root

statement ok
CREATE POLICY p1 ON sensitive_data_table FOR SELECT TO sensitive_user USING (C1 != 0);

statement ok
SET ROLE sensitive_user;

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
10

query I rowsort
SELECT my_non_sec_definer_reader_function()
----
1
4
10

statement ok
SET ROLE root;

statement ok
CREATE POLICY p2 ON sensitive_data_table FOR INSERT TO sensitive_user WITH CHECK (C1 != 55);

statement ok
CREATE POLICY IF NOT EXISTS p3 ON sensitive_data_table FOR UPDATE TO sensitive_user USING (true) WITH CHECK (C1 >= 10);

statement ok
SET ROLE sensitive_user;

# violates new policy for insert
statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_inserter_function(55);

query I
select my_non_sec_definer_inserter_function(54);
----
NULL

# violates new policy for update
statement error pq: new row violates row-level security policy for table "sensitive_data_table"
select my_non_sec_definer_updater_function(4);

query I
select my_non_sec_definer_updater_function(10);
----
NULL

query I rowsort
SELECT my_sec_definer_reader_function();
----
0
1
4
20
54

statement ok
SET ROLE root

statement ok
DROP FUNCTION my_sec_definer_reader_function;

statement ok
DROP FUNCTION my_non_sec_definer_reader_function;

statement ok
DROP TABLE sensitive_data_table CASCADE;

subtest alter_policy

statement ok
CREATE TABLE alter_policy_table (c1 INT NOT NULL PRIMARY KEY, c2 TEXT, FAMILY (c1, c2));

statement ok
ALTER TABLE alter_policy_table ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE ROLE alter_policy_role;

statement ok
CREATE ROLE aux1;

statement ok
CREATE USER aux2;

statement ok
CREATE SEQUENCE seq1;

statement ok
GRANT ALL ON seq1 TO alter_policy_role;

statement ok
ALTER TABLE alter_policy_table OWNER TO alter_policy_role;

statement ok
SET ROLE alter_policy_role;

statement ok
CREATE POLICY p ON alter_policy_table FOR INSERT WITH CHECK (false);

statement error pq: new row violates row-level security policy for table "alter_policy_table"
INSERT INTO alter_policy_table VALUES (1, 'one'), (2, 'two'), (3, 'three');

statement error pq: only WITH CHECK expression allowed for INSERT
ALTER POLICY p ON alter_policy_table USING (true);

statement ok
ALTER POLICY p ON alter_policy_table WITH CHECK (nextval('seq1') < 10000);

statement ok
INSERT INTO alter_policy_table VALUES (1, 'one'), (2, 'two'), (3, 'three');

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----

statement ok
ALTER POLICY p ON alter_policy_table RENAME TO p_ins;

statement ok
CREATE POLICY p ON alter_policy_table FOR SELECT TO aux1 USING (c1 > 0);

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----

statement error pq: policy "p_sel" for table "alter_policy_table" does not exist
ALTER POLICY p_sel ON alter_policy_table WITH CHECK (true);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
ALTER POLICY p ON alter_policy_table WITH CHECK (true);

statement ok
ALTER POLICY p ON alter_policy_table TO alter_policy_role,aux1,aux2 USING (c1 != 1);

query I
SELECT c1 FROM alter_policy_table ORDER BY c1;
----
2
3

statement ok
ALTER POLICY p ON alter_policy_table RENAME TO p_sel;

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table;
----
alter_policy_table  CREATE TABLE public.alter_policy_table (
                      c1 INT8 NOT NULL,
                      c2 STRING NULL,
                      CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                      FAMILY fam_0_c1_c2 (c1, c2)
                    ) WITH (schema_locked = true);
                    ALTER TABLE public.alter_policy_table ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
                    CREATE POLICY p_ins ON public.alter_policy_table AS PERMISSIVE FOR INSERT TO public WITH CHECK (nextval('public.seq1'::REGCLASS) < 10000:::INT8);
                    CREATE POLICY p_sel ON public.alter_policy_table AS PERMISSIVE FOR SELECT TO aux1, alter_policy_role, aux2 USING (c1 != 1:::INT8);

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table;
----
alter_policy_table  CREATE TABLE public.alter_policy_table (
                      c1 INT8 NOT NULL,
                      c2 STRING NULL,
                      CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                      FAMILY fam_0_c1_c2 (c1, c2)
                    );
                    ALTER TABLE public.alter_policy_table ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
                    CREATE POLICY p_ins ON public.alter_policy_table AS PERMISSIVE FOR INSERT TO public WITH CHECK (nextval('public.seq1'::REGCLASS) < 10000:::INT8);
                    CREATE POLICY p_sel ON public.alter_policy_table AS PERMISSIVE FOR SELECT TO aux1, alter_policy_role, aux2 USING (c1 != 1:::INT8);

query TTTTTT colnames
SELECT name,cmd,type,roles,using_expr,with_check_expr
FROM [SHOW POLICIES FOR alter_policy_table]
ORDER BY name DESC;
----
name   cmd     type        roles                          using_expr      with_check_expr
p_sel  SELECT  permissive  {alter_policy_role,aux1,aux2}  c1 != 1:::INT8  ·
p_ins  INSERT  permissive  {public}                       ·               nextval('public.seq1'::REGCLASS) < 10000:::INT8

statement ok
SET ROLE root;

statement error pq: cannot drop sequence seq1 because other objects depend on it
DROP SEQUENCE seq1;

# Change the policy so there isn't a dependency on seq1 anymore.
statement ok
ALTER POLICY p_ins ON alter_policy_table WITH CHECK (true);

statement ok
DROP SEQUENCE seq1;

statement ok
DROP TABLE alter_policy_table;

statement ok
DROP ROLE alter_policy_role, aux1, aux2;

# Verify that you need to be the table owner to do any of the RLS DDLs
subtest table_owner_and_rls_ddl

statement ok
CREATE USER tab_owner;

statement ok
CREATE USER nontab_owner;

statement ok
CREATE TABLE table_owner_test ();

statement ok
ALTER TABLE table_owner_test OWNER TO tab_owner;

statement ok
GRANT ALL ON table_owner_test TO nontab_owner;

statement ok
SET ROLE tab_owner;

statement ok
ALTER TABLE table_owner_test ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p1 on table_owner_test;

statement ok
DROP POLICY p1 on table_owner_test;

statement ok
CREATE POLICY new_p1 on table_owner_test;

statement ok
ALTER POLICY new_p1 on table_owner_test RENAME TO p1;

statement ok
ALTER POLICY p1 on table_owner_test RENAME TO new_p1;

statement ok
ALTER POLICY new_p1 on table_owner_test USING (true);

statement ok
SET ROLE nontab_owner;

statement error pq: must be owner of relation table_owner_test
ALTER TABLE table_owner_test DISABLE ROW LEVEL SECURITY;

statement error pq: must be owner of relation table_owner_test
ALTER TABLE table_owner_test NO FORCE ROW LEVEL SECURITY;

statement error pq: must be owner of relation table_owner_test
CREATE POLICY IF NOT EXISTS p2 on table_owner_test;

statement error pq: must be owner of relation table_owner_test
DROP POLICY new_p1 on table_owner_test;

statement error pq: must be owner of relation table_owner_test
ALTER POLICY new_p1 on table_owner_test WITH CHECK (true);

statement error pq: must be owner of relation table_owner_test
ALTER POLICY new_p1 on table_owner_test RENAME TO p1;

statement ok
SET ROLE root

statement ok
DROP TABLE table_owner_test;

statement ok
DROP ROLE nontab_owner, tab_owner;

subtest force

statement ok
CREATE USER forcer;

statement ok
CREATE USER funuser;

statement ok
GRANT CREATE ON DATABASE db1 TO forcer;

statement ok
set role forcer;

statement ok
CREATE TABLE force_check (c1 INT NOT NULL PRIMARY KEY, c2 TEXT);

statement ok
INSERT INTO force_check VALUES (10, 'ten'), (20, 'twenty'), (50, 'fifty')

statement ok
CREATE FUNCTION access_large_c2_as_session_user() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT c1 FROM force_check WHERE length(c2) > 3
$$;

statement ok
CREATE FUNCTION access_large_c2_as_forcer() RETURNS TABLE(ID INT)
LANGUAGE SQL AS
$$
 SELECT c1 FROM force_check WHERE length(c2) > 3
$$ SECURITY DEFINER;

statement ok
CREATE FUNCTION insert_policy_violation_as_session_user(c1 INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO force_check VALUES (c1, 't - violated col value') RETURNING c1, c2
$$;

statement ok
CREATE FUNCTION insert_policy_violation_as_forcer(c1 INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO force_check VALUES (c1, 't - violated col value') RETURNING c1, c2
$$ SECURITY DEFINER;

statement ok
ALTER TABLE force_check ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_sel ON force_check TO forcer, funuser USING (c2 not like 't%');

# Should see only part of the rows because we are the table owner with FORCE on.
# We use different queries, all showing the same results, so that the query cache
# has multiple statements. We will retry the exact same SQL later once RLS
# settings have changed. I label each query (e.g. q1) so it can be easily
# found when its reused in this subtest.
#
# q1
query IT
SELECT c1, c2 FROM force_check ORDER BY c1;
----
50 fifty

# q2
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement error pq: new row violates row-level security policy for table "force_check"
INSERT INTO force_check VALUES (30, 'thirty')

# Verify the admin can still see everything
statement ok
SET ROLE root

# q1 - show that query reuse doesn't occur for different user
query IT
SELECT c1, c2 FROM force_check ORDER BY c1;
----
10 ten
20 twenty
50 fifty

statement ok
INSERT INTO force_check VALUES (33, 'thirty-three')

statement ok
SET ROLE forcer;

# Turn off force to ensure we can see everything again.
statement ok
ALTER TABLE force_check NO FORCE ROW LEVEL SECURITY;

statement ok
INSERT INTO force_check VALUES (30, 'thirty')

# q2 - should not reuse because table version since last use
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
10 ten
20 twenty
30 thirty
33 thirty-three
50 fifty

# Transfer ownership of force_check back to the root and attempt query from cache.
statement ok
SET ROLE root

statement ok
ALTER TABLE force_check OWNER TO root;

statement ok
GRANT ALL ON force_check TO forcer;

statement ok
SET ROLE forcer;

# q2 - should not be reused due to an ownership change, which has resulted in a
# new table version since its last use
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement ok
SET ROLE root;

# Turn on force again, but it shouldn't matter because we aren't the owner anymore
statement ok
ALTER TABLE force_check FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE forcer;

# q2 - should not reuse because table version change
query IT
SELECT c1, c2 FROM force_check WHERE c1 > 0 ORDER BY c1;
----
50 fifty

statement error pq: new row violates row-level security policy for table "force_check"
INSERT INTO force_check VALUES (34, 'thirty-four')

# Transfer back to forcer and access table via functions as 'funuser'
statement ok
SET ROLE root

statement ok
ALTER TABLE force_check OWNER TO forcer;

statement ok
GRANT ALL ON force_check TO funuser;

statement ok
SET ROLE funuser;

# Since FORCE is enabled, the policies will apply both to the session user and
# when running the function as the security definer (forcer). Therefore, we
# expect the same filtered result in both cases.

query I
select * from access_large_c2_as_session_user();
----
50

query I
select * from access_large_c2_as_forcer();
----
50

# Similar for functions that add new rows

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_session_user(110);

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_forcer(111);

# Turn off FORCE and retry function access as funuser
statement ok
SET ROLE forcer;

statement ok
ALTER TABLE force_check NO FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE funuser;

# FORCE is now off. When run as funuser, the result should remain the same as
# before. However, when running the function as forcer, policies will not be
# applied since forcer is the table owner and is exempt from policy enforcement.

query I
select * from access_large_c2_as_session_user();
----
50

query I rowsort
select * from access_large_c2_as_forcer();
----
20
30
33
50

# Similar for functions that add new rows

statement error pq: new row violates row-level security policy for table "force_check"
SELECT insert_policy_violation_as_session_user(111);

query IT
SELECT * FROM insert_policy_violation_as_forcer(112);
----
112  t - violated col value

statement ok
SET ROLE root

statement ok
DROP TABLE force_check CASCADE;

# Test to make sure that the scan to enforce uniqueness is done without RLS policies.
subtest uniq

statement ok
CREATE TABLE uniq (rls_col TEXT, uniq_col INT8 UNIQUE);

statement ok
CREATE USER uniq_user;

statement ok
GRANT ALL ON uniq TO uniq_user;

statement ok
ALTER TABLE uniq OWNER TO uniq_user;

statement ok
SET ROLE uniq_user;

statement ok
ALTER TABLE uniq NO FORCE ROW LEVEL SECURITY, ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY access ON uniq USING (rls_col = 'cat');

statement ok
INSERT INTO uniq VALUES ('cat', 1), ('cat', 2), ('dog', 3), ('cat', 4), ('hamster', 5);

statement ok
ALTER TABLE uniq FORCE ROW LEVEL SECURITY;

statement error pq: duplicate key value violates unique constraint "uniq_uniq_col_key"\nDETAIL: Key \(uniq_col\)=\(3\) already exists.
INSERT INTO uniq VALUES ('cat', 3);

statement ok
INSERT INTO uniq VALUES ('cat', 6);

statement error pq: new row violates row-level security policy for table "uniq"
INSERT INTO uniq VALUES ('dog', 6);

statement error pq: duplicate key value violates unique constraint "uniq_uniq_col_key"\nDETAIL: Key \(uniq_col\)=\(5\) already exists.
UPDATE uniq SET uniq_col = 5 WHERE uniq_col = 1;

statement ok
UPDATE uniq SET uniq_col = 7 WHERE uniq_col = 1;

# Ensure that any attempts to update an invisible row will be a no-op
query TI
UPDATE uniq SET uniq_col = 8 WHERE uniq_col = 5 RETURNING rls_col, uniq_col;
----

statement ok
ALTER TABLE uniq NO FORCE ROW LEVEL SECURITY;

query TI
select rls_col, uniq_col FROM uniq ORDER BY uniq_col;
----
cat      2
dog      3
cat      4
hamster  5
cat      6
cat      7

statement ok
SET ROLE root;

statement ok
DROP TABLE uniq;

statement ok
DROP USER uniq_user;

# Test to make sure that the scan to enforce foreign keys is exempt from RLS policies.
subtest fk

statement ok
CREATE TABLE parent (key INT8 NOT NULL PRIMARY KEY);

statement ok
CREATE TABLE child (
  rls_col TEXT,
  key INT8 NOT NULL,
  CONSTRAINT fk FOREIGN KEY (key) REFERENCES parent(key) ON DELETE CASCADE
);

statement ok
CREATE USER fk_user;

statement ok
GRANT ALL ON parent TO fk_user;

statement ok
GRANT ALL ON child TO fk_user;

statement ok
ALTER TABLE parent OWNER TO fk_user;

statement ok
ALTER TABLE child OWNER TO fk_user;

statement ok
SET ROLE fk_user;

statement ok
INSERT INTO parent SELECT * FROM generate_series(1,6);

statement ok
INSERT INTO child VALUES ('bedroom', 1), ('office', 2)

# Set RLS at the parent and ensure FK still enforced.
statement ok
ALTER TABLE parent ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement error pq: insert on table "child" violates foreign key constraint "fk"
INSERT INTO child VALUES ('hall', 7);

statement ok
INSERT INTO child VALUES ('hall', 3);

# mimic the FK lookup to show that the given RLS policies will hide the value
query I
SELECT 1 FROM parent WHERE key = 3;
----

query I
SELECT key FROM child ORDER BY key;
----
1
2
3

# Set RLS at the child and ensure FK still enforced
statement ok
ALTER TABLE child ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY ins1 ON child FOR INSERT WITH CHECK (rls_col = 'bedroom');

statement error pq: insert on table "child" violates foreign key constraint "fk"
INSERT INTO child VALUES ('bedroom', 7);

statement error pq: new row violates row-level security policy for table "child"
INSERT INTO child VALUES ('deck', 7);

statement ok
INSERT INTO child VALUES ('bedroom', 4);

# Disable RLS at the parent so that we can do a delete and have it cascade down
statement ok
ALTER TABLE parent NO FORCE ROW LEVEL SECURITY;

statement ok
DELETE FROM parent WHERE key = 1;

statement ok
CREATE POLICY sel1 ON child FOR SELECT USING (true);

query I
SELECT key FROM child ORDER BY key;
----
2
3
4

statement ok
SET ROLE root

statement ok
DROP TABLE child;

statement ok
DROP TABLE parent;

statement ok
DROP USER fk_user;

# Test FK propagation with RLS enabled on child table.
subtest fk_cascade

statement ok
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name TEXT
);

statement ok
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT REFERENCES customers(id) ON UPDATE CASCADE ON DELETE SET NULL
);

statement ok
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

statement ok
INSERT INTO customers VALUES (1, 'bob');

statement ok
INSERT INTO orders VALUES (1000, 1), (1001, 1);

statement ok
CREATE USER u1;

statement ok
GRANT ALL ON orders, customers TO u1;

statement ok
SET ROLE u1;

# Verify u1 cannot ready anything from orders
query II
SELECT id, customer_id FROM orders
----

# Update the customer ID. This should succeed and cascade to orders.
query IT
UPDATE customers SET id = 2 WHERE id = 1 RETURNING id, name
----
2 bob

statement ok
RESET ROLE

query II
SELECT id, customer_id FROM orders ORDER BY id
----
1000 2
1001 2

statement ok
SET ROLE u1;

# Delete the customer. This should set customer_id in orders to NULL.
query IT
DELETE FROM customers WHERE id = 2 RETURNING id, name
----
2 bob

# Try to validate oders as u1, but invisible due to RLS
query IT
SELECT id, customer_id FROM orders ORDER BY id
----

statement ok
RESET ROLE;

# validate as the root user, should see the cascaded update
query II
SELECT id, customer_id FROM orders ORDER BY id
----
1000 NULL
1001 NULL

statement ok
DROP TABLE orders;

statement ok
DROP TABLE customers;

statement ok
DROP USER u1;

# Ensure CHECK constraints can work alongside RLS policies
subtest check_constraint

statement ok
CREATE TABLE rgb_only (col text, check (col = 'red' or col = 'green' or col = 'blue'));

statement ok
CREATE USER rgb_only_user;

statement ok
ALTER TABLE rgb_only OWNER TO rgb_only_user;

statement ok
SET ROLE rgb_only_user;

statement ok
ALTER TABLE rgb_only ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_sel ON rgb_only FOR SELECT USING (true);

statement ok
CREATE POLICY IF NOT EXISTS p_subset ON rgb_only FOR INSERT WITH CHECK (col = 'red' or col = 'brown');

statement ok
INSERT INTO rgb_only VALUES ('red')

# Allowed by policy, reject by CHECK constraint
statement error pq: failed to satisfy CHECK constraint \(\(\(col = 'red':::STRING\) OR \(col = 'green':::STRING\)\) OR \(col = 'blue':::STRING\)\)
INSERT INTO rgb_only VALUES ('brown')

# Disallowed by policy, accepted by CHECK constraint
statement error pq: new row violates row-level security policy for table "rgb_only"
INSERT INTO rgb_only VALUES ('green')

statement ok
DROP POLICY p_subset ON rgb_only;

statement ok
CREATE POLICY p_disjoint ON rgb_only FOR INSERT WITH CHECK (col = 'black');

# Disallowed by both.
statement error pq: new row violates row-level security policy for table "rgb_only"
INSERT INTO rgb_only VALUES ('blue')

query T
SELECT col FROM rgb_only ORDER BY col;
----
red

statement ok
SET ROLE root;

statement ok
DROP TABLE rgb_only;

statement ok
DROP USER rgb_only_user;

subtest truncate

statement ok
CREATE TYPE trunc_type AS ENUM('a', 'b', 'c');

statement ok
CREATE TABLE trunc (a INT, b trunc_type, FAMILY (a, b));

statement ok
INSERT INTO trunc VALUES (1, 'a'), (2, 'b'), (3, 'c');

statement ok
CREATE USER deleter;

statement ok
GRANT ALL ON trunc TO deleter;

statement ok
ALTER TABLE trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p1 ON trunc FOR SELECT TO deleter USING (a % 2 = 1 and b != 'b');

statement ok
CREATE POLICY p2 ON trunc FOR DELETE TO deleter USING (false);

statement ok
CREATE POLICY p3 ON trunc FOR INSERT TO deleter WITH CHECK (true);

statement ok
SET ROLE deleter;

query IT
SELECT a, b FROM trunc ORDER BY a;
----
1  a
3  c

# This should not delete anything because the expression for delete is false.
statement ok
DELETE FROM trunc;

query IT
SELECT a, b FROM trunc ORDER BY a;
----
1  a
3  c

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       ) WITH (schema_locked = true);
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true);

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       );
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true);

# Truncate should be allowed, despite the policy to prevent deletes.
statement ok
TRUNCATE TABLE trunc;

query IT
SELECT a, b FROM trunc ORDER BY a;
----

# TRUNCATE is implemented by recreating the table. Verify the same policies exist.
onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       );
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE trunc;
----
trunc  CREATE TABLE public.trunc (
         a INT8 NULL,
         b public.trunc_type NULL,
         rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
         CONSTRAINT trunc_pkey PRIMARY KEY (rowid ASC),
         FAMILY fam_0_a_b_rowid (a, b, rowid)
       ) WITH (schema_locked = true);
       ALTER TABLE public.trunc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
       CREATE POLICY p1 ON public.trunc AS PERMISSIVE FOR SELECT TO deleter USING (((a % 2:::INT8) = 1:::INT8) AND (b != 'b':::public.trunc_type));
       CREATE POLICY p2 ON public.trunc AS PERMISSIVE FOR DELETE TO deleter USING (false);
       CREATE POLICY p3 ON public.trunc AS PERMISSIVE FOR INSERT TO deleter WITH CHECK (true);

# Ensure the policies are still enforced.
statement ok
INSERT INTO trunc VALUES (7, 'a'), (8, 'b'), (9, 'c');

query IT
SELECT a, b FROM trunc ORDER BY a;
----
7  a
9  c

statement ok
DELETE FROM trunc;

query IT
SELECT a, b FROM TRUNC ORDER BY a;
----
7  a
9  c

statement ok
SET ROLE root;

statement ok
DROP TABLE trunc;

statement ok
DROP USER deleter;

subtest validate_statement_cache_after_rls_changes

statement ok
CREATE TABLE rls_cache_test (c1 TEXT);

statement ok
INSERT INTO rls_cache_test VALUES ('a'), ('b'), ('c');

statement ok
CREATE USER rls_cache_user;

statement ok
GRANT ALL ON rls_cache_test TO rls_cache_user;

statement ok
SET ROLE rls_cache_user;

# Prime the cache
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
a
b
c

statement ok
SET ROLE root

statement ok
ALTER TABLE rls_cache_test ENABLE ROW LEVEL SECURITY;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----

statement ok
SET ROLE root

statement ok
CREATE POLICY IF NOT EXISTS rls_cache_policy ON rls_cache_test FOR SELECT TO rls_cache_user USING (c1 != 'a');

# Should be a no-op because the policy already exists
statement ok
CREATE POLICY IF NOT EXISTS rls_cache_policy ON rls_cache_test;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated (again)
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
b
c

statement ok
SET ROLE root

statement ok
ALTER TABLE rls_cache_test DISABLE ROW LEVEL SECURITY;

statement ok
SET ROLE rls_cache_user;

# The cache should be invalidated (again)
query T
SELECT * FROM rls_cache_test ORDER BY c1;
----
a
b
c

statement ok
SET ROLE root

# Ensure that the cache is invalidated when table is dropped
statement ok
DROP TABLE rls_cache_test;

statement ok
SET ROLE rls_cache_user;

statement error pq: relation "rls_cache_test" does not exist
SELECT * FROM rls_cache_test ORDER BY c1;

statement ok
SET ROLE root

statement ok
DROP ROLE rls_cache_user;

subtest computed_virtual_cols

statement ok
CREATE ROLE alice LOGIN;

statement ok
CREATE TABLE t (
      k INT PRIMARY KEY,
      a INT,
      b INT,
      c INT,
      v INT AS (c + 1) VIRTUAL
);

statement ok
INSERT INTO t VALUES (1,1,1,1),(-1,-1,-1,-1);

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON t TO alice;

statement ok
ALTER TABLE t ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY select_policy
ON t
FOR SELECT
TO alice
USING (v > 0);

statement ok
CREATE POLICY insert_policy
ON t
FOR INSERT
TO alice
WITH CHECK (v > 1);

statement ok
CREATE POLICY update_policy
ON t
FOR UPDATE
TO alice
USING (v > 2);

statement ok
CREATE POLICY delete_policy
ON t
FOR DELETE
TO alice
USING (v > 3);

statement ok
SET ROLE alice;

query IIIII
SELECT * FROM t;
----
1  1  1  1  2

query II
SELECT k,a FROM t WHERE b IS NOT NULL;;
----
1  1

statement ok
INSERT INTO t VALUES (2,2,2,2);

statement error pq: new row violates row-level security policy for table "t"
INSERT INTO t VALUES (3,0,0,0);

query IIIII
UPDATE t SET c = 4 WHERE k = 2 RETURNING *;
----
2  2  2  4  5

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET c = 0 WHERE k = 2 RETURNING *;

query I
DELETE FROM t RETURNING v;
----
5

statement ok
SET ROLE root;

query IIIII
SELECT * FROM t ORDER BY k;
----
-1  -1  -1  -1  0
1   1   1   1   2

statement ok
DROP TABLE t;

statement ok
DROP USER ALICE;

subtest computed_stored_cols

statement ok
CREATE ROLE pat LOGIN;

statement ok
CREATE TABLE t (
      k INT PRIMARY KEY,
      a INT,
      b INT,
      c INT,
      v INT AS (c + 1) STORED
);

statement ok
INSERT INTO t VALUES (1,1,1,1),(-1,-1,-1,-1);

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON t TO pat;

statement ok
ALTER TABLE t ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY select_policy
ON t
FOR SELECT
TO pat
USING (v > 0);

statement ok
CREATE POLICY insert_policy
ON t
FOR INSERT
TO pat
WITH CHECK (v > 1);

statement ok
CREATE POLICY update_policy
ON t
FOR UPDATE
TO pat
USING (v > 2);

statement ok
CREATE POLICY delete_policy
ON t
FOR DELETE
TO pat
USING (v > 3);

statement ok
SET ROLE pat;

query IIIII
SELECT * FROM t;
----
1  1  1  1  2

query II
SELECT k,a FROM t WHERE b IS NOT NULL;;
----
1  1

statement ok
INSERT INTO t VALUES (2,2,2,2);

statement error pq: new row violates row-level security policy for table "t"
INSERT INTO t VALUES (3,0,0,0);

query IIIII
UPDATE t SET c = 4 WHERE k = 2 RETURNING *;
----
2  2  2  4  5

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET c = 0 WHERE k = 2 RETURNING *;

query I
DELETE FROM t RETURNING v;
----
5

statement ok
SET ROLE root;

query IIIII
SELECT * FROM t ORDER BY k;
----
-1  -1  -1  -1  0
1   1   1   1   2

statement ok
DROP TABLE t;

statement ok
DROP USER PAT;

subtest block_invalid_expressions

statement ok
CREATE TABLE blocker();

statement error pq: only WITH CHECK expression allowed for INSERT
CREATE POLICY p_insert on blocker FOR INSERT USING (1 = 1);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
CREATE POLICY p_select on blocker FOR SELECT WITH CHECK (false);

statement error pq: WITH CHECK cannot be applied to SELECT or DELETE
CREATE POLICY p_delete on blocker FOR DELETE WITH CHECK (1 = 1);

statement ok
DROP TABLE blocker;

subtest block_import

statement ok
CREATE TABLE importer (c1 INT);

statement ok
ALTER TABLE importer ENABLE ROW LEVEL SECURITY;

statement ok
CREATE USER z;

statement ok
GRANT ALL ON importer TO z;

statement ok
GRANT SYSTEM EXTERNALIOIMPLICITACCESS TO z;

# Ensure non-admin's are blocked
statement ok
SET ROLE z;

let $exp_file
WITH cte AS (EXPORT INTO CSV 'nodelocal://1/rls-importer' FROM select 99 UNION ALL SELECT 98 UNION ALL SELECT 97) SELECT filename FROM cte;

statement error pq: IMPORT INTO not supported with row-level security for non-admin users
IMPORT INTO importer CSV DATA ('nodelocal://1/rls-importer/$exp_file');

# Ensure import from the admin role works
statement
SET ROLE root;

# In general, IMPORT isn't compatible with the fake span resolver. So we skip
# in those configs.
skipif config fakedist fakedist-disk fakedist-vec-off
statement ok
IMPORT INTO importer CSV DATA ('nodelocal://1/rls-importer/$exp_file');

skipif config fakedist fakedist-disk fakedist-vec-off
query I
SELECT c1 FROM importer ORDER BY c1;
----
97
98
99

statement ok
DROP TABLE importer;

statement ok
REVOKE SYSTEM EXTERNALIOIMPLICITACCESS FROM z;

statement ok
DROP USER z;

subtest rls_for_insert

statement ok
CREATE TABLE rlsInsert (c1 int not null primary key, c2 text, c3 date, family (c1,c2,c3));

statement ok
ALTER TABLE rlsInsert ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY IF NOT EXISTS p_insert ON rlsInsert AS PERMISSIVE FOR INSERT TO buck WITH CHECK (c3 not between '2012-01-01' and '2012-12-31');

statement ok
CREATE POLICY p_select ON rlsInsert AS PERMISSIVE FOR SELECT TO buck USING (true);

statement ok
GRANT ALL on rlsInsert TO buck;

# Sanity that the admin can insert anything
statement ok
INSERT INTO rlsInsert VALUES (1, 'first', '2012-06-30'),(0, 'zero', NULL);

statement ok
SET ROLE buck;

statement ok
INSERT INTO rlsInsert VALUES (2, 'second', '2010-06-30');

# Violates policy because date is in 2012.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (3, 'third', '2012-07-08');

# Violates policy because date is in 2012.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert SELECT c1 + 5, c2, c3 FROM rlsInsert;

# Violates policy because date is NULL
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (4, 'four', NULL)

statement ok
INSERT INTO rlsInsert SELECT c1 + 5, c2, c3 FROM rlsInsert WHERE c3 not between '2012-01-01' and '2012-12-31';

statement ok
SET ROLE root;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE rlsInsert
----
rlsinsert  CREATE TABLE public.rlsinsert (
             c1 INT8 NOT NULL,
             c2 STRING NULL,
             c3 DATE NULL,
             CONSTRAINT rlsinsert_pkey PRIMARY KEY (c1 ASC),
             FAMILY fam_0_c1_c2_c3 (c1, c2, c3)
           );
           ALTER TABLE public.rlsinsert ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
           CREATE POLICY p_insert ON public.rlsinsert AS PERMISSIVE FOR INSERT TO buck WITH CHECK (c3 NOT BETWEEN '2012-01-01':::DATE AND '2012-12-31':::DATE);
           CREATE POLICY p_select ON public.rlsinsert AS PERMISSIVE FOR SELECT TO buck USING (true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE rlsInsert
----
rlsinsert  CREATE TABLE public.rlsinsert (
             c1 INT8 NOT NULL,
             c2 STRING NULL,
             c3 DATE NULL,
             CONSTRAINT rlsinsert_pkey PRIMARY KEY (c1 ASC),
             FAMILY fam_0_c1_c2_c3 (c1, c2, c3)
           ) WITH (schema_locked = true);
           ALTER TABLE public.rlsinsert ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;
           CREATE POLICY p_insert ON public.rlsinsert AS PERMISSIVE FOR INSERT TO buck WITH CHECK (c3 NOT BETWEEN '2012-01-01':::DATE AND '2012-12-31':::DATE);
           CREATE POLICY p_select ON public.rlsinsert AS PERMISSIVE FOR SELECT TO buck USING (true);

statement ok
DROP POLICY p_insert on rlsInsert;

statement ok
SET ROLE buck;

# There is no policy for insert, so we deny everything.
statement error pq: new row violates row-level security policy for table "rlsinsert"
INSERT INTO rlsInsert VALUES (4, 'fourth', '2022-10-08');

query I
select c1 from rlsInsert ORDER BY c1;
----
0
1
2
7

statement ok
SET ROLE root;

statement ok
DROP TABLE rlsInsert;

subtest rls_for_update

statement ok
CREATE TYPE league AS ENUM('AL','NL');

statement ok
CREATE FUNCTION al_only(l league) RETURNS BOOL AS $$
BEGIN
  RETURN l = 'AL';
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE SEQUENCE seq1;

statement ok
CREATE TABLE bbteams (team text, league league, wins int, family (team, league, wins));

statement ok
ALTER TABLE bbteams ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p_update ON bbteams FOR UPDATE TO buck USING (true) WITH CHECK (league = 'AL' and nextval('seq1') < 1000);

statement ok
CREATE POLICY p_select ON bbteams FOR SELECT TO buck USING (true);

statement ok
CREATE POLICY IF NOT EXISTS p_insert ON bbteams FOR INSERT TO buck WITH CHECK (nextval('seq1') < 1000);

# Should be a no-op because policy already exists
statement ok
CREATE POLICY IF NOT EXISTS p_insert ON bbteams;

statement ok
GRANT ALL on bbteams TO buck;

statement ok
GRANT USAGE ON seq1 TO buck;

statement ok
GRANT UPDATE ON seq1 TO buck;

statement ok
SET ROLE buck;

statement ok
INSERT INTO bbteams(team, league) VALUES ('guardians', 'AL'), ('royals', 'AL'), ('expos', 'NL');

# Should be violated because expos are not in the AL league.
statement error pq: new row violates row-level security policy for table "bbteams"
UPDATE bbteams SET wins = 91 WHERE team = 'expos';

# Is allowed because league changed to AL at the same time.
statement ok
UPDATE bbteams SET wins = 87, league = 'AL' WHERE team = 'expos';

# Change the sequence so that it's value violates the WITH CHECK expression for
# the update policy.
statement ok
select setval('seq1', 1500, true);

statement error pq: new row violates row-level security policy for table "bbteams"
UPDATE bbteams SET wins = 82  WHERE team = 'royals';

statement ok
SET ROLE root

query I
SELECT nextval('seq1')
----
1502

query TTI
select team, league, wins from bbteams order by team;
----
expos      AL  87
guardians  AL  NULL
royals     AL  NULL

statement ok
DROP TABLE bbteams;

statement ok
DROP FUNCTION al_only;

statement ok
DROP SEQUENCE seq1;

subtest multiple_policies

statement ok
CREATE TABLE multip (key INT NOT NULL, value TEXT, FAMILY (key,value));

statement ok
ALTER TABLE multip ENABLE ROW LEVEL SECURITY;

# The policies will be combined as: (or1 || or2 || or3) && and1 && and2
statement ok
CREATE POLICY or1 ON multip AS PERMISSIVE USING (key = 1);

statement ok
CREATE POLICY or2 ON multip AS PERMISSIVE USING (key = 2);

statement ok
CREATE POLICY IF NOT EXISTS or3 ON multip AS PERMISSIVE USING (key = 3);

statement ok
CREATE POLICY and1 ON multip AS RESTRICTIVE USING (value not like '%sensitive%')

statement ok
CREATE POLICY and2 ON multip AS RESTRICTIVE USING (value not like '%confidential%')

statement ok
INSERT INTO multip VALUES
 (0, 'key out of bounds'),
 (1, 'okay'),
 (1, 'sensitive - filtered out'),
 (2, 'okay'),
 (2, 'confidential - filtered out'),
 (3, 'okay'),
 (2, 'sensitive - filtered out'),
 (4, 'key out of bounds'),
 (4, 'confidential');

statement ok
CREATE USER multi_user;

statement ok
GRANT ALL ON multip TO multi_user;

statement ok
SET ROLE multi_user;

query IT
select * from multip ORDER BY key, value;
----
1  okay
2  okay
3  okay

query IT
select * from multip where key >= 0 ORDER BY key, value;
----
1  okay
2  okay
3  okay

statement ok
SET ROLE root

# Ensure that if only a restrictive policy exists that all rows will be rejected
# regardless of the policy expression.
statement ok
DROP POLICY or1 ON multip;

statement ok
DROP POLICY or2 ON multip;

statement ok
DROP POLICY or3 ON multip;

statement ok
SET ROLE multi_user;

onlyif config schema-locked-disabled
query TT
SHOW CREATE multip;
----
multip  CREATE TABLE public.multip (
          key INT8 NOT NULL,
          value STRING NULL,
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT multip_pkey PRIMARY KEY (rowid ASC),
          FAMILY fam_0_key_value_rowid (key, value, rowid)
        );
        ALTER TABLE public.multip ENABLE ROW LEVEL SECURITY;
        CREATE POLICY and1 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%sensitive%':::STRING);
        CREATE POLICY and2 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%confidential%':::STRING);

skipif config schema-locked-disabled
query TT
SHOW CREATE multip;
----
multip  CREATE TABLE public.multip (
          key INT8 NOT NULL,
          value STRING NULL,
          rowid INT8 NOT VISIBLE NOT NULL DEFAULT unique_rowid(),
          CONSTRAINT multip_pkey PRIMARY KEY (rowid ASC),
          FAMILY fam_0_key_value_rowid (key, value, rowid)
        ) WITH (schema_locked = true);
        ALTER TABLE public.multip ENABLE ROW LEVEL SECURITY;
        CREATE POLICY and1 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%sensitive%':::STRING);
        CREATE POLICY and2 ON public.multip AS RESTRICTIVE FOR ALL TO public USING (value NOT LIKE '%confidential%':::STRING);

query IT
select * from multip ORDER BY key, value;
----

statement ok
SET ROLE root;

# Setup to verify the write policies.
statement ok
TRUNCATE TABLE multip;

statement ok
CREATE POLICY or1 ON multip AS PERMISSIVE USING (key = 1);

statement ok
CREATE POLICY or2 ON multip AS PERMISSIVE USING (key = 2);

statement ok
CREATE POLICY or3 ON multip AS PERMISSIVE USING (key = 3);

query TTTTT colnames,rowsort
select name, cmd, type, roles, with_check_expr from [SHOW POLICIES FOR multip];
----
name  cmd  type         roles     with_check_expr
and1  ALL  restrictive  {public}  ·
and2  ALL  restrictive  {public}  ·
or1   ALL  permissive   {public}  ·
or2   ALL  permissive   {public}  ·
or3   ALL  permissive   {public}  ·

query T rowsort
select using_expr from [SHOW POLICIES FOR multip];
----
value NOT LIKE '%sensitive%':::STRING
value NOT LIKE '%confidential%':::STRING
key = 1:::INT8
key = 2:::INT8
key = 3:::INT8

statement ok
SET ROLE multi_user;

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (0, 'key out of bounds');

statement ok
INSERT INTO multip VALUES (1, 'okay');

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (1, 'sensitive - filtered out');

statement ok
INSERT INTO multip VALUES (2, 'okay')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (2, 'confidential - filtered out')

statement ok
INSERT INTO multip VALUES (3, 'okay')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (2, 'sensitive - filtered out')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (4, 'key out of bounds')

statement error pq: new row violates row-level security policy for table "multip"
INSERT INTO multip VALUES (4, 'confidential');

statement ok
SET ROLE root;

query IT rowsort
select * FROM multip ORDER BY key, value;
----
1  okay
2  okay
3  okay

statement ok
DROP TABLE multip;

statement ok
DROP USER multi_user;

subtest ctas_and_mqt

# Test that RLS is enforced, even when users create CTAS and materialized views

statement ok
CREATE ROLE alice LOGIN;

statement ok
CREATE ROLE bob LOGIN;

statement ok
CREATE TABLE documents (
    id INT PRIMARY KEY,
    owner TEXT NOT NULL,
    content TEXT NOT NULL
);

statement ok
INSERT INTO documents (id, owner, content) VALUES
  (1, 'alice', 'Alice’s first document'),
  (2, 'alice', 'Alice’s second document'),
  (3, 'bob',   'Bob’s only document so far'),
  (4, 'admin', 'Admin’s secret doc');

statement ok
GRANT ALL ON documents TO alice;

statement ok
GRANT ALL ON documents TO bob;

statement ok
GRANT CREATE ON SCHEMA public TO alice;

statement ok
GRANT CREATE ON SCHEMA public TO bob;

statement ok
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY alice ON documents TO alice USING (owner = 'alice');

statement ok
CREATE POLICY bob ON documents TO bob USING (owner = 'bob');

statement ok
SET ROLE alice;

query ITT
SELECT * FROM documents ORDER BY ID;
----
1  alice  Alice’s first document
2  alice  Alice’s second document

statement ok
CREATE TABLE ctas1 AS SELECT * FROM documents;

query ITT
SELECT * FROM ctas1 ORDER BY ID;
----
1  alice  Alice’s first document
2  alice  Alice’s second document

statement ok
CREATE MATERIALIZED VIEW mqt_doc AS SELECT * FROM documents;

query ITT
SELECT * FROM mqt_doc ORDER BY ID;
----
1  alice  Alice’s first document
2  alice  Alice’s second document

statement ok
GRANT ALL ON ctas1 TO bob;

statement ok
RESET ROLE;

statement ok
ALTER TABLE mqt_doc OWNER TO bob;

statement ok
SET ROLE bob;

query ITT
SELECT * FROM documents ORDER BY ID;
----
3  bob  Bob’s only document so far

query ITT
SELECT * FROM ctas1 ORDER BY ID;
----
1  alice  Alice’s first document
2  alice  Alice’s second document

query ITT
SELECT * FROM mqt_doc ORDER BY ID;
----
1  alice  Alice’s first document
2  alice  Alice’s second document

statement ok
REFRESH MATERIALIZED VIEW mqt_doc;

query ITT
SELECT * FROM mqt_doc ORDER BY ID;
----
3  bob  Bob’s only document so far

statement ok
RESET ROLE;

statement ok
DROP TABLE ctas1;

statement ok
DROP MATERIALIZED VIEW mqt_doc;

statement ok
DROP TABLE documents;

statement ok
REVOKE CREATE ON SCHEMA public FROM bob, alice;

statement ok
DROP ROLE alice, bob;

subtest show_policies_edge_cases

statement error pq: relation "nonexistent_table" does not exist
SHOW POLICIES FOR nonexistent_table;

statement ok
CREATE TABLE rls_disabled (id INT PRIMARY KEY);

statement ok
CREATE POLICY p1 ON rls_disabled USING (true);

statement ok
ALTER TABLE rls_disabled DISABLE ROW LEVEL SECURITY;

query TTTTTT colnames
SHOW POLICIES FOR rls_disabled;
----
name  cmd  type        roles     using_expr  with_check_expr
p1    ALL  permissive  {public}  true        ·

# Test case 3: Show policies for a table with no policies
statement ok
CREATE TABLE no_policies (id INT PRIMARY KEY);

statement ok
ALTER TABLE no_policies ENABLE ROW LEVEL SECURITY;

query TTTTTT
SHOW POLICIES FOR no_policies;
----

# This is another test for multiple policies. But the focus here is how multiple
# policies are applied when they apply for other commands. For example, having
# a policy that applies to SELECT and a policy that applies to DELETE.
subtest multi_policies_multi_cmd

statement ok
create table r1 (c1 int);

statement ok
alter table r1 enable row level security;

statement ok
insert into r1 values (0),(1),(2),(3),(4),(5),(22);

statement ok
create policy sel1 on r1 for select using (c1 % 2 = 0);

statement ok
create policy upd1 on r1 for update using (c1 between 0 and 20);

statement ok
create user r1_user;

statement ok
grant all on r1 to r1_user;

statement ok
set role r1_user;

# UPDATE should only apply to the combination of both policies.
statement ok
update r1 set c1 = c1 ;

query I rowsort
update r1 set c1 = c1 returning c1;
----
0
2
4

statement error pq: new row violates row-level security policy for table "r1"
update r1 set c1 = c1 + 1;

statement error pq: new row violates row-level security policy for table "r1"
update r1 set c1 = c1 + 1 where c1 between 1 and 3;

statement ok
update r1 set c1 = c1 + 2 where c1 between 1 and 10;

query I rowsort
update r1 set c1 = c1 + 2 where c1 between 1 and 10 returning c1;
----
6
8

query I
update r1 set c1 = c1 + 2 where c1 > 20 returning c1;
----

query I rowsort
SELECT * FROM r1;
----
0
6
8
22

statement ok
SET ROLE root;

query I rowsort
SELECT * FROM r1;
----
0
1
3
5
6
8
22

statement ok
DROP TABLE r1;

# Do another test of select and update policies, but use simple expressions and
# try out different combinations of those expressions.
statement ok
CREATE TABLE cnt (counter INT);

statement ok
INSERT INTO cnt VALUES (1);

statement ok
GRANT ALL ON cnt TO r1_user;

statement ok
ALTER TABLE cnt ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
ALTER TABLE cnt OWNER TO r1_user;

statement ok
SET ROLE r1_user;

statement ok
CREATE POLICY IF NOT EXISTS upd1 ON cnt FOR UPDATE USING (true);

# Only an UPDATE policy and no SELECT policy. Nothing is updated.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now create only a SELECT policy. Same behaviour as before.
statement ok
DROP POLICY upd1 ON cnt;

statement ok
CREATE POLICY sel1 ON cnt FOR SELECT USING (true);

query I
SELECT * FROM cnt;
----
1

# Any locking modes on the query will cause the UPDATE policies to be applied,
# which will filter out the row.
query I
SELECT * FROM cnt FOR UPDATE;
----


query I
SELECT * FROM cnt FOR SHARE;
----


let $cnt_oid
SELECT 'cnt'::REGCLASS::OID;

query I
SELECT * FROM [$cnt_oid as t];
----
1

query I
SELECT * FROM [$cnt_oid as t] FOR UPDATE;
----

query I
SELECT * FROM [$cnt_oid as t] FOR SHARE;
----

# Update with a SELECT policy but no UPDATE policy. Nothing should be returned.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now add a SELECT policy, but it still filters everything out.
statement ok
CREATE POLICY upd1 ON cnt FOR UPDATE USING (false);

# Same as before, no update occurs because the reading of existing rows filters
# everything out.
query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----

# Now alter the UPDATE policy with one that allows everything.
statement ok
ALTER POLICY upd1 ON cnt USING (true);

query I
UPDATE cnt SET counter = counter + 1 RETURNING counter;
----
2

# Update the UPDATE policy so that it allows old rows but blocks all new rows.
statement ok
ALTER POLICY upd1 ON cnt USING (true) WITH CHECK (false);

# We are able to read the row but cannot write a new row as it violates the
# update policy.
statement error pq: new row violates row-level security policy for table "cnt"
UPDATE cnt SET counter = counter + 1 RETURNING counter;

# Verify that select policy (true) with no delete policy will not delete anything.
query I
delete from cnt where counter is not null returning counter;
----

statement ok
delete from cnt;

query I
select counter from cnt;
----
2

# Now change the select policy to be always false, and delete policy to be always true.
statement ok
ALTER POLICY sel1 ON cnt USING (false);

statement ok
CREATE POLICY del1 ON cnt FOR DELETE USING (true);

query I
delete from cnt where counter > 0 returning counter;
----

statement ok
delete from cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

# Drop the select policy entirely. It should be no different than a deny-all select policy.
statement ok
DROP POLICY sel1 ON cnt;

statement ok
ALTER TABLE cnt FORCE ROW LEVEL SECURITY;

query I
delete from cnt where counter > 0 returning counter;
----

statement ok
delete from cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

statement ok
ALTER TABLE cnt FORCE ROW LEVEL SECURITY;

# Now change the select policy to always return true, and delete policy to always return false.
statement ok
DROP POLICY del1 ON cnt;

statement ok
CREATE POLICY sel1 ON cnt FOR SELECT USING (true);

statement ok
CREATE POLICY IF NOT EXISTS del1 ON cnt FOR DELETE USING (false);

query I
DELETE FROM cnt WHERE counter > 0 RETURNING counter;
----

statement ok
DELETE FROM cnt;

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

query I
SELECT counter FROM cnt;
----
2

statement ok
ALTER TABLE cnt NO FORCE ROW LEVEL SECURITY;

statement ok
SET ROLE root

statement ok
DROP TABLE cnt;

statement ok
DROP USER r1_user;

subtest show_policies_roles_and_users

statement ok
CREATE ROLE test_role1;

statement ok
CREATE ROLE test_role2;

statement ok
CREATE USER test_user1;

statement ok
CREATE USER test_user2;

statement ok
CREATE TABLE policy_roles_test (id INT PRIMARY KEY, val TEXT);

statement ok
CREATE POLICY mixed_policy ON policy_roles_test TO test_role1, test_user1, test_role2, test_user2;

query TTTTTT colnames
SHOW POLICIES FOR policy_roles_test
----
name          cmd  type        roles                                          using_expr  with_check_expr
mixed_policy  ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·

statement ok
CREATE POLICY users_only_policy ON policy_roles_test TO test_user1, test_user2;

query TTTTTT colnames,rowsort
SHOW POLICIES FOR policy_roles_test
----
name               cmd  type        roles                                          using_expr  with_check_expr
mixed_policy       ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·
users_only_policy  ALL  permissive  {test_user1,test_user2}                        ·           ·

statement ok
CREATE POLICY roles_only_policy ON policy_roles_test TO test_role1, test_role2;

query TTTTTT colnames,rowsort
SHOW POLICIES FOR policy_roles_test
----
name               cmd  type        roles                                          using_expr  with_check_expr
mixed_policy       ALL  permissive  {test_role1,test_role2,test_user1,test_user2}  ·           ·
roles_only_policy  ALL  permissive  {test_role1,test_role2}                        ·           ·
users_only_policy  ALL  permissive  {test_user1,test_user2}                        ·           ·

statement ok
DROP TABLE policy_roles_test;

statement ok
DROP USER test_user1;

statement ok
DROP USER test_user2;

statement ok
DROP ROLE test_role1;

statement ok
DROP ROLE test_role2;

# Ensure that if a role has the BYPASSRLS option or privilege set, that it's
# exempt from policies.
subtest bypassrls

statement ok
CREATE TABLE bypassrls (id INT PRIMARY KEY, val TEXT);

statement ok
CREATE USER bypassrls_user;

statement ok
GRANT ALL ON bypassrls TO bypassrls_user;

statement ok
ALTER TABLE bypassrls ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY pol1 ON bypassrls TO bypassrls_user USING (val like 'visible: %');

statement ok
CREATE FUNCTION insert_policy_violation_as_session_user(id INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO bypassrls VALUES (id, 'hidden: value') RETURNING id, val
$$;

# This function is like the above, except it will always be run as admin since
# it uses SECURITY DEFINER.
statement ok
CREATE FUNCTION insert_policy_violation_as_admin(id INT) RETURNS TABLE(id INT, description TEXT)
LANGUAGE SQL AS
$$
 INSERT INTO bypassrls VALUES (id, 'hidden: value') RETURNING id, val
$$ SECURITY DEFINER;

statement ok
INSERT INTO bypassrls VALUES (0, 'visible: 0'), (1, 'hidden: 1'), (2, 'visible: 2');

query IT
SELECT * FROM insert_policy_violation_as_admin(10);
----
10 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(11);
----
11 hidden: value

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
1 hidden: 1
2 visible: 2
10 hidden: value
11 hidden: value

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
2 visible: 2

query IT
SELECT * FROM insert_policy_violation_as_admin(20);
----
20 hidden: value

statement error pq: new row violates row-level security policy for table "bypassrls"
SELECT * FROM insert_policy_violation_as_session_user(21);

statement ok
SET ROLE root;

statement error pq: conflicting role options
ALTER ROLE bypassrls_user BYPASSRLS NOBYPASSRLS;

statement ok
ALTER ROLE bypassrls_user BYPASSRLS;

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
1 hidden: 1
2 visible: 2
10 hidden: value
11 hidden: value
20 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_admin(30);
----
30 hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(31);
----
31 hidden: value

statement ok
SET ROLE root

statement ok
ALTER ROLE bypassrls_user NOBYPASSRLS;

statement ok
GRANT SYSTEM BYPASSRLS TO bypassrls_user;

query TTB colnames
SELECT * FROM [SHOW SYSTEM GRANTS] WHERE privilege_type = 'BYPASSRLS';
----
grantee         privilege_type  is_grantable
bypassrls_user  BYPASSRLS             false

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0   visible: 0
1   hidden: 1
2   visible: 2
10  hidden: value
11  hidden: value
20  hidden: value
30  hidden: value
31  hidden: value

query IT
SELECT * FROM insert_policy_violation_as_session_user(40);
----
40 hidden: value

statement ok
SET ROLE root;

statement ok
REVOKE SYSTEM BYPASSRLS FROM bypassrls_user;

statement ok
SET ROLE bypassrls_user;

query IT
SELECT * FROM bypassrls ORDER BY id;
----
0 visible: 0
2 visible: 2

statement error pq: new row violates row-level security policy for table "bypassrls"
SELECT * FROM insert_policy_violation_as_session_user(50);

statement ok
SET ROLE root;

statement ok
DROP FUNCTION insert_policy_violation_as_admin, insert_policy_violation_as_session_user

statement ok
DROP TABLE bypassrls;

statement ok
DROP USER bypassrls_user;

subtest multi_col_family_policies

statement ok
CREATE TABLE mc (pk int not null primary key, f1 int, f2 int, family pk (pk), family f1 (f1), family f2 (f2));

statement ok
CREATE ROLE mc;

statement ok
ALTER TABLE mc OWNER TO mc;

statement ok
SET ROLE mc;

statement ok
ALTER TABLE mc ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

statement ok
CREATE POLICY p1 ON mc USING (f1 > 0 and f2 > 0);

statement ok
INSERT INTO mc VALUES (1, 1, 1);

# An UPDATE that writes to one column but reads from another—where the read column
# belongs to a different column family—fails because we don't currently have locking
# to enforce safe access across families.
onlyif config weak-iso-level-configs
statement error pq: unimplemented: multi-column-family check constraints are not yet supported under read committed isolation
UPDATE mc SET f2 = 10 WHERE f1 = 1;

skipif config weak-iso-level-configs
statement ok
UPDATE mc SET f2 = 11 WHERE f1 = 1;

statement ok
DROP POLICY p1 ON mc;

statement ok
CREATE POLICY sel ON mc FOR SELECT USING (f1 > 0);

statement ok
CREATE POLICY upd ON mc FOR UPDATE USING (true) WITH CHECK (f2 > 0);

statement ok
CREATE POLICY ins ON mc FOR INSERT WITH CHECK (true);

onlyif config weak-iso-level-configs
statement error pq: unimplemented: multi-column-family check constraints are not yet supported under read committed isolation
INSERT INTO mc VALUES(1, 1, 1) ON CONFLICT (pk) DO UPDATE SET f2 = 12;

skipif config weak-iso-level-configs
statement ok
INSERT INTO mc VALUES(1, 1, 1) ON CONFLICT (pk) DO UPDATE SET f2 = 12;

# Switch up the expressions to ensure we look at the column from the merge of
# all the policies.
statement ok
ALTER POLICY sel ON mc USING (f2 > 0);

statement ok
ALTER POLICY upd ON mc WITH CHECK (f1 > 0);

onlyif config weak-iso-level-configs
statement error pq: unimplemented: multi-column-family check constraints are not yet supported under read committed isolation
INSERT INTO mc VALUES(1, 1, 1) ON CONFLICT (pk) DO UPDATE SET f2 = 13;

skipif config weak-iso-level-configs
statement ok
INSERT INTO mc VALUES(1, 1, 1) ON CONFLICT (pk) DO UPDATE SET f2 = 13;

statement ok
SET ROLE root;

statement ok
DROP TABLE mc;

statement ok
DROP USER mc;

subtest insert_on_conflict_update

statement ok
CREATE TABLE ups (pk INT NOT NULL PRIMARY KEY, comment TEXT);

statement ok
CREATE USER ups;

statement ok
ALTER TABLE ups OWNER TO ups;

statement ok
SET ROLE ups;

statement ok
ALTER TABLE ups ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

# pk=1: Trigger UPDATE policy violation during conflict resolution, caused by
# the new row values for the updated row violating the policy's USING clause.
statement ok
CREATE POLICY p_sel ON ups FOR SELECT USING (true);

statement ok
CREATE POLICY p_ins ON ups FOR INSERT WITH CHECK (true);

statement ok
CREATE POLICY p_upd ON ups FOR UPDATE USING (comment = 'upsert') WITH CHECK (true);

# Okay because there is no conflict
statement ok
INSERT INTO ups VALUES (1, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Reject because we hit a conflict, and the old column of comment violates the UPDATE policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (1, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 1;
----
original value

# pk=2: Ensure UPDATE policy USING expression doesn't apply to new version of
# updated row.
statement ok
ALTER POLICY p_upd ON ups USING (comment = 'original value') WITH CHECK (true);

# Okay because there is no conflict
statement ok
INSERT INTO ups VALUES (2, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Drive a conflict and confirm that the USING expression isn't used against the
# new version of the row. Otherwise, the policy would be violated.
statement ok
INSERT INTO ups VALUES (2, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 2;
----
upsert

# pk=3: Confirm no policy violation during conflict resolution when the updated
# row satisfies the WITH CHECK expression.
statement ok
ALTER POLICY p_upd ON ups USING (true) WITH CHECK (comment = 'upsert');

statement ok
INSERT INTO ups VALUES (3, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement ok
INSERT INTO ups VALUES (3, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 3;
----
upsert

# pk=4: Trigger UPDATE policy violation during conflict resolution, caused by
# failing the WITH CHECK expression for the updated column values.
statement ok
ALTER POLICY p_upd ON ups USING (true) WITH CHECK (comment = 'original value');

statement ok
INSERT INTO ups VALUES (4, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# This should be rejected because updated value violates the WITH CHECK expression in the update policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (4, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 4;
----
original value

# pk=5: Trigger INSERT policy violation before conflict resolution.
statement ok
DROP POLICY p_upd ON ups;

statement ok
CREATE POLICY p_upd ON ups FOR UPDATE USING (true);

statement ok
ALTER POLICY p_ins ON ups WITH CHECK (comment = 'upsert');

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (5, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement ok
ALTER POLICY p_ins ON ups WITH CHECK (comment = 'original value');

statement ok
INSERT INTO ups VALUES (5, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Verify that the INSERT policies are skipped if we hit a conflict and end up
# updating the existing row.
statement ok
INSERT INTO ups VALUES (5, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 5;
----
upsert

# pk=6: Trigger SELECT policy violation on conflict resolution.
statement ok
ALTER POLICY p_ins ON ups WITH CHECK (true);

statement ok
ALTER POLICY p_sel ON ups USING (comment = 'original value');

statement ok
INSERT INTO ups VALUES (6, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# This should be rejected. The updated rows violate the USING clause expression
# for the SELECT policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (6, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 6;
----
original value

# pk=7: Trigger SELECT policy violation on new inserted row and updated row
# during conflict resolution.
statement ok
ALTER POLICY p_sel ON ups USING (comment = 'upsert');

# This should fail because the USING clause of the SELECT policy violates the
# new rows being inserted.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (7, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Setup so we can try on a conflict. Disable RLS to properly insert pk=7 in.
statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

statement ok
INSERT INTO ups VALUES (7, 'original value');

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# This should be rejected. When reading the old row, it violates the USING
# clause of the SELECT policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (7, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query T
SELECT comment FROM ups WHERE pk = 7;
----
original value

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# pk=8: Have an ALL policy with a USING expression that violates the new row.
statement ok
DROP POLICY p_sel ON ups;

statement ok
DROP POLICY p_ins ON ups;

statement ok
DROP POLICY p_upd ON ups;

statement ok
CREATE POLICY p_all ON ups FOR ALL USING (comment = 'upsert') WITH CHECK (true);

# This should fail with an RLS violation because the new row violates the USING expression.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (8, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Setup so we can try on a conflict. Disable RLS to properly insert pk=8 in.
statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

statement ok
INSERT INTO ups VALUES (8, 'original value');

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# This fails because the old row violates the USING expression of p_all.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (8, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query T
SELECT comment FROM ups WHERE pk = 8;
----
original value

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# pk=9: Have an ALL policy with a USING expression that violates the updated row
# during conflict resolution.
statement ok
ALTER POLICY p_all ON ups USING (comment = 'original value') WITH CHECK (true);

statement ok
INSERT INTO ups VALUES (9, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (9, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 9;
----
original value

# pk=10: Use an ALL policy with a WITH CHECK expression that applies to the
# updated value during conflict resolution.
statement ok
ALTER POLICY p_all ON ups USING (true) WITH CHECK (comment = 'upsert')

# This should fail with an RLS violation because the new row violates the WITH CHECK expression.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (10, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Setup so we can try on a conflict. Disable RLS to properly insert pk=8 in.
statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

statement ok
INSERT INTO ups VALUES (10, 'original value');

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# Insert a row that triggers a conflict and is handled via UPDATE.
# The values provided for the initial INSERT would violate a WITH CHECK
# constraint, but because the conflict resolution results in an UPDATE,
# we allow the statement to succeed.
#
# Note: This behavior slightly deviates from PostgreSQL, which rejects
# the statement.
statement ok
INSERT INTO ups VALUES (10, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# However, if you leave off the conflict, the insert will get rejected due to the policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (10, 'original value')

query T
SELECT comment FROM ups WHERE pk = 10;
----
upsert

# pk=11: Use an ALL policy with a WITH CHECK expression that applies to the
# inserted row value.
statement ok
ALTER POLICY p_all ON ups USING (true) WITH CHECK (comment = 'original value')

statement ok
INSERT INTO ups VALUES (11, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# This should fail because the updated row violates the INSERT policy.
statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (11, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

query T
SELECT comment FROM ups WHERE pk = 11;
----
original value

# pk=12: Test an ALL policy that only includes a WITH CHECK expression.
# Since there is no USING expression to evaluate during conflict checks,
# the default behavior is deny-all, causing the statements to fail.
statement ok
DROP POLICY p_all ON ups;

statement ok
CREATE POLICY p_all ON ups FOR ALL WITH CHECK (true);

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (12, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

statement ok
INSERT INTO ups VALUES (12, 'original value')

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (12, 'original value') ON CONFLICT (pk) DO UPDATE SET comment = 'upsert';

# Turn off force so we can query the row back
statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query T
SELECT comment FROM ups WHERE pk = 12;
----
original value

statement ok
SET ROLE root;

statement ok
DROP TABLE ups;

statement ok
DROP USER ups;

subtest insert_on_conflict_do_nothing

statement ok
CREATE TABLE ups (pk INT NOT NULL PRIMARY KEY, comment TEXT, c SMALLINT);

statement ok
CREATE USER ups;

statement ok
ALTER TABLE ups OWNER TO ups;

statement ok
SET ROLE ups;

statement ok
ALTER TABLE ups ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

# pk=1: Verify the conflict scan is exempt from RLS policies USING expressions
# and we don't insert a duplicate value.
statement ok
CREATE POLICY p_sel ON ups FOR SELECT USING (comment = 'original value');

statement ok
CREATE POLICY p_ins ON ups FOR INSERT WITH CHECK (true);

statement ok
INSERT INTO ups VALUES (1, 'original value', 1) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (1, 'original value', 2) ON CONFLICT (pk) DO NOTHING;

# Verify that input VALUES are not checked against policies when a conflict
# occurs. This behaviour differs from PostgreSQL, which evaluates VALUES even in
# conflict cases. The discrepancy stems from a known difference in how CHECK
# constraints are handled. See issue #35370 for more details.
statement ok
INSERT INTO ups VALUES (1, 'upsert', 3) ON CONFLICT (pk) DO NOTHING;

query TI
SELECT comment, c FROM ups WHERE pk = 1;
----
original value 1

statement ok
ALTER POLICY p_sel ON ups USING (comment = 'upsert');

# PostgreSQL would block this, but since a conflict occurs and we do nothing,
# the constraints are never evaluated.
statement ok
INSERT INTO ups VALUES (1, 'original value', 4) ON CONFLICT (pk) DO NOTHING;

# pk=2: Ensure that the INSERT expression is only violated if there is no
# conflict
statement ok
ALTER POLICY p_sel ON ups USING (true);

statement ok
ALTER POLICY p_ins ON ups WITH CHECK (comment = 'original value');

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (2, 'first value', 1) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (2, 'original value', 2) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (2, 'original value', 3) ON CONFLICT (pk) DO NOTHING;

# An INSERT that encounters a conflict will skip writing the row and skip the
# RLS policy checks. Note: This differs from PostgreSQL, which raises a policy
# violation error because it checks constraints/policies on the input values.
statement ok
INSERT INTO ups VALUES (2, 'upsert', 4) ON CONFLICT (pk) DO NOTHING;

query TI
SELECT comment, c FROM ups WHERE pk = 2;
----
original value 2

# pk=3: Test an ALL policy with a USING expression that is intentionally violated
statement ok
DROP POLICY p_ins ON ups;

statement ok
DROP POLICY p_sel ON ups;

statement ok
CREATE POLICY p_all ON ups FOR ALL USING (comment = 'original value') WITH CHECK (true);

statement error pq: new row violates row-level security policy for table "ups"
INSERT INTO ups VALUES (3, 'first value', 1) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (3, 'original value', 2) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (3, 'original value', 3) ON CONFLICT (pk) DO NOTHING;

# An INSERT that encounters a conflict will skip writing the row and skip the
# RLS policy checks. Note: This differs from PostgreSQL, which raises a policy
# violation error because it checks constraints/policies on the input values.
statement ok
INSERT INTO ups VALUES (3, 'upsert', 4) ON CONFLICT (pk) DO NOTHING;

query TI
SELECT comment, c FROM ups WHERE pk = 3;
----
original value 2

statement ok
DELETE FROM ups WHERE pk = 3;

statement ok
INSERT INTO ups VALUES (3, 'first value', 5);

statement ok
ALTER POLICY p_all ON ups USING (comment = 'upsert');

statement ok
INSERT INTO ups VALUES (3, 'upsert', 6) ON CONFLICT (pk) DO NOTHING;

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query TI
SELECT comment, c FROM ups WHERE pk = 3;
----
first value 5

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# pk=4: ALL policy with a violated WITH CHECK expression
statement ok
ALTER POLICY p_all ON ups USING (true) WITH CHECK (comment = 'original value');

statement ok
INSERT INTO ups VALUES (4, 'original value', 1) ON CONFLICT (pk) DO NOTHING;

statement ok
INSERT INTO ups VALUES (4, 'original value', 2) ON CONFLICT (pk) DO NOTHING;

# An INSERT that encounters a conflict will skip writing the row and skip the
# RLS policy checks. Note: This differs from PostgreSQL, which raises a policy
# violation error because it checks constraints/policies on the input values.
statement ok
INSERT INTO ups VALUES (4, 'upsert', 3) ON CONFLICT (pk) DO NOTHING;

query TI
SELECT comment, c FROM ups WHERE pk = 4;
----
original value 1

statement ok
ALTER POLICY p_all ON ups WITH CHECK (comment = 'upsert');

statement ok
INSERT INTO ups VALUES (4, 'upsert', 4) ON CONFLICT (pk) DO NOTHING;

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query TI
SELECT comment, c FROM ups WHERE pk = 4;
----
original value 1

statement ok
SET ROLE root;

statement ok
DROP TABLE ups;

statement ok
DROP USER ups;

subtest upsert

statement ok
CREATE TABLE ups (pk INT NOT NULL PRIMARY KEY, comment TEXT, c SMALLINT);

statement ok
CREATE USER ups;

statement ok
ALTER TABLE ups OWNER TO ups;

statement ok
SET ROLE ups;

statement ok
ALTER TABLE ups ENABLE ROW LEVEL SECURITY, FORCE ROW LEVEL SECURITY;

# pk=1: Trigger an UPDATE policy violation during conflict resolution,
# caused by the new row values violating the policy's USING expression.
statement ok
CREATE POLICY p_sel ON ups FOR SELECT USING (true);

statement ok
CREATE POLICY p_ins ON ups FOR INSERT WITH CHECK (true);

statement ok
CREATE POLICY p_upd ON ups FOR UPDATE USING (comment = 'original value') WITH CHECK (true);

statement ok
UPSERT INTO ups VALUES (1, 'original value', 1);

# Succeeds because the policy evaluates to true when it reads the old row.
statement ok
UPSERT INTO ups VALUES (1, 'upsert', 2);

query TI
SELECT comment, c FROM ups WHERE pk = 1;
----
upsert 2

# Fail because the old row violates the USING expression of the UPDATE policy
statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (1, 'upsert', 3);

# Fail because the old row violates the USING expression of the UPDATE policy
statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (1, 'original value', 4);

query TI
SELECT comment, c FROM ups WHERE pk = 1;
----
upsert 2

# pk=2: Trigger an UPDATE policy violation during conflict resolution because
# WITH CHECK expression fails.
statement ok
ALTER POLICY p_upd ON ups USING (true) WITH CHECK (comment = 'original value');

statement ok
UPSERT INTO ups VALUES (2, 'original value', 1);

# Drive a conflict and confirm that the WITH CHECK expression is violated.
statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (2, 'upsert', 2);

query TI
SELECT comment, c FROM ups WHERE pk = 2;
----
original value 1

# pk=3: Trigger a SELECT policy violation during conflict resolution.
statement ok
ALTER POLICY p_upd ON ups USING (true) WITH CHECK (true);

statement ok
ALTER POLICY p_sel ON ups USING (comment = 'original value')

# Fails because new row doesn't pass SELECT policy expression
statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (3, 'expect fail', 1);

statement ok
UPSERT INTO ups VALUES (3, 'original value', 2);

statement ok
UPSERT INTO ups VALUES (3, 'original value', 3);

statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (3, 'upsert', 4);

query TI
SELECT comment, c FROM ups WHERE pk = 3;
----
original value 3

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

statement ok
UPSERT INTO ups VALUES (3, 'upsert', 5);

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (3, 'original value', 6);

statement ok
ALTER TABLE ups NO FORCE ROW LEVEL SECURITY;

query TI
SELECT comment, c FROM ups WHERE pk = 3;
----
upsert 5

statement ok
ALTER TABLE ups FORCE ROW LEVEL SECURITY;

# pk=4: Trigger INSERT policy violation before conflict resolution.
statement ok
ALTER POLICY p_upd ON ups USING (true) WITH CHECK (true);

statement ok
ALTER POLICY p_ins ON ups WITH CHECK (comment = 'upsert');

statement ok
ALTER POLICY p_sel ON ups USING (true);

statement error pq: new row violates row-level security policy for table "ups"
UPSERT INTO ups VALUES (4, 'original value', 1);

statement ok
ALTER POLICY p_ins ON ups WITH CHECK (comment = 'original value');

statement ok
UPSERT INTO ups VALUES (4, 'original value', 2);

# Confirm that the INSERT policy isn't used if there is a conflict.
statement ok
UPSERT INTO ups VALUES (4, 'upsert', 3);

query TI
SELECT comment, c FROM ups WHERE pk = 4;
----
upsert 3

statement ok
SET ROLE root

statement ok
DROP TABLE ups;

statement ok
DROP USER ups;

subtest end

# An UPDATE statement enforces SELECT policies on new rows if columns are
# referenced in SET or WHERE expressions, or if a RETURNING clause is present.
subtest update_with_no_select_policies

statement ok
CREATE ROLE alice LOGIN;

statement ok
CREATE ROLE bob LOGIN;

statement ok
CREATE TABLE t (
  k INT PRIMARY KEY,
  a INT,
  b BOOL,
  FAMILY f (k, a, b)
);

statement ok
INSERT INTO t VALUES (1, 10, true);

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON t TO alice, bob;

statement ok
ALTER TABLE t ENABLE ROW LEVEL SECURITY;

# Include in the policy a column ('b') that is not referenced or modified by any
# UPDATE statements, except within the policy expression itself.
statement ok
CREATE POLICY select_policy_alice
ON t
FOR SELECT
TO alice
USING (a > 0 AND b IS true);

statement ok
CREATE POLICY update_policy_alice
ON t
FOR UPDATE
TO alice
USING (true);

statement ok
CREATE POLICY select_policy_bob
ON t
FOR SELECT
TO bob
USING (true);

statement ok
CREATE POLICY update_policy_bob
ON t
FOR UPDATE
TO bob
USING (true);

statement ok
SET ROLE alice;

statement ok
UPDATE t SET a = 0 WHERE true;

statement ok
SET ROLE bob;

query II
SELECT k, a FROM t;
----
1 0

statement ok
SET ROLE alice;

# TODO(145894): This UPDATE is incorrectly filtered by SELECT policies, even
# though no columns are referenced in SET or WHERE. Unlike postgres, we apply
# policies unnecessarily.
statement ok
UPDATE t SET a = -1 WHERE true;

statement ok
SET ROLE bob;

query II
SELECT k, a FROM t;
----
1 0

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

statement ok
SET ROLE alice;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = a - 10 WHERE true;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE k = 1;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE true RETURNING k;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE true RETURNING k + 1;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE true RETURNING (select t.a);

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE true RETURNING *;

statement error pq: new row violates row-level security policy for table "t"
UPDATE t SET a = 0 WHERE true RETURNING t.*;

query T
UPDATE t SET a = 0 WHERE true RETURNING 'foo';
----
foo

statement ok
SET ROLE bob;

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

statement ok
SET ROLE alice;

query I
UPDATE t SET a = 0 WHERE true RETURNING (select 1);
----
1

statement ok
SET ROLE bob;

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

statement ok
SET ROLE alice;

query IIT
UPDATE t SET a = 0 WHERE true RETURNING 1 + 1, 2, 'three'
----
2 2 three

statement ok
SET ROLE root;

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

# Create another table to test UPDATE .. FROM. Confirm that SELECT policies on 't'
# are not applied, even if the UPDATE references columns from this table.
statement ok
CREATE TABLE other (k INT PRIMARY KEY, a INT);

# Insert a row into 'other' that will cause the UPDATE on 't' to violate its
# SELECT policies. The second column will be used in the SET clause when
# updating 't'.
statement ok
INSERT INTO other VALUES (1, -1);

statement ok
GRANT ALL ON other TO alice;

statement ok
SET ROLE alice;

statement ok
UPDATE t SET a = other.a FROM other WHERE true;

statement ok
SET ROLE root;

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

statement ok
SET ROLE alice;

# Ensure SELECT policies on 't' are not applied when the RETURNING clause
# only references a column from the 'other' table.
query I
UPDATE t SET a = -3 FROM other WHERE true RETURNING other.k;
----
1

statement ok
SET ROLE root;

query I
SELECT a FROM t;
----
-3

# Reset the row.
statement ok
UPDATE t SET k = 1, a = 10 WHERE true;

statement ok
SET ROLE alice;

statement ok
UPDATE t SET a = -2 FROM other WHERE other.k = 1;

statement ok
SET ROLE root;

query I
SELECT a FROM t;
----
-2

statement ok
DROP TABLE t;

statement ok
DROP TABLE other;

statement ok
DROP ROLE alice, bob;

subtest policy_with_schema_locked

statement ok
CREATE TABLE alter_policy_table_locked (c1 INT8 NOT NULL, c2 STRING NULL, CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC), FAMILY fam_0_c1_c2 (c1, c2)) WITH (schema_locked = true);

statement ok
CREATE POLICY p ON alter_policy_table_locked WITH CHECK (TRUE);

statement ok
ALTER POLICY p ON alter_policy_table_locked RENAME TO p_sel;

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table_locked;
----
alter_policy_table_locked  CREATE TABLE public.alter_policy_table_locked (
                             c1 INT8 NOT NULL,
                             c2 STRING NULL,
                             CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                             FAMILY fam_0_c1_c2 (c1, c2)
                           ) WITH (schema_locked = true);
                           CREATE POLICY p_sel ON public.alter_policy_table_locked AS PERMISSIVE FOR ALL TO public WITH CHECK (true);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table_locked;
----
alter_policy_table_locked  CREATE TABLE public.alter_policy_table_locked (
                             c1 INT8 NOT NULL,
                             c2 STRING NULL,
                             CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                             FAMILY fam_0_c1_c2 (c1, c2)
                           ) WITH (schema_locked = true);
                           CREATE POLICY p_sel ON public.alter_policy_table_locked AS PERMISSIVE FOR ALL TO public WITH CHECK (true);

statement ok
ALTER POLICY p_sel ON alter_policy_table_locked WITH CHECK (FALSE);

onlyif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table_locked;
----
alter_policy_table_locked  CREATE TABLE public.alter_policy_table_locked (
                             c1 INT8 NOT NULL,
                             c2 STRING NULL,
                             CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                             FAMILY fam_0_c1_c2 (c1, c2)
                           ) WITH (schema_locked = true);
                           CREATE POLICY p_sel ON public.alter_policy_table_locked AS PERMISSIVE FOR ALL TO public WITH CHECK (false);

skipif config schema-locked-disabled
query TT
SHOW CREATE TABLE alter_policy_table_locked;
----
alter_policy_table_locked  CREATE TABLE public.alter_policy_table_locked (
                             c1 INT8 NOT NULL,
                             c2 STRING NULL,
                             CONSTRAINT alter_policy_table_pkey PRIMARY KEY (c1 ASC),
                             FAMILY fam_0_c1_c2 (c1, c2)
                           ) WITH (schema_locked = true);
                           CREATE POLICY p_sel ON public.alter_policy_table_locked AS PERMISSIVE FOR ALL TO public WITH CHECK (false);

subtest bug_fix_policy_respects_inheritance_#144780

statement ok
CREATE ROLE parent_role

statement ok
CREATE ROLE child_role

statement ok
GRANT parent_role TO child_role

statement ok
CREATE TABLE employees (id SERIAL PRIMARY KEY, name TEXT, department TEXT)

statement ok
INSERT INTO employees VALUES (1, 'Alice', 'Engineering')

statement ok
ALTER TABLE employees ENABLE ROW LEVEL SECURITY

statement ok
CREATE POLICY parent_policy_select ON employees FOR SELECT TO parent_role USING (true)

statement ok
CREATE POLICY parent_policy_insert ON employees FOR INSERT TO parent_role WITH CHECK (department IN ('Engineering', 'Sales'))

statement ok
CREATE POLICY parent_policy_update ON employees FOR UPDATE TO parent_role USING (false)

statement ok
GRANT SELECT, INSERT, UPDATE ON employees TO parent_role

# Test with role inheritance - child_role should inherit parent_role's permissions.
statement ok
SET ROLE child_role

query ITT
SELECT * FROM employees
----
1  Alice  Engineering

# Test INSERT with role inheritance - should succeed for allowed department.
statement ok
INSERT INTO employees (id, name, department) VALUES (2, 'Bob', 'Engineering')

# Test INSERT with role inheritance - should succeed for another allowed department.
statement ok
INSERT INTO employees (id, name, department) VALUES (3, 'Carol', 'Sales')

# Test INSERT with role inheritance - should fail for disallowed department.
statement error pq: new row violates row-level security policy for table "employees"
INSERT INTO employees (id, name, department) VALUES (4, 'Dave', 'Finance')

statement ok
UPDATE employees SET name = 'Robert' WHERE name = 'Bob'

query ITT
SELECT * FROM employees ORDER BY id
----
1  Alice  Engineering
2  Bob    Engineering
3  Carol  Sales

statement ok
RESET ROLE

# Now revoke the parent role and ensure permissions don't apply anymore.
statement ok
REVOKE parent_role FROM child_role

statement ok
GRANT ALL ON employees TO child_role

statement ok
SET ROLE child_role

# Should see no rows because the policy doesn't apply anymore.
query ITT
SELECT * FROM employees
----

# All write operations should fail now.
statement error pq: new row violates row-level security policy for table "employees"
INSERT INTO employees (id, name, department) VALUES (3, 'Eve', 'Engineering')

# Test UPDATE with role inheritance - should succeed,
# but the update will not go as the default with ENABLED ROW LEVEL SECURITY.
statement ok
UPDATE employees SET name = 'Alice 2.0' WHERE name = 'Alice'

statement ok
RESET ROLE

# Can see that no change was made by the update.
query ITT
SELECT * FROM employees ORDER BY id
----
1  Alice  Engineering
2  Bob    Engineering
3  Carol  Sales

statement ok
DROP TABLE employees CASCADE

statement ok
DROP ROLE child_role

statement ok
DROP ROLE parent_role

subtest end

subtest triggers_with_rls

statement ok
CREATE TABLE trigger_rls_table (id INT PRIMARY KEY, value INT, owner STRING);

statement ok
INSERT INTO trigger_rls_table VALUES (1, 100, 'alice'), (2, 200, 'bob'), (3, 300, 'alice'), (4, 400, 'bob');

statement ok
CREATE USER alice;

statement ok
CREATE USER bob;

statement ok
GRANT ALL ON trigger_rls_table TO alice, bob;

# Enable RLS on the table
statement ok
ALTER TABLE trigger_rls_table ENABLE ROW LEVEL SECURITY;

# Create a policy that only allows users to see their own data.
statement ok
CREATE POLICY owner_policy ON trigger_rls_table
  USING (owner = current_user())
  WITH CHECK (owner = current_user());

# Create a trigger function that logs changes to the table.
statement ok
CREATE FUNCTION log_value_changes() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    RAISE NOTICE 'User % updated value for id % from % to %', current_user(), (NEW).id, (OLD).value, (NEW).value;
  ELSIF TG_OP = 'INSERT' THEN
    RAISE NOTICE 'User % inserted new row with id % and value %', current_user(), (NEW).id, (NEW).value;
  ELSIF TG_OP = 'DELETE' THEN
    RAISE NOTICE 'User % deleted row with id % and value %', current_user(), (OLD).id, (OLD).value;
  END IF;
  RETURN NEW;
END;
$$;

# Create a trigger function that enforces a business rule: value must be positive.
statement ok
CREATE FUNCTION enforce_positive_value() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
  IF (NEW).value <= 0 THEN
    RAISE EXCEPTION 'Value must be positive';
  END IF;
  RETURN NEW;
END;
$$;

# Create a trigger that logs changes.
statement ok
CREATE TRIGGER log_changes
  AFTER INSERT OR UPDATE OR DELETE ON trigger_rls_table
  FOR EACH ROW
  EXECUTE FUNCTION log_value_changes();

# Create a trigger that enforces the business rule.
statement ok
CREATE TRIGGER check_positive_value
  BEFORE INSERT OR UPDATE ON trigger_rls_table
  FOR EACH ROW
  EXECUTE FUNCTION enforce_positive_value();

# Test as alice.
statement ok
SET ROLE alice;

# Alice should only see her own rows.
query IIT
SELECT * FROM trigger_rls_table ORDER BY id;
----
1  100  alice
3  300  alice

# Update a row that alice owns.
query T noticetrace
UPDATE trigger_rls_table SET value = 150 WHERE id = 1;
----
NOTICE: User alice updated value for id 1 from 100 to 150

# Try to update a row that bob owns (should not error, but should not affect any rows).
query T noticetrace
UPDATE trigger_rls_table SET value = 250 WHERE id = 2;
----

# Test negative value should trigger error.
statement error pq: Value must be positive
UPDATE trigger_rls_table SET value = -100 WHERE id = 1;

# Insert a new row that alice owns.
query T noticetrace
INSERT INTO trigger_rls_table VALUES (5, 500, 'alice');
----
NOTICE: User alice inserted new row with id 5 and value 500

# Try to insert a row that bob owns (should fail due to RLS policy).
statement error pq: new row violates row-level security policy for table "trigger_rls_table"
INSERT INTO trigger_rls_table VALUES (6, 600, 'bob');

# Delete a row that alice owns.
query T noticetrace
DELETE FROM trigger_rls_table WHERE id = 3;
----
NOTICE: User alice deleted row with id 3 and value 300

# Test as bob.
statement ok
SET ROLE bob;

# Bob should only see his own rows.
query IIT
SELECT * FROM trigger_rls_table ORDER BY id;
----
2  200  bob
4  400  bob

# Update a row that bob owns.
query T noticetrace
UPDATE trigger_rls_table SET value = 250 WHERE id = 2;
----
NOTICE: User bob updated value for id 2 from 200 to 250

# Try to update a row that alice owns (should not error, but should not affect any rows).
query T noticetrace
UPDATE trigger_rls_table SET value = 175 WHERE id = 1;
----

# Insert a new row that bob owns.
query T noticetrace
INSERT INTO trigger_rls_table VALUES (7, 700, 'bob');
----
NOTICE: User bob inserted new row with id 7 and value 700

# Test if bob can bypass RLS with a trigger function that modifies other rows.
statement ok
CREATE FUNCTION try_bypass_rls() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
  UPDATE trigger_rls_table SET value = 999 WHERE owner = 'alice';
  RETURN NEW;
END;
$$;

statement ok
CREATE TRIGGER bypass_attempt
  AFTER INSERT ON trigger_rls_table
  FOR EACH ROW
  EXECUTE FUNCTION try_bypass_rls();

# Try to trigger the bypass (this insert will succeed but the trigger's UPDATE should be limited by RLS).
statement ok
INSERT INTO trigger_rls_table VALUES (8, 800, 'bob');

# Check as root what happened.
statement ok
SET ROLE root;

# Alice's rows should not have been affected by bob's trigger.
query IIT
SELECT * FROM trigger_rls_table WHERE owner = 'alice' ORDER BY id;
----
1  150  alice
5  500  alice

# Now test a BEFORE trigger that modifies a column in a way that would violate an RLS policy.
statement ok
SET ROLE alice;

# Create a trigger function that tries to change the owner column to 'bob'.
statement ok
CREATE FUNCTION change_owner_to_bob() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
  NEW.owner = 'bob';
  RETURN NEW;
END;
$$;

# Create a trigger that applies the function before insert.
statement ok
CREATE TRIGGER force_bob_ownership
  BEFORE INSERT ON trigger_rls_table
  FOR EACH ROW
  EXECUTE FUNCTION change_owner_to_bob();

# Try to insert a row - this should fail because the trigger modifies
# the owner to 'bob' which violates alice's RLS policy.
statement error pq: new row violates row-level security policy for table "trigger_rls_table"
INSERT INTO trigger_rls_table VALUES (9, 900, 'alice');

# Now do the same with update.
statement ok
CREATE FUNCTION change_updated_owner_to_bob() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
  IF TG_OP = 'UPDATE' THEN
    NEW.owner = 'bob';
  END IF;
  RETURN NEW;
END;
$$;

statement ok
CREATE TRIGGER force_update_bob_ownership
  BEFORE UPDATE ON trigger_rls_table
  FOR EACH ROW
  EXECUTE FUNCTION change_updated_owner_to_bob();

# Try to update a row - this should fail because the trigger modifies
# the owner to 'bob' which violates alice's RLS policy.
statement error pq: new row violates row-level security policy for table "trigger_rls_table"
UPDATE trigger_rls_table SET value = 600 WHERE id = 5;

# Let's try with both bob and root to see how it works for them.
statement ok
SET ROLE bob;

# For bob, changing owner to bob is allowed by the policy.
query T noticetrace
INSERT INTO trigger_rls_table VALUES (10, 1000, 'alice');
----
NOTICE: User bob inserted new row with id 10 and value 1000

# Verify the owner was changed to bob by the trigger.
query IIT
SELECT * FROM trigger_rls_table WHERE id = 10;
----
10  1000  bob

# For completeness, let's see from the root perspective.
statement ok
SET ROLE root;

# Check all rows in the table to see what happened.
query IIT
SELECT * FROM trigger_rls_table ORDER BY id;
----
1  150  alice
2  250  bob
4  400  bob
5  500  alice
7  700  bob
8  800  bob
10  1000  bob

# Clean up the additional triggers and functions.
statement ok
DROP TRIGGER force_bob_ownership ON trigger_rls_table;
DROP TRIGGER force_update_bob_ownership ON trigger_rls_table;
DROP FUNCTION change_owner_to_bob;
DROP FUNCTION change_updated_owner_to_bob;
DROP TRIGGER log_changes ON trigger_rls_table;
DROP TRIGGER check_positive_value ON trigger_rls_table;
DROP TRIGGER bypass_attempt ON trigger_rls_table;
DROP FUNCTION log_value_changes;
DROP FUNCTION enforce_positive_value;
DROP FUNCTION try_bypass_rls;
DROP TABLE trigger_rls_table;
DROP USER alice;
DROP USER bob;

subtest bypassrls_pg_roles_pg_authid

statement ok
CREATE ROLE can_bypassrls WITH BYPASSRLS;

statement ok
CREATE ROLE cannot_bypassrls;

statement ok
CREATE ROLE can_bypassrls_global;

statement ok
GRANT SYSTEM BYPASSRLS TO can_bypassrls_global; 

query B
SELECT rolbypassrls FROM pg_authid WHERE rolname = 'can_bypassrls' OR rolname = 'can_bypassrls_global';
----
true
true

query B
SELECT rolbypassrls FROM pg_authid WHERE rolname = 'cannot_bypassrls';
----
false

query B
SELECT rolbypassrls FROM pg_roles WHERE rolname = 'can_bypassrls' OR rolname = 'can_bypassrls_global';
----
true
true


query B
SELECT rolbypassrls FROM pg_roles WHERE rolname = 'cannot_bypassrls';
----
false


statement ok
DROP ROLE can_bypassrls;

statement ok
DROP ROLE cannot_bypassrls;

subtest createrole_pg_roles_pg_authid

statement ok
CREATE ROLE can_createrole WITH CREATEROLE;

statement ok
CREATE ROLE cannot_createrole;

statement ok
CREATE ROLE can_createrole_global;

statement ok
GRANT SYSTEM CREATEROLE TO can_createrole_global; 

query B
SELECT rolcreaterole FROM pg_authid WHERE rolname = 'can_createrole' OR rolname = 'can_createrole_global';
----
true
true

query B
SELECT rolcreaterole FROM pg_authid WHERE rolname = 'cannot_createrole';
----
false

query B
SELECT rolcreaterole FROM pg_roles WHERE rolname = 'can_createrole' OR rolname = 'can_createrole_global';
----
true
true

query B
SELECT rolcreaterole FROM pg_roles WHERE rolname = 'cannot_createrole';
----
false

statement ok
DROP ROLE can_createrole;

statement ok
DROP ROLE cannot_createrole;

statement ok
REVOKE SYSTEM CREATEROLE FROM can_createrole_global; 

statement ok
DROP ROLE can_createrole_global;

subtest createdb_pg_roles_pg_authid

statement ok
CREATE ROLE can_createdb WITH CREATEDB;

statement ok
CREATE ROLE cannot_createdb;

statement ok
CREATE ROLE can_createdb_global;

statement ok
GRANT SYSTEM CREATEDB TO can_createdb_global; 

query B
SELECT rolcreatedb FROM pg_authid WHERE rolname = 'can_createdb' OR rolname = 'can_createdb_global';
----
true
true

query B
SELECT rolcreatedb FROM pg_authid WHERE rolname = 'cannot_createdb';
----
false

query B
SELECT rolcreatedb FROM pg_roles WHERE rolname = 'can_createdb' OR rolname = 'can_createdb_global';
----
true
true

query B
SELECT rolcreatedb FROM pg_roles WHERE rolname = 'cannot_createdb';
----
false

statement ok
DROP ROLE can_createdb;

statement ok
DROP ROLE cannot_createdb;

statement ok
REVOKE SYSTEM CREATEDB FROM can_createdb_global; 

statement ok
DROP ROLE can_createdb_global;

subtest end

subtest filter_pushdown_leaks

statement ok
CREATE ROLE alice;

statement ok
CREATE TABLE t (x INT PRIMARY KEY, y INT, alice_has_access BOOL);

statement ok
CREATE INDEX ON t(y);

statement ok
INSERT INTO t VALUES (1, 10, true), (2, 20, false);

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON t TO alice;

statement ok
ALTER TABLE t ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY select_policy_alice
ON t
FOR SELECT
TO alice
USING (alice_has_access);

statement ok
SET ROLE alice;

# Attempt various runtime errors to test whether the system leaks the existence
# of a row with y = 20, which is hidden from the user by the RLS policy.

# Division by zero
query IIB
SELECT * FROM t WHERE y = 20 AND y/0 = 0;
----

# Out of range error
query IIB
SELECT * FROM t WHERE y = 20 AND ARRAY[1,2,3][10] = 1;
----

# Out of range error
query IIB
UPDATE t SET y = y WHERE y = 20 AND ARRAY[1,2,3][10] = 1 RETURNING *;
----

# Custom function that raise an exception.
statement ok
CREATE FUNCTION fail() RETURNS INT AS $$ BEGIN RAISE EXCEPTION 'fail'; END; $$ LANGUAGE plpgsql;

query IIB
DELETE FROM t WHERE y = 20 AND fail() = 1 RETURNING *;
----

# Custom function that is designated as leakproof
statement ok
CREATE FUNCTION divbyzero() RETURNS INT IMMUTABLE LEAKPROOF
AS $$
 BEGIN
   SELECT 20 / 0;
   RETURN 1;
 END;
$$ LANGUAGE plpgsql;

# Show that queries on rows we can see will cause the query to fail
statement error pq: division by zero
SELECT * FROM t WHERE y = 10 AND divbyzero() = 1;

# But queries on rows we cannot see won't see any error.
query IIB
SELECT * FROM t WHERE y = 20 AND divbyzero() = 1;
----

# Invalid regular expression
query IIB
SELECT * FROM t WHERE y = 20 AND 'a' ~ '(';
----

# Unicode errors
query IIB
UPDATE t SET y = y WHERE y = 20 AND power(1e400, 1) > 0 RETURNING *;
----

# CTEs
query IIB
WITH rows AS (
  SELECT x FROM t WHERE y = 20 AND y/0 = 0
)
DELETE FROM t WHERE x IN (SELECT x FROM rows) RETURNING *;
----

# INSERT w/ ON CONFLICT. This leaks information because the update attempts
# to modify a row that is filtered out by RLS, and fails. Postgres behaves the
# same, so this is left here as an example of that behaviour.
statement error pq: new row violates row-level security policy for table "t"
INSERT INTO t VALUES (2, 20, false) ON CONFLICT(x) DO UPDATE SET y = 20;

statement ok
RESET ROLE;

statement ok
DROP TABLE t;

statement ok
DROP FUNCTION fail, divbyzero;

statement ok
DROP ROLE alice;

subtest end
