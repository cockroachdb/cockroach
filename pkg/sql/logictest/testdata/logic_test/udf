statement ok
CREATE TABLE ab (
  a INT PRIMARY KEY,
  b INT
)

statement error pgcode 0A000 unimplemented: PL/pgSQL is not yet supported
CREATE FUNCTION populate() RETURNS integer AS $$
DECLARE
    -- declarations
BEGIN
    PERFORM my_function();
END;
$$ LANGUAGE plpgsql

statement error pgcode 42704 language \"made_up_language\" does not exist
CREATE FUNCTION populate() RETURNS integer AS $$
DECLARE
    -- declarations
BEGIN
    PERFORM my_function();
END;
$$ LANGUAGE made_up_language

statement error pq: unimplemented: user-defined functions with SETOF return types are not supported
CREATE FUNCTION f(a int) RETURNS SETOF INT LANGUAGE SQL AS 'SELECT 1'

statement error pq: cannot set leakproof on function with non-immutable volatility: STABLE
CREATE FUNCTION f(a int) RETURNS INT LEAKPROOF STABLE LANGUAGE SQL AS 'SELECT 1'

statement error pq: return type mismatch in function declared to return int\nDETAIL: Actual return type is string
CREATE FUNCTION f() RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 'hello' $$

statement error pq: STABLE: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT IMMUTABLE STABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: STRICT: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT CALLED ON NULL INPUT STABLE STRICT LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: RETURNS NULL ON NULL INPUT: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT CALLED ON NULL INPUT STABLE RETURNS NULL ON NULL INPUT LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: NOT LEAKPROOF: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT LEAKPROOF NOT LEAKPROOF LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: AS \$\$ SELECT 2 \$\$: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$ AS $$ SELECT 2 $$;

statement error pq: LANGUAGE SQL: conflicting or redundant options
CREATE FUNCTION f() RETURNS INT IMMUTABLE LANGUAGE SQL LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: no language specified
CREATE FUNCTION f() RETURNS INT IMMUTABLE AS $$ SELECT 1 $$;

statement error pq: no function body specified
CREATE FUNCTION f() RETURNS INT IMMUTABLE LANGUAGE SQL;

statement ok
CREATE FUNCTION a(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT i'

statement ok
CREATE FUNCTION b(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT a FROM ab WHERE a = i'

statement ok
CREATE FUNCTION c(i INT, j INT) RETURNS INT LANGUAGE SQL AS 'SELECT i - j'

statement error column \"j\" does not exist
CREATE FUNCTION err(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT j'

statement error pgcode 42703 column \"j\" does not exist
CREATE FUNCTION err(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT a FROM ab WHERE a = j'

statement error pgcode 0A000 functions do not currently support \* expressions
CREATE FUNCTION err(i INT) RETURNS ab LANGUAGE SQL AS 'SELECT * FROM ab'

statement error pgcode 0A000 functions do not currently support \* expressions
CREATE FUNCTION err(i INT) RETURNS ab LANGUAGE SQL AS 'SELECT ab.* FROM ab'

statement error pgcode 0A000 functions do not currently support \* expressions
CREATE FUNCTION err(i INT) RETURNS ab LANGUAGE SQL AS $$
  SELECT 1;
  SELECT * FROM ab;
$$

statement error pgcode 0A000 functions do not currently support \* expressions
CREATE FUNCTION err(i INT) RETURNS INT LANGUAGE SQL AS $$
  SELECT * FROM ab;
  SELECT 1;
$$

statement ok
CREATE FUNCTION d(i INT2) RETURNS INT4 LANGUAGE SQL AS 'SELECT i'

statement error return type mismatch in function declared to return bool\nDETAIL: Actual return type is int
CREATE FUNCTION err(i INT, j INT) RETURNS BOOL LANGUAGE SQL AS 'SELECT i - j'

statement error return type mismatch in function declared to return int\nDETAIL: Actual return type is bool
CREATE FUNCTION err(b BOOL) RETURNS INT LANGUAGE SQL AS 'SELECT b'

statement error return type mismatch in function declared to return bool\nDETAIL: Actual return type is int
CREATE FUNCTION err(i INT, j INT) RETURNS BOOL LANGUAGE SQL AS 'SELECT i - j'

# Make sure using table name as tuple type name works properly.
# It should pass the return type validation and stored as a tuple type.
statement ok
CREATE TABLE t_implicit_type(a INT PRIMARY KEY, b STRING);

statement error pq: return type mismatch in function declared to return int\nDETAIL: Actual return type is record
CREATE FUNCTION f() RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT a, b from t_implicit_type $$

# Create function with no references.
statement ok
CREATE FUNCTION f_no_ref(a int) RETURNS INT IMMUTABLE AS 'SELECT 1' LANGUAGE SQL

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_no_ref];
----
CREATE FUNCTION public.f_no_ref(IN a INT8)
  RETURNS INT8
  IMMUTABLE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

# Make sure that names are qualified, references are tracked and sequence
# expression is rewritten.
statement ok
CREATE TABLE t(
a INT PRIMARY KEY,
b INT,
C INT,
INDEX t_idx_b(b),
INDEX t_idx_c(c)
);

statement ok
CREATE SEQUENCE sq1;

statement ok
CREATE TYPE notmyworkday AS ENUM ('Monday', 'Tuesday');

statement ok
CREATE FUNCTION f(a notmyworkday) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$
SELECT a FROM t;
SELECT b FROM t@t_idx_b;
SELECT c FROM t@t_idx_c;
SELECT nextval('sq1');
$$

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f];
----
CREATE FUNCTION public.f(IN a test.public.notmyworkday)
  RETURNS INT8
  IMMUTABLE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT a FROM test.public.t;
  SELECT b FROM test.public.t@t_idx_b;
  SELECT c FROM test.public.t@t_idx_c;
  SELECT nextval('public.sq1'::REGCLASS);
$$

statement error pq: unimplemented: alter function depends on extension not supported.*
ALTER FUNCTION f() DEPENDS ON EXTENSION postgis


subtest udf_pg_proc

statement ok
CREATE FUNCTION proc_f(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE FUNCTION proc_f(STRING, b INT) RETURNS STRING STRICT IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$ SELECT 'hello' $$;

statement ok
CREATE SCHEMA sc;

statement
CREATE FUNCTION sc.proc_f_2(STRING) RETURNS STRING LANGUAGE SQL AS $$ SELECT 'hello' $$;

query TTTTTBBBTITTTTT
SELECT oid, proname, pronamespace, proowner, prolang, proleakproof, proisstrict, proretset, provolatile, pronargs, prorettype, proargtypes, proargmodes, proargnames, prosrc
FROM pg_catalog.pg_proc WHERE proname IN ('proc_f', 'proc_f_2');
----
100118  proc_f    105  1546506610  14  false  false  false  v  1  20  20     {i}    NULL    SELECT 1;
100119  proc_f    105  1546506610  14  true   true   false  i  2  25  25 20  {i,i}  {"",b}  SELECT 'hello';
100121  proc_f_2  120  1546506610  14  false  false  false  v  1  25  25     {i}    NULL    SELECT 'hello';

statement ok
USE defaultdb;

query TTTTTBBBTITTTTT
SELECT oid, proname, pronamespace, proowner, prolang, proleakproof, proisstrict, proretset, provolatile, pronargs, prorettype, proargtypes, proargmodes, proargnames, prosrc
FROM pg_catalog.pg_proc WHERE proname IN ('proc_f', 'proc_f_2');
----

statement ok
USE test;

subtest create_function_statements

query TITITIT
SELECT create_statement, database_id, database_name, schema_id, schema_name, function_id, function_name
FROM crdb_internal.create_function_statements
WHERE function_name IN ('proc_f', 'proc_f_2')
ORDER BY function_name;
----
CREATE FUNCTION public.proc_f(IN INT8)
    RETURNS INT8
    VOLATILE
    NOT LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT 1;
$$  104  test  105  public  118  proc_f
CREATE FUNCTION public.proc_f(IN STRING, IN b INT8)
    RETURNS STRING
    IMMUTABLE
    LEAKPROOF
    STRICT
    LANGUAGE SQL
    AS $$
    SELECT 'hello';
$$  104  test  105  public  119  proc_f
CREATE FUNCTION sc.proc_f_2(IN STRING)
    RETURNS STRING
    VOLATILE
    NOT LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT 'hello';
$$  104  test  120  sc  121  proc_f_2

statement ok
CREATE DATABASE test_cross_db;
USE test_cross_db;
CREATE FUNCTION f_cross_db() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
USE test;

query TITITIT
SELECT create_statement, database_id, database_name, schema_id, schema_name, function_id, function_name
FROM "".crdb_internal.create_function_statements
WHERE function_name IN ('proc_f', 'proc_f_2', 'f_cross_db')
ORDER BY database_id, function_name;
----
CREATE FUNCTION public.proc_f(IN INT8)
    RETURNS INT8
    VOLATILE
    NOT LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT 1;
$$  104  test  105  public  118  proc_f
CREATE FUNCTION public.proc_f(IN STRING, IN b INT8)
    RETURNS STRING
    IMMUTABLE
    LEAKPROOF
    STRICT
    LANGUAGE SQL
    AS $$
    SELECT 'hello';
$$  104  test  105  public  119  proc_f
CREATE FUNCTION sc.proc_f_2(IN STRING)
    RETURNS STRING
    VOLATILE
    NOT LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT 'hello';
$$  104  test  120  sc  121  proc_f_2
CREATE FUNCTION public.f_cross_db()
    RETURNS INT8
    VOLATILE
    NOT LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT 1;
$$  122  test_cross_db  123  public  124  f_cross_db

subtest show_create_function

query T
SELECT @2 FROM [SHOW CREATE FUNCTION proc_f];
----
CREATE FUNCTION public.proc_f(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$
CREATE FUNCTION public.proc_f(IN STRING, IN b INT8)
  RETURNS STRING
  IMMUTABLE
  LEAKPROOF
  STRICT
  LANGUAGE SQL
  AS $$
  SELECT 'hello';
$$

statement error pq: unknown function: proc_f_2()
SHOW CREATE FUNCTION proc_f_2;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION sc.proc_f_2];
----
CREATE FUNCTION sc.proc_f_2(IN STRING)
  RETURNS STRING
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 'hello';
$$

statement ok
SET search_path = sc;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION proc_f_2];
----
CREATE FUNCTION sc.proc_f_2(IN STRING)
  RETURNS STRING
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 'hello';
$$

statement ok
SET search_path = public;

subtest udf_regproc

query T
SELECT '100126'::REGPROC;
----
100126

query T
SELECT 'sc.proc_f_2'::REGPROC;
----
proc_f_2

query I
SELECT 'sc.proc_f_2'::REGPROC::INT;
----
100121

statement error pq: unknown function: no_such_func()
SELECT 'no_such_func'::REGPROC;

statement error pq: more than one function named 'proc_f'
SELECT 'proc_f'::REGPROC;

query T
SELECT 100126::regproc;
----
100126

query I
SELECT 100117::regproc::INT;
----
100117

query T
SELECT 999999::regproc;
----
999999

subtest drop_function

statement ok
CREATE FUNCTION f_test_drop() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE FUNCTION f_test_drop(int) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE SCHEMA sc1

statement ok
CREATE FUNCTION sc1.f_test_drop(int) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
SET search_path = public,sc1

query T
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_drop];
----
CREATE FUNCTION public.f_test_drop()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$
CREATE FUNCTION public.f_test_drop(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

query T
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];
----
CREATE FUNCTION sc1.f_test_drop(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement error pq: function name \"f_test_drop\" is not unique
DROP FUNCTION f_test_drop;

statement ok
DROP FUNCTION IF EXISTS f_not_existing;

statement error pq: unknown function: f_not_existing\(\): function undefined
DROP FUNCTION f_not_existing;

# drop a function twice should fail.
statement error pq: function f_test_drop\(\) does not exist: function undefined
BEGIN;
DROP FUNCTION f_test_drop();
DROP FUNCTION f_test_drop();
COMMIT;

statement ok
ROLLBACK;

statement ok
DROP FUNCTION f_test_drop();

query T
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_drop];
----
CREATE FUNCTION public.f_test_drop(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

query T
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];
----
CREATE FUNCTION sc1.f_test_drop(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

# Drop with two identical function signatures should be ok. And only first match
# in path should be drop.
statement ok
DROP FUNCTION f_test_drop(INT), f_test_drop(INT);

statement error pq: unknown function: public.f_test_drop\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_drop];

query T
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];
----
CREATE FUNCTION sc1.f_test_drop(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement ok
DROP FUNCTION f_test_drop(INT);

statement error pq: unknown function: sc1.f_test_drop\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];

# If there are identical function signatures in different schemas, multiple drop
# statements should drop them all. This matches postgres behavior.
statement ok
CREATE FUNCTION public.f_test_drop() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION sc1.f_test_drop() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_drop];
----
CREATE FUNCTION public.f_test_drop()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

query T
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];
----
CREATE FUNCTION sc1.f_test_drop()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement ok;
BEGIN;
DROP FUNCTION f_test_drop();
DROP FUNCTION f_test_drop();
COMMIT;

statement error pq: unknown function: public.f_test_drop\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_drop];

statement error pq: unknown function: sc1.f_test_drop\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION sc1.f_test_drop];

statement ok
SET search_path = public

statement ok
DROP SCHEMA sc1;

subtest disallow_udf_in_table

statement ok
CREATE FUNCTION test_tbl_f() RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT DEFAULT (test_tbl_f() + 1));

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT ON UPDATE (test_tbl_f() + 1));

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT AS (test_tbl_f() + 1) STORED);

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT CHECK (test_tbl_f() > 0));

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT, INDEX idx_b(test_tbl_f()));

statement ok
CREATE TABLE test_tbl_t (a INT PRIMARY KEY, b INT);

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE INDEX t_idx ON test_tbl_t(test_tbl_f());

statement error pq: unimplemented: usage of user-defined function from relations not supported
CREATE INDEX t_idx ON test_tbl_t(b) WHERE test_tbl_f() > 0;

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ADD CONSTRAINT bgt CHECK (test_tbl_f() > 1);

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ADD COLUMN c int CHECK (test_tbl_f() > 0);

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ADD COLUMN c int AS (test_tbl_f()) stored;

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ADD COLUMN c int DEFAULT (test_tbl_f());

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ADD COLUMN c int ON UPDATE (test_tbl_f());

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ALTER COLUMN b SET DEFAULT (test_tbl_f());

statement error pq: unimplemented: usage of user-defined function from relations not supported
ALTER TABLE test_tbl_t ALTER COLUMN b SET ON UPDATE (test_tbl_f());

subtest disallow_udf_in_views_and_udf

statement ok
CREATE FUNCTION test_vf_f() RETURNS STRING LANGUAGE SQL AS $$ SELECT lower('hello') $$;

statement error pq: unknown function: test_vf_f\(\): function undefined
CREATE FUNCTION test_vf_g() RETURNS STRING LANGUAGE SQL AS $$ SELECT test_vf_f() $$;

statement ok
CREATE FUNCTION test_vf_g() RETURNS STRING LANGUAGE SQL AS $$ SELECT lower('hello') $$;

statement error pq: unknown function: test_vf_f\(\): function undefined
CREATE VIEW v AS SELECT test_vf_f();

statement ok
CREATE VIEW v AS SELECT lower('hello');

query T
SELECT @2 FROM [SHOW CREATE FUNCTION test_vf_f];
----
CREATE FUNCTION public.test_vf_f()
  RETURNS STRING
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT lower('hello');
$$


subtest grant_revoke

statement ok
CREATE SCHEMA test_priv_sc1;
SET search_path = public,test_priv_sc1;
CREATE FUNCTION test_priv_f1() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION test_priv_f2(int) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION test_priv_sc1.test_priv_f3() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE USER udf_test_user;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root     test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root     test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee  privilege_type  is_grantable
test           public         100137       test_priv_f1()      root     EXECUTE         true
test           public         100138       test_priv_f2(int8)  root     EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root     EXECUTE         true

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1(), test_priv_f2(INT), test_priv_f3()
----
database_name  schema_name    function_id  function_signature  grantee  privilege_type  is_grantable
test           public         100137       test_priv_f1()      root     EXECUTE         true
test           public         100138       test_priv_f2(int8)  root     EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root     EXECUTE         true

query TTTTTT colnames
SHOW FUNCTIONS
----
schema_name    function_name  result_data_type  argument_data_types  function_type  volatility
public         a              int8              int8                 func           volatile
public         b              int8              int8                 func           volatile
public         c              int8              int8, int8           func           volatile
public         d              int4              int2                 func           volatile
public         f              int8              notmyworkday         func           immutable
public         f_no_ref       int8              int8                 func           immutable
public         proc_f         int8              int8                 func           volatile
public         proc_f         text              text, int8           func           immutable
public         test_priv_f1   int8              ·                    func           volatile
public         test_priv_f2   int8              int8                 func           volatile
public         test_tbl_f     int8              ·                    func           immutable
public         test_vf_f      text              ·                    func           volatile
public         test_vf_g      text              ·                    func           volatile
sc             proc_f_2       text              text                 func           volatile
test_priv_sc1  test_priv_f3   int8              ·                    func           volatile

query TTTTTT colnames
SHOW FUNCTIONS FROM public
----
schema_name  function_name  result_data_type  argument_data_types  function_type  volatility
public       a              int8              int8                 func           volatile
public       b              int8              int8                 func           volatile
public       c              int8              int8, int8           func           volatile
public       d              int4              int2                 func           volatile
public       f              int8              notmyworkday         func           immutable
public       f_no_ref       int8              int8                 func           immutable
public       proc_f         int8              int8                 func           volatile
public       proc_f         text              text, int8           func           immutable
public       test_priv_f1   int8              ·                    func           volatile
public       test_priv_f2   int8              int8                 func           volatile
public       test_tbl_f     int8              ·                    func           immutable
public       test_vf_f      text              ·                    func           volatile
public       test_vf_g      text              ·                    func           volatile

query TTTTTT colnames
SHOW FUNCTIONS FROM test_priv_sc1
----
schema_name    function_name  result_data_type  argument_data_types  function_type  volatility
test_priv_sc1  test_priv_f3   int8              ·                    func           volatile

query TTTTTT colnames
SHOW FUNCTIONS FROM test
----
schema_name    function_name  result_data_type  argument_data_types  function_type  volatility
public         a              int8              int8                 func           volatile
public         b              int8              int8                 func           volatile
public         c              int8              int8, int8           func           volatile
public         d              int4              int2                 func           volatile
public         f              int8              notmyworkday         func           immutable
public         f_no_ref       int8              int8                 func           immutable
public         proc_f         int8              int8                 func           volatile
public         proc_f         text              text, int8           func           immutable
public         test_priv_f1   int8              ·                    func           volatile
public         test_priv_f2   int8              int8                 func           volatile
public         test_tbl_f     int8              ·                    func           immutable
public         test_vf_f      text              ·                    func           volatile
public         test_vf_g      text              ·                    func           volatile
sc             proc_f_2       text              text                 func           volatile
test_priv_sc1  test_priv_f3   int8              ·                    func           volatile

statement ok
GRANT EXECUTE ON FUNCTION test_priv_f1(), test_priv_f2(int), test_priv_sc1.test_priv_f3 TO udf_test_user WITH GRANT OPTION;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee        specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root           test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root           test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root           test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     udf_test_user  test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee        privilege_type  is_grantable
test           public         100137       test_priv_f1()      root           EXECUTE         true
test           public         100137       test_priv_f1()      udf_test_user  EXECUTE         true
test           public         100138       test_priv_f2(int8)  root           EXECUTE         true
test           public         100138       test_priv_f2(int8)  udf_test_user  EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root           EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      udf_test_user  EXECUTE         true

statement error pq: cannot drop role/user udf_test_user: grants still exist on.*
DROP USER udf_test_user;

statement ok
REVOKE GRANT OPTION FOR EXECUTE ON FUNCTION test_priv_f1(), test_priv_f2(int), test_priv_sc1.test_priv_f3 FROM udf_test_user;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee        specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root           test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root           test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root           test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         NO
NULL     udf_test_user  test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         NO
NULL     udf_test_user  test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         NO

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee        privilege_type  is_grantable
test           public         100137       test_priv_f1()      root           EXECUTE         true
test           public         100137       test_priv_f1()      udf_test_user  EXECUTE         false
test           public         100138       test_priv_f2(int8)  root           EXECUTE         true
test           public         100138       test_priv_f2(int8)  udf_test_user  EXECUTE         false
test           test_priv_sc1  100139       test_priv_f3()      root           EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      udf_test_user  EXECUTE         false

statement ok
REVOKE EXECUTE ON FUNCTION test_priv_f1(), test_priv_f2(int), test_priv_sc1.test_priv_f3 FROM udf_test_user;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root     test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root     test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee  privilege_type  is_grantable
test           public         100137       test_priv_f1()      root     EXECUTE         true
test           public         100138       test_priv_f2(int8)  root     EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root     EXECUTE         true

statement ok
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public, test_priv_sc1 TO udf_test_user WITH GRANT OPTION;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee        specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root           test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root           test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root           test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     udf_test_user  test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee        privilege_type  is_grantable
test           public         100137       test_priv_f1()      root           EXECUTE         true
test           public         100137       test_priv_f1()      udf_test_user  EXECUTE         true
test           public         100138       test_priv_f2(int8)  root           EXECUTE         true
test           public         100138       test_priv_f2(int8)  udf_test_user  EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root           EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      udf_test_user  EXECUTE         true

statement ok
REVOKE GRANT OPTION FOR EXECUTE ON ALL FUNCTIONS in schema public, test_priv_sc1 FROM udf_test_user;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee        specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root           test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root           test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root           test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         NO
NULL     udf_test_user  test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         NO
NULL     udf_test_user  test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         NO

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee        privilege_type  is_grantable
test           public         100137       test_priv_f1()      root           EXECUTE         true
test           public         100137       test_priv_f1()      udf_test_user  EXECUTE         false
test           public         100138       test_priv_f2(int8)  root           EXECUTE         true
test           public         100138       test_priv_f2(int8)  udf_test_user  EXECUTE         false
test           test_priv_sc1  100139       test_priv_f3()      root           EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      udf_test_user  EXECUTE         false

statement ok
REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA public, test_priv_sc1 FROM udf_test_user;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100137  test             public          test_priv_f1  EXECUTE         YES
NULL     root     test              public           test_priv_f2_100138  test             public          test_priv_f2  EXECUTE         YES
NULL     root     test              test_priv_sc1    test_priv_f3_100139  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee  privilege_type  is_grantable
test           public         100137       test_priv_f1()      root     EXECUTE         true
test           public         100138       test_priv_f2(int8)  root     EXECUTE         true
test           test_priv_sc1  100139       test_priv_f3()      root     EXECUTE         true

statement ok
DROP FUNCTION test_priv_f1;
DROP FUNCTION test_priv_f2;
DROP FUNCTION test_priv_sc1.test_priv_f3;
DROP USER udf_test_user;

subtest default_privileges

statement ok
CREATE USER udf_test_user;
CREATE FUNCTION test_priv_f1() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100140  test             public          test_priv_f1  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1
----
database_name  schema_name  function_id  function_signature  grantee  privilege_type  is_grantable
test           public       100140       test_priv_f1()      root     EXECUTE         true

# Add default privilege and make sure new function
statement ok
ALTER DEFAULT PRIVILEGES IN SCHEMA public, test_priv_sc1 GRANT EXECUTE ON FUNCTIONS TO udf_test_user WITH GRANT OPTION;

statement ok
CREATE FUNCTION test_priv_f2(int) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION test_priv_sc1.test_priv_f3() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee        specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root           test              public           test_priv_f1_100140  test             public          test_priv_f1  EXECUTE         YES
NULL     root           test              public           test_priv_f2_100141  test             public          test_priv_f2  EXECUTE         YES
NULL     root           test              test_priv_sc1    test_priv_f3_100142  test             test_priv_sc1   test_priv_f3  EXECUTE         YES
NULL     udf_test_user  test              public           test_priv_f2_100141  test             public          test_priv_f2  EXECUTE         YES
NULL     udf_test_user  test              test_priv_sc1    test_priv_f3_100142  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee        privilege_type  is_grantable
test           public         100140       test_priv_f1()      root           EXECUTE         true
test           public         100141       test_priv_f2(int8)  root           EXECUTE         true
test           public         100141       test_priv_f2(int8)  udf_test_user  EXECUTE         true
test           test_priv_sc1  100142       test_priv_f3()      root           EXECUTE         true
test           test_priv_sc1  100142       test_priv_f3()      udf_test_user  EXECUTE         true

statement ok
DROP FUNCTION test_priv_f2;
DROP FUNCTION test_priv_sc1.test_priv_f3;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100140  test             public          test_priv_f1  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1
----
database_name  schema_name  function_id  function_signature  grantee  privilege_type  is_grantable
test           public       100140       test_priv_f1()      root     EXECUTE         true

statement ok
ALTER DEFAULT PRIVILEGES IN SCHEMA public, test_priv_sc1 REVOKE EXECUTE ON FUNCTIONS FROM udf_test_user;

statement ok
CREATE FUNCTION test_priv_f2(int) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION test_priv_sc1.test_priv_f3() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query TTTTTTTTTT colnames
SELECT * FROM information_schema.role_routine_grants
WHERE routine_name IN ('test_priv_f1', 'test_priv_f2', 'test_priv_f3')
ORDER BY grantee, routine_name;
----
grantor  grantee  specific_catalog  specific_schema  specific_name        routine_catalog  routine_schema  routine_name  privilege_type  is_grantable
NULL     root     test              public           test_priv_f1_100140  test             public          test_priv_f1  EXECUTE         YES
NULL     root     test              public           test_priv_f2_100143  test             public          test_priv_f2  EXECUTE         YES
NULL     root     test              test_priv_sc1    test_priv_f3_100144  test             test_priv_sc1   test_priv_f3  EXECUTE         YES

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION test_priv_f1, test_priv_f2, test_priv_f3
----
database_name  schema_name    function_id  function_signature  grantee  privilege_type  is_grantable
test           public         100140       test_priv_f1()      root     EXECUTE         true
test           public         100143       test_priv_f2(int8)  root     EXECUTE         true
test           test_priv_sc1  100144       test_priv_f3()      root     EXECUTE         true

# Make sure has_function_privilege works.
query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE')
----
true

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE WITH GRANT OPTION')
----
true

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE, EXECUTE WITH GRANT OPTION')
----
true

user testuser

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE')
----
false

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE WITH GRANT OPTION')
----
false

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE, EXECUTE WITH GRANT OPTION')
----
false

user root

statement ok
GRANT EXECUTE ON FUNCTION test_priv_f1(), test_priv_f2(int), test_priv_sc1.test_priv_f3 TO testuser WITH GRANT OPTION;

user testuser

query B retry
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE')
----
true

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE WITH GRANT OPTION')
----
true

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE, EXECUTE WITH GRANT OPTION')
----
true

user root

statement ok
REVOKE GRANT OPTION FOR EXECUTE ON FUNCTION test_priv_f1(), test_priv_f2(int), test_priv_sc1.test_priv_f3 FROM testuser;

user testuser

query B retry
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE WITH GRANT OPTION')
----
false

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE')
----
true

query B
SELECT has_function_privilege('test_priv_f2(INT)', 'EXECUTE, EXECUTE WITH GRANT OPTION')
----
true

user root

statement ok
SET search_path = public;

subtest alter_function_options

statement ok
CREATE FUNCTION f_test_alter_opt(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_opt];
----
CREATE FUNCTION public.f_test_alter_opt(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement error pq: IMMUTABLE: conflicting or redundant options
ALTER FUNCTION f_test_alter_opt IMMUTABLE IMMUTABLE

statement error pq: cannot set leakproof on function with non-immutable volatility: STABLE
ALTER FUNCTION f_test_alter_opt STABLE LEAKPROOF

statement ok
ALTER FUNCTION f_test_alter_opt IMMUTABLE LEAKPROOF STRICT;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_opt];
----
CREATE FUNCTION public.f_test_alter_opt(IN INT8)
  RETURNS INT8
  IMMUTABLE
  LEAKPROOF
  STRICT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

subtest alter_function_name

statement ok
CREATE FUNCTION f_test_alter_name(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE FUNCTION f_test_alter_name_same_in(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE FUNCTION f_test_alter_name_diff_in() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_name];
----
CREATE FUNCTION public.f_test_alter_name(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement error pq: function f_test_alter_name\(IN INT8\) already exists in schema "public"
ALTER FUNCTION f_test_alter_name RENAME TO f_test_alter_name

statement error pq: function f_test_alter_name_same_in\(IN INT8\) already exists in schema "public"
ALTER FUNCTION f_test_alter_name RENAME TO f_test_alter_name_same_in

statement ok
ALTER FUNCTION f_test_alter_name RENAME TO f_test_alter_name_new

statement error pq: unknown function: f_test_alter_name\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_name];

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_name_new];
----
CREATE FUNCTION public.f_test_alter_name_new(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

statement ok
ALTER FUNCTION f_test_alter_name_new RENAME to f_test_alter_name_diff_in

statement error pq: unknown function: f_test_alter_name_new\(\): function undefined
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_name_new];

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_alter_name_diff_in];
----
CREATE FUNCTION public.f_test_alter_name_diff_in()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$
CREATE FUNCTION public.f_test_alter_name_diff_in(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

subtest alter_function_owner

statement ok
CREATE USER u_test_owner;
CREATE FUNCTION f_test_alter_owner() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query T
SELECT rolname FROM pg_catalog.pg_proc f
JOIN pg_catalog.pg_roles r ON f.proowner = r.oid
WHERE proname = 'f_test_alter_owner';
----
root

statement error  pq: role/user "user_not_exists" does not exist
ALTER FUNCTION f_test_alter_owner OWNER TO user_not_exists

statement ok
ALTER FUNCTION f_test_alter_owner OWNER TO u_test_owner;

query T
SELECT rolname FROM pg_catalog.pg_proc f
JOIN pg_catalog.pg_roles r ON f.proowner = r.oid
WHERE proname = 'f_test_alter_owner';
----
u_test_owner

statement ok
REASSIGN OWNED BY u_test_owner TO root;

query T
SELECT rolname FROM pg_catalog.pg_proc f
JOIN pg_catalog.pg_roles r ON f.proowner = r.oid
WHERE proname = 'f_test_alter_owner';
----
root

statement ok
ALTER FUNCTION f_test_alter_owner OWNER TO u_test_owner;

query T
SELECT rolname FROM pg_catalog.pg_proc f
JOIN pg_catalog.pg_roles r ON f.proowner = r.oid
WHERE proname = 'f_test_alter_owner';
----
u_test_owner

statement error pq: role u_test_owner cannot be dropped because some objects depend on it
DROP USER u_test_owner;

statement ok
DROP FUNCTION f_test_alter_owner;

statement ok
DROP USER u_test_owner;

subtest alter_function_set_schema

statement ok
CREATE FUNCTION f_test_sc() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION f_test_sc(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 2 $$;
CREATE SCHEMA test_alter_sc;
CREATE FUNCTION test_alter_sc.f_test_sc() RETURNS INT LANGUAGE SQL AS $$ SELECT 3 $$;

statement ok
CREATE FUNCTION get_function_id(namespace STRING, name STRING, argmodes STRING[])
  RETURNS INT
  LANGUAGE SQL
  AS $$
SELECT oid::INT8 - 100000
  FROM pg_proc
 WHERE proname = name
   AND pronamespace = namespace::REGNAMESPACE
   AND proargmodes = argmodes
$$

let $public_f_test_sc
SELECT get_function_id('public', 'f_test_sc', ARRAY[]:::STRING[]);

let $public_f_test_sc_int
SELECT get_function_id('public', 'f_test_sc', ARRAY['i']);

let $test_alter_sc_f_test_sc
SELECT get_function_id('test_alter_sc', 'f_test_sc', ARRAY[]:::STRING[]);

query TTT
SELECT oid, proname, prosrc
FROM pg_catalog.pg_proc WHERE proname IN ('f_test_sc');
----
100150  f_test_sc  SELECT 1;
100151  f_test_sc  SELECT 2;
100153  f_test_sc  SELECT 3;

query TT
  WITH fns AS (
            SELECT crdb_internal.pb_to_json(
                    'cockroach.sql.sqlbase.Descriptor',
                    descriptor,
                    false
                   )->'function' AS fn
              FROM system.descriptor
             WHERE id
                   IN (
                        $public_f_test_sc,
                        $public_f_test_sc_int,
                        $test_alter_sc_f_test_sc
                    )
           )
SELECT fn->>'id' AS id, fn->'parentSchemaId'
  FROM fns
  ORDER BY id;
----
150  105
151  105
153  152

statement error pq: cannot move objects into or out of virtual schemas
ALTER FUNCTION f_test_sc() SET SCHEMA pg_catalog;

statement error pq: function test_alter_sc.f_test_sc\(\) already exists in schema "test_alter_sc"
ALTER FUNCTION f_test_sc() SET SCHEMA test_alter_sc;

# Make sure moving to same schema has not effects.
statement ok
ALTER FUNCTION f_test_sc(INT) SET SCHEMA public;

query TT
  WITH fns AS (
            SELECT crdb_internal.pb_to_json(
                    'cockroach.sql.sqlbase.Descriptor',
                    descriptor,
                    false
                   )->'function' AS fn
              FROM system.descriptor
             WHERE id
                   IN (
                        $public_f_test_sc,
                        $public_f_test_sc_int,
                        $test_alter_sc_f_test_sc
                    )
           )
SELECT fn->>'id' AS id, fn->'parentSchemaId'
  FROM fns
  ORDER BY id;
----
150  105
151  105
153  152

query T
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_sc];
----
CREATE FUNCTION public.f_test_sc()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$
CREATE FUNCTION public.f_test_sc(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 2;
$$

# Make sure moving to another schema changes function's parentSchemaId and
# schema's function list.
statement ok
ALTER FUNCTION f_test_sc(INT) SET SCHEMA test_alter_sc;

query TT
  WITH fns AS (
            SELECT crdb_internal.pb_to_json(
                    'cockroach.sql.sqlbase.Descriptor',
                    descriptor,
                    false
                   )->'function' AS fn
              FROM system.descriptor
             WHERE id
                   IN (
                        $public_f_test_sc,
                        $public_f_test_sc_int,
                        $test_alter_sc_f_test_sc
                    )
           )
SELECT fn->>'id' AS id, fn->'parentSchemaId'
  FROM fns
  ORDER BY id;
----
150  105
151  152
153  152

query T
SELECT @2 FROM [SHOW CREATE FUNCTION public.f_test_sc];
----
CREATE FUNCTION public.f_test_sc()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

query T
SELECT @2 FROM [SHOW CREATE FUNCTION test_alter_sc.f_test_sc];
----
CREATE FUNCTION test_alter_sc.f_test_sc()
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 3;
$$
CREATE FUNCTION test_alter_sc.f_test_sc(IN INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 2;
$$


subtest create_or_replace_function

statement error pq: parameter name "a" used more than once
CREATE FUNCTION f_test_cor(a INT, a INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE FUNCTION f_test_cor(a INT, b INT) RETURNS INT IMMUTABLE LEAKPROOF STRICT LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: function "f_test_cor" already exists with same argument types
CREATE FUNCTION f_test_cor(a INT, b INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement ok
CREATE OR REPLACE FUNCTION f_test_cor_not_exist(a INT, b INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: cannot change name of input parameter "b"
CREATE OR REPLACE FUNCTION f_test_cor(a INT, c INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: cannot change return type of existing function
CREATE OR REPLACE FUNCTION f_test_cor(a INT, b INT) RETURNS STRING IMMUTABLE LANGUAGE SQL AS $$ SELECT 'hello' $$;

statement error pq: unimplemented: user-defined functions with SETOF return types are not supported
CREATE OR REPLACE FUNCTION f_test_cor(a INT, b INT) RETURNS SETOF INT IMMUTABLE LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: cannot set leakproof on function with non-immutable volatility: VOLATILE
CREATE OR REPLACE FUNCTION f_test_cor(a INT, b INT) RETURNS INT LEAKPROOF LANGUAGE SQL AS $$ SELECT 1 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_cor];
----
CREATE FUNCTION public.f_test_cor(IN a INT8, IN b INT8)
  RETURNS INT8
  IMMUTABLE
  LEAKPROOF
  STRICT
  LANGUAGE SQL
  AS $$
  SELECT 1;
$$

# Make sure volatility, leakproof and null input behavior are default values
# after replacing with a definition not specifying them.
statement ok
CREATE OR REPLACE FUNCTION f_test_cor(a INT, b INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 2 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_cor];
----
CREATE FUNCTION public.f_test_cor(IN a INT8, IN b INT8)
  RETURNS INT8
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 2;
$$

statement ok
CREATE OR REPLACE FUNCTION f_test_cor(a INT, b INT) RETURNS INT IMMUTABLE LEAKPROOF STRICT LANGUAGE SQL AS $$ SELECT 3 $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_test_cor];
----
CREATE FUNCTION public.f_test_cor(IN a INT8, IN b INT8)
  RETURNS INT8
  IMMUTABLE
  LEAKPROOF
  STRICT
  LANGUAGE SQL
  AS $$
  SELECT 3;
$$

subtest seq_qualified_name

statement ok
CREATE SCHEMA sc_seq_qualified_name;
CREATE SEQUENCE sc_seq_qualified_name.sq;

statement error pq: relation "sc_seq_qualified_name.sq" does not exist
CREATE FUNCTION f_seq_qualified_name() RETURNS INT LANGUAGE SQL AS $$ SELECT * FROM nextval('"sc_seq_qualified_name.sq"') $$;

statement ok
CREATE FUNCTION f_seq_qualified_name() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('sc_seq_qualified_name.sq') $$;

query I
SELECT f_seq_qualified_name()
----
1

statement ok
CREATE FUNCTION f_seq_qualified_name_quoted() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('"sc_seq_qualified_name"."sq"') $$;

query I
SELECT f_seq_qualified_name_quoted()
----
2

subtest udt_rewrite

statement ok
CREATE FUNCTION f_udt_rewrite() RETURNS notmyworkday LANGUAGE SQL AS $$ SELECT 'Monday':: notmyworkday $$;

query T
SELECT @2 FROM [SHOW CREATE FUNCTION f_udt_rewrite];
----
CREATE FUNCTION public.f_udt_rewrite()
  RETURNS test.public.notmyworkday
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE SQL
  AS $$
  SELECT 'Monday':::test.public.notmyworkday;
$$

query T
SELECT f_udt_rewrite()
----
Monday

statement ok
ALTER TYPE notmyworkday RENAME TO notmyworkday_new;

query T
SELECT f_udt_rewrite()
----
Monday

statement ok
ALTER TYPE notmyworkday_new RENAME TO notmyworkday;

query T
SELECT f_udt_rewrite()
----
Monday

subtest cross_db

statement ok
CREATE DATABASE cross_db1;
CREATE SCHEMA cross_db1.sc;
CREATE TYPE cross_db1.sc.workday AS ENUM ('MON');
CREATE TABLE cross_db1.sc.tbl(a INT PRIMARY KEY, b cross_db1.sc.workday);
CREATE VIEW cross_db1.sc.v AS SELECT a FROM cross_db1.sc.tbl;

statement error pq: cross database type references are not supported: cross_db1.sc.workday
CREATE FUNCTION f_cross_db(cross_db1.sc.workday) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

statement error pq: cross database type references are not supported: cross_db1.sc.workday
CREATE FUNCTION f_cross_db() RETURNS cross_db1.sc.workday LANGUAGE SQL AS $$ SELECT 'MON'::cross_db1.sc.workday $$;

statement error pq: the function cannot refer to other databases
CREATE FUNCTION f_cross_db() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM cross_db1.sc.tbl $$;

statement error pq: the function cannot refer to other databases
CREATE FUNCTION f_cross_db() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM cross_db1.sc.v $$;

subtest db_rename

statement ok
CREATE DATABASE rename_db1;
SET DATABASE = rename_db1;

statement ok
CREATE SCHEMA sc1;
CREATE SCHEMA sc2;
CREATE TYPE sc1.workday AS ENUM ('Mon');
CREATE TABLE sc1.tbl(a INT PRIMARY KEY);
CREATE SEQUENCE sc1.sq;

statement ok
CREATE FUNCTION sc1.f_tbl() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM sc1.tbl $$;
CREATE FUNCTION sc1.f_type() RETURNS sc1.workday LANGUAGE SQL AS $$ SELECT 'Mon'::sc1.workday $$;
CREATE FUNCTION sc1.f_seq() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('sc1.sq') $$;
CREATE FUNCTION sc2.f_tbl() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM sc1.tbl $$;
CREATE FUNCTION sc2.f_type() RETURNS sc1.workday LANGUAGE SQL AS $$ SELECT 'Mon'::sc1.workday $$;
CREATE FUNCTION sc2.f_seq() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('sc1.sq') $$;

query T
SELECT sc1.f_type()
----
Mon

query I
SELECT sc1.f_seq()
----
1

query T
SELECT sc2.f_type()
----
Mon

query I
SELECT sc2.f_seq()
----
2

statement error pq: cannot rename database because relation "rename_db1.sc1.f_tbl" depends on relation "rename_db1.sc1.tbl"
ALTER DATABASE rename_db1 RENAME TO rename_db2;

statement ok
DROP FUNCTION sc1.f_tbl()

statement error pq: cannot rename database because relation "rename_db1.sc2.f_tbl" depends on relation "rename_db1.sc1.tbl"
ALTER DATABASE rename_db1 RENAME TO rename_db2;

statement ok
DROP FUNCTION sc2.f_tbl()

statement ok
ALTER DATABASE rename_db1 RENAME TO rename_db2;
USE rename_db2;

# Make sure that db renaming does not affect types and sequences in UDF.
query T
SELECT sc1.f_type()
----
Mon

query I
SELECT sc1.f_seq()
----
3

query T
SELECT sc2.f_type()
----
Mon

query I
SELECT sc2.f_seq()
----
4

statement ok
SET DATABASE = test

statement ok
CREATE DATABASE rename_sc1;
SET DATABASE = rename_sc1;

statement ok
CREATE SCHEMA sc1;
CREATE SCHEMA sc2;
CREATE TYPE sc1.workday AS ENUM ('Mon');
CREATE TABLE sc1.tbl(a INT PRIMARY KEY);
CREATE SEQUENCE sc1.sq;

statement ok
CREATE FUNCTION sc1.f_tbl() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM sc1.tbl $$;
CREATE FUNCTION sc1.f_type() RETURNS sc1.workday LANGUAGE SQL AS $$ SELECT 'Mon'::sc1.workday $$;
CREATE FUNCTION sc1.f_seq() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('sc1.sq') $$;
CREATE FUNCTION sc2.f_tbl() RETURNS INT LANGUAGE SQL AS $$ SELECT a FROM sc1.tbl $$;
CREATE FUNCTION sc2.f_type() RETURNS sc1.workday LANGUAGE SQL AS $$ SELECT 'Mon'::sc1.workday $$;
CREATE FUNCTION sc2.f_seq() RETURNS INT LANGUAGE SQL AS $$ SELECT nextval('sc1.sq') $$;

query T
SELECT sc1.f_type()
----
Mon

query I
SELECT sc1.f_seq()
----
1

query T
SELECT sc2.f_type()
----
Mon

query I
SELECT sc2.f_seq()
----
2

statement error pq: cannot rename schema because relation "rename_sc1.sc1.f_tbl" depends on relation "rename_sc1.sc1.tbl"
ALTER SCHEMA sc1 RENAME TO sc1_new

statement ok
DROP FUNCTION sc1.f_tbl()

statement error pq: cannot rename schema because relation "rename_sc1.sc2.f_tbl" depends on relation "rename_sc1.sc1.tbl"
ALTER SCHEMA sc1 RENAME TO sc1_new

statement ok
DROP FUNCTION sc2.f_tbl()

statement ok
ALTER SCHEMA sc1 RENAME TO sc1_new

# Cannot refer to the old schema name.
statement error pq: schema "sc1" does not exist
SELECT sc1.f_type()

statement error pq: schema "sc1" does not exist
SELECT sc1.f_seq()

# Make sure that schema renaming does not affect types and sequences in UDF.
query T
SELECT sc1_new.f_type()
----
Mon

query I
SELECT sc1_new.f_seq()
----
3

query T
SELECT sc2.f_type()
----
Mon

query I
SELECT sc2.f_seq()
----
4

statement ok
SET DATABASE = test

subtest select_from_seq_rename

statement ok
CREATE DATABASE tdb_seq_select;
SET DATABASE = tdb_seq_select;

statement ok
CREATE SCHEMA sc;
CREATE SEQUENCE sc.sq;
CREATE FUNCTION f() RETURNS INT LANGUAGE SQL AS $$ SELECT last_value FROM sc.sq $$;

query I
SELECT f()
----
0

statement ok
ALTER SEQUENCE sc.sq RENAME TO sq_new;

statement error pq: relation "tdb_seq_select.sc.sq" does not exist
SELECT f()

statement ok
ALTER SEQUENCE sc.sq_new RENAME TO sq;
SELECT f();

statement ok
ALTER SCHEMA sc RENAME TO sc_new;

statement error pq: unknown schema "sc"
SELECT f()

statement ok
ALTER SCHEMA sc_new RENAME TO sc;
SELECT f()

statement ok
ALTER DATABASE tdb_seq_select RENAME TO tdb_seq_select_new;
SET DATABASE = tdb_seq_select_new;

statement error pq: database "tdb_seq_select" does not exist
SELECT f()

statement ok
ALTER DATABASE tdb_seq_select_new RENAME TO tdb_seq_select;
SET DATABASE = tdb_seq_select;
SELECT f()

statement ok
SET DATABASE = test;

subtest event_logging

statement ok
CREATE USER u_test_event;
CREATE SCHEMA sc_test_event;
DELETE FROM system.eventlog;

statement ok
CREATE FUNCTION f_test_log() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

query TTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'create_function'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'Statement' FROM tmp;
----
create_function  203  "test.public.f_test_log"  "CREATE FUNCTION test.public.f_test_log()\n\tRETURNS INT8\n\tLANGUAGE SQL\n\tAS $$SELECT 1;$$"

statement ok
CREATE OR REPLACE FUNCTION f_test_log() RETURNS INT LANGUAGE SQL AS $$ SELECT 2 $$;

query TTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'create_function'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'Statement' FROM tmp;
----
create_function  203  "test.public.f_test_log"  "CREATE FUNCTION test.public.f_test_log()\n\tRETURNS INT8\n\tLANGUAGE SQL\n\tAS $$SELECT 1;$$"
create_function  203  "test.public.f_test_log"  "CREATE OR REPLACE FUNCTION test.public.f_test_log()\n\tRETURNS INT8\n\tLANGUAGE SQL\n\tAS $$SELECT 2;$$"

statement ok
ALTER FUNCTION f_test_log RENAME TO f_test_log_new;

query TTTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'rename_function'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'NewFunctionName', info_json->'Statement' FROM tmp;
----
rename_function  203  "test.public.f_test_log"  "test.public.f_test_log_new"  "ALTER FUNCTION \"\".\"\".f_test_log RENAME TO f_test_log_new"

statement ok
ALTER FUNCTION f_test_log_new RENAME TO f_test_log;

statement ok
ALTER FUNCTION f_test_log OWNER TO u_test_event;

query TTTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'alter_function_owner'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'Owner', info_json->'Statement' FROM tmp;
----
alter_function_owner  203  "test.public.f_test_log"  "u_test_event"  "ALTER FUNCTION \"\".\"\".f_test_log OWNER TO u_test_event"

statement ok
ALTER FUNCTION f_test_log SET SCHEMA sc_test_event;

query TTTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'set_schema'
)
SELECT etype, info_json->'DescriptorID', info_json->'DescriptorName', info_json->'NewDescriptorName', info_json->'Statement' FROM tmp;
----
set_schema  203  "test.public.f_test_log"  "test.sc_test_event.f_test_log"  "ALTER FUNCTION \"\".\"\".f_test_log SET SCHEMA sc_test_event"

statement ok
ALTER FUNCTION sc_test_event.f_test_log SET SCHEMA public;
ALTER FUNCTION f_test_log IMMUTABLE;
DROP FUNCTION f_test_log;

query TTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'alter_function_options'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'Statement' FROM tmp;
----
alter_function_options  203  "test.public.f_test_log"  "ALTER FUNCTION \"\".\"\".f_test_log IMMUTABLE"

query TTTT retry
WITH tmp AS (
  SELECT "eventType" AS etype, info::JSONB AS info_json
  FROM system.eventlog
  WHERE "eventType" = 'drop_function'
)
SELECT etype, info_json->'DescriptorID', info_json->'FunctionName', info_json->'Statement' FROM tmp;
----
drop_function  203  "test.public.f_test_log"  "DROP FUNCTION \"\".\"\".f_test_log"

subtest show_grants

statement ok
CREATE SCHEMA sc_test_show_grants;
SET search_path = sc_test_show_grants;
CREATE FUNCTION f_test_show_grants(INT) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE FUNCTION f_test_show_grants(INT, string, OID) RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;
CREATE USER u_test_show_grants;
GRANT EXECUTE ON FUNCTION f_test_show_grants(INT), f_test_show_grants(INT, string, OID) TO u_test_show_grants;

statement error pq: function name "f_test_show_grants" is not unique
SHOW GRANTS ON FUNCTION f_test_show_grants;

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION f_test_show_grants(INT), f_test_show_grants(INT, string, OID);
----
database_name  schema_name          function_id  function_signature                   grantee             privilege_type  is_grantable
test           sc_test_show_grants  100205       f_test_show_grants(int8)             root                EXECUTE         true
test           sc_test_show_grants  100205       f_test_show_grants(int8)             u_test_show_grants  EXECUTE         false
test           sc_test_show_grants  100206       f_test_show_grants(int8, text, oid)  root                EXECUTE         true
test           sc_test_show_grants  100206       f_test_show_grants(int8, text, oid)  u_test_show_grants  EXECUTE         false

statement error pq: function f_test_show_grants\(string\) does not exist: function undefined
SHOW GRANTS ON FUNCTION f_test_show_grants(string);

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION f_test_show_grants(INT)
----
database_name  schema_name          function_id  function_signature        grantee             privilege_type  is_grantable
test           sc_test_show_grants  100205       f_test_show_grants(int8)  root                EXECUTE         true
test           sc_test_show_grants  100205       f_test_show_grants(int8)  u_test_show_grants  EXECUTE         false

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION f_test_show_grants(INT, string, OID);
----
database_name  schema_name          function_id  function_signature                   grantee             privilege_type  is_grantable
test           sc_test_show_grants  100206       f_test_show_grants(int8, text, oid)  root                EXECUTE         true
test           sc_test_show_grants  100206       f_test_show_grants(int8, text, oid)  u_test_show_grants  EXECUTE         false

statement error pq: unknown function: f_not_existing\(\): function undefined
SHOW GRANTS ON FUNCTION f_not_existing;

query TTTTTTB colnames
SHOW GRANTS ON FUNCTION f_test_show_grants(INT), f_test_show_grants(INT, string, OID) FOR u_test_show_grants;
----
database_name  schema_name          function_id  function_signature                   grantee             privilege_type  is_grantable
test           sc_test_show_grants  100205       f_test_show_grants(int8)             u_test_show_grants  EXECUTE         false
test           sc_test_show_grants  100206       f_test_show_grants(int8, text, oid)  u_test_show_grants  EXECUTE         false

query TTTTTB colnames
SHOW GRANTS FOR u_test_show_grants;
----
database_name  schema_name          relation_name                        grantee             privilege_type  is_grantable
test           sc_test_show_grants  f_test_show_grants(int8)             u_test_show_grants  EXECUTE         false
test           sc_test_show_grants  f_test_show_grants(int8, text, oid)  u_test_show_grants  EXECUTE         false

statement ok
SET search_path = public;

subtest udf_create_privilege

statement ok
CREATE SCHEMA sc_test_priv;

user testuser

statement error pq: user testuser does not have CREATE privilege on schema sc_test_priv
CREATE FUNCTION sc_test_priv.f() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

user root

statement ok
GRANT CREATE ON SCHEMA sc_test_priv TO testuser

user testuser

statement ok
CREATE FUNCTION sc_test_priv.f() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

user root

subtest execution

statement ok
INSERT INTO ab VALUES (1, 1), (2, 2), (3, 3), (4, 1), (5, 1)

statement ok
CREATE FUNCTION one() RETURNS INT LANGUAGE SQL AS 'SELECT 2-1';

query I
SELECT one()
----
1

query I colnames
SELECT * FROM one()
----
one
1

query III colnames
SELECT *, one() FROM ab WHERE a = one()
----
a  b  one
1  1  1

query III colnames
SELECT *, one() FROM ab WHERE b = one()
----
a  b  one
1  1  1
4  1  1
5  1  1

query II colnames
SELECT * FROM ab WHERE b = one() + 1
----
a  b
2  2

statement ok
CREATE FUNCTION max_in_values() RETURNS INT LANGUAGE SQL AS $$
  SELECT i FROM (VALUES (1, 0), (2, 0), (3, 0)) AS v(i, j) ORDER BY i DESC
$$

query I
SELECT max_in_values()
----
3

statement ok
CREATE FUNCTION fetch_one_then_two() RETURNS INT LANGUAGE SQL AS $$
SELECT b FROM ab WHERE a = 1;
SELECT b FROM ab WHERE a = 2;
$$

query II
SELECT i, fetch_one_then_two()
FROM (VALUES (1), (2), (3)) AS v(i)
WHERE i = fetch_one_then_two()
----
2  2

query I colnames
SELECT * FROM fetch_one_then_two()
----
fetch_one_then_two
2

statement ok
CREATE TABLE empty (e INT);
CREATE FUNCTION empty_result() RETURNS INT LANGUAGE SQL AS $$
SELECT e FROM empty
$$

query I
SELECT empty_result()
----
NULL

statement ok
CREATE FUNCTION int_identity(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT i';

query I
SELECT int_identity(1)
----
1

query I
SELECT int_identity(10 + int_identity(1))
----
11

query II
SELECT a+b, int_identity(a+b) FROM ab WHERE a = int_identity(a) AND b = int_identity(b)
----
2  2
4  4
6  6
5  5
6  6

# Define some custom arithmetic functions that we can write interesting tests
# with that use builtin operators as oracles.
statement ok
CREATE FUNCTION add(x INT, y INT) RETURNS INT LANGUAGE SQL AS 'SELECT x+y';

statement ok
CREATE FUNCTION sub(x INT, y INT) RETURNS INT LANGUAGE SQL AS 'SELECT x-y';

statement ok
CREATE FUNCTION mult(x INT, y INT) RETURNS INT LANGUAGE SQL AS 'SELECT x*y';

query II
SELECT a + a + a + b + b + b, add(a, add(a, add(a, add(b, add(b, b))))) FROM ab
----
6   6
12  12
18  18
15  15
18  18

query II
SELECT (a * (a + b)) - b, sub(mult(a, add(a, b)), b) FROM ab
----
1   1
6   6
15  15
19  19
29  29

query II
SELECT a * (3 + b - a) + a * b * a, add(mult(a, add(3, sub(b, a))), mult(a, mult(b, a))) FROM ab
----
4   4
14  14
36  36
16  16
20  20

statement ok
CREATE FUNCTION fetch_b(arg_a INT) RETURNS INT LANGUAGE SQL AS $$
SELECT b FROM ab WHERE a = arg_a
$$

query II
SELECT b, fetch_b(a) FROM ab
----
1  1
2  2
3  3
1  1
1  1

query II
SELECT b + (a * 7) - (a * b), add(fetch_b(a), sub(mult(a, 7), mult(a, fetch_b(a)))) FROM ab
----
7   7
12  12
15  15
25  25
31  31

query I
SELECT fetch_b(99999999)
----
NULL

statement ok
CREATE FUNCTION one_nth(n INT) RETURNS INT LANGUAGE SQL AS 'SELECT 1/n'

statement error pgcode 22012 division by zero
SELECT one_nth(0)

statement error pgcode 22012 division by zero
SELECT int_identity((1/0)::INT)

# Test that tracing spans are created for each UDF invocation and for each
# statement in the UDF body.
statement ok
CREATE TABLE trace_tab (
  a INT PRIMARY KEY
);
INSERT INTO trace_tab VALUES (1), (2), (3);
CREATE FUNCTION trace_fn(i INT) RETURNS INT LANGUAGE SQL AS $$
  SELECT 'no-op';
  SELECT i;
$$

statement ok
SET tracing = on

statement ok
SELECT trace_fn(a) FROM trace_tab

statement ok
SET tracing = off

query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message ~ 'udf'
----
=== SPAN START: udf-stmt-trace_fn-0 ===
=== SPAN START: udf-stmt-trace_fn-1 ===
=== SPAN START: udf-stmt-trace_fn-0 ===
=== SPAN START: udf-stmt-trace_fn-1 ===
=== SPAN START: udf-stmt-trace_fn-0 ===
=== SPAN START: udf-stmt-trace_fn-1 ===


subtest args

# TODO(mgartner): Technically $3 is a parameter, and the error message should be
# more similar to Postgres's "there is no parameter $3".
statement error no value provided for placeholder: \$3
CREATE FUNCTION err(x INT, y INT) RETURNS INT LANGUAGE SQL AS 'SELECT x + y + $1 + $2 + $3'

statement error no value provided for placeholder: \$3
CREATE FUNCTION err(INT, INT) RETURNS INT LANGUAGE SQL AS 'SELECT $1 + $2 + $3'

statement error placeholder index must be between 1 and 65536
CREATE FUNCTION err(INT) RETURNS INT LANGUAGE SQL AS 'SELECT 1 + $0'

statement ok
CREATE FUNCTION add(x INT, y INT, z INT) RETURNS INT LANGUAGE SQL AS $$
  SELECT (x - $1 + x) + ($2 - y + $2) + (z - $3 + z);
$$

statement ok
CREATE FUNCTION mult(x INT, y INT, z INT) RETURNS INT LANGUAGE SQL AS $$
  SELECT $1 * y * (z - $3 + z);
$$

query II rowsort
SELECT a + b + a, add(a, b, a) FROM ab
----
3   3
6   6
9   9
9   9
11  11

query I
SELECT a FROM ab WHERE (a + b + b) != add(a, b, b)
----

query II rowsort
SELECT
  (a + b + a) * (a + 3 + 7) * (b + 11 + 17),
  mult(add(a, b, a), add(a, 3, 7), add(b, 11, 17))
FROM ab
----
957   957
2160  2160
3627  3627
3654  3654
4785  4785

statement ok
PREPARE do_math(INT, INT, INT, INT) AS
SELECT
  (a + b + a) * (a + $1 + $2) * (b + $3 + $4),
  mult(add(a, b, a), add(a, $1, $2), add(b, $3, $4))
FROM ab

query II rowsort
EXECUTE do_math(3, 7, 11, 17)
----
957   957
2160  2160
3627  3627
3654  3654
4785  4785

statement error pgcode 54023 functions cannot have more than 100 arguments
CREATE FUNCTION err(
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT
) RETURNS INT LANGUAGE SQL AS 'SELECT $1';

# Up to 100 arguments are allowed.
statement ok
CREATE FUNCTION add(
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT,
  INT, INT, INT, INT, INT, INT, INT, INT, INT, INT
) RETURNS INT LANGUAGE SQL AS $$
  SELECT $1 + $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9 + $10 +
    $11 + $12 + $13 + $14 + $15 + $16 + $17 + $18 + $19 + $20 +
    $21 + $22 + $23 + $24 + $25 + $26 + $27 + $28 + $29 + $30 +
    $31 + $32 + $33 + $34 + $35 + $36 + $37 + $38 + $39 + $40 +
    $41 + $42 + $43 + $44 + $45 + $46 + $47 + $48 + $49 + $50 +
    $51 + $52 + $53 + $54 + $55 + $56 + $57 + $58 + $59 + $60 +
    $61 + $62 + $63 + $64 + $65 + $66 + $67 + $68 + $69 + $70 +
    $71 + $72 + $73 + $74 + $75 + $76 + $77 + $78 + $79 + $80 +
    $81 + $82 + $83 + $84 + $85 + $86 + $87 + $88 + $89 + $90 +
    $91 + $92 + $93 + $94 + $95 + $96 + $97 + $98 + $99 + $100;
$$;

query TI
SELECT sum(i),
  add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
  51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
  71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
  81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
  91, 92, 93, 94, 95, 96, 97, 98, 99, 100)
FROM generate_series(1, 100) AS g(i)
----
5050  5050


subtest volatility

statement ok
CREATE TABLE kv (k INT PRIMARY KEY, v INT);
INSERT INTO kv VALUES (1, 1), (2, 2), (3, 3);
CREATE FUNCTION get_l(i INT) RETURNS INT IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$
SELECT v FROM kv WHERE k = i;
$$;
CREATE FUNCTION get_i(i INT) RETURNS INT IMMUTABLE LANGUAGE SQL AS $$
SELECT v FROM kv WHERE k = i;
$$;
CREATE FUNCTION get_s(i INT) RETURNS INT STABLE LANGUAGE SQL AS $$
SELECT v FROM kv WHERE k = i;
$$;
CREATE FUNCTION get_v(i INT) RETURNS INT VOLATILE LANGUAGE SQL AS $$
SELECT v FROM kv WHERE k = i;
$$;
CREATE FUNCTION int_identity_v(i INT) RETURNS INT VOLATILE LANGUAGE SQL AS $$
SELECT i;
$$;

query T
SELECT pg_get_functiondef('get_l'::regproc::oid)
----
CREATE FUNCTION public.get_l(IN i INT8)
    RETURNS INT8
    IMMUTABLE
    LEAKPROOF
    CALLED ON NULL INPUT
    LANGUAGE SQL
    AS $$
    SELECT v FROM test.public.kv WHERE k = i;
$$

query T
SELECT pg_get_functiondef(NULL)
----
NULL

query T
SELECT pg_get_functiondef(123456)
----
NULL

# Postgres behaves differently for builtin functions, but we don't yet support
# the syntax for defining non-SQL functions.
query T
SELECT pg_get_functiondef('soundex'::regproc::oid)
----
soundex

# Only the volatile functions should see the changes made by the UPDATE in the
# CTE.
query IIIIIIII colnames
WITH u AS (
  UPDATE kv SET v = v + 10 RETURNING k
)
SELECT
get_l(k) l1, get_l(int_identity_v(k)) l2,
get_i(k) i1, get_i(int_identity_v(k)) i2,
get_s(k) s1, get_s(int_identity_v(k)) s2,
get_v(k) v1, get_v(int_identity_v(k)) v2
FROM u;
----
l1  l2  i1  i2  s1  s2  v1  v2
1   1   1   1   1   1   11  11
2   2   2   2   2   2   12  12
3   3   3   3   3   3   13  13


subtest implicit_record_types

statement ok
CREATE TABLE imp(k INT PRIMARY KEY, a INT, b TEXT);
INSERT INTO imp VALUES (1, 2, 'a');

statement ok
CREATE FUNCTION imp_const_tup() RETURNS imp LANGUAGE SQL AS $$
  SELECT (11, 22, 'b')
$$

query TBT
SELECT imp_const_tup(), (11,22,'b')::imp = imp_const_tup(), pg_typeof(imp_const_tup())
----
(11,22,b)  true  imp

statement ok
CREATE FUNCTION imp_const_cast() RETURNS imp LANGUAGE SQL AS $$
  SELECT (11, 22, 'b')::imp
$$

query TBT
SELECT imp_const_cast(), (11,22,'b')::imp = imp_const_cast(), pg_typeof(imp_const_cast())
----
(11,22,b)  true  imp

statement ok
CREATE FUNCTION imp_const() RETURNS imp LANGUAGE SQL AS $$
  SELECT 11 AS k, 22 AS a, 'b' AS b
$$

query TBT
SELECT imp_const(), (11,22,'b')::imp = imp_const(), pg_typeof(imp_const())
----
(11,22,b)  true  imp

statement ok
CREATE FUNCTION imp_const_unnamed() RETURNS imp LANGUAGE SQL AS $$
  SELECT 11, 22, 'b'
$$

query TBT
SELECT imp_const_unnamed(), (11,22,'b')::imp = imp_const_unnamed(), pg_typeof(imp_const_unnamed())
----
(11,22,b)  true  imp

statement ok
CREATE FUNCTION imp_tup() RETURNS imp LANGUAGE SQL AS $$
  SELECT (k, a, b) FROM imp
$$

# TODO(mgartner): pg_typeof(imp_tup()) is omitted because we get different
# results for different configurations, due to #58252.
query TB
SELECT imp_tup(), (1,2,'a')::imp = imp_tup()
----
(1,2,a)  true

statement ok
CREATE FUNCTION imp() RETURNS imp LANGUAGE SQL AS $$
  SELECT k, a, b FROM imp
$$

query TBT
SELECT imp(), (1,2,'a')::imp = imp(), pg_typeof(imp())
----
(1,2,a)  true  imp

# TODO(#90080): Allow star expressions in UDFs.
# statement ok
# CREATE FUNCTION imp_star() RETURNS imp LANGUAGE SQL AS $$
#   SELECT * FROM imp
# $$
#
# query TBT
# SELECT imp_star(), (1,2,'a')::imp = imp_star(), pg_typeof(imp_star())
# ----
# (1,2,a)  true  imp

statement ok
INSERT INTO imp VALUES (100, 200, 'z')

statement ok
CREATE FUNCTION imp_tup_ordered() RETURNS imp LANGUAGE SQL AS $$
  SELECT (k, a, b) FROM imp ORDER BY b DESC
$$

# TODO(mgartner): pg_typeof(imp_tup_ordered()) is omitted because we get
# different results for different configurations, due to #58252.
query TB
SELECT imp_tup_ordered(), (100,200,'z')::imp = imp_tup_ordered()
----
(100,200,z)  true

statement ok
CREATE FUNCTION imp_ordered() RETURNS imp LANGUAGE SQL AS $$
  SELECT k, a, b FROM imp ORDER BY b DESC
$$

query TBT
SELECT imp_ordered(), (100,200,'z')::imp = imp_ordered(), pg_typeof(imp_ordered())
----
(100,200,z)  true  imp

statement ok
CREATE FUNCTION imp_identity(i imp) RETURNS imp LANGUAGE SQL AS $$
  SELECT i
$$

query TT
SELECT imp_identity((1,2,'a')), imp_identity((1,2,'a')::imp)
----
(1,2,a)  (1,2,a)

statement ok
CREATE FUNCTION imp_a(i imp) RETURNS INT LANGUAGE SQL AS $$
  SELECT (i).a
$$

query II
SELECT imp_a((1,2,'a')), imp_a((1,2,'a')::imp)
----
2  2

statement ok
CREATE FUNCTION imp_cast() RETURNS imp LANGUAGE SQL AS $$
  SELECT (1, 2, 3)
$$

query TBT
SELECT imp_cast(), (1,2,'3') = imp_cast(), pg_typeof(imp_cast())
----
(1,2,3)  true  imp

statement error return type mismatch in function declared to return imp
CREATE FUNCTION err() RETURNS imp LANGUAGE SQL AS $$
  SELECT (1, 2)
$$

# TODO(mgartner): The error message should say "imp" instead of "record".
statement error pgcode 42P13 return type mismatch in function declared to return record
CREATE FUNCTION err() RETURNS imp LANGUAGE SQL AS $$
  SELECT k, a FROM imp
$$

# TODO(mgartner): The error message should say "imp" instead of "record".
statement error pgcode 42P13 return type mismatch in function declared to return record
CREATE FUNCTION err() RETURNS imp LANGUAGE SQL AS $$
  SELECT k, a, b::INT FROM imp
$$

statement error pgcode 42P13 return type mismatch in function declared to return int
CREATE FUNCTION err(i imp) RETURNS INT LANGUAGE SQL AS $$
  SELECT i
$$


subtest return_type_assignment_casts

# Do not allow functions with return type mismatches that cannot be cast in an
# implicit or assignment context.
statement error pgcode 42P13 return type mismatch in function declared to return bool
CREATE FUNCTION err(i INT) RETURNS BOOL LANGUAGE SQL AS 'SELECT i'

statement ok
CREATE FUNCTION itof(i INT) RETURNS FLOAT8 LANGUAGE SQL AS 'SELECT i'

query FT
SELECT itof(123), pg_typeof(itof(123))
----
123  double precision

statement ok
CREATE FUNCTION stoc(s STRING) RETURNS CHAR LANGUAGE SQL AS 'SELECT s'

query FT
SELECT stoc('a'), pg_typeof(stoc('a'))
----
a  text

statement error pgcode 22001 value too long for type CHAR
SELECT stoc('abc')


subtest ddl

# DDL is not currently supported in UDF bodies.
statement error pgcode 0A000 unimplemented: CREATE TABLE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'CREATE TABLE t (a INT)'

statement error pgcode 0A000 unimplemented: ALTER TABLE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'ALTER TABLE t ADD COLUMN b BOOL'

statement error pgcode 0A000 unimplemented: DROP TABLE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'DROP TABLE t'


subtest mutation

# Mutations are not currently supported in UDF bodies.
statement error pgcode 0A000 unimplemented: INSERT usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'INSERT INTO t VALUES (1)'

statement error pgcode 0A000 unimplemented: INSERT usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'UPSERT INTO t VALUES (1)'

statement error pgcode 0A000 unimplemented: UPDATE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'UPDATE t SET a = 1'

statement error pgcode 0A000 unimplemented: DELETE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'DELETE FROM t WHERE a = 1'


subtest prepared_statement

# Prepared statements are not currently supported in UDF bodies.
statement error pgcode 0A000 unimplemented: PREPARE usage inside a function definition
CREATE FUNCTION err() RETURNS VOID LANGUAGE SQL AS 'PREPARE p AS SELECT * FROM t'


subtest cte

# CTEs are not currently supported in UDF bodies.
statement error pgcode 0A000 unimplemented: CTE usage inside a function definition
CREATE FUNCTION err() RETURNS INT LANGUAGE SQL AS 'WITH s AS (SELECT a FROM t) SELECT a FROM s'


subtest recursion

# Recursive UDFs are not currently supported.
statement error pgcode 42883 unknown function: rec()
CREATE FUNCTION rec(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT CASE i WHEN 0 THEN 0 ELSE i + rec(i-1) END'

# References to other UDFs in UDF bodies are not currently supported.
statement ok
CREATE FUNCTION other_udf() RETURNS INT LANGUAGE SQL AS 'SELECT 1'

statement error pgcode 42883 unknown function: other_udf()
CREATE FUNCTION err() RETURNS INT LANGUAGE SQL AS 'SELECT other_udf()'


subtest subqueries

# UDFs with subqueries are not currently supported.
statement error pgcode 0A000 unimplemented: subquery usage inside a function definition
CREATE FUNCTION rec(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT * FROM t WHERE a = (SELECT max(i) FROM s)'

subtest execute_dropped_function

statement ok
CREATE FUNCTION f_test_exec_dropped(a int) RETURNS INT LANGUAGE SQL AS $$ SELECT a $$;

query I
SELECT f_test_exec_dropped(123);
----
123

statement ok
DROP FUNCTION f_test_exec_dropped;

statement error pq: unknown function: f_test_exec_dropped\(\): function undefined
SELECT f_test_exec_dropped(321);


subtest variadic

# Variadic UDFS are not currently supported.
statement error pgcode 0A000 unimplemented: this syntax\nHINT.*\n.*88947
CREATE FUNCTION rec(VARIADIC arr INT[]) RETURNS INT LANGUAGE SQL AS '1'


subtest regression_tests

# Regression test for #93083. UDFs with empty bodies should execute successfully
# and return NULL.
statement ok
CREATE FUNCTION f93083() RETURNS INT LANGUAGE SQL AS '';

query I
SELECT f93083()
----
NULL

# Regression test for #93314
subtest regression_93314

statement ok
CREATE TYPE e_93314 AS ENUM ('a', 'b');
CREATE TABLE t_93314 (i INT, e e_93314);
INSERT INTO t_93314 VALUES (1, 'a');

statement ok
CREATE OR REPLACE FUNCTION f_93314 () RETURNS t_93314 AS
$$
  SELECT i, e
  FROM t_93314
  ORDER BY i
  LIMIT 1;
$$ LANGUAGE SQL;

query T
SELECT f_93314();
----
(1,a)

statement ok
CREATE TABLE t_93314_alias (i INT, e _e_93314);
INSERT INTO t_93314_alias VALUES (1, ARRAY['a', 'b']::_e_93314);

statement ok
CREATE OR REPLACE FUNCTION f_93314_alias () RETURNS t_93314_alias AS
$$
  SELECT i, e
  FROM t_93314_alias
  ORDER BY i
  LIMIT 1;
$$ LANGUAGE SQL;

query T
SELECT f_93314_alias();
----
(1,"{a,b}")

query TTTTTBBBTITTTTT
SELECT oid, proname, pronamespace, proowner, prolang, proleakproof, proisstrict, proretset, provolatile, pronargs, prorettype, proargtypes, proargmodes, proargnames, prosrc
FROM pg_catalog.pg_proc WHERE proname IN ('f_93314', 'f_93314_alias', 'f_93314_comp', 'f_93314_comp_t')
ORDER BY oid;
----
100251  f_93314        105  1546506610  14  false  false  false  v  0  100250  ·  {}  NULL  SELECT i, e FROM test.public.t_93314 ORDER BY i LIMIT 1;
100253  f_93314_alias  105  1546506610  14  false  false  false  v  0  100252  ·  {}  NULL  SELECT i, e FROM test.public.t_93314_alias ORDER BY i LIMIT 1;

onlyif config local
query T
EXPLAIN CREATE FUNCTION f() RETURNS INT LANGUAGE SQL AS 'SELECT 1'
----
distribution: local
vectorized: true
·
• create function

subtest regression_97130

statement ok
CREATE FUNCTION f_97130() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

let $pre_search_path
SHOW search_path

statement ok
SET search_path = public,public

statement ok
SELECT f_97130();

statement ok
SET search_path = $pre_search_path

# Regression test for #93082 - invalidate a cached query with a UDF if the UDF
# has been dropped.
subtest regression_93082

statement ok
CREATE FUNCTION fn(a INT) RETURNS INT LANGUAGE SQL AS 'SELECT a';

query I
SELECT fn(1);
----
1

statement ok
DROP FUNCTION fn;

statement error pq: unknown function: fn\(\): function undefined
SELECT fn(1);

# Regression test for #93321 - invalidate a cached query with an unqualified UDF
# reference after the database is switched.
subtest regression_93321

statement ok
CREATE FUNCTION fn(a INT) RETURNS INT LANGUAGE SQL AS 'SELECT a';

query I
SELECT fn(1);
----
1

statement ok
CREATE DATABASE d;
USE d;

statement error pq: unknown function: fn\(\): function undefined
SELECT fn(1);

statement ok
USE test;
DROP DATABASE d CASCADE;
DROP FUNCTION fn;
