# LogicTest: local

statement ok
CREATE TABLE a (a INT, b INT, c INT4, PRIMARY KEY (a, b))

statement ok
CREATE TABLE c (a INT, b INT, c INT, d INT, PRIMARY KEY (a, c), INDEX sec (b))

statement ok
CREATE TABLE d (a INT, b INT, PRIMARY KEY (b, a))

statement ok
INSERT INTO a SELECT g//2, g, g FROM generate_series(0,2000) g(g)

statement ok
INSERT INTO c VALUES (1, 1, 1, 0), (2, 1, 2, 0)

statement ok
ALTER TABLE c INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1,
    "distinct_count": 1
  }
]'

statement ok
INSERT INTO d VALUES (1, 1), (1, 2)

# Test that vectorized stats are collected correctly.
statement ok
SET vectorize = on

statement ok
SET distsql = on

query T
EXPLAIN ANALYZE (DISTSQL) SELECT a FROM a
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
rows read from KV: 2,001 (16 KiB)
maximum memory usage: <hidden>
network usage: <hidden>
regions: <hidden>
·
• scan
  nodes: <hidden>
  regions: <hidden>
  actual row count: 2,001
  KV time: 0µs
  KV contention time: 0µs
  KV rows read: 2,001
  KV bytes read: 16 KiB
  MVCC step count: 0
  MVCC seek count: 0
  missing stats
  table: a@primary
  spans: FULL SCAN
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJyMkcFq40AQRO_7FU2dZ1lpD3uYk1njgHEcB9v4EnQYS40jIs8o0y0SY_RZ-YF8WbDGDgkhkGO9mqmC6iPksYHFanI9Ga_J0dVyMScHAx8qvnF7Ftg75CgM2hhKFgnxhI7Dg2n1DJsZ1L7t9IQLgzJEhj1Ca20YFmu3bXjJruL4J4NBxerqZoh1ozbWexcPMFi1zoul3zBYdGpplMNgtiGt92wpe32RpMvglb3WwX-xYngSiuwqS39Nlp0DtgflC87_0az-D4P5ZjwmUW6pDJ1XS9k7ZH74CLdOy3sWCp223ZkNRReQqoreIJHzDKJux7B5b34-1ZKlDV7400rfJWd9YcDVjtM5JHSx5NsYyqEmycXwbwAViyY3T2Lqk9UX_a-3AAAA__8TM6XW

query T
EXPLAIN ANALYZE (DISTSQL) SELECT c.a FROM c JOIN d ON d.b = c.b
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
rows read from KV: 3 (24 B)
maximum memory usage: <hidden>
network usage: <hidden>
regions: <hidden>
·
• lookup join
│ nodes: <hidden>
│ regions: <hidden>
│ actual row count: 2
│ KV time: 0µs
│ KV contention time: 0µs
│ KV rows read: 1
│ KV bytes read: 8 B
│ MVCC step count: 0
│ MVCC seek count: 0
│ table: d@primary
│ equality: (b) = (b)
│
└── • scan
      nodes: <hidden>
      regions: <hidden>
      actual row count: 2
      KV time: 0µs
      KV contention time: 0µs
      KV rows read: 2
      KV bytes read: 16 B
      MVCC step count: 0
      MVCC seek count: 0
      estimated row count: 1 (100% of the table; stats collected <hidden> ago)
      table: c@sec
      spans: FULL SCAN
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJykktFu0zAUhu95iqP_2pSkFwhZQqqohtSxNaibdoNy4dhHIyz1CbYjNlV9LF6AJ0ONM7RRgRi7_L-T3yf-5B3i1w4aFydnJ8tLsjND7zfVOVk6rVZrclStyc0aekt21kDBi-O12XKE_oQStUIfxHKMEg5oN36wcrfQhULr-yEdcK1gJTD0DqlNHUPj0jQdb9g4Dq8KKDhOpu3GY-0isoXCRW981PQSCtWQNC1KtZhD4cMVpXbLmoof32POVnxin1rxR6Mg3yIFNk7TVG7uEt-j8jW9g8L51XJJMXFPVgafNBW_IPPNQ9iYZD9zJBlSP0xsXHEP5qj3CjlNd4_JXDN0uVf_7udUWj_pKR_rcYs-tFsT7qBwJnIz9PRFWk_iNY1-JlmYFowG8uVzjsl03ZGn_1NaHit980SjfMt2ON7zDNHzp4jecOzFR34k-U8nF_tagd0158ceZQiWPwax45ocq7E3Ascx5WmZw8rn0eEHH5bLv5bnv5Xr_YufAQAA__8S5TJm

query T
EXPLAIN (OPT, VERBOSE) SELECT c.a FROM c INNER MERGE JOIN d ON c.a = d.b
----
project
 ├── columns: a:1
 ├── stats: [rows=10]
 ├── cost: 1122.17
 ├── prune: (1)
 └── inner-join (merge)
      ├── columns: c.a:1 d.b:8
      ├── flags: force merge join
      ├── left ordering: +1
      ├── right ordering: +8
      ├── stats: [rows=10, distinct(1)=1, null(1)=0, distinct(8)=1, null(8)=0]
      ├── cost: 1122.06
      ├── fd: (1)==(8), (8)==(1)
      ├── sort
      │    ├── columns: c.a:1
      │    ├── stats: [rows=1, distinct(1)=1, null(1)=0]
      │    ├── cost: 26.73
      │    ├── ordering: +1
      │    ├── prune: (1)
      │    ├── interesting orderings: (+1)
      │    ├── unfiltered-cols: (1-6)
      │    └── scan c@sec
      │         ├── columns: c.a:1
      │         ├── stats: [rows=1, distinct(1)=1, null(1)=0]
      │         ├── cost: 26.69
      │         ├── prune: (1)
      │         ├── interesting orderings: (+1)
      │         └── unfiltered-cols: (1-6)
      ├── scan d
      │    ├── columns: d.b:8
      │    ├── stats: [rows=1000, distinct(8)=100, null(8)=0]
      │    ├── cost: 1085.21
      │    ├── ordering: +8
      │    ├── prune: (8)
      │    ├── interesting orderings: (+8)
      │    └── unfiltered-cols: (7-10)
      └── filters (true)

query T
EXPLAIN ANALYZE (DISTSQL) SELECT c.a FROM c INNER MERGE JOIN d ON c.a = d.b
----
planning time: 10µs
execution time: 100µs
distribution: <hidden>
vectorized: <hidden>
rows read from KV: 4 (32 B)
maximum memory usage: <hidden>
network usage: <hidden>
regions: <hidden>
·
• merge join
│ nodes: <hidden>
│ regions: <hidden>
│ actual row count: 2
│ equality: (a) = (b)
│
├── • sort
│   │ nodes: <hidden>
│   │ regions: <hidden>
│   │ actual row count: 2
│   │ estimated row count: 1
│   │ order: +a
│   │
│   └── • scan
│         nodes: <hidden>
│         regions: <hidden>
│         actual row count: 2
│         KV time: 0µs
│         KV contention time: 0µs
│         KV rows read: 2
│         KV bytes read: 16 B
│         MVCC step count: 0
│         MVCC seek count: 0
│         estimated row count: 1 (100% of the table; stats collected <hidden> ago)
│         table: c@sec
│         spans: FULL SCAN
│
└── • scan
      nodes: <hidden>
      regions: <hidden>
      actual row count: 2
      KV time: 0µs
      KV contention time: 0µs
      KV rows read: 2
      KV bytes read: 16 B
      MVCC step count: 0
      MVCC seek count: 0
      missing stats
      table: d@primary
      spans: FULL SCAN
·
Diagram: https://cockroachdb.github.io/distsqlplan/decode.html#eJzUU9Fu0zAUfecrru4TaGaN04kHS5MqqoI6aIvaaS8oD659yaIldmY7olXVz-IH-DKUZIWmK4OKF_aWe849ts-5Nxv09zkKXIw-jobXoM4lvJvPJqBgPJ2O5jAZzd-P4Go2noKG2bRpuAR9vkSGxmqayoI8is_IMWFYOqvIe-tqaNM0jPUKRcQwM2UVajhhqKwjFBsMWcgJBV7LZU5zkppcL0KGmoLM8uZYNfCkkOGilMYLeI0MZ1UQMODI8MMNhKwgAdH3b76tlTWBTMiseUQ5-9WDI6kFxC2yXAfaQfwNvEWGk5vhEHygEpStTBAQ_QSJ7vbBpQzqljzYKpTVA9ZcsQNiTLYM2-rBuA8yJRR8y_4-nIV1gVyPd3MZ8DNkSCtS1WOzhVxBQYV1a5B5bpUMpAVEjcGa8_c5BCpK0Jm_g8rLlHb0P7iKT3G1P_K4a00PSpcV0q2PjT1-xmPv_zagX7lUxjpNjnQnk6RW_qnlSMoTcild2cyQ6_W7Kef0Jbwc8LNXly5Lb9vPzs_1X-3WxSm7NSdfWuPpMMKjJ0d1bqRTaufgbeUUfXJWNde05azRNYAmH1qWt8XYtFT9wH0xf1Lc74j5oTg-QRwfivtPii8Onp1sX_wIAAD__w2R8m8=

statement ok
RESET vectorize; RESET distsql

statement ok
SET tracing=off

# Making sure that colBatchScan operator can parallelize scans.
# This test is similar to that in testplannerlogic/select
statement ok
CREATE TABLE tpar (
    a INT PRIMARY KEY, item STRING, price FLOAT, FAMILY (a, item, price),
    UNIQUE INDEX item (item), UNIQUE INDEX p (price)
)

statement ok
ALTER TABLE tpar SPLIT AT VALUES(5)

# Run a select to prime the range cache to simplify the trace below.
statement ok
SELECT * FROM tpar

# Make sure that the scan actually gets parallelized.
statement ok
SET tracing = on; SELECT * FROM tpar WHERE a = 0 OR a = 10; SET tracing = off

# The span "sending partial batch" means that the scan was parallelized.
# Note that table ID here is hardcoded, so if a new table is created before
# tpar, this query will need an adjustment.
query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message LIKE 'querying next range at %'
----
querying next range at /Table/56/1/0/0
querying next range at /Table/56/1/10/0

# Regression test for #46123 (rowexec.TableReader not implementing
# execinfra.OpNode interface).
statement ok
CREATE TABLE t46123(c0 INT)

query T
EXPLAIN (VEC) SELECT stddev(0) FROM t46123 WHERE ('' COLLATE en)::BOOL
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colexecbase.constInt64Op
      └ *rowexec.filtererProcessor
        └ *colfetcher.ColBatchScan

# Regression test for #46122.
statement ok
CREATE TABLE t46122_0(c0 STRING); CREATE TABLE t46122_1(c0 STRING)

query T
EXPLAIN (VEC) SELECT t46122_0.c0 FROM t46122_0, t46122_1
----
│
└ Node 1
  └ *colexecjoin.crossJoiner
    ├ *colfetcher.ColBatchScan
    └ *colfetcher.ColBatchScan

statement ok
CREATE TABLE t46404_0(c0 INT); CREATE TABLE t46404_1(c0 INT)

query T
EXPLAIN (VEC) SELECT stddev((t46404_1.c0 > ANY (0, 0))::INT) FROM t46404_0, t46404_1 GROUP BY t46404_0.rowid
----
│
└ Node 1
  └ *colexec.hashAggregator
    └ *colexecbase.castBoolInt64Op
      └ *colexecproj.defaultCmpRConstProjOp
        └ *colexecjoin.crossJoiner
          ├ *colfetcher.ColBatchScan
          └ *colfetcher.ColBatchScan

statement ok
CREATE TABLE xyz (
  x INT,
  y INT,
  z TEXT
)

# Check that we fallback gracefully to row-by-row engine on a join type with
# ON expression that we don't support.
query T
EXPLAIN (VEC) SELECT * FROM xyz AS t1 FULL OUTER JOIN xyz AS t2 ON t1.x = t2.x AND t1.x + t2.x = 0
----
│
└ Node 1
  └ *rowexec.hashJoiner
    ├ *colfetcher.ColBatchScan
    └ *colfetcher.ColBatchScan

# Verify that the vectorized engine is used (there is a mismatch between
# argument type width and the result).
query T
EXPLAIN (VEC) SELECT max(c) FROM a
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colfetcher.ColBatchScan

# Verify that binary operations on integers of any width return INT8.
statement ok
CREATE TABLE ints (_int2 INT2, _int4 INT4, _int8 INT8);
INSERT INTO ints VALUES (1, 1, 1), (2, 2, 2)

query T
SELECT pg_typeof(_int2 - _int2) FROM ints LIMIT 1
----
bigint

query T
EXPLAIN (VEC) SELECT _int2 * _int2 FROM ints WHERE _int4 + _int4 = _int8 + 2
----
│
└ Node 1
  └ *colexecproj.projMultInt64Int64Op
    └ *colexecbase.castInt16Int64Op
      └ *colexecbase.castInt16Int64Op
        └ *colexecsel.selEQInt64Int64Op
          └ *colexecproj.projPlusInt64Int64ConstOp
            └ *colexecproj.projPlusInt64Int64Op
              └ *colexecbase.castInt32Int64Op
                └ *colexecbase.castInt32Int64Op
                  └ *colfetcher.ColBatchScan

query I
SELECT _int2 * _int2 FROM ints WHERE _int4 + _int4 = _int8 + 2
----
4

# Check that joinReader core is wrapped into the plan when vectorize is set to
# `experimental_always` - that core is the only exception to disabling of
# wrapping.

query T
EXPLAIN (VEC) SELECT c.a FROM c JOIN d ON d.b = c.b
----
│
└ Node 1
  └ *rowexec.joinReader
    └ *colfetcher.ColBatchScan

statement ok
SET vectorize = experimental_always

statement ok
SELECT c.a FROM c JOIN d ON d.b = c.b

statement ok
RESET vectorize

statement ok
CREATE TABLE bytes_string(_group INT, _bytes BYTES, _string STRING)

query T
EXPLAIN (VEC) SELECT concat_agg(_bytes), concat_agg(_string) FROM bytes_string GROUP BY _group
----
│
└ Node 1
  └ *colexec.hashAggregator
    └ *colfetcher.ColBatchScan

query T
EXPLAIN (VEC) SELECT concat_agg(_bytes), concat_agg(_string) FROM bytes_string
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colfetcher.ColBatchScan

statement ok
CREATE TABLE t63792 (c INT);
INSERT INTO t63792 VALUES (NULL), (1), (2)

# Check that casts of constants are pre-evaluated (which allows us to use
# colexec.isNullProjOp instead of colexecproj.defaultCmpProjOp).
query T
EXPLAIN (VEC) SELECT c = c FROM t63792
----
│
└ Node 1
  └ *colexec.orProjOp
    ├ *colfetcher.ColBatchScan
    ├ *colexec.isNullProjOp
    └ *colexecbase.castOpNullAny
      └ *colexecbase.constNullOp

query IB rowsort
SELECT c, c = c FROM t63792
----
NULL  NULL
1     true
2     true

# Regression test that we can run EXPLAIN (VEC) on a mutation that utilizes the
# vectorized engine for some internal operations (#66568).
statement ok
CREATE TABLE t66568 (c INT PRIMARY KEY);

query T
EXPLAIN (VEC) INSERT INTO t66568 VALUES (1) ON CONFLICT DO NOTHING
----
│
└ Node 1
  └ *sql.planNodeToRowSource
    └ *colexecjoin.crossJoiner
      ├ *sql.planNodeToRowSource
      └ *colfetcher.ColBatchScan
