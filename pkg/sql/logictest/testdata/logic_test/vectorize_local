# LogicTest: local

statement ok
CREATE TABLE a (a INT, b INT, c INT4, PRIMARY KEY (a, b))

statement ok
CREATE TABLE c (a INT, b INT, c INT, d INT, PRIMARY KEY (a, c), INDEX sec (b))

statement ok
CREATE TABLE d (a INT, b INT, PRIMARY KEY (b, a))

statement ok
INSERT INTO a SELECT g//2, g, g FROM generate_series(0,2000) g(g)

statement ok
INSERT INTO c VALUES (1, 1, 1, 0), (2, 1, 2, 0)

statement ok
ALTER TABLE c INJECT STATISTICS '[
  {
    "columns": ["a"],
    "created_at": "2018-01-01 1:00:00.00000+00:00",
    "row_count": 1,
    "distinct_count": 1
  }
]'

statement ok
INSERT INTO d VALUES (1, 1), (1, 2)

# Test that vectorized stats are collected correctly.
statement ok
SET vectorize = on

statement ok
SET distsql = on

statement ok
SET vectorize_row_count_threshold = 0

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT a FROM a]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyMkEFL60AUhffvVwxn9R7Mw8SFi1m1aoTQ2NamiFqymCaXGkhn4swNWEr-uyQTBReCy_ude86dM2f4twYKeZIlN1vRuUbcbVb3Ypc8rbN5uhTz5Tx7fknE39s03-YP2T8xreqwqAtIGFvRUh_JQ-0Qo5BonS3Je-sGdB4X0uodKpKoTdvxgAuJ0jqCOoNrbggKW71vaEO6IncRQaIi1nUzxupZ6-qjdidI5K02Xon_kFh1rMQshsTiUXB9JCUiH6bSGibDtTWTEJtJ4a5tyAtHulLiMoom-_7EXzS-Eov6GhJ7zeUreWE7bodbw7Mm_ycaE4peIoCpm2d9IKi4l7_vvyHfWuPpW_WfkqO-kKDqQOGPve1cSWtny_FMGFejbwQVeQ5qHIbUBKkv-j8fAQAA__96Z6SA

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c JOIN d ON d.b = c.b]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJyckk9v1DAQxe98itGcQDLLeg8cLCHtAouUEpKyu0JAlYNjj0ogawf_kVqt8t1RYoPaQhH0OG_mzfj35BP67z0K3G_L7asDRNfDm139Di62H8_LTVHBptqUnz5v4fHrYn_Yvy-fQB5VC5lGFZzVRQUa6gr0ooUXoBZtgwyN1VTJI3kUF8ixYTg4q8h76ybpNA8U-grFkmFnhhgmuWGorCMUJwxd6AkFHmTb046kJvdsiQw1Bdn181q19qSQ4X6Qxgt4igzrGASsOVuvkOHbDxC6IwlY-lQpawKZ0FmTG9zkTohDTx4cSS0ge9vr8Eviz-ElMmxlUF_Ig41hmC5ND8rWn9IKm5FhqjKSD_KSUPCR_Tv2me1Mpua3qfV6cN1RumtkWFr7LQ7w1XYGrBEwY-cMMB_IbAkrKT7Ivr-TzYOS4n_iZ0hXpOIN87z19-zuC2r1P0HtyA_WeLoV0n2bl2PDkPQlpT_obXSKzp1V85lU1rNvFjT5kLo8FYVJremBN838r-bVHXMzPvoRAAD__-1hG-0=

query T
SELECT url FROM [EXPLAIN ANALYZE SELECT c.a FROM c INNER MERGE JOIN d ON c.a = d.b]
----
https://cockroachdb.github.io/distsqlplan/decode.html#eJzMUs9v0zAUvvNXPL3TJsyWZBIHS5NWIKCMNh1thYApB9d-dBGJHWxHalX1f0dxAixjDA0u3PK-H3a-z2-P7muFHJfpNH25gtZW8Hoxn8F1-uFqOslymOST6cdPKRy9ypar5bvpMQxSeSJ6qYQsz9MFzNLFmxQu51kOCuZ5EJyDOlkXyFAbRbmoySG_xhgLho01kpwztoP2QZCpLfKIYamb1ndwwVAaS8j36EtfEXJciXVFCxKK7GmEDBV5UVbhWHnR2LIWdocMl43QjsMzZDhvPYeLGBm-fQ--rIlD5PpJGu1J-9LogYj1wPi2qciBJaE4JD223vkfUPwcXiDDtfDyhhyY1jfdNd0fDdbvUILFgWE_DZmcFxtCHh_Y3-WOx7nVQ7mT_y938tvcP-O22lhFltQoatE5_yS5p7wZ2Q1dmlKTPU3G5VX02R9dxE-Pz225uek_R0tDW5LtrapCh7XYQk21sTsQVWWk8KQ4RKGbjnPSdg2BKt2XXxX_1N7ZY7ZmQa4x2tHdFu89OeqqI7Wh_imcaa2kK2tkuKYf58EXAEXO92zSD5kOVFjr2-b4Eebkrjl50Hw2MkeH4vDkWwAAAP__tLmLwA==

statement ok
RESET vectorize; RESET distsql; RESET vectorize_row_count_threshold

statement ok
SET tracing=off

# Making sure that colBatchScan operator can parallelize scans.
# This test is similar to that in testplannerlogic/select
statement ok
CREATE TABLE tpar (
    a INT PRIMARY KEY, item STRING, price FLOAT, FAMILY (a, item, price),
    UNIQUE INDEX item (item), UNIQUE INDEX p (price)
)

statement ok
ALTER TABLE tpar SPLIT AT VALUES(5)

# Run a select to prime the range cache to simplify the trace below.
statement ok
SELECT * FROM tpar

# Make sure that the scan actually gets parallelized.
statement ok
SET tracing = on; SELECT * FROM tpar WHERE a = 0 OR a = 10; SET tracing = off

# The span "sending partial batch" means that the scan was parallelized.
# Note that table ID here is hardcoded, so if a new table is created before
# tpar, this query will need an adjustment.
query T
SELECT message FROM [SHOW TRACE FOR SESSION] WHERE message IN
    ('querying next range at /Table/56/1/0',
     'querying next range at /Table/56/1/10',
     '=== SPAN START: kv.DistSender: sending partial batch ==='
    )
----
querying next range at /Table/56/1/0
=== SPAN START: kv.DistSender: sending partial batch ===
querying next range at /Table/56/1/10

# Regression test for #46123 (rowexec.TableReader not implementing
# execinfra.OpNode interface).
statement ok
CREATE TABLE t46123(c0 INT)

query T
EXPLAIN (VEC) SELECT stddev(0) FROM t46123 WHERE ('' COLLATE en)::BOOL
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colexec.distinctChainOps
      └ *rowexec.tableReader

# Regression test for #46122 (checking that we gracefully fallback to row
# execution on cross joins).
statement ok
CREATE TABLE t46122_0(c0 STRING); CREATE TABLE t46122_1(c0 STRING)

query T
EXPLAIN (VEC) SELECT t46122_0.c0 FROM t46122_0, t46122_1
----
│
└ Node 1
  └ *rowexec.hashJoiner
    ├ *colfetcher.ColBatchScan
    └ *colfetcher.ColBatchScan

statement ok
CREATE TABLE t46404_0(c0 INT); CREATE TABLE t46404_1(c0 INT)

query T
EXPLAIN (VEC) SELECT stddev((t46404_1.c0 > ANY (0, 0))::INT) FROM t46404_0, t46404_1 GROUP BY t46404_0.rowid
----
│
└ Node 1
  └ *colexec.hashAggregator
    └ *colexec.castBoolInt64Op
      └ *colexec.defaultCmpRConstProjOp
        └ *colexec.hashJoiner
          ├ *colfetcher.ColBatchScan
          └ *colfetcher.ColBatchScan

statement ok
CREATE TABLE xyz (
  x INT,
  y INT,
  z TEXT
)

# Check that we fallback gracefully to row-by-row engine on a join type with
# ON expression that we don't support.
query T
EXPLAIN (VEC) SELECT * FROM xyz AS t1 FULL OUTER JOIN xyz AS t2 ON t1.x = t2.x AND t1.x + t2.x = 0
----
│
└ Node 1
  └ *rowexec.hashJoiner
    ├ *colfetcher.ColBatchScan
    └ *colfetcher.ColBatchScan

# Verify that the vectorized engine is used (there is a mismatch between
# argument type width and the result).
query T
EXPLAIN (VEC) SELECT max(c) FROM a
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colexec.distinctChainOps
      └ *colfetcher.ColBatchScan

# Verify that binary operations on integers of any width return INT8.
statement ok
CREATE TABLE ints (_int2 INT2, _int4 INT4, _int8 INT8);
INSERT INTO ints VALUES (1, 1, 1), (2, 2, 2)

query T
SELECT pg_typeof(_int2 - _int2) FROM ints LIMIT 1
----
bigint

query T
EXPLAIN (VEC) SELECT _int2 * _int2 FROM ints WHERE _int4 + _int4 = _int8 + 2
----
│
└ Node 1
  └ *colexec.projMultInt64Int64Op
    └ *colexec.castInt16Int64Op
      └ *colexec.castInt16Int64Op
        └ *colexec.selEQInt64Int64Op
          └ *colexec.projPlusInt64Int64ConstOp
            └ *colexec.projPlusInt64Int64Op
              └ *colexec.castInt32Int64Op
                └ *colexec.castInt32Int64Op
                  └ *colfetcher.ColBatchScan

query I
SELECT _int2 * _int2 FROM ints WHERE _int4 + _int4 = _int8 + 2
----
4

# Check that joinReader core is wrapped into the plan when vectorize is set to
# `experimental_always` - that core is the only exception to disabling of
# wrapping.

query T
EXPLAIN (VEC) SELECT c.a FROM c JOIN d ON d.b = c.b
----
│
└ Node 1
  └ *rowexec.joinReader
    └ *colfetcher.ColBatchScan

statement ok
SET vectorize = experimental_always

statement ok
SELECT c.a FROM c JOIN d ON d.b = c.b

statement ok
RESET vectorize

statement ok
CREATE TABLE bytes_string(_group INT, _bytes BYTES, _string STRING)

query T
EXPLAIN (VEC) SELECT concat_agg(_bytes), concat_agg(_string) FROM bytes_string GROUP BY _group
----
│
└ Node 1
  └ *colexec.hashAggregator
    └ *colfetcher.ColBatchScan

query T
EXPLAIN (VEC) SELECT concat_agg(_bytes), concat_agg(_string) FROM bytes_string
----
│
└ Node 1
  └ *colexec.orderedAggregator
    └ *colexec.distinctChainOps
      └ *colfetcher.ColBatchScan
