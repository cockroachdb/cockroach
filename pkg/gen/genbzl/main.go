// Command genbzl is used to generate bazel files which then get imported by
// the gen package's BUILD.bazel to facilitate hoisting these generated files
// back into the source tree.
//
// It's all a bit meta. The flow is that we invoke this binary inside the
// bazelutil/bazel-generate.sh script which writes out some bzl files with
// lists of targets which are then depended on in gen.bzl
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

var (
	outDir = flag.String("out-dir", "", "directory in which to place the generated files")
)

func main() {
	flag.Parse()
	if err := generate(*outDir); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate files: %v\n", err)
		os.Exit(1)
	}
}

var targets = []*target{
	newTarget(
		"protobuf.bzl",
		newQuery("kind(go_proto_library, //pkg/...)"),
		`# Generated by genbzl

PROTOBUF_SRCS = [{{ range . }}
  "{{ . }}",{{end}}
]
`),
}

func newQuery(q string, filters ...func(s string) (shouldKeep bool)) *query {
	return &query{
		query:   q,
		filters: filters,
	}
}

type target struct {
	filename string
	template *template.Template
	query    *query
}

func newTarget(filename string, query *query, tmpl string) *target {
	return &target{
		filename: filename,
		template: template.Must(template.New(filename).Parse(tmpl)),
		query:    query,
	}
}

type query struct {
	query   string
	filters []func(s string) bool
}

func (q query) exec() (results []string, _ error) {
	cmd := exec.Command("bazel", "query", q.query)
	var stdout bytes.Buffer
	var stderr strings.Builder
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		return nil, errors.Errorf(
			"failed to run %s: %v\n(stderr)\n%s", cmd, err, &stderr)
	}
	sc := bufio.NewScanner(&stdout)
	keep := func(s string) (shouldKeep bool) {
		for _, f := range q.filters {
			if !f(s) {
				return false
			}
		}
		return true
	}
	for sc.Scan() {
		if s := sc.Text(); keep(s) {
			results = append(results, s)
		}
	}
	sort.Strings(results)
	return results, nil
}

func generate(outDir string) error {
	tmpDir, err := ioutil.TempDir("", "")
	if err != nil {
		return err
	}
	defer func() { _ = os.RemoveAll(tmpDir) }()
	for _, t := range targets {
		out, err := t.query.exec()
		if err != nil {
			return err
		}
		fp := filepath.Join(tmpDir, t.filename)
		f, err := os.Create(fp)
		if err != nil {
			return err
		}
		if err := t.template.Execute(f, out); err != nil {
			return errors.Wrapf(err, "failed to execute template for %s", t.filename)
		}
		if err := f.Close(); err != nil {
			return errors.Wrapf(err, "failed to write file for %s", t.filename)
		}
		if err := os.Rename(fp, filepath.Join(outDir, t.filename)); err != nil {
			return errors.Wrapf(err, "failed to rename file for %s", t.filename)
		}
	}
	return nil
}
