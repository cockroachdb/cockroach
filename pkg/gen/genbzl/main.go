// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Command genbzl is used to generate bazel files which then get imported by
// the gen package's BUILD.bazel to facilitate hoisting these generated files
// back into the source tree.
//
// It's all a bit meta. The flow is that we invoke this binary inside the
// bazelutil/bazel-generate.sh script which writes out some bzl files with
// lists of targets which are then depended on in gen.bzl.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/cockroachdb/cockroach/pkg/cli/exit"
	"github.com/cockroachdb/errors"
)

var (
	outDir = flag.String("out-dir", "", "directory in which to place the generated files")
)

func main() {
	flag.Parse()
	if err := generate(*outDir); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate files: %v\n", err)
		exit.WithCode(exit.UnspecifiedError())
	}
}

var tmpl = template.Must(template.New("file").Parse(
	`# Generated by genbzl

{{ .Variable }} = [{{ range .Targets }}
  "{{ . }}",{{end}}
]
`))

type templateData struct {
	Variable string
	Targets  []string
}

var targets = []*target{
	{
		filename: "protobuf.bzl", variable: "PROTOBUF_SRCS",
		query: "kind(go_proto_library, //pkg/...)",
	},
	{
		filename: "gomock.bzl", variable: "GOMOCK_SRCS",
		query: `labels("out", kind("_gomock_prog_exec rule",  //pkg/...:*))`,
	},
	{
		filename: "stringer.bzl",
		variable: "STRINGER_SRCS",
		query:    `labels("outs",  filter("-stringer$", kind("genrule rule",  //pkg/...:*)))`,
	},
	{
		filename: "execgen.bzl", variable: "EXECGEN_SRCS",
		query: `
let genrules =
  kind("genrule rule",  //pkg/...:*)
in labels("outs",  attr("tools", "execgen", $genrules)
  + attr("exec_tools", "execgen", $genrules))`,
	},
	{
		filename: "optgen.bzl", variable: "OPTGEN_SRCS",
		query: `
let targets = attr("exec_tools", "(opt|lang)gen",  kind("genrule rule",  //pkg/...:*))
in let og = labels("outs",  $targets)
in $og - filter(".*:.*(-gen|gen-).*", $og)`,
	},
	{
		filename: "docs.bzl", variable: "DOCS_SRCS",
		query: `
kind("generated file", //docs/...:*)
  - labels("outs", //docs/generated/sql/bnf:svg)`,
	},
	{
		filename: "excluded.bzl", variable: "EXCLUDED_SRCS",
		query: `
let all = kind("generated file", //...:*)
in ($all ^ //pkg/ui/...:*)
  + ($all ^ labels("out", kind("_gomock_prog_gen rule",  //pkg/...:*)))
  + filter(".*:.*(-gen|gen-).*", $all)
  + //pkg/testutils/lint/passes/errcheck:errcheck_excludes.txt
  + //build/bazelutil:test_stamping.txt
  + labels("outs", //docs/generated/sql/bnf:svg)`,
	},
	// MISC_SRCS is a special beast to capture everything which is not excluded
	// or included explicitly in one of the other targets. By defining this
	// target in this way, we ensure that we don't forget to generate anything.
	// One note is that this needs to be last. The definition relies on the
	// existence of the above definitions (indirectly via the fact that these
	// referenced gen labels refer to variables whose data we're populating
	// here).
	{
		filename: "misc.bzl", variable: "MISC_SRCS",
		query: `
kind("generated file", //...:*)
  - labels("srcs", //pkg/gen:explicitly_generated)
  - labels("srcs", //pkg/gen:excluded)
`,
	},
}

type target struct {
	filename string
	variable string
	query    string
}

func execQuery(q string) (results []string, _ error) {
	cmd := exec.Command("bazel", "query", q)
	var stdout bytes.Buffer
	var stderr strings.Builder
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	if err := cmd.Run(); err != nil {
		return nil, errors.Wrapf(err,
			"failed to run %s: (stderr)\n%s", cmd, &stderr)
	}
	for sc := bufio.NewScanner(&stdout); sc.Scan(); {
		results = append(results, sc.Text())
	}
	sort.Strings(results)
	return results, nil
}

func generate(outDir string) error {
	// Go through once and rewrite all the generated variables to be empty sets.
	// The reason to do this is that the values stored in these variables are
	// part of the build graph and can affect `bazel query`. If any of the
	// targets were to have rotted and contain values which don't exist in the
	// graph, we'd see errors. Clearing out the lists and then building them up
	// again from empty helps avoid such issues.
	for _, t := range targets {
		if err := t.write(outDir, nil); err != nil {
			return err
		}
	}
	// Now go and populate the lists based on the results of the queries.
	for _, t := range targets {
		out, err := execQuery(t.query)
		if err != nil {
			return err
		}
		if err := t.write(outDir, out); err != nil {
			return err
		}
	}
	return nil
}

func (t *target) write(outDir string, out []string) error {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData{
		Variable: t.variable,
		Targets:  out,
	}); err != nil {
		return errors.Wrapf(err, "failed to execute template for %s", t.filename)
	}
	f, err := os.Create(filepath.Join(outDir, t.filename))
	if err != nil {
		return errors.Wrapf(err, "failed to open file for %s", t.filename)
	}
	if _, err := io.Copy(f, &buf); err != nil {
		return errors.Wrapf(err, "failed to write file for %s", t.filename)
	}
	if err := f.Close(); err != nil {
		return errors.Wrapf(err, "failed to write file for %s", t.filename)
	}
	return nil
}
