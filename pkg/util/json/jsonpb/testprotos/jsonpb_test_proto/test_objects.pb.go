// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/json/jsonpb/testprotos/jsonpb_test_proto/test_objects.proto

package jsonpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Widget_Color int32

const (
	Widget_RED   Widget_Color = 0
	Widget_GREEN Widget_Color = 1
	Widget_BLUE  Widget_Color = 2
)

var Widget_Color_name = map[int32]string{
	0: "RED",
	1: "GREEN",
	2: "BLUE",
}

var Widget_Color_value = map[string]int32{
	"RED":   0,
	"GREEN": 1,
	"BLUE":  2,
}

func (x Widget_Color) Enum() *Widget_Color {
	p := new(Widget_Color)
	*p = x
	return p
}

func (x Widget_Color) String() string {
	return proto.EnumName(Widget_Color_name, int32(x))
}

func (x *Widget_Color) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Widget_Color_value, data, "Widget_Color")
	if err != nil {
		return err
	}
	*x = Widget_Color(value)
	return nil
}

func (Widget_Color) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{3, 0}
}

// Test message for holding primitive types.
type Simple struct {
	OBool      *bool    `protobuf:"varint,1,opt,name=o_bool,json=oBool" json:"o_bool,omitempty"`
	OInt32     *int32   `protobuf:"varint,2,opt,name=o_int32,json=oInt32" json:"o_int32,omitempty"`
	OInt32Str  *int32   `protobuf:"varint,3,opt,name=o_int32_str,json=oInt32Str" json:"o_int32_str,omitempty"`
	OInt64     *int64   `protobuf:"varint,4,opt,name=o_int64,json=oInt64" json:"o_int64,omitempty"`
	OInt64Str  *int64   `protobuf:"varint,5,opt,name=o_int64_str,json=oInt64Str" json:"o_int64_str,omitempty"`
	OUint32    *uint32  `protobuf:"varint,6,opt,name=o_uint32,json=oUint32" json:"o_uint32,omitempty"`
	OUint32Str *uint32  `protobuf:"varint,7,opt,name=o_uint32_str,json=oUint32Str" json:"o_uint32_str,omitempty"`
	OUint64    *uint64  `protobuf:"varint,8,opt,name=o_uint64,json=oUint64" json:"o_uint64,omitempty"`
	OUint64Str *uint64  `protobuf:"varint,9,opt,name=o_uint64_str,json=oUint64Str" json:"o_uint64_str,omitempty"`
	OSint32    *int32   `protobuf:"zigzag32,10,opt,name=o_sint32,json=oSint32" json:"o_sint32,omitempty"`
	OSint32Str *int32   `protobuf:"zigzag32,11,opt,name=o_sint32_str,json=oSint32Str" json:"o_sint32_str,omitempty"`
	OSint64    *int64   `protobuf:"zigzag64,12,opt,name=o_sint64,json=oSint64" json:"o_sint64,omitempty"`
	OSint64Str *int64   `protobuf:"zigzag64,13,opt,name=o_sint64_str,json=oSint64Str" json:"o_sint64_str,omitempty"`
	OFloat     *float32 `protobuf:"fixed32,14,opt,name=o_float,json=oFloat" json:"o_float,omitempty"`
	OFloatStr  *float32 `protobuf:"fixed32,15,opt,name=o_float_str,json=oFloatStr" json:"o_float_str,omitempty"`
	ODouble    *float64 `protobuf:"fixed64,16,opt,name=o_double,json=oDouble" json:"o_double,omitempty"`
	ODoubleStr *float64 `protobuf:"fixed64,17,opt,name=o_double_str,json=oDoubleStr" json:"o_double_str,omitempty"`
	OString    *string  `protobuf:"bytes,18,opt,name=o_string,json=oString" json:"o_string,omitempty"`
	OBytes     []byte   `protobuf:"bytes,19,opt,name=o_bytes,json=oBytes" json:"o_bytes,omitempty"`
	OCastBytes Bytes    `protobuf:"bytes,20,opt,name=o_cast_bytes,json=oCastBytes,casttype=Bytes" json:"o_cast_bytes,omitempty"`
}

func (m *Simple) Reset()         { *m = Simple{} }
func (m *Simple) String() string { return proto.CompactTextString(m) }
func (*Simple) ProtoMessage()    {}
func (*Simple) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{0}
}
func (m *Simple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Simple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Simple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Simple.Merge(m, src)
}
func (m *Simple) XXX_Size() int {
	return m.Size()
}
func (m *Simple) XXX_DiscardUnknown() {
	xxx_messageInfo_Simple.DiscardUnknown(m)
}

var xxx_messageInfo_Simple proto.InternalMessageInfo

// Test message for holding special non-finites primitives.
type NonFinites struct {
	FNan  *float32 `protobuf:"fixed32,1,opt,name=f_nan,json=fNan" json:"f_nan,omitempty"`
	FPinf *float32 `protobuf:"fixed32,2,opt,name=f_pinf,json=fPinf" json:"f_pinf,omitempty"`
	FNinf *float32 `protobuf:"fixed32,3,opt,name=f_ninf,json=fNinf" json:"f_ninf,omitempty"`
	DNan  *float64 `protobuf:"fixed64,4,opt,name=d_nan,json=dNan" json:"d_nan,omitempty"`
	DPinf *float64 `protobuf:"fixed64,5,opt,name=d_pinf,json=dPinf" json:"d_pinf,omitempty"`
	DNinf *float64 `protobuf:"fixed64,6,opt,name=d_ninf,json=dNinf" json:"d_ninf,omitempty"`
}

func (m *NonFinites) Reset()         { *m = NonFinites{} }
func (m *NonFinites) String() string { return proto.CompactTextString(m) }
func (*NonFinites) ProtoMessage()    {}
func (*NonFinites) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{1}
}
func (m *NonFinites) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NonFinites) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NonFinites) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonFinites.Merge(m, src)
}
func (m *NonFinites) XXX_Size() int {
	return m.Size()
}
func (m *NonFinites) XXX_DiscardUnknown() {
	xxx_messageInfo_NonFinites.DiscardUnknown(m)
}

var xxx_messageInfo_NonFinites proto.InternalMessageInfo

// Test message for holding repeated primitives.
type Repeats struct {
	RBool   []bool    `protobuf:"varint,1,rep,name=r_bool,json=rBool" json:"r_bool,omitempty"`
	RInt32  []int32   `protobuf:"varint,2,rep,name=r_int32,json=rInt32" json:"r_int32,omitempty"`
	RInt64  []int64   `protobuf:"varint,3,rep,name=r_int64,json=rInt64" json:"r_int64,omitempty"`
	RUint32 []uint32  `protobuf:"varint,4,rep,name=r_uint32,json=rUint32" json:"r_uint32,omitempty"`
	RUint64 []uint64  `protobuf:"varint,5,rep,name=r_uint64,json=rUint64" json:"r_uint64,omitempty"`
	RSint32 []int32   `protobuf:"zigzag32,6,rep,name=r_sint32,json=rSint32" json:"r_sint32,omitempty"`
	RSint64 []int64   `protobuf:"zigzag64,7,rep,name=r_sint64,json=rSint64" json:"r_sint64,omitempty"`
	RFloat  []float32 `protobuf:"fixed32,8,rep,name=r_float,json=rFloat" json:"r_float,omitempty"`
	RDouble []float64 `protobuf:"fixed64,9,rep,name=r_double,json=rDouble" json:"r_double,omitempty"`
	RString []string  `protobuf:"bytes,10,rep,name=r_string,json=rString" json:"r_string,omitempty"`
	RBytes  [][]byte  `protobuf:"bytes,11,rep,name=r_bytes,json=rBytes" json:"r_bytes,omitempty"`
}

func (m *Repeats) Reset()         { *m = Repeats{} }
func (m *Repeats) String() string { return proto.CompactTextString(m) }
func (*Repeats) ProtoMessage()    {}
func (*Repeats) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{2}
}
func (m *Repeats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repeats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Repeats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repeats.Merge(m, src)
}
func (m *Repeats) XXX_Size() int {
	return m.Size()
}
func (m *Repeats) XXX_DiscardUnknown() {
	xxx_messageInfo_Repeats.DiscardUnknown(m)
}

var xxx_messageInfo_Repeats proto.InternalMessageInfo

// Test message for holding enums and nested messages.
type Widget struct {
	Color    *Widget_Color  `protobuf:"varint,1,opt,name=color,enum=jsonpb.Widget_Color" json:"color,omitempty"`
	RColor   []Widget_Color `protobuf:"varint,2,rep,name=r_color,json=rColor,enum=jsonpb.Widget_Color" json:"r_color,omitempty"`
	Simple   *Simple        `protobuf:"bytes,10,opt,name=simple" json:"simple,omitempty"`
	RSimple  []*Simple      `protobuf:"bytes,11,rep,name=r_simple,json=rSimple" json:"r_simple,omitempty"`
	Repeats  *Repeats       `protobuf:"bytes,20,opt,name=repeats" json:"repeats,omitempty"`
	RRepeats []*Repeats     `protobuf:"bytes,21,rep,name=r_repeats,json=rRepeats" json:"r_repeats,omitempty"`
}

func (m *Widget) Reset()         { *m = Widget{} }
func (m *Widget) String() string { return proto.CompactTextString(m) }
func (*Widget) ProtoMessage()    {}
func (*Widget) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{3}
}
func (m *Widget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Widget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Widget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Widget.Merge(m, src)
}
func (m *Widget) XXX_Size() int {
	return m.Size()
}
func (m *Widget) XXX_DiscardUnknown() {
	xxx_messageInfo_Widget.DiscardUnknown(m)
}

var xxx_messageInfo_Widget proto.InternalMessageInfo

type Maps struct {
	MInt64Str   map[int64]string `protobuf:"bytes,1,rep,name=m_int64_str,json=mInt64Str" json:"m_int64_str,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MBoolSimple map[bool]*Simple `protobuf:"bytes,2,rep,name=m_bool_simple,json=mBoolSimple" json:"m_bool_simple,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Maps) Reset()         { *m = Maps{} }
func (m *Maps) String() string { return proto.CompactTextString(m) }
func (*Maps) ProtoMessage()    {}
func (*Maps) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{4}
}
func (m *Maps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Maps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Maps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Maps.Merge(m, src)
}
func (m *Maps) XXX_Size() int {
	return m.Size()
}
func (m *Maps) XXX_DiscardUnknown() {
	xxx_messageInfo_Maps.DiscardUnknown(m)
}

var xxx_messageInfo_Maps proto.InternalMessageInfo

type MsgWithOneof struct {
	// Types that are valid to be assigned to Union:
	//	*MsgWithOneof_Title
	//	*MsgWithOneof_Salary
	//	*MsgWithOneof_Country
	//	*MsgWithOneof_HomeAddress
	//	*MsgWithOneof_MsgWithRequired
	Union isMsgWithOneof_Union `protobuf_oneof:"union"`
}

func (m *MsgWithOneof) Reset()         { *m = MsgWithOneof{} }
func (m *MsgWithOneof) String() string { return proto.CompactTextString(m) }
func (*MsgWithOneof) ProtoMessage()    {}
func (*MsgWithOneof) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{5}
}
func (m *MsgWithOneof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithOneof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgWithOneof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithOneof.Merge(m, src)
}
func (m *MsgWithOneof) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithOneof) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithOneof.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithOneof proto.InternalMessageInfo

type isMsgWithOneof_Union interface {
	isMsgWithOneof_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgWithOneof_Title struct {
	Title string `protobuf:"bytes,1,opt,name=title,oneof" json:"title,omitempty"`
}
type MsgWithOneof_Salary struct {
	Salary int64 `protobuf:"varint,2,opt,name=salary,oneof" json:"salary,omitempty"`
}
type MsgWithOneof_Country struct {
	Country string `protobuf:"bytes,3,opt,name=Country,oneof" json:"Country,omitempty"`
}
type MsgWithOneof_HomeAddress struct {
	HomeAddress string `protobuf:"bytes,4,opt,name=home_address,json=homeAddress,oneof" json:"home_address,omitempty"`
}
type MsgWithOneof_MsgWithRequired struct {
	MsgWithRequired *MsgWithRequired `protobuf:"bytes,5,opt,name=msg_with_required,json=msgWithRequired,oneof" json:"msg_with_required,omitempty"`
}

func (*MsgWithOneof_Title) isMsgWithOneof_Union()           {}
func (*MsgWithOneof_Salary) isMsgWithOneof_Union()          {}
func (*MsgWithOneof_Country) isMsgWithOneof_Union()         {}
func (*MsgWithOneof_HomeAddress) isMsgWithOneof_Union()     {}
func (*MsgWithOneof_MsgWithRequired) isMsgWithOneof_Union() {}

func (m *MsgWithOneof) GetUnion() isMsgWithOneof_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *MsgWithOneof) GetTitle() string {
	if x, ok := m.GetUnion().(*MsgWithOneof_Title); ok {
		return x.Title
	}
	return ""
}

func (m *MsgWithOneof) GetSalary() int64 {
	if x, ok := m.GetUnion().(*MsgWithOneof_Salary); ok {
		return x.Salary
	}
	return 0
}

func (m *MsgWithOneof) GetCountry() string {
	if x, ok := m.GetUnion().(*MsgWithOneof_Country); ok {
		return x.Country
	}
	return ""
}

func (m *MsgWithOneof) GetHomeAddress() string {
	if x, ok := m.GetUnion().(*MsgWithOneof_HomeAddress); ok {
		return x.HomeAddress
	}
	return ""
}

func (m *MsgWithOneof) GetMsgWithRequired() *MsgWithRequired {
	if x, ok := m.GetUnion().(*MsgWithOneof_MsgWithRequired); ok {
		return x.MsgWithRequired
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgWithOneof) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgWithOneof_Title)(nil),
		(*MsgWithOneof_Salary)(nil),
		(*MsgWithOneof_Country)(nil),
		(*MsgWithOneof_HomeAddress)(nil),
		(*MsgWithOneof_MsgWithRequired)(nil),
	}
}

type Real struct {
	Value                        *float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
}

func (m *Real) Reset()         { *m = Real{} }
func (m *Real) String() string { return proto.CompactTextString(m) }
func (*Real) ProtoMessage()    {}
func (*Real) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{6}
}

var extRange_Real = []proto.ExtensionRange{
	{Start: 100, End: 536870911},
}

func (*Real) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_Real
}

func (m *Real) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Real) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Real) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Real.Merge(m, src)
}
func (m *Real) XXX_Size() int {
	return m.Size()
}
func (m *Real) XXX_DiscardUnknown() {
	xxx_messageInfo_Real.DiscardUnknown(m)
}

var xxx_messageInfo_Real proto.InternalMessageInfo

type Complex struct {
	Imaginary                    *float64 `protobuf:"fixed64,1,opt,name=imaginary" json:"imaginary,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
}

func (m *Complex) Reset()         { *m = Complex{} }
func (m *Complex) String() string { return proto.CompactTextString(m) }
func (*Complex) ProtoMessage()    {}
func (*Complex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{7}
}

var extRange_Complex = []proto.ExtensionRange{
	{Start: 100, End: 536870911},
}

func (*Complex) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_Complex
}

func (m *Complex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Complex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Complex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Complex.Merge(m, src)
}
func (m *Complex) XXX_Size() int {
	return m.Size()
}
func (m *Complex) XXX_DiscardUnknown() {
	xxx_messageInfo_Complex.DiscardUnknown(m)
}

var xxx_messageInfo_Complex proto.InternalMessageInfo

var E_Complex_RealExtension = &proto.ExtensionDesc{
	ExtendedType:  (*Real)(nil),
	ExtensionType: (*Complex)(nil),
	Field:         123,
	Name:          "jsonpb.Complex.real_extension",
	Tag:           "bytes,123,opt,name=real_extension",
	Filename:      "util/json/jsonpb/testprotos/jsonpb_test_proto/test_objects.proto",
}

type KnownTypes struct {
	An    *types.Any         `protobuf:"bytes,14,opt,name=an" json:"an,omitempty"`
	Dur   *types.Duration    `protobuf:"bytes,1,opt,name=dur" json:"dur,omitempty"`
	St    *types.Struct      `protobuf:"bytes,12,opt,name=st" json:"st,omitempty"`
	Ts    *types.Timestamp   `protobuf:"bytes,2,opt,name=ts" json:"ts,omitempty"`
	Lv    *types.ListValue   `protobuf:"bytes,15,opt,name=lv" json:"lv,omitempty"`
	Val   *types.Value       `protobuf:"bytes,16,opt,name=val" json:"val,omitempty"`
	Dbl   *types.DoubleValue `protobuf:"bytes,3,opt,name=dbl" json:"dbl,omitempty"`
	Flt   *types.FloatValue  `protobuf:"bytes,4,opt,name=flt" json:"flt,omitempty"`
	I64   *types.Int64Value  `protobuf:"bytes,5,opt,name=i64" json:"i64,omitempty"`
	U64   *types.UInt64Value `protobuf:"bytes,6,opt,name=u64" json:"u64,omitempty"`
	I32   *types.Int32Value  `protobuf:"bytes,7,opt,name=i32" json:"i32,omitempty"`
	U32   *types.UInt32Value `protobuf:"bytes,8,opt,name=u32" json:"u32,omitempty"`
	Bool  *types.BoolValue   `protobuf:"bytes,9,opt,name=bool" json:"bool,omitempty"`
	Str   *types.StringValue `protobuf:"bytes,10,opt,name=str" json:"str,omitempty"`
	Bytes *types.BytesValue  `protobuf:"bytes,11,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *KnownTypes) Reset()         { *m = KnownTypes{} }
func (m *KnownTypes) String() string { return proto.CompactTextString(m) }
func (*KnownTypes) ProtoMessage()    {}
func (*KnownTypes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{8}
}
func (m *KnownTypes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KnownTypes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KnownTypes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KnownTypes.Merge(m, src)
}
func (m *KnownTypes) XXX_Size() int {
	return m.Size()
}
func (m *KnownTypes) XXX_DiscardUnknown() {
	xxx_messageInfo_KnownTypes.DiscardUnknown(m)
}

var xxx_messageInfo_KnownTypes proto.InternalMessageInfo

// Test messages for marshaling/unmarshaling required fields.
type MsgWithRequired struct {
	Str *string `protobuf:"bytes,1,req,name=str" json:"str,omitempty"`
}

func (m *MsgWithRequired) Reset()         { *m = MsgWithRequired{} }
func (m *MsgWithRequired) String() string { return proto.CompactTextString(m) }
func (*MsgWithRequired) ProtoMessage()    {}
func (*MsgWithRequired) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{9}
}
func (m *MsgWithRequired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithRequired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgWithRequired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithRequired.Merge(m, src)
}
func (m *MsgWithRequired) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithRequired) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithRequired.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithRequired proto.InternalMessageInfo

type MsgWithIndirectRequired struct {
	Subm       *MsgWithRequired            `protobuf:"bytes,1,opt,name=subm" json:"subm,omitempty"`
	MapField   map[string]*MsgWithRequired `protobuf:"bytes,2,rep,name=map_field,json=mapField" json:"map_field,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SliceField []*MsgWithRequired          `protobuf:"bytes,3,rep,name=slice_field,json=sliceField" json:"slice_field,omitempty"`
}

func (m *MsgWithIndirectRequired) Reset()         { *m = MsgWithIndirectRequired{} }
func (m *MsgWithIndirectRequired) String() string { return proto.CompactTextString(m) }
func (*MsgWithIndirectRequired) ProtoMessage()    {}
func (*MsgWithIndirectRequired) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{10}
}
func (m *MsgWithIndirectRequired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithIndirectRequired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgWithIndirectRequired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithIndirectRequired.Merge(m, src)
}
func (m *MsgWithIndirectRequired) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithIndirectRequired) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithIndirectRequired.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithIndirectRequired proto.InternalMessageInfo

type MsgWithRequiredBytes struct {
	Byts []byte `protobuf:"bytes,1,req,name=byts" json:"byts,omitempty"`
}

func (m *MsgWithRequiredBytes) Reset()         { *m = MsgWithRequiredBytes{} }
func (m *MsgWithRequiredBytes) String() string { return proto.CompactTextString(m) }
func (*MsgWithRequiredBytes) ProtoMessage()    {}
func (*MsgWithRequiredBytes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{11}
}
func (m *MsgWithRequiredBytes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithRequiredBytes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgWithRequiredBytes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithRequiredBytes.Merge(m, src)
}
func (m *MsgWithRequiredBytes) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithRequiredBytes) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithRequiredBytes.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithRequiredBytes proto.InternalMessageInfo

type MsgWithRequiredWKT struct {
	Str *types.StringValue `protobuf:"bytes,1,req,name=str" json:"str,omitempty"`
}

func (m *MsgWithRequiredWKT) Reset()         { *m = MsgWithRequiredWKT{} }
func (m *MsgWithRequiredWKT) String() string { return proto.CompactTextString(m) }
func (*MsgWithRequiredWKT) ProtoMessage()    {}
func (*MsgWithRequiredWKT) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7a50f7b1b16aa34, []int{12}
}
func (m *MsgWithRequiredWKT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithRequiredWKT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgWithRequiredWKT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithRequiredWKT.Merge(m, src)
}
func (m *MsgWithRequiredWKT) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithRequiredWKT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithRequiredWKT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithRequiredWKT proto.InternalMessageInfo

var E_Name = &proto.ExtensionDesc{
	ExtendedType:  (*Real)(nil),
	ExtensionType: (*string)(nil),
	Field:         124,
	Name:          "jsonpb.name",
	Tag:           "bytes,124,opt,name=name",
	Filename:      "util/json/jsonpb/testprotos/jsonpb_test_proto/test_objects.proto",
}

var E_Extm = &proto.ExtensionDesc{
	ExtendedType:  (*Real)(nil),
	ExtensionType: (*MsgWithRequired)(nil),
	Field:         125,
	Name:          "jsonpb.extm",
	Tag:           "bytes,125,opt,name=extm",
	Filename:      "util/json/jsonpb/testprotos/jsonpb_test_proto/test_objects.proto",
}

func init() {
	proto.RegisterEnum("jsonpb.Widget_Color", Widget_Color_name, Widget_Color_value)
	proto.RegisterType((*Simple)(nil), "jsonpb.Simple")
	proto.RegisterType((*NonFinites)(nil), "jsonpb.NonFinites")
	proto.RegisterType((*Repeats)(nil), "jsonpb.Repeats")
	proto.RegisterType((*Widget)(nil), "jsonpb.Widget")
	proto.RegisterType((*Maps)(nil), "jsonpb.Maps")
	proto.RegisterMapType((map[bool]*Simple)(nil), "jsonpb.Maps.MBoolSimpleEntry")
	proto.RegisterMapType((map[int64]string)(nil), "jsonpb.Maps.MInt64StrEntry")
	proto.RegisterType((*MsgWithOneof)(nil), "jsonpb.MsgWithOneof")
	proto.RegisterType((*Real)(nil), "jsonpb.Real")
	proto.RegisterExtension(E_Complex_RealExtension)
	proto.RegisterType((*Complex)(nil), "jsonpb.Complex")
	proto.RegisterType((*KnownTypes)(nil), "jsonpb.KnownTypes")
	proto.RegisterType((*MsgWithRequired)(nil), "jsonpb.MsgWithRequired")
	proto.RegisterType((*MsgWithIndirectRequired)(nil), "jsonpb.MsgWithIndirectRequired")
	proto.RegisterMapType((map[string]*MsgWithRequired)(nil), "jsonpb.MsgWithIndirectRequired.MapFieldEntry")
	proto.RegisterType((*MsgWithRequiredBytes)(nil), "jsonpb.MsgWithRequiredBytes")
	proto.RegisterType((*MsgWithRequiredWKT)(nil), "jsonpb.MsgWithRequiredWKT")
	proto.RegisterExtension(E_Name)
	proto.RegisterExtension(E_Extm)
}

func init() {
	proto.RegisterFile("util/json/jsonpb/testprotos/jsonpb_test_proto/test_objects.proto", fileDescriptor_e7a50f7b1b16aa34)
}

var fileDescriptor_e7a50f7b1b16aa34 = []byte{
	// 1568 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcf, 0x72, 0x1b, 0x49,
	0x19, 0xd7, 0xcc, 0x68, 0x24, 0xcd, 0x27, 0xff, 0x4b, 0xc7, 0xbb, 0x91, 0x45, 0xd0, 0x4e, 0x69,
	0x97, 0x45, 0x24, 0x58, 0x2e, 0x64, 0x95, 0x6a, 0x09, 0x1c, 0x88, 0x63, 0x87, 0x2c, 0xbb, 0x31,
	0x54, 0xdb, 0x21, 0xdc, 0x54, 0x23, 0xcf, 0x48, 0x99, 0x65, 0x66, 0x5a, 0x74, 0xb7, 0xec, 0xa8,
	0x80, 0x2a, 0x3f, 0x02, 0x45, 0xf1, 0x04, 0x1c, 0x78, 0x04, 0x0e, 0x3c, 0xc1, 0x1e, 0x97, 0x5b,
	0x0e, 0x14, 0x05, 0xce, 0x5b, 0x70, 0xa2, 0xfa, 0xeb, 0x1e, 0xfd, 0xb3, 0x55, 0x70, 0xb1, 0xd5,
	0xdf, 0xef, 0x4f, 0xf7, 0x74, 0xff, 0xe6, 0xeb, 0x81, 0x9f, 0x4c, 0x64, 0x9c, 0x1c, 0x7c, 0x25,
	0x58, 0x86, 0x7f, 0xc6, 0x83, 0x03, 0x19, 0x09, 0x39, 0xe6, 0x4c, 0x32, 0x61, 0x2a, 0x7d, 0x55,
	0xe9, 0x63, 0x09, 0xc1, 0x3e, 0x1b, 0x7c, 0x15, 0x5d, 0x48, 0xd1, 0xc6, 0x12, 0x29, 0x69, 0x56,
	0x7d, 0x6f, 0xc4, 0xd8, 0x28, 0x89, 0x0e, 0xb0, 0x3a, 0x98, 0x0c, 0x0f, 0x82, 0x6c, 0xaa, 0x29,
	0xf5, 0xc6, 0x2a, 0x14, 0x4e, 0x78, 0x20, 0x63, 0x96, 0x19, 0xfc, 0xe1, 0x2a, 0x2e, 0x24, 0x9f,
	0x5c, 0x48, 0x83, 0x7e, 0xb4, 0x8a, 0xca, 0x38, 0x8d, 0x84, 0x0c, 0xd2, 0xf1, 0x3a, 0xfb, 0x2b,
	0x1e, 0x8c, 0xc7, 0x11, 0x37, 0x2b, 0xac, 0xef, 0x8e, 0xd8, 0x88, 0xe9, 0xf5, 0xab, 0x5f, 0xba,
	0xda, 0xfc, 0x47, 0x11, 0x4a, 0x67, 0x71, 0x3a, 0x4e, 0x22, 0xf2, 0x01, 0x94, 0x58, 0x7f, 0xc0,
	0x58, 0x52, 0xb3, 0x7c, 0xab, 0x55, 0xa1, 0x2e, 0x3b, 0x62, 0x2c, 0x21, 0x0f, 0xa0, 0xcc, 0xfa,
	0x71, 0x26, 0x0f, 0x3b, 0x35, 0xdb, 0xb7, 0x5a, 0x2e, 0x2d, 0xb1, 0xcf, 0xd5, 0x88, 0x34, 0xa0,
	0x6a, 0x80, 0xbe, 0x90, 0xbc, 0xe6, 0x20, 0xe8, 0x69, 0xf0, 0x4c, 0xf2, 0x99, 0xb0, 0xd7, 0xad,
	0x15, 0x7d, 0xab, 0xe5, 0x68, 0x61, 0xaf, 0x3b, 0x13, 0xf6, 0xba, 0x28, 0x74, 0x11, 0xf4, 0x34,
	0xa8, 0x84, 0x7b, 0x50, 0x61, 0xfd, 0x89, 0x9e, 0xb2, 0xe4, 0x5b, 0xad, 0x4d, 0x5a, 0x66, 0xaf,
	0x70, 0x48, 0x7c, 0xd8, 0xc8, 0x21, 0xd4, 0x96, 0x11, 0x06, 0x03, 0x2f, 0x89, 0x7b, 0xdd, 0x5a,
	0xc5, 0xb7, 0x5a, 0x45, 0x23, 0xee, 0x75, 0xe7, 0x62, 0x33, 0xb1, 0x87, 0x30, 0x18, 0x78, 0x26,
	0x16, 0x7a, 0x66, 0xf0, 0xad, 0xd6, 0x3d, 0x5a, 0x66, 0x67, 0x0b, 0x33, 0x8b, 0xf9, 0xcc, 0x55,
	0x84, 0xc1, 0xc0, 0x4b, 0xe2, 0x5e, 0xb7, 0xb6, 0xe1, 0x5b, 0x2d, 0x62, 0xc4, 0xf9, 0xcc, 0x62,
	0x3e, 0xf3, 0x26, 0xc2, 0x60, 0xe0, 0xd9, 0x66, 0x0d, 0x13, 0x16, 0xc8, 0xda, 0x96, 0x6f, 0xb5,
	0x6c, 0x5a, 0x62, 0xcf, 0xd5, 0x48, 0x6f, 0x16, 0x02, 0xa8, 0xdc, 0x46, 0xd0, 0xd3, 0xe0, 0x6c,
	0xd6, 0x90, 0x4d, 0x06, 0x49, 0x54, 0xdb, 0xf1, 0xad, 0x96, 0x45, 0xcb, 0xec, 0x18, 0x87, 0x7a,
	0x56, 0x0d, 0xa1, 0xf6, 0x1e, 0xc2, 0x60, 0xe0, 0xf9, 0x92, 0x25, 0x8f, 0xb3, 0x51, 0x8d, 0xf8,
	0x56, 0xcb, 0x53, 0x4b, 0xc6, 0xa1, 0x5e, 0xd0, 0x60, 0x2a, 0x23, 0x51, 0xbb, 0xef, 0x5b, 0xad,
	0x0d, 0x5a, 0x62, 0x47, 0x6a, 0x44, 0x1e, 0x2b, 0xd7, 0x8b, 0x40, 0x48, 0x83, 0xee, 0x2a, 0xf4,
	0xc8, 0xfb, 0xcf, 0x3f, 0x3f, 0x72, 0x91, 0x40, 0x81, 0x3d, 0x0b, 0x84, 0xc4, 0xdf, 0xcd, 0x3f,
	0x5a, 0x00, 0xa7, 0x2c, 0x7b, 0x1e, 0x67, 0xb1, 0xd2, 0xde, 0x07, 0x77, 0xd8, 0xcf, 0x82, 0x0c,
	0x13, 0x66, 0xd3, 0xe2, 0xf0, 0x34, 0xc8, 0x54, 0xee, 0x86, 0xfd, 0x71, 0x9c, 0x0d, 0x31, 0x5f,
	0x36, 0x75, 0x87, 0xbf, 0x88, 0xb3, 0xa1, 0x2e, 0x67, 0xaa, 0xec, 0x98, 0xf2, 0xa9, 0x2a, 0xdf,
	0x07, 0x37, 0x44, 0x8b, 0x22, 0x3e, 0x4d, 0x31, 0x34, 0x16, 0xa1, 0xb6, 0x70, 0xb1, 0xea, 0x86,
	0xb9, 0x45, 0xa8, 0x2d, 0x4a, 0xa6, 0xac, 0x2c, 0x9a, 0x7f, 0xb1, 0xa1, 0x4c, 0xa3, 0x71, 0x14,
	0x48, 0xa1, 0x28, 0x3c, 0x0f, 0xbd, 0xa3, 0x42, 0xcf, 0xf3, 0xd0, 0xf3, 0x59, 0xe8, 0x1d, 0x15,
	0x7a, 0xae, 0x43, 0x9f, 0x03, 0xbd, 0x6e, 0xcd, 0xf1, 0x1d, 0x15, 0x6a, 0xae, 0x43, 0xbd, 0x07,
	0x15, 0x9e, 0x87, 0xb6, 0xe8, 0x3b, 0x2a, 0xb4, 0xdc, 0x84, 0x76, 0x06, 0xf5, 0xba, 0x35, 0xd7,
	0x77, 0x54, 0x24, 0xb9, 0x89, 0x24, 0x42, 0x22, 0x8f, 0xba, 0xa3, 0x02, 0xc7, 0xcf, 0x16, 0x54,
	0x26, 0x4e, 0x65, 0xdf, 0x51, 0x71, 0xe2, 0x26, 0x4e, 0xb8, 0x08, 0x1d, 0x96, 0x8a, 0xef, 0xa8,
	0xb0, 0x70, 0x1d, 0x16, 0xd4, 0x98, 0x30, 0x78, 0xbe, 0xa3, 0xc2, 0xc0, 0x4d, 0x18, 0xb4, 0x9d,
	0x3e, 0x6a, 0xf0, 0x1d, 0x75, 0xd4, 0x7c, 0x7e, 0xd4, 0xdc, 0x1c, 0x66, 0xd5, 0x77, 0xd4, 0x51,
	0x73, 0x7d, 0x7a, 0x7f, 0xb5, 0xa1, 0xf4, 0x3a, 0x0e, 0x47, 0x91, 0x24, 0x8f, 0xc0, 0xbd, 0x60,
	0x09, 0xe3, 0x78, 0x72, 0x5b, 0x9d, 0xdd, 0xb6, 0xee, 0x77, 0x6d, 0x0d, 0xb7, 0x9f, 0x29, 0x8c,
	0x6a, 0x0a, 0xd9, 0x57, 0x7e, 0x9a, 0xad, 0x36, 0x6f, 0x1d, 0xbb, 0xc4, 0xf1, 0x3f, 0xf9, 0x14,
	0x4a, 0x02, 0x3b, 0x10, 0xbe, 0x72, 0xd5, 0xce, 0x56, 0xce, 0xd6, 0x7d, 0x89, 0x1a, 0x94, 0x7c,
	0x4f, 0x6f, 0x08, 0x32, 0xd5, 0x3a, 0x6f, 0x33, 0xd5, 0x06, 0x19, 0x6a, 0x99, 0xeb, 0x03, 0xc6,
	0x78, 0x56, 0x3b, 0xdb, 0x39, 0xd3, 0x9c, 0x3b, 0xcd, 0x71, 0xf2, 0x7d, 0xf0, 0x78, 0x3f, 0x27,
	0x7f, 0x80, 0xb6, 0xb7, 0xc8, 0x15, 0x6e, 0x7e, 0x35, 0xbf, 0x03, 0xae, 0x5e, 0x74, 0x19, 0x1c,
	0x7a, 0x72, 0xbc, 0x53, 0x20, 0x1e, 0xb8, 0x3f, 0xa5, 0x27, 0x27, 0xa7, 0x3b, 0x16, 0xa9, 0x40,
	0xf1, 0xe8, 0xcb, 0x57, 0x27, 0x3b, 0x76, 0xf3, 0x4f, 0x36, 0x14, 0x5f, 0x06, 0x63, 0x41, 0x7e,
	0x04, 0xd5, 0x74, 0xa1, 0xd5, 0x59, 0xe8, 0xff, 0xad, 0xdc, 0x5f, 0x51, 0xda, 0x2f, 0xf3, 0xbe,
	0x77, 0x92, 0x49, 0x3e, 0xa5, 0x5e, 0x3a, 0xeb, 0x83, 0x4f, 0x61, 0x33, 0xc5, 0x6c, 0xe6, 0x4f,
	0x6d, 0xa3, 0xfc, 0xdb, 0xcb, 0x72, 0x95, 0x57, 0xfd, 0xd8, 0xda, 0xa0, 0x9a, 0xce, 0x2b, 0xf5,
	0x1f, 0xc3, 0xd6, 0xb2, 0x3f, 0xd9, 0x01, 0xe7, 0xd7, 0xd1, 0x14, 0x8f, 0xd1, 0xa1, 0xea, 0x27,
	0xd9, 0x05, 0xf7, 0x32, 0x48, 0x26, 0x11, 0xbe, 0x7e, 0x1e, 0xd5, 0x83, 0x27, 0xf6, 0x67, 0x56,
	0xfd, 0x14, 0x76, 0x56, 0xed, 0x17, 0xf5, 0x15, 0xad, 0xff, 0x64, 0x51, 0x7f, 0xfb, 0x50, 0xe6,
	0x7e, 0xcd, 0xbf, 0x5b, 0xb0, 0xf1, 0x52, 0x8c, 0x5e, 0xc7, 0xf2, 0xcd, 0xcf, 0xb3, 0x88, 0x0d,
	0xc9, 0x87, 0xe0, 0xca, 0x58, 0x26, 0x11, 0xda, 0x79, 0x2f, 0x0a, 0x54, 0x0f, 0x49, 0x0d, 0x4a,
	0x22, 0x48, 0x02, 0x3e, 0x45, 0x4f, 0xe7, 0x45, 0x81, 0x9a, 0x31, 0xa9, 0x43, 0xf9, 0x19, 0x9b,
	0xa8, 0x95, 0x60, 0x5b, 0x50, 0x9a, 0xbc, 0x40, 0x3e, 0x86, 0x8d, 0x37, 0x2c, 0x8d, 0xfa, 0x41,
	0x18, 0xf2, 0x48, 0x08, 0xec, 0x10, 0x8a, 0x50, 0x55, 0xd5, 0xa7, 0xba, 0x48, 0x4e, 0xe0, 0x5e,
	0x2a, 0x46, 0xfd, 0xab, 0x58, 0xbe, 0xe9, 0xf3, 0xe8, 0x37, 0x93, 0x98, 0x47, 0x21, 0x76, 0x8d,
	0x6a, 0xe7, 0xc1, 0x6c, 0x63, 0xf5, 0x1a, 0xa9, 0x81, 0x5f, 0x14, 0xe8, 0x76, 0xba, 0x5c, 0x3a,
	0x2a, 0x83, 0x3b, 0xc9, 0x62, 0x96, 0x35, 0x3f, 0x85, 0x22, 0x8d, 0x82, 0x64, 0xbe, 0x8b, 0x96,
	0x6e, 0x35, 0x38, 0x78, 0x54, 0xa9, 0x84, 0x3b, 0xd7, 0xd7, 0xd7, 0xd7, 0x76, 0xf3, 0x4a, 0x2d,
	0x5c, 0x6d, 0xc8, 0x5b, 0xf2, 0x10, 0xbc, 0x38, 0x0d, 0x46, 0x71, 0xa6, 0x1e, 0x50, 0xd3, 0xe7,
	0x85, 0xb9, 0xa4, 0x73, 0x0c, 0x5b, 0x3c, 0x0a, 0x92, 0x7e, 0xf4, 0x56, 0x46, 0x99, 0x88, 0x59,
	0x46, 0x36, 0xe6, 0xc9, 0x0c, 0x92, 0xda, 0x6f, 0x97, 0xa3, 0x6d, 0xec, 0xe9, 0xa6, 0x12, 0x9d,
	0xe4, 0x9a, 0xe6, 0xdf, 0x5c, 0x80, 0x2f, 0x32, 0x76, 0x95, 0x9d, 0x4f, 0xc7, 0x91, 0x20, 0x9f,
	0x80, 0x1d, 0x64, 0x78, 0xc7, 0x54, 0x3b, 0xbb, 0x6d, 0xfd, 0xcd, 0xd0, 0xce, 0xbf, 0x19, 0xda,
	0x4f, 0xb3, 0x29, 0xb5, 0x83, 0x8c, 0x3c, 0x06, 0x27, 0x9c, 0xe8, 0x97, 0xbd, 0xda, 0xd9, 0xbb,
	0x45, 0x3b, 0x36, 0x5f, 0x2e, 0x54, 0xb1, 0xc8, 0x77, 0xc1, 0x16, 0x12, 0xaf, 0x3c, 0xb5, 0x87,
	0xab, 0xdc, 0x33, 0xfc, 0x8a, 0xa1, 0xb6, 0x50, 0x4d, 0xc4, 0x96, 0xc2, 0xc4, 0xa4, 0x7e, 0x8b,
	0x78, 0x9e, 0x7f, 0xd0, 0x50, 0x5b, 0x0a, 0xc5, 0x4d, 0x2e, 0xf1, 0xba, 0xbb, 0x8b, 0xfb, 0x65,
	0x2c, 0xe4, 0x2f, 0xd5, 0x0e, 0x53, 0x3b, 0xb9, 0x24, 0x2d, 0x70, 0x2e, 0x83, 0x04, 0xaf, 0xbf,
	0x6a, 0xe7, 0xc3, 0x5b, 0x64, 0x4d, 0x54, 0x14, 0xd2, 0x06, 0x27, 0x1c, 0x24, 0x18, 0x9d, 0x6a,
	0xe7, 0xe1, 0xed, 0xe7, 0xc2, 0x5e, 0x69, 0xf8, 0xe1, 0x20, 0x21, 0xfb, 0xe0, 0x0c, 0x13, 0x89,
	0x49, 0x52, 0xef, 0xed, 0x2a, 0x1f, 0xbb, 0xae, 0xa1, 0x0f, 0x13, 0xa9, 0xe8, 0x31, 0x36, 0xf9,
	0xbb, 0xe9, 0xf8, 0x26, 0x1a, 0x7a, 0xdc, 0xeb, 0xaa, 0xd5, 0x4c, 0x7a, 0x5d, 0xbc, 0x9c, 0xee,
	0x5a, 0xcd, 0xab, 0x45, 0xfe, 0xa4, 0xd7, 0x45, 0xfb, 0xc3, 0x0e, 0x7e, 0xf4, 0xac, 0xb1, 0x3f,
	0xec, 0xe4, 0xf6, 0x87, 0x1d, 0xb4, 0x3f, 0xec, 0xe0, 0x57, 0xd0, 0x3a, 0xfb, 0x19, 0x7f, 0x82,
	0xfc, 0x22, 0xde, 0x84, 0xde, 0x9a, 0x4d, 0x57, 0xad, 0x40, 0xd3, 0x91, 0xa7, 0xfc, 0x55, 0x53,
	0x83, 0x35, 0xfe, 0xfa, 0x76, 0x31, 0xfe, 0x42, 0x72, 0xf2, 0x03, 0x70, 0xf3, 0x5b, 0xe6, 0xee,
	0x07, 0xc0, 0x5b, 0x47, 0x0b, 0x34, 0xb3, 0xf9, 0x31, 0x6c, 0xaf, 0xbc, 0x8c, 0xaa, 0x01, 0xe9,
	0x56, 0x6a, 0xb7, 0x3c, 0xf4, 0x6d, 0xfe, 0xd9, 0x86, 0x07, 0x86, 0xf5, 0x79, 0x16, 0xc6, 0x3c,
	0xba, 0x90, 0x33, 0xf6, 0x63, 0x28, 0x8a, 0xc9, 0x20, 0x35, 0x49, 0x5e, 0xf7, 0x86, 0x53, 0x24,
	0x91, 0x9f, 0x81, 0x97, 0x06, 0xe3, 0xfe, 0x30, 0x8e, 0x92, 0xd0, 0x34, 0xdb, 0xfd, 0x15, 0xc5,
	0xea, 0x04, 0xaa, 0x09, 0x3f, 0x57, 0x7c, 0xdd, 0x7c, 0x2b, 0xa9, 0x19, 0x92, 0xcf, 0xa0, 0x2a,
	0x92, 0xf8, 0x22, 0x32, 0x6e, 0x0e, 0xba, 0xad, 0x9d, 0x1f, 0x90, 0x8b, 0xca, 0xfa, 0x39, 0x6c,
	0x2e, 0x99, 0x2e, 0xb6, 0x5c, 0x4f, 0xb7, 0xdc, 0xfd, 0xe5, 0x96, 0xbb, 0xd6, 0x76, 0xa1, 0xf7,
	0x3e, 0x82, 0xdd, 0x15, 0x54, 0x7f, 0xce, 0x11, 0x28, 0x0e, 0xa6, 0x52, 0xe0, 0x7e, 0x6e, 0x50,
	0xfc, 0xdd, 0x3c, 0x06, 0xb2, 0xc2, 0x7d, 0xfd, 0xc5, 0x79, 0x7e, 0xdc, 0x8a, 0xf8, 0xff, 0x1c,
	0xf7, 0x13, 0x1f, 0x8a, 0x59, 0x90, 0x46, 0x2b, 0x4d, 0xeb, 0x77, 0xf8, 0x14, 0x88, 0x3c, 0xf9,
	0x21, 0x14, 0xa3, 0xb7, 0x32, 0x5d, 0x61, 0xfc, 0xfe, 0x7f, 0x1c, 0x95, 0x92, 0x1c, 0xf9, 0x5f,
	0xff, 0xbb, 0x51, 0xf8, 0xfa, 0xa6, 0x61, 0x7d, 0x73, 0xd3, 0xb0, 0xde, 0xdd, 0x34, 0xac, 0x7f,
	0xdd, 0x34, 0xac, 0x3f, 0xbc, 0x6f, 0x14, 0xbe, 0x79, 0xdf, 0x28, 0xbc, 0x7b, 0xdf, 0x28, 0xfc,
	0xca, 0xfd, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xcc, 0x59, 0x2d, 0xd6, 0x0d, 0x00, 0x00,
}

func (m *Simple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Simple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Simple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OCastBytes != nil {
		i -= len(m.OCastBytes)
		copy(dAtA[i:], m.OCastBytes)
		i = encodeVarintTestObjects(dAtA, i, uint64(len(m.OCastBytes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.OBytes != nil {
		i -= len(m.OBytes)
		copy(dAtA[i:], m.OBytes)
		i = encodeVarintTestObjects(dAtA, i, uint64(len(m.OBytes)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OString != nil {
		i -= len(*m.OString)
		copy(dAtA[i:], *m.OString)
		i = encodeVarintTestObjects(dAtA, i, uint64(len(*m.OString)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ODoubleStr != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ODoubleStr))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.ODouble != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.ODouble))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.OFloatStr != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OFloatStr))))
		i--
		dAtA[i] = 0x7d
	}
	if m.OFloat != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.OFloat))))
		i--
		dAtA[i] = 0x75
	}
	if m.OSint64Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64((uint64(*m.OSint64Str)<<1)^uint64((*m.OSint64Str>>63))))
		i--
		dAtA[i] = 0x68
	}
	if m.OSint64 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64((uint64(*m.OSint64)<<1)^uint64((*m.OSint64>>63))))
		i--
		dAtA[i] = 0x60
	}
	if m.OSint32Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64((uint32(*m.OSint32Str)<<1)^uint32((*m.OSint32Str>>31))))
		i--
		dAtA[i] = 0x58
	}
	if m.OSint32 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64((uint32(*m.OSint32)<<1)^uint32((*m.OSint32>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.OUint64Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OUint64Str))
		i--
		dAtA[i] = 0x48
	}
	if m.OUint64 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OUint64))
		i--
		dAtA[i] = 0x40
	}
	if m.OUint32Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OUint32Str))
		i--
		dAtA[i] = 0x38
	}
	if m.OUint32 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OUint32))
		i--
		dAtA[i] = 0x30
	}
	if m.OInt64Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OInt64Str))
		i--
		dAtA[i] = 0x28
	}
	if m.OInt64 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OInt64))
		i--
		dAtA[i] = 0x20
	}
	if m.OInt32Str != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OInt32Str))
		i--
		dAtA[i] = 0x18
	}
	if m.OInt32 != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.OInt32))
		i--
		dAtA[i] = 0x10
	}
	if m.OBool != nil {
		i--
		if *m.OBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NonFinites) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NonFinites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NonFinites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DNinf != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DNinf))))
		i--
		dAtA[i] = 0x31
	}
	if m.DPinf != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DPinf))))
		i--
		dAtA[i] = 0x29
	}
	if m.DNan != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DNan))))
		i--
		dAtA[i] = 0x21
	}
	if m.FNinf != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FNinf))))
		i--
		dAtA[i] = 0x1d
	}
	if m.FPinf != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FPinf))))
		i--
		dAtA[i] = 0x15
	}
	if m.FNan != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FNan))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Repeats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repeats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repeats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RBytes) > 0 {
		for iNdEx := len(m.RBytes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RBytes[iNdEx])
			copy(dAtA[i:], m.RBytes[iNdEx])
			i = encodeVarintTestObjects(dAtA, i, uint64(len(m.RBytes[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.RString) > 0 {
		for iNdEx := len(m.RString) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RString[iNdEx])
			copy(dAtA[i:], m.RString[iNdEx])
			i = encodeVarintTestObjects(dAtA, i, uint64(len(m.RString[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.RDouble) > 0 {
		for iNdEx := len(m.RDouble) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.RDouble[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x49
		}
	}
	if len(m.RFloat) > 0 {
		for iNdEx := len(m.RFloat) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.RFloat[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x45
		}
	}
	if len(m.RSint64) > 0 {
		for iNdEx := len(m.RSint64) - 1; iNdEx >= 0; iNdEx-- {
			x3 := (uint64(m.RSint64[iNdEx]) << 1) ^ uint64((m.RSint64[iNdEx] >> 63))
			i = encodeVarintTestObjects(dAtA, i, uint64(x3))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.RSint32) > 0 {
		for iNdEx := len(m.RSint32) - 1; iNdEx >= 0; iNdEx-- {
			x4 := (uint32(m.RSint32[iNdEx]) << 1) ^ uint32((m.RSint32[iNdEx] >> 31))
			i = encodeVarintTestObjects(dAtA, i, uint64(x4))
			i--
			dAtA[i] = 0x30
		}
	}
	if len(m.RUint64) > 0 {
		for iNdEx := len(m.RUint64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTestObjects(dAtA, i, uint64(m.RUint64[iNdEx]))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.RUint32) > 0 {
		for iNdEx := len(m.RUint32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTestObjects(dAtA, i, uint64(m.RUint32[iNdEx]))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.RInt64) > 0 {
		for iNdEx := len(m.RInt64) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTestObjects(dAtA, i, uint64(m.RInt64[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.RInt32) > 0 {
		for iNdEx := len(m.RInt32) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTestObjects(dAtA, i, uint64(m.RInt32[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	if len(m.RBool) > 0 {
		for iNdEx := len(m.RBool) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.RBool[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *Widget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Widget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Widget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RRepeats) > 0 {
		for iNdEx := len(m.RRepeats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RRepeats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestObjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.Repeats != nil {
		{
			size, err := m.Repeats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.RSimple) > 0 {
		for iNdEx := len(m.RSimple) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RSimple[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestObjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Simple != nil {
		{
			size, err := m.Simple.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.RColor) > 0 {
		for iNdEx := len(m.RColor) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintTestObjects(dAtA, i, uint64(m.RColor[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	if m.Color != nil {
		i = encodeVarintTestObjects(dAtA, i, uint64(*m.Color))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Maps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Maps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Maps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MBoolSimple) > 0 {
		keysForMBoolSimple := make([]bool, 0, len(m.MBoolSimple))
		for k := range m.MBoolSimple {
			keysForMBoolSimple = append(keysForMBoolSimple, bool(k))
		}
		github_com_gogo_protobuf_sortkeys.Bools(keysForMBoolSimple)
		for iNdEx := len(keysForMBoolSimple) - 1; iNdEx >= 0; iNdEx-- {
			v := m.MBoolSimple[bool(keysForMBoolSimple[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTestObjects(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i--
			if keysForMBoolSimple[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
			i = encodeVarintTestObjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MInt64Str) > 0 {
		keysForMInt64Str := make([]int64, 0, len(m.MInt64Str))
		for k := range m.MInt64Str {
			keysForMInt64Str = append(keysForMInt64Str, int64(k))
		}
		github_com_gogo_protobuf_sortkeys.Int64s(keysForMInt64Str)
		for iNdEx := len(keysForMInt64Str) - 1; iNdEx >= 0; iNdEx-- {
			v := m.MInt64Str[int64(keysForMInt64Str[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTestObjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintTestObjects(dAtA, i, uint64(keysForMInt64Str[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTestObjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithOneof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithOneof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		{
			size := m.Union.Size()
			i -= size
			if _, err := m.Union.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithOneof_Title) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof_Title) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintTestObjects(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *MsgWithOneof_Salary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof_Salary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTestObjects(dAtA, i, uint64(m.Salary))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MsgWithOneof_Country) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof_Country) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Country)
	copy(dAtA[i:], m.Country)
	i = encodeVarintTestObjects(dAtA, i, uint64(len(m.Country)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *MsgWithOneof_HomeAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof_HomeAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HomeAddress)
	copy(dAtA[i:], m.HomeAddress)
	i = encodeVarintTestObjects(dAtA, i, uint64(len(m.HomeAddress)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *MsgWithOneof_MsgWithRequired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithOneof_MsgWithRequired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MsgWithRequired != nil {
		{
			size, err := m.MsgWithRequired.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Real) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Real) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Real) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.Value != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Complex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Complex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Complex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if n, err := github_com_gogo_protobuf_proto.EncodeInternalExtensionBackwards(m, dAtA[:i]); err != nil {
		return 0, err
	} else {
		i -= n
	}
	if m.Imaginary != nil {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Imaginary))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *KnownTypes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KnownTypes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KnownTypes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Lv != nil {
		{
			size, err := m.Lv.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.An != nil {
		{
			size, err := m.An.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.St != nil {
		{
			size, err := m.St.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Bytes != nil {
		{
			size, err := m.Bytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Str != nil {
		{
			size, err := m.Str.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Bool != nil {
		{
			size, err := m.Bool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.U32 != nil {
		{
			size, err := m.U32.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.I32 != nil {
		{
			size, err := m.I32.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.U64 != nil {
		{
			size, err := m.U64.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.I64 != nil {
		{
			size, err := m.I64.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Flt != nil {
		{
			size, err := m.Flt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Dbl != nil {
		{
			size, err := m.Dbl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ts != nil {
		{
			size, err := m.Ts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Dur != nil {
		{
			size, err := m.Dur.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithRequired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithRequired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithRequired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Str == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("str")
	} else {
		i -= len(*m.Str)
		copy(dAtA[i:], *m.Str)
		i = encodeVarintTestObjects(dAtA, i, uint64(len(*m.Str)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithIndirectRequired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithIndirectRequired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithIndirectRequired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SliceField) > 0 {
		for iNdEx := len(m.SliceField) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SliceField[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestObjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MapField) > 0 {
		keysForMapField := make([]string, 0, len(m.MapField))
		for k := range m.MapField {
			keysForMapField = append(keysForMapField, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMapField)
		for iNdEx := len(keysForMapField) - 1; iNdEx >= 0; iNdEx-- {
			v := m.MapField[string(keysForMapField[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTestObjects(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForMapField[iNdEx])
			copy(dAtA[i:], keysForMapField[iNdEx])
			i = encodeVarintTestObjects(dAtA, i, uint64(len(keysForMapField[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTestObjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Subm != nil {
		{
			size, err := m.Subm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithRequiredBytes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithRequiredBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithRequiredBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Byts == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("byts")
	} else {
		i -= len(m.Byts)
		copy(dAtA[i:], m.Byts)
		i = encodeVarintTestObjects(dAtA, i, uint64(len(m.Byts)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithRequiredWKT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithRequiredWKT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithRequiredWKT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Str == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("str")
	} else {
		{
			size, err := m.Str.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestObjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTestObjects(dAtA []byte, offset int, v uint64) int {
	offset -= sovTestObjects(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Simple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OBool != nil {
		n += 2
	}
	if m.OInt32 != nil {
		n += 1 + sovTestObjects(uint64(*m.OInt32))
	}
	if m.OInt32Str != nil {
		n += 1 + sovTestObjects(uint64(*m.OInt32Str))
	}
	if m.OInt64 != nil {
		n += 1 + sovTestObjects(uint64(*m.OInt64))
	}
	if m.OInt64Str != nil {
		n += 1 + sovTestObjects(uint64(*m.OInt64Str))
	}
	if m.OUint32 != nil {
		n += 1 + sovTestObjects(uint64(*m.OUint32))
	}
	if m.OUint32Str != nil {
		n += 1 + sovTestObjects(uint64(*m.OUint32Str))
	}
	if m.OUint64 != nil {
		n += 1 + sovTestObjects(uint64(*m.OUint64))
	}
	if m.OUint64Str != nil {
		n += 1 + sovTestObjects(uint64(*m.OUint64Str))
	}
	if m.OSint32 != nil {
		n += 1 + sozTestObjects(uint64(*m.OSint32))
	}
	if m.OSint32Str != nil {
		n += 1 + sozTestObjects(uint64(*m.OSint32Str))
	}
	if m.OSint64 != nil {
		n += 1 + sozTestObjects(uint64(*m.OSint64))
	}
	if m.OSint64Str != nil {
		n += 1 + sozTestObjects(uint64(*m.OSint64Str))
	}
	if m.OFloat != nil {
		n += 5
	}
	if m.OFloatStr != nil {
		n += 5
	}
	if m.ODouble != nil {
		n += 10
	}
	if m.ODoubleStr != nil {
		n += 10
	}
	if m.OString != nil {
		l = len(*m.OString)
		n += 2 + l + sovTestObjects(uint64(l))
	}
	if m.OBytes != nil {
		l = len(m.OBytes)
		n += 2 + l + sovTestObjects(uint64(l))
	}
	if m.OCastBytes != nil {
		l = len(m.OCastBytes)
		n += 2 + l + sovTestObjects(uint64(l))
	}
	return n
}

func (m *NonFinites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FNan != nil {
		n += 5
	}
	if m.FPinf != nil {
		n += 5
	}
	if m.FNinf != nil {
		n += 5
	}
	if m.DNan != nil {
		n += 9
	}
	if m.DPinf != nil {
		n += 9
	}
	if m.DNinf != nil {
		n += 9
	}
	return n
}

func (m *Repeats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RBool) > 0 {
		n += 2 * len(m.RBool)
	}
	if len(m.RInt32) > 0 {
		for _, e := range m.RInt32 {
			n += 1 + sovTestObjects(uint64(e))
		}
	}
	if len(m.RInt64) > 0 {
		for _, e := range m.RInt64 {
			n += 1 + sovTestObjects(uint64(e))
		}
	}
	if len(m.RUint32) > 0 {
		for _, e := range m.RUint32 {
			n += 1 + sovTestObjects(uint64(e))
		}
	}
	if len(m.RUint64) > 0 {
		for _, e := range m.RUint64 {
			n += 1 + sovTestObjects(uint64(e))
		}
	}
	if len(m.RSint32) > 0 {
		for _, e := range m.RSint32 {
			n += 1 + sozTestObjects(uint64(e))
		}
	}
	if len(m.RSint64) > 0 {
		for _, e := range m.RSint64 {
			n += 1 + sozTestObjects(uint64(e))
		}
	}
	if len(m.RFloat) > 0 {
		n += 5 * len(m.RFloat)
	}
	if len(m.RDouble) > 0 {
		n += 9 * len(m.RDouble)
	}
	if len(m.RString) > 0 {
		for _, s := range m.RString {
			l = len(s)
			n += 1 + l + sovTestObjects(uint64(l))
		}
	}
	if len(m.RBytes) > 0 {
		for _, b := range m.RBytes {
			l = len(b)
			n += 1 + l + sovTestObjects(uint64(l))
		}
	}
	return n
}

func (m *Widget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != nil {
		n += 1 + sovTestObjects(uint64(*m.Color))
	}
	if len(m.RColor) > 0 {
		for _, e := range m.RColor {
			n += 1 + sovTestObjects(uint64(e))
		}
	}
	if m.Simple != nil {
		l = m.Simple.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if len(m.RSimple) > 0 {
		for _, e := range m.RSimple {
			l = e.Size()
			n += 1 + l + sovTestObjects(uint64(l))
		}
	}
	if m.Repeats != nil {
		l = m.Repeats.Size()
		n += 2 + l + sovTestObjects(uint64(l))
	}
	if len(m.RRepeats) > 0 {
		for _, e := range m.RRepeats {
			l = e.Size()
			n += 2 + l + sovTestObjects(uint64(l))
		}
	}
	return n
}

func (m *Maps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MInt64Str) > 0 {
		for k, v := range m.MInt64Str {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTestObjects(uint64(k)) + 1 + len(v) + sovTestObjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovTestObjects(uint64(mapEntrySize))
		}
	}
	if len(m.MBoolSimple) > 0 {
		for k, v := range m.MBoolSimple {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTestObjects(uint64(l))
			}
			mapEntrySize := 1 + 1 + l
			n += mapEntrySize + 1 + sovTestObjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgWithOneof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *MsgWithOneof_Title) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovTestObjects(uint64(l))
	return n
}
func (m *MsgWithOneof_Salary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTestObjects(uint64(m.Salary))
	return n
}
func (m *MsgWithOneof_Country) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Country)
	n += 1 + l + sovTestObjects(uint64(l))
	return n
}
func (m *MsgWithOneof_HomeAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HomeAddress)
	n += 1 + l + sovTestObjects(uint64(l))
	return n
}
func (m *MsgWithOneof_MsgWithRequired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgWithRequired != nil {
		l = m.MsgWithRequired.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	return n
}
func (m *Real) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += 9
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *Complex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Imaginary != nil {
		n += 9
	}
	n += github_com_gogo_protobuf_proto.SizeOfInternalExtension(m)
	return n
}

func (m *KnownTypes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dur != nil {
		l = m.Dur.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Ts != nil {
		l = m.Ts.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Dbl != nil {
		l = m.Dbl.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Flt != nil {
		l = m.Flt.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.I64 != nil {
		l = m.I64.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.U64 != nil {
		l = m.U64.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.I32 != nil {
		l = m.I32.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.U32 != nil {
		l = m.U32.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Bool != nil {
		l = m.Bool.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Str != nil {
		l = m.Str.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Bytes != nil {
		l = m.Bytes.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.St != nil {
		l = m.St.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.An != nil {
		l = m.An.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Lv != nil {
		l = m.Lv.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 2 + l + sovTestObjects(uint64(l))
	}
	return n
}

func (m *MsgWithRequired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Str != nil {
		l = len(*m.Str)
		n += 1 + l + sovTestObjects(uint64(l))
	}
	return n
}

func (m *MsgWithIndirectRequired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subm != nil {
		l = m.Subm.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	if len(m.MapField) > 0 {
		for k, v := range m.MapField {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTestObjects(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTestObjects(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTestObjects(uint64(mapEntrySize))
		}
	}
	if len(m.SliceField) > 0 {
		for _, e := range m.SliceField {
			l = e.Size()
			n += 1 + l + sovTestObjects(uint64(l))
		}
	}
	return n
}

func (m *MsgWithRequiredBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Byts != nil {
		l = len(m.Byts)
		n += 1 + l + sovTestObjects(uint64(l))
	}
	return n
}

func (m *MsgWithRequiredWKT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Str != nil {
		l = m.Str.Size()
		n += 1 + l + sovTestObjects(uint64(l))
	}
	return n
}

func sovTestObjects(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTestObjects(x uint64) (n int) {
	return sovTestObjects(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Simple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Simple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Simple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OBool = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OInt32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OInt32 = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OInt32Str", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OInt32Str = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OInt64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OInt64 = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OInt64Str", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OInt64Str = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OUint32 = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUint32Str", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OUint32Str = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OUint64 = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OUint64Str", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OUint64Str = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OSint32 = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSint32Str", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OSint32Str = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.OSint64 = &v2
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSint64Str", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.OSint64Str = &v2
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OFloat = &v2
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OFloatStr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.OFloatStr = &v2
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ODouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ODouble = &v2
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ODoubleStr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.ODoubleStr = &v2
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OString = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OBytes = append(m.OBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OBytes == nil {
				m.OBytes = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OCastBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OCastBytes = append(m.OCastBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OCastBytes == nil {
				m.OCastBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NonFinites) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NonFinites: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NonFinites: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FNan", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FNan = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FPinf", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FPinf = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FNinf", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FNinf = &v2
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNan", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DNan = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DPinf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DPinf = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNinf", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DNinf = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repeats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repeats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repeats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RBool = append(m.RBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.RBool) == 0 {
					m.RBool = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RBool = append(m.RBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RBool", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RInt32 = append(m.RInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RInt32) == 0 {
					m.RInt32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RInt32 = append(m.RInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RInt32", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RInt64 = append(m.RInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RInt64) == 0 {
					m.RInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RInt64 = append(m.RInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RInt64", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RUint32 = append(m.RUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RUint32) == 0 {
					m.RUint32 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RUint32 = append(m.RUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RUint32", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RUint64 = append(m.RUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RUint64) == 0 {
					m.RUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RUint64 = append(m.RUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RUint64", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RSint32 = append(m.RSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RSint32) == 0 {
					m.RSint32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RSint32 = append(m.RSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RSint32", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RSint64 = append(m.RSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RSint64) == 0 {
					m.RSint64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RSint64 = append(m.RSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RSint64", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.RFloat = append(m.RFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.RFloat) == 0 {
					m.RFloat = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.RFloat = append(m.RFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RFloat", wireType)
			}
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.RDouble = append(m.RDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.RDouble) == 0 {
					m.RDouble = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.RDouble = append(m.RDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RDouble", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RString = append(m.RString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RBytes = append(m.RBytes, make([]byte, postIndex-iNdEx))
			copy(m.RBytes[len(m.RBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Widget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Widget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Widget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var v Widget_Color
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Widget_Color(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Color = &v
		case 2:
			if wireType == 0 {
				var v Widget_Color
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Widget_Color(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RColor = append(m.RColor, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTestObjects
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTestObjects
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RColor) == 0 {
					m.RColor = make([]Widget_Color, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Widget_Color
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Widget_Color(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RColor = append(m.RColor, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RColor", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Simple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Simple == nil {
				m.Simple = &Simple{}
			}
			if err := m.Simple.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSimple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RSimple = append(m.RSimple, &Simple{})
			if err := m.RSimple[len(m.RSimple)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repeats == nil {
				m.Repeats = &Repeats{}
			}
			if err := m.Repeats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRepeats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RRepeats = append(m.RRepeats, &Repeats{})
			if err := m.RRepeats[len(m.RRepeats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Maps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Maps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Maps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MInt64Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MInt64Str == nil {
				m.MInt64Str = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTestObjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTestObjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestObjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTestObjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MInt64Str[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MBoolSimple", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MBoolSimple == nil {
				m.MBoolSimple = make(map[bool]*Simple)
			}
			var mapkey bool
			var mapvalue *Simple
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTestObjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTestObjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Simple{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestObjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTestObjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MBoolSimple[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithOneof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithOneof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithOneof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = &MsgWithOneof_Title{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salary", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Union = &MsgWithOneof_Salary{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = &MsgWithOneof_Country{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = &MsgWithOneof_HomeAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgWithRequired", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgWithRequired{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &MsgWithOneof_MsgWithRequired{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Real) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Real: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Real: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		default:
			if (fieldNum >= 100) && (fieldNum < 536870912) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipTestObjects(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthTestObjects
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipTestObjects(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthTestObjects
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Complex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Complex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Complex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imaginary", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Imaginary = &v2
		default:
			if (fieldNum >= 100) && (fieldNum < 536870912) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipTestObjects(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthTestObjects
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				github_com_gogo_protobuf_proto.AppendExtension(m, int32(fieldNum), dAtA[iNdEx:iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipTestObjects(dAtA[iNdEx:])
				if err != nil {
					return err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return ErrInvalidLengthTestObjects
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += skippy
			}
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KnownTypes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KnownTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KnownTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dur", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dur == nil {
				m.Dur = &types.Duration{}
			}
			if err := m.Dur.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &types.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbl == nil {
				m.Dbl = &types.DoubleValue{}
			}
			if err := m.Dbl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flt == nil {
				m.Flt = &types.FloatValue{}
			}
			if err := m.Flt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.I64 == nil {
				m.I64 = &types.Int64Value{}
			}
			if err := m.I64.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.U64 == nil {
				m.U64 = &types.UInt64Value{}
			}
			if err := m.U64.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.I32 == nil {
				m.I32 = &types.Int32Value{}
			}
			if err := m.I32.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.U32 == nil {
				m.U32 = &types.UInt32Value{}
			}
			if err := m.U32.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bool == nil {
				m.Bool = &types.BoolValue{}
			}
			if err := m.Bool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Str == nil {
				m.Str = &types.StringValue{}
			}
			if err := m.Str.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bytes == nil {
				m.Bytes = &types.BytesValue{}
			}
			if err := m.Bytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field St", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.St == nil {
				m.St = &types.Struct{}
			}
			if err := m.St.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field An", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.An == nil {
				m.An = &types.Any{}
			}
			if err := m.An.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lv == nil {
				m.Lv = &types.ListValue{}
			}
			if err := m.Lv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &types.Value{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithRequired) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithRequired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithRequired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Str = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("str")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithIndirectRequired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithIndirectRequired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithIndirectRequired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subm == nil {
				m.Subm = &MsgWithRequired{}
			}
			if err := m.Subm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapField == nil {
				m.MapField = make(map[string]*MsgWithRequired)
			}
			var mapkey string
			var mapvalue *MsgWithRequired
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestObjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestObjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTestObjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestObjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTestObjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTestObjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MsgWithRequired{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestObjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTestObjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapField[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliceField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SliceField = append(m.SliceField, &MsgWithRequired{})
			if err := m.SliceField[len(m.SliceField)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithRequiredBytes) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithRequiredBytes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithRequiredBytes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Byts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Byts = append(m.Byts[:0], dAtA[iNdEx:postIndex]...)
			if m.Byts == nil {
				m.Byts = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("byts")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithRequiredWKT) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithRequiredWKT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithRequiredWKT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestObjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestObjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Str == nil {
				m.Str = &types.StringValue{}
			}
			if err := m.Str.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipTestObjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestObjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("str")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTestObjects(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTestObjects
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestObjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTestObjects
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTestObjects
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTestObjects
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTestObjects        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTestObjects          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTestObjects = fmt.Errorf("proto: unexpected end of group")
)
