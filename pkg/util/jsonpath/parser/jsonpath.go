// Code generated by goyacc -p jsonpath -o bazel-out/darwin_arm64-fastbuild/bin/pkg/util/jsonpath/parser/jsonpath.go jsonpath-gen.y. DO NOT EDIT.

//line jsonpath-gen.y:2
package parser

import __yyfmt__ "fmt"

//line jsonpath-gen.y:2

import (
	"strconv"

	"github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgcode"
	"github.com/cockroachdb/cockroach/pkg/sql/pgwire/pgerror"
	"github.com/cockroachdb/cockroach/pkg/sql/scanner"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/util/json"
	"github.com/cockroachdb/cockroach/pkg/util/jsonpath"
)

//line jsonpath-gen.y:18

func setErr(jsonpathlex jsonpathLexer, err error) int {
	jsonpathlex.(*lexer).setErr(err)
	return 1
}

func unimplemented(jsonpathlex jsonpathLexer, feature string) int {
	jsonpathlex.(*lexer).Unimplemented(feature)
	return 1
}

var _ scanner.ScanSymType = &jsonpathSymType{}

func (s *jsonpathSymType) jsonpathScanSymType() {}

func (s *jsonpathSymType) ID() int32 {
	return s.id
}

func (s *jsonpathSymType) SetID(id int32) {
	s.id = id
}

func (s *jsonpathSymType) Pos() int32 {
	return s.pos
}

func (s *jsonpathSymType) SetPos(pos int32) {
	s.pos = pos
}

func (s *jsonpathSymType) Str() string {
	return s.str
}

func (s *jsonpathSymType) SetStr(str string) {
	s.str = str
}

func (s *jsonpathSymType) UnionVal() interface{} {
	return s.union.val
}

func (s *jsonpathSymType) SetUnionVal(val interface{}) {
	s.union.val = val
}

type jsonpathSymUnion struct {
	val interface{}
}

func (u *jsonpathSymUnion) jsonpath() jsonpath.Jsonpath {
	return u.val.(jsonpath.Jsonpath)
}

func (u *jsonpathSymUnion) path() jsonpath.Path {
	return u.val.(jsonpath.Path)
}

func (u *jsonpathSymUnion) paths() jsonpath.Paths {
	return u.val.(jsonpath.Paths)
}

func (u *jsonpathSymUnion) pathArr() []jsonpath.Path {
	return u.val.([]jsonpath.Path)
}

func (u *jsonpathSymUnion) bool() bool {
	return u.val.(bool)
}

func (u *jsonpathSymUnion) numVal() *tree.NumVal {
	return u.val.(*tree.NumVal)
}

func (u *jsonpathSymUnion) arrayList() jsonpath.ArrayList {
	return u.val.(jsonpath.ArrayList)
}

func (u *jsonpathSymUnion) operationType() jsonpath.OperationType {
	return u.val.(jsonpath.OperationType)
}

//line jsonpath-gen.y:112

func binaryOp(op jsonpath.OperationType, left jsonpath.Path, right jsonpath.Path) jsonpath.Operation {
	return jsonpath.Operation{
		Type:  op,
		Left:  left,
		Right: right,
	}
}

func unaryOp(op jsonpath.OperationType, left jsonpath.Path) jsonpath.Path {
	if scalar, ok := maybeNormalizeUnaryOp(op, left); ok {
		return scalar
	}
	return jsonpath.Operation{
		Type:  op,
		Left:  left,
		Right: nil,
	}
}

func maybeNormalizeUnaryOp(op jsonpath.OperationType, expr jsonpath.Path) (jsonpath.Scalar, bool) {

	if op != jsonpath.OpPlus && op != jsonpath.OpMinus {
		return jsonpath.Scalar{}, false
	}

	scalar, ok := extractNumericScalar(expr)
	if !ok {
		return jsonpath.Scalar{}, false
	}
	if op == jsonpath.OpMinus {
		dec, _ := scalar.Value.AsDecimal()
		dec.Neg(dec)
		scalar.Value = json.FromDecimal(*dec)
	}
	return scalar, true
}

func extractNumericScalar(expr jsonpath.Path) (jsonpath.Scalar, bool) {
	potentialScalar := expr
	if paths, ok := expr.(jsonpath.Paths); ok {
		if len(paths) != 1 {
			return jsonpath.Scalar{}, false
		}
		potentialScalar = paths[0]
	}
	scalar, ok := potentialScalar.(jsonpath.Scalar)
	if !ok {
		return jsonpath.Scalar{}, false
	}
	if scalar.Type != jsonpath.ScalarFloat && scalar.Type != jsonpath.ScalarInt {
		return jsonpath.Scalar{}, false
	}
	return scalar, true
}

func regexBinaryOp(left jsonpath.Path, regex string, flags string) (jsonpath.Operation, error) {
	goFlags, err := jsonpath.RegexFlagsToGoFlags(flags)
	if err != nil {
		return jsonpath.Operation{}, err
	}
	r := jsonpath.Regex{Regex: regex, Flags: goFlags}
	_, err = ReCache.GetRegexpWithFlags(r, goFlags)
	if err != nil {
		return jsonpath.Operation{}, pgerror.Wrapf(err, pgcode.InvalidRegularExpression,
			"invalid regular expression")
	}
	return binaryOp(jsonpath.OpLikeRegex, left, r), nil
}

//line jsonpath-gen.y:190
type jsonpathSymType struct {
	yys   int
	id    int32
	pos   int32
	str   string
	union jsonpathSymUnion
}

const IDENT = 57346
const UIDENT = 57347
const FCONST = 57348
const SCONST = 57349
const USCONST = 57350
const BCONST = 57351
const XCONST = 57352
const Op = 57353
const ICONST = 57354
const PARAM = 57355
const TYPECAST = 57356
const DOT_DOT = 57357
const COLON_EQUALS = 57358
const EQUALS_GREATER = 57359
const LESS_EQUALS = 57360
const GREATER_EQUALS = 57361
const NOT_EQUALS = 57362
const ERROR = 57363
const STRICT = 57364
const LAX = 57365
const ROOT = 57366
const CURRENT = 57367
const VARIABLE = 57368
const STR = 57369
const NULL = 57370
const TRUE = 57371
const FALSE = 57372
const EQUAL = 57373
const NOT_EQUAL = 57374
const LESS = 57375
const LESS_EQUAL = 57376
const GREATER = 57377
const GREATER_EQUAL = 57378
const AND = 57379
const OR = 57380
const NOT = 57381
const LIKE_REGEX = 57382
const FLAG = 57383
const TO = 57384
const LAST = 57385
const EXISTS = 57386
const IS = 57387
const UNKNOWN = 57388
const STARTS = 57389
const WITH = 57390
const ANY = 57391
const SIZE = 57392
const TYPE = 57393
const KEYVALUE = 57394
const ABS = 57395
const CEILING = 57396
const FLOOR = 57397
const BIGINT = 57398
const BOOLEAN = 57399
const DATE = 57400
const DOUBLE = 57401
const INTEGER = 57402
const NUMBER = 57403
const STRING = 57404
const DECIMAL = 57405
const DATETIME = 57406
const TIME = 57407
const TIME_TZ = 57408
const TIMESTAMP = 57409
const TIMESTAMP_TZ = 57410
const UMINUS = 57411

var jsonpathToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"IDENT",
	"UIDENT",
	"FCONST",
	"SCONST",
	"USCONST",
	"BCONST",
	"XCONST",
	"Op",
	"ICONST",
	"PARAM",
	"TYPECAST",
	"DOT_DOT",
	"COLON_EQUALS",
	"EQUALS_GREATER",
	"LESS_EQUALS",
	"GREATER_EQUALS",
	"NOT_EQUALS",
	"ERROR",
	"STRICT",
	"LAX",
	"ROOT",
	"CURRENT",
	"VARIABLE",
	"STR",
	"NULL",
	"TRUE",
	"FALSE",
	"EQUAL",
	"NOT_EQUAL",
	"LESS",
	"LESS_EQUAL",
	"GREATER",
	"GREATER_EQUAL",
	"AND",
	"OR",
	"NOT",
	"LIKE_REGEX",
	"FLAG",
	"TO",
	"LAST",
	"EXISTS",
	"IS",
	"UNKNOWN",
	"STARTS",
	"WITH",
	"ANY",
	"SIZE",
	"TYPE",
	"KEYVALUE",
	"ABS",
	"CEILING",
	"FLOOR",
	"BIGINT",
	"BOOLEAN",
	"DATE",
	"DOUBLE",
	"INTEGER",
	"NUMBER",
	"STRING",
	"DECIMAL",
	"DATETIME",
	"TIME",
	"TIME_TZ",
	"TIMESTAMP",
	"TIMESTAMP_TZ",
	"'+'",
	"'-'",
	"'*'",
	"'/'",
	"'%'",
	"UMINUS",
	"'('",
	"')'",
	"'.'",
	"'?'",
	"'['",
	"']'",
	"','",
	"'{'",
	"'}'",
}

var jsonpathStatenames = [...]string{}

const jsonpathEofCode = 1
const jsonpathErrCode = 2
const jsonpathInitialStackSize = 16

//line jsonpath-gen.y:804

//line yacctab:1
var jsonpathExca = [...]int16{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 78,
	75, 63,
	-2, 124,
	-1, 79,
	75, 64,
	-2, 134,
	-1, 80,
	75, 65,
	-2, 118,
	-1, 81,
	75, 66,
	-2, 104,
	-1, 82,
	75, 67,
	-2, 107,
	-1, 83,
	75, 68,
	-2, 115,
	-1, 84,
	75, 69,
	-2, 105,
	-1, 85,
	75, 70,
	-2, 106,
	-1, 86,
	75, 71,
	-2, 108,
	-1, 87,
	75, 72,
	-2, 111,
	-1, 88,
	75, 73,
	-2, 116,
	-1, 89,
	75, 74,
	-2, 123,
	-1, 90,
	75, 75,
	-2, 127,
}

const jsonpathPrivate = 57344

const jsonpathLast = 252

var jsonpathAct = [...]uint8{
	160, 147, 65, 154, 113, 6, 138, 177, 180, 7,
	134, 135, 48, 50, 52, 43, 131, 168, 133, 49,
	44, 46, 47, 139, 175, 174, 41, 42, 173, 172,
	56, 57, 58, 59, 60, 61, 171, 35, 36, 37,
	38, 39, 40, 167, 93, 144, 34, 130, 176, 129,
	114, 64, 66, 33, 48, 44, 46, 47, 119, 128,
	127, 117, 105, 101, 118, 163, 126, 94, 103, 107,
	97, 41, 42, 125, 124, 27, 28, 29, 30, 31,
	102, 98, 106, 100, 96, 99, 108, 104, 109, 91,
	78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
	88, 89, 90, 71, 72, 73, 74, 75, 76, 62,
	141, 68, 35, 36, 37, 38, 39, 40, 15, 110,
	132, 34, 137, 22, 29, 30, 31, 55, 33, 21,
	166, 123, 157, 158, 159, 41, 42, 161, 114, 165,
	164, 16, 17, 20, 25, 26, 23, 24, 41, 54,
	27, 28, 29, 30, 31, 153, 13, 115, 143, 148,
	19, 15, 27, 28, 29, 30, 31, 63, 162, 142,
	178, 41, 42, 170, 140, 22, 41, 42, 179, 155,
	136, 21, 22, 122, 121, 169, 10, 11, 21, 3,
	4, 156, 9, 16, 17, 20, 25, 26, 23, 24,
	16, 17, 20, 25, 26, 23, 24, 27, 28, 29,
	30, 31, 19, 12, 152, 116, 149, 150, 146, 19,
	27, 28, 29, 30, 31, 151, 145, 53, 70, 2,
	95, 92, 77, 32, 112, 8, 69, 120, 10, 11,
	111, 18, 45, 67, 51, 10, 11, 14, 5, 1,
	0, 51,
}

var jsonpathPact = [...]int16{
	167, -1000, 117, -1000, -1000, -1000, 6, 134, -57, 117,
	176, 176, -1000, 74, -1000, 52, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 176, 176, 176,
	176, 176, 176, 61, 140, -1000, -1000, -1000, -1000, -1000,
	-1000, 117, 117, -1000, 40, -1000, 44, 169, 81, 139,
	-1000, 117, -1000, -1000, 117, 176, 53, 53, -1000, -1000,
	-1000, 151, 157, 90, -1000, 6, 111, -1000, -1000, -1,
	-1000, -2, -9, -15, -16, -26, -28, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -66, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	117, -62, -70, -1000, 138, -57, -22, 98, 34, 93,
	-1000, -1000, -1000, 131, -31, 147, 128, 179, 179, 179,
	179, 125, -11, -1000, -1000, 176, 176, -1000, -1000, 84,
	-57, -1000, -1000, -1000, -1000, -33, -64, -1000, -1000, 173,
	161, -40, -1000, -1000, -47, -1000, -1000, -48, -51, -52,
	-35, -1000, -1000, -1000, -1000, 151, -1000, -1000, 147, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 125, -1000, -75,
	-1000,
}

var jsonpathPgo = [...]uint8{
	0, 249, 248, 2, 6, 247, 243, 242, 241, 4,
	9, 213, 237, 236, 235, 234, 233, 232, 231, 230,
	229, 228, 226, 225, 3, 0, 218, 1, 214, 179,
}

var jsonpathR1 = [...]int8{
	0, 1, 20, 20, 20, 2, 2, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 14, 14, 14, 14,
	5, 5, 5, 5, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 6, 17, 7, 7,
	15, 15, 9, 9, 10, 10, 10, 10, 10, 10,
	10, 10, 10, 11, 11, 12, 12, 16, 16, 16,
	16, 16, 16, 13, 13, 13, 13, 13, 13, 13,
	13, 13, 13, 13, 13, 13, 21, 21, 21, 25,
	25, 22, 22, 26, 26, 27, 27, 27, 23, 23,
	28, 24, 24, 29, 8, 8, 8, 8, 8, 8,
	8, 18, 18, 18, 19, 19, 19, 19, 19, 19,
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
	19, 19, 19, 19, 19, 19, 19,
}

var jsonpathR2 = [...]int8{
	0, 2, 1, 1, 0, 1, 1, 1, 3, 2,
	2, 3, 3, 3, 3, 3, 1, 4, 4, 2,
	1, 1, 1, 1, 2, 1, 4, 2, 4, 2,
	5, 5, 5, 5, 5, 5, 1, 1, 3, 3,
	1, 3, 1, 3, 1, 3, 3, 3, 2, 5,
	4, 3, 5, 3, 4, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 4, 6, 1,
	1, 1, 0, 1, 3, 1, 2, 2, 1, 0,
	1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1,
}

var jsonpathChk = [...]int16{
	-1000, -1, -20, 22, 23, -2, -3, -10, -14, 75,
	69, 70, -11, 39, -5, 44, 24, 25, -8, 43,
	26, 12, 6, 29, 30, 27, 28, 69, 70, 71,
	72, 73, -16, 47, 40, 31, 32, 33, 34, 35,
	36, 37, 38, -4, 77, -7, 78, 79, -3, -10,
	-3, 75, -3, -11, 75, 75, -3, -3, -3, -3,
	-3, -3, 48, 27, -10, -3, -10, -6, 71, -13,
	-21, 63, 64, 65, 66, 67, 68, -17, 50, 51,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
	62, 49, -18, 4, 27, -19, 44, 30, 41, 45,
	43, 23, 40, 28, 47, 22, 42, 29, 46, 48,
	75, 71, -15, -9, -3, 76, 76, -10, -10, -3,
	-12, 27, 26, 41, 75, 75, 75, 75, 75, 75,
	75, 82, -10, 80, 80, 81, 42, -4, -4, 45,
	76, 76, 76, 27, 76, -22, -26, -27, 12, 69,
	70, -23, -28, 27, -24, -29, 12, -24, -24, -24,
	-25, 12, 43, 76, -9, -3, 46, 76, 81, 12,
	12, 76, 76, 76, 76, 76, 83, 42, -27, -25,
	83,
}

var jsonpathDef = [...]int16{
	4, -2, 0, 2, 3, 1, 5, 6, 7, 0,
	0, 0, 44, 0, 16, 0, 20, 21, 22, 23,
	94, 95, 96, 97, 98, 99, 100, 0, 0, 0,
	0, 0, 0, 0, 0, 57, 58, 59, 60, 61,
	62, 0, 0, 19, 0, 25, 0, 0, 0, 0,
	9, 0, 10, 48, 0, 0, 11, 12, 13, 14,
	15, 45, 0, 51, 46, 0, 47, 24, 27, 0,
	29, 110, 109, 128, 131, 129, 130, 36, -2, -2,
	-2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
	-2, 76, 37, 101, 102, 103, 112, 113, 114, 117,
	119, 120, 121, 122, 125, 126, 132, 133, 135, 136,
	0, 0, 0, 40, 42, 8, 53, 0, 0, 0,
	50, 55, 56, 0, 0, 82, 89, 92, 92, 92,
	92, 0, 0, 38, 39, 0, 0, 17, 18, 0,
	0, 53, 54, 52, 28, 0, 81, 83, 85, 0,
	0, 0, 88, 90, 0, 91, 93, 0, 0, 0,
	0, 79, 80, 26, 41, 43, 49, 30, 0, 86,
	87, 31, 32, 33, 34, 35, 77, 0, 84, 0,
	78,
}

var jsonpathTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 73, 3, 3,
	75, 76, 71, 69, 81, 70, 77, 72, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 78, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 79, 3, 80, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 82, 3, 83,
}

var jsonpathTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
	62, 63, 64, 65, 66, 67, 68, 74,
}

var jsonpathTok3 = [...]int8{
	0,
}

var jsonpathErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	jsonpathDebug        = 0
	jsonpathErrorVerbose = false
)

type jsonpathLexer interface {
	Lex(lval *jsonpathSymType) int
	Error(s string)
}

type jsonpathParser interface {
	Parse(jsonpathLexer) int
	Lookahead() int
}

type jsonpathParserImpl struct {
	lval  jsonpathSymType
	stack [jsonpathInitialStackSize]jsonpathSymType
	char  int
}

func (p *jsonpathParserImpl) Lookahead() int {
	return p.char
}

func jsonpathNewParser() jsonpathParser {
	return &jsonpathParserImpl{}
}

const jsonpathFlag = -1000

func jsonpathTokname(c int) string {
	if c >= 1 && c-1 < len(jsonpathToknames) {
		if jsonpathToknames[c-1] != "" {
			return jsonpathToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func jsonpathStatname(s int) string {
	if s >= 0 && s < len(jsonpathStatenames) {
		if jsonpathStatenames[s] != "" {
			return jsonpathStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func jsonpathErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !jsonpathErrorVerbose {
		return "syntax error"
	}

	for _, e := range jsonpathErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + jsonpathTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(jsonpathPact[state])
	for tok := TOKSTART; tok-1 < len(jsonpathToknames); tok++ {
		if n := base + tok; n >= 0 && n < jsonpathLast && int(jsonpathChk[int(jsonpathAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if jsonpathDef[state] == -2 {
		i := 0
		for jsonpathExca[i] != -1 || int(jsonpathExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; jsonpathExca[i] >= 0; i += 2 {
			tok := int(jsonpathExca[i])
			if tok < TOKSTART || jsonpathExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if jsonpathExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += jsonpathTokname(tok)
	}
	return res
}

func jsonpathlex1(lex jsonpathLexer, lval *jsonpathSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(jsonpathTok1[0])
		goto out
	}
	if char < len(jsonpathTok1) {
		token = int(jsonpathTok1[char])
		goto out
	}
	if char >= jsonpathPrivate {
		if char < jsonpathPrivate+len(jsonpathTok2) {
			token = int(jsonpathTok2[char-jsonpathPrivate])
			goto out
		}
	}
	for i := 0; i < len(jsonpathTok3); i += 2 {
		token = int(jsonpathTok3[i+0])
		if token == char {
			token = int(jsonpathTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(jsonpathTok2[1]) /* unknown char */
	}
	if jsonpathDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", jsonpathTokname(token), uint(char))
	}
	return char, token
}

func jsonpathParse(jsonpathlex jsonpathLexer) int {
	return jsonpathNewParser().Parse(jsonpathlex)
}

func (jsonpathrcvr *jsonpathParserImpl) Parse(jsonpathlex jsonpathLexer) int {
	var jsonpathn int
	var jsonpathVAL jsonpathSymType
	var jsonpathDollar []jsonpathSymType
	_ = jsonpathDollar // silence set and not used
	jsonpathS := jsonpathrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	jsonpathstate := 0
	jsonpathrcvr.char = -1
	jsonpathtoken := -1 // jsonpathrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		jsonpathstate = -1
		jsonpathrcvr.char = -1
		jsonpathtoken = -1
	}()
	jsonpathp := -1
	goto jsonpathstack

ret0:
	return 0

ret1:
	return 1

jsonpathstack:
	/* put a state and value onto the stack */
	if jsonpathDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", jsonpathTokname(jsonpathtoken), jsonpathStatname(jsonpathstate))
	}

	jsonpathp++
	if jsonpathp >= len(jsonpathS) {
		nyys := make([]jsonpathSymType, len(jsonpathS)*2)
		copy(nyys, jsonpathS)
		jsonpathS = nyys
	}
	jsonpathS[jsonpathp] = jsonpathVAL
	jsonpathS[jsonpathp].yys = jsonpathstate

jsonpathnewstate:
	jsonpathn = int(jsonpathPact[jsonpathstate])
	if jsonpathn <= jsonpathFlag {
		goto jsonpathdefault /* simple state */
	}
	if jsonpathrcvr.char < 0 {
		jsonpathrcvr.char, jsonpathtoken = jsonpathlex1(jsonpathlex, &jsonpathrcvr.lval)
	}
	jsonpathn += jsonpathtoken
	if jsonpathn < 0 || jsonpathn >= jsonpathLast {
		goto jsonpathdefault
	}
	jsonpathn = int(jsonpathAct[jsonpathn])
	if int(jsonpathChk[jsonpathn]) == jsonpathtoken { /* valid shift */
		jsonpathrcvr.char = -1
		jsonpathtoken = -1
		jsonpathVAL = jsonpathrcvr.lval
		jsonpathstate = jsonpathn
		if Errflag > 0 {
			Errflag--
		}
		goto jsonpathstack
	}

jsonpathdefault:
	/* default state action */
	jsonpathn = int(jsonpathDef[jsonpathstate])
	if jsonpathn == -2 {
		if jsonpathrcvr.char < 0 {
			jsonpathrcvr.char, jsonpathtoken = jsonpathlex1(jsonpathlex, &jsonpathrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if jsonpathExca[xi+0] == -1 && int(jsonpathExca[xi+1]) == jsonpathstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			jsonpathn = int(jsonpathExca[xi+0])
			if jsonpathn < 0 || jsonpathn == jsonpathtoken {
				break
			}
		}
		jsonpathn = int(jsonpathExca[xi+1])
		if jsonpathn < 0 {
			goto ret0
		}
	}
	if jsonpathn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			jsonpathlex.Error(jsonpathErrorMessage(jsonpathstate, jsonpathtoken))
			Nerrs++
			if jsonpathDebug >= 1 {
				__yyfmt__.Printf("%s", jsonpathStatname(jsonpathstate))
				__yyfmt__.Printf(" saw %s\n", jsonpathTokname(jsonpathtoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for jsonpathp >= 0 {
				jsonpathn = int(jsonpathPact[jsonpathS[jsonpathp].yys]) + jsonpathErrCode
				if jsonpathn >= 0 && jsonpathn < jsonpathLast {
					jsonpathstate = int(jsonpathAct[jsonpathn]) /* simulate a shift of "error" */
					if int(jsonpathChk[jsonpathstate]) == jsonpathErrCode {
						goto jsonpathstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if jsonpathDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", jsonpathS[jsonpathp].yys)
				}
				jsonpathp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if jsonpathDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", jsonpathTokname(jsonpathtoken))
			}
			if jsonpathtoken == jsonpathEofCode {
				goto ret1
			}
			jsonpathrcvr.char = -1
			jsonpathtoken = -1
			goto jsonpathnewstate /* try again in the same state */
		}
	}

	/* reduction by production jsonpathn */
	if jsonpathDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", jsonpathn, jsonpathStatname(jsonpathstate))
	}

	jsonpathnt := jsonpathn
	jsonpathpt := jsonpathp
	_ = jsonpathpt // guard against "declared and not used"

	jsonpathp -= int(jsonpathR2[jsonpathn])
	// jsonpathp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if jsonpathp+1 >= len(jsonpathS) {
		nyys := make([]jsonpathSymType, len(jsonpathS)*2)
		copy(nyys, jsonpathS)
		jsonpathS = nyys
	}
	jsonpathVAL = jsonpathS[jsonpathp+1]

	/* consult goto table to find next state */
	jsonpathn = int(jsonpathR1[jsonpathn])
	jsonpathg := int(jsonpathPgo[jsonpathn])
	jsonpathj := jsonpathg + jsonpathS[jsonpathp].yys + 1

	if jsonpathj >= jsonpathLast {
		jsonpathstate = int(jsonpathAct[jsonpathg])
	} else {
		jsonpathstate = int(jsonpathAct[jsonpathj])
		if int(jsonpathChk[jsonpathstate]) != -jsonpathn {
			jsonpathstate = int(jsonpathAct[jsonpathg])
		}
	}
	// dummy call; replaced with literal code
	switch jsonpathnt {

	case 1:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:259
		{
			jp := jsonpath.Jsonpath{Strict: jsonpathDollar[1].union.bool(), Path: jsonpathDollar[2].union.path()}
			jsonpathlex.(*lexer).SetJsonpath(jp)
		}
	case 2:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:267
		{
			jsonpathVAL.union.val = true
		}
	case 3:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:271
		{
			jsonpathVAL.union.val = false
		}
	case 4:
		jsonpathDollar = jsonpathS[jsonpathpt-0 : jsonpathpt+1]
//line jsonpath-gen.y:275
		{
			jsonpathVAL.union.val = false
		}
	case 5:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:282
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 6:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:286
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 7:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:293
		{
			jsonpathVAL.union.val = jsonpath.Paths(jsonpathDollar[1].union.pathArr())
		}
	case 8:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:297
		{
			jsonpathVAL.union.val = jsonpathDollar[2].union.path()
		}
	case 9:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:301
		{
			jsonpathVAL.union.val = unaryOp(jsonpath.OpPlus, jsonpathDollar[2].union.path())
		}
	case 10:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:305
		{
			jsonpathVAL.union.val = unaryOp(jsonpath.OpMinus, jsonpathDollar[2].union.path())
		}
	case 11:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:309
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpAdd, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 12:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:313
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpSub, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 13:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:317
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpMult, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 14:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:321
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpDiv, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 15:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:325
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpMod, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 16:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:332
		{
			jsonpathVAL.union.val = []jsonpath.Path{jsonpathDollar[1].union.path()}
		}
	case 17:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:336
		{
			jsonpathVAL.union.val = []jsonpath.Path{jsonpathDollar[2].union.path(), jsonpathDollar[4].union.path()}
		}
	case 18:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:340
		{
			jsonpathVAL.union.val = []jsonpath.Path{jsonpathDollar[2].union.path(), jsonpathDollar[4].union.path()}
		}
	case 19:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:344
		{
			jsonpathVAL.union.val = append(jsonpathDollar[1].union.pathArr(), jsonpathDollar[2].union.path())
		}
	case 20:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:351
		{
			jsonpathVAL.union.val = jsonpath.Root{}
		}
	case 21:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:355
		{
			jsonpathVAL.union.val = jsonpath.Current{}
		}
	case 22:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:359
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 23:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:363
		{
			jsonpathVAL.union.val = jsonpath.Last{}
		}
	case 24:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:370
		{
			jsonpathVAL.union.val = jsonpathDollar[2].union.path()
		}
	case 25:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:374
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 26:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:378
		{
			jsonpathVAL.union.val = jsonpath.Filter{Condition: jsonpathDollar[3].union.path()}
		}
	case 27:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:382
		{
			jsonpathVAL.union.val = jsonpath.AnyKey{}
		}
	case 28:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:386
		{
			jsonpathVAL.union.val = jsonpathDollar[2].union.path()
		}
	case 29:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:390
		{
			return unimplemented(jsonpathlex, ".**")
		}
	case 30:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:394
		{
			return unimplemented(jsonpathlex, ".decimal()")
		}
	case 31:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:398
		{
			return unimplemented(jsonpathlex, ".datetime()")
		}
	case 32:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:402
		{
			return unimplemented(jsonpathlex, ".time()")
		}
	case 33:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:406
		{
			return unimplemented(jsonpathlex, ".time_tz()")
		}
	case 34:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:410
		{
			return unimplemented(jsonpathlex, ".timestamp()")
		}
	case 35:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:414
		{
			return unimplemented(jsonpathlex, ".timestamp_tz()")
		}
	case 36:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:421
		{
			jsonpathVAL.union.val = jsonpath.Key(jsonpathDollar[1].str)
		}
	case 37:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:428
		{
			jsonpathVAL.str = jsonpathDollar[1].str
		}
	case 38:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:435
		{
			jsonpathVAL.union.val = jsonpath.Wildcard{}
		}
	case 39:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:439
		{
			jsonpathVAL.union.val = jsonpathDollar[2].union.path()
		}
	case 40:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:446
		{
			jsonpathVAL.union.val = jsonpath.ArrayList{jsonpathDollar[1].union.path()}
		}
	case 41:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:450
		{
			jsonpathVAL.union.val = append(jsonpathDollar[1].union.arrayList(), jsonpathDollar[3].union.path())
		}
	case 42:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:457
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 43:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:461
		{
			jsonpathVAL.union.val = jsonpath.ArrayIndexRange{
				Start: jsonpathDollar[1].union.path(),
				End:   jsonpathDollar[3].union.path(),
			}
		}
	case 44:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:471
		{
			jsonpathVAL.union.val = jsonpathDollar[1].union.path()
		}
	case 45:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:475
		{
			jsonpathVAL.union.val = binaryOp(jsonpathDollar[2].union.operationType(), jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 46:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:479
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpLogicalAnd, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 47:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:483
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpLogicalOr, jsonpathDollar[1].union.path(), jsonpathDollar[3].union.path())
		}
	case 48:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:487
		{
			jsonpathVAL.union.val = unaryOp(jsonpath.OpLogicalNot, jsonpathDollar[2].union.path())
		}
	case 49:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:491
		{
			jsonpathVAL.union.val = unaryOp(jsonpath.OpIsUnknown, jsonpathDollar[2].union.path())
		}
	case 50:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:495
		{
			jsonpathVAL.union.val = binaryOp(jsonpath.OpStartsWith, jsonpathDollar[1].union.path(), jsonpathDollar[4].union.path())
		}
	case 51:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:499
		{
			regex, err := regexBinaryOp(jsonpathDollar[1].union.path(), jsonpathDollar[3].str, "")
			if err != nil {
				return setErr(jsonpathlex, err)
			}
			jsonpathVAL.union.val = regex
		}
	case 52:
		jsonpathDollar = jsonpathS[jsonpathpt-5 : jsonpathpt+1]
//line jsonpath-gen.y:507
		{
			regex, err := regexBinaryOp(jsonpathDollar[1].union.path(), jsonpathDollar[3].str, jsonpathDollar[5].str)
			if err != nil {
				return setErr(jsonpathlex, err)
			}
			jsonpathVAL.union.val = regex
		}
	case 53:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:518
		{
			jsonpathVAL.union.val = jsonpathDollar[2].union.path()
		}
	case 54:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:522
		{
			jsonpathVAL.union.val = unaryOp(jsonpath.OpExists, jsonpathDollar[3].union.path())
		}
	case 55:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:529
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarString, Value: json.FromString(jsonpathDollar[1].str)}
		}
	case 56:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:533
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarVariable, Variable: jsonpathDollar[1].str}
		}
	case 57:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:540
		{
			jsonpathVAL.union.val = jsonpath.OpCompEqual
		}
	case 58:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:544
		{
			jsonpathVAL.union.val = jsonpath.OpCompNotEqual
		}
	case 59:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:548
		{
			jsonpathVAL.union.val = jsonpath.OpCompLess
		}
	case 60:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:552
		{
			jsonpathVAL.union.val = jsonpath.OpCompLessEqual
		}
	case 61:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:556
		{
			jsonpathVAL.union.val = jsonpath.OpCompGreater
		}
	case 62:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:560
		{
			jsonpathVAL.union.val = jsonpath.OpCompGreaterEqual
		}
	case 63:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:567
		{
			jsonpathVAL.union.val = jsonpath.Method{Type: jsonpath.SizeMethod}
		}
	case 64:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:571
		{
			jsonpathVAL.union.val = jsonpath.Method{Type: jsonpath.TypeMethod}
		}
	case 65:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:575
		{
			return unimplemented(jsonpathlex, ".keyvalue()")
		}
	case 66:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:579
		{
			jsonpathVAL.union.val = jsonpath.Method{Type: jsonpath.AbsMethod}
		}
	case 67:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:583
		{
			jsonpathVAL.union.val = jsonpath.Method{Type: jsonpath.CeilingMethod}
		}
	case 68:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:587
		{
			jsonpathVAL.union.val = jsonpath.Method{Type: jsonpath.FloorMethod}
		}
	case 69:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:591
		{
			return unimplemented(jsonpathlex, ".bigint()")
		}
	case 70:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:595
		{
			return unimplemented(jsonpathlex, ".boolean()")
		}
	case 71:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:599
		{
			return unimplemented(jsonpathlex, ".date()")
		}
	case 72:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:603
		{
			return unimplemented(jsonpathlex, ".double()")
		}
	case 73:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:607
		{
			return unimplemented(jsonpathlex, ".integer()")
		}
	case 74:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:611
		{
			return unimplemented(jsonpathlex, ".number()")
		}
	case 75:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:615
		{
			return unimplemented(jsonpathlex, ".string()")
		}
	case 76:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:622
		{

		}
	case 77:
		jsonpathDollar = jsonpathS[jsonpathpt-4 : jsonpathpt+1]
//line jsonpath-gen.y:626
		{

		}
	case 78:
		jsonpathDollar = jsonpathS[jsonpathpt-6 : jsonpathpt+1]
//line jsonpath-gen.y:630
		{

		}
	case 79:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:637
		{

		}
	case 80:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:641
		{

		}
	case 81:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:648
		{

		}
	case 82:
		jsonpathDollar = jsonpathS[jsonpathpt-0 : jsonpathpt+1]
//line jsonpath-gen.y:652
		{

		}
	case 83:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:659
		{

		}
	case 84:
		jsonpathDollar = jsonpathS[jsonpathpt-3 : jsonpathpt+1]
//line jsonpath-gen.y:663
		{

		}
	case 85:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:670
		{

		}
	case 86:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:674
		{

		}
	case 87:
		jsonpathDollar = jsonpathS[jsonpathpt-2 : jsonpathpt+1]
//line jsonpath-gen.y:678
		{

		}
	case 88:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:685
		{

		}
	case 89:
		jsonpathDollar = jsonpathS[jsonpathpt-0 : jsonpathpt+1]
//line jsonpath-gen.y:689
		{

		}
	case 90:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:696
		{

		}
	case 91:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:703
		{

		}
	case 92:
		jsonpathDollar = jsonpathS[jsonpathpt-0 : jsonpathpt+1]
//line jsonpath-gen.y:707
		{

		}
	case 93:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:714
		{

		}
	case 94:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:721
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarVariable, Variable: jsonpathDollar[1].str}
		}
	case 95:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:725
		{
			i, err := jsonpathDollar[1].union.numVal().AsInt64()
			if err != nil {
				return setErr(jsonpathlex, err)
			}
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarInt, Value: json.FromInt64(i)}
		}
	case 96:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:733
		{
			f, err := strconv.ParseFloat(jsonpathDollar[1].str, 64)
			if err != nil {
				return setErr(jsonpathlex, err)
			}
			j, err := json.FromFloat64(f)
			if err != nil {
				return setErr(jsonpathlex, err)
			}
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarFloat, Value: j}
		}
	case 97:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:745
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarBool, Value: json.FromBool(true)}
		}
	case 98:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:749
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarBool, Value: json.FromBool(false)}
		}
	case 99:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:753
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarString, Value: json.FromString(jsonpathDollar[1].str)}
		}
	case 100:
		jsonpathDollar = jsonpathS[jsonpathpt-1 : jsonpathpt+1]
//line jsonpath-gen.y:757
		{
			jsonpathVAL.union.val = jsonpath.Scalar{Type: jsonpath.ScalarNull, Value: json.NullJSONValue}
		}
	}
	goto jsonpathstack /* stack new state and value */
}
