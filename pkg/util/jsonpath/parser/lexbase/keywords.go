// Code generated by pkg/sql/lexbase/allkeywords. DO NOT EDIT.

package lexbase

var KeywordsCategories = map[string]string{
"abs": "U",
"bigint": "U",
"boolean": "U",
"ceiling": "U",
"date": "U",
"datetime": "U",
"decimal": "U",
"double": "U",
"exists": "U",
"false": "U",
"flag": "U",
"floor": "U",
"integer": "U",
"is": "U",
"keyvalue": "U",
"last": "U",
"lax": "U",
"like_regex": "U",
"null": "U",
"number": "U",
"size": "U",
"starts": "U",
"strict": "U",
"string": "U",
"time": "U",
"timestamp": "U",
"timestamp_tz": "U",
"time_tz": "U",
"to": "U",
"true": "U",
"type": "U",
"unknown": "U",
"with": "U",
}

// KeywordNames contains all keywords sorted, so that pg_get_keywords returns
// deterministic results.
var KeywordNames = []string{
"abs",
"bigint",
"boolean",
"ceiling",
"date",
"datetime",
"decimal",
"double",
"exists",
"false",
"flag",
"floor",
"integer",
"is",
"keyvalue",
"last",
"lax",
"like_regex",
"null",
"number",
"size",
"starts",
"strict",
"string",
"time",
"timestamp",
"timestamp_tz",
"time_tz",
"to",
"true",
"type",
"unknown",
"with",
}

var keywordID = map[string]int32{
"abs": ABS,
"bigint": BIGINT,
"boolean": BOOLEAN,
"ceiling": CEILING,
"date": DATE,
"datetime": DATETIME,
"decimal": DECIMAL,
"double": DOUBLE,
"exists": EXISTS,
"false": FALSE,
"flag": FLAG,
"floor": FLOOR,
"integer": INTEGER,
"is": IS,
"keyvalue": KEYVALUE,
"last": LAST,
"lax": LAX,
"like_regex": LIKE_REGEX,
"null": NULL,
"number": NUMBER,
"size": SIZE,
"starts": STARTS,
"strict": STRICT,
"string": STRING,
"time": TIME,
"timestamp": TIMESTAMP,
"timestamp_tz": TIMESTAMP_TZ,
"time_tz": TIME_TZ,
"to": TO,
"true": TRUE,
"type": TYPE,
"unknown": UNKNOWN,
"with": WITH,
}

// GetKeywordID returns the lex id of the SQL keyword k or IDENT if k is
// not a keyword.
//
//gcassert:inline
func GetKeywordID(k string) int32 {
	id, ok := keywordID[k]
	if !ok {
		return IDENT
	}
	return id
}
