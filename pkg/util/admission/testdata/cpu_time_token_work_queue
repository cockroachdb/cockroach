###
# The first test here is mostly a test of AdmittedWorkDone (work-done).
# So AC admits requests, one to tenant ID 53 and another to tenant ID
# 54. The test granter has been set up to allow granting of all requests.
# This is just test setup.
###
init
----

set-try-get-return-value v=true
----

admit id=1 tenant=53 requested-count=3 bypass=false
----
tryGet: input noBurst, returning true
id 1: admit succeeded

admit id=2 tenant=54 requested-count=8 bypass=false
----
tryGet: input noBurst, returning true
id 2: admit succeeded

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 3, w: 1, fifo: -128
 tenant-id: 54 used: 8, w: 1, fifo: -128
burst-buckets: t53=fullness=0.0% tokens=-3 capacity=0 qual=noBurst t54=fullness=0.0% tokens=-8 capacity=0 qual=noBurst

# requested-count at admit time was 3. cpu-time below is 1. This
# simulates a situation where at admit time, the predicted CPU usage
# was 3 ns of CPU time (see cpu_time_token_estimation.go), and then
# measured CPU usage was 1 ns of CPU time. In this case, we should
# return 3-1=2 tokens to the granter, which stores the CPU time token
# buckets (see cpu_time_token_granter.go).
work-done id=1 cpu-time=1
----
returnGrant 2

# Also, used should be adjusted, to reflect actual usage in CPU time,
# again measured in ns. You can see below that used is now 1 for the
# tenant with tenant ID 53.
print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 1, w: 1, fifo: -128
 tenant-id: 54 used: 8, w: 1, fifo: -128
burst-buckets: t53=fullness=0.0% tokens=-1 capacity=0 qual=noBurst t54=fullness=0.0% tokens=-8 capacity=0 qual=noBurst

# In this case, measured CPU usage was more than predicted CPU usage.
# So, we should take additional tokens from the granter this time.
work-done id=2 cpu-time=15
----
tookWithoutPermission 7

# Same here. Used is adjusted, to reflect actual usage.
print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 1, w: 1, fifo: -128
 tenant-id: 54 used: 15, w: 1, fifo: -128
burst-buckets: t53=fullness=0.0% tokens=-1 capacity=0 qual=noBurst t54=fullness=0.0% tokens=-15 capacity=0 qual=noBurst

###
# This test is of the integration of burstQualification with the tenant
# heap sorting in WorkQueue. That is, we check that work associated with
# canBurst tenants sort to the top of the heap. See
# cpu_time_token_burst.go for more.
###
init
----

set-try-get-return-value v=true
----

admit id=1 tenant=53 requested-count=1 bypass=false
----
tryGet: input noBurst, returning true
id 1: admit succeeded

admit id=2 tenant=54 requested-count=1 bypass=false
----
tryGet: input noBurst, returning true
id 2: admit succeeded

# Set up buckets so that tenant 53 can burst, while tenant
# 54 cannot burst (call to Admit below empties 54's token
# bucket).
refill-burst-buckets to-add=100 capacity=100
----

admit id=1000 tenant=54 requested-count=100 bypass=false
----
tryGet: input noBurst, returning true
id 1000: admit succeeded

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 1, w: 1, fifo: -128
 tenant-id: 54 used: 101, w: 1, fifo: -128
burst-buckets: t53=fullness=99.0% tokens=99 capacity=100 qual=canBurst t54=fullness=-1.0% tokens=-1 capacity=100 qual=noBurst

set-try-get-return-value v=false
----

# Tenant 53 can burst. Tenant 54 cannot burst. Some work from 53 is
# queued. Then some work from 54 tries to admit. The work from 54
# should queue without checking granter state at all, since there
# is already a backlog of canBurst work.
admit id=3 tenant=53 requested-count=1 bypass=false
----
tryGet: input canBurst, returning false

set-try-get-return-value v=true
----

admit id=4 tenant=54 requested-count=15 bypass=false
----

gc-tenants-and-reset-used
----
closed epoch: 0 tenantHeap len: 2 top tenant: 53
 tenant-id: 53 used: 0, w: 1, fifo: -128 waiting work heap: [0: pri: normal-pri, ct: 1, epoch: 0, qt: 100]
 tenant-id: 54 used: 0, w: 1, fifo: -128 waiting work heap: [0: pri: normal-pri, ct: 1, epoch: 0, qt: 100]
burst-buckets: t53=fullness=99.0% tokens=99 capacity=100 qual=canBurst t54=fullness=-1.0% tokens=-1 capacity=100 qual=noBurst

# The canBurst request should be granted admission before the noBurst
# request.
granted chain-id=1
----
continueGrantChain 1
id 3: admit succeeded
granted: returned 1

granted chain-id=1
----
continueGrantChain 1
id 4: admit succeeded
granted: returned 15

# Non-burst tenant is queued, burst can run immediately
set-try-get-return-value v=false
----

# Some work from 54 is queued this time. Then some work from 53
# tries to admit. The work from 53 is admitted, since 53 can
# burst, and the backlog is all for work that cannot burst, and
# since the granter says the work from 53 can proceed (there are
# available canBurst CPU time tokens in the granter).
admit id=5 tenant=54 requested-count=15 bypass=false
----
tryGet: input noBurst, returning false

set-try-get-return-value v=true
----

admit id=6 tenant=53 requested-count=1 bypass=false
----
tryGet: input canBurst, returning true
id 6: admit succeeded

granted chain-id=1
----
continueGrantChain 1
id 5: admit succeeded
granted: returned 15

set-try-get-return-value v=false
----

# First, a canBurst request is queued. Then a noBurst request.
# Finally another canBurst request. Note that the second canBurst
# request does not check the granter state this time, since the
# backlog already has one canBurst request in it.
admit id=7 tenant=53 requested-count=1 bypass=false
----
tryGet: input canBurst, returning false

admit id=8 tenant=54 requested-count=15 bypass=false
----

admit id=9 tenant=53 requested-count=1 bypass=false
----

# See Less implementation in WorkQueue. We clear used to be sure
# that the reason the WorkQueue sorts the heap the way it does below
# is the burstQualifications.
gc-tenants-and-reset-used
----
closed epoch: 0 tenantHeap len: 2 top tenant: 53
 tenant-id: 53 used: 0, w: 1, fifo: -128 waiting work heap: [0: pri: normal-pri, ct: 1, epoch: 0, qt: 100] [1: pri: normal-pri, ct: 1, epoch: 0, qt: 100]
 tenant-id: 54 used: 0, w: 1, fifo: -128 waiting work heap: [0: pri: normal-pri, ct: 1, epoch: 0, qt: 100]
burst-buckets: t53=fullness=97.0% tokens=97 capacity=100 qual=canBurst t54=fullness=-31.0% tokens=-31 capacity=100 qual=noBurst

# The two canBurst requests are granted admission before the noBurst
# request, even though the noBurst request is queued before the second
# canBurst request.
granted chain-id=1
----
continueGrantChain 1
id 7: admit succeeded
granted: returned 1

granted chain-id=1
----
continueGrantChain 1
id 9: admit succeeded
granted: returned 1

granted chain-id=1
----
continueGrantChain 1
id 8: admit succeeded
granted: returned 15

###
# This is a test of WorkQueue deducting tokens from the burst buckets.
# Note that we already have TestCPUTimeTokenBurst for testing that
# the burst buckets correctly categorize tenants into canBurst and
# noBurst. This test is an integration test instead. It ensures that
# the burst bucket state correctly captures the usage seen by the
# WorkQueue.
###
init
----

set-try-get-return-value v=true
----

# Init a tenant, fill its burst bucket to the top.
admit id=1 tenant=53 requested-count=1 bypass=false
----
tryGet: input noBurst, returning true
id 1: admit succeeded

refill-burst-buckets to-add=100 capacity=100
----

# The rest of this test is mostly of the burstBucket state
# below. It starts at 99% full. The call to Admit put the
# bucket at -1 tokens. The call to refill added 100 tokens.
#
# The rest of the test is self-explanatory, so I will not
# add comments above every call to print. Calls to Admit
# or AdmittedWorkDone are made, and they both adjust used
# and adjust the burst bucket state.
print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 1, w: 1, fifo: -128
burst-buckets: t53=fullness=99.0% tokens=99 capacity=100 qual=canBurst

admit id=2 tenant=53 requested-count=5 bypass=false
----
tryGet: input canBurst, returning true
id 2: admit succeeded

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 6, w: 1, fifo: -128
burst-buckets: t53=fullness=94.0% tokens=94 capacity=100 qual=canBurst

set-try-get-return-value v=false
----

admit id=3 tenant=53 requested-count=1 bypass=false
----
tryGet: input canBurst, returning false

print
----
closed epoch: 0 tenantHeap len: 1 top tenant: 53
 tenant-id: 53 used: 6, w: 1, fifo: -128 waiting work heap: [0: pri: normal-pri, ct: 1, epoch: 0, qt: 100]
burst-buckets: t53=fullness=94.0% tokens=94 capacity=100 qual=canBurst

granted chain-id=1
----
continueGrantChain 1
id 3: admit succeeded
granted: returned 1

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 7, w: 1, fifo: -128
burst-buckets: t53=fullness=93.0% tokens=93 capacity=100 qual=canBurst

work-done id=1 cpu-time=2
----
tookWithoutPermission 1

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 8, w: 1, fifo: -128
burst-buckets: t53=fullness=92.0% tokens=92 capacity=100 qual=canBurst

work-done id=2 cpu-time=3
----
returnGrant 2

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 6, w: 1, fifo: -128
burst-buckets: t53=fullness=94.0% tokens=94 capacity=100 qual=canBurst

admit id=4 tenant=53 requested-count=1 bypass=true
----
tookWithoutPermission 1
id 4: admit succeeded

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 7, w: 1, fifo: -128
burst-buckets: t53=fullness=93.0% tokens=93 capacity=100 qual=canBurst

set-try-get-return-value v=false
----

admit id=5 tenant=53 requested-count=1 bypass=false
----
tryGet: input canBurst, returning false

cancel-work id=5
----
id 5: admit failed

print
----
closed epoch: 0 tenantHeap len: 0
 tenant-id: 53 used: 7, w: 1, fifo: -128
burst-buckets: t53=fullness=93.0% tokens=93 capacity=100 qual=canBurst
