// Copyright 2025 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// Package unique exposes some utilities for generating unique 64-bit IDs.
package unique

import (
	"math/bits"
	"time"

	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	"github.com/cockroachdb/cockroach/pkg/util/timeutil"
)

// ProcessUniqueID is an ID which is unique to this process in the cluster.
// It is used to generate unique integer keys via GenerateUniqueInt. Generally
// it is the node ID of a system tenant or the sql instance ID of a secondary
// tenant.
//
// Note that for its uniqueness property to hold, the value must use no more
// than 15 bits. Nothing enforces this for node IDs, but, in practice, they
// do not generally get to be more than 16k unless nodes are being added and
// removed frequently. In order to eliminate this bug, we ought to use the
// leased SQLInstanceID instead of the NodeID to generate these unique integers
// in all cases.
type ProcessUniqueID int32

// A unique int generated by GenerateUniqueInt is a 64-bit integer with
// the following format:
//
//	[1 leading zero bit][48 bits for timestamp][15 bits for nodeID]
const (
	// UniqueIntLeadingZeroBits is the number of leading zero bits in a unique
	// int generated by GenerateUniqueInt.
	UniqueIntLeadingZeroBits = 1

	// UniqueIntTimestampBits is the number of bits in the timestamp segment
	// in a unique int generated by GenerateUniqueInt.
	UniqueIntTimestampBits = 48

	// UniqueIntNodeIDBits is the number of bits in the node ID segment
	// in a unique int generated by GenerateUniqueInt.
	UniqueIntNodeIDBits = 15

	// UniqueIntNodeIDMask is a bitmask for the node ID in a unique int
	// generated by GenerateUniqueInt.
	UniqueIntNodeIDMask = 1<<UniqueIntNodeIDBits - 1

	// UniqueIntTimestampMask is a bitmask for the timestamp in a unique int
	// generated by GenerateUniqueInt.
	UniqueIntTimestampMask = (1<<UniqueIntTimestampBits - 1) << UniqueIntNodeIDBits
)

// GenerateUniqueUnorderedID creates a unique int64 composed of the current time
// at a 10-microsecond granularity and the instance-id. The top-bit is left
// empty so that negative values are not returned. The 48 bits following after
// represent the reversed timestamp and then 15 bits of the node id.
func GenerateUniqueUnorderedID(instanceID ProcessUniqueID) int64 {
	orig := uint64(GenerateUniqueInt(instanceID))
	uniqueUnorderedID := mapToUnorderedUniqueInt(orig)
	return int64(uniqueUnorderedID)
}

// mapToUnorderedUniqueInt is used by GenerateUniqueUnorderedID to convert a
// serial unique uint64 to an unordered unique int64. It accomplishes this by
// reversing the timestamp portion of the unique ID. This bit manipulation
// should preserve the number of 1-bits.
func mapToUnorderedUniqueInt(uniqueInt uint64) uint64 {
	// val is [0][48 bits of ts][15 bits of node id]
	ts := uniqueInt & UniqueIntTimestampMask
	nodeID := uniqueInt & UniqueIntNodeIDMask
	reversedTS := bits.Reverse64(ts<<UniqueIntLeadingZeroBits) << UniqueIntNodeIDBits
	unorderedUniqueInt := reversedTS | nodeID
	return unorderedUniqueInt
}

// GenerateUniqueInt creates a unique int composed of the current time at a
// 10-microsecond granularity and the instance-id. The instance-id is stored in the
// lower 15 bits of the returned value and the timestamp is stored in the upper
// 48 bits. The top-bit is left empty so that negative values are not returned.
// The 48-bit timestamp field provides for 89 years of timestamps. We use a
// custom epoch (Jan 1, 2015) in order to utilize the entire timestamp range.
//
// Note that GenerateUniqueInt() imposes a limit on instance IDs while
// generateUniqueBytes() does not.
//
// TODO(pmattis): Do we have to worry about persisting the milliseconds value
// periodically to avoid the clock ever going backwards (e.g. due to NTP
// adjustment)?
func GenerateUniqueInt(instanceID ProcessUniqueID) int64 {
	const precision = uint64(10 * time.Microsecond)

	// TODO(andrei): For tenants we need to validate that the current time is
	// within the validity of the sqlliveness session to which the instanceID is
	// bound. Without this validation, two different nodes might be calling this
	// function with the same instanceID at the same time, and both would generate
	// the same unique int. See #90459.
	nowNanos := timeutil.Now().UnixNano()
	// Paranoia: nowNanos should never be less than uniqueIntEpoch.
	if nowNanos < uniqueIntEpoch {
		nowNanos = uniqueIntEpoch
	}
	timestamp := uint64(nowNanos-uniqueIntEpoch) / precision

	uniqueIntState.Lock()
	if timestamp <= uniqueIntState.timestamp {
		timestamp = uniqueIntState.timestamp + 1
	}
	uniqueIntState.timestamp = timestamp
	uniqueIntState.Unlock()

	return generateUniqueID(int32(instanceID), timestamp)
}

var uniqueIntState struct {
	syncutil.Mutex
	timestamp uint64
}

var uniqueIntEpoch = time.Date(2015, time.January, 1, 0, 0, 0, 0, time.UTC).UnixNano()

// generateUniqueID encapsulates the logic to generate a unique number from
// a nodeID and timestamp.
func generateUniqueID(instanceID int32, timestamp uint64) int64 {
	// We xor in the instanceID so that instanceIDs larger than 32K will flip bits
	// in the timestamp portion of the final value instead of always setting them.
	id := (timestamp << UniqueIntNodeIDBits) ^ uint64(instanceID)
	return int64(id)
}
