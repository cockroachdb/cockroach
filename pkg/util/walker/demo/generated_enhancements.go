// Code generated by hand. DO NOT EDIT.
// source: demo.go
package demo

// This file contains additional methods defined on the visitable types.

import (
	"context"
	"fmt"
	"reflect"
)

// statementImpl is an enhanced Statement.
type statementImpl interface {
	Statement
	// pre calls the relevant PreXYZ method on the visitor.
	pre(ctx StatementContext, v StatementVisitor) (bool, error)
	// post calls the relevant PreXYZ method on the visitor.
	post(ctx StatementContext, v StatementVisitor) error
	// traverse visits the fields within the statement.
	traverse(ctx StatementContext, v StatementVisitor)
}

func ensureStatementImpl(val interface{}, assignableTo reflect.Type) statementImpl {
	var ret reflect.Value
	valTyp := reflect.TypeOf(val)
	if valTyp.ConvertibleTo(assignableTo) && valTyp.AssignableTo(statementImplType) {
		ret = reflect.ValueOf(val).Convert(assignableTo)
	} else if ptrType := reflect.PtrTo(valTyp); ptrType.ConvertibleTo(assignableTo) && ptrType.AssignableTo(statementImplType) {
		ret = reflect.New(valTyp)
		ret.Elem().Set(reflect.ValueOf(val))
	} else {
		panic(fmt.Sprintf("unhandled conversion %+v to %v", val, assignableTo))
	}
	return ret.Interface().(statementImpl)
}

func ensureStatementImpls(slice interface{}, assignableTo reflect.Type) []statementImpl {
	val := reflect.ValueOf(slice)
	ln := val.Len()
	ret := make([]statementImpl, ln)
	for i := 0; i < ln; i++ {
		ret[i] = ensureStatementImpl(val.Index(i), assignableTo)
	}
	return ret
}

// Whether or not these traverse() methods are generated as
// Foo or *Foo should depend on the receiver type used when
// implementing the user's visitable interface.
var _ statementImpl = &Foo{}
var _ statementImpl = &Bar{}
var _ statementImpl = Quux{}

func (x *Foo) Walk(ctx context.Context, v StatementVisitor) (*Foo, bool, error) {
	ret, changed, err := walkStatement(ctx, x, v, fooPtrType)
	return ret.(*Foo), changed, err
}

func (x *Foo) pre(ctx StatementContext, v StatementVisitor) (bool, error) {
	return v.PreFoo(ctx, x)
}

func (x *Foo) post(ctx StatementContext, v StatementVisitor) error {
	return v.PostFoo(ctx, x)
}

// No fields
func (x *Foo) traverse(ctx StatementContext, v StatementVisitor) {}

func (x *Bar) Walk(ctx context.Context, v StatementVisitor) (*Bar, bool, error) {
	ret, changed, err := walkStatement(ctx, x, v, barPtrType)
	return ret.(*Bar), changed, err
}

func (x *Bar) pre(ctx StatementContext, v StatementVisitor) (bool, error) {
	return v.PreBar(ctx, x)
}

func (x *Bar) post(ctx StatementContext, v StatementVisitor) error {
	return v.PostBar(ctx, x)
}

func (x *Bar) traverse(ctx StatementContext, v StatementVisitor) {
	dirty := false
	// *Visitable in Visitable field
	newFoo := &x.foo
	if x, changed := ctx.accept(v, &x.foo, fooPtrType); changed {
		dirty = true
		newFoo = x.(*Foo)
	}
	// *Visitable in *Visitable field
	newFooPtr := x.fooPtr
	if newFooPtr != nil {
		if x, changed := ctx.accept(v, x.fooPtr, fooPtrType); changed {
			dirty = true
			newFooPtr = x.(*Foo)
		}
	}
	// Visitable in Visitable field
	newQuux := x.quux
	if x, changed := ctx.accept(v, &x.quux, quuxType); changed {
		dirty = true
		newQuux = x.(Quux)
	}
	// Visitable in *Visitable field
	newQuuxPtr := x.quuxPtr
	if newQuuxPtr != nil {
		if x, changed := ctx.accept(v, x.quuxPtr, quuxType); changed {
			dirty = true
			t := x.(Quux)
			newQuuxPtr = &t
		}
	}

	{
		// Todo slices
	}

	if dirty {
		ctx.Replace(&Bar{
			foo:     *newFoo,
			fooPtr:  newFooPtr,
			quux:    newQuux,
			quuxPtr: newQuuxPtr,
		})
	}
}

func (x Quux) Walk(ctx context.Context, v StatementVisitor) (Quux, bool, error) {
	ret, changed, err := walkStatement(ctx, x, v, quuxType)
	return ret.(Quux), changed, err
}

func (x Quux) pre(ctx StatementContext, v StatementVisitor) (bool, error) {
	return v.PreQuux(ctx, x)
}

func (x Quux) post(ctx StatementContext, v StatementVisitor) error {
	return v.PostQuux(ctx, x)
}

// No fields.
func (x Quux) traverse(ctx StatementContext, v StatementVisitor) {}
