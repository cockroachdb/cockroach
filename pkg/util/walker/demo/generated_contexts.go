// Code generated by hand. DO NOT EDIT.
// source: demo.go
package demo

import (
	"context"
	"reflect"
	"sync"

	"github.com/cockroachdb/cockroach/pkg/util/walker"
)

type baseStatementContext struct {
	context.Context
	assignableTo reflect.Type
	dirty        bool
}

var _ StatementContext = &baseStatementContext{}

func (c baseStatementContext) Accept(v StatementVisitor, x Statement) (Statement, bool) {
	s := ensureStatementImpl(x, statementType)
	return c.accept(v, s, statementType)
}

func (c baseStatementContext) accept(
	v StatementVisitor, x statementImpl, assignableTo reflect.Type,
) (statementImpl, bool) {
	ctx := newScalarStatementContext(c, assignableTo,
		assignableTo.Kind() == reflect.Interface || assignableTo.Kind() == reflect.Ptr)

	recurse, err := x.pre(ctx, v)
	if err != nil {
		ctx.close()
		ctx.unwind(err)
	}
	if ctx.dirty {
		x = ctx.replacement
		// If the user has nullified the value that we were visiting,
		// exit early.
		if x == nil {
			ctx.close()
			return x, true
		}
		ctx.replacement = nil
	}
	if recurse {
		x.traverse(ctx, v)
	}
	if err := x.post(ctx, v); err != nil {
		ctx.close()
		ctx.unwind(err)
	}
	if ctx.replacement != nil {
		x = ctx.replacement
	}
	dirty := ctx.dirty
	ctx.close()
	return x, dirty
}

func (c baseStatementContext) AcceptMany(v StatementVisitor, n []Statement) ([]Statement, bool) {
	newValue, changed := c.acceptMany(v, ensureStatementImpls(n, statementType), statementType)
	if !changed {
		return n, false
	}
	ret := make([]Statement, len(newValue))
	for i, j := range ret {
		ret[i] = j
	}
	return ret, true
}

func (c baseStatementContext) acceptMany(
	v StatementVisitor, n []statementImpl, assignableTo reflect.Type,
) ([]statementImpl, bool) {
	out := make([]statementImpl, 0, len(n))
	dirty := false
	for _, x := range n {
		ctx := &sliceStatementContext{
			baseStatementContext: baseStatementContext{
				Context:      c,
				assignableTo: assignableTo,
			},
		}

		if ctx.insertBefore != nil {
			dirty = true
			out = append(out, ctx.insertBefore...)
		}
		if ctx.didRemove {
			dirty = true
		} else {
			if ctx.didReplace {
				dirty = true
				out = append(out, ctx.replace)
			} else {
				// Not dirty, retaining existing element.
				out = append(out, x)
			}
		}
		if ctx.insertAfter != nil {
			dirty = true
			out = append(out, ctx.insertAfter...)
		}
	}
	if dirty {
		return out, true
	}
	return n, false
}

func (c baseStatementContext) CanReplace() bool {
	return false
}

func (c baseStatementContext) Replace(n Statement) {
	panic("this context cannot replace")
}

func (c baseStatementContext) CanInsertBefore() bool {
	return false
}

func (c baseStatementContext) InsertBefore(n Statement) {
	panic("this context cannot insert")
}

func (c baseStatementContext) CanInsertAfter() bool {
	return false
}

func (c baseStatementContext) InsertAfter(n Statement) {
	panic("this context cannot insert")
}

func (baseStatementContext) CanRemove() bool {
	return false
}

func (baseStatementContext) Remove() {
	panic("this context cannot remove")
}

// unwind uses panic/recover to allow quickly unwinding up to
// the top-level walk function.
func (c baseStatementContext) unwind(err error) {
	panic(walker.WalkError{Reason: err})
}

// scalerStatementContext instances should be obtained through
// newScalarStatementContext.
type scalerStatementContext struct {
	baseStatementContext
	allowRemove bool
	replacement statementImpl
}

var _ StatementContext = &scalerStatementContext{}

var scalarStatementContextPool = sync.Pool{New: func() interface{} {
	return &scalerStatementContext{}
}}

func newScalarStatementContext(
	parent baseStatementContext, assignableTo reflect.Type, allowRemove bool,
) *scalerStatementContext {
	ret := scalarStatementContextPool.Get().(*scalerStatementContext)
	*ret = scalerStatementContext{
		baseStatementContext: baseStatementContext{
			Context:      parent.Context,
			assignableTo: assignableTo,
		},
		allowRemove: allowRemove,
	}
	return ret
}

func (c *scalerStatementContext) close() {
	scalarStatementContextPool.Put(c)
}

func (c *scalerStatementContext) CanRemove() bool {
	return c.allowRemove
}

func (*scalerStatementContext) CanReplace() bool {
	return true
}

func (c *scalerStatementContext) Remove() {
	if c.allowRemove {
		c.dirty = true
		c.replacement = nil
	} else {
		c.baseStatementContext.Remove()
	}
}

func (c *scalerStatementContext) Replace(n Statement) {
	if n == nil {
		c.Remove()
	} else {
		c.dirty = true
		c.replacement = ensureStatementImpl(n, c.assignableTo)
	}
}

type sliceStatementContext struct {
	baseStatementContext
	didRemove    bool
	didReplace   bool
	insertAfter  []statementImpl
	insertBefore []statementImpl
	replace      statementImpl
}

func (c *sliceStatementContext) CanInsertAfter() bool {
	return true
}
func (c *sliceStatementContext) CanInsertBefore() bool {
	return true
}
func (c *sliceStatementContext) CanRemove() bool {
	return true
}
func (c *sliceStatementContext) CanReplace() bool {
	return true
}
func (c *sliceStatementContext) InsertAfter(val Statement) {
	c.dirty = true
	c.insertAfter = append(c.insertAfter, ensureStatementImpl(val, c.assignableTo))
}
func (c *sliceStatementContext) InsertBefore(val Statement) {
	c.dirty = true
	c.insertBefore = append(c.insertBefore, ensureStatementImpl(val, c.assignableTo))
}
func (c *sliceStatementContext) Remove() {
	c.dirty = true
	c.didRemove = true
	c.didReplace = false
}
func (c *sliceStatementContext) Replace(x Statement) {
	c.dirty = true
	c.didRemove = false
	c.didReplace = true
	c.replace = ensureStatementImpl(x, c.assignableTo)
}
