// Copyright 2016 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package grpcutil

import (
	"context"
	"math"
	"regexp"
	"time"

	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/cockroachdb/cockroach/pkg/util/log/severity"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	"github.com/cockroachdb/cockroach/pkg/util/timeutil"
	"google.golang.org/grpc/grpclog"
)

func init() {
	SetSeverity(severity.ERROR)
}

// SetSeverity sets the severity level below which GRPC log messages are
// suppressed.
//
// Must be called before GRPC is used.
func SetSeverity(s log.Severity) {
	grpclog.SetLoggerV2((*logger)(&s))
}

// NB: This interface is implemented by a pointer because using a value causes
// a synthetic stack frame to be inserted on calls to the interface methods.
// Specifically, we get a stack frame that appears as "<autogenerated>", which
// is not useful in logs.
//
// Also NB: we pass a depth of 2 here because all logging calls originate from
// the logging adapter file in grpc, which is an additional stack frame away
// from the actual logging site.
var _ grpclog.LoggerV2 = (*logger)(nil)

type logger log.Severity

func (sev *logger) Info(args ...interface{}) {
	if log.Severity(*sev) > severity.INFO {
		return
	}
	log.InfofDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Infoln(args ...interface{}) {
	if log.Severity(*sev) > severity.INFO {
		return
	}
	log.InfofDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Infof(format string, args ...interface{}) {
	if log.Severity(*sev) > severity.INFO {
		return
	}
	log.InfofDepth(context.TODO(), 2, format, args...)
}

func (sev *logger) Warning(args ...interface{}) {
	if log.Severity(*sev) > severity.WARNING {
		return
	}
	if shouldPrintWarning(args...) {
		log.WarningfDepth(context.TODO(), 2, "", args...)
	}
}

func (sev *logger) Warningln(args ...interface{}) {
	if log.Severity(*sev) > severity.WARNING {
		return
	}
	log.WarningfDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Warningf(format string, args ...interface{}) {
	if log.Severity(*sev) > severity.WARNING {
		return
	}
	log.WarningfDepth(context.TODO(), 2, format, args...)
}

func (sev *logger) Error(args ...interface{}) {
	if log.Severity(*sev) > severity.ERROR {
		return
	}
	log.ErrorfDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Errorln(args ...interface{}) {
	if log.Severity(*sev) > severity.ERROR {
		return
	}
	log.ErrorfDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Errorf(format string, args ...interface{}) {
	if log.Severity(*sev) > severity.ERROR {
		return
	}
	log.ErrorfDepth(context.TODO(), 2, format, args...)
}

func (sev *logger) Fatal(args ...interface{}) {
	if log.Severity(*sev) > severity.NONE {
		return
	}
	log.FatalfDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Fatalln(args ...interface{}) {
	if log.Severity(*sev) > severity.NONE {
		return
	}
	log.FatalfDepth(context.TODO(), 2, "", args...)
}

func (sev *logger) Fatalf(format string, args ...interface{}) {
	if log.Severity(*sev) > severity.NONE {
		return
	}
	log.FatalfDepth(context.TODO(), 2, format, args...)
}

func (sev *logger) V(i int) bool {
	if i < 0 {
		i = 0
	}
	if i > math.MaxInt32 {
		i = math.MaxInt32
	}
	return log.VDepth(log.Level(i) /* level */, 1 /* depth */)
}

// https://github.com/grpc/grpc-go/blob/v1.29.1/clientconn.go#L1275
const (
	outgoingConnSpamReSrc = `^grpc: addrConn\.createTransport failed to connect to.*(` +
		// *nix
		`connection refused` + `|` +
		// Windows
		`No connection could be made because the target machine actively refused it` + `|` +
		// Host removed from the network and no longer resolvable:
		// https://github.com/golang/go/blob/go1.8.3/src/net/net.go#L566
		`no such host` + `|` +
		// RPC dialer is currently failing but also retrying.
		errCannotReuseClientConnMsg +
		`)`

	// When a TCP probe simply opens and immediately closes the
	// connection, gRPC is unhappy that the TLS handshake did not
	// complete. We don't care.
	incomingConnSpamReSrc = `^grpc: Server\.Serve failed to complete security handshake from "[^"]*": EOF`
)

var outgoingConnSpamRe = regexp.MustCompile(outgoingConnSpamReSrc)
var incomingConnSpamRe = regexp.MustCompile(incomingConnSpamReSrc)

var spamMu = struct {
	syncutil.Mutex
	strs map[string]time.Time
}{
	strs: make(map[string]time.Time),
}

const minSpamLogInterval = 30 * time.Second

// shouldPrintWarning returns true iff the gRPC warning message
// identified by args can be logged now. It returns false for outgoing
// connections errors that repeat within minSpamLogInterval of each
// other, and also for certain types of incoming connection errors.
func shouldPrintWarning(args ...interface{}) bool {
	for _, arg := range args {
		if argStr, ok := arg.(string); ok {
			// Incoming connection errors that match the criteria are blocked
			// always.
			if incomingConnSpamRe.MatchString(argStr) {
				return false
			}

			// Outgoing connection errors are only reported if performed too
			// often.
			// TODO(knz): Maybe the string map should be cleared periodically,
			// to avoid unbounded memory growth.
			if outgoingConnSpamRe.MatchString(argStr) {
				now := timeutil.Now()
				spamMu.Lock()
				t, ok := spamMu.strs[argStr]
				doPrint := !(ok && now.Sub(t) < minSpamLogInterval)
				if doPrint {
					spamMu.strs[argStr] = now
				}
				spamMu.Unlock()
				return doPrint
			}
		}
	}
	return true
}
