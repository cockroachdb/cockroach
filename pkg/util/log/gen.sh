#!/usr/bin/env bash

set -eu -o pipefail

pkg=$(dirname "$0")

all_severities=$(awk '
/enum Severity/ { active=1; next }
/}/ { active=0; next }
/^[ \t]*[A-Z][A-Z]*/ { if (active) { print $1 } }
' <$pkg/logpb/log.proto)

severities=()
severities_comments=()
severities_raw_comments=()
for s in $all_severities; do
    raw_comment=$(awk '
/\/\/ '$s'/ { active=1; print $0; next }
/^[ \t]*[A-Z][A-Z]*/ { active=0; next }
{ if (active) { print $0 } }
' <$pkg/logpb/log.proto | sed -e "s/^ *//g")

    if test $s = NONE -o $s = UNKNOWN -o $s = DEFAULT; then
        eval ${s}_COMMENT="\$raw_comment"
        continue
    fi

    comment=$(echo "$raw_comment" | sed -e "s/$s/The $s severity/g")
    set +u # builder image bash is too old and balks at expanding an empty array
    severities=(${severities[*]} $s)
    severities_raw_comments=("${severities_raw_comments[@]}" "$raw_comment")
    severities_comments=("${severities_comments[@]}" "$comment")
    set -u
done

all_channels=$(awk '
/enum Channel/ { active=1; next }
/}/ { active=0; next }
/^[ \t]*[A-Z][A-Z]*/ { if (active) { print $1 } }
' <$pkg/logpb/log.proto)

channels=()
channels_comments=()
channels_raw_comments=()
for s in $all_channels; do
    raw_comment=$(awk '
/\/\/ '$s'/ { active=1; print $0; next }
/^[ \t]*[A-Z][A-Z]*/ { active=0; next }
{ if (active) { print $0 } }
' <$pkg/logpb/log.proto | sed -e "s/^ *//g")
    comment=$(echo "$raw_comment" | sed -e "s/$s/The $s channel/g")
    set +u # builder image bash is too old and balks at expanding an empty array
    channels=(${channels[*]} $s)
    channels_comments=("${channels_comments[@]}" "$comment")
    channels_raw_comments=("${channels_raw_comments[@]}" "$raw_comment")
    set -u
done

if test $1 = log_channels.go; then
    cat <<EOF
// Code generated by gen.sh. DO NOT EDIT.

package log

import (
  "context"

  "github.com/cockroachdb/cockroach/pkg/util/log/channel"
  "github.com/cockroachdb/cockroach/pkg/util/log/severity"
)

// ChannelLogger is a helper interface to ease the run-time selection
// of channels. We do not force use of ChannelLogger when
// instantiating the logger objects below (e.g. by giving them the
// interface type), to ensure the calls remain inlinable in the common
// case.
//
// Note that casting a channel logger to the interface
// type yields a heap allocation: it may be useful for performance to
// pre-allocate interface references in the global scope.
type ChannelLogger interface {
EOF

    for sidx in ${!severities[*]}; do
        SEVERITY=${severities[$sidx]}
        severity=${SEVERITY,,} # FOO -> foo
        severityw=(${severity//_/ }) # foo_bar -> (foo bar)
        Severityt=${severityw[*]^} # (foo bar) -> (Foo Bar)
        Severityt=${Severityt[*]} # (Foo Bar) -> "Foo Bar"
        Severity=${Severityt// /} # "Foo Bar" -> "FooBar"
        SeverityComment=${severities_comments[$sidx]}
        cat <<EOF
  // ${Severity}f logs to the channel with severity ${SEVERITY}.
  // It extracts log tags from the context and logs them along with the given
  // message. Arguments are handled in the manner of fmt.Printf.
  ${Severity}f(ctx context.Context, format string, args ...interface{})

  // V${Severity}f logs to the channel with severity ${SEVERITY},
  // if logging has been enabled for the source file where the call is
  // performed at the provided verbosity level, via the vmodule setting.
  // It extracts log tags from the context and logs them along with the given
  // message. Arguments are handled in the manner of fmt.Printf.
  V${Severity}f(ctx context.Context, level Level, format string, args ...interface{})

  // ${Severity} logs to the channel with severity ${SEVERITY}.
  // It extracts log tags from the context and logs them along with the given
  // message.
  ${Severity}(ctx context.Context, msg string)

  // ${Severity}fDepth logs to the channel with severity ${SEVERITY},
  // offsetting the caller's stack frame by 'depth'.
  // It extracts log tags from the context and logs them along with the given
  // message. Arguments are handled in the manner of fmt.Printf.
  ${Severity}fDepth(ctx context.Context, depth int, format string, args ...interface{})
EOF
    done

    cat <<EOF
  // Shout logs to the channel, and also to the real stderr if logging
  // is currently redirected to a file.
  Shout(ctx context.Context, sev Severity, msg string)

  // Shoutf logs to the channel, and also to the real stderr if
  // logging is currently redirected to a file. Arguments are handled in
  // the manner of fmt.Printf.
  Shoutf(ctx context.Context, sev Severity, format string, args ...interface{})
EOF
    echo "}"
    echo

    for cidx in ${!channels[*]}; do
        CHANNEL=${channels[$cidx]}
        channel=${CHANNEL,,} # FOO -> foo
        channelw=(${channel//_/ }) # foo_bar -> (foo bar)
        Channelt=${channelw[*]^} # (foo bar) -> (Foo Bar)
        Channelt=${Channelt[*]} # (Foo Bar) -> "Foo Bar"
        Channel=${Channelt// /} # "Foo Bar" -> "FooBar"
        ChannelComment=${channels_comments[$cidx]}

        cat <<EOF
// logger${Channel} is the logger type for the ${CHANNEL} channel.
type logger${Channel} struct{}

// ${Channel} is a logger that logs to the ${CHANNEL} channel.
//
${ChannelComment}
var ${Channel} logger${Channel}

// ${Channel} and logger${Channel} implement ChannelLogger.
//
// We do not force use of ChannelLogger when instantiating the logger
// object above (e.g. by giving it the interface type), to ensure
// the calls to the API methods remain inlinable in the common case.
var _ ChannelLogger = ${Channel}

EOF
        
        for sidx in ${!severities[*]}; do
            SEVERITY=${severities[$sidx]}
            severity=${SEVERITY,,} # FOO -> foo
            severityw=(${severity//_/ }) # foo_bar -> (foo bar)
            Severityt=${severityw[*]^} # (foo bar) -> (Foo Bar)
            Severityt=${Severityt[*]} # (Foo Bar) -> "Foo Bar"
            Severity=${Severityt// /} # "Foo Bar" -> "FooBar"
            SeverityComment=${severities_comments[$sidx]}

            cat <<EOF
// ${Severity}f logs to the ${CHANNEL} channel with severity ${SEVERITY}.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func (logger${Channel}) ${Severity}f(ctx context.Context, format string, args ...interface{}) {
  logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
}

// V${Severity}f logs to the ${CHANNEL} channel with severity ${SEVERITY},
// if logging has been enabled for the source file where the call is
// performed at the provided verbosity level, via the vmodule setting.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func (logger${Channel}) V${Severity}f(ctx context.Context, level Level, format string, args ...interface{}) {
  if VDepth(level, 1) {
    logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
  }
}

// ${Severity} logs to the ${CHANNEL} channel with severity ${SEVERITY}.
// It extracts log tags from the context and logs them along with the given
// message.
//
${ChannelComment}
//
${SeverityComment}
func (logger${Channel}) ${Severity}(ctx context.Context, msg string) {
  logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, msg)
}

// ${Severity}fDepth logs to the ${CHANNEL} channel with severity ${SEVERITY},
// offsetting the caller's stack frame by 'depth'.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func (logger${Channel}) ${Severity}fDepth(ctx context.Context, depth int, format string, args ...interface{}) {
  logfDepth(ctx, depth+1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
}

EOF
            if test $CHANNEL = DEV; then
                cat <<EOF
// ${Severity}f logs to the ${CHANNEL} channel with severity ${SEVERITY},
// if logging has been enabled for the source file where the call is
// performed at the provided verbosity level, via the vmodule setting.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func ${Severity}f(ctx context.Context, format string, args ...interface{}) {
  logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
}

// V${Severity}f logs to the ${CHANNEL} channel with severity ${SEVERITY}.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func V${Severity}f(ctx context.Context, level Level, format string, args ...interface{}) {
  if VDepth(level, 1) {
    logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
  }
}

// ${Severity} logs to the ${CHANNEL} channel with severity ${SEVERITY}.
// It extracts log tags from the context and logs them along with the given
// message.
//
${ChannelComment}
//
${SeverityComment}
func ${Severity}(ctx context.Context, msg string) {
  logfDepth(ctx, 1, severity.${SEVERITY}, channel.${CHANNEL}, msg)
}

// ${Severity}fDepth logs to the ${CHANNEL} channel with severity ${SEVERITY},
// offsetting the caller's stack frame by 'depth'.
// It extracts log tags from the context and logs them along with the given
// message. Arguments are handled in the manner of fmt.Printf.
//
${ChannelComment}
//
${SeverityComment}
func ${Severity}fDepth(ctx context.Context, depth int, format string, args ...interface{}) {
  logfDepth(ctx, depth+1, severity.${SEVERITY}, channel.${CHANNEL}, format, args...)
}

EOF
            fi
        done

        cat <<EOF
// Shout logs to channel ${CHANNEL}, and also to the real stderr if logging
// is currently redirected to a file.
//
${ChannelComment}
func (logger${Channel}) Shout(ctx context.Context, sev Severity, msg string) {
  shoutfDepth(ctx, 1, sev, channel.${CHANNEL}, msg)
}

// Shoutf logs to channel ${CHANNEL}, and also to the real stderr if
// logging is currently redirected to a file. Arguments are handled in
// the manner of fmt.Printf.
//
${ChannelComment}
func (logger${Channel}) Shoutf(ctx context.Context, sev Severity, format string, args ...interface{}) {
  shoutfDepth(ctx, 1, sev, channel.${CHANNEL}, format, args...)
}

EOF
        if test $CHANNEL = DEV; then
            cat <<EOF
// Shout logs to channel ${CHANNEL}, and also to the real stderr if logging
// is currently redirected to a file.
//
${ChannelComment}
func Shout(ctx context.Context, sev Severity, msg string) {
  shoutfDepth(ctx, 1, sev, channel.${CHANNEL}, msg)
}

// Shoutf logs to channel ${CHANNEL}, and also to the real stderr if
// logging is currently redirected to a file. Arguments are handled in
// the manner of fmt.Printf.
//
${ChannelComment}
func Shoutf(ctx context.Context, sev Severity, format string, args ...interface{}) {
  shoutfDepth(ctx, 1, sev, channel.${CHANNEL}, format, args...)
}

EOF
        fi
    done
fi

if test $1 = logging.md; then
    echo "# Logging levels (severities)"
    echo

    for sidx in ${!severities[*]}; do
        SEVERITY=${severities[$sidx]}
        SeverityComment=${severities_comments[$sidx]}

        echo "## $SEVERITY"
        echo
        echo "$SeverityComment" | sed -e 's,^// ,,g;s,^// *$,,g'
        echo
    done

    echo "# Logging channels"
    echo

    for sidx in ${!channels[*]}; do
        CHANNEL=${channels[$sidx]}
        ChannelComment=${channels_comments[$sidx]}

        echo "## $CHANNEL"
        echo
        echo "$ChannelComment" | sed -e 's,^// ,,g;s,^// *$,,g'
        echo
    done
fi

if test $1 = severity.go; then
   cat <<EOF
// Code generated by gen.sh. DO NOT EDIT.

package severity

import "github.com/cockroachdb/cockroach/pkg/util/log/logpb"

${UNKNOWN_COMMENT}
const UNKNOWN = logpb.Severity_UNKNOWN

${DEFAULT_COMMENT}
const DEFAULT = logpb.Severity_DEFAULT

${NONE_COMMENT}
const NONE = logpb.Severity_NONE
EOF

   for sidx in ${!severities[*]}; do
       SEVERITY=${severities[$sidx]}
       severity=${SEVERITY,,} # FOO -> foo
       severityw=(${severity//_/ }) # foo_bar -> (foo bar)
       Severityt=${severityw[*]^} # (foo bar) -> (Foo Bar)
       Severityt=${Severityt[*]} # (Foo Bar) -> "Foo Bar"
       Severity=${Severityt// /} # "Foo Bar" -> "FooBar"
       SeverityComment=${severities_raw_comments[$sidx]}
       cat <<EOF

${SeverityComment}
const ${SEVERITY} = logpb.Severity_${SEVERITY}
EOF
   done
fi


if test $1 = channel.go; then
    cat <<EOF
// Code generated by gen.sh. DO NOT EDIT.

package channel

import "github.com/cockroachdb/cockroach/pkg/util/log/logpb"

EOF

    for cidx in ${!channels[*]}; do
        CHANNEL=${channels[$cidx]}
        channel=${CHANNEL,,} # FOO -> foo
        channelw=(${channel//_/ }) # foo_bar -> (foo bar)
        Channelt=${channelw[*]^} # (foo bar) -> (Foo Bar)
        Channelt=${Channelt[*]} # (Foo Bar) -> "Foo Bar"
        Channel=${Channelt// /} # "Foo Bar" -> "FooBar"
        ChannelComment=${channels_raw_comments[$cidx]}

        cat <<EOF

${ChannelComment}
const ${CHANNEL} = logpb.Channel_${CHANNEL}
EOF
    done
fi
