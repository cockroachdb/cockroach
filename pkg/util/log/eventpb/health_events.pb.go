// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/eventpb/health_events.proto

package eventpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RuntimeStats is recorded every 10 seconds as server health metrics.
type RuntimeStats struct {
	CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// The process RSS. Expressed as mebibytes.
	RSS string `protobuf:"bytes,2,opt,name=rss,proto3" json:",omitempty"`
	// The number of goroutines.
	NumGoroutines string `protobuf:"bytes,3,opt,name=num_goroutines,json=numGoroutines,proto3" json:",omitempty"`
	// The stack system memory used. Expressed as mebibytes.
	StackSysMemory string `protobuf:"bytes,4,opt,name=stack_sys_memory,json=stackSysMemory,proto3" json:",omitempty"`
	// The ratio of the mebibytes of memory allocated by Go to the total mebibytes of memory allocated by Go but not released.
	GoMemoryRatio string `protobuf:"bytes,5,opt,name=go_memory_ratio,json=goMemoryRatio,proto3" json:",omitempty"`
	// If the Go memory statistics are stale, the stale message.
	StaleMessage string `protobuf:"bytes,6,opt,name=stale_message,json=staleMessage,proto3" json:",omitempty"`
	// The amount of heap fragmentation. Expressed as mebibytes.
	HeapFragmentation string `protobuf:"bytes,7,opt,name=heap_fragmentation,json=heapFragmentation,proto3" json:",omitempty"`
	// The amount of heap reserved. Expressed as mebibytes.
	HeapReserved string `protobuf:"bytes,8,opt,name=heap_reserved,json=heapReserved,proto3" json:",omitempty"`
	// The amount of heap released. Expressed as mebibytes.
	HeapReleased string `protobuf:"bytes,9,opt,name=heap_released,json=heapReleased,proto3" json:",omitempty"`
	// The ratio of the mebibytes of memory allocated outside of Go to the total mebibytes of memory allocated outside of Go but not released.
	CGoMemoryRatio string `protobuf:"bytes,10,opt,name=cgo_memory_ratio,json=cgoMemoryRatio,proto3" json:",omitempty"`
	// The total number of calls outside of Go over time. Expressed as operations per second.
	CGoRate string `protobuf:"bytes,11,opt,name=cgo_rate,json=cgoRate,proto3" json:",omitempty"`
	// The ratio of user CPU percentage to system CPU percentage.
	CPURatio string `protobuf:"bytes,12,opt,name=cpu_ratio,json=cpuRatio,proto3" json:",omitempty"`
	// The GC pause percentage.
	GCPauseRatio string `protobuf:"bytes,13,opt,name=gc_pause_ratio,json=gcPauseRatio,proto3" json:",omitempty"`
	// The total number of GC runs.
	GCCount string `protobuf:"bytes,14,opt,name=gc_count,json=gcCount,proto3" json:",omitempty"`
	// The ratio of kilobytes received to kilobytes sent, on all network interfaces since this process started.
	HostNetBytesRatio string `protobuf:"bytes,15,opt,name=host_net_bytes_ratio,json=hostNetBytesRatio,proto3" json:",omitempty"`
}

func (m *RuntimeStats) Reset()         { *m = RuntimeStats{} }
func (m *RuntimeStats) String() string { return proto.CompactTextString(m) }
func (*RuntimeStats) ProtoMessage()    {}
func (*RuntimeStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb2537843d9e7598, []int{0}
}
func (m *RuntimeStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuntimeStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeStats.Merge(m, src)
}
func (m *RuntimeStats) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeStats) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeStats.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeStats proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RuntimeStats)(nil), "cockroach.util.log.eventpb.RuntimeStats")
}

func init() {
	proto.RegisterFile("util/log/eventpb/health_events.proto", fileDescriptor_eb2537843d9e7598)
}

var fileDescriptor_eb2537843d9e7598 = []byte{
	// 563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0x4f, 0x6b, 0xdb, 0x3e,
	0x18, 0xc7, 0xed, 0x5f, 0x7f, 0x6b, 0x52, 0xd5, 0x75, 0x3b, 0xd1, 0x81, 0x17, 0x98, 0x1d, 0xc6,
	0x60, 0x1d, 0x0c, 0x07, 0xd6, 0xfd, 0xbb, 0x8c, 0x41, 0xdc, 0x2d, 0x30, 0xe8, 0x28, 0xce, 0x76,
	0xd9, 0xc5, 0x28, 0xea, 0x33, 0xc5, 0xd4, 0xb6, 0x8c, 0x25, 0x17, 0xf2, 0x1e, 0x76, 0xd8, 0xcb,
	0xca, 0x31, 0xc7, 0x9e, 0xcc, 0xe6, 0xdc, 0xfa, 0x2a, 0x86, 0x14, 0xb3, 0x66, 0x99, 0xbb, 0x5b,
	0x2c, 0x7d, 0x3e, 0xdf, 0xef, 0xc3, 0x13, 0x84, 0x1e, 0x95, 0x32, 0x4e, 0x06, 0x09, 0x67, 0x03,
	0xb8, 0x84, 0x4c, 0xe6, 0x93, 0xc1, 0x14, 0x48, 0x22, 0xa7, 0x91, 0xfe, 0x14, 0x7e, 0x5e, 0x70,
	0xc9, 0x71, 0x8f, 0x72, 0x7a, 0x51, 0x70, 0x42, 0xa7, 0xbe, 0xe2, 0xfd, 0x84, 0x33, 0xbf, 0xe1,
	0x7b, 0x87, 0x8c, 0x33, 0xae, 0xb1, 0x81, 0xfa, 0xb5, 0x32, 0x7a, 0x0f, 0xfe, 0xca, 0x5d, 0x0f,
	0x7c, 0xf8, 0xad, 0x83, 0xac, 0xb0, 0xcc, 0x64, 0x9c, 0xc2, 0x58, 0x12, 0x29, 0xf0, 0x27, 0xb4,
	0x4d, 0x79, 0x9a, 0xf2, 0xcc, 0x31, 0xfb, 0xe6, 0xd1, 0xee, 0x33, 0xdf, 0xbf, 0xbd, 0xd2, 0x0f,
	0x34, 0xf9, 0x4e, 0x7d, 0x9d, 0x80, 0x24, 0x71, 0x22, 0x86, 0xd6, 0xbc, 0xf2, 0x8c, 0x45, 0xe5,
	0x99, 0xd7, 0x95, 0x67, 0x84, 0x4d, 0x16, 0x7e, 0x8c, 0xb6, 0x0a, 0x21, 0x9c, 0xff, 0xfa, 0xe6,
	0xd1, 0xce, 0xf0, 0x5e, 0x5d, 0x79, 0x5b, 0xe1, 0x78, 0x7c, 0x5d, 0x79, 0xe8, 0x29, 0x4f, 0x63,
	0x09, 0x69, 0x2e, 0x67, 0xa1, 0x22, 0xf0, 0x0b, 0x64, 0x67, 0x65, 0x1a, 0x31, 0x5e, 0xf0, 0x52,
	0xc6, 0x19, 0x08, 0x67, 0x4b, 0x3b, 0xf6, 0x06, 0xbc, 0x97, 0x95, 0xe9, 0xe8, 0x37, 0x84, 0x5f,
	0xa3, 0x03, 0x21, 0x09, 0xbd, 0x88, 0xc4, 0x4c, 0x44, 0x29, 0xa4, 0xbc, 0x98, 0x39, 0xff, 0xb7,
	0x8a, 0xb6, 0xe6, 0xc6, 0x33, 0x71, 0xaa, 0x29, 0xfc, 0x12, 0xed, 0x33, 0xde, 0x28, 0x51, 0x41,
	0x64, 0xcc, 0x9d, 0x3b, 0xed, 0x8d, 0x8c, 0xaf, 0x94, 0x50, 0x41, 0xf8, 0x18, 0xed, 0x09, 0x49,
	0x12, 0x88, 0x52, 0x10, 0x82, 0x30, 0x70, 0xb6, 0x5b, 0x2d, 0x4b, 0x43, 0xa7, 0x2b, 0x06, 0xbf,
	0x41, 0x78, 0x0a, 0x24, 0x8f, 0xbe, 0x16, 0x84, 0xa5, 0x90, 0x49, 0x95, 0x94, 0x39, 0x9d, 0x56,
	0xf3, 0xae, 0x22, 0xdf, 0xaf, 0x83, 0xaa, 0x53, 0xeb, 0x05, 0x08, 0x28, 0x2e, 0xe1, 0xdc, 0xe9,
	0xb6, 0x77, 0x2a, 0x28, 0x6c, 0x98, 0x35, 0x29, 0x01, 0x22, 0xe0, 0xdc, 0xd9, 0xf9, 0x97, 0xb4,
	0x62, 0xf0, 0x07, 0x74, 0x40, 0x37, 0xd7, 0x82, 0xb4, 0xd7, 0xaf, 0x2b, 0xcf, 0x0e, 0x46, 0xeb,
	0xbb, 0xd8, 0xdc, 0x30, 0xfd, 0x73, 0x53, 0xcf, 0x51, 0x57, 0x65, 0x15, 0x44, 0x82, 0xb3, 0xab,
	0x33, 0xee, 0xd7, 0x95, 0xd7, 0x09, 0x46, 0x3c, 0x24, 0x12, 0x36, 0xe4, 0x0e, 0x65, 0xfa, 0x18,
	0xbf, 0x42, 0x3b, 0x34, 0x2f, 0x9b, 0x6a, 0x4b, 0x6b, 0xbd, 0xba, 0xf2, 0xba, 0xc1, 0xd9, 0xe7,
	0xb6, 0xd2, 0x2e, 0xcd, 0xcb, 0x55, 0xdd, 0x09, 0xb2, 0x19, 0x8d, 0x72, 0x52, 0x0a, 0x68, 0xec,
	0x3d, 0x6d, 0xbb, 0x75, 0xe5, 0x59, 0xa3, 0xe0, 0x4c, 0x5d, 0xb4, 0x25, 0x58, 0x8c, 0xde, 0xdc,
	0xa9, 0xa1, 0x19, 0x8d, 0x28, 0x2f, 0x33, 0xe9, 0xd8, 0x37, 0x43, 0x8f, 0x82, 0x40, 0x1d, 0x6d,
	0x0e, 0xcd, 0xa8, 0x3e, 0xc6, 0x6f, 0xd1, 0xe1, 0x94, 0x0b, 0x19, 0x65, 0x20, 0xa3, 0xc9, 0x4c,
	0x82, 0x68, 0x26, 0xd8, 0xbf, 0xe5, 0x1f, 0xe6, 0x42, 0x7e, 0x04, 0x39, 0x54, 0xa4, 0xae, 0x1d,
	0x3e, 0x99, 0xff, 0x74, 0x8d, 0x79, 0xed, 0x9a, 0x8b, 0xda, 0x35, 0xaf, 0x6a, 0xd7, 0xfc, 0x51,
	0xbb, 0xe6, 0xf7, 0xa5, 0x6b, 0x2c, 0x96, 0xae, 0x71, 0xb5, 0x74, 0x8d, 0x2f, 0x9d, 0xe6, 0xed,
	0x4d, 0xb6, 0xf5, 0x03, 0x3e, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0x56, 0xf9, 0x72, 0x26, 0x39,
	0x04, 0x00, 0x00,
}

func (m *RuntimeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostNetBytesRatio) > 0 {
		i -= len(m.HostNetBytesRatio)
		copy(dAtA[i:], m.HostNetBytesRatio)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.HostNetBytesRatio)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.GCCount) > 0 {
		i -= len(m.GCCount)
		copy(dAtA[i:], m.GCCount)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.GCCount)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.GCPauseRatio) > 0 {
		i -= len(m.GCPauseRatio)
		copy(dAtA[i:], m.GCPauseRatio)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.GCPauseRatio)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CPURatio) > 0 {
		i -= len(m.CPURatio)
		copy(dAtA[i:], m.CPURatio)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.CPURatio)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.CGoRate) > 0 {
		i -= len(m.CGoRate)
		copy(dAtA[i:], m.CGoRate)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.CGoRate)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CGoMemoryRatio) > 0 {
		i -= len(m.CGoMemoryRatio)
		copy(dAtA[i:], m.CGoMemoryRatio)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.CGoMemoryRatio)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.HeapReleased) > 0 {
		i -= len(m.HeapReleased)
		copy(dAtA[i:], m.HeapReleased)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.HeapReleased)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HeapReserved) > 0 {
		i -= len(m.HeapReserved)
		copy(dAtA[i:], m.HeapReserved)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.HeapReserved)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.HeapFragmentation) > 0 {
		i -= len(m.HeapFragmentation)
		copy(dAtA[i:], m.HeapFragmentation)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.HeapFragmentation)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StaleMessage) > 0 {
		i -= len(m.StaleMessage)
		copy(dAtA[i:], m.StaleMessage)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.StaleMessage)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GoMemoryRatio) > 0 {
		i -= len(m.GoMemoryRatio)
		copy(dAtA[i:], m.GoMemoryRatio)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.GoMemoryRatio)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StackSysMemory) > 0 {
		i -= len(m.StackSysMemory)
		copy(dAtA[i:], m.StackSysMemory)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.StackSysMemory)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NumGoroutines) > 0 {
		i -= len(m.NumGoroutines)
		copy(dAtA[i:], m.NumGoroutines)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.NumGoroutines)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RSS) > 0 {
		i -= len(m.RSS)
		copy(dAtA[i:], m.RSS)
		i = encodeVarintHealthEvents(dAtA, i, uint64(len(m.RSS)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintHealthEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintHealthEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovHealthEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RuntimeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovHealthEvents(uint64(l))
	l = len(m.RSS)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.NumGoroutines)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.StackSysMemory)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.GoMemoryRatio)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.StaleMessage)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.HeapFragmentation)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.HeapReserved)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.HeapReleased)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.CGoMemoryRatio)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.CGoRate)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.CPURatio)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.GCPauseRatio)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.GCCount)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	l = len(m.HostNetBytesRatio)
	if l > 0 {
		n += 1 + l + sovHealthEvents(uint64(l))
	}
	return n
}

func sovHealthEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHealthEvents(x uint64) (n int) {
	return sovHealthEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RuntimeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHealthEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RSS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumGoroutines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumGoroutines = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackSysMemory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StackSysMemory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoMemoryRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoMemoryRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaleMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeapFragmentation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeapFragmentation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeapReserved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeapReserved = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeapReleased", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeapReleased = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CGoMemoryRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CGoMemoryRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CGoRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CGoRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPURatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPURatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPauseRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCPauseRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCCount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetBytesRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHealthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostNetBytesRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHealthEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHealthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHealthEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHealthEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHealthEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHealthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHealthEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHealthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHealthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHealthEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHealthEvents = fmt.Errorf("proto: unexpected end of group")
)
