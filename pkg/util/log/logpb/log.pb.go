// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/logpb/log.proto

package logpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Severity is the severity level of individual log events.
//
// Note: do not forget to run gen.sh (go generate) when
// changing this list or the explanatory comments.
type Severity int32

const (
	// UNKNOWN is populated into decoded log entries when the
	// severity could not be determined.
	Severity_UNKNOWN Severity = 0
	// INFO is used for informational messages, when no action
	// is required as a result.
	Severity_INFO Severity = 1
	// WARNING is used for situations which may require special handling,
	// while normal operation is expected to resume automatically.
	Severity_WARNING Severity = 2
	// ERROR is used for situations that require special handling,
	// when normal operation could not proceed as expected.
	// Other operations can continue mostly unaffected.
	Severity_ERROR Severity = 3
	// FATAL is used for situations that require an immedate, hard
	// server shutdown. A report is also sent to telemetry if telemetry
	// is enabled.
	Severity_FATAL Severity = 4
	// NONE can be used in filters to specify that no messages
	// should be emitted.
	Severity_NONE Severity = 5
	// DEFAULT is the end sentinel. It is used during command-line
	// handling to indicate that another value should be replaced instead
	// (depending on which command is being run); see cli/flags.go for
	// details.
	Severity_DEFAULT Severity = 6
)

var Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "INFO",
	2: "WARNING",
	3: "ERROR",
	4: "FATAL",
	5: "NONE",
	6: "DEFAULT",
}

var Severity_value = map[string]int32{
	"UNKNOWN": 0,
	"INFO":    1,
	"WARNING": 2,
	"ERROR":   3,
	"FATAL":   4,
	"NONE":    5,
	"DEFAULT": 6,
}

func (x Severity) String() string {
	return proto.EnumName(Severity_name, int32(x))
}

func (Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{0}
}

// Channel is the logical logging channel on which a message is sent.
// Different channels can be redirected to different sinks. All
// messages from the same channel are sent to the same sink(s).
//
//
// Note: do not forget to run gen.sh (go generate) when
// changing this list or the explanatory comments.
type Channel int32

const (
	// DEV is the channel used during development, to collect log
	// details useful for troubleshooting when it is unclear which other
	// channel to use. It is also the default logging channel in
	// CockroachDB, when the caller does not indicate a channel.
	//
	// This channel is special in that there are no constraints as to
	// what may or may not be logged on it. Conversely, users in
	// production deployments are invited to not collect DEV logs in
	// centralized logging facilities, because they likely contain
	// sensitive operational data.
	Channel_DEV Channel = 0
	// OPS is the channel used to report "point" operational events,
	// initiated by user operators or automation:
	//
	// - operator or system actions on server processes: process starts,
	//   stops, shutdowns, crashes (if they can be logged),
	//   including each time: command-line parameters, current version being run.
	// - actions that impact the topology of a cluster: node additions,
	//   removals, decommissions, etc.
	// - job-related initiation or termination.
	// - cluster setting changes.
	// - zone configuration changes.
	Channel_OPS Channel = 1
	// HEALTH is the channel used to report "background" operational
	// events, initiated by CockroachDB or reporting on automatic processes:
	//
	// - current resource usage, including critical resource usage.
	// - node-node connection events, including connection errors and
	//   gossip details.
	// - range and table leasing events.
	// - up-, down-replication; range unavailability.
	Channel_HEALTH Channel = 2
	// STORAGE is the channel used to report low-level storage
	// layer events (RocksDB/Pebble).
	Channel_STORAGE Channel = 3
	// SESSIONS is the channel used to report client network activity:
	//
	// - connections opened/closed.
	// - authentication events: logins, failed attempts.
	// - session and query cancellation.
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_SESSIONS Channel = 4
	// SQL_SCHEMA is the channel used to report changes to the
	// SQL logical schema, excluding privilege and ownership changes
	// (which are reported on the separate channel PRIVILEGES) and
	// zone config changes (which go to OPS).
	//
	// This includes:
	//
	// - database/schema/table/sequence/view/type creation
	// - adding/removing/changing table columns
	// - changing sequence parameters
	//
	// etc., more generally changes to the schema that affect the
	// functional behavior of client apps using stored objects.
	Channel_SQL_SCHEMA Channel = 5
	// USER_ADMIN is the channel used to report changes
	// in users and roles, including:
	//
	// - users added/dropped.
	// - changes to authentication credentials, incl passwords, validity etc.
	// - role grants/revocations.
	// - role option grants/revocations.
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_USER_ADMIN Channel = 6
	// PRIVILEGES is the channel used to report data
	// authorization changes, including:
	//
	// - privilege grants/revocations on database, objects etc.
	// - object ownership changes.
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_PRIVILEGES Channel = 7
	// SENSITIVE_ACCESS is the channel used to report SQL
	// data access to sensitive data (when enabled):
	//
	// - data access audit events (when table audit is enabled).
	// - SQL statements executed by users with the ADMIN bit.
	// - operations that write to `system` tables.
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_SENSITIVE_ACCESS Channel = 8
	// SQL_EXEC is the channel used to report SQL execution on
	// behalf of client connections:
	//
	// - logical SQL statement executions (if enabled)
	// - pgwire events (if enabled)
	Channel_SQL_EXEC Channel = 9
	// SQL_PERF is the channel used to report SQL executions
	// that are marked to be highlighted as "out of the ordinary"
	// to facilitate performance investigations.
	// This includes the "SQL slow query log".
	//
	// Arguably, this channel overlaps with SQL_EXEC defined above.
	// However, we keep them separate for backward-compatibility
	// with previous versions, where the corresponding events
	// were redirected to separate files.
	Channel_SQL_PERF Channel = 10
	// SQL_INTERNAL_PERF is like the SQL perf channel above but aimed at
	// helping developers of CockroachDB itself. It exists as a separate
	// channel so as to not pollute the SQL perf logging output with
	// internal troubleshooting details.
	Channel_SQL_INTERNAL_PERF Channel = 11
	// TELEMETRY reports telemetry events. Telemetry events describe
	// feature usage within CockroachDB and anonymizes any application-
	// specific data.
	Channel_TELEMETRY Channel = 12
)

var Channel_name = map[int32]string{
	0:  "DEV",
	1:  "OPS",
	2:  "HEALTH",
	3:  "STORAGE",
	4:  "SESSIONS",
	5:  "SQL_SCHEMA",
	6:  "USER_ADMIN",
	7:  "PRIVILEGES",
	8:  "SENSITIVE_ACCESS",
	9:  "SQL_EXEC",
	10: "SQL_PERF",
	11: "SQL_INTERNAL_PERF",
	12: "TELEMETRY",
}

var Channel_value = map[string]int32{
	"DEV":               0,
	"OPS":               1,
	"HEALTH":            2,
	"STORAGE":           3,
	"SESSIONS":          4,
	"SQL_SCHEMA":        5,
	"USER_ADMIN":        6,
	"PRIVILEGES":        7,
	"SENSITIVE_ACCESS":  8,
	"SQL_EXEC":          9,
	"SQL_PERF":          10,
	"SQL_INTERNAL_PERF": 11,
	"TELEMETRY":         12,
}

func (x Channel) String() string {
	return proto.EnumName(Channel_name, int32(x))
}

func (Channel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{1}
}

// Entry represents a cockroach log entry in the following two cases:
// - when reading a log file using the crdb-v1 format, entries
//   are parsed into this struct.
// - when injecting an interceptor into the logging package, the
//   interceptor is fed entries using this structure.
type Entry struct {
	// Severity is the importance of the log entry. See the
	// documentation for the Severity enum for more details.
	Severity Severity `protobuf:"varint,1,opt,name=severity,proto3,enum=cockroach.util.log.Severity" json:"severity,omitempty"`
	// Nanoseconds since the epoch.
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// Goroutine ID. This helps match logging events with goroutine
	// stack dumps.
	Goroutine int64 `protobuf:"varint,6,opt,name=goroutine,proto3" json:"goroutine,omitempty"`
	// File name where the logging event was produced. Logging client
	// code can adjust this with the "depth" parameter.
	File string `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
	// Line number in the file where the logging event was produced.
	Line int64 `protobuf:"varint,4,opt,name=line,proto3" json:"line,omitempty"`
	// Message contains the main text of the logging message.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// Tags contains the context tags available in the context where the
	// entry was created.
	Tags string `protobuf:"bytes,7,opt,name=tags,proto3" json:"tags,omitempty"`
	// Counter is an entry counter, meant for use in audit logs as an
	// instrument against log repudiation.
	// See: https://en.wikipedia.org/wiki/Non-repudiation
	//
	// It is incremented for every use of the logger where the entry was
	// produced.
	Counter uint64 `protobuf:"varint,8,opt,name=counter,proto3" json:"counter,omitempty"`
	// Redactable is true iff the message and tags fields include markers
	// to delineate sensitive information. In that case, confidentiality
	// can be obtained by only stripping away the data within this
	// marker. If redactable is false or unknown, the message should be
	// considered to only contain sensitive information, and should be
	// stripped away completely for confidentiality.
	Redactable bool `protobuf:"varint,9,opt,name=redactable,proto3" json:"redactable,omitempty"`
	// Channel is the channel on which the message was sent.
	Channel Channel `protobuf:"varint,10,opt,name=channel,proto3,enum=cockroach.util.log.Channel" json:"channel,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{0}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

// A FileDetails holds all of the particulars that can be parsed by the name of
// a log file.
type FileDetails struct {
	Program  string `protobuf:"bytes,1,opt,name=program,proto3" json:"program,omitempty"`
	Host     string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	UserName string `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Time     int64  `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	PID      int64  `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *FileDetails) Reset()         { *m = FileDetails{} }
func (m *FileDetails) String() string { return proto.CompactTextString(m) }
func (*FileDetails) ProtoMessage()    {}
func (*FileDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{1}
}
func (m *FileDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileDetails.Merge(m, src)
}
func (m *FileDetails) XXX_Size() int {
	return m.Size()
}
func (m *FileDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_FileDetails.DiscardUnknown(m)
}

var xxx_messageInfo_FileDetails proto.InternalMessageInfo

type FileInfo struct {
	Name         string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SizeBytes    int64       `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	ModTimeNanos int64       `protobuf:"varint,3,opt,name=mod_time_nanos,json=modTimeNanos,proto3" json:"mod_time_nanos,omitempty"`
	Details      FileDetails `protobuf:"bytes,4,opt,name=details,proto3" json:"details"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{2}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.util.log.Severity", Severity_name, Severity_value)
	proto.RegisterEnum("cockroach.util.log.Channel", Channel_name, Channel_value)
	proto.RegisterType((*Entry)(nil), "cockroach.util.log.Entry")
	proto.RegisterType((*FileDetails)(nil), "cockroach.util.log.FileDetails")
	proto.RegisterType((*FileInfo)(nil), "cockroach.util.log.FileInfo")
}

func init() { proto.RegisterFile("util/log/logpb/log.proto", fileDescriptor_84e824ab4ae60f77) }

var fileDescriptor_84e824ab4ae60f77 = []byte{
	// 697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xdd, 0x6a, 0xe3, 0x46,
	0x18, 0xb5, 0x2c, 0xc9, 0x92, 0x3e, 0xa7, 0x61, 0x3a, 0x6c, 0x41, 0xed, 0x6e, 0x15, 0x13, 0x0a,
	0x35, 0x7b, 0xe1, 0x85, 0x2d, 0x85, 0xde, 0x15, 0xd9, 0x1e, 0x27, 0x6a, 0x1d, 0xd9, 0x3b, 0x52,
	0xb2, 0xfd, 0xb9, 0x10, 0xb2, 0x3d, 0x51, 0x44, 0x25, 0x8d, 0x91, 0xe4, 0x42, 0xfa, 0x0e, 0x85,
	0x3e, 0x44, 0x9f, 0xa2, 0x4f, 0x10, 0x7a, 0x95, 0xcb, 0x5c, 0x85, 0xd6, 0x79, 0x91, 0x32, 0x63,
	0x2b, 0x0d, 0x6c, 0x2e, 0x6c, 0xce, 0x39, 0x73, 0xe6, 0x9b, 0x6f, 0xce, 0xa7, 0x01, 0x7b, 0x53,
	0xa7, 0xd9, 0x9b, 0x8c, 0x27, 0xe2, 0xb7, 0x5e, 0x88, 0xff, 0xc1, 0xba, 0xe4, 0x35, 0xc7, 0x78,
	0xc9, 0x97, 0xbf, 0x94, 0x3c, 0x5e, 0x5e, 0x0d, 0x84, 0x67, 0x90, 0xf1, 0xe4, 0xb3, 0x17, 0x09,
	0x4f, 0xb8, 0x5c, 0x7e, 0x23, 0xd0, 0xce, 0x79, 0xfc, 0x57, 0x1b, 0x74, 0x52, 0xd4, 0xe5, 0x35,
	0xfe, 0x06, 0xcc, 0x8a, 0xfd, 0xca, 0xca, 0xb4, 0xbe, 0xb6, 0x95, 0x9e, 0xd2, 0x3f, 0x7c, 0xfb,
	0x6a, 0xf0, 0x61, 0x99, 0x41, 0xb0, 0xf7, 0xd0, 0x47, 0x37, 0xc6, 0xa0, 0xd5, 0x69, 0xce, 0xec,
	0x76, 0x4f, 0xe9, 0xab, 0x54, 0x62, 0xfc, 0x0a, 0xac, 0x84, 0x97, 0x7c, 0x53, 0xa7, 0x05, 0xb3,
	0x3b, 0x72, 0xe1, 0x7f, 0x41, 0xec, 0xb8, 0x4c, 0x33, 0x66, 0xab, 0x3d, 0xa5, 0x6f, 0x51, 0x89,
	0x85, 0x96, 0x09, 0xb3, 0xb6, 0xab, 0x22, 0x30, 0xb6, 0xc1, 0xc8, 0x59, 0x55, 0xc5, 0x09, 0xb3,
	0x75, 0x69, 0x6d, 0xa8, 0x3c, 0x33, 0x4e, 0x2a, 0xdb, 0xd8, 0x55, 0x10, 0x58, 0xb8, 0x97, 0x7c,
	0x53, 0xd4, 0xac, 0xb4, 0xcd, 0x9e, 0xd2, 0xd7, 0x68, 0x43, 0xb1, 0x03, 0x50, 0xb2, 0x55, 0xbc,
	0xac, 0xe3, 0x45, 0xc6, 0x6c, 0xab, 0xa7, 0xf4, 0x4d, 0xfa, 0x44, 0xc1, 0x5f, 0x83, 0xb1, 0xbc,
	0x8a, 0x8b, 0x82, 0x65, 0x36, 0xc8, 0xab, 0xbf, 0x7c, 0xee, 0xea, 0xa3, 0x9d, 0x85, 0x36, 0xde,
	0xe3, 0xdf, 0x15, 0xe8, 0x4e, 0xd2, 0x8c, 0x8d, 0x59, 0x1d, 0xa7, 0x99, 0x6c, 0x60, 0x5d, 0xf2,
	0xa4, 0x8c, 0x73, 0x99, 0xa0, 0x45, 0x1b, 0x2a, 0xda, 0xbd, 0xe2, 0x55, 0x2d, 0x23, 0xb2, 0xa8,
	0xc4, 0xf8, 0x25, 0x58, 0x9b, 0x8a, 0x95, 0x51, 0x11, 0xe7, 0x4d, 0x12, 0xa6, 0x10, 0xfc, 0x38,
	0x67, 0x8f, 0x99, 0xea, 0x4f, 0x32, 0xfd, 0x14, 0xd4, 0x75, 0xba, 0xda, 0xa5, 0x39, 0x34, 0xb6,
	0xf7, 0x47, 0xea, 0xdc, 0x1b, 0x53, 0xa1, 0x7d, 0xa7, 0x99, 0x1a, 0xd2, 0x8f, 0xff, 0x54, 0xc0,
	0x14, 0xfd, 0x78, 0xc5, 0x25, 0x17, 0x15, 0x64, 0xe5, 0x5d, 0x27, 0x12, 0xe3, 0xcf, 0x01, 0xaa,
	0xf4, 0x37, 0x16, 0x2d, 0xae, 0x6b, 0x56, 0xed, 0xe7, 0x65, 0x09, 0x65, 0x28, 0x04, 0xfc, 0x05,
	0x1c, 0xe6, 0x7c, 0x15, 0x89, 0xc3, 0xa2, 0x22, 0x2e, 0x78, 0x25, 0xdb, 0x52, 0xe9, 0x41, 0xce,
	0x57, 0x61, 0x9a, 0x33, 0x5f, 0x68, 0xf8, 0x5b, 0x30, 0x56, 0xbb, 0x0b, 0xcb, 0x59, 0x75, 0xdf,
	0x1e, 0x3d, 0x17, 0xd6, 0x93, 0x5c, 0x86, 0xda, 0xcd, 0xfd, 0x51, 0x8b, 0x36, 0xbb, 0x5e, 0xff,
	0x0c, 0x66, 0xf3, 0x15, 0xe1, 0x2e, 0x18, 0xe7, 0xfe, 0xf7, 0xfe, 0xec, 0xbd, 0x8f, 0x5a, 0xd8,
	0x04, 0xcd, 0xf3, 0x27, 0x33, 0xa4, 0x08, 0xf9, 0xbd, 0x4b, 0x7d, 0xcf, 0x3f, 0x41, 0x6d, 0x6c,
	0x81, 0x4e, 0x28, 0x9d, 0x51, 0xa4, 0x0a, 0x38, 0x71, 0x43, 0x77, 0x8a, 0x34, 0x61, 0xf6, 0x67,
	0x3e, 0x41, 0xba, 0x30, 0x8f, 0xc9, 0xc4, 0x3d, 0x9f, 0x86, 0xa8, 0xf3, 0xfa, 0x6f, 0x05, 0x8c,
	0xfd, 0xa0, 0xb0, 0x01, 0xea, 0x98, 0x5c, 0xa0, 0x96, 0x00, 0xb3, 0x79, 0x80, 0x14, 0x0c, 0xd0,
	0x39, 0x25, 0xee, 0x34, 0x3c, 0x45, 0x6d, 0xb1, 0x2d, 0x08, 0x67, 0xd4, 0x3d, 0x21, 0x48, 0xc5,
	0x07, 0x60, 0x06, 0x24, 0x08, 0xbc, 0x99, 0x1f, 0x20, 0x0d, 0x1f, 0x02, 0x04, 0xef, 0xa6, 0x51,
	0x30, 0x3a, 0x25, 0x67, 0x2e, 0xd2, 0x05, 0x3f, 0x0f, 0x08, 0x8d, 0xdc, 0xf1, 0x99, 0xe7, 0xa3,
	0x8e, 0xe0, 0x73, 0xea, 0x5d, 0x78, 0x53, 0x72, 0x42, 0x02, 0x64, 0xe0, 0x17, 0x80, 0x02, 0xe2,
	0x07, 0x5e, 0xe8, 0x5d, 0x90, 0xc8, 0x1d, 0x8d, 0x48, 0x10, 0x20, 0x53, 0xd6, 0x7c, 0x37, 0x8d,
	0xc8, 0x0f, 0x64, 0x84, 0xac, 0x86, 0xcd, 0x09, 0x9d, 0x20, 0xc0, 0x9f, 0xc0, 0xc7, 0x82, 0x79,
	0x7e, 0x48, 0xa8, 0xef, 0xee, 0xe5, 0x2e, 0xfe, 0x08, 0xac, 0x90, 0x4c, 0xc9, 0x19, 0x09, 0xe9,
	0x8f, 0xe8, 0x60, 0xf8, 0xe5, 0xcd, 0xbf, 0x4e, 0xeb, 0x66, 0xeb, 0x28, 0xb7, 0x5b, 0x47, 0xb9,
	0xdb, 0x3a, 0xca, 0x3f, 0x5b, 0x47, 0xf9, 0xe3, 0xc1, 0x69, 0xdd, 0x3e, 0x38, 0xad, 0xbb, 0x07,
	0xa7, 0xf5, 0x93, 0x2e, 0x9f, 0xfe, 0xa2, 0x23, 0x5f, 0xf3, 0x57, 0xff, 0x05, 0x00, 0x00, 0xff,
	0xff, 0x3f, 0x45, 0xc8, 0x77, 0x13, 0x04, 0x00, 0x00,
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Channel != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x50
	}
	if m.Redactable {
		i--
		if m.Redactable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Counter != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Goroutine != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Goroutine))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Line != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x20
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintLog(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Severity != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PID != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x30
	}
	if m.Time != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintLog(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLog(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ModTimeNanos != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.ModTimeNanos))
		i--
		dAtA[i] = 0x18
	}
	if m.SizeBytes != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLog(dAtA []byte, offset int, v uint64) int {
	offset -= sovLog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovLog(uint64(m.Severity))
	}
	if m.Time != 0 {
		n += 1 + sovLog(uint64(m.Time))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Line != 0 {
		n += 1 + sovLog(uint64(m.Line))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Goroutine != 0 {
		n += 1 + sovLog(uint64(m.Goroutine))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Counter != 0 {
		n += 1 + sovLog(uint64(m.Counter))
	}
	if m.Redactable {
		n += 2
	}
	if m.Channel != 0 {
		n += 1 + sovLog(uint64(m.Channel))
	}
	return n
}

func (m *FileDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovLog(uint64(m.Time))
	}
	if m.PID != 0 {
		n += 1 + sovLog(uint64(m.PID))
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovLog(uint64(m.SizeBytes))
	}
	if m.ModTimeNanos != 0 {
		n += 1 + sovLog(uint64(m.ModTimeNanos))
	}
	l = m.Details.Size()
	n += 1 + l + sovLog(uint64(l))
	return n
}

func sovLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLog(x uint64) (n int) {
	return sovLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goroutine", wireType)
			}
			m.Goroutine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Goroutine |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redactable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redactable = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= Channel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTimeNanos", wireType)
			}
			m.ModTimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLog = fmt.Errorf("proto: unexpected end of group")
)
