// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/logpb/log.proto

package logpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Severity is the severity level of individual log events.
//
// Note: do not forget to run gen.sh (go generate) when
// changing this list or the explanatory comments.
type Severity int32

const (
	// UNKNOWN is populated into decoded log entries when the
	// severity could not be determined.
	Severity_UNKNOWN Severity = 0
	// INFO is used for informational messages that do not
	// require action.
	Severity_INFO Severity = 1
	// WARNING is used for situations which may require special handling,
	// where normal operation is expected to resume automatically.
	Severity_WARNING Severity = 2
	// ERROR is used for situations that require special handling,
	// where normal operation could not proceed as expected.
	// Other operations can continue mostly unaffected.
	Severity_ERROR Severity = 3
	// FATAL is used for situations that require an immedate, hard
	// server shutdown. A report is also sent to telemetry if telemetry
	// is enabled.
	Severity_FATAL Severity = 4
	// NONE can be used in filters to specify that no messages
	// should be emitted.
	Severity_NONE Severity = 5
	// DEFAULT is the end sentinel. It is used during command-line
	// handling to indicate that another value should be replaced instead
	// (depending on which command is being run); see cli/flags.go for
	// details.
	Severity_DEFAULT Severity = 6
)

var Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "INFO",
	2: "WARNING",
	3: "ERROR",
	4: "FATAL",
	5: "NONE",
	6: "DEFAULT",
}

var Severity_value = map[string]int32{
	"UNKNOWN": 0,
	"INFO":    1,
	"WARNING": 2,
	"ERROR":   3,
	"FATAL":   4,
	"NONE":    5,
	"DEFAULT": 6,
}

func (x Severity) String() string {
	return proto.EnumName(Severity_name, int32(x))
}

func (Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{0}
}

// Channel is the logical logging channel on which a message is sent.
// Different channels can be redirected to different sinks. All
// messages from the same channel are sent to the same sink(s).
//
//
// Note: do not forget to run gen.sh (go generate) when
// changing this list or the explanatory comments.
type Channel int32

const (
	// DEV is used during development to collect log
	// details useful for troubleshooting that fall outside the
	// scope of other channels. It is also the default logging
	// channel for events not associated with a channel.
	//
	// This channel is special in that there are no constraints as to
	// what may or may not be logged on it. Conversely, users in
	// production deployments are invited to not collect `DEV` logs in
	// centralized logging facilities, because they likely contain
	// sensitive operational data.
	// See [Configure logs](configure-logs.html#dev-channel).
	Channel_DEV Channel = 0
	// OPS is used to report "point" operational events,
	// initiated by user operators or automation:
	//
	// - Operator or system actions on server processes: process starts,
	//   stops, shutdowns, crashes (if they can be logged),
	//   including each time: command-line parameters, current version being run
	// - Actions that impact the topology of a cluster: node additions,
	//   removals, decommissions, etc.
	// - Job-related initiation or termination
	// - [Cluster setting](cluster-settings.html) changes
	// - [Zone configuration](configure-replication-zones.html) changes
	Channel_OPS Channel = 1
	// HEALTH is used to report "background" operational
	// events, initiated by CockroachDB or reporting on automatic processes:
	//
	// - Current resource usage, including critical resource usage
	// - Node-node connection events, including connection errors and
	//   gossip details
	// - Range and table leasing events
	// - Up- and down-replication, range unavailability
	Channel_HEALTH Channel = 2
	// STORAGE is used to report low-level storage
	// layer events (RocksDB/Pebble).
	Channel_STORAGE Channel = 3
	// SESSIONS is used to report client network activity when enabled via
	// the `server.auth_log.sql_connections.enabled` and/or
	// `server.auth_log.sql_sessions.enabled` [cluster setting](cluster-settings.html):
	//
	// - Connections opened/closed
	// - Authentication events: logins, failed attempts
	// - Session and query cancellation
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_SESSIONS Channel = 4
	// SQL_SCHEMA is used to report changes to the
	// SQL logical schema, excluding privilege and ownership changes
	// (which are reported separately on the `PRIVILEGES` channel) and
	// zone configuration changes (which go to the `OPS` channel).
	//
	// This includes:
	//
	// - Database/schema/table/sequence/view/type creation
	// - Adding/removing/changing table columns
	// - Changing sequence parameters
	//
	// `SQL_SCHEMA` events generally comprise changes to the schema that affect the
	// functional behavior of client apps using stored objects.
	Channel_SQL_SCHEMA Channel = 5
	// USER_ADMIN is used to report changes
	// in users and roles, including:
	//
	// - Users added/dropped
	// - Changes to authentication credentials (e.g., passwords, validity, etc.)
	// - Role grants/revocations
	// - Role option grants/revocations
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_USER_ADMIN Channel = 6
	// PRIVILEGES is used to report data
	// authorization changes, including:
	//
	// - Privilege grants/revocations on database, objects, etc.
	// - Object ownership changes
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_PRIVILEGES Channel = 7
	// SENSITIVE_ACCESS is used to report SQL
	// data access to sensitive data:
	//
	// - Data access audit events (when table audit is enabled via
	//   [EXPERIMENTAL_AUDIT](experimental-audit.html))
	// - SQL statements executed by users with the admin role
	// - Operations that write to system tables
	//
	// This is typically configured in "audit" mode, with event
	// numbering and synchronous writes.
	Channel_SENSITIVE_ACCESS Channel = 8
	// SQL_EXEC is used to report SQL execution on
	// behalf of client connections:
	//
	// - Logical SQL statement executions (when enabled via the
	//   `sql.trace.log_statement_execute` [cluster setting](cluster-settings.html))
	// - uncaught Go panic errors during the execution of a SQL statement.
	Channel_SQL_EXEC Channel = 9
	// SQL_PERF is used to report SQL executions
	// that are marked as "out of the ordinary"
	// to facilitate performance investigations.
	// This includes the SQL "slow query log".
	//
	// Arguably, this channel overlaps with `SQL_EXEC`.
	// However, we keep both channels separate for backward compatibility
	// with versions prior to v21.1, where the corresponding events
	// were redirected to separate files.
	Channel_SQL_PERF Channel = 10
	// SQL_INTERNAL_PERF is like the `SQL_PERF` channel, but is aimed at
	// helping developers of CockroachDB itself. It exists as a separate
	// channel so as to not pollute the `SQL_PERF` logging output with
	// internal troubleshooting details.
	Channel_SQL_INTERNAL_PERF Channel = 11
	// TELEMETRY reports telemetry events. Telemetry events describe
	// feature usage within CockroachDB and anonymizes any application-
	// specific data.
	Channel_TELEMETRY Channel = 12
)

var Channel_name = map[int32]string{
	0:  "DEV",
	1:  "OPS",
	2:  "HEALTH",
	3:  "STORAGE",
	4:  "SESSIONS",
	5:  "SQL_SCHEMA",
	6:  "USER_ADMIN",
	7:  "PRIVILEGES",
	8:  "SENSITIVE_ACCESS",
	9:  "SQL_EXEC",
	10: "SQL_PERF",
	11: "SQL_INTERNAL_PERF",
	12: "TELEMETRY",
}

var Channel_value = map[string]int32{
	"DEV":               0,
	"OPS":               1,
	"HEALTH":            2,
	"STORAGE":           3,
	"SESSIONS":          4,
	"SQL_SCHEMA":        5,
	"USER_ADMIN":        6,
	"PRIVILEGES":        7,
	"SENSITIVE_ACCESS":  8,
	"SQL_EXEC":          9,
	"SQL_PERF":          10,
	"SQL_INTERNAL_PERF": 11,
	"TELEMETRY":         12,
}

func (x Channel) String() string {
	return proto.EnumName(Channel_name, int32(x))
}

func (Channel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{1}
}

// Entry represents a cockroach log entry in the following two cases:
// - when reading a log file using the crdb-v1 format, entries
//   are parsed into this struct.
// - when injecting an interceptor into the logging package, the
//   interceptor is fed entries using this structure.
type Entry struct {
	// Severity is the importance of the log entry. See the
	// documentation for the Severity enum for more details.
	Severity Severity `protobuf:"varint,1,opt,name=severity,proto3,enum=cockroach.util.log.Severity" json:"severity,omitempty"`
	// Nanoseconds since the epoch.
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// Goroutine ID. This helps match logging events with goroutine
	// stack dumps.
	Goroutine int64 `protobuf:"varint,6,opt,name=goroutine,proto3" json:"goroutine,omitempty"`
	// File name where the logging event was produced. Logging client
	// code can adjust this with the "depth" parameter.
	File string `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
	// Line number in the file where the logging event was produced.
	Line int64 `protobuf:"varint,4,opt,name=line,proto3" json:"line,omitempty"`
	// Message contains the main text of the logging message.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// Tags contains the context tags available in the context where the
	// entry was created.
	Tags string `protobuf:"bytes,7,opt,name=tags,proto3" json:"tags,omitempty"`
	// Counter is an entry counter, meant for use in audit logs as an
	// instrument against log repudiation.
	// See: https://en.wikipedia.org/wiki/Non-repudiation
	//
	// It is incremented for every use of the logger where the entry was
	// produced.
	Counter uint64 `protobuf:"varint,8,opt,name=counter,proto3" json:"counter,omitempty"`
	// Redactable is true if the message and tags fields include markers
	// to delineate sensitive information. In that case, confidentiality
	// can be obtained by only stripping away the data within this
	// marker. If redactable is false or unknown, the message should be
	// considered to only contain sensitive information, and should be
	// stripped away completely for confidentiality.
	Redactable bool `protobuf:"varint,9,opt,name=redactable,proto3" json:"redactable,omitempty"`
	// Channel is the channel on which the message was sent.
	Channel Channel `protobuf:"varint,10,opt,name=channel,proto3,enum=cockroach.util.log.Channel" json:"channel,omitempty"`
	// StructuredEnd, if non-zero, indicates that the entry
	// is structured; it is also the index
	// inside the Message field where the JSON payload ends (exclusive).
	StructuredEnd uint32 `protobuf:"varint,11,opt,name=structured_end,json=structuredEnd,proto3" json:"structured_end,omitempty"`
	// StructuredStart, when StructuredEnd is non-zero, is the index
	// inside the Message field where the JSON payload starts (inclusive).
	StructuredStart uint32 `protobuf:"varint,12,opt,name=structured_start,json=structuredStart,proto3" json:"structured_start,omitempty"`
	// StackTraceStart is the index inside Message where a detailed
	// stack trace starts. If zero, no stack trace is present. Stack
	// traces are always separated from the message using a newline
	// character. If a stack trace is included, StackTracePosition is
	// the index of the character immediately after the newline
	// character.
	//
	// We use an index-in-string field in the protobuf, instead of two
	// separate string fields, because previous-version consumers of
	// Entry are still expecting the message and the stack trace in the
	// same field.
	StackTraceStart uint32 `protobuf:"varint,13,opt,name=stack_trace_start,json=stackTraceStart,proto3" json:"stack_trace_start,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{0}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

// A FileDetails holds all of the particulars that can be parsed by the name of
// a log file.
type FileDetails struct {
	Program  string `protobuf:"bytes,1,opt,name=program,proto3" json:"program,omitempty"`
	Host     string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	UserName string `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Time     int64  `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	PID      int64  `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *FileDetails) Reset()         { *m = FileDetails{} }
func (m *FileDetails) String() string { return proto.CompactTextString(m) }
func (*FileDetails) ProtoMessage()    {}
func (*FileDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{1}
}
func (m *FileDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileDetails.Merge(m, src)
}
func (m *FileDetails) XXX_Size() int {
	return m.Size()
}
func (m *FileDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_FileDetails.DiscardUnknown(m)
}

var xxx_messageInfo_FileDetails proto.InternalMessageInfo

type FileInfo struct {
	Name         string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SizeBytes    int64       `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	ModTimeNanos int64       `protobuf:"varint,3,opt,name=mod_time_nanos,json=modTimeNanos,proto3" json:"mod_time_nanos,omitempty"`
	Details      FileDetails `protobuf:"bytes,4,opt,name=details,proto3" json:"details"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_84e824ab4ae60f77, []int{2}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.util.log.Severity", Severity_name, Severity_value)
	proto.RegisterEnum("cockroach.util.log.Channel", Channel_name, Channel_value)
	proto.RegisterType((*Entry)(nil), "cockroach.util.log.Entry")
	proto.RegisterType((*FileDetails)(nil), "cockroach.util.log.FileDetails")
	proto.RegisterType((*FileInfo)(nil), "cockroach.util.log.FileInfo")
}

func init() { proto.RegisterFile("util/log/logpb/log.proto", fileDescriptor_84e824ab4ae60f77) }

var fileDescriptor_84e824ab4ae60f77 = []byte{
	// 765 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0xdf, 0x6e, 0xdb, 0x36,
	0x14, 0xc6, 0xad, 0x48, 0xb6, 0xa4, 0xe3, 0x24, 0x63, 0x89, 0x0e, 0xd0, 0xd6, 0x4e, 0x31, 0x82,
	0x0d, 0xf3, 0x72, 0xe1, 0x02, 0x1d, 0x06, 0xec, 0x6e, 0x50, 0x6c, 0x3a, 0xd1, 0xe6, 0xc8, 0x29,
	0xa9, 0xa4, 0xfb, 0x73, 0x21, 0x28, 0x32, 0xeb, 0x08, 0x91, 0xc5, 0x40, 0xa2, 0x07, 0x64, 0xef,
	0x30, 0x60, 0x0f, 0xb1, 0x87, 0xd8, 0x23, 0x04, 0xbb, 0xea, 0x65, 0xaf, 0x8a, 0xcd, 0x79, 0x91,
	0x81, 0xb4, 0xd5, 0x04, 0x58, 0x2e, 0x6c, 0x7c, 0xe7, 0xd3, 0x8f, 0x87, 0x3c, 0x3c, 0x07, 0x04,
	0x6f, 0x29, 0xf3, 0xe2, 0x45, 0x21, 0xe6, 0xea, 0x77, 0x7d, 0xa1, 0xfe, 0x07, 0xd7, 0x95, 0x90,
	0x02, 0xe3, 0x4c, 0x64, 0x57, 0x95, 0x48, 0xb3, 0xcb, 0x81, 0x62, 0x06, 0x85, 0x98, 0x7f, 0xfa,
	0x74, 0x2e, 0xe6, 0x42, 0x7f, 0x7e, 0xa1, 0xd4, 0x9a, 0xdc, 0xff, 0xcb, 0x84, 0x36, 0x29, 0x65,
	0x75, 0x83, 0xbf, 0x05, 0xa7, 0xe6, 0xbf, 0xf2, 0x2a, 0x97, 0x37, 0x9e, 0xd1, 0x33, 0xfa, 0xbb,
	0x2f, 0x9f, 0x0f, 0xfe, 0x9f, 0x66, 0xc0, 0x36, 0x0c, 0xfd, 0x40, 0x63, 0x0c, 0x96, 0xcc, 0x17,
	0xdc, 0xdb, 0xea, 0x19, 0x7d, 0x93, 0x6a, 0x8d, 0x9f, 0x83, 0x3b, 0x17, 0x95, 0x58, 0xca, 0xbc,
	0xe4, 0x5e, 0x47, 0x7f, 0xb8, 0x37, 0xd4, 0x8a, 0x37, 0x79, 0xc1, 0x3d, 0xb3, 0x67, 0xf4, 0x5d,
	0xaa, 0xb5, 0xf2, 0x0a, 0x05, 0x5b, 0xeb, 0x2c, 0x4a, 0x63, 0x0f, 0xec, 0x05, 0xaf, 0xeb, 0x74,
	0xce, 0xbd, 0xb6, 0x46, 0x9b, 0x50, 0xef, 0x99, 0xce, 0x6b, 0xcf, 0x5e, 0x67, 0x50, 0x5a, 0xd1,
	0x99, 0x58, 0x96, 0x92, 0x57, 0x9e, 0xd3, 0x33, 0xfa, 0x16, 0x6d, 0x42, 0xec, 0x03, 0x54, 0x7c,
	0x96, 0x66, 0x32, 0xbd, 0x28, 0xb8, 0xe7, 0xf6, 0x8c, 0xbe, 0x43, 0x1f, 0x38, 0xf8, 0x1b, 0xb0,
	0xb3, 0xcb, 0xb4, 0x2c, 0x79, 0xe1, 0x81, 0x2e, 0xfd, 0xd9, 0x63, 0xa5, 0x0f, 0xd7, 0x08, 0x6d,
	0x58, 0xfc, 0x05, 0xec, 0xd6, 0xb2, 0x5a, 0x66, 0x72, 0x59, 0xf1, 0x59, 0xc2, 0xcb, 0x99, 0xd7,
	0xed, 0x19, 0xfd, 0x1d, 0xba, 0x73, 0xef, 0x92, 0x72, 0x86, 0xbf, 0x02, 0xf4, 0x00, 0xab, 0x65,
	0x5a, 0x49, 0x6f, 0x5b, 0x83, 0x1f, 0xdd, 0xfb, 0x4c, 0xd9, 0xf8, 0x00, 0x9e, 0xd4, 0x32, 0xcd,
	0xae, 0x12, 0x59, 0xa5, 0x19, 0xdf, 0xb0, 0x3b, 0x0d, 0x9b, 0x66, 0x57, 0xb1, 0xf2, 0x35, 0xbb,
	0xff, 0xbb, 0x01, 0xdd, 0x71, 0x5e, 0xf0, 0x11, 0x97, 0x69, 0x5e, 0xe8, 0xf2, 0xaf, 0x2b, 0x31,
	0xaf, 0xd2, 0x85, 0xee, 0x9f, 0x4b, 0x9b, 0x50, 0x5d, 0xd6, 0xa5, 0xa8, 0xa5, 0x6e, 0x90, 0x4b,
	0xb5, 0xc6, 0xcf, 0xc0, 0x5d, 0xd6, 0xbc, 0x4a, 0xca, 0x74, 0xd1, 0xf4, 0xc1, 0x51, 0x46, 0x94,
	0x2e, 0xf8, 0x87, 0x8e, 0xb6, 0x1f, 0x74, 0xf4, 0x13, 0x30, 0xaf, 0xf3, 0xd9, 0xba, 0x97, 0x87,
	0xf6, 0xea, 0xfd, 0x9e, 0x79, 0x1a, 0x8e, 0xa8, 0xf2, 0xbe, 0xb7, 0x1c, 0x0b, 0xb5, 0xf7, 0xff,
	0x34, 0xc0, 0x51, 0xe7, 0x09, 0xcb, 0x37, 0x42, 0x65, 0xd0, 0x99, 0xd7, 0x27, 0xd1, 0x1a, 0x7f,
	0x06, 0x50, 0xe7, 0xbf, 0xf1, 0xe4, 0xe2, 0x46, 0xf2, 0x7a, 0x33, 0x2d, 0xae, 0x72, 0x0e, 0x95,
	0x81, 0x3f, 0x87, 0xdd, 0x85, 0x98, 0x25, 0x6a, 0xb3, 0xa4, 0x4c, 0x4b, 0x51, 0xeb, 0x63, 0x99,
	0x74, 0x7b, 0x21, 0x66, 0x71, 0xbe, 0xe0, 0x91, 0xf2, 0xf0, 0x77, 0x60, 0xcf, 0xd6, 0x05, 0xeb,
	0x49, 0xe9, 0xbe, 0xdc, 0x7b, 0xac, 0x55, 0x0f, 0xee, 0xe5, 0xd0, 0xba, 0x7d, 0xbf, 0xd7, 0xa2,
	0xcd, 0xaa, 0x83, 0x5f, 0xc0, 0x69, 0x66, 0x18, 0x77, 0xc1, 0x3e, 0x8b, 0x7e, 0x88, 0xa6, 0xaf,
	0x23, 0xd4, 0xc2, 0x0e, 0x58, 0x61, 0x34, 0x9e, 0x22, 0x43, 0xd9, 0xaf, 0x03, 0x1a, 0x85, 0xd1,
	0x11, 0xda, 0xc2, 0x2e, 0xb4, 0x09, 0xa5, 0x53, 0x8a, 0x4c, 0x25, 0xc7, 0x41, 0x1c, 0x4c, 0x90,
	0xa5, 0xe0, 0x68, 0x1a, 0x11, 0xd4, 0x56, 0xf0, 0x88, 0x8c, 0x83, 0xb3, 0x49, 0x8c, 0x3a, 0x07,
	0x7f, 0x1b, 0x60, 0x6f, 0xc6, 0x04, 0xdb, 0x60, 0x8e, 0xc8, 0x39, 0x6a, 0x29, 0x31, 0x3d, 0x65,
	0xc8, 0xc0, 0x00, 0x9d, 0x63, 0x12, 0x4c, 0xe2, 0x63, 0xb4, 0xa5, 0x96, 0xb1, 0x78, 0x4a, 0x83,
	0x23, 0x82, 0x4c, 0xbc, 0x0d, 0x0e, 0x23, 0x8c, 0x85, 0xd3, 0x88, 0x21, 0x0b, 0xef, 0x02, 0xb0,
	0x57, 0x93, 0x84, 0x0d, 0x8f, 0xc9, 0x49, 0x80, 0xda, 0x2a, 0x3e, 0x63, 0x84, 0x26, 0xc1, 0xe8,
	0x24, 0x8c, 0x50, 0x47, 0xc5, 0xa7, 0x34, 0x3c, 0x0f, 0x27, 0xe4, 0x88, 0x30, 0x64, 0xe3, 0xa7,
	0x80, 0x18, 0x89, 0x58, 0x18, 0x87, 0xe7, 0x24, 0x09, 0x86, 0x43, 0xc2, 0x18, 0x72, 0x74, 0xce,
	0x57, 0x93, 0x84, 0xfc, 0x48, 0x86, 0xc8, 0x6d, 0xa2, 0x53, 0x42, 0xc7, 0x08, 0xf0, 0xc7, 0xf0,
	0x44, 0x45, 0x61, 0x14, 0x13, 0x1a, 0x05, 0x1b, 0xbb, 0x8b, 0x77, 0xc0, 0x8d, 0xc9, 0x84, 0x9c,
	0x90, 0x98, 0xfe, 0x84, 0xb6, 0x0f, 0xbf, 0xbc, 0xfd, 0xd7, 0x6f, 0xdd, 0xae, 0x7c, 0xe3, 0xed,
	0xca, 0x37, 0xde, 0xad, 0x7c, 0xe3, 0x9f, 0x95, 0x6f, 0xfc, 0x71, 0xe7, 0xb7, 0xde, 0xde, 0xf9,
	0xad, 0x77, 0x77, 0x7e, 0xeb, 0xe7, 0xb6, 0x7e, 0x78, 0x2e, 0x3a, 0xfa, 0x2d, 0xf9, 0xfa, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x9e, 0x4c, 0xb7, 0x91, 0x04, 0x00, 0x00,
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StackTraceStart != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.StackTraceStart))
		i--
		dAtA[i] = 0x68
	}
	if m.StructuredStart != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.StructuredStart))
		i--
		dAtA[i] = 0x60
	}
	if m.StructuredEnd != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.StructuredEnd))
		i--
		dAtA[i] = 0x58
	}
	if m.Channel != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x50
	}
	if m.Redactable {
		i--
		if m.Redactable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Counter != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Goroutine != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Goroutine))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Line != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x20
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintLog(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Severity != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PID != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x30
	}
	if m.Time != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintLog(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Program) > 0 {
		i -= len(m.Program)
		copy(dAtA[i:], m.Program)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Program)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLog(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ModTimeNanos != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.ModTimeNanos))
		i--
		dAtA[i] = 0x18
	}
	if m.SizeBytes != 0 {
		i = encodeVarintLog(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLog(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLog(dAtA []byte, offset int, v uint64) int {
	offset -= sovLog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovLog(uint64(m.Severity))
	}
	if m.Time != 0 {
		n += 1 + sovLog(uint64(m.Time))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Line != 0 {
		n += 1 + sovLog(uint64(m.Line))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Goroutine != 0 {
		n += 1 + sovLog(uint64(m.Goroutine))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Counter != 0 {
		n += 1 + sovLog(uint64(m.Counter))
	}
	if m.Redactable {
		n += 2
	}
	if m.Channel != 0 {
		n += 1 + sovLog(uint64(m.Channel))
	}
	if m.StructuredEnd != 0 {
		n += 1 + sovLog(uint64(m.StructuredEnd))
	}
	if m.StructuredStart != 0 {
		n += 1 + sovLog(uint64(m.StructuredStart))
	}
	if m.StackTraceStart != 0 {
		n += 1 + sovLog(uint64(m.StackTraceStart))
	}
	return n
}

func (m *FileDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Program)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovLog(uint64(m.Time))
	}
	if m.PID != 0 {
		n += 1 + sovLog(uint64(m.PID))
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLog(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovLog(uint64(m.SizeBytes))
	}
	if m.ModTimeNanos != 0 {
		n += 1 + sovLog(uint64(m.ModTimeNanos))
	}
	l = m.Details.Size()
	n += 1 + l + sovLog(uint64(l))
	return n
}

func sovLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLog(x uint64) (n int) {
	return sovLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goroutine", wireType)
			}
			m.Goroutine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Goroutine |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redactable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redactable = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= Channel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructuredEnd", wireType)
			}
			m.StructuredEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StructuredEnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructuredStart", wireType)
			}
			m.StructuredStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StructuredStart |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StackTraceStart", wireType)
			}
			m.StackTraceStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StackTraceStart |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Program = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTimeNanos", wireType)
			}
			m.ModTimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLog = fmt.Errorf("proto: unexpected end of group")
)
