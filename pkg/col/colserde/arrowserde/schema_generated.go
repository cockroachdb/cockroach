// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package arrowserde

import flatbuffers "github.com/google/flatbuffers/go"

type MetadataVersion = int16

const (
	/// 0.1.0
	MetadataVersionV1 MetadataVersion = 0
	/// 0.2.0
	MetadataVersionV2 MetadataVersion = 1
	/// 0.3.0 -> 0.7.1
	MetadataVersionV3 MetadataVersion = 2
	/// >= 0.8.0
	MetadataVersionV4 MetadataVersion = 3
)

var EnumNamesMetadataVersion = map[MetadataVersion]string{
	MetadataVersionV1: "V1",
	MetadataVersionV2: "V2",
	MetadataVersionV3: "V3",
	MetadataVersionV4: "V4",
}

type UnionMode = int16

const (
	UnionModeSparse UnionMode = 0
	UnionModeDense  UnionMode = 1
)

var EnumNamesUnionMode = map[UnionMode]string{
	UnionModeSparse: "Sparse",
	UnionModeDense:  "Dense",
}

type Precision = int16

const (
	PrecisionHALF   Precision = 0
	PrecisionSINGLE Precision = 1
	PrecisionDOUBLE Precision = 2
)

var EnumNamesPrecision = map[Precision]string{
	PrecisionHALF:   "HALF",
	PrecisionSINGLE: "SINGLE",
	PrecisionDOUBLE: "DOUBLE",
}

type DateUnit = int16

const (
	DateUnitDAY         DateUnit = 0
	DateUnitMILLISECOND DateUnit = 1
)

var EnumNamesDateUnit = map[DateUnit]string{
	DateUnitDAY:         "DAY",
	DateUnitMILLISECOND: "MILLISECOND",
}

type TimeUnit = int16

const (
	TimeUnitSECOND      TimeUnit = 0
	TimeUnitMILLISECOND TimeUnit = 1
	TimeUnitMICROSECOND TimeUnit = 2
	TimeUnitNANOSECOND  TimeUnit = 3
)

var EnumNamesTimeUnit = map[TimeUnit]string{
	TimeUnitSECOND:      "SECOND",
	TimeUnitMILLISECOND: "MILLISECOND",
	TimeUnitMICROSECOND: "MICROSECOND",
	TimeUnitNANOSECOND:  "NANOSECOND",
}

type IntervalUnit = int16

const (
	IntervalUnitYEAR_MONTH IntervalUnit = 0
	IntervalUnitDAY_TIME   IntervalUnit = 1
)

var EnumNamesIntervalUnit = map[IntervalUnit]string{
	IntervalUnitYEAR_MONTH: "YEAR_MONTH",
	IntervalUnitDAY_TIME:   "DAY_TIME",
}

/// ----------------------------------------------------------------------
/// Top-level Type value, enabling extensible type-specific metadata. We can
/// add new logical types to Type without breaking backwards compatibility
type Type = byte

const (
	TypeNONE            Type = 0
	TypeNull            Type = 1
	TypeInt             Type = 2
	TypeFloatingPoint   Type = 3
	TypeBinary          Type = 4
	TypeUtf8            Type = 5
	TypeBool            Type = 6
	TypeDecimal         Type = 7
	TypeDate            Type = 8
	TypeTime            Type = 9
	TypeTimestamp       Type = 10
	TypeInterval        Type = 11
	TypeList            Type = 12
	TypeStruct_         Type = 13
	TypeUnion           Type = 14
	TypeFixedSizeBinary Type = 15
	TypeFixedSizeList   Type = 16
	TypeMap             Type = 17
)

var EnumNamesType = map[Type]string{
	TypeNONE:            "NONE",
	TypeNull:            "Null",
	TypeInt:             "Int",
	TypeFloatingPoint:   "FloatingPoint",
	TypeBinary:          "Binary",
	TypeUtf8:            "Utf8",
	TypeBool:            "Bool",
	TypeDecimal:         "Decimal",
	TypeDate:            "Date",
	TypeTime:            "Time",
	TypeTimestamp:       "Timestamp",
	TypeInterval:        "Interval",
	TypeList:            "List",
	TypeStruct_:         "Struct_",
	TypeUnion:           "Union",
	TypeFixedSizeBinary: "FixedSizeBinary",
	TypeFixedSizeList:   "FixedSizeList",
	TypeMap:             "Map",
}

/// ----------------------------------------------------------------------
/// Endianness of the platform producing the data
type Endianness = int16

const (
	EndiannessLittle Endianness = 0
	EndiannessBig    Endianness = 1
)

var EnumNamesEndianness = map[Endianness]string{
	EndiannessLittle: "Little",
	EndiannessBig:    "Big",
}

/// These are stored in the flatbuffer in the Type union below
type Null struct {
	_tab flatbuffers.Table
}

func GetRootAsNull(buf []byte, offset flatbuffers.UOffsetT) *Null {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Null{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Null) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Null) Table() flatbuffers.Table {
	return rcv._tab
}

func NullStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func NullEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
/// (according to the physical memory layout). We used Struct_ here as
/// Struct is a reserved word in Flatbuffers
type Struct_ struct {
	_tab flatbuffers.Table
}

func GetRootAsStruct_(buf []byte, offset flatbuffers.UOffsetT) *Struct_ {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Struct_{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Struct_) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Struct_) Table() flatbuffers.Table {
	return rcv._tab
}

func Struct_Start(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func Struct_End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type List struct {
	_tab flatbuffers.Table
}

func GetRootAsList(buf []byte, offset flatbuffers.UOffsetT) *List {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &List{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *List) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *List) Table() flatbuffers.Table {
	return rcv._tab
}

func ListStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func ListEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FixedSizeList struct {
	_tab flatbuffers.Table
}

func GetRootAsFixedSizeList(buf []byte, offset flatbuffers.UOffsetT) *FixedSizeList {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FixedSizeList{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FixedSizeList) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FixedSizeList) Table() flatbuffers.Table {
	return rcv._tab
}

/// Number of list items per value
func (rcv *FixedSizeList) ListSize() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of list items per value
func (rcv *FixedSizeList) MutateListSize(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func FixedSizeListStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func FixedSizeListAddListSize(builder *flatbuffers.Builder, listSize int32) {
	builder.PrependInt32Slot(0, listSize, 0)
}
func FixedSizeListEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// A Map is a logical nested type that is represented as
///
/// List<entry: Struct<key: K, value: V>>
///
/// In this layout, the keys and values are each respectively contiguous. We do
/// not constrain the key and value types, so the application is responsible
/// for ensuring that the keys are hashable and unique. Whether the keys are sorted
/// may be set in the metadata for this field
///
/// In a Field with Map type, the Field has a child Struct field, which then
/// has two children: key type and the second the value type. The names of the
/// child fields may be respectively "entry", "key", and "value", but this is
/// not enforced
///
/// Map
///   - child[0] entry: Struct
///     - child[0] key: K
///     - child[1] value: V
///
/// Neither the "entry" field nor the "key" field may be nullable.
///
/// The metadata is structured so that Arrow systems without special handling
/// for Map can make Map an alias for List. The "layout" attribute for the Map
/// field must have the same contents as a List.
type Map struct {
	_tab flatbuffers.Table
}

func GetRootAsMap(buf []byte, offset flatbuffers.UOffsetT) *Map {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Map{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Map) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Map) Table() flatbuffers.Table {
	return rcv._tab
}

/// Set to true if the keys within each value are sorted
func (rcv *Map) KeysSorted() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// Set to true if the keys within each value are sorted
func (rcv *Map) MutateKeysSorted(n byte) bool {
	return rcv._tab.MutateByteSlot(4, n)
}

func MapStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func MapAddKeysSorted(builder *flatbuffers.Builder, keysSorted byte) {
	builder.PrependByteSlot(0, keysSorted, 0)
}
func MapEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// A union is a complex type with children in Field
/// By default ids in the type vector refer to the offsets in the children
/// optionally typeIds provides an indirection between the child offset and the type id
/// for each child typeIds[offset] is the id used in the type vector
type Union struct {
	_tab flatbuffers.Table
}

func GetRootAsUnion(buf []byte, offset flatbuffers.UOffsetT) *Union {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Union{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Union) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Union) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Union) Mode() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Union) MutateMode(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func (rcv *Union) TypeIds(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Union) TypeIdsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func UnionStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func UnionAddMode(builder *flatbuffers.Builder, mode int16) {
	builder.PrependInt16Slot(0, mode, 0)
}
func UnionAddTypeIds(builder *flatbuffers.Builder, typeIds flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(typeIds), 0)
}
func UnionStartTypeIdsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func UnionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Int struct {
	_tab flatbuffers.Table
}

func GetRootAsInt(buf []byte, offset flatbuffers.UOffsetT) *Int {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Int{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Int) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Int) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Int) BitWidth() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Int) MutateBitWidth(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Int) IsSigned() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Int) MutateIsSigned(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func IntStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func IntAddBitWidth(builder *flatbuffers.Builder, bitWidth int32) {
	builder.PrependInt32Slot(0, bitWidth, 0)
}
func IntAddIsSigned(builder *flatbuffers.Builder, isSigned byte) {
	builder.PrependByteSlot(1, isSigned, 0)
}
func IntEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FloatingPoint struct {
	_tab flatbuffers.Table
}

func GetRootAsFloatingPoint(buf []byte, offset flatbuffers.UOffsetT) *FloatingPoint {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FloatingPoint{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FloatingPoint) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FloatingPoint) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FloatingPoint) Precision() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *FloatingPoint) MutatePrecision(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func FloatingPointStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func FloatingPointAddPrecision(builder *flatbuffers.Builder, precision int16) {
	builder.PrependInt16Slot(0, precision, 0)
}
func FloatingPointEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// Unicode with UTF-8 encoding
type Utf8 struct {
	_tab flatbuffers.Table
}

func GetRootAsUtf8(buf []byte, offset flatbuffers.UOffsetT) *Utf8 {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Utf8{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Utf8) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Utf8) Table() flatbuffers.Table {
	return rcv._tab
}

func Utf8Start(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func Utf8End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Binary struct {
	_tab flatbuffers.Table
}

func GetRootAsBinary(buf []byte, offset flatbuffers.UOffsetT) *Binary {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Binary{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Binary) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Binary) Table() flatbuffers.Table {
	return rcv._tab
}

func BinaryStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func BinaryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FixedSizeBinary struct {
	_tab flatbuffers.Table
}

func GetRootAsFixedSizeBinary(buf []byte, offset flatbuffers.UOffsetT) *FixedSizeBinary {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FixedSizeBinary{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FixedSizeBinary) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FixedSizeBinary) Table() flatbuffers.Table {
	return rcv._tab
}

/// Number of bytes per value
func (rcv *FixedSizeBinary) ByteWidth() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of bytes per value
func (rcv *FixedSizeBinary) MutateByteWidth(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func FixedSizeBinaryStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func FixedSizeBinaryAddByteWidth(builder *flatbuffers.Builder, byteWidth int32) {
	builder.PrependInt32Slot(0, byteWidth, 0)
}
func FixedSizeBinaryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Bool struct {
	_tab flatbuffers.Table
}

func GetRootAsBool(buf []byte, offset flatbuffers.UOffsetT) *Bool {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Bool{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Bool) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Bool) Table() flatbuffers.Table {
	return rcv._tab
}

func BoolStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func BoolEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Decimal struct {
	_tab flatbuffers.Table
}

func GetRootAsDecimal(buf []byte, offset flatbuffers.UOffsetT) *Decimal {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Decimal{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Decimal) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Decimal) Table() flatbuffers.Table {
	return rcv._tab
}

/// Total number of decimal digits
func (rcv *Decimal) Precision() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Total number of decimal digits
func (rcv *Decimal) MutatePrecision(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

/// Number of digits after the decimal point "."
func (rcv *Decimal) Scale() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

/// Number of digits after the decimal point "."
func (rcv *Decimal) MutateScale(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func DecimalStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func DecimalAddPrecision(builder *flatbuffers.Builder, precision int32) {
	builder.PrependInt32Slot(0, precision, 0)
}
func DecimalAddScale(builder *flatbuffers.Builder, scale int32) {
	builder.PrependInt32Slot(1, scale, 0)
}
func DecimalEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// Date is either a 32-bit or 64-bit type representing elapsed time since UNIX
/// epoch (1970-01-01), stored in either of two units:
///
/// * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
///   leap seconds), where the values are evenly divisible by 86400000
/// * Days (32 bits) since the UNIX epoch
type Date struct {
	_tab flatbuffers.Table
}

func GetRootAsDate(buf []byte, offset flatbuffers.UOffsetT) *Date {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Date{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Date) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Date) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Date) Unit() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 1
}

func (rcv *Date) MutateUnit(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func DateStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func DateAddUnit(builder *flatbuffers.Builder, unit int16) {
	builder.PrependInt16Slot(0, unit, 1)
}
func DateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// Time type. The physical storage type depends on the unit
/// - SECOND and MILLISECOND: 32 bits
/// - MICROSECOND and NANOSECOND: 64 bits
type Time struct {
	_tab flatbuffers.Table
}

func GetRootAsTime(buf []byte, offset flatbuffers.UOffsetT) *Time {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Time{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Time) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Time) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Time) Unit() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 1
}

func (rcv *Time) MutateUnit(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func (rcv *Time) BitWidth() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 32
}

func (rcv *Time) MutateBitWidth(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func TimeStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TimeAddUnit(builder *flatbuffers.Builder, unit int16) {
	builder.PrependInt16Slot(0, unit, 1)
}
func TimeAddBitWidth(builder *flatbuffers.Builder, bitWidth int32) {
	builder.PrependInt32Slot(1, bitWidth, 32)
}
func TimeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding
/// leap seconds, as a 64-bit integer. Note that UNIX time does not include
/// leap seconds.
///
/// The Timestamp metadata supports both "time zone naive" and "time zone
/// aware" timestamps. Read about the timezone attribute for more detail
type Timestamp struct {
	_tab flatbuffers.Table
}

func GetRootAsTimestamp(buf []byte, offset flatbuffers.UOffsetT) *Timestamp {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Timestamp{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Timestamp) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Timestamp) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Timestamp) Unit() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Timestamp) MutateUnit(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

/// The time zone is a string indicating the name of a time zone, one of:
///
/// * As used in the Olson time zone database (the "tz database" or
///   "tzdata"), such as "America/New_York"
/// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30
///
/// Whether a timezone string is present indicates different semantics about
/// the data:
///
/// * If the time zone is null or equal to an empty string, the data is "time
///   zone naive" and shall be displayed *as is* to the user, not localized
///   to the locale of the user. This data can be though of as UTC but
///   without having "UTC" as the time zone, it is not considered to be
///   localized to any time zone
///
/// * If the time zone is set to a valid value, values can be displayed as
///   "localized" to that time zone, even though the underlying 64-bit
///   integers are identical to the same data stored in UTC. Converting
///   between time zones is a metadata-only operation and does not change the
///   underlying values
func (rcv *Timestamp) Timezone() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The time zone is a string indicating the name of a time zone, one of:
///
/// * As used in the Olson time zone database (the "tz database" or
///   "tzdata"), such as "America/New_York"
/// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30
///
/// Whether a timezone string is present indicates different semantics about
/// the data:
///
/// * If the time zone is null or equal to an empty string, the data is "time
///   zone naive" and shall be displayed *as is* to the user, not localized
///   to the locale of the user. This data can be though of as UTC but
///   without having "UTC" as the time zone, it is not considered to be
///   localized to any time zone
///
/// * If the time zone is set to a valid value, values can be displayed as
///   "localized" to that time zone, even though the underlying 64-bit
///   integers are identical to the same data stored in UTC. Converting
///   between time zones is a metadata-only operation and does not change the
///   underlying values
func TimestampStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func TimestampAddUnit(builder *flatbuffers.Builder, unit int16) {
	builder.PrependInt16Slot(0, unit, 0)
}
func TimestampAddTimezone(builder *flatbuffers.Builder, timezone flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(timezone), 0)
}
func TimestampEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Interval struct {
	_tab flatbuffers.Table
}

func GetRootAsInterval(buf []byte, offset flatbuffers.UOffsetT) *Interval {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Interval{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Interval) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Interval) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Interval) Unit() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Interval) MutateUnit(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func IntervalStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func IntervalAddUnit(builder *flatbuffers.Builder, unit int16) {
	builder.PrependInt16Slot(0, unit, 0)
}
func IntervalEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// ----------------------------------------------------------------------
/// user defined key value pairs to add custom metadata to arrow
/// key namespacing is the responsibility of the user
type KeyValue struct {
	_tab flatbuffers.Table
}

func GetRootAsKeyValue(buf []byte, offset flatbuffers.UOffsetT) *KeyValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KeyValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *KeyValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KeyValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *KeyValue) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *KeyValue) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func KeyValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func KeyValueAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func KeyValueAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func KeyValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// ----------------------------------------------------------------------
/// Dictionary encoding metadata
type DictionaryEncoding struct {
	_tab flatbuffers.Table
}

func GetRootAsDictionaryEncoding(buf []byte, offset flatbuffers.UOffsetT) *DictionaryEncoding {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DictionaryEncoding{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *DictionaryEncoding) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DictionaryEncoding) Table() flatbuffers.Table {
	return rcv._tab
}

/// The known dictionary id in the application where this data is used. In
/// the file or streaming formats, the dictionary ids are found in the
/// DictionaryBatch messages
func (rcv *DictionaryEncoding) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// The known dictionary id in the application where this data is used. In
/// the file or streaming formats, the dictionary ids are found in the
/// DictionaryBatch messages
func (rcv *DictionaryEncoding) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

/// The dictionary indices are constrained to be positive integers. If this
/// field is null, the indices must be signed int32
func (rcv *DictionaryEncoding) IndexType(obj *Int) *Int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Int)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The dictionary indices are constrained to be positive integers. If this
/// field is null, the indices must be signed int32
/// By default, dictionaries are not ordered, or the order does not have
/// semantic meaning. In some statistical, applications, dictionary-encoding
/// is used to represent ordered categorical data, and we provide a way to
/// preserve that metadata here
func (rcv *DictionaryEncoding) IsOrdered() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

/// By default, dictionaries are not ordered, or the order does not have
/// semantic meaning. In some statistical, applications, dictionary-encoding
/// is used to represent ordered categorical data, and we provide a way to
/// preserve that metadata here
func (rcv *DictionaryEncoding) MutateIsOrdered(n byte) bool {
	return rcv._tab.MutateByteSlot(8, n)
}

func DictionaryEncodingStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func DictionaryEncodingAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func DictionaryEncodingAddIndexType(builder *flatbuffers.Builder, indexType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(indexType), 0)
}
func DictionaryEncodingAddIsOrdered(builder *flatbuffers.Builder, isOrdered byte) {
	builder.PrependByteSlot(2, isOrdered, 0)
}
func DictionaryEncodingEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// ----------------------------------------------------------------------
/// A field represents a named column in a record / row batch or child of a
/// nested type.
///
/// - children is only for nested Arrow arrays
/// - For primitive types, children will have length 0
/// - nullable should default to true in general
type Field struct {
	_tab flatbuffers.Table
}

func GetRootAsField(buf []byte, offset flatbuffers.UOffsetT) *Field {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Field{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Field) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Field) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Field) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Field) Nullable() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Field) MutateNullable(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func (rcv *Field) TypeType() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Field) MutateTypeType(n byte) bool {
	return rcv._tab.MutateByteSlot(8, n)
}

func (rcv *Field) Type(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *Field) Dictionary(obj *DictionaryEncoding) *DictionaryEncoding {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(DictionaryEncoding)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Field) Children(obj *Field, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Field) ChildrenLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Field) CustomMetadata(obj *KeyValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Field) CustomMetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func FieldStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func FieldAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FieldAddNullable(builder *flatbuffers.Builder, nullable byte) {
	builder.PrependByteSlot(1, nullable, 0)
}
func FieldAddTypeType(builder *flatbuffers.Builder, typeType byte) {
	builder.PrependByteSlot(2, typeType, 0)
}
func FieldAddType(builder *flatbuffers.Builder, type_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(type_), 0)
}
func FieldAddDictionary(builder *flatbuffers.Builder, dictionary flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(dictionary), 0)
}
func FieldAddChildren(builder *flatbuffers.Builder, children flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(children), 0)
}
func FieldStartChildrenVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FieldAddCustomMetadata(builder *flatbuffers.Builder, customMetadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(customMetadata), 0)
}
func FieldStartCustomMetadataVector(
	builder *flatbuffers.Builder, numElems int,
) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FieldEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/// ----------------------------------------------------------------------
/// A Buffer represents a single contiguous memory segment
type Buffer struct {
	_tab flatbuffers.Struct
}

func (rcv *Buffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Buffer) Table() flatbuffers.Table {
	return rcv._tab.Table
}

/// The relative offset into the shared memory page where the bytes for this
/// buffer starts
func (rcv *Buffer) Offset() int64 {
	return rcv._tab.GetInt64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}

/// The relative offset into the shared memory page where the bytes for this
/// buffer starts
func (rcv *Buffer) MutateOffset(n int64) bool {
	return rcv._tab.MutateInt64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

/// The absolute length (in bytes) of the memory buffer. The memory is found
/// from offset (inclusive) to offset + length (non-inclusive).
func (rcv *Buffer) Length() int64 {
	return rcv._tab.GetInt64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}

/// The absolute length (in bytes) of the memory buffer. The memory is found
/// from offset (inclusive) to offset + length (non-inclusive).
func (rcv *Buffer) MutateLength(n int64) bool {
	return rcv._tab.MutateInt64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func CreateBuffer(builder *flatbuffers.Builder, offset int64, length int64) flatbuffers.UOffsetT {
	builder.Prep(8, 16)
	builder.PrependInt64(length)
	builder.PrependInt64(offset)
	return builder.Offset()
}

/// ----------------------------------------------------------------------
/// A Schema describes the columns in a row batch
type Schema struct {
	_tab flatbuffers.Table
}

func GetRootAsSchema(buf []byte, offset flatbuffers.UOffsetT) *Schema {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Schema{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Schema) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Schema) Table() flatbuffers.Table {
	return rcv._tab
}

/// endianness of the buffer
/// it is Little Endian by default
/// if endianness doesn't match the underlying system then the vectors need to be converted
func (rcv *Schema) Endianness() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

/// endianness of the buffer
/// it is Little Endian by default
/// if endianness doesn't match the underlying system then the vectors need to be converted
func (rcv *Schema) MutateEndianness(n int16) bool {
	return rcv._tab.MutateInt16Slot(4, n)
}

func (rcv *Schema) Fields(obj *Field, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Schema) FieldsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Schema) CustomMetadata(obj *KeyValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Schema) CustomMetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SchemaStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SchemaAddEndianness(builder *flatbuffers.Builder, endianness int16) {
	builder.PrependInt16Slot(0, endianness, 0)
}
func SchemaAddFields(builder *flatbuffers.Builder, fields flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(fields), 0)
}
func SchemaStartFieldsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SchemaAddCustomMetadata(builder *flatbuffers.Builder, customMetadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(customMetadata), 0)
}
func SchemaStartCustomMetadataVector(
	builder *flatbuffers.Builder, numElems int,
) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SchemaEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
