// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package spanconfigsqlwatcher

import (
	"context"
	"sort"

	"github.com/cockroachdb/cockroach/pkg/kv/kvclient/rangefeed/rangefeedbuffer"
	"github.com/cockroachdb/cockroach/pkg/spanconfig"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog"
	"github.com/cockroachdb/cockroach/pkg/util/hlc"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	"github.com/cockroachdb/errors"
)

// buffer is a helper struct for the SQLWatcher. It buffers events generated by
// the SQLWatcher's rangefeeds over system.zones and system.descriptors. It is
// safe for concurrent use.
//
// The buffer tracks frontier timestamps for both these rangefeeds as well. It
// maintains the notion of the combined frontier timestamp computed as the
// minimum of the two. This is used when flushing the buffer periodically.
type buffer struct {
	mu struct {
		syncutil.Mutex

		// rangefeed.Buffer stores spanconfigsqlwatcher.Events.
		buffer *rangefeedbuffer.Buffer

		// rangefeedFrontiers tracks the frontier timestamps of individual
		// rangefeeds established by the SQLWatcher.
		rangefeedFrontiers [numRangefeeds]hlc.Timestamp
	}
}

// event is the unit produced by the rangefeeds the SQLWatcher establishes over
// system.protected_ts_records, system.zones and system.descriptors. It
// implements the rangefeedbuffer.Event interface.
type event struct {
	// timestamp at which the event was generated by the rangefeed.
	timestamp hlc.Timestamp

	// update captures information about the descriptor or zone or protected
	// timestamp record that the SQLWatcher has observed change.
	update spanconfig.SQLUpdate
}

// Timestamp implements the rangefeedbuffer.Event interface.
func (e event) Timestamp() hlc.Timestamp {
	return e.timestamp
}

// rangefeedKind is used to identify the distinct rangefeeds {descriptors,
// zones, protected_ts_records} established by the SQLWatcher.
type rangefeedKind int

const (
	zonesRangefeed rangefeedKind = iota
	descriptorsRangefeed
	protectedTimestampRangefeed

	// numRangefeeds should be listed last.
	numRangefeeds int = iota
)

// newBuffer constructs a new buffer initialized with a starting frontier
// timestamp.
func newBuffer(limit int, initialFrontierTS hlc.Timestamp) *buffer {
	rangefeedBuffer := rangefeedbuffer.New(limit)
	eventBuffer := &buffer{}
	eventBuffer.mu.buffer = rangefeedBuffer
	for i := range eventBuffer.mu.rangefeedFrontiers {
		eventBuffer.mu.rangefeedFrontiers[i].Forward(initialFrontierTS)
	}
	return eventBuffer
}

// advance advances the frontier for the given rangefeed.
func (b *buffer) advance(rangefeed rangefeedKind, timestamp hlc.Timestamp) {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.mu.rangefeedFrontiers[rangefeed].Forward(timestamp)
}

// add records the given event in the buffer.
func (b *buffer) add(ev event) error {
	b.mu.Lock()
	defer b.mu.Unlock()
	return b.mu.buffer.Add(ev)
}

// flushEvents computes the combined frontier timestamp of the buffer and
// returns  a list of relevant events which were buffered up to that timestamp.
func (b *buffer) flushEvents(
	ctx context.Context,
) (updates []rangefeedbuffer.Event, combinedFrontierTS hlc.Timestamp) {
	b.mu.Lock()
	defer b.mu.Unlock()
	// First we determine the checkpoint timestamp, which is the minimum
	// checkpoint timestamp of all event types.
	combinedFrontierTS = hlc.MaxTimestamp
	for _, ts := range b.mu.rangefeedFrontiers {
		combinedFrontierTS.Backward(ts)
	}

	return b.mu.buffer.Flush(ctx, combinedFrontierTS), combinedFrontierTS
}

// flush computes the combined frontier timestamp of the buffer and returns a
// list of unique spanconfig.DescriptorUpdates below this timestamp. The
// combined frontier timestamp is also returned.
func (b *buffer) flush(
	ctx context.Context,
) (sqlUpdates []spanconfig.SQLUpdate, _ hlc.Timestamp, _ error) {
	events, combinedFrontierTS := b.flushEvents(ctx)
	// The events slice can contain a SQLUpdate that applies to a descriptor, or a
	// SQLUpdate that applies to a protected timestamp record. We bubble up the
	// protected timestamp SQLUpdates to the end of the slice, so that we can
	// perform the subsequent deduplication of SQLUpdates. We do this instead of
	// pre-processing events to separate the two kinds of updates, to save on the
	// allocation of additional `events` slices.
	sort.Slice(events, func(i, j int) bool {
		ei, ej := events[i].(event), events[j].(event)
		if ei.update.IsDescriptorUpdate() && ej.update.IsDescriptorUpdate() {
			descUpdatei := ei.update.GetDescriptorUpdate()
			descUpdatej := ej.update.GetDescriptorUpdate()
			if descUpdatei.ID == descUpdatej.ID {
				return ei.timestamp.Less(ej.timestamp)
			}
			return descUpdatei.ID < descUpdatej.ID
		}

		// If the LHS is a descriptor update, sort it before the RHS which is a
		// protected timestamp update.
		if ei.update.IsDescriptorUpdate() {
			return true
		}

		// If the RHS is a descriptor update, sort it before the LHS which is a
		// protected timestamp update.
		if ej.update.IsDescriptorUpdate() {
			return false
		}

		return ei.timestamp.Less(ej.timestamp)
	})

	// Find the index before which all events are SQLUpdates on descriptors.
	descriptorUpdatesIdx := sort.Search(len(events), func(i int) bool {
		update := events[i].(event).update
		return update.IsProtectedTimestampUpdate()
	})

	// Deduplicate the SQLUpdates emitted by the buffer that apply to descriptors.
	for i, ev := range events[:descriptorUpdatesIdx] {
		update := ev.(event).update
		descriptorUpdate := update.GetDescriptorUpdate()
		if i == 0 {
			sqlUpdates = append(sqlUpdates, update)
			continue
		}

		prevUpdate := events[i-1].(event).update
		if prevUpdate.GetDescriptorUpdate().ID != descriptorUpdate.ID {
			sqlUpdates = append(sqlUpdates, update)
			continue
		}

		prevDescriptorSQLUpdate := sqlUpdates[len(sqlUpdates)-1].GetDescriptorUpdate()
		descType, err := combine(prevDescriptorSQLUpdate.DescriptorType,
			descriptorUpdate.DescriptorType)
		if err != nil {
			return nil, hlc.Timestamp{}, err
		}
		sqlUpdates[len(sqlUpdates)-1] = spanconfig.MakeDescriptorSQLUpdate(
			prevDescriptorSQLUpdate.ID, descType)
	}

	// Deduplicate the SQLUpdates emitted by the buffer that apply to protected
	// timestamps.
	ptsUpdates := make(map[string]struct{})
	for _, ev := range events[descriptorUpdatesIdx:] {
		update := ev.(event).update
		ptsUpdate := update.GetProtectedTimestampUpdate()
		if _, exists := ptsUpdates[ptsUpdate.ClusterOrTenantsTarget.String()]; exists {
			continue
		}
		ptsUpdates[ptsUpdate.ClusterOrTenantsTarget.String()] = struct{}{}
		sqlUpdates = append(sqlUpdates, update)
	}
	return sqlUpdates, combinedFrontierTS, nil
}

// combine takes two catalog.DescriptorTypes and combines them according to the
// following semantics:
// - Any can combine with any concrete descriptor type (including itself).
// Concrete descriptor types are {Table,Database,Schema,Type} descriptor types.
// - Concrete descriptor types can combine with themselves.
// - A concrete descriptor type cannot combine with another concrete descriptor
// type.
func combine(d1 catalog.DescriptorType, d2 catalog.DescriptorType) (catalog.DescriptorType, error) {
	if d1 == d2 {
		return d1, nil
	}
	if d1 == catalog.Any {
		return d2, nil
	}
	if d2 == catalog.Any {
		return d1, nil
	}
	return catalog.Any, errors.AssertionFailedf("cannot combine %s and %s", d1, d2)
}
