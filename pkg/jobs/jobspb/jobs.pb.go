// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jobs/jobspb/jobs.proto

package jobspb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import errorspb "github.com/cockroachdb/errors/errorspb"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import github_com_cockroachdb_cockroach_pkg_sql_sqlbase "github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
import github_com_cockroachdb_cockroach_pkg_sql_sem_tree "github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	Status_DRAINING_NAMES       Status = 0
	Status_WAIT_FOR_GC_INTERVAL Status = 1
	Status_ROCKSDB_COMPACTION   Status = 2
	Status_DONE                 Status = 10
)

var Status_name = map[int32]string{
	0:  "DRAINING_NAMES",
	1:  "WAIT_FOR_GC_INTERVAL",
	2:  "ROCKSDB_COMPACTION",
	10: "DONE",
}
var Status_value = map[string]int32{
	"DRAINING_NAMES":       0,
	"WAIT_FOR_GC_INTERVAL": 1,
	"ROCKSDB_COMPACTION":   2,
	"DONE":                 10,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{0}
}

type Type int32

const (
	TypeUnspecified     Type = 0
	TypeBackup          Type = 1
	TypeRestore         Type = 2
	TypeSchemaChange    Type = 3
	TypeImport          Type = 4
	TypeChangefeed      Type = 5
	TypeCreateStats     Type = 6
	TypeAutoCreateStats Type = 7
)

var Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "BACKUP",
	2: "RESTORE",
	3: "SCHEMA_CHANGE",
	4: "IMPORT",
	5: "CHANGEFEED",
	6: "CREATE_STATS",
	7: "AUTO_CREATE_STATS",
}
var Type_value = map[string]int32{
	"UNSPECIFIED":       0,
	"BACKUP":            1,
	"RESTORE":           2,
	"SCHEMA_CHANGE":     3,
	"IMPORT":            4,
	"CHANGEFEED":        5,
	"CREATE_STATS":      6,
	"AUTO_CREATE_STATS": 7,
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{1}
}

type Lease struct {
	// The ID of the node that holds the lease.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// The epoch of the lease holder's node liveness entry.
	Epoch int64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *Lease) Reset()         { *m = Lease{} }
func (m *Lease) String() string { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()    {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{0}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(dst, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

type BackupDetails struct {
	StartTime hlc.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	EndTime   hlc.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// URI is the URI for the main backup destination. For partitioned backups,
	// the main BACKUP manifest and files with no other specified destination are
	// written to this location. For regular backups, all files are written to
	// this location.
	URI string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// URIsByLocalityKV is a map of locality KVs to store URIs, used for
	// partitioned backups.
	URIsByLocalityKV map[string]string              `protobuf:"bytes,5,rep,name=uris_by_locality_kv,json=urisByLocalityKv,proto3" json:"uris_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	BackupManifest   []byte                         `protobuf:"bytes,4,opt,name=backup_manifest,json=backupManifest,proto3" json:"backup_manifest,omitempty"`
	Encryption       *roachpb.FileEncryptionOptions `protobuf:"bytes,6,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *BackupDetails) Reset()         { *m = BackupDetails{} }
func (m *BackupDetails) String() string { return proto.CompactTextString(m) }
func (*BackupDetails) ProtoMessage()    {}
func (*BackupDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{1}
}
func (m *BackupDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDetails.Merge(dst, src)
}
func (m *BackupDetails) XXX_Size() int {
	return m.Size()
}
func (m *BackupDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDetails.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDetails proto.InternalMessageInfo

type BackupProgress struct {
}

func (m *BackupProgress) Reset()         { *m = BackupProgress{} }
func (m *BackupProgress) String() string { return proto.CompactTextString(m) }
func (*BackupProgress) ProtoMessage()    {}
func (*BackupProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{2}
}
func (m *BackupProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupProgress.Merge(dst, src)
}
func (m *BackupProgress) XXX_Size() int {
	return m.Size()
}
func (m *BackupProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupProgress.DiscardUnknown(m)
}

var xxx_messageInfo_BackupProgress proto.InternalMessageInfo

type RestoreDetails struct {
	EndTime       hlc.Timestamp                                                                        `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	TableRewrites map[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite `protobuf:"bytes,2,rep,name=table_rewrites,json=tableRewrites,proto3,castkey=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"table_rewrites,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// URIs contains one URI for each backup (full or incremental) corresponding
	// to the location of the main BACKUP manifest. For partitioned backups, each
	// backup may also have files in other stores.
	URIs               []string                                                             `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	BackupLocalityInfo []RestoreDetails_BackupLocalityInfo                                  `protobuf:"bytes,7,rep,name=backup_locality_info,json=backupLocalityInfo,proto3" json:"backup_locality_info"`
	TableDescs         []*sqlbase.TableDescriptor                                           `protobuf:"bytes,5,rep,name=table_descs,json=tableDescs,proto3" json:"table_descs,omitempty"`
	OverrideDB         string                                                               `protobuf:"bytes,6,opt,name=override_db,json=overrideDb,proto3" json:"override_db,omitempty"`
	PrepareCompleted   bool                                                                 `protobuf:"varint,8,opt,name=prepare_completed,json=prepareCompleted,proto3" json:"prepare_completed,omitempty"`
	StatsInserted      bool                                                                 `protobuf:"varint,9,opt,name=stats_inserted,json=statsInserted,proto3" json:"stats_inserted,omitempty"`
	TablesPublished    bool                                                                 `protobuf:"varint,10,opt,name=tables_published,json=tablesPublished,proto3" json:"tables_published,omitempty"`
	DescriptorCoverage github_com_cockroachdb_cockroach_pkg_sql_sem_tree.DescriptorCoverage `protobuf:"varint,11,opt,name=descriptor_coverage,json=descriptorCoverage,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/tree.DescriptorCoverage" json:"descriptor_coverage,omitempty"`
	Encryption         *roachpb.FileEncryptionOptions                                       `protobuf:"bytes,12,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *RestoreDetails) Reset()         { *m = RestoreDetails{} }
func (m *RestoreDetails) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails) ProtoMessage()    {}
func (*RestoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{3}
}
func (m *RestoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails.Merge(dst, src)
}
func (m *RestoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails proto.InternalMessageInfo

type RestoreDetails_TableRewrite struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"table_id,omitempty"`
	ParentID github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID `protobuf:"varint,2,opt,name=parent_id,json=parentId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"parent_id,omitempty"`
}

func (m *RestoreDetails_TableRewrite) Reset()         { *m = RestoreDetails_TableRewrite{} }
func (m *RestoreDetails_TableRewrite) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails_TableRewrite) ProtoMessage()    {}
func (*RestoreDetails_TableRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{3, 0}
}
func (m *RestoreDetails_TableRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails_TableRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails_TableRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails_TableRewrite.Merge(dst, src)
}
func (m *RestoreDetails_TableRewrite) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails_TableRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails_TableRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails_TableRewrite proto.InternalMessageInfo

type RestoreDetails_BackupLocalityInfo struct {
	URIsByOriginalLocalityKV map[string]string `protobuf:"bytes,1,rep,name=uris_by_original_locality_kv,json=urisByOriginalLocalityKv,proto3" json:"uris_by_original_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RestoreDetails_BackupLocalityInfo) Reset()         { *m = RestoreDetails_BackupLocalityInfo{} }
func (m *RestoreDetails_BackupLocalityInfo) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails_BackupLocalityInfo) ProtoMessage()    {}
func (*RestoreDetails_BackupLocalityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{3, 1}
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails_BackupLocalityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails_BackupLocalityInfo.Merge(dst, src)
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails_BackupLocalityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails_BackupLocalityInfo proto.InternalMessageInfo

type RestoreProgress struct {
	HighWater []byte `protobuf:"bytes,1,opt,name=high_water,json=highWater,proto3" json:"high_water,omitempty"`
}

func (m *RestoreProgress) Reset()         { *m = RestoreProgress{} }
func (m *RestoreProgress) String() string { return proto.CompactTextString(m) }
func (*RestoreProgress) ProtoMessage()    {}
func (*RestoreProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{4}
}
func (m *RestoreProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreProgress.Merge(dst, src)
}
func (m *RestoreProgress) XXX_Size() int {
	return m.Size()
}
func (m *RestoreProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreProgress proto.InternalMessageInfo

type ImportDetails struct {
	Tables     []ImportDetails_Table                               `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	URIs       []string                                            `protobuf:"bytes,2,rep,name=uris,proto3" json:"uris,omitempty"`
	Format     roachpb.IOFileFormat                                `protobuf:"bytes,3,opt,name=format,proto3" json:"format"`
	SSTSize    int64                                               `protobuf:"varint,4,opt,name=sst_size,json=sstSize,proto3" json:"sst_size,omitempty"`
	Oversample int64                                               `protobuf:"varint,9,opt,name=oversample,proto3" json:"oversample,omitempty"`
	SkipFKs    bool                                                `protobuf:"varint,10,opt,name=skip_fks,json=skipFks,proto3" json:"skip_fks,omitempty"`
	Walltime   int64                                               `protobuf:"varint,5,opt,name=walltime,proto3" json:"walltime,omitempty"`
	ParentID   github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID `protobuf:"varint,6,opt,name=parent_id,json=parentId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"parent_id,omitempty"`
	BackupPath string                                              `protobuf:"bytes,7,opt,name=backup_path,json=backupPath,proto3" json:"backup_path,omitempty"`
	// samples is a sampling of cockroach KV keys generated from the input data.
	// It is populated with the sampling phase's results. These must be
	// used if a job is resumed to guarantee that AddSSTable will not attempt
	// to add ranges with an old split point within them.
	Samples [][]byte `protobuf:"bytes,8,rep,name=samples,proto3" json:"samples,omitempty"`
	// ingest_directly means the Import job directly ingests the data as readers
	// produce it instead of sampling it and then setting up a distsql shuffle and
	// sort that produced sorted, non-overlapping data to ingest. When ingesting
	// directly, many other fields like samples, oversample, sst_size are ignored.
	IngestDirectly  bool `protobuf:"varint,11,opt,name=ingest_directly,json=ingestDirectly,proto3" json:"ingest_directly,omitempty"`
	PrepareComplete bool `protobuf:"varint,12,opt,name=prepare_complete,json=prepareComplete,proto3" json:"prepare_complete,omitempty"`
	TablesPublished bool `protobuf:"varint,13,opt,name=tables_published,json=tablesPublished,proto3" json:"tables_published,omitempty"`
	// ProtectedTimestampRecord is the ID of the protected timestamp record
	// corresponding to this job. While the job ought to clean up the record
	// when it enters a terminal state, there may be cases where it cannot or
	// does not run the code to do so. To deal with this there is a background
	// reconcilliation loop to ensure that protected timestamps are cleaned up.
	ProtectedTimestampRecord *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,22,opt,name=protected_timestamp_record,json=protectedTimestampRecord,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"protected_timestamp_record,omitempty"`
}

func (m *ImportDetails) Reset()         { *m = ImportDetails{} }
func (m *ImportDetails) String() string { return proto.CompactTextString(m) }
func (*ImportDetails) ProtoMessage()    {}
func (*ImportDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{5}
}
func (m *ImportDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails.Merge(dst, src)
}
func (m *ImportDetails) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails proto.InternalMessageInfo

type ImportDetails_Table struct {
	Desc       *sqlbase.TableDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	Name       string                   `protobuf:"bytes,18,opt,name=name,proto3" json:"name,omitempty"`
	SeqVal     int64                    `protobuf:"varint,19,opt,name=seq_val,json=seqVal,proto3" json:"seq_val,omitempty"`
	IsNew      bool                     `protobuf:"varint,20,opt,name=is_new,json=isNew,proto3" json:"is_new,omitempty"`
	TargetCols []string                 `protobuf:"bytes,21,rep,name=target_cols,json=targetCols,proto3" json:"target_cols,omitempty"`
}

func (m *ImportDetails_Table) Reset()         { *m = ImportDetails_Table{} }
func (m *ImportDetails_Table) String() string { return proto.CompactTextString(m) }
func (*ImportDetails_Table) ProtoMessage()    {}
func (*ImportDetails_Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{5, 0}
}
func (m *ImportDetails_Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails_Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails_Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails_Table.Merge(dst, src)
}
func (m *ImportDetails_Table) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails_Table) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails_Table.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails_Table proto.InternalMessageInfo

type ImportProgress struct {
	SamplingProgress []float32 `protobuf:"fixed32,1,rep,packed,name=sampling_progress,json=samplingProgress,proto3" json:"sampling_progress,omitempty"`
	ReadProgress     []float32 `protobuf:"fixed32,2,rep,packed,name=read_progress,json=readProgress,proto3" json:"read_progress,omitempty"`
	WriteProgress    []float32 `protobuf:"fixed32,3,rep,packed,name=write_progress,json=writeProgress,proto3" json:"write_progress,omitempty"`
	// The spans of split keys which have had their SSTable's generated.
	// This allows us to skip the shuffle stage for already-completed
	// spans when resuming an import job.
	SpanProgress []roachpb.Span `protobuf:"bytes,4,rep,name=span_progress,json=spanProgress,proto3" json:"span_progress"`
	// In direct-ingest import, once the KVs for i'th row of an input file have
	// been flushed, we can advance the count here and then on resume skip over
	// that many rows without needing to convert/process them at all.
	ResumePos []int64 `protobuf:"varint,5,rep,packed,name=resume_pos,json=resumePos,proto3" json:"resume_pos,omitempty"`
}

func (m *ImportProgress) Reset()         { *m = ImportProgress{} }
func (m *ImportProgress) String() string { return proto.CompactTextString(m) }
func (*ImportProgress) ProtoMessage()    {}
func (*ImportProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{6}
}
func (m *ImportProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportProgress.Merge(dst, src)
}
func (m *ImportProgress) XXX_Size() int {
	return m.Size()
}
func (m *ImportProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ImportProgress proto.InternalMessageInfo

type ResumeSpanList struct {
	ResumeSpans []roachpb.Span `protobuf:"bytes,1,rep,name=resume_spans,json=resumeSpans,proto3" json:"resume_spans"`
}

func (m *ResumeSpanList) Reset()         { *m = ResumeSpanList{} }
func (m *ResumeSpanList) String() string { return proto.CompactTextString(m) }
func (*ResumeSpanList) ProtoMessage()    {}
func (*ResumeSpanList) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{7}
}
func (m *ResumeSpanList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeSpanList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResumeSpanList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeSpanList.Merge(dst, src)
}
func (m *ResumeSpanList) XXX_Size() int {
	return m.Size()
}
func (m *ResumeSpanList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeSpanList.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeSpanList proto.InternalMessageInfo

type DroppedTableDetails struct {
	Name   string                                              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ID     github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID `protobuf:"varint,2,opt,name=ID,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"ID,omitempty"`
	Status Status                                              `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.sql.jobs.jobspb.Status" json:"status,omitempty"`
}

func (m *DroppedTableDetails) Reset()         { *m = DroppedTableDetails{} }
func (m *DroppedTableDetails) String() string { return proto.CompactTextString(m) }
func (*DroppedTableDetails) ProtoMessage()    {}
func (*DroppedTableDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{8}
}
func (m *DroppedTableDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DroppedTableDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DroppedTableDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DroppedTableDetails.Merge(dst, src)
}
func (m *DroppedTableDetails) XXX_Size() int {
	return m.Size()
}
func (m *DroppedTableDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_DroppedTableDetails.DiscardUnknown(m)
}

var xxx_messageInfo_DroppedTableDetails proto.InternalMessageInfo

type SchemaChangeDetails struct {
	// A schema change can involve running multiple processors backfilling
	// or deleting data. They occasionally checkpoint Spans so that the
	// processing can resume in the event of a node failure. The spans are
	// non-overlapping contiguous areas of the KV space that still need to
	// be processed. The index represents the index of a mutation in a
	// mutation list containing mutations for the same mutationID.
	ResumeSpanList []ResumeSpanList      `protobuf:"bytes,2,rep,name=resume_span_list,json=resumeSpanList,proto3" json:"resume_span_list"`
	DroppedTables  []DroppedTableDetails `protobuf:"bytes,3,rep,name=dropped_tables,json=droppedTables,proto3" json:"dropped_tables"`
	// The descriptor ID of the dropped database which created this job.
	DroppedDatabaseID github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID         `protobuf:"varint,4,opt,name=dropped_database_id,json=droppedDatabaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"dropped_database_id,omitempty"`
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID         `protobuf:"varint,5,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"table_id,omitempty"`
	MutationID        github_com_cockroachdb_cockroach_pkg_sql_sqlbase.MutationID `protobuf:"varint,6,opt,name=mutation_id,json=mutationId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.MutationID" json:"mutation_id,omitempty"`
}

func (m *SchemaChangeDetails) Reset()         { *m = SchemaChangeDetails{} }
func (m *SchemaChangeDetails) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeDetails) ProtoMessage()    {}
func (*SchemaChangeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{9}
}
func (m *SchemaChangeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeDetails.Merge(dst, src)
}
func (m *SchemaChangeDetails) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeDetails proto.InternalMessageInfo

type SchemaChangeProgress struct {
}

func (m *SchemaChangeProgress) Reset()         { *m = SchemaChangeProgress{} }
func (m *SchemaChangeProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeProgress) ProtoMessage()    {}
func (*SchemaChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{10}
}
func (m *SchemaChangeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeProgress.Merge(dst, src)
}
func (m *SchemaChangeProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeProgress proto.InternalMessageInfo

type ChangefeedTarget struct {
	StatementTimeName string `protobuf:"bytes,1,opt,name=statement_time_name,json=statementTimeName,proto3" json:"statement_time_name,omitempty"`
}

func (m *ChangefeedTarget) Reset()         { *m = ChangefeedTarget{} }
func (m *ChangefeedTarget) String() string { return proto.CompactTextString(m) }
func (*ChangefeedTarget) ProtoMessage()    {}
func (*ChangefeedTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{11}
}
func (m *ChangefeedTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedTarget.Merge(dst, src)
}
func (m *ChangefeedTarget) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedTarget.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedTarget proto.InternalMessageInfo

type ChangefeedDetails struct {
	// Targets contains the user-specified tables and databases to watch, mapping
	// the descriptor id to the name at the time of changefeed creating. There is
	// a 1:1 correspondance between unique targets in the original sql query and
	// entries in this map.
	//
	// - A watched table is stored here under its table id
	// - TODO(dan): A watched database is stored here under its database id
	// - TODO(dan): A db.* expansion is treated identicially to watching the
	//   database
	//
	// Note that the TODOs mean this field currently is guaranteed to only hold
	// table ids and a cluster version check will be added when this changes.
	//
	// The names at resolution time are included so that table and database
	// renames can be detected. They are also used to construct an error message
	// if the descriptor id no longer exists when the jobs is unpaused (which can
	// happen if it was dropped or truncated).
	Targets       ChangefeedTargets `protobuf:"bytes,6,rep,name=targets,proto3,casttype=ChangefeedTargets,castkey=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"targets" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SinkURI       string            `protobuf:"bytes,3,opt,name=sink_uri,json=sinkUri,proto3" json:"sink_uri,omitempty"`
	Opts          map[string]string `protobuf:"bytes,4,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StatementTime hlc.Timestamp     `protobuf:"bytes,7,opt,name=statement_time,json=statementTime,proto3" json:"statement_time"`
}

func (m *ChangefeedDetails) Reset()         { *m = ChangefeedDetails{} }
func (m *ChangefeedDetails) String() string { return proto.CompactTextString(m) }
func (*ChangefeedDetails) ProtoMessage()    {}
func (*ChangefeedDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{12}
}
func (m *ChangefeedDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedDetails.Merge(dst, src)
}
func (m *ChangefeedDetails) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedDetails proto.InternalMessageInfo

type ResolvedSpan struct {
	Span            roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	Timestamp       hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	BoundaryReached bool          `protobuf:"varint,3,opt,name=boundary_reached,json=boundaryReached,proto3" json:"boundary_reached,omitempty"`
}

func (m *ResolvedSpan) Reset()         { *m = ResolvedSpan{} }
func (m *ResolvedSpan) String() string { return proto.CompactTextString(m) }
func (*ResolvedSpan) ProtoMessage()    {}
func (*ResolvedSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{13}
}
func (m *ResolvedSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResolvedSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedSpan.Merge(dst, src)
}
func (m *ResolvedSpan) XXX_Size() int {
	return m.Size()
}
func (m *ResolvedSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedSpan.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedSpan proto.InternalMessageInfo

type ChangefeedProgress struct {
	ResolvedSpans []ResolvedSpan `protobuf:"bytes,2,rep,name=resolved_spans,json=resolvedSpans,proto3" json:"resolved_spans"`
}

func (m *ChangefeedProgress) Reset()         { *m = ChangefeedProgress{} }
func (m *ChangefeedProgress) String() string { return proto.CompactTextString(m) }
func (*ChangefeedProgress) ProtoMessage()    {}
func (*ChangefeedProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{14}
}
func (m *ChangefeedProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedProgress.Merge(dst, src)
}
func (m *ChangefeedProgress) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedProgress proto.InternalMessageInfo

// CreateStatsDetails are used for the CreateStats job, which is triggered
// whenever the `CREATE STATISTICS` SQL statement is run. The CreateStats job
// collects table statistics, which contain info such as the number of rows in
// the table or the number of distinct values in a column.
type CreateStatsDetails struct {
	Name            string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Table           sqlbase.TableDescriptor      `protobuf:"bytes,2,opt,name=table,proto3" json:"table"`
	ColumnStats     []CreateStatsDetails_ColStat `protobuf:"bytes,3,rep,name=column_stats,json=columnStats,proto3" json:"column_stats"`
	Statement       string                       `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"`
	AsOf            *hlc.Timestamp               `protobuf:"bytes,5,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`
	MaxFractionIdle float64                      `protobuf:"fixed64,7,opt,name=max_fraction_idle,json=maxFractionIdle,proto3" json:"max_fraction_idle,omitempty"`
	// Fully qualified table name.
	FQTableName string `protobuf:"bytes,6,opt,name=fq_table_name,json=fqTableName,proto3" json:"fq_table_name,omitempty"`
}

func (m *CreateStatsDetails) Reset()         { *m = CreateStatsDetails{} }
func (m *CreateStatsDetails) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails) ProtoMessage()    {}
func (*CreateStatsDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{15}
}
func (m *CreateStatsDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails.Merge(dst, src)
}
func (m *CreateStatsDetails) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails proto.InternalMessageInfo

type CreateStatsDetails_ColStat struct {
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID `protobuf:"varint,1,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ColumnID" json:"column_ids,omitempty"`
	// Indicates whether this column stat should include a histogram.
	HasHistogram bool `protobuf:"varint,2,opt,name=has_histogram,json=hasHistogram,proto3" json:"has_histogram,omitempty"`
}

func (m *CreateStatsDetails_ColStat) Reset()         { *m = CreateStatsDetails_ColStat{} }
func (m *CreateStatsDetails_ColStat) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails_ColStat) ProtoMessage()    {}
func (*CreateStatsDetails_ColStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{15, 0}
}
func (m *CreateStatsDetails_ColStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails_ColStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails_ColStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails_ColStat.Merge(dst, src)
}
func (m *CreateStatsDetails_ColStat) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails_ColStat) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails_ColStat.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails_ColStat proto.InternalMessageInfo

type CreateStatsProgress struct {
}

func (m *CreateStatsProgress) Reset()         { *m = CreateStatsProgress{} }
func (m *CreateStatsProgress) String() string { return proto.CompactTextString(m) }
func (*CreateStatsProgress) ProtoMessage()    {}
func (*CreateStatsProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{16}
}
func (m *CreateStatsProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsProgress.Merge(dst, src)
}
func (m *CreateStatsProgress) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsProgress.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsProgress proto.InternalMessageInfo

type Payload struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// If empty, the description is assumed to be the statement.
	Statement string `protobuf:"bytes,16,opt,name=statement,proto3" json:"statement,omitempty"`
	Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// For consistency with the SQL timestamp type, which has microsecond
	// precision, we avoid the timestamp.Timestamp WKT, which has nanosecond
	// precision, and use microsecond integers directly.
	StartedMicros  int64                                                 `protobuf:"varint,3,opt,name=started_micros,json=startedMicros,proto3" json:"started_micros,omitempty"`
	FinishedMicros int64                                                 `protobuf:"varint,4,opt,name=finished_micros,json=finishedMicros,proto3" json:"finished_micros,omitempty"`
	DescriptorIDs  []github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID `protobuf:"varint,6,rep,packed,name=descriptor_ids,json=descriptorIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sqlbase.ID" json:"descriptor_ids,omitempty"`
	// TODO (lucy): Deprecate the string error field and move to using the encoded
	// errors everywhere.
	Error         string                   `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	ResumeErrors  []*errorspb.EncodedError `protobuf:"bytes,17,rep,name=resume_errors,json=resumeErrors,proto3" json:"resume_errors,omitempty"`
	CleanupErrors []*errorspb.EncodedError `protobuf:"bytes,18,rep,name=cleanup_errors,json=cleanupErrors,proto3" json:"cleanup_errors,omitempty"`
	// FinalResumeError is set when an error occurs that requires the job to be
	// reverted. The error is recorded so it can be handled while reverting, if
	// needed.
	FinalResumeError *errorspb.EncodedError `protobuf:"bytes,19,opt,name=final_resume_error,json=finalResumeError,proto3" json:"final_resume_error,omitempty"`
	Lease            *Lease                 `protobuf:"bytes,9,opt,name=lease,proto3" json:"lease,omitempty"`
	// Noncancelable is used to denote when a job cannot be canceled. This field
	// will not be respected in mixed version clusters where some nodes have
	// a version < 20.1, so it can only be used in cases where all nodes having
	// versions >= 20.1 is guaranteed.
	Noncancelable bool `protobuf:"varint,20,opt,name=noncancelable,proto3" json:"noncancelable,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Payload_Backup
	//	*Payload_Restore
	//	*Payload_SchemaChange
	//	*Payload_Import
	//	*Payload_Changefeed
	//	*Payload_CreateStats
	Details isPayload_Details `protobuf_oneof:"details"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{17}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(dst, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

type isPayload_Details interface {
	isPayload_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Payload_Backup struct {
	Backup *BackupDetails `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Payload_Restore struct {
	Restore *RestoreDetails `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Payload_SchemaChange struct {
	SchemaChange *SchemaChangeDetails `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Payload_Import struct {
	Import *ImportDetails `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Payload_Changefeed struct {
	Changefeed *ChangefeedDetails `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Payload_CreateStats struct {
	CreateStats *CreateStatsDetails `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}

func (*Payload_Backup) isPayload_Details()       {}
func (*Payload_Restore) isPayload_Details()      {}
func (*Payload_SchemaChange) isPayload_Details() {}
func (*Payload_Import) isPayload_Details()       {}
func (*Payload_Changefeed) isPayload_Details()   {}
func (*Payload_CreateStats) isPayload_Details()  {}

func (m *Payload) GetDetails() isPayload_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Payload) GetBackup() *BackupDetails {
	if x, ok := m.GetDetails().(*Payload_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Payload) GetRestore() *RestoreDetails {
	if x, ok := m.GetDetails().(*Payload_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Payload) GetSchemaChange() *SchemaChangeDetails {
	if x, ok := m.GetDetails().(*Payload_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Payload) GetImport() *ImportDetails {
	if x, ok := m.GetDetails().(*Payload_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Payload) GetChangefeed() *ChangefeedDetails {
	if x, ok := m.GetDetails().(*Payload_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Payload) GetCreateStats() *CreateStatsDetails {
	if x, ok := m.GetDetails().(*Payload_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Payload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Payload_OneofMarshaler, _Payload_OneofUnmarshaler, _Payload_OneofSizer, []interface{}{
		(*Payload_Backup)(nil),
		(*Payload_Restore)(nil),
		(*Payload_SchemaChange)(nil),
		(*Payload_Import)(nil),
		(*Payload_Changefeed)(nil),
		(*Payload_CreateStats)(nil),
	}
}

func _Payload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Payload_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Payload_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Payload_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Payload_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Payload_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Payload.Details has unexpected type %T", x)
	}
	return nil
}

func _Payload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Payload)
	switch tag {
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_CreateStats{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Payload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Progress struct {
	// Types that are valid to be assigned to Progress:
	//	*Progress_FractionCompleted
	//	*Progress_HighWater
	Progress       isProgress_Progress `protobuf_oneof:"progress"`
	ModifiedMicros int64               `protobuf:"varint,2,opt,name=modified_micros,json=modifiedMicros,proto3" json:"modified_micros,omitempty"`
	RunningStatus  string              `protobuf:"bytes,4,opt,name=running_status,json=runningStatus,proto3" json:"running_status,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Progress_Backup
	//	*Progress_Restore
	//	*Progress_SchemaChange
	//	*Progress_Import
	//	*Progress_Changefeed
	//	*Progress_CreateStats
	Details isProgress_Details `protobuf_oneof:"details"`
}

func (m *Progress) Reset()         { *m = Progress{} }
func (m *Progress) String() string { return proto.CompactTextString(m) }
func (*Progress) ProtoMessage()    {}
func (*Progress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{18}
}
func (m *Progress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Progress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Progress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Progress.Merge(dst, src)
}
func (m *Progress) XXX_Size() int {
	return m.Size()
}
func (m *Progress) XXX_DiscardUnknown() {
	xxx_messageInfo_Progress.DiscardUnknown(m)
}

var xxx_messageInfo_Progress proto.InternalMessageInfo

type isProgress_Progress interface {
	isProgress_Progress()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isProgress_Details interface {
	isProgress_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Progress_FractionCompleted struct {
	FractionCompleted float32 `protobuf:"fixed32,1,opt,name=fraction_completed,json=fractionCompleted,proto3,oneof"`
}
type Progress_HighWater struct {
	HighWater *hlc.Timestamp `protobuf:"bytes,3,opt,name=high_water,json=highWater,proto3,oneof"`
}
type Progress_Backup struct {
	Backup *BackupProgress `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Progress_Restore struct {
	Restore *RestoreProgress `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Progress_SchemaChange struct {
	SchemaChange *SchemaChangeProgress `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Progress_Import struct {
	Import *ImportProgress `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Progress_Changefeed struct {
	Changefeed *ChangefeedProgress `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Progress_CreateStats struct {
	CreateStats *CreateStatsProgress `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}

func (*Progress_FractionCompleted) isProgress_Progress() {}
func (*Progress_HighWater) isProgress_Progress()         {}
func (*Progress_Backup) isProgress_Details()             {}
func (*Progress_Restore) isProgress_Details()            {}
func (*Progress_SchemaChange) isProgress_Details()       {}
func (*Progress_Import) isProgress_Details()             {}
func (*Progress_Changefeed) isProgress_Details()         {}
func (*Progress_CreateStats) isProgress_Details()        {}

func (m *Progress) GetProgress() isProgress_Progress {
	if m != nil {
		return m.Progress
	}
	return nil
}
func (m *Progress) GetDetails() isProgress_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Progress) GetFractionCompleted() float32 {
	if x, ok := m.GetProgress().(*Progress_FractionCompleted); ok {
		return x.FractionCompleted
	}
	return 0
}

func (m *Progress) GetHighWater() *hlc.Timestamp {
	if x, ok := m.GetProgress().(*Progress_HighWater); ok {
		return x.HighWater
	}
	return nil
}

func (m *Progress) GetBackup() *BackupProgress {
	if x, ok := m.GetDetails().(*Progress_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Progress) GetRestore() *RestoreProgress {
	if x, ok := m.GetDetails().(*Progress_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Progress) GetSchemaChange() *SchemaChangeProgress {
	if x, ok := m.GetDetails().(*Progress_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Progress) GetImport() *ImportProgress {
	if x, ok := m.GetDetails().(*Progress_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Progress) GetChangefeed() *ChangefeedProgress {
	if x, ok := m.GetDetails().(*Progress_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Progress) GetCreateStats() *CreateStatsProgress {
	if x, ok := m.GetDetails().(*Progress_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Progress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Progress_OneofMarshaler, _Progress_OneofUnmarshaler, _Progress_OneofSizer, []interface{}{
		(*Progress_FractionCompleted)(nil),
		(*Progress_HighWater)(nil),
		(*Progress_Backup)(nil),
		(*Progress_Restore)(nil),
		(*Progress_SchemaChange)(nil),
		(*Progress_Import)(nil),
		(*Progress_Changefeed)(nil),
		(*Progress_CreateStats)(nil),
	}
}

func _Progress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FractionCompleted)))
	case *Progress_HighWater:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HighWater); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Progress has unexpected type %T", x)
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Progress_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Progress_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Progress_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Progress_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Progress_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Details has unexpected type %T", x)
	}
	return nil
}

func _Progress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Progress)
	switch tag {
	case 1: // progress.fraction_completed
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Progress = &Progress_FractionCompleted{math.Float32frombits(uint32(x))}
		return true, err
	case 3: // progress.high_water
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hlc.Timestamp)
		err := b.DecodeMessage(msg)
		m.Progress = &Progress_HighWater{msg}
		return true, err
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_CreateStats{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Progress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		n += 1 // tag and wire
		n += 4
	case *Progress_HighWater:
		s := proto.Size(x.HighWater)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Job struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Keep progress first as it may bre more relevant to see when looking at a
	// running job.
	Progress *Progress `protobuf:"bytes,2,opt,name=progress,proto3" json:"progress,omitempty"`
	Payload  *Payload  `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_73f32b5a5a4957b4, []int{19}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(dst, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Lease)(nil), "cockroach.sql.jobs.jobspb.Lease")
	proto.RegisterType((*BackupDetails)(nil), "cockroach.sql.jobs.jobspb.BackupDetails")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.BackupDetails.UrisByLocalityKvEntry")
	proto.RegisterType((*BackupProgress)(nil), "cockroach.sql.jobs.jobspb.BackupProgress")
	proto.RegisterType((*RestoreDetails)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.TableRewritesEntry")
	proto.RegisterType((*RestoreDetails_TableRewrite)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.TableRewrite")
	proto.RegisterType((*RestoreDetails_BackupLocalityInfo)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.BackupLocalityInfo")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.BackupLocalityInfo.UrisByOriginalLocalityKvEntry")
	proto.RegisterType((*RestoreProgress)(nil), "cockroach.sql.jobs.jobspb.RestoreProgress")
	proto.RegisterType((*ImportDetails)(nil), "cockroach.sql.jobs.jobspb.ImportDetails")
	proto.RegisterType((*ImportDetails_Table)(nil), "cockroach.sql.jobs.jobspb.ImportDetails.Table")
	proto.RegisterType((*ImportProgress)(nil), "cockroach.sql.jobs.jobspb.ImportProgress")
	proto.RegisterType((*ResumeSpanList)(nil), "cockroach.sql.jobs.jobspb.ResumeSpanList")
	proto.RegisterType((*DroppedTableDetails)(nil), "cockroach.sql.jobs.jobspb.DroppedTableDetails")
	proto.RegisterType((*SchemaChangeDetails)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeDetails")
	proto.RegisterType((*SchemaChangeProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeProgress")
	proto.RegisterType((*ChangefeedTarget)(nil), "cockroach.sql.jobs.jobspb.ChangefeedTarget")
	proto.RegisterType((*ChangefeedDetails)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails.OptsEntry")
	proto.RegisterMapType((ChangefeedTargets)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails.TargetsEntry")
	proto.RegisterType((*ResolvedSpan)(nil), "cockroach.sql.jobs.jobspb.ResolvedSpan")
	proto.RegisterType((*ChangefeedProgress)(nil), "cockroach.sql.jobs.jobspb.ChangefeedProgress")
	proto.RegisterType((*CreateStatsDetails)(nil), "cockroach.sql.jobs.jobspb.CreateStatsDetails")
	proto.RegisterType((*CreateStatsDetails_ColStat)(nil), "cockroach.sql.jobs.jobspb.CreateStatsDetails.ColStat")
	proto.RegisterType((*CreateStatsProgress)(nil), "cockroach.sql.jobs.jobspb.CreateStatsProgress")
	proto.RegisterType((*Payload)(nil), "cockroach.sql.jobs.jobspb.Payload")
	proto.RegisterType((*Progress)(nil), "cockroach.sql.jobs.jobspb.Progress")
	proto.RegisterType((*Job)(nil), "cockroach.sql.jobs.jobspb.Job")
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.Status", Status_name, Status_value)
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.Type", Type_name, Type_value)
}
func (this *Lease) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Lease)
	if !ok {
		that2, ok := that.(Lease)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *BackupDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StartTime.Size()))
	n1, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n2, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.BackupManifest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.BackupManifest)))
		i += copy(dAtA[i:], m.BackupManifest)
	}
	if len(m.URIsByLocalityKV) > 0 {
		keysForURIsByLocalityKV := make([]string, 0, len(m.URIsByLocalityKV))
		for k := range m.URIsByLocalityKV {
			keysForURIsByLocalityKV = append(keysForURIsByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByLocalityKV)
		for _, k := range keysForURIsByLocalityKV {
			dAtA[i] = 0x2a
			i++
			v := m.URIsByLocalityKV[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Encryption != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n3, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *BackupProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RestoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableRewrites) > 0 {
		keysForTableRewrites := make([]uint32, 0, len(m.TableRewrites))
		for k := range m.TableRewrites {
			keysForTableRewrites = append(keysForTableRewrites, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTableRewrites)
		for _, k := range keysForTableRewrites {
			dAtA[i] = 0x12
			i++
			v := m.TableRewrites[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n5, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.TableDescs) > 0 {
		for _, msg := range m.TableDescs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OverrideDB) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.OverrideDB)))
		i += copy(dAtA[i:], m.OverrideDB)
	}
	if len(m.BackupLocalityInfo) > 0 {
		for _, msg := range m.BackupLocalityInfo {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PrepareCompleted {
		dAtA[i] = 0x40
		i++
		if m.PrepareCompleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StatsInserted {
		dAtA[i] = 0x48
		i++
		if m.StatsInserted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TablesPublished {
		dAtA[i] = 0x50
		i++
		if m.TablesPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DescriptorCoverage != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n6, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *RestoreDetails_TableRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails_TableRewrite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TableID))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	return i, nil
}

func (m *RestoreDetails_BackupLocalityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails_BackupLocalityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URIsByOriginalLocalityKV) > 0 {
		keysForURIsByOriginalLocalityKV := make([]string, 0, len(m.URIsByOriginalLocalityKV))
		for k := range m.URIsByOriginalLocalityKV {
			keysForURIsByOriginalLocalityKV = append(keysForURIsByOriginalLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByOriginalLocalityKV)
		for _, k := range keysForURIsByOriginalLocalityKV {
			dAtA[i] = 0xa
			i++
			v := m.URIsByOriginalLocalityKV[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *RestoreProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HighWater) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.HighWater)))
		i += copy(dAtA[i:], m.HighWater)
	}
	return i, nil
}

func (m *ImportDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Format.Size()))
	n7, err := m.Format.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.SSTSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	if len(m.BackupPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.BackupPath)))
		i += copy(dAtA[i:], m.BackupPath)
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			dAtA[i] = 0x42
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Oversample != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Oversample))
	}
	if m.SkipFKs {
		dAtA[i] = 0x50
		i++
		if m.SkipFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IngestDirectly {
		dAtA[i] = 0x58
		i++
		if m.IngestDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrepareComplete {
		dAtA[i] = 0x60
		i++
		if m.PrepareComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TablesPublished {
		dAtA[i] = 0x68
		i++
		if m.TablesPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProtectedTimestampRecord != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ProtectedTimestampRecord.Size()))
		n8, err := m.ProtectedTimestampRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ImportDetails_Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails_Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Desc.Size()))
		n9, err := m.Desc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.SeqVal != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SeqVal))
	}
	if m.IsNew {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ImportProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SamplingProgress)*4))
		for _, num := range m.SamplingProgress {
			f10 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f10))
			i += 4
		}
	}
	if len(m.ReadProgress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.ReadProgress)*4))
		for _, num := range m.ReadProgress {
			f11 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f11))
			i += 4
		}
	}
	if len(m.WriteProgress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.WriteProgress)*4))
		for _, num := range m.WriteProgress {
			f12 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f12))
			i += 4
		}
	}
	if len(m.SpanProgress) > 0 {
		for _, msg := range m.SpanProgress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResumePos) > 0 {
		dAtA14 := make([]byte, len(m.ResumePos)*10)
		var j13 int
		for _, num1 := range m.ResumePos {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *ResumeSpanList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeSpanList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, msg := range m.ResumeSpans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DroppedTableDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DroppedTableDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, msg := range m.ResumeSpanList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, msg := range m.DroppedTables {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DroppedDatabaseID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DroppedDatabaseID))
	}
	if m.TableID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TableID))
	}
	if m.MutationID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.MutationID))
	}
	return i, nil
}

func (m *SchemaChangeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChangefeedTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatementTimeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.StatementTimeName)))
		i += copy(dAtA[i:], m.StatementTimeName)
	}
	return i, nil
}

func (m *ChangefeedDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SinkURI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SinkURI)))
		i += copy(dAtA[i:], m.SinkURI)
	}
	if len(m.Opts) > 0 {
		keysForOpts := make([]string, 0, len(m.Opts))
		for k := range m.Opts {
			keysForOpts = append(keysForOpts, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOpts)
		for _, k := range keysForOpts {
			dAtA[i] = 0x22
			i++
			v := m.Opts[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Targets) > 0 {
		keysForTargets := make([]uint32, 0, len(m.Targets))
		for k := range m.Targets {
			keysForTargets = append(keysForTargets, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTargets)
		for _, k := range keysForTargets {
			dAtA[i] = 0x32
			i++
			v := m.Targets[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64((&v).Size()))
			n15, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n15
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StatementTime.Size()))
	n16, err := m.StatementTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *ResolvedSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedSpan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Span.Size()))
	n17, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Timestamp.Size()))
	n18, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.BoundaryReached {
		dAtA[i] = 0x18
		i++
		if m.BoundaryReached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChangefeedProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, msg := range m.ResolvedSpans {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateStatsDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Table.Size()))
	n19, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.ColumnStats) > 0 {
		for _, msg := range m.ColumnStats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.AsOf != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.AsOf.Size()))
		n20, err := m.AsOf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.FQTableName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.FQTableName)))
		i += copy(dAtA[i:], m.FQTableName)
	}
	if m.MaxFractionIdle != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFractionIdle))))
		i += 8
	}
	return i, nil
}

func (m *CreateStatsDetails_ColStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails_ColStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA22 := make([]byte, len(m.ColumnIDs)*10)
		var j21 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if m.HasHistogram {
		dAtA[i] = 0x10
		i++
		if m.HasHistogram {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateStatsProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.StartedMicros != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		dAtA24 := make([]byte, len(m.DescriptorIDs)*10)
		var j23 int
		for _, num := range m.DescriptorIDs {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Lease != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Lease.Size()))
		n25, err := m.Lease.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Details != nil {
		nn26, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn26
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if len(m.ResumeErrors) > 0 {
		for _, msg := range m.ResumeErrors {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CleanupErrors) > 0 {
		for _, msg := range m.CleanupErrors {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FinalResumeError != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FinalResumeError.Size()))
		n27, err := m.FinalResumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Noncancelable {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Noncancelable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Payload_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n28, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *Payload_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n29, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *Payload_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n30, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *Payload_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n31, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *Payload_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n32, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *Payload_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n33, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *Progress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Progress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Progress != nil {
		nn34, err := m.Progress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn34
	}
	if m.ModifiedMicros != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ModifiedMicros))
	}
	if len(m.RunningStatus) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.RunningStatus)))
		i += copy(dAtA[i:], m.RunningStatus)
	}
	if m.Details != nil {
		nn35, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	return i, nil
}

func (m *Progress_FractionCompleted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FractionCompleted))))
	i += 4
	return i, nil
}
func (m *Progress_HighWater) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HighWater != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.HighWater.Size()))
		n36, err := m.HighWater.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}
func (m *Progress_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n37, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}
func (m *Progress_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n38, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *Progress_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n39, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *Progress_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n40, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *Progress_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n41, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}
func (m *Progress_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n42, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}
func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Id))
	}
	if m.Progress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Progress.Size()))
		n43, err := m.Progress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Payload != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Payload.Size()))
		n44, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func encodeVarintJobs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovJobs(uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		n += 1 + sovJobs(uint64(m.Epoch))
	}
	return n
}

func (m *BackupDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.BackupManifest)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.URIsByLocalityKV) > 0 {
		for k, v := range m.URIsByLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *BackupProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RestoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableRewrites) > 0 {
		for k, v := range m.TableRewrites {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJobs(uint64(l))
			}
			mapEntrySize := 1 + sovJobs(uint64(k)) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.TableDescs) > 0 {
		for _, e := range m.TableDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.OverrideDB)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.BackupLocalityInfo) > 0 {
		for _, e := range m.BackupLocalityInfo {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.PrepareCompleted {
		n += 2
	}
	if m.StatsInserted {
		n += 2
	}
	if m.TablesPublished {
		n += 2
	}
	if m.DescriptorCoverage != 0 {
		n += 1 + sovJobs(uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *RestoreDetails_TableRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovJobs(uint64(m.TableID))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	return n
}

func (m *RestoreDetails_BackupLocalityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.URIsByOriginalLocalityKV) > 0 {
		for k, v := range m.URIsByOriginalLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RestoreProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HighWater)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ImportDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.SSTSize != 0 {
		n += 1 + sovJobs(uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		n += 1 + sovJobs(uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	l = len(m.BackupPath)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			l = len(b)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.Oversample != 0 {
		n += 1 + sovJobs(uint64(m.Oversample))
	}
	if m.SkipFKs {
		n += 2
	}
	if m.IngestDirectly {
		n += 2
	}
	if m.PrepareComplete {
		n += 2
	}
	if m.TablesPublished {
		n += 2
	}
	if m.ProtectedTimestampRecord != nil {
		l = m.ProtectedTimestampRecord.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ImportDetails_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.SeqVal != 0 {
		n += 2 + sovJobs(uint64(m.SeqVal))
	}
	if m.IsNew {
		n += 3
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ImportProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.SamplingProgress)*4)) + len(m.SamplingProgress)*4
	}
	if len(m.ReadProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.ReadProgress)*4)) + len(m.ReadProgress)*4
	}
	if len(m.WriteProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.WriteProgress)*4)) + len(m.WriteProgress)*4
	}
	if len(m.SpanProgress) > 0 {
		for _, e := range m.SpanProgress {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.ResumePos) > 0 {
		l = 0
		for _, e := range m.ResumePos {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	return n
}

func (m *ResumeSpanList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, e := range m.ResumeSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *DroppedTableDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, e := range m.ResumeSpanList {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, e := range m.DroppedTables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.DroppedDatabaseID != 0 {
		n += 1 + sovJobs(uint64(m.DroppedDatabaseID))
	}
	if m.TableID != 0 {
		n += 1 + sovJobs(uint64(m.TableID))
	}
	if m.MutationID != 0 {
		n += 1 + sovJobs(uint64(m.MutationID))
	}
	return n
}

func (m *SchemaChangeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChangefeedTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StatementTimeName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ChangefeedDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SinkURI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Opts) > 0 {
		for k, v := range m.Opts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.Targets) > 0 {
		for k, v := range m.Targets {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovJobs(uint64(k)) + 1 + l + sovJobs(uint64(l))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	l = m.StatementTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	return n
}

func (m *ResolvedSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.BoundaryReached {
		n += 2
	}
	return n
}

func (m *ChangefeedProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *CreateStatsDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = m.Table.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.ColumnStats) > 0 {
		for _, e := range m.ColumnStats {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.AsOf != nil {
		l = m.AsOf.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.FQTableName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.MaxFractionIdle != 0 {
		n += 9
	}
	return n
}

func (m *CreateStatsDetails_ColStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	if m.HasHistogram {
		n += 2
	}
	return n
}

func (m *CreateStatsProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.StartedMicros != 0 {
		n += 1 + sovJobs(uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		n += 1 + sovJobs(uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		l = 0
		for _, e := range m.DescriptorIDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	l = len(m.Statement)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if len(m.ResumeErrors) > 0 {
		for _, e := range m.ResumeErrors {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if len(m.CleanupErrors) > 0 {
		for _, e := range m.CleanupErrors {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if m.FinalResumeError != nil {
		l = m.FinalResumeError.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.Noncancelable {
		n += 3
	}
	return n
}

func (m *Payload_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Progress != nil {
		n += m.Progress.Size()
	}
	if m.ModifiedMicros != 0 {
		n += 1 + sovJobs(uint64(m.ModifiedMicros))
	}
	l = len(m.RunningStatus)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	return n
}

func (m *Progress_FractionCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Progress_HighWater) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HighWater != nil {
		l = m.HighWater.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovJobs(uint64(m.Id))
	}
	if m.Progress != nil {
		l = m.Progress.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func sovJobs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozJobs(x uint64) (n int) {
	return sovJobs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupManifest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupManifest = append(m.BackupManifest[:0], dAtA[iNdEx:postIndex]...)
			if m.BackupManifest == nil {
				m.BackupManifest = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByLocalityKV == nil {
				m.URIsByLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRewrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableRewrites == nil {
				m.TableRewrites = make(map[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID]*RestoreDetails_TableRewrite)
			}
			var mapkey uint32
			var mapvalue *RestoreDetails_TableRewrite
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RestoreDetails_TableRewrite{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableRewrites[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDescs = append(m.TableDescs, &sqlbase.TableDescriptor{})
			if err := m.TableDescs[len(m.TableDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideDB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideDB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupLocalityInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupLocalityInfo = append(m.BackupLocalityInfo, RestoreDetails_BackupLocalityInfo{})
			if err := m.BackupLocalityInfo[len(m.BackupLocalityInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareCompleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareCompleted = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsInserted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsInserted = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TablesPublished = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorCoverage", wireType)
			}
			m.DescriptorCoverage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorCoverage |= (github_com_cockroachdb_cockroach_pkg_sql_sem_tree.DescriptorCoverage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails_TableRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails_BackupLocalityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupLocalityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupLocalityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByOriginalLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByOriginalLocalityKV == nil {
				m.URIsByOriginalLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByOriginalLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighWater = append(m.HighWater[:0], dAtA[iNdEx:postIndex]...)
			if m.HighWater == nil {
				m.HighWater = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, ImportDetails_Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTSize", wireType)
			}
			m.SSTSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSTSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Walltime", wireType)
			}
			m.Walltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Walltime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, make([]byte, postIndex-iNdEx))
			copy(m.Samples[len(m.Samples)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oversample", wireType)
			}
			m.Oversample = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oversample |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipFKs = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestDirectly = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareComplete = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TablesPublished = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestampRecord", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.ProtectedTimestampRecord = &v
			if err := m.ProtectedTimestampRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails_Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &sqlbase.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqVal", wireType)
			}
			m.SeqVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqVal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNew = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SamplingProgress = append(m.SamplingProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.SamplingProgress) == 0 {
					m.SamplingProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SamplingProgress = append(m.SamplingProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingProgress", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.ReadProgress = append(m.ReadProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.ReadProgress) == 0 {
					m.ReadProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.ReadProgress = append(m.ReadProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadProgress", wireType)
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.WriteProgress = append(m.WriteProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.WriteProgress) == 0 {
					m.WriteProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.WriteProgress = append(m.WriteProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteProgress", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanProgress = append(m.SpanProgress, roachpb.Span{})
			if err := m.SpanProgress[len(m.SpanProgress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ResumePos = append(m.ResumePos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ResumePos) == 0 {
					m.ResumePos = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ResumePos = append(m.ResumePos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeSpanList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeSpanList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeSpanList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpans = append(m.ResumeSpans, roachpb.Span{})
			if err := m.ResumeSpans[len(m.ResumeSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DroppedTableDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedTableDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedTableDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpanList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpanList = append(m.ResumeSpanList, ResumeSpanList{})
			if err := m.ResumeSpanList[len(m.ResumeSpanList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedTables = append(m.DroppedTables, DroppedTableDetails{})
			if err := m.DroppedTables[len(m.DroppedTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedDatabaseID", wireType)
			}
			m.DroppedDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedDatabaseID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationID", wireType)
			}
			m.MutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MutationID |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTimeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementTimeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SinkURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opts == nil {
				m.Opts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Opts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Targets == nil {
				m.Targets = make(ChangefeedTargets)
			}
			var mapkey uint32
			mapvalue := &ChangefeedTarget{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChangefeedTarget{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Targets[github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StatementTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundaryReached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoundaryReached = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnStats = append(m.ColumnStats, CreateStatsDetails_ColStat{})
			if err := m.ColumnStats[len(m.ColumnStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsOf == nil {
				m.AsOf = &hlc.Timestamp{}
			}
			if err := m.AsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFractionIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFractionIdle = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails_ColStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasHistogram = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedMicros", wireType)
			}
			m.StartedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedMicros", wireType)
			}
			m.FinishedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DescriptorIDs = append(m.DescriptorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DescriptorIDs) == 0 {
					m.DescriptorIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_sqlbase.ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DescriptorIDs = append(m.DescriptorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorIDs", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &Lease{}
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_CreateStats{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeErrors = append(m.ResumeErrors, &errorspb.EncodedError{})
			if err := m.ResumeErrors[len(m.ResumeErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CleanupErrors = append(m.CleanupErrors, &errorspb.EncodedError{})
			if err := m.CleanupErrors[len(m.CleanupErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalResumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalResumeError == nil {
				m.FinalResumeError = &errorspb.EncodedError{}
			}
			if err := m.FinalResumeError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noncancelable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noncancelable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Progress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Progress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Progress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionCompleted", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = &Progress_FractionCompleted{float32(math.Float32frombits(v))}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMicros", wireType)
			}
			m.ModifiedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &hlc.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Progress = &Progress_HighWater{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_CreateStats{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = &Progress{}
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJobs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthJobs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipJobs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthJobs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJobs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("jobs/jobspb/jobs.proto", fileDescriptor_jobs_73f32b5a5a4957b4) }

var fileDescriptor_jobs_73f32b5a5a4957b4 = []byte{
	// 3107 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x73, 0x23, 0xc7,
	0x75, 0x27, 0x80, 0x01, 0x30, 0x78, 0x20, 0xc0, 0x61, 0x93, 0xbb, 0x82, 0x50, 0x2b, 0x02, 0x81,
	0x3e, 0x96, 0xbb, 0x8a, 0xc0, 0x64, 0x55, 0x91, 0x22, 0x45, 0x51, 0x42, 0x7c, 0x70, 0x09, 0xec,
	0xf2, 0x43, 0x4d, 0x72, 0x95, 0x28, 0x95, 0x4c, 0x06, 0x98, 0x26, 0x39, 0xe1, 0x60, 0x66, 0x76,
	0x7a, 0xb0, 0x2b, 0xaa, 0x52, 0x95, 0x8a, 0x7d, 0x51, 0xed, 0xc9, 0xae, 0xf2, 0xc5, 0x65, 0x6d,
	0x95, 0xaa, 0x6c, 0x57, 0xf9, 0xe2, 0x92, 0xca, 0x27, 0xff, 0x09, 0xba, 0x59, 0x47, 0xd9, 0x07,
	0xd8, 0x86, 0x2e, 0x3e, 0xe8, 0x2f, 0xd8, 0x93, 0xab, 0x3f, 0x66, 0x30, 0xe0, 0x52, 0xfc, 0x58,
	0xd9, 0x17, 0x72, 0xfa, 0xf5, 0x7b, 0xaf, 0xbb, 0x5f, 0xbf, 0xf7, 0x7b, 0xef, 0x35, 0xe0, 0xea,
	0xff, 0xb8, 0x3d, 0xba, 0xc2, 0xfe, 0x78, 0x3d, 0xfe, 0xaf, 0xee, 0xf9, 0x6e, 0xe0, 0xa2, 0xe7,
	0xfb, 0x6e, 0xff, 0xc8, 0x77, 0x8d, 0xfe, 0x61, 0x9d, 0xde, 0xb7, 0xeb, 0x7c, 0x46, 0x70, 0x95,
	0xaf, 0x10, 0xdf, 0x77, 0x7d, 0xc6, 0x2f, 0x3e, 0x84, 0x44, 0x79, 0xf1, 0xc0, 0x3d, 0x70, 0xf9,
	0xe7, 0x0a, 0xfb, 0x92, 0xd4, 0x79, 0xae, 0xc3, 0xeb, 0xad, 0x18, 0x9e, 0x25, 0x49, 0x28, 0x24,
	0x99, 0x46, 0x60, 0x48, 0x5a, 0x29, 0xa4, 0x59, 0xee, 0x6b, 0xfb, 0xae, 0x3f, 0x30, 0x82, 0x50,
	0xed, 0x35, 0x7a, 0xdf, 0x5e, 0xa1, 0xf7, 0xed, 0x9e, 0x41, 0xc9, 0x0a, 0x0d, 0xfc, 0x61, 0x3f,
	0x18, 0xfa, 0xc4, 0x0c, 0xe5, 0x86, 0x81, 0x65, 0xaf, 0x1c, 0xda, 0xfd, 0x95, 0xc0, 0x1a, 0x10,
	0x1a, 0x18, 0x03, 0x4f, 0xcc, 0xd4, 0xfe, 0x0f, 0xd2, 0x77, 0x89, 0x41, 0x09, 0xfa, 0x00, 0xb2,
	0x8e, 0x6b, 0x12, 0xdd, 0x32, 0x4b, 0x89, 0x6a, 0x62, 0xb9, 0xd0, 0x58, 0x1d, 0x8f, 0x2a, 0x99,
	0x4d, 0xd7, 0x24, 0x9d, 0xd6, 0x93, 0x51, 0xe5, 0xf5, 0x03, 0x2b, 0x38, 0x1c, 0xf6, 0xea, 0x7d,
	0x77, 0xb0, 0x12, 0x9d, 0xd9, 0xec, 0x4d, 0xbe, 0x57, 0xbc, 0xa3, 0x83, 0x15, 0xb9, 0xbd, 0xba,
	0x10, 0xc3, 0x19, 0xa6, 0xb1, 0x63, 0xa2, 0x45, 0x48, 0x13, 0xcf, 0xed, 0x1f, 0x96, 0x92, 0xd5,
	0xc4, 0x72, 0x0a, 0x8b, 0xc1, 0xdb, 0xca, 0x9f, 0x3e, 0xad, 0x24, 0x6a, 0xdf, 0xa4, 0xa0, 0xd0,
	0x30, 0xfa, 0x47, 0x43, 0xaf, 0x45, 0x02, 0xc3, 0xb2, 0x29, 0x6a, 0x00, 0xd0, 0xc0, 0xf0, 0x03,
	0x9d, 0xed, 0x95, 0x6f, 0x26, 0x7f, 0xeb, 0x85, 0xfa, 0xc4, 0xd0, 0xec, 0x2c, 0xf5, 0x43, 0xbb,
	0x5f, 0xdf, 0x0d, 0xcf, 0xd2, 0x50, 0xbe, 0x18, 0x55, 0x66, 0x70, 0x8e, 0x8b, 0x31, 0x2a, 0x7a,
	0x17, 0x54, 0xe2, 0x98, 0x42, 0x43, 0xf2, 0xe2, 0x1a, 0xb2, 0xc4, 0x31, 0xb9, 0xfc, 0xf3, 0x90,
	0x1a, 0xfa, 0x56, 0x29, 0x55, 0x4d, 0x2c, 0xe7, 0x1a, 0xd9, 0xf1, 0xa8, 0x92, 0xda, 0xc3, 0x1d,
	0xcc, 0x68, 0xe8, 0x3a, 0xcc, 0xf5, 0xf8, 0x7e, 0xf5, 0x81, 0xe1, 0x58, 0xfb, 0x84, 0x06, 0x25,
	0xa5, 0x9a, 0x58, 0x9e, 0xc5, 0x45, 0x41, 0xde, 0x90, 0x54, 0xf4, 0xfd, 0x04, 0x2c, 0x0c, 0x7d,
	0x8b, 0xea, 0xbd, 0x63, 0xdd, 0x76, 0xfb, 0x86, 0x6d, 0x05, 0xc7, 0xfa, 0xd1, 0x83, 0x52, 0xba,
	0x9a, 0x5a, 0xce, 0xdf, 0x7a, 0xb7, 0xfe, 0xad, 0xae, 0x53, 0x9f, 0xb2, 0x47, 0x7d, 0xcf, 0xb7,
	0x68, 0xe3, 0xf8, 0xae, 0xd4, 0x70, 0xe7, 0x41, 0xdb, 0x09, 0xfc, 0xe3, 0xc6, 0xe2, 0x78, 0x54,
	0xd1, 0xf6, 0x70, 0x27, 0x3e, 0x75, 0x0f, 0x6b, 0xc3, 0x13, 0xcc, 0x68, 0x1d, 0x80, 0x38, 0x7d,
	0xff, 0xd8, 0x0b, 0x2c, 0xd7, 0x29, 0x65, 0xb8, 0x2d, 0x96, 0x63, 0x6b, 0x87, 0x57, 0xb6, 0x66,
	0xd9, 0xa4, 0x1d, 0x31, 0x6e, 0xf1, 0xbf, 0x14, 0xc7, 0x64, 0xcb, 0x4d, 0xb8, 0x72, 0xea, 0x56,
	0x90, 0x06, 0xa9, 0x23, 0x72, 0xcc, 0x6f, 0x2a, 0x87, 0xd9, 0x27, 0xbb, 0xf0, 0x07, 0x86, 0x3d,
	0x14, 0xb6, 0xcf, 0x61, 0x31, 0x78, 0x3b, 0xf9, 0x8f, 0x89, 0x9a, 0x06, 0x45, 0x71, 0xba, 0x6d,
	0xdf, 0x3d, 0xf0, 0x09, 0xa5, 0xb5, 0x5f, 0xe5, 0xa1, 0x88, 0x09, 0x0d, 0x5c, 0x9f, 0x84, 0x1e,
	0xf0, 0x49, 0x02, 0x8a, 0x81, 0xd1, 0xb3, 0x89, 0xee, 0x93, 0x87, 0xbe, 0x15, 0x10, 0x5a, 0x4a,
	0x72, 0xa3, 0xbd, 0x73, 0x86, 0xd1, 0xa6, 0x75, 0xd4, 0x77, 0x99, 0x3c, 0x96, 0xe2, 0xc2, 0x64,
	0x6f, 0x7e, 0xef, 0xf7, 0x17, 0xf4, 0xe3, 0x58, 0x30, 0xd5, 0x3b, 0x2d, 0x5c, 0x08, 0xe2, 0xca,
	0xd0, 0x35, 0x50, 0x98, 0x99, 0x4b, 0xa9, 0x6a, 0x6a, 0x39, 0xd7, 0x50, 0xc7, 0xa3, 0x8a, 0xc2,
	0x2e, 0x02, 0x73, 0xea, 0x94, 0xeb, 0x29, 0xcf, 0xe0, 0x7a, 0xb7, 0x21, 0x2f, 0xce, 0x6e, 0x12,
	0xda, 0xa7, 0xd2, 0x5b, 0x5e, 0x39, 0x71, 0xf0, 0x70, 0x73, 0xfc, 0x94, 0x2d, 0x42, 0xfb, 0xbe,
	0xe5, 0x05, 0xae, 0x8f, 0x21, 0x08, 0x09, 0x14, 0xad, 0x40, 0xde, 0x7d, 0x40, 0x7c, 0xdf, 0x32,
	0x89, 0x6e, 0xf6, 0xf8, 0xd5, 0xe7, 0x1a, 0xc5, 0xf1, 0xa8, 0x02, 0x5b, 0x92, 0xdc, 0x6a, 0x60,
	0x08, 0x59, 0x5a, 0x3d, 0x14, 0xc0, 0xa2, 0xf4, 0xec, 0xc8, 0x5d, 0x2d, 0x67, 0xdf, 0x2d, 0x65,
	0x2f, 0x6b, 0x7b, 0x71, 0xc3, 0xa1, 0x9b, 0x74, 0x9c, 0x7d, 0x57, 0x1e, 0x12, 0xf5, 0x9e, 0x9a,
	0x41, 0xaf, 0xc2, 0xbc, 0xe7, 0x13, 0xcf, 0xf0, 0x89, 0xde, 0x77, 0x07, 0x9e, 0x4d, 0x02, 0x62,
	0x96, 0xd4, 0x6a, 0x62, 0x59, 0xc5, 0x9a, 0x9c, 0x68, 0x86, 0x74, 0xf4, 0x32, 0x14, 0x69, 0x60,
	0x04, 0x54, 0xb7, 0x1c, 0x4a, 0x7c, 0xc6, 0x99, 0xe3, 0x9c, 0x05, 0x4e, 0xed, 0x48, 0x22, 0xba,
	0x01, 0x1a, 0x37, 0x04, 0xd5, 0xbd, 0x61, 0xcf, 0xb6, 0xe8, 0x21, 0x31, 0x4b, 0xc0, 0x19, 0xe7,
	0x04, 0x7d, 0x3b, 0x24, 0xa3, 0x63, 0x58, 0x30, 0x23, 0xfb, 0xe9, 0x7d, 0x66, 0x0e, 0xe3, 0x80,
	0x94, 0xf2, 0xd5, 0xc4, 0x72, 0xba, 0xb1, 0xfe, 0x64, 0x54, 0x69, 0x5d, 0xdc, 0x63, 0xc8, 0x60,
	0x25, 0xf0, 0x09, 0xa9, 0x4f, 0x2e, 0xa4, 0x29, 0xf5, 0x61, 0x64, 0x3e, 0x45, 0x3b, 0x11, 0x9a,
	0xb3, 0xdf, 0x21, 0x34, 0x7f, 0x93, 0x80, 0xd9, 0xb8, 0xc3, 0xa3, 0xff, 0x04, 0x55, 0x38, 0x51,
	0x04, 0xe7, 0x8d, 0xf1, 0xa8, 0x92, 0xe5, 0x3c, 0x97, 0xc0, 0xf3, 0x13, 0x71, 0x90, 0xe5, 0x3a,
	0x3b, 0x26, 0xfa, 0x6f, 0xc8, 0xb1, 0x7b, 0x71, 0x02, 0xa6, 0x3f, 0xc9, 0xf5, 0x37, 0xc7, 0xa3,
	0x8a, 0xba, 0xcd, 0x89, 0xcf, 0xbe, 0x80, 0x2a, 0xb4, 0x76, 0xcc, 0xf2, 0x27, 0x49, 0x40, 0x4f,
	0xbb, 0x11, 0xfa, 0x75, 0x02, 0xae, 0x85, 0x98, 0xea, 0xfa, 0xd6, 0x81, 0xe5, 0x18, 0xf6, 0x14,
	0xb8, 0x26, 0xb8, 0xaf, 0x7e, 0xf0, 0x5d, 0x7c, 0x55, 0x02, 0xee, 0x96, 0x54, 0x7f, 0x12, 0x78,
	0xaf, 0x8d, 0x47, 0x95, 0x92, 0x00, 0xde, 0xa7, 0x58, 0xee, 0xe1, 0xd2, 0xf0, 0x5b, 0x84, 0xcb,
	0x77, 0xe0, 0x85, 0x33, 0x15, 0x5f, 0x06, 0x46, 0xcb, 0x1f, 0x02, 0x7a, 0x1a, 0xe0, 0xe2, 0x1a,
	0x0a, 0x42, 0xc3, 0xdd, 0xb8, 0x86, 0xfc, 0xad, 0x37, 0x9e, 0x0d, 0x3f, 0x63, 0x2b, 0x77, 0x15,
	0x35, 0xa1, 0x25, 0x6b, 0x7f, 0x07, 0x73, 0x92, 0x3f, 0xc4, 0x71, 0xf4, 0x02, 0xc0, 0xa1, 0x75,
	0x70, 0xa8, 0x3f, 0x34, 0x02, 0xe2, 0xf3, 0x3d, 0xcc, 0xe2, 0x1c, 0xa3, 0xbc, 0xcf, 0x08, 0xb5,
	0xff, 0x57, 0xa1, 0xd0, 0x19, 0x78, 0xae, 0x1f, 0x84, 0x28, 0x7f, 0x17, 0x32, 0x22, 0x18, 0xe5,
	0xa5, 0xd5, 0xcf, 0xd8, 0xdc, 0x94, 0xa4, 0xd8, 0x9b, 0x84, 0x14, 0xa9, 0x23, 0x02, 0xe5, 0xe4,
	0xa9, 0xa0, 0xfc, 0xcf, 0x90, 0x11, 0xf5, 0x12, 0x4f, 0xe9, 0xf9, 0x5b, 0x95, 0x53, 0xc2, 0xac,
	0xb3, 0xc5, 0x02, 0x6d, 0x8d, 0xb3, 0x85, 0xca, 0x85, 0x10, 0x7a, 0x05, 0x54, 0x4a, 0x03, 0x9d,
	0x5a, 0x1f, 0x09, 0x4c, 0x4f, 0x35, 0xf2, 0x2c, 0x9c, 0x76, 0x76, 0x76, 0x77, 0xac, 0x8f, 0x08,
	0xce, 0x52, 0x1a, 0xb0, 0x0f, 0x54, 0x06, 0xf5, 0xa1, 0x61, 0xdb, 0x1c, 0xfb, 0xd3, 0xbc, 0xd6,
	0x89, 0xc6, 0xd3, 0x31, 0x93, 0xf9, 0x2b, 0xc4, 0x0c, 0xaa, 0x40, 0x5e, 0xe2, 0xb7, 0x67, 0x04,
	0x87, 0xa5, 0x2c, 0x77, 0x1a, 0x10, 0xa4, 0x6d, 0x23, 0x38, 0x44, 0x25, 0xc8, 0x52, 0x83, 0x41,
	0x29, 0x2d, 0xa9, 0xd5, 0xd4, 0xf2, 0x2c, 0x0e, 0x87, 0x68, 0x09, 0x78, 0x22, 0x10, 0x43, 0x8e,
	0xa9, 0x29, 0x1c, 0xa3, 0x70, 0x03, 0x1c, 0x59, 0x9e, 0xbe, 0x7f, 0x44, 0x05, 0x90, 0x4a, 0x03,
	0x1c, 0x59, 0xde, 0xda, 0x1d, 0x8a, 0xb3, 0x6c, 0x72, 0xed, 0x88, 0xb2, 0xe2, 0xc8, 0x72, 0x0e,
	0x08, 0x0d, 0x74, 0xd3, 0xf2, 0x49, 0x3f, 0xb0, 0x8f, 0x39, 0x92, 0xaa, 0xb8, 0x28, 0xc8, 0x2d,
	0x49, 0x65, 0x08, 0x7d, 0x12, 0xf5, 0x39, 0x02, 0xaa, 0x78, 0xee, 0x04, 0xe8, 0x9f, 0x0a, 0xe6,
	0x85, 0xd3, 0xc1, 0xfc, 0x87, 0x09, 0x28, 0xb3, 0xba, 0x96, 0xf4, 0x03, 0x22, 0x52, 0x30, 0x4f,
	0xb1, 0xba, 0x4f, 0xfa, 0xae, 0x6f, 0x96, 0xae, 0x32, 0xa7, 0x6c, 0xec, 0xfc, 0xee, 0xa2, 0x96,
	0xe6, 0x55, 0xf3, 0x70, 0x68, 0x99, 0xf5, 0xbd, 0xbd, 0x4e, 0x8b, 0xc5, 0xfd, 0x76, 0xa8, 0x3c,
	0x4a, 0xdf, 0x98, 0xab, 0xc6, 0x25, 0xef, 0x5b, 0x66, 0xca, 0x1f, 0x27, 0x21, 0xcd, 0x1d, 0x16,
	0xbd, 0x0d, 0x0a, 0xcb, 0x02, 0xb2, 0xa4, 0xbd, 0x68, 0x4a, 0xe7, 0x32, 0x08, 0x81, 0xe2, 0x18,
	0x03, 0x52, 0x42, 0xfc, 0x52, 0xf9, 0x37, 0x7a, 0x0e, 0xb2, 0x94, 0xdc, 0xd7, 0x1f, 0x18, 0x76,
	0x69, 0x81, 0xdf, 0x58, 0x86, 0x92, 0xfb, 0xf7, 0x0c, 0x1b, 0x5d, 0x81, 0x8c, 0x45, 0x75, 0x87,
	0x3c, 0x2c, 0x2d, 0x72, 0x3b, 0xa5, 0x2d, 0xba, 0x49, 0x1e, 0x32, 0xff, 0x08, 0x0c, 0xff, 0x80,
	0x04, 0x7a, 0xdf, 0xb5, 0x69, 0xe9, 0x0a, 0x8b, 0x14, 0x56, 0x31, 0x30, 0x52, 0xd3, 0xb5, 0x69,
	0x57, 0x51, 0x93, 0x5a, 0xaa, 0xab, 0xa8, 0x29, 0x4d, 0xe9, 0x2a, 0xaa, 0xa2, 0xa5, 0xbb, 0x8a,
	0x9a, 0xd6, 0x32, 0x5d, 0x45, 0xcd, 0x68, 0xd9, 0xae, 0xa2, 0x66, 0x35, 0xb5, 0xab, 0xa8, 0xaa,
	0x96, 0xeb, 0x2a, 0x6a, 0x4e, 0x83, 0xae, 0xa2, 0x82, 0x96, 0xef, 0x2a, 0x6a, 0x5e, 0x9b, 0xed,
	0x2a, 0xea, 0xac, 0x56, 0xe8, 0x2a, 0x6a, 0x41, 0x2b, 0x76, 0x15, 0xb5, 0xa8, 0xcd, 0x75, 0x15,
	0x75, 0x4e, 0xd3, 0xba, 0x8a, 0xaa, 0x69, 0xf3, 0x5d, 0x45, 0x9d, 0xd7, 0x50, 0xed, 0x9b, 0x04,
	0x14, 0x45, 0x24, 0x47, 0xa8, 0xf1, 0x2a, 0xcc, 0x73, 0x17, 0xb3, 0x9c, 0x03, 0xdd, 0x93, 0x44,
	0x8e, 0x07, 0x49, 0xac, 0x85, 0x13, 0x11, 0xf3, 0x8b, 0x50, 0xf0, 0x89, 0x61, 0x4e, 0x18, 0x93,
	0x9c, 0x71, 0x96, 0x11, 0x23, 0xa6, 0x97, 0xa1, 0xc8, 0x41, 0x6b, 0xc2, 0x95, 0xe2, 0x5c, 0x05,
	0x4e, 0x8d, 0xd8, 0x1a, 0x50, 0xa0, 0x9e, 0xe1, 0x4c, 0xb8, 0x14, 0x0e, 0x42, 0xcf, 0x9d, 0x02,
	0x0c, 0x3b, 0x9e, 0xe1, 0x48, 0x40, 0x98, 0x65, 0x32, 0x71, 0xc8, 0xf3, 0x09, 0x1d, 0x0e, 0x88,
	0xee, 0xb9, 0xa2, 0x52, 0x4b, 0xe1, 0x9c, 0xa0, 0x6c, 0xbb, 0xb4, 0x86, 0x79, 0x61, 0x3b, 0x1c,
	0x10, 0xa6, 0xe0, 0xae, 0x45, 0x03, 0xf4, 0xaf, 0x30, 0x2b, 0x05, 0x98, 0x9e, 0x10, 0xf8, 0xce,
	0x59, 0x33, 0xef, 0x47, 0x4a, 0x68, 0xed, 0x97, 0x09, 0x58, 0x68, 0xf9, 0xae, 0xe7, 0x11, 0x53,
	0x3a, 0x8a, 0x00, 0xd3, 0xd0, 0x3f, 0x12, 0x31, 0xff, 0xb8, 0x0d, 0xc9, 0x4e, 0x4b, 0xa6, 0xe7,
	0x37, 0x9f, 0x15, 0x5e, 0x92, 0x9d, 0x16, 0x7a, 0x0b, 0x32, 0xac, 0xbe, 0x1a, 0x52, 0x8e, 0x9e,
	0xc5, 0x5b, 0x7f, 0x73, 0x06, 0x52, 0xef, 0x70, 0x46, 0x2c, 0x05, 0x6a, 0x9f, 0x2a, 0xb0, 0xb0,
	0xd3, 0x3f, 0x24, 0x03, 0xa3, 0x79, 0x68, 0x38, 0x07, 0xd1, 0x7e, 0xff, 0x1d, 0xb4, 0x98, 0x25,
	0x74, 0xdb, 0xa2, 0x81, 0xac, 0xf1, 0x6f, 0x9c, 0x9d, 0xa3, 0x62, 0xe6, 0x94, 0xf6, 0x29, 0xfa,
	0xd3, 0x46, 0xfe, 0x0f, 0x28, 0x9a, 0xc2, 0x42, 0xba, 0xcc, 0x2f, 0xa9, 0x73, 0xf3, 0xcb, 0x29,
	0x26, 0x95, 0xda, 0x0b, 0x66, 0x6c, 0x8a, 0xa2, 0xff, 0x85, 0x85, 0x50, 0x39, 0xeb, 0xcb, 0x99,
	0x95, 0x18, 0x9e, 0x2b, 0xdc, 0xc8, 0x77, 0xc7, 0xa3, 0xca, 0xbc, 0x54, 0xd5, 0x92, 0xb3, 0xcf,
	0x0e, 0xec, 0xf3, 0xe6, 0x09, 0x4d, 0xe6, 0x54, 0x59, 0x97, 0xfe, 0xcb, 0x97, 0x75, 0x0e, 0xe4,
	0x07, 0xc3, 0xc0, 0x60, 0x25, 0xe5, 0x24, 0x49, 0x6d, 0xb0, 0x8e, 0x61, 0x43, 0x92, 0xf9, 0x22,
	0xff, 0x74, 0xe9, 0x45, 0x26, 0xe2, 0x18, 0xc2, 0x15, 0x3a, 0xa6, 0xac, 0x25, 0xae, 0xc2, 0x62,
	0xdc, 0x43, 0xa2, 0xc6, 0xb0, 0x01, 0x9a, 0xa0, 0xec, 0x13, 0x66, 0x7e, 0x86, 0x52, 0xa8, 0x0e,
	0x0b, 0xcc, 0xb1, 0xc8, 0x80, 0xe5, 0x51, 0x86, 0xef, 0x7a, 0xcc, 0xeb, 0xe7, 0xa3, 0x29, 0x86,
	0xc1, 0x9b, 0xc6, 0x80, 0xd4, 0x3e, 0x53, 0x60, 0x7e, 0xa2, 0x24, 0x74, 0x3e, 0x96, 0xcd, 0x2c,
	0xe7, 0x48, 0x9f, 0xb4, 0xf8, 0x22, 0x9b, 0x59, 0xce, 0x11, 0x6b, 0xf3, 0xb3, 0x6c, 0x72, 0xcf,
	0xb7, 0x50, 0x17, 0x14, 0xd7, 0x0b, 0x42, 0x68, 0x38, 0xab, 0x78, 0x7a, 0x6a, 0x8d, 0xfa, 0x96,
	0x17, 0x88, 0xaa, 0x0c, 0x73, 0x1d, 0xe8, 0xe7, 0x09, 0xc8, 0x0a, 0xa8, 0xa5, 0xa5, 0x0c, 0xd7,
	0xf7, 0xd6, 0xa5, 0xf4, 0x09, 0x03, 0xc8, 0x4e, 0x76, 0x9b, 0xb9, 0xe6, 0x93, 0x51, 0x65, 0xfe,
	0xa4, 0x81, 0xe8, 0xb3, 0xb6, 0xb8, 0xe1, 0xde, 0x50, 0x57, 0x74, 0x58, 0x13, 0x0b, 0xf3, 0x3a,
	0xe2, 0x82, 0x4d, 0x6c, 0x61, 0xea, 0x06, 0xca, 0x07, 0xac, 0x2b, 0x99, 0x6c, 0xfb, 0x94, 0xfa,
	0x74, 0x75, 0xba, 0x3e, 0x7d, 0xf5, 0x42, 0x26, 0x11, 0x3a, 0xe3, 0xe5, 0xf0, 0x9b, 0x90, 0x8b,
	0xec, 0x7d, 0x99, 0x3a, 0x5a, 0x78, 0x60, 0x94, 0xf7, 0xd2, 0x5a, 0xa6, 0xf6, 0x59, 0x02, 0x66,
	0x31, 0xa1, 0xae, 0xfd, 0x80, 0x98, 0x0c, 0x52, 0xd0, 0xdf, 0x83, 0xc2, 0x20, 0x4a, 0x66, 0xed,
	0x73, 0xb0, 0x9a, 0xb3, 0xa2, 0x55, 0xc8, 0x45, 0xb5, 0xc7, 0x65, 0x9e, 0x9f, 0x26, 0x52, 0xac,
	0xe8, 0xe9, 0xb9, 0x43, 0xc7, 0x34, 0xfc, 0x63, 0xdd, 0x27, 0x46, 0x9f, 0x15, 0x3d, 0x29, 0x51,
	0xf4, 0x84, 0x74, 0x2c, 0xc8, 0x35, 0x0f, 0xd0, 0xc4, 0x36, 0x51, 0x6e, 0xda, 0x05, 0x86, 0x8b,
	0xfc, 0x18, 0x32, 0xd9, 0x08, 0x78, 0xbd, 0x7e, 0x36, 0xbc, 0x46, 0xe7, 0x0e, 0x6f, 0xd4, 0x8f,
	0xd1, 0xa8, 0x8c, 0xd8, 0x9f, 0x28, 0x80, 0x9a, 0x3e, 0x31, 0x02, 0xc2, 0xd0, 0x9e, 0x9e, 0x95,
	0x83, 0x1a, 0x90, 0xe6, 0xe8, 0x22, 0xcd, 0x70, 0xc1, 0xa2, 0x47, 0x2e, 0x2e, 0x44, 0xd1, 0x7f,
	0xc1, 0x6c, 0xdf, 0xb5, 0x87, 0x03, 0x47, 0xe7, 0x5d, 0xbe, 0x84, 0xf3, 0x7f, 0x38, 0xcb, 0x57,
	0x9e, 0xda, 0x5c, 0xbd, 0xe9, 0xda, 0x6c, 0x1c, 0xe6, 0x54, 0xa1, 0x90, 0x73, 0xa0, 0x6b, 0x90,
	0x8b, 0xfc, 0x96, 0x23, 0x79, 0x0e, 0x4f, 0x08, 0xe8, 0x16, 0xa4, 0x0d, 0xaa, 0xbb, 0xfb, 0x1c,
	0x70, 0xcf, 0xbb, 0x48, 0xac, 0x18, 0x74, 0x6b, 0x1f, 0xbd, 0x0e, 0x85, 0xfd, 0xfb, 0x22, 0xfb,
	0x08, 0x80, 0x12, 0x8f, 0x2f, 0x73, 0xe3, 0x51, 0x25, 0xbf, 0xf6, 0x1e, 0x3f, 0x2c, 0x83, 0x27,
	0x9c, 0xdf, 0xbf, 0x1f, 0x0d, 0xd0, 0x4d, 0x98, 0x1f, 0x18, 0x1f, 0xea, 0xfb, 0xbe, 0xd1, 0x97,
	0x08, 0x6c, 0x8b, 0xe0, 0x4b, 0xe0, 0xb9, 0x81, 0xf1, 0xe1, 0x9a, 0xa4, 0x77, 0x4c, 0x9b, 0x94,
	0x7f, 0x9c, 0x80, 0xac, 0x3c, 0x11, 0xb2, 0x00, 0xa4, 0x79, 0x2c, 0x53, 0x94, 0x14, 0x85, 0x46,
	0x77, 0x3c, 0xaa, 0xe4, 0x9a, 0x9c, 0xda, 0x69, 0xd1, 0x27, 0xa3, 0xca, 0x5b, 0x97, 0x06, 0x85,
	0x50, 0x1a, 0xe7, 0x84, 0xf6, 0x8e, 0xc9, 0x0b, 0xb0, 0x43, 0x83, 0xea, 0x87, 0x16, 0x0d, 0xdc,
	0x03, 0xdf, 0x18, 0xf0, 0x5b, 0x55, 0xf1, 0xec, 0xa1, 0x41, 0xd7, 0x43, 0x5a, 0xed, 0x0a, 0x2c,
	0xc4, 0xec, 0x1f, 0xc1, 0xf9, 0x6f, 0x55, 0xc8, 0x6e, 0x1b, 0xc7, 0xb6, 0x6b, 0x98, 0xa8, 0x0a,
	0xf9, 0xf0, 0x3d, 0xc4, 0x72, 0x1d, 0xe9, 0x30, 0x71, 0x12, 0xeb, 0xa4, 0x86, 0x94, 0xf8, 0xdc,
	0x78, 0x22, 0x6a, 0xa3, 0xb1, 0x7c, 0x04, 0xf2, 0x59, 0x89, 0x3f, 0xb0, 0xfa, 0xbe, 0x2b, 0xca,
	0x92, 0x14, 0x47, 0x1f, 0x46, 0xdd, 0xe0, 0x44, 0xd6, 0x8b, 0xec, 0x5b, 0x0e, 0x6f, 0x0c, 0x42,
	0x3e, 0xde, 0xbb, 0xe1, 0x62, 0x48, 0x96, 0x8c, 0x2e, 0x14, 0x63, 0x4f, 0x40, 0xcc, 0x88, 0x19,
	0x6e, 0xc4, 0xf5, 0xf1, 0xa8, 0x52, 0x98, 0x38, 0xa5, 0x30, 0xe4, 0xb3, 0x3d, 0x20, 0x4e, 0xf4,
	0x33, 0x33, 0x2e, 0x42, 0x9a, 0xff, 0x26, 0xc0, 0x9f, 0xb9, 0x72, 0x58, 0x0c, 0xd0, 0x1b, 0x90,
	0xb6, 0x89, 0x41, 0x45, 0xfb, 0x95, 0xbf, 0x55, 0x3d, 0xc3, 0xbf, 0xf9, 0x93, 0x3d, 0x16, 0xec,
	0xa8, 0x01, 0x19, 0xd1, 0xe3, 0xf1, 0xce, 0x6c, 0xfa, 0x09, 0xe9, 0xcc, 0x97, 0xe5, 0xf5, 0x19,
	0x2c, 0x25, 0x51, 0x1b, 0xb2, 0xbe, 0xe8, 0xe7, 0x79, 0xbf, 0x76, 0x6e, 0x15, 0x16, 0x7b, 0x29,
	0x58, 0x9f, 0xc1, 0xa1, 0x2c, 0xda, 0x85, 0x59, 0x1a, 0x4b, 0xe5, 0xf2, 0x4d, 0xeb, 0xac, 0xc2,
	0xeb, 0x94, 0xda, 0x70, 0x9d, 0x95, 0xd9, 0x31, 0x32, 0x3b, 0xa0, 0xc5, 0xbb, 0x06, 0xde, 0xf6,
	0x9d, 0x7d, 0xc0, 0xa9, 0x87, 0x02, 0x76, 0x40, 0x21, 0x89, 0x36, 0x01, 0xfa, 0x11, 0x48, 0x96,
	0x8a, 0x5c, 0xcf, 0xdf, 0x5e, 0x26, 0x01, 0xaf, 0xcf, 0xe0, 0x98, 0x06, 0xf4, 0x1e, 0xe4, 0xfb,
	0x13, 0x27, 0x2f, 0xcd, 0x71, 0x85, 0xaf, 0x5d, 0x0a, 0x92, 0xd6, 0x19, 0x0c, 0x4d, 0xa8, 0xd3,
	0x30, 0xa4, 0x9d, 0x84, 0xa1, 0x36, 0xeb, 0x7d, 0x78, 0xc1, 0x2c, 0x7e, 0x4e, 0x2a, 0xcd, 0x73,
	0x14, 0x8c, 0x7b, 0x49, 0xf8, 0x83, 0x53, 0xbd, 0xed, 0xf4, 0x5d, 0x93, 0x98, 0x6d, 0x36, 0xc6,
	0xb2, 0xe3, 0xe0, 0x03, 0x8a, 0x6e, 0x43, 0xb1, 0x6f, 0x13, 0xc3, 0x19, 0x7a, 0xa1, 0x1e, 0x74,
	0x41, 0x3d, 0x05, 0x29, 0x27, 0x15, 0x6d, 0x02, 0xda, 0xe7, 0xaf, 0x6f, 0xf1, 0x5d, 0xf1, 0x3e,
	0xf4, 0x22, 0xca, 0x34, 0x2e, 0x8b, 0x27, 0x3b, 0x43, 0x2f, 0x41, 0xc1, 0x71, 0x9d, 0xbe, 0xe1,
	0xf4, 0x89, 0xcd, 0x13, 0x86, 0x68, 0x5d, 0xa7, 0x89, 0x8d, 0x1c, 0x64, 0x4d, 0x61, 0xbd, 0xa8,
	0x35, 0xcd, 0x6a, 0x6a, 0xed, 0xf3, 0x34, 0xa8, 0x51, 0xe6, 0x5b, 0x01, 0x14, 0x61, 0xe8, 0xe4,
	0x45, 0x99, 0x61, 0x4c, 0x72, 0x7d, 0x06, 0xcf, 0x87, 0x73, 0x93, 0x47, 0xe5, 0xeb, 0x30, 0x37,
	0x70, 0x4d, 0x6b, 0xdf, 0x9a, 0x00, 0x85, 0xf8, 0xa1, 0xaa, 0x18, 0x92, 0x25, 0x50, 0xbc, 0x3b,
	0xf5, 0xc4, 0x95, 0xba, 0x40, 0x3e, 0x58, 0x9f, 0x89, 0xbd, 0x81, 0x31, 0xe0, 0xf2, 0x87, 0x8e,
	0xc3, 0x7a, 0x5d, 0xd9, 0x4f, 0x89, 0x6c, 0x53, 0x90, 0x54, 0xd1, 0x3b, 0xa1, 0xe6, 0x89, 0x80,
	0xbe, 0x71, 0x6e, 0x40, 0x87, 0x67, 0x5f, 0x4f, 0x44, 0x11, 0xbd, 0x76, 0x32, 0xa2, 0x6f, 0x9e,
	0x1f, 0xd1, 0x31, 0x35, 0x51, 0x48, 0xef, 0x9d, 0x1a, 0xd2, 0x2b, 0x17, 0x0c, 0xe9, 0x98, 0xc6,
	0xe9, 0x98, 0x6e, 0x9e, 0x88, 0xe9, 0x1b, 0xe7, 0xc6, 0x74, 0xfc, 0x8c, 0x32, 0xa8, 0xb7, 0x4e,
	0x09, 0xea, 0xd7, 0x2e, 0x14, 0xd4, 0x31, 0x65, 0xf1, 0xa8, 0xc6, 0xa7, 0x45, 0x75, 0xfd, 0x62,
	0x51, 0x1d, 0x53, 0x19, 0x57, 0xd2, 0x00, 0x50, 0xc3, 0x37, 0x86, 0x98, 0xfb, 0xd6, 0x7e, 0x94,
	0x80, 0x54, 0xd7, 0xed, 0xa1, 0x22, 0x24, 0xe5, 0x1b, 0x7d, 0x0a, 0x27, 0x2d, 0x13, 0xfd, 0xcb,
	0x84, 0x5d, 0xd6, 0x4c, 0x2f, 0x9e, 0xb1, 0x7e, 0xb8, 0x28, 0x8e, 0x84, 0xd0, 0x3b, 0x90, 0xf5,
	0x44, 0x9a, 0x95, 0x1e, 0x5a, 0x3b, 0x4b, 0x5e, 0x70, 0xe2, 0x50, 0xe4, 0xe6, 0xbf, 0x41, 0x46,
	0x7a, 0x21, 0x82, 0x62, 0x0b, 0xaf, 0x76, 0x36, 0x3b, 0x9b, 0xb7, 0xf5, 0xcd, 0xd5, 0x8d, 0xf6,
	0x8e, 0x36, 0x83, 0x4a, 0xb0, 0xf8, 0xfe, 0x6a, 0x67, 0x57, 0x5f, 0xdb, 0xc2, 0xfa, 0xed, 0xa6,
	0xde, 0xd9, 0xdc, 0x6d, 0xe3, 0x7b, 0xab, 0x77, 0xb5, 0x04, 0xba, 0x0a, 0x08, 0x6f, 0x35, 0xef,
	0xec, 0xb4, 0x1a, 0x7a, 0x73, 0x6b, 0x63, 0x7b, 0xb5, 0xb9, 0xdb, 0xd9, 0xda, 0xd4, 0x92, 0x48,
	0x05, 0xa5, 0xb5, 0xb5, 0xd9, 0xd6, 0xe0, 0xe6, 0xe7, 0x49, 0x50, 0x76, 0x8f, 0x3d, 0x82, 0x5e,
	0x82, 0xfc, 0xde, 0xe6, 0xce, 0x76, 0xbb, 0xd9, 0x59, 0xeb, 0xb4, 0x5b, 0xda, 0x4c, 0x79, 0xe1,
	0xd1, 0xe3, 0xea, 0x1c, 0x9b, 0xda, 0x73, 0xa8, 0x47, 0xfa, 0x3c, 0xe2, 0x50, 0x19, 0x32, 0x8d,
	0xd5, 0xe6, 0x9d, 0xbd, 0x6d, 0x2d, 0x51, 0x2e, 0x3e, 0x7a, 0x5c, 0x05, 0xc6, 0x20, 0xbc, 0x1d,
	0x5d, 0x83, 0x2c, 0x6e, 0xef, 0xec, 0x6e, 0xe1, 0xb6, 0x96, 0x2c, 0xcf, 0x3d, 0x7a, 0x5c, 0xcd,
	0xb3, 0x49, 0xe9, 0xc4, 0xe8, 0x3a, 0x14, 0x76, 0x9a, 0xeb, 0xed, 0x8d, 0x55, 0xbd, 0xb9, 0xbe,
	0xba, 0x79, 0xbb, 0xad, 0xa5, 0xca, 0x8b, 0x8f, 0x1e, 0x57, 0x35, 0xc6, 0x13, 0xf7, 0x4d, 0xb6,
	0x44, 0x67, 0x63, 0x7b, 0x0b, 0xef, 0x6a, 0xca, 0x64, 0x09, 0xe1, 0x6c, 0xa8, 0x06, 0x20, 0xa4,
	0xd7, 0xda, 0xed, 0x96, 0x96, 0x2e, 0xa3, 0x47, 0x8f, 0xab, 0x45, 0x36, 0x3f, 0xf1, 0x21, 0xf4,
	0x32, 0xcc, 0x36, 0x71, 0x7b, 0x75, 0xb7, 0xad, 0xef, 0xec, 0xae, 0xee, 0xee, 0x68, 0x99, 0xc9,
	0x49, 0x62, 0x7e, 0x81, 0xea, 0x30, 0xbf, 0xba, 0xb7, 0xbb, 0xa5, 0x4f, 0xf1, 0x66, 0xcb, 0xcf,
	0x3d, 0x7a, 0x5c, 0x5d, 0x60, 0xbc, 0xab, 0xc3, 0xc0, 0x8d, 0xf1, 0x97, 0xd5, 0x8f, 0x7f, 0xba,
	0x34, 0xf3, 0x8b, 0x9f, 0x2d, 0xcd, 0x34, 0x96, 0xbf, 0xf8, 0xe3, 0xd2, 0xcc, 0x17, 0xe3, 0xa5,
	0xc4, 0x97, 0xe3, 0xa5, 0xc4, 0x57, 0xe3, 0xa5, 0xc4, 0x1f, 0xc6, 0x4b, 0x89, 0x1f, 0x7c, 0xbd,
	0x34, 0xf3, 0xe5, 0xd7, 0x4b, 0x33, 0x5f, 0x7d, 0xbd, 0x34, 0xf3, 0x41, 0x46, 0xdc, 0x63, 0x2f,
	0xc3, 0x7f, 0xcd, 0x7f, 0xfd, 0xcf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x70, 0xc2, 0x88, 0x79, 0xa8,
	0x20, 0x00, 0x00,
}
