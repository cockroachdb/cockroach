// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jobs/jobspb/jobs.proto

package jobspb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import errorspb "github.com/cockroachdb/errors/errorspb"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
import scpb "github.com/cockroachdb/cockroach/pkg/sql/schemachanger/scpb"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import github_com_cockroachdb_cockroach_pkg_ccl_streamingccl "github.com/cockroachdb/cockroach/pkg/ccl/streamingccl"
import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
import github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
import github_com_cockroachdb_cockroach_pkg_sql_sem_tree "github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
import github_com_cockroachdb_cockroach_pkg_security "github.com/cockroachdb/cockroach/pkg/security"

import bytes "bytes"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EncryptionMode int32

const (
	EncryptionMode_Passphrase EncryptionMode = 0
	EncryptionMode_KMS        EncryptionMode = 1
)

var EncryptionMode_name = map[int32]string{
	0: "Passphrase",
	1: "KMS",
}
var EncryptionMode_value = map[string]int32{
	"Passphrase": 0,
	"KMS":        1,
}

func (x EncryptionMode) String() string {
	return proto.EnumName(EncryptionMode_name, int32(x))
}
func (EncryptionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{0}
}

type Status int32

const (
	Status_DRAINING_NAMES       Status = 0
	Status_WAIT_FOR_GC_INTERVAL Status = 1
	Status_ROCKSDB_COMPACTION   Status = 2
	Status_DONE                 Status = 10
)

var Status_name = map[int32]string{
	0:  "DRAINING_NAMES",
	1:  "WAIT_FOR_GC_INTERVAL",
	2:  "ROCKSDB_COMPACTION",
	10: "DONE",
}
var Status_value = map[string]int32{
	"DRAINING_NAMES":       0,
	"WAIT_FOR_GC_INTERVAL": 1,
	"ROCKSDB_COMPACTION":   2,
	"DONE":                 10,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{1}
}

type Type int32

const (
	TypeUnspecified     Type = 0
	TypeBackup          Type = 1
	TypeRestore         Type = 2
	TypeSchemaChange    Type = 3
	TypeImport          Type = 4
	TypeChangefeed      Type = 5
	TypeCreateStats     Type = 6
	TypeAutoCreateStats Type = 7
	TypeSchemaChangeGC  Type = 8
	// We can't name this TYPE_SCHEMA_CHANGE due to how proto generates actual
	// names for this enum, which cause a conflict with the SCHEMA_CHANGE entry.
	TypeTypeSchemaChange Type = 9
	TypeStreamIngestion  Type = 10
	TypeNewSchemaChange  Type = 11
)

var Type_name = map[int32]string{
	0:  "UNSPECIFIED",
	1:  "BACKUP",
	2:  "RESTORE",
	3:  "SCHEMA_CHANGE",
	4:  "IMPORT",
	5:  "CHANGEFEED",
	6:  "CREATE_STATS",
	7:  "AUTO_CREATE_STATS",
	8:  "SCHEMA_CHANGE_GC",
	9:  "TYPEDESC_SCHEMA_CHANGE",
	10: "STREAM_INGESTION",
	11: "NEW_SCHEMA_CHANGE",
}
var Type_value = map[string]int32{
	"UNSPECIFIED":            0,
	"BACKUP":                 1,
	"RESTORE":                2,
	"SCHEMA_CHANGE":          3,
	"IMPORT":                 4,
	"CHANGEFEED":             5,
	"CREATE_STATS":           6,
	"AUTO_CREATE_STATS":      7,
	"SCHEMA_CHANGE_GC":       8,
	"TYPEDESC_SCHEMA_CHANGE": 9,
	"STREAM_INGESTION":       10,
	"NEW_SCHEMA_CHANGE":      11,
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{2}
}

type EncryptionInfo_Scheme int32

const (
	EncryptionInfo_AES256GCM EncryptionInfo_Scheme = 0
)

var EncryptionInfo_Scheme_name = map[int32]string{
	0: "AES256GCM",
}
var EncryptionInfo_Scheme_value = map[string]int32{
	"AES256GCM": 0,
}

func (x EncryptionInfo_Scheme) String() string {
	return proto.EnumName(EncryptionInfo_Scheme_name, int32(x))
}
func (EncryptionInfo_Scheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{2, 0}
}

type SchemaChangeGCProgress_Status int32

const (
	// Waiting for the index/table to expire.
	SchemaChangeGCProgress_WAITING_FOR_GC SchemaChangeGCProgress_Status = 0
	// The GC TTL has expired. This element is marked for imminent deletion
	SchemaChangeGCProgress_DELETING SchemaChangeGCProgress_Status = 1
	// This element has been deleted. The job is done when all elements are in
	// this state.
	SchemaChangeGCProgress_DELETED SchemaChangeGCProgress_Status = 2
)

var SchemaChangeGCProgress_Status_name = map[int32]string{
	0: "WAITING_FOR_GC",
	1: "DELETING",
	2: "DELETED",
}
var SchemaChangeGCProgress_Status_value = map[string]int32{
	"WAITING_FOR_GC": 0,
	"DELETING":       1,
	"DELETED":        2,
}

func (x SchemaChangeGCProgress_Status) String() string {
	return proto.EnumName(SchemaChangeGCProgress_Status_name, int32(x))
}
func (SchemaChangeGCProgress_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{22, 0}
}

type Lease struct {
	// The ID of the node that holds the lease.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// The epoch of the lease holder's node liveness entry.
	Epoch int64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *Lease) Reset()         { *m = Lease{} }
func (m *Lease) String() string { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()    {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{0}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(dst, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

// BackupEncryptionOptions stores information resolved during the BACKUP/RESTORE
// planning stage, and by the BACKUP/RESTORE job to encrypt or decrypt BACKUP
// data and manifest files.
type BackupEncryptionOptions struct {
	// Key specifies the key to use for encryption or decryption.
	Key  []byte         `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Mode EncryptionMode `protobuf:"varint,2,opt,name=mode,proto3,enum=cockroach.sql.jobs.jobspb.EncryptionMode" json:"mode,omitempty"`
	// KMSInfo specifies the KMS and encrypted DataKey pair to use for
	// encryption or decryption when mode == KMS.
	KMSInfo *BackupEncryptionOptions_KMSInfo `protobuf:"bytes,3,opt,name=kms_info,json=kmsInfo,proto3" json:"kms_info,omitempty"`
}

func (m *BackupEncryptionOptions) Reset()         { *m = BackupEncryptionOptions{} }
func (m *BackupEncryptionOptions) String() string { return proto.CompactTextString(m) }
func (*BackupEncryptionOptions) ProtoMessage()    {}
func (*BackupEncryptionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{1}
}
func (m *BackupEncryptionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupEncryptionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupEncryptionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupEncryptionOptions.Merge(dst, src)
}
func (m *BackupEncryptionOptions) XXX_Size() int {
	return m.Size()
}
func (m *BackupEncryptionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupEncryptionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_BackupEncryptionOptions proto.InternalMessageInfo

type BackupEncryptionOptions_KMSInfo struct {
	Uri              string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	EncryptedDataKey []byte `protobuf:"bytes,2,opt,name=encrypted_data_key,json=encryptedDataKey,proto3" json:"encrypted_data_key,omitempty"`
}

func (m *BackupEncryptionOptions_KMSInfo) Reset()         { *m = BackupEncryptionOptions_KMSInfo{} }
func (m *BackupEncryptionOptions_KMSInfo) String() string { return proto.CompactTextString(m) }
func (*BackupEncryptionOptions_KMSInfo) ProtoMessage()    {}
func (*BackupEncryptionOptions_KMSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{1, 0}
}
func (m *BackupEncryptionOptions_KMSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupEncryptionOptions_KMSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupEncryptionOptions_KMSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupEncryptionOptions_KMSInfo.Merge(dst, src)
}
func (m *BackupEncryptionOptions_KMSInfo) XXX_Size() int {
	return m.Size()
}
func (m *BackupEncryptionOptions_KMSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupEncryptionOptions_KMSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BackupEncryptionOptions_KMSInfo proto.InternalMessageInfo

// EncryptionInfo is stored IN PLAINTEXT along side collections of encrypted
// files stored outside of cockroach, for example by BACKUP/RESTORE.
type EncryptionInfo struct {
	Scheme EncryptionInfo_Scheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=cockroach.sql.jobs.jobspb.EncryptionInfo_Scheme" json:"scheme,omitempty"`
	Salt   []byte                `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
	// EncryptedDataKeyByKMSMasterKeyID is a mapping from the hashed master key
	// identifier of a KMS to the encrypted version of the DataKey obtained from
	// that KMS.
	EncryptedDataKeyByKMSMasterKeyID map[string][]byte `protobuf:"bytes,3,rep,name=encryptedDataKeyByKMSMasterKeyID,proto3" json:"encryptedDataKeyByKMSMasterKeyID,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EncryptionInfo) Reset()         { *m = EncryptionInfo{} }
func (m *EncryptionInfo) String() string { return proto.CompactTextString(m) }
func (*EncryptionInfo) ProtoMessage()    {}
func (*EncryptionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{2}
}
func (m *EncryptionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *EncryptionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptionInfo.Merge(dst, src)
}
func (m *EncryptionInfo) XXX_Size() int {
	return m.Size()
}
func (m *EncryptionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptionInfo proto.InternalMessageInfo

type StreamIngestionDetails struct {
	// StreamAddress locates the stream. It enables the client to find the
	// addresses of the stream's partitions.
	StreamAddress github_com_cockroachdb_cockroach_pkg_ccl_streamingccl.StreamAddress `protobuf:"bytes,1,opt,name=stream_address,json=streamAddress,proto3,casttype=github.com/cockroachdb/cockroach/pkg/ccl/streamingccl.StreamAddress" json:"stream_address,omitempty"`
	// Span is the keyspan into which this job will ingest KVs.
	//
	// The stream should emit all changes for a given span, and no changes outside
	// a span. Note that KVs received from the stream may need to be re-keyed into
	// this span.
	Span roachpb.Span `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
	// The job will ingest events from StartTime onwards.
	StartTime hlc.Timestamp `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
}

func (m *StreamIngestionDetails) Reset()         { *m = StreamIngestionDetails{} }
func (m *StreamIngestionDetails) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionDetails) ProtoMessage()    {}
func (*StreamIngestionDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{3}
}
func (m *StreamIngestionDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StreamIngestionDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionDetails.Merge(dst, src)
}
func (m *StreamIngestionDetails) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionDetails.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionDetails proto.InternalMessageInfo

type StreamIngestionProgress struct {
}

func (m *StreamIngestionProgress) Reset()         { *m = StreamIngestionProgress{} }
func (m *StreamIngestionProgress) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionProgress) ProtoMessage()    {}
func (*StreamIngestionProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{4}
}
func (m *StreamIngestionProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StreamIngestionProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionProgress.Merge(dst, src)
}
func (m *StreamIngestionProgress) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionProgress.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionProgress proto.InternalMessageInfo

type BackupDetails struct {
	StartTime hlc.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	EndTime   hlc.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// URI is the URI for the main backup destination. For partitioned backups,
	// the main BACKUP manifest and files with no other specified destination are
	// written to this location. For regular backups, all files are written to
	// this location.
	URI string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// URIsByLocalityKV is a map of locality KVs to store URIs, used for
	// partitioned backups.
	URIsByLocalityKV         map[string]string        `protobuf:"bytes,5,rep,name=uris_by_locality_kv,json=urisByLocalityKv,proto3" json:"uris_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DeprecatedBackupManifest []byte                   `protobuf:"bytes,4,opt,name=deprecated_backup_manifest,json=deprecatedBackupManifest,proto3" json:"deprecated_backup_manifest,omitempty"`
	EncryptionOptions        *BackupEncryptionOptions `protobuf:"bytes,6,opt,name=encryption_options,json=encryptionOptions,proto3" json:"encryption_options,omitempty"`
	EncryptionInfo           *EncryptionInfo          `protobuf:"bytes,9,opt,name=encryption_info,json=encryptionInfo,proto3" json:"encryption_info,omitempty"`
	// ProtectedTimestampRecord is the ID of the protected timestamp record
	// corresponding to this job. While the job ought to clean up the record
	// when it enters a terminal state, there may be cases where it cannot or
	// does not run the code to do so. To deal with this there is a background
	// reconcilliation loop to ensure that protected timestamps are cleaned up.
	ProtectedTimestampRecord *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,7,opt,name=protected_timestamp_record,json=protectedTimestampRecord,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"protected_timestamp_record,omitempty"`
	// CollectionURI is the path to the collection into which this backup is being
	// written, i.e. the URI the user provided before a chosen suffix was appended
	// to its path.
	CollectionURI string `protobuf:"bytes,8,opt,name=collection_URI,json=collectionURI,proto3" json:"collection_URI,omitempty"`
}

func (m *BackupDetails) Reset()         { *m = BackupDetails{} }
func (m *BackupDetails) String() string { return proto.CompactTextString(m) }
func (*BackupDetails) ProtoMessage()    {}
func (*BackupDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{5}
}
func (m *BackupDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDetails.Merge(dst, src)
}
func (m *BackupDetails) XXX_Size() int {
	return m.Size()
}
func (m *BackupDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDetails.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDetails proto.InternalMessageInfo

type BackupProgress struct {
}

func (m *BackupProgress) Reset()         { *m = BackupProgress{} }
func (m *BackupProgress) String() string { return proto.CompactTextString(m) }
func (*BackupProgress) ProtoMessage()    {}
func (*BackupProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{6}
}
func (m *BackupProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *BackupProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupProgress.Merge(dst, src)
}
func (m *BackupProgress) XXX_Size() int {
	return m.Size()
}
func (m *BackupProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupProgress.DiscardUnknown(m)
}

var xxx_messageInfo_BackupProgress proto.InternalMessageInfo

type RestoreDetails struct {
	EndTime            hlc.Timestamp                                                                                    `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	DescriptorRewrites map[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID]*RestoreDetails_DescriptorRewrite `protobuf:"bytes,2,rep,name=descriptor_rewrites,json=descriptorRewrites,proto3,castkey=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"descriptor_rewrites,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// URIs contains one URI for each backup (full or incremental) corresponding
	// to the location of the main BACKUP manifest. For partitioned backups, each
	// backup may also have files in other stores.
	URIs               []string                            `protobuf:"bytes,3,rep,name=uris,proto3" json:"uris,omitempty"`
	BackupLocalityInfo []RestoreDetails_BackupLocalityInfo `protobuf:"bytes,7,rep,name=backup_locality_info,json=backupLocalityInfo,proto3" json:"backup_locality_info"`
	// We keep track of the descriptors that we're creating as part of the
	// restore.
	DatabaseDescs []*descpb.DatabaseDescriptor `protobuf:"bytes,16,rep,name=database_descs,json=databaseDescs,proto3" json:"database_descs,omitempty"`
	TableDescs    []*descpb.TableDescriptor    `protobuf:"bytes,5,rep,name=table_descs,json=tableDescs,proto3" json:"table_descs,omitempty"`
	// TypeDescs contains the type descriptors written as part of this restore.
	// Note that it does not include type descriptors existing in the cluster
	// that backed up types are remapped to.
	TypeDescs []*descpb.TypeDescriptor `protobuf:"bytes,14,rep,name=type_descs,json=typeDescs,proto3" json:"type_descs,omitempty"`
	// SchemaDescs contains schema descriptors written as part of this restore.
	// Like TypeDescs, it does not include existing schema descriptors in the
	// cluster that backed up schemas are remapped to.
	SchemaDescs []*descpb.SchemaDescriptor `protobuf:"bytes,15,rep,name=schema_descs,json=schemaDescs,proto3" json:"schema_descs,omitempty"`
	Tenants     []descpb.TenantInfo        `protobuf:"bytes,13,rep,name=tenants,proto3" json:"tenants"`
	OverrideDB  string                     `protobuf:"bytes,6,opt,name=override_db,json=overrideDb,proto3" json:"override_db,omitempty"`
	// The restore job has several atomic stages. For now, we keep track of which
	// stages have completed via these flags.
	PrepareCompleted bool `protobuf:"varint,8,opt,name=prepare_completed,json=prepareCompleted,proto3" json:"prepare_completed,omitempty"`
	StatsInserted    bool `protobuf:"varint,9,opt,name=stats_inserted,json=statsInserted,proto3" json:"stats_inserted,omitempty"`
	// DescriptorsPublished indicates whether or not the descriptors written in
	// the job have been transactionally updated after the data was restored.
	DescriptorsPublished bool                                                                 `protobuf:"varint,10,opt,name=descriptors_published,json=descriptorsPublished,proto3" json:"descriptors_published,omitempty"`
	DescriptorCoverage   github_com_cockroachdb_cockroach_pkg_sql_sem_tree.DescriptorCoverage `protobuf:"varint,11,opt,name=descriptor_coverage,json=descriptorCoverage,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/tree.DescriptorCoverage" json:"descriptor_coverage,omitempty"`
	Encryption           *BackupEncryptionOptions                                             `protobuf:"bytes,12,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *RestoreDetails) Reset()         { *m = RestoreDetails{} }
func (m *RestoreDetails) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails) ProtoMessage()    {}
func (*RestoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{7}
}
func (m *RestoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails.Merge(dst, src)
}
func (m *RestoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails proto.InternalMessageInfo

type RestoreDetails_DescriptorRewrite struct {
	ID       github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"id,omitempty"`
	ParentID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,2,opt,name=parent_id,json=parentId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"parent_id,omitempty"`
	// ToExisting represents whether this descriptor is being remapped to a
	// descriptor that already exists in the cluster.
	ToExisting bool `protobuf:"varint,3,opt,name=to_existing,json=toExisting,proto3" json:"to_existing,omitempty"`
}

func (m *RestoreDetails_DescriptorRewrite) Reset()         { *m = RestoreDetails_DescriptorRewrite{} }
func (m *RestoreDetails_DescriptorRewrite) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails_DescriptorRewrite) ProtoMessage()    {}
func (*RestoreDetails_DescriptorRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{7, 0}
}
func (m *RestoreDetails_DescriptorRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails_DescriptorRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails_DescriptorRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails_DescriptorRewrite.Merge(dst, src)
}
func (m *RestoreDetails_DescriptorRewrite) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails_DescriptorRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails_DescriptorRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails_DescriptorRewrite proto.InternalMessageInfo

type RestoreDetails_BackupLocalityInfo struct {
	URIsByOriginalLocalityKV map[string]string `protobuf:"bytes,1,rep,name=uris_by_original_locality_kv,json=urisByOriginalLocalityKv,proto3" json:"uris_by_original_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RestoreDetails_BackupLocalityInfo) Reset()         { *m = RestoreDetails_BackupLocalityInfo{} }
func (m *RestoreDetails_BackupLocalityInfo) String() string { return proto.CompactTextString(m) }
func (*RestoreDetails_BackupLocalityInfo) ProtoMessage()    {}
func (*RestoreDetails_BackupLocalityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{7, 1}
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreDetails_BackupLocalityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDetails_BackupLocalityInfo.Merge(dst, src)
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDetails_BackupLocalityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDetails_BackupLocalityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDetails_BackupLocalityInfo proto.InternalMessageInfo

type RestoreProgress struct {
	HighWater []byte `protobuf:"bytes,1,opt,name=high_water,json=highWater,proto3" json:"high_water,omitempty"`
}

func (m *RestoreProgress) Reset()         { *m = RestoreProgress{} }
func (m *RestoreProgress) String() string { return proto.CompactTextString(m) }
func (*RestoreProgress) ProtoMessage()    {}
func (*RestoreProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{8}
}
func (m *RestoreProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RestoreProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreProgress.Merge(dst, src)
}
func (m *RestoreProgress) XXX_Size() int {
	return m.Size()
}
func (m *RestoreProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreProgress proto.InternalMessageInfo

type ImportDetails struct {
	Tables     []ImportDetails_Table `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	URIs       []string              `protobuf:"bytes,2,rep,name=uris,proto3" json:"uris,omitempty"`
	Format     roachpb.IOFileFormat  `protobuf:"bytes,3,opt,name=format,proto3" json:"format"`
	SSTSize    int64                 `protobuf:"varint,4,opt,name=sst_size,json=sstSize,proto3" json:"sst_size,omitempty"`
	Oversample int64                 `protobuf:"varint,9,opt,name=oversample,proto3" json:"oversample,omitempty"`
	SkipFKs    bool                  `protobuf:"varint,10,opt,name=skip_fks,json=skipFks,proto3" json:"skip_fks,omitempty"`
	// walltime is the time at which an import job will write KVs.
	Walltime   int64                                                      `protobuf:"varint,5,opt,name=walltime,proto3" json:"walltime,omitempty"`
	ParentID   github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,6,opt,name=parent_id,json=parentId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"parent_id,omitempty"`
	BackupPath string                                                     `protobuf:"bytes,7,opt,name=backup_path,json=backupPath,proto3" json:"backup_path,omitempty"`
	// samples is a sampling of cockroach KV keys generated from the input data.
	// It is populated with the sampling phase's results. These must be
	// used if a job is resumed to guarantee that AddSSTable will not attempt
	// to add ranges with an old split point within them.
	Samples [][]byte `protobuf:"bytes,8,rep,name=samples,proto3" json:"samples,omitempty"`
	// ingest_directly means the Import job directly ingests the data as readers
	// produce it instead of sampling it and then setting up a distsql shuffle and
	// sort that produced sorted, non-overlapping data to ingest. When ingesting
	// directly, many other fields like samples, oversample, sst_size are ignored.
	IngestDirectly    bool `protobuf:"varint,11,opt,name=ingest_directly,json=ingestDirectly,proto3" json:"ingest_directly,omitempty"`
	PrepareComplete   bool `protobuf:"varint,12,opt,name=prepare_complete,json=prepareComplete,proto3" json:"prepare_complete,omitempty"`
	TablesPublished   bool `protobuf:"varint,13,opt,name=tables_published,json=tablesPublished,proto3" json:"tables_published,omitempty"`
	ParseBundleSchema bool `protobuf:"varint,14,opt,name=parse_bundle_schema,json=parseBundleSchema,proto3" json:"parse_bundle_schema,omitempty"`
	// ProtectedTimestampRecord is the ID of the protected timestamp record
	// corresponding to this job. While the job ought to clean up the record
	// when it enters a terminal state, there may be cases where it cannot or
	// does not run the code to do so. To deal with this there is a background
	// reconciliation loop to ensure that protected timestamps are cleaned up.
	ProtectedTimestampRecord *github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,22,opt,name=protected_timestamp_record,json=protectedTimestampRecord,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"protected_timestamp_record,omitempty"`
}

func (m *ImportDetails) Reset()         { *m = ImportDetails{} }
func (m *ImportDetails) String() string { return proto.CompactTextString(m) }
func (*ImportDetails) ProtoMessage()    {}
func (*ImportDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{9}
}
func (m *ImportDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails.Merge(dst, src)
}
func (m *ImportDetails) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails proto.InternalMessageInfo

type ImportDetails_Table struct {
	Desc       *descpb.TableDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	Name       string                  `protobuf:"bytes,18,opt,name=name,proto3" json:"name,omitempty"`
	SeqVal     int64                   `protobuf:"varint,19,opt,name=seq_val,json=seqVal,proto3" json:"seq_val,omitempty"`
	IsNew      bool                    `protobuf:"varint,20,opt,name=is_new,json=isNew,proto3" json:"is_new,omitempty"`
	WasEmpty   bool                    `protobuf:"varint,22,opt,name=was_empty,json=wasEmpty,proto3" json:"was_empty,omitempty"`
	TargetCols []string                `protobuf:"bytes,21,rep,name=target_cols,json=targetCols,proto3" json:"target_cols,omitempty"`
}

func (m *ImportDetails_Table) Reset()         { *m = ImportDetails_Table{} }
func (m *ImportDetails_Table) String() string { return proto.CompactTextString(m) }
func (*ImportDetails_Table) ProtoMessage()    {}
func (*ImportDetails_Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{9, 0}
}
func (m *ImportDetails_Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDetails_Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportDetails_Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDetails_Table.Merge(dst, src)
}
func (m *ImportDetails_Table) XXX_Size() int {
	return m.Size()
}
func (m *ImportDetails_Table) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDetails_Table.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDetails_Table proto.InternalMessageInfo

// SequenceValChunks represents a single chunk of sequence values allocated
// during an IMPORT.
type SequenceValChunk struct {
	ChunkStartVal int64 `protobuf:"varint,1,opt,name=chunk_start_val,json=chunkStartVal,proto3" json:"chunk_start_val,omitempty"`
	ChunkSize     int64 `protobuf:"varint,2,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	// The first row in the file being imported from which the current chunk of
	// sequence values is being used.
	ChunkStartRow int64 `protobuf:"varint,3,opt,name=chunk_start_row,json=chunkStartRow,proto3" json:"chunk_start_row,omitempty"`
	// The row in the file being imported at which the import will need to use a
	// new chunk of sequence values.
	NextChunkStartRow int64 `protobuf:"varint,4,opt,name=next_chunk_start_row,json=nextChunkStartRow,proto3" json:"next_chunk_start_row,omitempty"`
}

func (m *SequenceValChunk) Reset()         { *m = SequenceValChunk{} }
func (m *SequenceValChunk) String() string { return proto.CompactTextString(m) }
func (*SequenceValChunk) ProtoMessage()    {}
func (*SequenceValChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{10}
}
func (m *SequenceValChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceValChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SequenceValChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceValChunk.Merge(dst, src)
}
func (m *SequenceValChunk) XXX_Size() int {
	return m.Size()
}
func (m *SequenceValChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceValChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceValChunk proto.InternalMessageInfo

// SequenceDetails represents information about the sequences processed in a
// single file during IMPORT.
type SequenceDetails struct {
	// Mapping from sequence ID to allocated sequence chunks.
	SeqIdToChunks map[int32]*SequenceDetails_SequenceChunks `protobuf:"bytes,1,rep,name=seq_id_to_chunks,json=seqIdToChunks,proto3" json:"seq_id_to_chunks,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SequenceDetails) Reset()         { *m = SequenceDetails{} }
func (m *SequenceDetails) String() string { return proto.CompactTextString(m) }
func (*SequenceDetails) ProtoMessage()    {}
func (*SequenceDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{11}
}
func (m *SequenceDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SequenceDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceDetails.Merge(dst, src)
}
func (m *SequenceDetails) XXX_Size() int {
	return m.Size()
}
func (m *SequenceDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceDetails proto.InternalMessageInfo

// SequenceChunks represents all the chunks reserved for a particular sequence
// during an IMPORT.
type SequenceDetails_SequenceChunks struct {
	Chunks []*SequenceValChunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *SequenceDetails_SequenceChunks) Reset()         { *m = SequenceDetails_SequenceChunks{} }
func (m *SequenceDetails_SequenceChunks) String() string { return proto.CompactTextString(m) }
func (*SequenceDetails_SequenceChunks) ProtoMessage()    {}
func (*SequenceDetails_SequenceChunks) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{11, 0}
}
func (m *SequenceDetails_SequenceChunks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceDetails_SequenceChunks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SequenceDetails_SequenceChunks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceDetails_SequenceChunks.Merge(dst, src)
}
func (m *SequenceDetails_SequenceChunks) XXX_Size() int {
	return m.Size()
}
func (m *SequenceDetails_SequenceChunks) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceDetails_SequenceChunks.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceDetails_SequenceChunks proto.InternalMessageInfo

type ImportProgress struct {
	SamplingProgress []float32 `protobuf:"fixed32,1,rep,packed,name=sampling_progress,json=samplingProgress,proto3" json:"sampling_progress,omitempty"`
	ReadProgress     []float32 `protobuf:"fixed32,2,rep,packed,name=read_progress,json=readProgress,proto3" json:"read_progress,omitempty"`
	WriteProgress    []float32 `protobuf:"fixed32,3,rep,packed,name=write_progress,json=writeProgress,proto3" json:"write_progress,omitempty"`
	// The spans of split keys which have had their SSTable's generated.
	// This allows us to skip the shuffle stage for already-completed
	// spans when resuming an import job.
	SpanProgress []roachpb.Span `protobuf:"bytes,4,rep,name=span_progress,json=spanProgress,proto3" json:"span_progress"`
	// In direct-ingest import, once the KVs for i'th row of an input file have
	// been flushed, we can advance the count here and then on resume skip over
	// that many rows without needing to convert/process them at all.
	ResumePos []int64 `protobuf:"varint,5,rep,packed,name=resume_pos,json=resumePos,proto3" json:"resume_pos,omitempty"`
	// Holds metadata related to sequences for every file processed during an
	// IMPORT.
	SequenceDetails []*SequenceDetails `protobuf:"bytes,6,rep,name=sequence_details,json=sequenceDetails,proto3" json:"sequence_details,omitempty"`
}

func (m *ImportProgress) Reset()         { *m = ImportProgress{} }
func (m *ImportProgress) String() string { return proto.CompactTextString(m) }
func (*ImportProgress) ProtoMessage()    {}
func (*ImportProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{12}
}
func (m *ImportProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ImportProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportProgress.Merge(dst, src)
}
func (m *ImportProgress) XXX_Size() int {
	return m.Size()
}
func (m *ImportProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ImportProgress proto.InternalMessageInfo

// TypeSchemaChangeDetails is the job detail information for a type schema change job.
type TypeSchemaChangeDetails struct {
	TypeID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"type_id,omitempty"`
}

func (m *TypeSchemaChangeDetails) Reset()         { *m = TypeSchemaChangeDetails{} }
func (m *TypeSchemaChangeDetails) String() string { return proto.CompactTextString(m) }
func (*TypeSchemaChangeDetails) ProtoMessage()    {}
func (*TypeSchemaChangeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{13}
}
func (m *TypeSchemaChangeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeSchemaChangeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TypeSchemaChangeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeSchemaChangeDetails.Merge(dst, src)
}
func (m *TypeSchemaChangeDetails) XXX_Size() int {
	return m.Size()
}
func (m *TypeSchemaChangeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeSchemaChangeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_TypeSchemaChangeDetails proto.InternalMessageInfo

// TypeSchemaChangeProgress is the persisted progress for a type schema change job.
type TypeSchemaChangeProgress struct {
}

func (m *TypeSchemaChangeProgress) Reset()         { *m = TypeSchemaChangeProgress{} }
func (m *TypeSchemaChangeProgress) String() string { return proto.CompactTextString(m) }
func (*TypeSchemaChangeProgress) ProtoMessage()    {}
func (*TypeSchemaChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{14}
}
func (m *TypeSchemaChangeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeSchemaChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TypeSchemaChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeSchemaChangeProgress.Merge(dst, src)
}
func (m *TypeSchemaChangeProgress) XXX_Size() int {
	return m.Size()
}
func (m *TypeSchemaChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeSchemaChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_TypeSchemaChangeProgress proto.InternalMessageInfo

// TypeSchemaChangeDetails is the job detail information for the new schema change job.
type NewSchemaChangeDetails struct {
	Targets []*scpb.Target `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
}

func (m *NewSchemaChangeDetails) Reset()         { *m = NewSchemaChangeDetails{} }
func (m *NewSchemaChangeDetails) String() string { return proto.CompactTextString(m) }
func (*NewSchemaChangeDetails) ProtoMessage()    {}
func (*NewSchemaChangeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{15}
}
func (m *NewSchemaChangeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewSchemaChangeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NewSchemaChangeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSchemaChangeDetails.Merge(dst, src)
}
func (m *NewSchemaChangeDetails) XXX_Size() int {
	return m.Size()
}
func (m *NewSchemaChangeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSchemaChangeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NewSchemaChangeDetails proto.InternalMessageInfo

// NewSchemaChangeProgress is the persisted progress for the new schema change job.
type NewSchemaChangeProgress struct {
	States []scpb.State `protobuf:"varint,1,rep,packed,name=states,proto3,enum=cockroach.sql.schemachanger.scpb.State" json:"states,omitempty"`
}

func (m *NewSchemaChangeProgress) Reset()         { *m = NewSchemaChangeProgress{} }
func (m *NewSchemaChangeProgress) String() string { return proto.CompactTextString(m) }
func (*NewSchemaChangeProgress) ProtoMessage()    {}
func (*NewSchemaChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{16}
}
func (m *NewSchemaChangeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewSchemaChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NewSchemaChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSchemaChangeProgress.Merge(dst, src)
}
func (m *NewSchemaChangeProgress) XXX_Size() int {
	return m.Size()
}
func (m *NewSchemaChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSchemaChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_NewSchemaChangeProgress proto.InternalMessageInfo

type ResumeSpanList struct {
	ResumeSpans []roachpb.Span `protobuf:"bytes,1,rep,name=resume_spans,json=resumeSpans,proto3" json:"resume_spans"`
}

func (m *ResumeSpanList) Reset()         { *m = ResumeSpanList{} }
func (m *ResumeSpanList) String() string { return proto.CompactTextString(m) }
func (*ResumeSpanList) ProtoMessage()    {}
func (*ResumeSpanList) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{17}
}
func (m *ResumeSpanList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeSpanList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResumeSpanList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeSpanList.Merge(dst, src)
}
func (m *ResumeSpanList) XXX_Size() int {
	return m.Size()
}
func (m *ResumeSpanList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeSpanList.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeSpanList proto.InternalMessageInfo

type DroppedTableDetails struct {
	Name   string                                                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ID     github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,2,opt,name=ID,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"ID,omitempty"`
	Status Status                                                     `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.sql.jobs.jobspb.Status" json:"status,omitempty"`
}

func (m *DroppedTableDetails) Reset()         { *m = DroppedTableDetails{} }
func (m *DroppedTableDetails) String() string { return proto.CompactTextString(m) }
func (*DroppedTableDetails) ProtoMessage()    {}
func (*DroppedTableDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{18}
}
func (m *DroppedTableDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DroppedTableDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DroppedTableDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DroppedTableDetails.Merge(dst, src)
}
func (m *DroppedTableDetails) XXX_Size() int {
	return m.Size()
}
func (m *DroppedTableDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_DroppedTableDetails.DiscardUnknown(m)
}

var xxx_messageInfo_DroppedTableDetails proto.InternalMessageInfo

// SchemaChangeGCDetails should resemble one of the following:
//
// 1. Index (non-interleaved) deletions: One or more deletions of an index on a
// table.
//      details.Indexes -> the indexes to GC. These indexes must be
//      non-interleaved.
//      details.ParentID -> the table with the indexes.
//
// 2. Table deletions: The deletion of a single table.
//      details.Tables -> the tables to be deleted.
//
// 3. Database deletions: The deletion of a database and therefore all its tables.
//      details.Tables -> the IDs of the tables to GC.
//      details.ParentID -> the ID of the database to drop.
//
// 4. Tenant deletion: The deletion of a tenant key range.
//      details.TenantID -> the ID of the tenant to delete.
type SchemaChangeGCDetails struct {
	// Indexes to GC.
	Indexes []SchemaChangeGCDetails_DroppedIndex `protobuf:"bytes,1,rep,name=indexes,proto3" json:"indexes"`
	// InterleavedTable is the table being truncated. In particular, it is the
	// TableDescriptor before any of the truncate modifications have been applied.
	InterleavedTable *descpb.TableDescriptor `protobuf:"bytes,4,opt,name=interleaved_table,json=interleavedTable,proto3" json:"interleaved_table,omitempty"`
	// InterleavedIndexes is the set of interleaved indexes to truncate.
	InterleavedIndexes []descpb.IndexDescriptor `protobuf:"bytes,5,rep,name=interleaved_indexes,json=interleavedIndexes,proto3" json:"interleaved_indexes"`
	// Entire tables to GC.
	Tables []SchemaChangeGCDetails_DroppedID `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables"`
	// If dropping indexes, the table ID which has those indexes. If dropping a
	// database, the database ID.
	ParentID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,3,opt,name=parent_id,json=parentId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"parent_id,omitempty"`
	// Tenant to GC.
	Tenant *SchemaChangeGCDetails_DroppedTenant `protobuf:"bytes,6,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (m *SchemaChangeGCDetails) Reset()         { *m = SchemaChangeGCDetails{} }
func (m *SchemaChangeGCDetails) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails) ProtoMessage()    {}
func (*SchemaChangeGCDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{19}
}
func (m *SchemaChangeGCDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails.Merge(dst, src)
}
func (m *SchemaChangeGCDetails) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails proto.InternalMessageInfo

type SchemaChangeGCDetails_DroppedIndex struct {
	IndexID  github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"index_id,omitempty"`
	DropTime int64                                                           `protobuf:"varint,2,opt,name=drop_time,json=dropTime,proto3" json:"drop_time,omitempty"`
}

func (m *SchemaChangeGCDetails_DroppedIndex) Reset()         { *m = SchemaChangeGCDetails_DroppedIndex{} }
func (m *SchemaChangeGCDetails_DroppedIndex) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails_DroppedIndex) ProtoMessage()    {}
func (*SchemaChangeGCDetails_DroppedIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{19, 0}
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails_DroppedIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex.Merge(dst, src)
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails_DroppedIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails_DroppedIndex proto.InternalMessageInfo

type SchemaChangeGCDetails_DroppedID struct {
	ID       github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"id,omitempty"`
	DropTime int64                                                      `protobuf:"varint,2,opt,name=drop_time,json=dropTime,proto3" json:"drop_time,omitempty"`
}

func (m *SchemaChangeGCDetails_DroppedID) Reset()         { *m = SchemaChangeGCDetails_DroppedID{} }
func (m *SchemaChangeGCDetails_DroppedID) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails_DroppedID) ProtoMessage()    {}
func (*SchemaChangeGCDetails_DroppedID) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{19, 1}
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails_DroppedID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedID.Merge(dst, src)
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails_DroppedID) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedID.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails_DroppedID proto.InternalMessageInfo

type SchemaChangeGCDetails_DroppedTenant struct {
	ID       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	DropTime int64  `protobuf:"varint,2,opt,name=drop_time,json=dropTime,proto3" json:"drop_time,omitempty"`
}

func (m *SchemaChangeGCDetails_DroppedTenant) Reset()         { *m = SchemaChangeGCDetails_DroppedTenant{} }
func (m *SchemaChangeGCDetails_DroppedTenant) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCDetails_DroppedTenant) ProtoMessage()    {}
func (*SchemaChangeGCDetails_DroppedTenant) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{19, 2}
}
func (m *SchemaChangeGCDetails_DroppedTenant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCDetails_DroppedTenant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCDetails_DroppedTenant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedTenant.Merge(dst, src)
}
func (m *SchemaChangeGCDetails_DroppedTenant) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCDetails_DroppedTenant) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCDetails_DroppedTenant.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCDetails_DroppedTenant proto.InternalMessageInfo

type SchemaChangeDetails struct {
	// A schema change can involve running multiple processors backfilling
	// or deleting data. They occasionally checkpoint Spans so that the
	// processing can resume in the event of a node failure. The spans are
	// non-overlapping contiguous areas of the KV space that still need to
	// be processed. The index represents the index of a mutation in a
	// mutation list containing mutations for the same mutationID.
	ResumeSpanList []ResumeSpanList      `protobuf:"bytes,2,rep,name=resume_span_list,json=resumeSpanList,proto3" json:"resume_span_list"`
	DroppedTables  []DroppedTableDetails `protobuf:"bytes,3,rep,name=dropped_tables,json=droppedTables,proto3" json:"dropped_tables"`
	// dropped_types holds the set of types to drop as part of a DROP DATABASE
	// statement. We collect the types here rather than creating individual DROP
	// TYPE jobs for each dropped type.
	DroppedTypes []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,8,rep,packed,name=dropped_types,json=droppedTypes,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"dropped_types,omitempty"`
	// dropped_schemas holds the set of schemas to drop as part of a DROP SCHEMA
	// or DROP DATABASE cascade statement.
	DroppedSchemas []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,9,rep,packed,name=dropped_schemas,json=droppedSchemas,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"dropped_schemas,omitempty"`
	// The descriptor ID of the dropped database which created this job.
	DroppedDatabaseID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,4,opt,name=dropped_database_id,json=droppedDatabaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"dropped_database_id,omitempty"`
	// desc_id is the target descriptor for this schema change. Note that this ID
	// is not always a table ID! We allow referencing any descriptor here to allow
	// generic schema changes on descriptors whose schema change process involves
	// only draining names and existing leases. This allows us to implement the
	// simple schema changes on SchemaDescriptors and DatabaseDescriptors without
	// implementing a new job for each.
	DescID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,5,opt,name=desc_id,json=descId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"desc_id,omitempty"`
	// table_mutation_id is the mutation ID that the schema changer is to process. It is
	// only set when desc_id references a TableDescriptor.
	TableMutationID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.MutationID `protobuf:"varint,6,opt,name=table_mutation_id,json=tableMutationId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.MutationID" json:"table_mutation_id,omitempty"`
	// The format version of the schema change job details. This is used to
	// distinguish between jobs as they existed in 19.2 and earlier versions
	// (controlled and updated by a SchemaChanger) and jobs as they exist in 20.1
	// (scheduled and run by the job registry).
	FormatVersion SchemaChangeDetailsFormatVersion `protobuf:"varint,7,opt,name=format_version,json=formatVersion,proto3,casttype=SchemaChangeDetailsFormatVersion" json:"format_version,omitempty"`
}

func (m *SchemaChangeDetails) Reset()         { *m = SchemaChangeDetails{} }
func (m *SchemaChangeDetails) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeDetails) ProtoMessage()    {}
func (*SchemaChangeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{20}
}
func (m *SchemaChangeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeDetails.Merge(dst, src)
}
func (m *SchemaChangeDetails) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeDetails proto.InternalMessageInfo

type SchemaChangeProgress struct {
}

func (m *SchemaChangeProgress) Reset()         { *m = SchemaChangeProgress{} }
func (m *SchemaChangeProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeProgress) ProtoMessage()    {}
func (*SchemaChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{21}
}
func (m *SchemaChangeProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeProgress.Merge(dst, src)
}
func (m *SchemaChangeProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeProgress proto.InternalMessageInfo

type SchemaChangeGCProgress struct {
	// Indexes to GC.
	Indexes []SchemaChangeGCProgress_IndexProgress `protobuf:"bytes,1,rep,name=indexes,proto3" json:"indexes"`
	// Entire tables to GC.
	Tables []SchemaChangeGCProgress_TableProgress `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables"`
	// The status of the tenant to be deleted.
	Tenant *SchemaChangeGCProgress_TenantProgress `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
}

func (m *SchemaChangeGCProgress) Reset()         { *m = SchemaChangeGCProgress{} }
func (m *SchemaChangeGCProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{22}
}
func (m *SchemaChangeGCProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress proto.InternalMessageInfo

type SchemaChangeGCProgress_IndexProgress struct {
	IndexID github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,1,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"index_id,omitempty"`
	Status  SchemaChangeGCProgress_Status                                   `protobuf:"varint,2,opt,name=status,proto3,enum=cockroach.sql.jobs.jobspb.SchemaChangeGCProgress_Status" json:"status,omitempty"`
}

func (m *SchemaChangeGCProgress_IndexProgress) Reset()         { *m = SchemaChangeGCProgress_IndexProgress{} }
func (m *SchemaChangeGCProgress_IndexProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress_IndexProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress_IndexProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{22, 0}
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress_IndexProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress_IndexProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress_IndexProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress_IndexProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress_IndexProgress proto.InternalMessageInfo

type SchemaChangeGCProgress_TableProgress struct {
	ID     github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"id,omitempty"`
	Status SchemaChangeGCProgress_Status                              `protobuf:"varint,2,opt,name=status,proto3,enum=cockroach.sql.jobs.jobspb.SchemaChangeGCProgress_Status" json:"status,omitempty"`
}

func (m *SchemaChangeGCProgress_TableProgress) Reset()         { *m = SchemaChangeGCProgress_TableProgress{} }
func (m *SchemaChangeGCProgress_TableProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress_TableProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress_TableProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{22, 1}
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress_TableProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress_TableProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress_TableProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress_TableProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress_TableProgress proto.InternalMessageInfo

type SchemaChangeGCProgress_TenantProgress struct {
	Status SchemaChangeGCProgress_Status `protobuf:"varint,1,opt,name=status,proto3,enum=cockroach.sql.jobs.jobspb.SchemaChangeGCProgress_Status" json:"status,omitempty"`
}

func (m *SchemaChangeGCProgress_TenantProgress) Reset()         { *m = SchemaChangeGCProgress_TenantProgress{} }
func (m *SchemaChangeGCProgress_TenantProgress) String() string { return proto.CompactTextString(m) }
func (*SchemaChangeGCProgress_TenantProgress) ProtoMessage()    {}
func (*SchemaChangeGCProgress_TenantProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{22, 2}
}
func (m *SchemaChangeGCProgress_TenantProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChangeGCProgress_TenantProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SchemaChangeGCProgress_TenantProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChangeGCProgress_TenantProgress.Merge(dst, src)
}
func (m *SchemaChangeGCProgress_TenantProgress) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChangeGCProgress_TenantProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChangeGCProgress_TenantProgress.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChangeGCProgress_TenantProgress proto.InternalMessageInfo

type ChangefeedTarget struct {
	StatementTimeName string `protobuf:"bytes,1,opt,name=statement_time_name,json=statementTimeName,proto3" json:"statement_time_name,omitempty"`
}

func (m *ChangefeedTarget) Reset()         { *m = ChangefeedTarget{} }
func (m *ChangefeedTarget) String() string { return proto.CompactTextString(m) }
func (*ChangefeedTarget) ProtoMessage()    {}
func (*ChangefeedTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{23}
}
func (m *ChangefeedTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedTarget.Merge(dst, src)
}
func (m *ChangefeedTarget) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedTarget.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedTarget proto.InternalMessageInfo

type ChangefeedDetails struct {
	// Targets contains the user-specified tables and databases to watch, mapping
	// the descriptor id to the name at the time of changefeed creating. There is
	// a 1:1 correspondance between unique targets in the original sql query and
	// entries in this map.
	//
	// - A watched table is stored here under its table id
	// - TODO(dan): A watched database is stored here under its database id
	// - TODO(dan): A db.* expansion is treated identicially to watching the
	//   database
	//
	// Note that the TODOs mean this field currently is guaranteed to only hold
	// table ids and a cluster version check will be added when this changes.
	//
	// The names at resolution time are included so that table and database
	// renames can be detected. They are also used to construct an error message
	// if the descriptor id no longer exists when the jobs is unpaused (which can
	// happen if it was dropped or truncated).
	Targets       ChangefeedTargets `protobuf:"bytes,6,rep,name=targets,proto3,casttype=ChangefeedTargets,castkey=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"targets" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SinkURI       string            `protobuf:"bytes,3,opt,name=sink_uri,json=sinkUri,proto3" json:"sink_uri,omitempty"`
	Opts          map[string]string `protobuf:"bytes,4,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StatementTime hlc.Timestamp     `protobuf:"bytes,7,opt,name=statement_time,json=statementTime,proto3" json:"statement_time"`
}

func (m *ChangefeedDetails) Reset()         { *m = ChangefeedDetails{} }
func (m *ChangefeedDetails) String() string { return proto.CompactTextString(m) }
func (*ChangefeedDetails) ProtoMessage()    {}
func (*ChangefeedDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{24}
}
func (m *ChangefeedDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedDetails.Merge(dst, src)
}
func (m *ChangefeedDetails) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedDetails proto.InternalMessageInfo

type ResolvedSpan struct {
	Span            roachpb.Span  `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	Timestamp       hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	BoundaryReached bool          `protobuf:"varint,3,opt,name=boundary_reached,json=boundaryReached,proto3" json:"boundary_reached,omitempty"`
}

func (m *ResolvedSpan) Reset()         { *m = ResolvedSpan{} }
func (m *ResolvedSpan) String() string { return proto.CompactTextString(m) }
func (*ResolvedSpan) ProtoMessage()    {}
func (*ResolvedSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{25}
}
func (m *ResolvedSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolvedSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResolvedSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolvedSpan.Merge(dst, src)
}
func (m *ResolvedSpan) XXX_Size() int {
	return m.Size()
}
func (m *ResolvedSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolvedSpan.DiscardUnknown(m)
}

var xxx_messageInfo_ResolvedSpan proto.InternalMessageInfo

type ChangefeedProgress struct {
	ResolvedSpans []ResolvedSpan `protobuf:"bytes,2,rep,name=resolved_spans,json=resolvedSpans,proto3" json:"resolved_spans"`
	// ProtectedTimestampRecord is the ID of the protected timestamp record
	// corresponding to this job. While the job ought to clean up the record
	// when it enters a terminal state, there may be cases where it cannot or
	// does not run the code to do so. To deal with this there is a background
	// reconcilliation loop to ensure that protected timestamps are cleaned up.
	//
	// A record is created with the job if the job requires an initial backfill.
	// Furthermore, once subsequent backfills begin, record will be created and
	// released accordingly.
	ProtectedTimestampRecord github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,3,opt,name=protected_timestamp_record,json=protectedTimestampRecord,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"protected_timestamp_record"`
}

func (m *ChangefeedProgress) Reset()         { *m = ChangefeedProgress{} }
func (m *ChangefeedProgress) String() string { return proto.CompactTextString(m) }
func (*ChangefeedProgress) ProtoMessage()    {}
func (*ChangefeedProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{26}
}
func (m *ChangefeedProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChangefeedProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedProgress.Merge(dst, src)
}
func (m *ChangefeedProgress) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedProgress proto.InternalMessageInfo

// CreateStatsDetails are used for the CreateStats job, which is triggered
// whenever the `CREATE STATISTICS` SQL statement is run. The CreateStats job
// collects table statistics, which contain info such as the number of rows in
// the table or the number of distinct values in a column.
type CreateStatsDetails struct {
	Name            string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Table           descpb.TableDescriptor       `protobuf:"bytes,2,opt,name=table,proto3" json:"table"`
	ColumnStats     []CreateStatsDetails_ColStat `protobuf:"bytes,3,rep,name=column_stats,json=columnStats,proto3" json:"column_stats"`
	Statement       string                       `protobuf:"bytes,4,opt,name=statement,proto3" json:"statement,omitempty"`
	AsOf            *hlc.Timestamp               `protobuf:"bytes,5,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`
	MaxFractionIdle float64                      `protobuf:"fixed64,7,opt,name=max_fraction_idle,json=maxFractionIdle,proto3" json:"max_fraction_idle,omitempty"`
	// Fully qualified table name.
	FQTableName string `protobuf:"bytes,6,opt,name=fq_table_name,json=fqTableName,proto3" json:"fq_table_name,omitempty"`
}

func (m *CreateStatsDetails) Reset()         { *m = CreateStatsDetails{} }
func (m *CreateStatsDetails) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails) ProtoMessage()    {}
func (*CreateStatsDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{27}
}
func (m *CreateStatsDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails.Merge(dst, src)
}
func (m *CreateStatsDetails) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails proto.InternalMessageInfo

type CreateStatsDetails_ColStat struct {
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,1,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"column_ids,omitempty"`
	// Indicates whether this column stat should include a histogram.
	HasHistogram bool `protobuf:"varint,2,opt,name=has_histogram,json=hasHistogram,proto3" json:"has_histogram,omitempty"`
	// Indicates whether this column stat is over an inverted index.
	Inverted bool `protobuf:"varint,3,opt,name=inverted,proto3" json:"inverted,omitempty"`
	// If this column stat includes a histogram, indicates the maximum number
	// of buckets that should be created. If this field is unset, a default
	// maximum of 200 buckets are created.
	HistogramMaxBuckets uint32 `protobuf:"varint,4,opt,name=histogram_max_buckets,json=histogramMaxBuckets,proto3" json:"histogram_max_buckets,omitempty"`
}

func (m *CreateStatsDetails_ColStat) Reset()         { *m = CreateStatsDetails_ColStat{} }
func (m *CreateStatsDetails_ColStat) String() string { return proto.CompactTextString(m) }
func (*CreateStatsDetails_ColStat) ProtoMessage()    {}
func (*CreateStatsDetails_ColStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{27, 0}
}
func (m *CreateStatsDetails_ColStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsDetails_ColStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsDetails_ColStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsDetails_ColStat.Merge(dst, src)
}
func (m *CreateStatsDetails_ColStat) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsDetails_ColStat) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsDetails_ColStat.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsDetails_ColStat proto.InternalMessageInfo

type CreateStatsProgress struct {
}

func (m *CreateStatsProgress) Reset()         { *m = CreateStatsProgress{} }
func (m *CreateStatsProgress) String() string { return proto.CompactTextString(m) }
func (*CreateStatsProgress) ProtoMessage()    {}
func (*CreateStatsProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{28}
}
func (m *CreateStatsProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatsProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatsProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatsProgress.Merge(dst, src)
}
func (m *CreateStatsProgress) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatsProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatsProgress.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatsProgress proto.InternalMessageInfo

type Payload struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// If empty, the description is assumed to be the statement.
	Statement     string                                                         `protobuf:"bytes,16,opt,name=statement,proto3" json:"statement,omitempty"`
	UsernameProto github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto `protobuf:"bytes,2,opt,name=username_proto,json=usernameProto,proto3,casttype=github.com/cockroachdb/cockroach/pkg/security.SQLUsernameProto" json:"username_proto,omitempty"`
	// For consistency with the SQL timestamp type, which has microsecond
	// precision, we avoid the timestamp.Timestamp WKT, which has nanosecond
	// precision, and use microsecond integers directly.
	StartedMicros  int64                                                        `protobuf:"varint,3,opt,name=started_micros,json=startedMicros,proto3" json:"started_micros,omitempty"`
	FinishedMicros int64                                                        `protobuf:"varint,4,opt,name=finished_micros,json=finishedMicros,proto3" json:"finished_micros,omitempty"`
	DescriptorIDs  []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID `protobuf:"varint,6,rep,packed,name=descriptor_ids,json=descriptorIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"descriptor_ids,omitempty"`
	// TODO (lucy): Deprecate the string error field and move to using the encoded
	// errors everywhere.
	Error         string                   `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	ResumeErrors  []*errorspb.EncodedError `protobuf:"bytes,17,rep,name=resume_errors,json=resumeErrors,proto3" json:"resume_errors,omitempty"`
	CleanupErrors []*errorspb.EncodedError `protobuf:"bytes,18,rep,name=cleanup_errors,json=cleanupErrors,proto3" json:"cleanup_errors,omitempty"`
	// FinalResumeError is set when an error occurs that requires the job to be
	// reverted. The error is recorded so it can be handled while reverting, if
	// needed.
	FinalResumeError *errorspb.EncodedError `protobuf:"bytes,19,opt,name=final_resume_error,json=finalResumeError,proto3" json:"final_resume_error,omitempty"`
	Lease            *Lease                 `protobuf:"bytes,9,opt,name=lease,proto3" json:"lease,omitempty"`
	// Noncancelable is used to denote when a job cannot be canceled. This field
	// will not be respected in mixed version clusters where some nodes have
	// a version < 20.1, so it can only be used in cases where all nodes having
	// versions >= 20.1 is guaranteed.
	Noncancelable bool `protobuf:"varint,20,opt,name=noncancelable,proto3" json:"noncancelable,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Payload_Backup
	//	*Payload_Restore
	//	*Payload_SchemaChange
	//	*Payload_Import
	//	*Payload_Changefeed
	//	*Payload_CreateStats
	//	*Payload_SchemaChangeGC
	//	*Payload_TypeSchemaChange
	//	*Payload_StreamIngestion
	//	*Payload_NewSchemaChange
	Details isPayload_Details `protobuf_oneof:"details"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{29}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(dst, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

type isPayload_Details interface {
	isPayload_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Payload_Backup struct {
	Backup *BackupDetails `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Payload_Restore struct {
	Restore *RestoreDetails `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Payload_SchemaChange struct {
	SchemaChange *SchemaChangeDetails `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Payload_Import struct {
	Import *ImportDetails `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Payload_Changefeed struct {
	Changefeed *ChangefeedDetails `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Payload_CreateStats struct {
	CreateStats *CreateStatsDetails `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}
type Payload_SchemaChangeGC struct {
	SchemaChangeGC *SchemaChangeGCDetails `protobuf:"bytes,21,opt,name=schemaChangeGC,proto3,oneof"`
}
type Payload_TypeSchemaChange struct {
	TypeSchemaChange *TypeSchemaChangeDetails `protobuf:"bytes,22,opt,name=typeSchemaChange,proto3,oneof"`
}
type Payload_StreamIngestion struct {
	StreamIngestion *StreamIngestionDetails `protobuf:"bytes,23,opt,name=streamIngestion,proto3,oneof"`
}
type Payload_NewSchemaChange struct {
	NewSchemaChange *NewSchemaChangeDetails `protobuf:"bytes,24,opt,name=newSchemaChange,proto3,oneof"`
}

func (*Payload_Backup) isPayload_Details()           {}
func (*Payload_Restore) isPayload_Details()          {}
func (*Payload_SchemaChange) isPayload_Details()     {}
func (*Payload_Import) isPayload_Details()           {}
func (*Payload_Changefeed) isPayload_Details()       {}
func (*Payload_CreateStats) isPayload_Details()      {}
func (*Payload_SchemaChangeGC) isPayload_Details()   {}
func (*Payload_TypeSchemaChange) isPayload_Details() {}
func (*Payload_StreamIngestion) isPayload_Details()  {}
func (*Payload_NewSchemaChange) isPayload_Details()  {}

func (m *Payload) GetDetails() isPayload_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Payload) GetBackup() *BackupDetails {
	if x, ok := m.GetDetails().(*Payload_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Payload) GetRestore() *RestoreDetails {
	if x, ok := m.GetDetails().(*Payload_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Payload) GetSchemaChange() *SchemaChangeDetails {
	if x, ok := m.GetDetails().(*Payload_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Payload) GetImport() *ImportDetails {
	if x, ok := m.GetDetails().(*Payload_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Payload) GetChangefeed() *ChangefeedDetails {
	if x, ok := m.GetDetails().(*Payload_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Payload) GetCreateStats() *CreateStatsDetails {
	if x, ok := m.GetDetails().(*Payload_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

func (m *Payload) GetSchemaChangeGC() *SchemaChangeGCDetails {
	if x, ok := m.GetDetails().(*Payload_SchemaChangeGC); ok {
		return x.SchemaChangeGC
	}
	return nil
}

func (m *Payload) GetTypeSchemaChange() *TypeSchemaChangeDetails {
	if x, ok := m.GetDetails().(*Payload_TypeSchemaChange); ok {
		return x.TypeSchemaChange
	}
	return nil
}

func (m *Payload) GetStreamIngestion() *StreamIngestionDetails {
	if x, ok := m.GetDetails().(*Payload_StreamIngestion); ok {
		return x.StreamIngestion
	}
	return nil
}

func (m *Payload) GetNewSchemaChange() *NewSchemaChangeDetails {
	if x, ok := m.GetDetails().(*Payload_NewSchemaChange); ok {
		return x.NewSchemaChange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Payload) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Payload_OneofMarshaler, _Payload_OneofUnmarshaler, _Payload_OneofSizer, []interface{}{
		(*Payload_Backup)(nil),
		(*Payload_Restore)(nil),
		(*Payload_SchemaChange)(nil),
		(*Payload_Import)(nil),
		(*Payload_Changefeed)(nil),
		(*Payload_CreateStats)(nil),
		(*Payload_SchemaChangeGC)(nil),
		(*Payload_TypeSchemaChange)(nil),
		(*Payload_StreamIngestion)(nil),
		(*Payload_NewSchemaChange)(nil),
	}
}

func _Payload_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Payload_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Payload_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Payload_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Payload_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Payload_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case *Payload_SchemaChangeGC:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChangeGC); err != nil {
			return err
		}
	case *Payload_TypeSchemaChange:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypeSchemaChange); err != nil {
			return err
		}
	case *Payload_StreamIngestion:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamIngestion); err != nil {
			return err
		}
	case *Payload_NewSchemaChange:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewSchemaChange); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Payload.Details has unexpected type %T", x)
	}
	return nil
}

func _Payload_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Payload)
	switch tag {
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_CreateStats{msg}
		return true, err
	case 21: // details.schemaChangeGC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeGCDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_SchemaChangeGC{msg}
		return true, err
	case 22: // details.typeSchemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeSchemaChangeDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_TypeSchemaChange{msg}
		return true, err
	case 23: // details.streamIngestion
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamIngestionDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_StreamIngestion{msg}
		return true, err
	case 24: // details.newSchemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NewSchemaChangeDetails)
		err := b.DecodeMessage(msg)
		m.Details = &Payload_NewSchemaChange{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Payload_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Payload)
	// details
	switch x := m.Details.(type) {
	case *Payload_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_SchemaChangeGC:
		s := proto.Size(x.SchemaChangeGC)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_TypeSchemaChange:
		s := proto.Size(x.TypeSchemaChange)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_StreamIngestion:
		s := proto.Size(x.StreamIngestion)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Payload_NewSchemaChange:
		s := proto.Size(x.NewSchemaChange)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Progress struct {
	// Types that are valid to be assigned to Progress:
	//	*Progress_FractionCompleted
	//	*Progress_HighWater
	Progress       isProgress_Progress `protobuf_oneof:"progress"`
	ModifiedMicros int64               `protobuf:"varint,2,opt,name=modified_micros,json=modifiedMicros,proto3" json:"modified_micros,omitempty"`
	RunningStatus  string              `protobuf:"bytes,4,opt,name=running_status,json=runningStatus,proto3" json:"running_status,omitempty"`
	// Types that are valid to be assigned to Details:
	//	*Progress_Backup
	//	*Progress_Restore
	//	*Progress_SchemaChange
	//	*Progress_Import
	//	*Progress_Changefeed
	//	*Progress_CreateStats
	//	*Progress_SchemaChangeGC
	//	*Progress_TypeSchemaChange
	//	*Progress_StreamIngest
	//	*Progress_NewSchemaChange
	Details isProgress_Details `protobuf_oneof:"details"`
}

func (m *Progress) Reset()         { *m = Progress{} }
func (m *Progress) String() string { return proto.CompactTextString(m) }
func (*Progress) ProtoMessage()    {}
func (*Progress) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{30}
}
func (m *Progress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Progress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Progress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Progress.Merge(dst, src)
}
func (m *Progress) XXX_Size() int {
	return m.Size()
}
func (m *Progress) XXX_DiscardUnknown() {
	xxx_messageInfo_Progress.DiscardUnknown(m)
}

var xxx_messageInfo_Progress proto.InternalMessageInfo

type isProgress_Progress interface {
	isProgress_Progress()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isProgress_Details interface {
	isProgress_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Progress_FractionCompleted struct {
	FractionCompleted float32 `protobuf:"fixed32,1,opt,name=fraction_completed,json=fractionCompleted,proto3,oneof"`
}
type Progress_HighWater struct {
	HighWater *hlc.Timestamp `protobuf:"bytes,3,opt,name=high_water,json=highWater,proto3,oneof"`
}
type Progress_Backup struct {
	Backup *BackupProgress `protobuf:"bytes,10,opt,name=backup,proto3,oneof"`
}
type Progress_Restore struct {
	Restore *RestoreProgress `protobuf:"bytes,11,opt,name=restore,proto3,oneof"`
}
type Progress_SchemaChange struct {
	SchemaChange *SchemaChangeProgress `protobuf:"bytes,12,opt,name=schemaChange,proto3,oneof"`
}
type Progress_Import struct {
	Import *ImportProgress `protobuf:"bytes,13,opt,name=import,proto3,oneof"`
}
type Progress_Changefeed struct {
	Changefeed *ChangefeedProgress `protobuf:"bytes,14,opt,name=changefeed,proto3,oneof"`
}
type Progress_CreateStats struct {
	CreateStats *CreateStatsProgress `protobuf:"bytes,15,opt,name=createStats,proto3,oneof"`
}
type Progress_SchemaChangeGC struct {
	SchemaChangeGC *SchemaChangeGCProgress `protobuf:"bytes,16,opt,name=schemaChangeGC,proto3,oneof"`
}
type Progress_TypeSchemaChange struct {
	TypeSchemaChange *TypeSchemaChangeProgress `protobuf:"bytes,17,opt,name=typeSchemaChange,proto3,oneof"`
}
type Progress_StreamIngest struct {
	StreamIngest *StreamIngestionProgress `protobuf:"bytes,18,opt,name=streamIngest,proto3,oneof"`
}
type Progress_NewSchemaChange struct {
	NewSchemaChange *NewSchemaChangeProgress `protobuf:"bytes,19,opt,name=newSchemaChange,proto3,oneof"`
}

func (*Progress_FractionCompleted) isProgress_Progress() {}
func (*Progress_HighWater) isProgress_Progress()         {}
func (*Progress_Backup) isProgress_Details()             {}
func (*Progress_Restore) isProgress_Details()            {}
func (*Progress_SchemaChange) isProgress_Details()       {}
func (*Progress_Import) isProgress_Details()             {}
func (*Progress_Changefeed) isProgress_Details()         {}
func (*Progress_CreateStats) isProgress_Details()        {}
func (*Progress_SchemaChangeGC) isProgress_Details()     {}
func (*Progress_TypeSchemaChange) isProgress_Details()   {}
func (*Progress_StreamIngest) isProgress_Details()       {}
func (*Progress_NewSchemaChange) isProgress_Details()    {}

func (m *Progress) GetProgress() isProgress_Progress {
	if m != nil {
		return m.Progress
	}
	return nil
}
func (m *Progress) GetDetails() isProgress_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Progress) GetFractionCompleted() float32 {
	if x, ok := m.GetProgress().(*Progress_FractionCompleted); ok {
		return x.FractionCompleted
	}
	return 0
}

func (m *Progress) GetHighWater() *hlc.Timestamp {
	if x, ok := m.GetProgress().(*Progress_HighWater); ok {
		return x.HighWater
	}
	return nil
}

func (m *Progress) GetBackup() *BackupProgress {
	if x, ok := m.GetDetails().(*Progress_Backup); ok {
		return x.Backup
	}
	return nil
}

func (m *Progress) GetRestore() *RestoreProgress {
	if x, ok := m.GetDetails().(*Progress_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Progress) GetSchemaChange() *SchemaChangeProgress {
	if x, ok := m.GetDetails().(*Progress_SchemaChange); ok {
		return x.SchemaChange
	}
	return nil
}

func (m *Progress) GetImport() *ImportProgress {
	if x, ok := m.GetDetails().(*Progress_Import); ok {
		return x.Import
	}
	return nil
}

func (m *Progress) GetChangefeed() *ChangefeedProgress {
	if x, ok := m.GetDetails().(*Progress_Changefeed); ok {
		return x.Changefeed
	}
	return nil
}

func (m *Progress) GetCreateStats() *CreateStatsProgress {
	if x, ok := m.GetDetails().(*Progress_CreateStats); ok {
		return x.CreateStats
	}
	return nil
}

func (m *Progress) GetSchemaChangeGC() *SchemaChangeGCProgress {
	if x, ok := m.GetDetails().(*Progress_SchemaChangeGC); ok {
		return x.SchemaChangeGC
	}
	return nil
}

func (m *Progress) GetTypeSchemaChange() *TypeSchemaChangeProgress {
	if x, ok := m.GetDetails().(*Progress_TypeSchemaChange); ok {
		return x.TypeSchemaChange
	}
	return nil
}

func (m *Progress) GetStreamIngest() *StreamIngestionProgress {
	if x, ok := m.GetDetails().(*Progress_StreamIngest); ok {
		return x.StreamIngest
	}
	return nil
}

func (m *Progress) GetNewSchemaChange() *NewSchemaChangeProgress {
	if x, ok := m.GetDetails().(*Progress_NewSchemaChange); ok {
		return x.NewSchemaChange
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Progress) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Progress_OneofMarshaler, _Progress_OneofUnmarshaler, _Progress_OneofSizer, []interface{}{
		(*Progress_FractionCompleted)(nil),
		(*Progress_HighWater)(nil),
		(*Progress_Backup)(nil),
		(*Progress_Restore)(nil),
		(*Progress_SchemaChange)(nil),
		(*Progress_Import)(nil),
		(*Progress_Changefeed)(nil),
		(*Progress_CreateStats)(nil),
		(*Progress_SchemaChangeGC)(nil),
		(*Progress_TypeSchemaChange)(nil),
		(*Progress_StreamIngest)(nil),
		(*Progress_NewSchemaChange)(nil),
	}
}

func _Progress_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FractionCompleted)))
	case *Progress_HighWater:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HighWater); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Progress has unexpected type %T", x)
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Backup); err != nil {
			return err
		}
	case *Progress_Restore:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Progress_SchemaChange:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChange); err != nil {
			return err
		}
	case *Progress_Import:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Import); err != nil {
			return err
		}
	case *Progress_Changefeed:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Changefeed); err != nil {
			return err
		}
	case *Progress_CreateStats:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateStats); err != nil {
			return err
		}
	case *Progress_SchemaChangeGC:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SchemaChangeGC); err != nil {
			return err
		}
	case *Progress_TypeSchemaChange:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypeSchemaChange); err != nil {
			return err
		}
	case *Progress_StreamIngest:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamIngest); err != nil {
			return err
		}
	case *Progress_NewSchemaChange:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NewSchemaChange); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Progress.Details has unexpected type %T", x)
	}
	return nil
}

func _Progress_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Progress)
	switch tag {
	case 1: // progress.fraction_completed
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Progress = &Progress_FractionCompleted{math.Float32frombits(uint32(x))}
		return true, err
	case 3: // progress.high_water
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(hlc.Timestamp)
		err := b.DecodeMessage(msg)
		m.Progress = &Progress_HighWater{msg}
		return true, err
	case 10: // details.backup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BackupProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Backup{msg}
		return true, err
	case 11: // details.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Restore{msg}
		return true, err
	case 12: // details.schemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_SchemaChange{msg}
		return true, err
	case 13: // details.import
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ImportProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Import{msg}
		return true, err
	case 14: // details.changefeed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChangefeedProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_Changefeed{msg}
		return true, err
	case 15: // details.createStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateStatsProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_CreateStats{msg}
		return true, err
	case 16: // details.schemaChangeGC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SchemaChangeGCProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_SchemaChangeGC{msg}
		return true, err
	case 17: // details.typeSchemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeSchemaChangeProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_TypeSchemaChange{msg}
		return true, err
	case 18: // details.streamIngest
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamIngestionProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_StreamIngest{msg}
		return true, err
	case 19: // details.newSchemaChange
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NewSchemaChangeProgress)
		err := b.DecodeMessage(msg)
		m.Details = &Progress_NewSchemaChange{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Progress_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Progress)
	// progress
	switch x := m.Progress.(type) {
	case *Progress_FractionCompleted:
		n += 1 // tag and wire
		n += 4
	case *Progress_HighWater:
		s := proto.Size(x.HighWater)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// details
	switch x := m.Details.(type) {
	case *Progress_Backup:
		s := proto.Size(x.Backup)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Restore:
		s := proto.Size(x.Restore)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_SchemaChange:
		s := proto.Size(x.SchemaChange)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Import:
		s := proto.Size(x.Import)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_Changefeed:
		s := proto.Size(x.Changefeed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_CreateStats:
		s := proto.Size(x.CreateStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_SchemaChangeGC:
		s := proto.Size(x.SchemaChangeGC)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_TypeSchemaChange:
		s := proto.Size(x.TypeSchemaChange)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_StreamIngest:
		s := proto.Size(x.StreamIngest)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Progress_NewSchemaChange:
		s := proto.Size(x.NewSchemaChange)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Job struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Keep progress first as it may bre more relevant to see when looking at a
	// running job.
	Progress *Progress `protobuf:"bytes,2,opt,name=progress,proto3" json:"progress,omitempty"`
	Payload  *Payload  `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_jobs_8f6d1b2aa13f3feb, []int{31}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(dst, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Lease)(nil), "cockroach.sql.jobs.jobspb.Lease")
	proto.RegisterType((*BackupEncryptionOptions)(nil), "cockroach.sql.jobs.jobspb.BackupEncryptionOptions")
	proto.RegisterType((*BackupEncryptionOptions_KMSInfo)(nil), "cockroach.sql.jobs.jobspb.BackupEncryptionOptions.KMSInfo")
	proto.RegisterType((*EncryptionInfo)(nil), "cockroach.sql.jobs.jobspb.EncryptionInfo")
	proto.RegisterMapType((map[string][]byte)(nil), "cockroach.sql.jobs.jobspb.EncryptionInfo.EncryptedDataKeyByKMSMasterKeyIDEntry")
	proto.RegisterType((*StreamIngestionDetails)(nil), "cockroach.sql.jobs.jobspb.StreamIngestionDetails")
	proto.RegisterType((*StreamIngestionProgress)(nil), "cockroach.sql.jobs.jobspb.StreamIngestionProgress")
	proto.RegisterType((*BackupDetails)(nil), "cockroach.sql.jobs.jobspb.BackupDetails")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.BackupDetails.UrisByLocalityKvEntry")
	proto.RegisterType((*BackupProgress)(nil), "cockroach.sql.jobs.jobspb.BackupProgress")
	proto.RegisterType((*RestoreDetails)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID]*RestoreDetails_DescriptorRewrite)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.DescriptorRewritesEntry")
	proto.RegisterType((*RestoreDetails_DescriptorRewrite)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.DescriptorRewrite")
	proto.RegisterType((*RestoreDetails_BackupLocalityInfo)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.BackupLocalityInfo")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.RestoreDetails.BackupLocalityInfo.UrisByOriginalLocalityKvEntry")
	proto.RegisterType((*RestoreProgress)(nil), "cockroach.sql.jobs.jobspb.RestoreProgress")
	proto.RegisterType((*ImportDetails)(nil), "cockroach.sql.jobs.jobspb.ImportDetails")
	proto.RegisterType((*ImportDetails_Table)(nil), "cockroach.sql.jobs.jobspb.ImportDetails.Table")
	proto.RegisterType((*SequenceValChunk)(nil), "cockroach.sql.jobs.jobspb.SequenceValChunk")
	proto.RegisterType((*SequenceDetails)(nil), "cockroach.sql.jobs.jobspb.SequenceDetails")
	proto.RegisterMapType((map[int32]*SequenceDetails_SequenceChunks)(nil), "cockroach.sql.jobs.jobspb.SequenceDetails.SeqIdToChunksEntry")
	proto.RegisterType((*SequenceDetails_SequenceChunks)(nil), "cockroach.sql.jobs.jobspb.SequenceDetails.SequenceChunks")
	proto.RegisterType((*ImportProgress)(nil), "cockroach.sql.jobs.jobspb.ImportProgress")
	proto.RegisterType((*TypeSchemaChangeDetails)(nil), "cockroach.sql.jobs.jobspb.TypeSchemaChangeDetails")
	proto.RegisterType((*TypeSchemaChangeProgress)(nil), "cockroach.sql.jobs.jobspb.TypeSchemaChangeProgress")
	proto.RegisterType((*NewSchemaChangeDetails)(nil), "cockroach.sql.jobs.jobspb.NewSchemaChangeDetails")
	proto.RegisterType((*NewSchemaChangeProgress)(nil), "cockroach.sql.jobs.jobspb.NewSchemaChangeProgress")
	proto.RegisterType((*ResumeSpanList)(nil), "cockroach.sql.jobs.jobspb.ResumeSpanList")
	proto.RegisterType((*DroppedTableDetails)(nil), "cockroach.sql.jobs.jobspb.DroppedTableDetails")
	proto.RegisterType((*SchemaChangeGCDetails)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCDetails")
	proto.RegisterType((*SchemaChangeGCDetails_DroppedIndex)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCDetails.DroppedIndex")
	proto.RegisterType((*SchemaChangeGCDetails_DroppedID)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCDetails.DroppedID")
	proto.RegisterType((*SchemaChangeGCDetails_DroppedTenant)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCDetails.DroppedTenant")
	proto.RegisterType((*SchemaChangeDetails)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeDetails")
	proto.RegisterType((*SchemaChangeProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeProgress")
	proto.RegisterType((*SchemaChangeGCProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCProgress")
	proto.RegisterType((*SchemaChangeGCProgress_IndexProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCProgress.IndexProgress")
	proto.RegisterType((*SchemaChangeGCProgress_TableProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCProgress.TableProgress")
	proto.RegisterType((*SchemaChangeGCProgress_TenantProgress)(nil), "cockroach.sql.jobs.jobspb.SchemaChangeGCProgress.TenantProgress")
	proto.RegisterType((*ChangefeedTarget)(nil), "cockroach.sql.jobs.jobspb.ChangefeedTarget")
	proto.RegisterType((*ChangefeedDetails)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails.OptsEntry")
	proto.RegisterMapType((ChangefeedTargets)(nil), "cockroach.sql.jobs.jobspb.ChangefeedDetails.TargetsEntry")
	proto.RegisterType((*ResolvedSpan)(nil), "cockroach.sql.jobs.jobspb.ResolvedSpan")
	proto.RegisterType((*ChangefeedProgress)(nil), "cockroach.sql.jobs.jobspb.ChangefeedProgress")
	proto.RegisterType((*CreateStatsDetails)(nil), "cockroach.sql.jobs.jobspb.CreateStatsDetails")
	proto.RegisterType((*CreateStatsDetails_ColStat)(nil), "cockroach.sql.jobs.jobspb.CreateStatsDetails.ColStat")
	proto.RegisterType((*CreateStatsProgress)(nil), "cockroach.sql.jobs.jobspb.CreateStatsProgress")
	proto.RegisterType((*Payload)(nil), "cockroach.sql.jobs.jobspb.Payload")
	proto.RegisterType((*Progress)(nil), "cockroach.sql.jobs.jobspb.Progress")
	proto.RegisterType((*Job)(nil), "cockroach.sql.jobs.jobspb.Job")
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.EncryptionMode", EncryptionMode_name, EncryptionMode_value)
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.Status", Status_name, Status_value)
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.Type", Type_name, Type_value)
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.EncryptionInfo_Scheme", EncryptionInfo_Scheme_name, EncryptionInfo_Scheme_value)
	proto.RegisterEnum("cockroach.sql.jobs.jobspb.SchemaChangeGCProgress_Status", SchemaChangeGCProgress_Status_name, SchemaChangeGCProgress_Status_value)
}
func (this *Lease) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Lease)
	if !ok {
		that2, ok := that.(Lease)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	return true
}
func (this *BackupEncryptionOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BackupEncryptionOptions)
	if !ok {
		that2, ok := that.(BackupEncryptionOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.KMSInfo.Equal(that1.KMSInfo) {
		return false
	}
	return true
}
func (this *BackupEncryptionOptions_KMSInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BackupEncryptionOptions_KMSInfo)
	if !ok {
		that2, ok := that.(BackupEncryptionOptions_KMSInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if !bytes.Equal(this.EncryptedDataKey, that1.EncryptedDataKey) {
		return false
	}
	return true
}
func (this *EncryptionInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptionInfo)
	if !ok {
		that2, ok := that.(EncryptionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if !bytes.Equal(this.Salt, that1.Salt) {
		return false
	}
	if len(this.EncryptedDataKeyByKMSMasterKeyID) != len(that1.EncryptedDataKeyByKMSMasterKeyID) {
		return false
	}
	for i := range this.EncryptedDataKeyByKMSMasterKeyID {
		if !bytes.Equal(this.EncryptedDataKeyByKMSMasterKeyID[i], that1.EncryptedDataKeyByKMSMasterKeyID[i]) {
			return false
		}
	}
	return true
}
func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *BackupEncryptionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupEncryptionOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Mode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Mode))
	}
	if m.KMSInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.KMSInfo.Size()))
		n1, err := m.KMSInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *BackupEncryptionOptions_KMSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupEncryptionOptions_KMSInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.EncryptedDataKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.EncryptedDataKey)))
		i += copy(dAtA[i:], m.EncryptedDataKey)
	}
	return i, nil
}

func (m *EncryptionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Scheme != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Scheme))
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if len(m.EncryptedDataKeyByKMSMasterKeyID) > 0 {
		keysForEncryptedDataKeyByKMSMasterKeyID := make([]string, 0, len(m.EncryptedDataKeyByKMSMasterKeyID))
		for k := range m.EncryptedDataKeyByKMSMasterKeyID {
			keysForEncryptedDataKeyByKMSMasterKeyID = append(keysForEncryptedDataKeyByKMSMasterKeyID, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEncryptedDataKeyByKMSMasterKeyID)
		for _, k := range keysForEncryptedDataKeyByKMSMasterKeyID {
			dAtA[i] = 0x1a
			i++
			v := m.EncryptedDataKeyByKMSMasterKeyID[string(k)]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovJobs(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + byteSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *StreamIngestionDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreamAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.StreamAddress)))
		i += copy(dAtA[i:], m.StreamAddress)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Span.Size()))
	n2, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StartTime.Size()))
	n3, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *StreamIngestionProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BackupDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StartTime.Size()))
	n4, err := m.StartTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n5, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.URI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.URI)))
		i += copy(dAtA[i:], m.URI)
	}
	if len(m.DeprecatedBackupManifest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.DeprecatedBackupManifest)))
		i += copy(dAtA[i:], m.DeprecatedBackupManifest)
	}
	if len(m.URIsByLocalityKV) > 0 {
		keysForURIsByLocalityKV := make([]string, 0, len(m.URIsByLocalityKV))
		for k := range m.URIsByLocalityKV {
			keysForURIsByLocalityKV = append(keysForURIsByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByLocalityKV)
		for _, k := range keysForURIsByLocalityKV {
			dAtA[i] = 0x2a
			i++
			v := m.URIsByLocalityKV[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.EncryptionOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.EncryptionOptions.Size()))
		n6, err := m.EncryptionOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ProtectedTimestampRecord != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ProtectedTimestampRecord.Size()))
		n7, err := m.ProtectedTimestampRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.CollectionURI) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.CollectionURI)))
		i += copy(dAtA[i:], m.CollectionURI)
	}
	if m.EncryptionInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.EncryptionInfo.Size()))
		n8, err := m.EncryptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *BackupProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RestoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DescriptorRewrites) > 0 {
		keysForDescriptorRewrites := make([]uint32, 0, len(m.DescriptorRewrites))
		for k := range m.DescriptorRewrites {
			keysForDescriptorRewrites = append(keysForDescriptorRewrites, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForDescriptorRewrites)
		for _, k := range keysForDescriptorRewrites {
			dAtA[i] = 0x12
			i++
			v := m.DescriptorRewrites[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.EndTime.Size()))
	n10, err := m.EndTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.TableDescs) > 0 {
		for _, msg := range m.TableDescs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OverrideDB) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.OverrideDB)))
		i += copy(dAtA[i:], m.OverrideDB)
	}
	if len(m.BackupLocalityInfo) > 0 {
		for _, msg := range m.BackupLocalityInfo {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PrepareCompleted {
		dAtA[i] = 0x40
		i++
		if m.PrepareCompleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StatsInserted {
		dAtA[i] = 0x48
		i++
		if m.StatsInserted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DescriptorsPublished {
		dAtA[i] = 0x50
		i++
		if m.DescriptorsPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DescriptorCoverage != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Encryption.Size()))
		n11, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Tenants) > 0 {
		for _, msg := range m.Tenants {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TypeDescs) > 0 {
		for _, msg := range m.TypeDescs {
			dAtA[i] = 0x72
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SchemaDescs) > 0 {
		for _, msg := range m.SchemaDescs {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DatabaseDescs) > 0 {
		for _, msg := range m.DatabaseDescs {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RestoreDetails_DescriptorRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails_DescriptorRewrite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	if m.ToExisting {
		dAtA[i] = 0x18
		i++
		if m.ToExisting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RestoreDetails_BackupLocalityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDetails_BackupLocalityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URIsByOriginalLocalityKV) > 0 {
		keysForURIsByOriginalLocalityKV := make([]string, 0, len(m.URIsByOriginalLocalityKV))
		for k := range m.URIsByOriginalLocalityKV {
			keysForURIsByOriginalLocalityKV = append(keysForURIsByOriginalLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByOriginalLocalityKV)
		for _, k := range keysForURIsByOriginalLocalityKV {
			dAtA[i] = 0xa
			i++
			v := m.URIsByOriginalLocalityKV[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *RestoreProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HighWater) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.HighWater)))
		i += copy(dAtA[i:], m.HighWater)
	}
	return i, nil
}

func (m *ImportDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Format.Size()))
	n12, err := m.Format.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.SSTSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	if len(m.BackupPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.BackupPath)))
		i += copy(dAtA[i:], m.BackupPath)
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			dAtA[i] = 0x42
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Oversample != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Oversample))
	}
	if m.SkipFKs {
		dAtA[i] = 0x50
		i++
		if m.SkipFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IngestDirectly {
		dAtA[i] = 0x58
		i++
		if m.IngestDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrepareComplete {
		dAtA[i] = 0x60
		i++
		if m.PrepareComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TablesPublished {
		dAtA[i] = 0x68
		i++
		if m.TablesPublished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ParseBundleSchema {
		dAtA[i] = 0x70
		i++
		if m.ParseBundleSchema {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProtectedTimestampRecord != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ProtectedTimestampRecord.Size()))
		n13, err := m.ProtectedTimestampRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ImportDetails_Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDetails_Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Desc.Size()))
		n14, err := m.Desc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.SeqVal != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SeqVal))
	}
	if m.IsNew {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.WasEmpty {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.WasEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SequenceValChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceValChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkStartVal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ChunkStartVal))
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ChunkSize))
	}
	if m.ChunkStartRow != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ChunkStartRow))
	}
	if m.NextChunkStartRow != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NextChunkStartRow))
	}
	return i, nil
}

func (m *SequenceDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeqIdToChunks) > 0 {
		keysForSeqIdToChunks := make([]int32, 0, len(m.SeqIdToChunks))
		for k := range m.SeqIdToChunks {
			keysForSeqIdToChunks = append(keysForSeqIdToChunks, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForSeqIdToChunks)
		for _, k := range keysForSeqIdToChunks {
			dAtA[i] = 0xa
			i++
			v := m.SeqIdToChunks[int32(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintJobs(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	return i, nil
}

func (m *SequenceDetails_SequenceChunks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceDetails_SequenceChunks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImportProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SamplingProgress)*4))
		for _, num := range m.SamplingProgress {
			f16 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f16))
			i += 4
		}
	}
	if len(m.ReadProgress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.ReadProgress)*4))
		for _, num := range m.ReadProgress {
			f17 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f17))
			i += 4
		}
	}
	if len(m.WriteProgress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.WriteProgress)*4))
		for _, num := range m.WriteProgress {
			f18 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f18))
			i += 4
		}
	}
	if len(m.SpanProgress) > 0 {
		for _, msg := range m.SpanProgress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResumePos) > 0 {
		dAtA20 := make([]byte, len(m.ResumePos)*10)
		var j19 int
		for _, num1 := range m.ResumePos {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.SequenceDetails) > 0 {
		for _, msg := range m.SequenceDetails {
			dAtA[i] = 0x32
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TypeSchemaChangeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeSchemaChangeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TypeID))
	}
	return i, nil
}

func (m *TypeSchemaChangeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeSchemaChangeProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NewSchemaChangeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewSchemaChangeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, msg := range m.Targets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NewSchemaChangeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewSchemaChangeProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.States) > 0 {
		dAtA22 := make([]byte, len(m.States)*10)
		var j21 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	return i, nil
}

func (m *ResumeSpanList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeSpanList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, msg := range m.ResumeSpans {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DroppedTableDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DroppedTableDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ParentID))
	}
	if m.InterleavedTable != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.InterleavedTable.Size()))
		n23, err := m.InterleavedTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.InterleavedIndexes) > 0 {
		for _, msg := range m.InterleavedIndexes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tenant != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Tenant.Size()))
		n24, err := m.Tenant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *SchemaChangeGCDetails_DroppedIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails_DroppedIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.IndexID))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails_DroppedID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails_DroppedID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *SchemaChangeGCDetails_DroppedTenant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCDetails_DroppedTenant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.DropTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DropTime))
	}
	return i, nil
}

func (m *SchemaChangeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, msg := range m.ResumeSpanList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, msg := range m.DroppedTables {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DroppedDatabaseID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DroppedDatabaseID))
	}
	if m.DescID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.DescID))
	}
	if m.TableMutationID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TableMutationID))
	}
	if m.FormatVersion != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FormatVersion))
	}
	if len(m.DroppedTypes) > 0 {
		dAtA26 := make([]byte, len(m.DroppedTypes)*10)
		var j25 int
		for _, num := range m.DroppedTypes {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if len(m.DroppedSchemas) > 0 {
		dAtA28 := make([]byte, len(m.DroppedSchemas)*10)
		var j27 int
		for _, num := range m.DroppedSchemas {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	return i, nil
}

func (m *SchemaChangeProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SchemaChangeGCProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tables) > 0 {
		for _, msg := range m.Tables {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tenant != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Tenant.Size()))
		n29, err := m.Tenant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *SchemaChangeGCProgress_IndexProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress_IndexProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.IndexID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeGCProgress_TableProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress_TableProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SchemaChangeGCProgress_TenantProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChangeGCProgress_TenantProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *ChangefeedTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedTarget) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatementTimeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.StatementTimeName)))
		i += copy(dAtA[i:], m.StatementTimeName)
	}
	return i, nil
}

func (m *ChangefeedDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SinkURI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.SinkURI)))
		i += copy(dAtA[i:], m.SinkURI)
	}
	if len(m.Opts) > 0 {
		keysForOpts := make([]string, 0, len(m.Opts))
		for k := range m.Opts {
			keysForOpts = append(keysForOpts, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOpts)
		for _, k := range keysForOpts {
			dAtA[i] = 0x22
			i++
			v := m.Opts[string(k)]
			mapSize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Targets) > 0 {
		keysForTargets := make([]uint32, 0, len(m.Targets))
		for k := range m.Targets {
			keysForTargets = append(keysForTargets, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForTargets)
		for _, k := range keysForTargets {
			dAtA[i] = 0x32
			i++
			v := m.Targets[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovJobs(uint64(msgSize))
			}
			mapSize := 1 + sovJobs(uint64(k)) + msgSize
			i = encodeVarintJobs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintJobs(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64((&v).Size()))
			n30, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n30
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.StatementTime.Size()))
	n31, err := m.StatementTime.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	return i, nil
}

func (m *ResolvedSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolvedSpan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Span.Size()))
	n32, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Timestamp.Size()))
	n33, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if m.BoundaryReached {
		dAtA[i] = 0x18
		i++
		if m.BoundaryReached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChangefeedProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, msg := range m.ResolvedSpans {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.ProtectedTimestampRecord.Size()))
	n34, err := m.ProtectedTimestampRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	return i, nil
}

func (m *CreateStatsDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobs(dAtA, i, uint64(m.Table.Size()))
	n35, err := m.Table.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	if len(m.ColumnStats) > 0 {
		for _, msg := range m.ColumnStats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.AsOf != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.AsOf.Size()))
		n36, err := m.AsOf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.FQTableName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.FQTableName)))
		i += copy(dAtA[i:], m.FQTableName)
	}
	if m.MaxFractionIdle != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFractionIdle))))
		i += 8
	}
	return i, nil
}

func (m *CreateStatsDetails_ColStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsDetails_ColStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA38 := make([]byte, len(m.ColumnIDs)*10)
		var j37 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if m.HasHistogram {
		dAtA[i] = 0x10
		i++
		if m.HasHistogram {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Inverted {
		dAtA[i] = 0x18
		i++
		if m.Inverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HistogramMaxBuckets != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.HistogramMaxBuckets))
	}
	return i, nil
}

func (m *CreateStatsProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatsProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.UsernameProto) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.UsernameProto)))
		i += copy(dAtA[i:], m.UsernameProto)
	}
	if m.StartedMicros != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		dAtA40 := make([]byte, len(m.DescriptorIDs)*10)
		var j39 int
		for _, num := range m.DescriptorIDs {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobs(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Lease != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Lease.Size()))
		n41, err := m.Lease.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Details != nil {
		nn42, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if len(m.ResumeErrors) > 0 {
		for _, msg := range m.ResumeErrors {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CleanupErrors) > 0 {
		for _, msg := range m.CleanupErrors {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintJobs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FinalResumeError != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.FinalResumeError.Size()))
		n43, err := m.FinalResumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Noncancelable {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Noncancelable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Payload_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n44, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *Payload_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n45, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *Payload_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n46, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *Payload_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n47, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *Payload_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n48, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *Payload_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n49, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *Payload_SchemaChangeGC) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChangeGC != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChangeGC.Size()))
		n50, err := m.SchemaChangeGC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}
func (m *Payload_TypeSchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TypeSchemaChange != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TypeSchemaChange.Size()))
		n51, err := m.TypeSchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}
func (m *Payload_StreamIngestion) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StreamIngestion != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.StreamIngestion.Size()))
		n52, err := m.StreamIngestion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}
func (m *Payload_NewSchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewSchemaChange != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NewSchemaChange.Size()))
		n53, err := m.NewSchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}
func (m *Progress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Progress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Progress != nil {
		nn54, err := m.Progress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn54
	}
	if m.ModifiedMicros != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.ModifiedMicros))
	}
	if len(m.RunningStatus) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobs(dAtA, i, uint64(len(m.RunningStatus)))
		i += copy(dAtA[i:], m.RunningStatus)
	}
	if m.Details != nil {
		nn55, err := m.Details.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn55
	}
	return i, nil
}

func (m *Progress_FractionCompleted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FractionCompleted))))
	i += 4
	return i, nil
}
func (m *Progress_HighWater) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HighWater != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.HighWater.Size()))
		n56, err := m.HighWater.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *Progress_Backup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Backup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Backup.Size()))
		n57, err := m.Backup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *Progress_Restore) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Restore != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Restore.Size()))
		n58, err := m.Restore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *Progress_SchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChange != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChange.Size()))
		n59, err := m.SchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *Progress_Import) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Import != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Import.Size()))
		n60, err := m.Import.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *Progress_Changefeed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Changefeed != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Changefeed.Size()))
		n61, err := m.Changefeed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *Progress_CreateStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateStats != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.CreateStats.Size()))
		n62, err := m.CreateStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *Progress_SchemaChangeGC) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SchemaChangeGC != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.SchemaChangeGC.Size()))
		n63, err := m.SchemaChangeGC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *Progress_TypeSchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TypeSchemaChange != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.TypeSchemaChange.Size()))
		n64, err := m.TypeSchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *Progress_StreamIngest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StreamIngest != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.StreamIngest.Size()))
		n65, err := m.StreamIngest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *Progress_NewSchemaChange) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NewSchemaChange != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.NewSchemaChange.Size()))
		n66, err := m.NewSchemaChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}
func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Id))
	}
	if m.Progress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Progress.Size()))
		n67, err := m.Progress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.Payload != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobs(dAtA, i, uint64(m.Payload.Size()))
		n68, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func encodeVarintJobs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovJobs(uint64(m.NodeID))
	}
	if m.Epoch != 0 {
		n += 1 + sovJobs(uint64(m.Epoch))
	}
	return n
}

func (m *BackupEncryptionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovJobs(uint64(m.Mode))
	}
	if m.KMSInfo != nil {
		l = m.KMSInfo.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *BackupEncryptionOptions_KMSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.EncryptedDataKey)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *EncryptionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheme != 0 {
		n += 1 + sovJobs(uint64(m.Scheme))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.EncryptedDataKeyByKMSMasterKeyID) > 0 {
		for k, v := range m.EncryptedDataKeyByKMSMasterKeyID {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovJobs(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StreamIngestionDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreamAddress)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = m.Span.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.StartTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	return n
}

func (m *StreamIngestionProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BackupDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.DeprecatedBackupManifest)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.URIsByLocalityKV) > 0 {
		for k, v := range m.URIsByLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if m.EncryptionOptions != nil {
		l = m.EncryptionOptions.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.ProtectedTimestampRecord != nil {
		l = m.ProtectedTimestampRecord.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.CollectionURI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.EncryptionInfo != nil {
		l = m.EncryptionInfo.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *BackupProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RestoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DescriptorRewrites) > 0 {
		for k, v := range m.DescriptorRewrites {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJobs(uint64(l))
			}
			mapEntrySize := 1 + sovJobs(uint64(k)) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.EndTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.TableDescs) > 0 {
		for _, e := range m.TableDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.OverrideDB)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.BackupLocalityInfo) > 0 {
		for _, e := range m.BackupLocalityInfo {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.PrepareCompleted {
		n += 2
	}
	if m.StatsInserted {
		n += 2
	}
	if m.DescriptorsPublished {
		n += 2
	}
	if m.DescriptorCoverage != 0 {
		n += 1 + sovJobs(uint64(m.DescriptorCoverage))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Tenants) > 0 {
		for _, e := range m.Tenants {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.TypeDescs) > 0 {
		for _, e := range m.TypeDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.SchemaDescs) > 0 {
		for _, e := range m.SchemaDescs {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.DatabaseDescs) > 0 {
		for _, e := range m.DatabaseDescs {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *RestoreDetails_DescriptorRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	if m.ToExisting {
		n += 2
	}
	return n
}

func (m *RestoreDetails_BackupLocalityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.URIsByOriginalLocalityKV) > 0 {
		for k, v := range m.URIsByOriginalLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RestoreProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HighWater)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ImportDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.SSTSize != 0 {
		n += 1 + sovJobs(uint64(m.SSTSize))
	}
	if m.Walltime != 0 {
		n += 1 + sovJobs(uint64(m.Walltime))
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	l = len(m.BackupPath)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Samples) > 0 {
		for _, b := range m.Samples {
			l = len(b)
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.Oversample != 0 {
		n += 1 + sovJobs(uint64(m.Oversample))
	}
	if m.SkipFKs {
		n += 2
	}
	if m.IngestDirectly {
		n += 2
	}
	if m.PrepareComplete {
		n += 2
	}
	if m.TablesPublished {
		n += 2
	}
	if m.ParseBundleSchema {
		n += 2
	}
	if m.ProtectedTimestampRecord != nil {
		l = m.ProtectedTimestampRecord.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ImportDetails_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.SeqVal != 0 {
		n += 2 + sovJobs(uint64(m.SeqVal))
	}
	if m.IsNew {
		n += 3
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if m.WasEmpty {
		n += 3
	}
	return n
}

func (m *SequenceValChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkStartVal != 0 {
		n += 1 + sovJobs(uint64(m.ChunkStartVal))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovJobs(uint64(m.ChunkSize))
	}
	if m.ChunkStartRow != 0 {
		n += 1 + sovJobs(uint64(m.ChunkStartRow))
	}
	if m.NextChunkStartRow != 0 {
		n += 1 + sovJobs(uint64(m.NextChunkStartRow))
	}
	return n
}

func (m *SequenceDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SeqIdToChunks) > 0 {
		for k, v := range m.SeqIdToChunks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJobs(uint64(l))
			}
			mapEntrySize := 1 + sovJobs(uint64(k)) + l
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SequenceDetails_SequenceChunks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *ImportProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SamplingProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.SamplingProgress)*4)) + len(m.SamplingProgress)*4
	}
	if len(m.ReadProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.ReadProgress)*4)) + len(m.ReadProgress)*4
	}
	if len(m.WriteProgress) > 0 {
		n += 1 + sovJobs(uint64(len(m.WriteProgress)*4)) + len(m.WriteProgress)*4
	}
	if len(m.SpanProgress) > 0 {
		for _, e := range m.SpanProgress {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.ResumePos) > 0 {
		l = 0
		for _, e := range m.ResumePos {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	if len(m.SequenceDetails) > 0 {
		for _, e := range m.SequenceDetails {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *TypeSchemaChangeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovJobs(uint64(m.TypeID))
	}
	return n
}

func (m *TypeSchemaChangeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NewSchemaChangeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *NewSchemaChangeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	return n
}

func (m *ResumeSpanList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpans) > 0 {
		for _, e := range m.ResumeSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	return n
}

func (m *DroppedTableDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeGCDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.ParentID != 0 {
		n += 1 + sovJobs(uint64(m.ParentID))
	}
	if m.InterleavedTable != nil {
		l = m.InterleavedTable.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.InterleavedIndexes) > 0 {
		for _, e := range m.InterleavedIndexes {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.Tenant != nil {
		l = m.Tenant.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *SchemaChangeGCDetails_DroppedIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexID != 0 {
		n += 1 + sovJobs(uint64(m.IndexID))
	}
	if m.DropTime != 0 {
		n += 1 + sovJobs(uint64(m.DropTime))
	}
	return n
}

func (m *SchemaChangeGCDetails_DroppedID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.DropTime != 0 {
		n += 1 + sovJobs(uint64(m.DropTime))
	}
	return n
}

func (m *SchemaChangeGCDetails_DroppedTenant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.DropTime != 0 {
		n += 1 + sovJobs(uint64(m.DropTime))
	}
	return n
}

func (m *SchemaChangeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResumeSpanList) > 0 {
		for _, e := range m.ResumeSpanList {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.DroppedTables) > 0 {
		for _, e := range m.DroppedTables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.DroppedDatabaseID != 0 {
		n += 1 + sovJobs(uint64(m.DroppedDatabaseID))
	}
	if m.DescID != 0 {
		n += 1 + sovJobs(uint64(m.DescID))
	}
	if m.TableMutationID != 0 {
		n += 1 + sovJobs(uint64(m.TableMutationID))
	}
	if m.FormatVersion != 0 {
		n += 1 + sovJobs(uint64(m.FormatVersion))
	}
	if len(m.DroppedTypes) > 0 {
		l = 0
		for _, e := range m.DroppedTypes {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	if len(m.DroppedSchemas) > 0 {
		l = 0
		for _, e := range m.DroppedSchemas {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	return n
}

func (m *SchemaChangeProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SchemaChangeGCProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	if m.Tenant != nil {
		l = m.Tenant.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *SchemaChangeGCProgress_IndexProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexID != 0 {
		n += 1 + sovJobs(uint64(m.IndexID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeGCProgress_TableProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovJobs(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *SchemaChangeGCProgress_TenantProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovJobs(uint64(m.Status))
	}
	return n
}

func (m *ChangefeedTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StatementTimeName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func (m *ChangefeedDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SinkURI)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if len(m.Opts) > 0 {
		for k, v := range m.Opts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobs(uint64(len(k))) + 1 + len(v) + sovJobs(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	if len(m.Targets) > 0 {
		for k, v := range m.Targets {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovJobs(uint64(k)) + 1 + l + sovJobs(uint64(l))
			n += mapEntrySize + 1 + sovJobs(uint64(mapEntrySize))
		}
	}
	l = m.StatementTime.Size()
	n += 1 + l + sovJobs(uint64(l))
	return n
}

func (m *ResolvedSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovJobs(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovJobs(uint64(l))
	if m.BoundaryReached {
		n += 2
	}
	return n
}

func (m *ChangefeedProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResolvedSpans) > 0 {
		for _, e := range m.ResolvedSpans {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = m.ProtectedTimestampRecord.Size()
	n += 1 + l + sovJobs(uint64(l))
	return n
}

func (m *CreateStatsDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = m.Table.Size()
	n += 1 + l + sovJobs(uint64(l))
	if len(m.ColumnStats) > 0 {
		for _, e := range m.ColumnStats {
			l = e.Size()
			n += 1 + l + sovJobs(uint64(l))
		}
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.AsOf != nil {
		l = m.AsOf.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.FQTableName)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.MaxFractionIdle != 0 {
		n += 9
	}
	return n
}

func (m *CreateStatsDetails_ColStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	if m.HasHistogram {
		n += 2
	}
	if m.Inverted {
		n += 2
	}
	if m.HistogramMaxBuckets != 0 {
		n += 1 + sovJobs(uint64(m.HistogramMaxBuckets))
	}
	return n
}

func (m *CreateStatsProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	l = len(m.UsernameProto)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.StartedMicros != 0 {
		n += 1 + sovJobs(uint64(m.StartedMicros))
	}
	if m.FinishedMicros != 0 {
		n += 1 + sovJobs(uint64(m.FinishedMicros))
	}
	if len(m.DescriptorIDs) > 0 {
		l = 0
		for _, e := range m.DescriptorIDs {
			l += sovJobs(uint64(e))
		}
		n += 1 + sovJobs(uint64(l)) + l
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	l = len(m.Statement)
	if l > 0 {
		n += 2 + l + sovJobs(uint64(l))
	}
	if len(m.ResumeErrors) > 0 {
		for _, e := range m.ResumeErrors {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if len(m.CleanupErrors) > 0 {
		for _, e := range m.CleanupErrors {
			l = e.Size()
			n += 2 + l + sovJobs(uint64(l))
		}
	}
	if m.FinalResumeError != nil {
		l = m.FinalResumeError.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	if m.Noncancelable {
		n += 3
	}
	return n
}

func (m *Payload_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_SchemaChangeGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChangeGC != nil {
		l = m.SchemaChangeGC.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_TypeSchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeSchemaChange != nil {
		l = m.TypeSchemaChange.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_StreamIngestion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamIngestion != nil {
		l = m.StreamIngestion.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Payload_NewSchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewSchemaChange != nil {
		l = m.NewSchemaChange.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Progress != nil {
		n += m.Progress.Size()
	}
	if m.ModifiedMicros != 0 {
		n += 1 + sovJobs(uint64(m.ModifiedMicros))
	}
	l = len(m.RunningStatus)
	if l > 0 {
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Details != nil {
		n += m.Details.Size()
	}
	return n
}

func (m *Progress_FractionCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Progress_HighWater) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HighWater != nil {
		l = m.HighWater.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Backup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backup != nil {
		l = m.Backup.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Restore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Restore != nil {
		l = m.Restore.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_SchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChange != nil {
		l = m.SchemaChange.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Import) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Import != nil {
		l = m.Import.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_Changefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Changefeed != nil {
		l = m.Changefeed.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_CreateStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStats != nil {
		l = m.CreateStats.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_SchemaChangeGC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChangeGC != nil {
		l = m.SchemaChangeGC.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_TypeSchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeSchemaChange != nil {
		l = m.TypeSchemaChange.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_StreamIngest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamIngest != nil {
		l = m.StreamIngest.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Progress_NewSchemaChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewSchemaChange != nil {
		l = m.NewSchemaChange.Size()
		n += 2 + l + sovJobs(uint64(l))
	}
	return n
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovJobs(uint64(m.Id))
	}
	if m.Progress != nil {
		l = m.Progress.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovJobs(uint64(l))
	}
	return n
}

func sovJobs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozJobs(x uint64) (n int) {
	return sovJobs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupEncryptionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupEncryptionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupEncryptionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (EncryptionMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KMSInfo == nil {
				m.KMSInfo = &BackupEncryptionOptions_KMSInfo{}
			}
			if err := m.KMSInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupEncryptionOptions_KMSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KMSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KMSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedDataKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedDataKey = append(m.EncryptedDataKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedDataKey == nil {
				m.EncryptedDataKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= (EncryptionInfo_Scheme(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedDataKeyByKMSMasterKeyID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptedDataKeyByKMSMasterKeyID == nil {
				m.EncryptedDataKeyByKMSMasterKeyID = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthJobs
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EncryptedDataKeyByKMSMasterKeyID[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamAddress = github_com_cockroachdb_cockroach_pkg_ccl_streamingccl.StreamAddress(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedBackupManifest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedBackupManifest = append(m.DeprecatedBackupManifest[:0], dAtA[iNdEx:postIndex]...)
			if m.DeprecatedBackupManifest == nil {
				m.DeprecatedBackupManifest = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByLocalityKV == nil {
				m.URIsByLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionOptions == nil {
				m.EncryptionOptions = &BackupEncryptionOptions{}
			}
			if err := m.EncryptionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestampRecord", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.ProtectedTimestampRecord = &v
			if err := m.ProtectedTimestampRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionInfo == nil {
				m.EncryptionInfo = &EncryptionInfo{}
			}
			if err := m.EncryptionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorRewrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DescriptorRewrites == nil {
				m.DescriptorRewrites = make(map[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID]*RestoreDetails_DescriptorRewrite)
			}
			var mapkey uint32
			var mapvalue *RestoreDetails_DescriptorRewrite
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RestoreDetails_DescriptorRewrite{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DescriptorRewrites[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDescs = append(m.TableDescs, &descpb.TableDescriptor{})
			if err := m.TableDescs[len(m.TableDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideDB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideDB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupLocalityInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupLocalityInfo = append(m.BackupLocalityInfo, RestoreDetails_BackupLocalityInfo{})
			if err := m.BackupLocalityInfo[len(m.BackupLocalityInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareCompleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareCompleted = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsInserted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsInserted = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorsPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DescriptorsPublished = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorCoverage", wireType)
			}
			m.DescriptorCoverage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorCoverage |= (github_com_cockroachdb_cockroach_pkg_sql_sem_tree.DescriptorCoverage(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &BackupEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenants = append(m.Tenants, descpb.TenantInfo{})
			if err := m.Tenants[len(m.Tenants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeDescs = append(m.TypeDescs, &descpb.TypeDescriptor{})
			if err := m.TypeDescs[len(m.TypeDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaDescs = append(m.SchemaDescs, &descpb.SchemaDescriptor{})
			if err := m.SchemaDescs[len(m.SchemaDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseDescs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseDescs = append(m.DatabaseDescs, &descpb.DatabaseDescriptor{})
			if err := m.DatabaseDescs[len(m.DatabaseDescs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails_DescriptorRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToExisting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToExisting = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDetails_BackupLocalityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupLocalityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupLocalityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByOriginalLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByOriginalLocalityKV == nil {
				m.URIsByOriginalLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByOriginalLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighWater = append(m.HighWater[:0], dAtA[iNdEx:postIndex]...)
			if m.HighWater == nil {
				m.HighWater = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, ImportDetails_Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSTSize", wireType)
			}
			m.SSTSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSTSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Walltime", wireType)
			}
			m.Walltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Walltime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, make([]byte, postIndex-iNdEx))
			copy(m.Samples[len(m.Samples)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oversample", wireType)
			}
			m.Oversample = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oversample |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipFKs = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestDirectly = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrepareComplete = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesPublished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TablesPublished = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseBundleSchema", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ParseBundleSchema = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestampRecord", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.ProtectedTimestampRecord = &v
			if err := m.ProtectedTimestampRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDetails_Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqVal", wireType)
			}
			m.SeqVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqVal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNew = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WasEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceValChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceValChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceValChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkStartVal", wireType)
			}
			m.ChunkStartVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkStartVal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkStartRow", wireType)
			}
			m.ChunkStartRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkStartRow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextChunkStartRow", wireType)
			}
			m.NextChunkStartRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextChunkStartRow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqIdToChunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeqIdToChunks == nil {
				m.SeqIdToChunks = make(map[int32]*SequenceDetails_SequenceChunks)
			}
			var mapkey int32
			var mapvalue *SequenceDetails_SequenceChunks
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SequenceDetails_SequenceChunks{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SeqIdToChunks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceDetails_SequenceChunks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceChunks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceChunks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &SequenceValChunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SamplingProgress = append(m.SamplingProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.SamplingProgress) == 0 {
					m.SamplingProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SamplingProgress = append(m.SamplingProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingProgress", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.ReadProgress = append(m.ReadProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.ReadProgress) == 0 {
					m.ReadProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.ReadProgress = append(m.ReadProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadProgress", wireType)
			}
		case 3:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.WriteProgress = append(m.WriteProgress, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.WriteProgress) == 0 {
					m.WriteProgress = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.WriteProgress = append(m.WriteProgress, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteProgress", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanProgress = append(m.SpanProgress, roachpb.Span{})
			if err := m.SpanProgress[len(m.SpanProgress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ResumePos = append(m.ResumePos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ResumePos) == 0 {
					m.ResumePos = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ResumePos = append(m.ResumePos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SequenceDetails = append(m.SequenceDetails, &SequenceDetails{})
			if err := m.SequenceDetails[len(m.SequenceDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeSchemaChangeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeSchemaChangeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeSchemaChangeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeSchemaChangeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeSchemaChangeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeSchemaChangeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewSchemaChangeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewSchemaChangeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewSchemaChangeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &scpb.Target{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewSchemaChangeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewSchemaChangeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewSchemaChangeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v scpb.State
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (scpb.State(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]scpb.State, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v scpb.State
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (scpb.State(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeSpanList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeSpanList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeSpanList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpans = append(m.ResumeSpans, roachpb.Span{})
			if err := m.ResumeSpans[len(m.ResumeSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DroppedTableDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedTableDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedTableDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeGCDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeGCDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, SchemaChangeGCDetails_DroppedIndex{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, SchemaChangeGCDetails_DroppedID{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterleavedTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterleavedTable == nil {
				m.InterleavedTable = &descpb.TableDescriptor{}
			}
			if err := m.InterleavedTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterleavedIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterleavedIndexes = append(m.InterleavedIndexes, descpb.IndexDescriptor{})
			if err := m.InterleavedIndexes[len(m.InterleavedIndexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tenant == nil {
				m.Tenant = &SchemaChangeGCDetails_DroppedTenant{}
			}
			if err := m.Tenant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails_DroppedIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails_DroppedID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCDetails_DroppedTenant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DroppedTenant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DroppedTenant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTime", wireType)
			}
			m.DropTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpanList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeSpanList = append(m.ResumeSpanList, ResumeSpanList{})
			if err := m.ResumeSpanList[len(m.ResumeSpanList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedTables = append(m.DroppedTables, DroppedTableDetails{})
			if err := m.DroppedTables[len(m.DroppedTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedDatabaseID", wireType)
			}
			m.DroppedDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedDatabaseID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			m.DescID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableMutationID", wireType)
			}
			m.TableMutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableMutationID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatVersion", wireType)
			}
			m.FormatVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FormatVersion |= (SchemaChangeDetailsFormatVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DroppedTypes = append(m.DroppedTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DroppedTypes) == 0 {
					m.DroppedTypes = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DroppedTypes = append(m.DroppedTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedTypes", wireType)
			}
		case 9:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DroppedSchemas = append(m.DroppedSchemas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DroppedSchemas) == 0 {
					m.DroppedSchemas = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DroppedSchemas = append(m.DroppedSchemas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedSchemas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeGCProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeGCProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, SchemaChangeGCProgress_IndexProgress{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, SchemaChangeGCProgress_TableProgress{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tenant == nil {
				m.Tenant = &SchemaChangeGCProgress_TenantProgress{}
			}
			if err := m.Tenant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress_IndexProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (SchemaChangeGCProgress_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress_TableProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (SchemaChangeGCProgress_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChangeGCProgress_TenantProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (SchemaChangeGCProgress_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTimeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementTimeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SinkURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opts == nil {
				m.Opts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobs
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Opts[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Targets == nil {
				m.Targets = make(ChangefeedTargets)
			}
			var mapkey uint32
			mapvalue := &ChangefeedTarget{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthJobs
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChangefeedTarget{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJobs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Targets[github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StatementTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundaryReached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoundaryReached = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvedSpans = append(m.ResolvedSpans, ResolvedSpan{})
			if err := m.ResolvedSpans[len(m.ResolvedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestampRecord", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtectedTimestampRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnStats = append(m.ColumnStats, CreateStatsDetails_ColStat{})
			if err := m.ColumnStats[len(m.ColumnStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsOf == nil {
				m.AsOf = &hlc.Timestamp{}
			}
			if err := m.AsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FQTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FQTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFractionIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFractionIdle = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsDetails_ColStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasHistogram = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inverted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramMaxBuckets", wireType)
			}
			m.HistogramMaxBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistogramMaxBuckets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatsProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatsProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatsProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernameProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsernameProto = github_com_cockroachdb_cockroach_pkg_security.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedMicros", wireType)
			}
			m.StartedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedMicros", wireType)
			}
			m.FinishedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DescriptorIDs = append(m.DescriptorIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DescriptorIDs) == 0 {
					m.DescriptorIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DescriptorIDs = append(m.DescriptorIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorIDs", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &Lease{}
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_CreateStats{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResumeErrors = append(m.ResumeErrors, &errorspb.EncodedError{})
			if err := m.ResumeErrors[len(m.ResumeErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CleanupErrors = append(m.CleanupErrors, &errorspb.EncodedError{})
			if err := m.CleanupErrors[len(m.CleanupErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalResumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalResumeError == nil {
				m.FinalResumeError = &errorspb.EncodedError{}
			}
			if err := m.FinalResumeError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noncancelable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Noncancelable = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChangeGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeGCDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_SchemaChangeGC{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeSchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeSchemaChangeDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_TypeSchemaChange{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIngestion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamIngestionDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_StreamIngestion{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewSchemaChangeDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Payload_NewSchemaChange{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Progress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Progress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Progress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FractionCompleted", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = &Progress_FractionCompleted{float32(math.Float32frombits(v))}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMicros", wireType)
			}
			m.ModifiedMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWater", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &hlc.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Progress = &Progress_HighWater{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BackupProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Backup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Restore{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_SchemaChange{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Import", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ImportProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Import{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changefeed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChangefeedProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_Changefeed{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStatsProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_CreateStats{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChangeGC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChangeGCProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_SchemaChangeGC{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeSchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeSchemaChangeProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_TypeSchemaChange{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIngest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamIngestionProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_StreamIngest{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSchemaChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewSchemaChangeProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &Progress_NewSchemaChange{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = &Progress{}
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJobs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJobs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJobs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthJobs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowJobs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipJobs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthJobs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJobs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("jobs/jobspb/jobs.proto", fileDescriptor_jobs_8f6d1b2aa13f3feb) }

var fileDescriptor_jobs_8f6d1b2aa13f3feb = []byte{
	// 4692 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7b, 0x4b, 0x6c, 0x23, 0x47,
	0x7a, 0xbf, 0x9a, 0xa4, 0xc8, 0xe6, 0x47, 0x91, 0x6a, 0x95, 0x34, 0x33, 0x5c, 0xfe, 0x6d, 0x51,
	0x4b, 0xbf, 0x66, 0xc6, 0x36, 0xe5, 0x95, 0xff, 0xeb, 0xb5, 0x27, 0xf6, 0xd8, 0x7c, 0x8d, 0x44,
	0x6a, 0xf4, 0x70, 0x53, 0x1a, 0x3f, 0x36, 0xde, 0x4e, 0xb3, 0xbb, 0x24, 0x75, 0x44, 0x76, 0x73,
	0xba, 0x9a, 0x33, 0xa3, 0x4d, 0x90, 0x04, 0x1b, 0x04, 0x58, 0xcc, 0x29, 0x01, 0x92, 0x5c, 0x92,
	0x01, 0x02, 0x64, 0x17, 0x08, 0x92, 0x00, 0x01, 0x8c, 0x20, 0xc9, 0x21, 0xb7, 0x5c, 0x7c, 0x48,
	0x80, 0xbd, 0x04, 0x30, 0x72, 0xe0, 0x26, 0xf2, 0x25, 0xc7, 0x20, 0x7b, 0x9b, 0x4b, 0x82, 0x7a,
	0x74, 0xb3, 0x49, 0xea, 0x41, 0x8d, 0xec, 0xcd, 0x45, 0xc3, 0xfe, 0xea, 0xab, 0x5f, 0xbd, 0xbe,
	0xfa, 0x7d, 0x5f, 0x7d, 0x55, 0x03, 0x57, 0x7f, 0xdd, 0x69, 0x91, 0x65, 0xfa, 0xa7, 0xdb, 0x62,
	0xff, 0x14, 0xbb, 0xae, 0xe3, 0x39, 0xe8, 0x5b, 0x86, 0x63, 0x1c, 0xba, 0x8e, 0x6e, 0x1c, 0x14,
	0xc9, 0xfd, 0x76, 0x91, 0x95, 0x70, 0xad, 0xdc, 0x15, 0xec, 0xba, 0x8e, 0x4b, 0xf5, 0xf9, 0x0f,
	0x5e, 0x23, 0xb7, 0xb0, 0xef, 0xec, 0x3b, 0xec, 0xe7, 0x32, 0xfd, 0x25, 0xa4, 0x88, 0x61, 0x74,
	0x5b, 0xcb, 0xa6, 0xee, 0xe9, 0x42, 0x96, 0xf5, 0x65, 0x96, 0xf3, 0xfa, 0x9e, 0xe3, 0x76, 0x74,
	0xcf, 0xc7, 0x78, 0x81, 0xdc, 0x6f, 0x2f, 0x1b, 0xba, 0xa7, 0xb7, 0x9d, 0xfd, 0x65, 0x13, 0x13,
	0xa3, 0xdb, 0x5a, 0x26, 0x9e, 0xdb, 0x33, 0xbc, 0x9e, 0x8b, 0x4d, 0xa1, 0x94, 0x3f, 0x41, 0xc9,
	0xc3, 0xb6, 0x6e, 0x7b, 0x3e, 0x7e, 0xcf, 0xb3, 0xda, 0xcb, 0x07, 0x6d, 0x63, 0xd9, 0xb3, 0x3a,
	0x98, 0x78, 0x7a, 0xa7, 0x2b, 0x4a, 0xbe, 0x4d, 0xab, 0x12, 0xe3, 0x00, 0x77, 0x74, 0xe3, 0x40,
	0xb7, 0xf7, 0xb1, 0xbb, 0xcc, 0xdb, 0x30, 0xba, 0x2d, 0xae, 0x52, 0xf8, 0x6d, 0x98, 0xbe, 0x8b,
	0x75, 0x82, 0xd1, 0xa7, 0x90, 0xb0, 0x1d, 0x13, 0x6b, 0x96, 0x99, 0x95, 0x96, 0xa4, 0xeb, 0xe9,
	0x72, 0xe9, 0xb8, 0x9f, 0x8f, 0x6f, 0x3a, 0x26, 0xae, 0x57, 0x9f, 0xf6, 0xf3, 0x6f, 0xee, 0x5b,
	0xde, 0x41, 0xaf, 0x55, 0x34, 0x9c, 0xce, 0x72, 0x30, 0x57, 0x66, 0x6b, 0xf0, 0x7b, 0xb9, 0x7b,
	0xb8, 0xbf, 0x2c, 0x46, 0x5a, 0xe4, 0xd5, 0xd4, 0x38, 0x45, 0xac, 0x9b, 0x68, 0x01, 0xa6, 0x71,
	0xd7, 0x31, 0x0e, 0xb2, 0x91, 0x25, 0xe9, 0x7a, 0x54, 0xe5, 0x1f, 0xb7, 0x62, 0xff, 0xf9, 0x67,
	0x79, 0xa9, 0xf0, 0xd3, 0x08, 0x5c, 0x2b, 0xeb, 0xc6, 0x61, 0xaf, 0x5b, 0xb3, 0x0d, 0xf7, 0xa8,
	0xeb, 0x59, 0x8e, 0xbd, 0xc5, 0xfe, 0x12, 0xa4, 0x40, 0xf4, 0x10, 0x1f, 0xb1, 0xfe, 0xcc, 0xa8,
	0xf4, 0x27, 0x7a, 0x0f, 0x62, 0x1d, 0xc7, 0xc4, 0x0c, 0x28, 0xb3, 0x72, 0xa3, 0x78, 0xea, 0xb2,
	0x15, 0x07, 0x68, 0x1b, 0x8e, 0x89, 0x55, 0x56, 0x0d, 0xb5, 0x40, 0x3e, 0xec, 0x10, 0xcd, 0xb2,
	0xf7, 0x9c, 0x6c, 0x74, 0x49, 0xba, 0x9e, 0x5a, 0xb9, 0x75, 0x06, 0xc4, 0x29, 0xdd, 0x2a, 0xae,
	0x6f, 0x34, 0xeb, 0xf6, 0x9e, 0x53, 0x4e, 0x1d, 0xf7, 0xf3, 0x09, 0xf1, 0xa1, 0x26, 0x0e, 0x3b,
	0x84, 0xfe, 0xc8, 0x6d, 0x81, 0x2f, 0xa3, 0xfd, 0xef, 0xb9, 0x16, 0xeb, 0x7f, 0x52, 0xa5, 0x3f,
	0xd1, 0x6b, 0x80, 0x30, 0xc7, 0xc3, 0xa6, 0x46, 0x6d, 0x44, 0xa3, 0x03, 0x8c, 0xb0, 0x01, 0x2a,
	0x41, 0x49, 0x55, 0xf7, 0xf4, 0x75, 0x7c, 0xc4, 0x67, 0x48, 0xcc, 0xd3, 0xef, 0x44, 0x21, 0x33,
	0xe8, 0x0a, 0x83, 0x5f, 0x83, 0x38, 0x5b, 0x5c, 0xcc, 0x5a, 0xc8, 0xac, 0xbc, 0x31, 0xd1, 0x74,
	0xd0, 0xaa, 0xc5, 0x26, 0xab, 0xa7, 0x8a, 0xfa, 0x08, 0x41, 0x8c, 0xe8, 0x6d, 0x4f, 0x74, 0x84,
	0xfd, 0x46, 0x7f, 0x22, 0xc1, 0xd2, 0x68, 0x8f, 0xca, 0x47, 0xeb, 0x1b, 0xcd, 0x0d, 0x9d, 0x78,
	0xd8, 0x5d, 0xc7, 0x47, 0xf5, 0x6a, 0x36, 0xba, 0x14, 0xbd, 0x9e, 0x5a, 0xd9, 0x9a, 0xbc, 0xe1,
	0xda, 0x39, 0x88, 0x35, 0xdb, 0x73, 0x8f, 0xd4, 0x73, 0x1b, 0xce, 0x35, 0xe1, 0xa5, 0x89, 0xa0,
	0xc2, 0x36, 0x94, 0xe4, 0x36, 0xb4, 0x00, 0xd3, 0x0f, 0xf4, 0x76, 0x0f, 0x8b, 0xd1, 0xf2, 0x8f,
	0x5b, 0x91, 0xb7, 0xa5, 0xc2, 0x35, 0x88, 0xf3, 0x89, 0x41, 0x69, 0x48, 0x96, 0x6a, 0xcd, 0x95,
	0xef, 0xbe, 0xb5, 0x5a, 0xd9, 0x50, 0xa6, 0xc4, 0x12, 0xfc, 0x8f, 0x04, 0x57, 0x9b, 0x9e, 0x8b,
	0xf5, 0x4e, 0xdd, 0xde, 0xc7, 0x84, 0x8e, 0xa9, 0x8a, 0x3d, 0xdd, 0x6a, 0x13, 0x64, 0x43, 0x86,
	0xb0, 0x12, 0x4d, 0x37, 0x4d, 0x17, 0x13, 0xc2, 0x1b, 0x2c, 0xaf, 0x3e, 0xed, 0xe7, 0x2b, 0x13,
	0x6d, 0x1d, 0xc3, 0x68, 0x2f, 0x73, 0x08, 0xcb, 0xde, 0x37, 0x8c, 0x76, 0x91, 0xb7, 0x54, 0xe2,
	0x70, 0x6a, 0x9a, 0x84, 0x3f, 0xd1, 0x77, 0x20, 0x46, 0xba, 0xba, 0xcd, 0x86, 0x90, 0x5a, 0xb9,
	0x16, 0x9a, 0x7f, 0x7f, 0x0b, 0x36, 0xbb, 0xba, 0x5d, 0x8e, 0x7d, 0xd1, 0xcf, 0x4f, 0xa9, 0x4c,
	0x15, 0x95, 0x01, 0x88, 0xa7, 0xbb, 0x9e, 0x46, 0x59, 0x42, 0x58, 0xff, 0xf3, 0xa1, 0x8a, 0x94,
	0x45, 0x8a, 0x07, 0x6d, 0xa3, 0xb8, 0xe3, 0xb3, 0x88, 0xa8, 0x9e, 0x64, 0xd5, 0xa8, 0xb4, 0xf0,
	0x2d, 0xb8, 0x36, 0x32, 0x01, 0xdb, 0xae, 0xb3, 0x4f, 0x7b, 0x54, 0xf8, 0xc7, 0x38, 0xa4, 0xf9,
	0x86, 0xf1, 0xe7, 0x64, 0xb8, 0x41, 0xe9, 0x59, 0x1a, 0x44, 0xb7, 0x41, 0xc6, 0xb6, 0xc9, 0x11,
	0x22, 0x93, 0x23, 0x24, 0xb0, 0x6d, 0xb2, 0xfa, 0xdf, 0xe2, 0x3b, 0x30, 0xca, 0x16, 0x23, 0x71,
	0xdc, 0xcf, 0x47, 0x77, 0xd5, 0x3a, 0xdf, 0x8a, 0xef, 0x42, 0xce, 0xc4, 0x5d, 0x17, 0x1b, 0x3a,
	0xdd, 0x8b, 0x2d, 0xd6, 0x75, 0xad, 0xa3, 0xdb, 0xd6, 0x1e, 0x26, 0x5e, 0x36, 0xc6, 0x6c, 0x23,
	0x3b, 0xd0, 0xe0, 0x63, 0xdb, 0x10, 0xe5, 0xe8, 0x77, 0x25, 0x98, 0xef, 0xb9, 0x16, 0xd1, 0x5a,
	0x47, 0x5a, 0xdb, 0x31, 0xf4, 0xb6, 0xe5, 0x1d, 0x69, 0x87, 0x0f, 0xb2, 0xd3, 0x6c, 0x43, 0xdc,
	0x3e, 0x97, 0x55, 0xc4, 0x24, 0x15, 0x77, 0x5d, 0x8b, 0x94, 0x8f, 0xee, 0x0a, 0x84, 0xf5, 0x07,
	0xcc, 0x68, 0xcb, 0x0b, 0xc7, 0xfd, 0xbc, 0xb2, 0xab, 0xd6, 0xc3, 0x45, 0xf7, 0x54, 0xa5, 0x37,
	0xa2, 0x8c, 0xf4, 0x80, 0x4e, 0x2c, 0xc7, 0xd6, 0x1c, 0xce, 0x4f, 0xd9, 0x38, 0x9b, 0xa8, 0x95,
	0x8b, 0x33, 0x9b, 0x3a, 0x87, 0xc7, 0x38, 0xf8, 0x0f, 0x24, 0xc8, 0x51, 0x57, 0x81, 0x0d, 0x3a,
	0x4d, 0x81, 0x87, 0xd1, 0x5c, 0x6c, 0x38, 0xae, 0x99, 0x4d, 0xd0, 0x79, 0x2a, 0x37, 0xff, 0x6d,
	0x52, 0x0f, 0xc1, 0x7c, 0x55, 0xaf, 0x67, 0x99, 0xc5, 0xdd, 0xdd, 0x7a, 0xf5, 0xb8, 0x9f, 0xcf,
	0x6e, 0xfb, 0xe0, 0xc1, 0x22, 0xaa, 0x0c, 0x5a, 0xcd, 0x76, 0x4f, 0x29, 0x41, 0x6f, 0x43, 0xc6,
	0x70, 0xda, 0x6d, 0x6c, 0xb0, 0x61, 0xef, 0xaa, 0xf5, 0xac, 0xcc, 0x16, 0x78, 0xee, 0xb8, 0x9f,
	0x4f, 0x57, 0x82, 0x12, 0xba, 0xd4, 0x69, 0x23, 0xfc, 0x89, 0x54, 0x98, 0x0d, 0x4d, 0x18, 0xf3,
	0x03, 0x49, 0x36, 0x5b, 0x37, 0x26, 0xa6, 0x30, 0x35, 0x83, 0x87, 0xbe, 0x73, 0x15, 0xb8, 0x72,
	0xe2, 0x2a, 0x9e, 0x47, 0x3d, 0xc9, 0x30, 0xf5, 0x28, 0x90, 0xe1, 0x8b, 0x12, 0x6c, 0xa8, 0xcf,
	0x33, 0x90, 0x51, 0x31, 0xf1, 0x1c, 0x17, 0xfb, 0x3b, 0xea, 0x73, 0x09, 0xe6, 0x69, 0x04, 0xe0,
	0x5a, 0x5d, 0xcf, 0x71, 0x35, 0x17, 0x3f, 0x74, 0x2d, 0x0f, 0x93, 0x6c, 0x84, 0x19, 0x5d, 0xe9,
	0x8c, 0x21, 0x0c, 0x03, 0x15, 0xab, 0x01, 0x88, 0x2a, 0x30, 0xb8, 0xdd, 0xdd, 0xfe, 0xd1, 0xcf,
	0xf3, 0xb7, 0x26, 0x5a, 0xc7, 0xf1, 0xa0, 0xa4, 0x58, 0xaf, 0xaa, 0xc8, 0x1c, 0x03, 0x46, 0xcf,
	0x41, 0x8c, 0xda, 0x2d, 0x73, 0x15, 0xc9, 0xb2, 0x7c, 0xdc, 0xcf, 0xc7, 0xa8, 0x65, 0xab, 0x4c,
	0x3a, 0xb4, 0xc1, 0x63, 0xcf, 0xb0, 0xc1, 0x57, 0x21, 0xe5, 0xe9, 0xad, 0x36, 0xd6, 0x68, 0xcb,
	0x44, 0x6c, 0xbf, 0x97, 0x47, 0x66, 0x82, 0xdc, 0x6f, 0xb7, 0x74, 0x82, 0x8b, 0x3b, 0x54, 0x33,
	0x34, 0x76, 0xf0, 0x7c, 0x01, 0x41, 0xcb, 0x90, 0x72, 0x1e, 0x60, 0xd7, 0xb5, 0x4c, 0xac, 0x99,
	0x2d, 0xb6, 0x87, 0x92, 0xe5, 0xcc, 0x71, 0x3f, 0x0f, 0x5b, 0x42, 0x5c, 0x2d, 0xab, 0xe0, 0xab,
	0x54, 0x5b, 0xc8, 0x83, 0x05, 0x41, 0x1a, 0xc1, 0xfe, 0x67, 0xf6, 0x94, 0x60, 0x5d, 0x78, 0x77,
	0xf2, 0xc5, 0xe0, 0xeb, 0xee, 0x1b, 0x0f, 0x8b, 0x2c, 0xf8, 0x20, 0x51, 0x6b, 0xac, 0x04, 0xbd,
	0x0a, 0x73, 0x5d, 0x17, 0x77, 0x75, 0x17, 0x6b, 0x86, 0xd3, 0xe9, 0xb6, 0xb1, 0x87, 0x4d, 0x66,
	0xfd, 0xb2, 0xaa, 0x88, 0x82, 0x8a, 0x2f, 0x47, 0x2f, 0x51, 0xaf, 0xa4, 0x7b, 0x34, 0xe0, 0x21,
	0xd8, 0xa5, 0x9a, 0x49, 0xa6, 0x99, 0x66, 0xd2, 0xba, 0x10, 0xa2, 0x37, 0xe1, 0xca, 0x60, 0xdd,
	0x88, 0xd6, 0xed, 0xb5, 0xda, 0x16, 0x39, 0xc0, 0x66, 0x16, 0x98, 0xf6, 0x42, 0xa8, 0x70, 0xdb,
	0x2f, 0x43, 0x47, 0x43, 0xa6, 0x68, 0xd0, 0x89, 0xd1, 0xf7, 0x71, 0x36, 0xb5, 0x24, 0x5d, 0x9f,
	0x2e, 0xaf, 0x3d, 0xed, 0xe7, 0xab, 0x13, 0xdb, 0x11, 0xc1, 0x9d, 0x65, 0xcf, 0xc5, 0x38, 0x64,
	0x96, 0x15, 0x81, 0x17, 0xb6, 0x28, 0x5f, 0x86, 0x54, 0x80, 0xc1, 0x16, 0xcc, 0xce, 0x3c, 0x33,
	0xdb, 0x85, 0x50, 0x50, 0x09, 0x12, 0x3c, 0xa8, 0x26, 0xd9, 0x34, 0x5b, 0xc0, 0x6f, 0x9f, 0x66,
	0x43, 0x4c, 0x2b, 0xb4, 0x4a, 0x7e, 0x3d, 0x54, 0x05, 0xf0, 0x8e, 0xba, 0xbe, 0x25, 0x66, 0x18,
	0xca, 0x4b, 0xa7, 0xa1, 0x1c, 0x75, 0xc3, 0x86, 0x98, 0xf4, 0xc4, 0x37, 0x41, 0x0d, 0x98, 0xe1,
	0x11, 0xbb, 0xc0, 0x99, 0x65, 0x38, 0xaf, 0x9c, 0x82, 0xc3, 0xc2, 0x15, 0x3d, 0x84, 0x94, 0x22,
	0x81, 0x84, 0xa0, 0x6d, 0xc8, 0xd0, 0x18, 0x93, 0x6a, 0x0a, 0x34, 0x85, 0xa1, 0xdd, 0x38, 0x05,
	0xad, 0x2a, 0x94, 0x43, 0x78, 0x69, 0x33, 0x24, 0x23, 0xb9, 0x5f, 0x48, 0x30, 0x37, 0x46, 0x1e,
	0x68, 0x07, 0x22, 0xc1, 0xb1, 0x81, 0x72, 0x7a, 0x84, 0x1d, 0x19, 0x2e, 0x43, 0x24, 0x11, 0xcb,
	0x44, 0xfb, 0x90, 0xa4, 0xe6, 0x6c, 0x7b, 0xf4, 0x4c, 0x12, 0x61, 0xe0, 0x8d, 0xe3, 0x7e, 0x5e,
	0xde, 0x66, 0xc2, 0x4b, 0x37, 0x21, 0x73, 0xf0, 0xba, 0x89, 0xf2, 0x90, 0xf2, 0x1c, 0x0d, 0x3f,
	0xb2, 0x88, 0x67, 0xd9, 0xfb, 0x2c, 0x58, 0x90, 0x55, 0xf0, 0x9c, 0x9a, 0x90, 0xe4, 0xfe, 0x34,
	0x02, 0x68, 0x7c, 0x97, 0xa2, 0x7f, 0x90, 0xe0, 0x39, 0x3f, 0x06, 0x70, 0x5c, 0x6b, 0xdf, 0xb2,
	0xf5, 0xf6, 0x50, 0x30, 0x20, 0xb1, 0xd9, 0xfe, 0xf4, 0x32, 0x54, 0x20, 0x02, 0x84, 0x2d, 0x01,
	0x3f, 0x1a, 0x28, 0x3c, 0x47, 0x3d, 0x28, 0x0f, 0x14, 0xc6, 0x54, 0xee, 0xa9, 0xd9, 0xde, 0x29,
	0x95, 0x73, 0xeb, 0xf0, 0xfc, 0x99, 0xc0, 0x17, 0xf1, 0x5d, 0xb9, 0x1f, 0x49, 0x70, 0xed, 0x14,
	0x8f, 0x12, 0xc6, 0x49, 0x73, 0x9c, 0x0f, 0xc3, 0x38, 0xa9, 0x95, 0x5f, 0xb9, 0x84, 0xd7, 0x0a,
	0x75, 0xa2, 0x11, 0x93, 0x25, 0x25, 0x52, 0x78, 0x03, 0x66, 0x45, 0x25, 0xdf, 0x8f, 0xa2, 0xe7,
	0x01, 0x0e, 0xac, 0xfd, 0x03, 0xed, 0xa1, 0xee, 0x61, 0x57, 0x9c, 0x25, 0x93, 0x54, 0xf2, 0x11,
	0x15, 0x14, 0xfe, 0x55, 0x86, 0x74, 0xbd, 0xd3, 0x75, 0x5c, 0xcf, 0xf7, 0xb2, 0x77, 0x21, 0xce,
	0xfc, 0x02, 0x11, 0xeb, 0x57, 0x3c, 0xa3, 0x87, 0x43, 0x35, 0xb9, 0x7f, 0x11, 0xb4, 0x20, 0x30,
	0x02, 0xf7, 0x17, 0x39, 0xd1, 0xfd, 0xbd, 0x07, 0x71, 0x9e, 0x12, 0x10, 0x01, 0x79, 0xfe, 0x84,
	0x48, 0xbe, 0xbe, 0x75, 0xc7, 0x6a, 0xe3, 0x3b, 0x4c, 0xcd, 0x07, 0xe7, 0x95, 0xd0, 0xcb, 0x20,
	0x13, 0xe2, 0x69, 0xc4, 0xfa, 0x21, 0xf7, 0x9e, 0x51, 0x7e, 0x26, 0x6d, 0x36, 0x77, 0x9a, 0xd6,
	0x0f, 0xb1, 0x9a, 0x20, 0xc4, 0xa3, 0x3f, 0x50, 0x0e, 0xe4, 0x87, 0x7a, 0xbb, 0xcd, 0xbc, 0xec,
	0x34, 0x3b, 0x83, 0x07, 0xdf, 0xc3, 0xdb, 0x2c, 0xfe, 0xcd, 0x6e, 0x33, 0xe1, 0x30, 0xbb, 0xba,
	0x77, 0xc0, 0x22, 0xc7, 0xa4, 0x0a, 0x5c, 0xb4, 0xad, 0x7b, 0x07, 0x28, 0x0b, 0x09, 0xa2, 0x53,
	0xdf, 0x45, 0xb2, 0xf2, 0x52, 0xf4, 0xfa, 0x8c, 0xea, 0x7f, 0xa2, 0x45, 0x60, 0x9e, 0x97, 0x7f,
	0x32, 0x27, 0x16, 0x55, 0x43, 0x12, 0x36, 0x0f, 0x87, 0x56, 0x57, 0xdb, 0x3b, 0x24, 0xdc, 0x69,
	0x89, 0x79, 0x38, 0xb4, 0xba, 0x77, 0xd6, 0x89, 0x9a, 0xa0, 0x85, 0x77, 0x0e, 0x09, 0x7a, 0x05,
	0x66, 0x2d, 0x76, 0x72, 0xd1, 0x4c, 0xcb, 0xc5, 0x86, 0xd7, 0x3e, 0x62, 0x0e, 0x4b, 0x56, 0x33,
	0x5c, 0x5c, 0x15, 0x52, 0x74, 0x03, 0x94, 0x51, 0x37, 0xcb, 0x1c, 0x8d, 0xac, 0xce, 0x8e, 0x78,
	0x59, 0xaa, 0xca, 0x97, 0x3a, 0xe4, 0x38, 0xd3, 0x5c, 0x95, 0xcb, 0x07, 0x3e, 0xb3, 0x08, 0xf3,
	0x5d, 0xdd, 0x25, 0x58, 0x6b, 0xf5, 0x6c, 0xb3, 0x8d, 0x35, 0xce, 0xd5, 0xd9, 0x0c, 0xd3, 0x9e,
	0x63, 0x45, 0x65, 0x56, 0xc2, 0x69, 0xfd, 0xbc, 0xd8, 0xfb, 0xea, 0xff, 0x41, 0xec, 0x9d, 0xfb,
	0x69, 0x04, 0xa6, 0x99, 0x9d, 0xa3, 0x5b, 0x10, 0xa3, 0xcb, 0x2c, 0x4e, 0x76, 0x93, 0xc6, 0x5c,
	0xac, 0x0e, 0x42, 0x10, 0xb3, 0xf5, 0x0e, 0xce, 0x22, 0x66, 0x04, 0xec, 0x37, 0xba, 0x06, 0x09,
	0x82, 0xef, 0x6b, 0x0f, 0xf4, 0x76, 0x76, 0x9e, 0xad, 0x70, 0x9c, 0xe0, 0xfb, 0xf7, 0xf4, 0x36,
	0xba, 0x02, 0x71, 0x8b, 0x68, 0x36, 0x7e, 0x98, 0x5d, 0x60, 0x33, 0x35, 0x6d, 0x91, 0x4d, 0xfc,
	0x90, 0xd1, 0xb6, 0xee, 0xee, 0x63, 0x4f, 0x33, 0x9c, 0x36, 0xc9, 0x5e, 0xa1, 0x1b, 0x8c, 0x86,
	0x74, 0x54, 0x54, 0x71, 0xda, 0x04, 0xfd, 0x3f, 0x48, 0x3e, 0xd4, 0x89, 0x86, 0x3b, 0x5d, 0xef,
	0x88, 0x4d, 0x96, 0x4c, 0xcd, 0x9e, 0xd4, 0xe8, 0x77, 0x23, 0x26, 0x47, 0x94, 0x68, 0x23, 0x26,
	0x47, 0x95, 0x58, 0x23, 0x26, 0xc7, 0x94, 0xe9, 0x46, 0x4c, 0x9e, 0x56, 0xe2, 0x8d, 0x98, 0x1c,
	0x57, 0x12, 0x8d, 0x98, 0x9c, 0x50, 0xe4, 0x46, 0x4c, 0x96, 0x95, 0x64, 0x23, 0x26, 0x27, 0x15,
	0x68, 0xc4, 0x64, 0x50, 0x52, 0x8d, 0x98, 0x9c, 0x52, 0x66, 0x1a, 0x31, 0x79, 0x46, 0x49, 0x37,
	0x62, 0x72, 0x5a, 0xc9, 0x34, 0x62, 0x72, 0x46, 0x99, 0x6d, 0xc4, 0xe4, 0x59, 0x45, 0x69, 0xc4,
	0x64, 0x45, 0x99, 0x6b, 0xc4, 0xe4, 0x39, 0x05, 0x15, 0x3e, 0x97, 0x40, 0x69, 0xe2, 0xfb, 0x3d,
	0x6c, 0x1b, 0xf8, 0x9e, 0xde, 0xae, 0x1c, 0xf4, 0xec, 0x43, 0xf4, 0x32, 0xcc, 0x1a, 0xf4, 0x87,
	0xc6, 0x0f, 0xc6, 0x74, 0xa8, 0x12, 0x1b, 0x6a, 0x9a, 0x89, 0x9b, 0x54, 0x4a, 0x47, 0xfc, 0x3c,
	0x80, 0xd0, 0xa3, 0x3b, 0x9b, 0x67, 0xcd, 0x92, 0x5c, 0x85, 0x6e, 0xe7, 0x11, 0x18, 0xd7, 0x79,
	0xc8, 0xe8, 0x63, 0x08, 0x46, 0x75, 0x1e, 0xa2, 0x65, 0x58, 0xb0, 0xf1, 0x23, 0x4f, 0x1b, 0x55,
	0x66, 0x54, 0xa1, 0xce, 0xd1, 0xb2, 0x4a, 0xb8, 0x42, 0xe1, 0x5f, 0x22, 0x30, 0xeb, 0x77, 0xda,
	0xa7, 0xc3, 0x3d, 0x50, 0xe8, 0xb2, 0x58, 0xa6, 0xe6, 0x39, 0x1c, 0xc9, 0x27, 0xc6, 0xf7, 0xce,
	0x20, 0xc6, 0x11, 0x14, 0xfa, 0x5d, 0x37, 0x77, 0x1c, 0xd6, 0x1c, 0x77, 0x0d, 0x6a, 0x9a, 0x84,
	0x65, 0xb9, 0x5d, 0xc8, 0xf8, 0x95, 0xb8, 0x04, 0x55, 0x20, 0x3e, 0xd4, 0xde, 0xab, 0x13, 0xb4,
	0xe7, 0x4f, 0xb5, 0x2a, 0xaa, 0xe6, 0x7e, 0x03, 0xd0, 0x78, 0xdb, 0x61, 0xb7, 0x34, 0xcd, 0xdd,
	0xd2, 0xd6, 0xb0, 0x5b, 0x7a, 0xe7, 0x62, 0x63, 0x0b, 0x75, 0x3b, 0x7c, 0xaa, 0xfb, 0xa7, 0x08,
	0x64, 0xb8, 0x8b, 0x08, 0xdc, 0xd1, 0xab, 0x30, 0xc7, 0x48, 0xcb, 0xb2, 0xf7, 0xb5, 0xae, 0x10,
	0xb2, 0xf1, 0x45, 0x54, 0xc5, 0x2f, 0x08, 0x94, 0x5f, 0x80, 0xb4, 0x8b, 0x75, 0x73, 0xa0, 0x18,
	0x61, 0x8a, 0x33, 0x54, 0x18, 0x28, 0xbd, 0x04, 0x19, 0xe6, 0x0d, 0x07, 0x5a, 0x51, 0xa6, 0x95,
	0x66, 0xd2, 0x40, 0xad, 0x0c, 0x69, 0xd2, 0xd5, 0xed, 0x81, 0x56, 0x8c, 0x4d, 0xea, 0x39, 0xb9,
	0xa3, 0x19, 0x5a, 0x27, 0xec, 0x4b, 0x5d, 0x4c, 0x7a, 0x1d, 0xac, 0x75, 0x1d, 0x7e, 0xd8, 0x8a,
	0xaa, 0x49, 0x2e, 0xd9, 0x76, 0x08, 0xda, 0x65, 0xa6, 0xc2, 0xe6, 0x42, 0x33, 0xf9, 0xe4, 0x64,
	0xe3, 0xac, 0x95, 0x9b, 0x93, 0x4f, 0xa7, 0x3a, 0x4b, 0x86, 0x05, 0x85, 0xdf, 0x84, 0x6b, 0x34,
	0x5e, 0xe6, 0xa4, 0x58, 0x61, 0x89, 0x6c, 0xdf, 0x38, 0x75, 0x48, 0xb0, 0x98, 0x3b, 0x08, 0x3f,
	0xd7, 0x8e, 0xfb, 0xf9, 0x38, 0xd5, 0xbe, 0xb4, 0xe3, 0x8a, 0x53, 0xe0, 0xba, 0x59, 0xc8, 0x41,
	0x76, 0xb4, 0xf5, 0xe0, 0x8c, 0xfe, 0xab, 0x70, 0x75, 0x13, 0x3f, 0x3c, 0xa9, 0x63, 0x65, 0x48,
	0x70, 0x26, 0xf2, 0x8d, 0xf7, 0xfa, 0x28, 0x3f, 0x86, 0xd3, 0xf2, 0x45, 0xd6, 0xe8, 0x0e, 0xab,
	0xa0, 0xfa, 0x15, 0x0b, 0x9f, 0xc2, 0xb5, 0x11, 0xf4, 0x60, 0x21, 0xde, 0x87, 0x38, 0x3d, 0xc3,
	0x89, 0x18, 0x25, 0x33, 0x7e, 0x3e, 0x18, 0x47, 0x6f, 0x52, 0x7d, 0x55, 0x54, 0x2b, 0xa8, 0x2c,
	0xb9, 0xd0, 0xeb, 0x60, 0xba, 0xd6, 0x77, 0x2d, 0xe2, 0xa1, 0x0f, 0x60, 0x46, 0xac, 0x2d, 0x5d,
	0x72, 0xbf, 0xdb, 0xe7, 0x98, 0x47, 0xca, 0x0d, 0x40, 0x48, 0xe1, 0x6f, 0x25, 0x98, 0xaf, 0xba,
	0x4e, 0xb7, 0x8b, 0x4d, 0xc1, 0xfa, 0x7c, 0x2e, 0x7c, 0xb2, 0x97, 0x42, 0x64, 0xbf, 0x09, 0x91,
	0x7a, 0x55, 0x44, 0xf5, 0xb7, 0x2f, 0x7b, 0x58, 0xa8, 0x57, 0xd1, 0x3b, 0x7c, 0x42, 0x7a, 0x84,
	0x31, 0x61, 0x66, 0xec, 0xf8, 0x36, 0x64, 0x70, 0x4c, 0x51, 0x15, 0x15, 0x0a, 0x3f, 0x49, 0xc0,
	0x95, 0xf0, 0x24, 0xaf, 0x56, 0xfc, 0x8e, 0x7f, 0x06, 0x09, 0xcb, 0x36, 0xf1, 0x23, 0x3c, 0x11,
	0xe3, 0x9d, 0x04, 0x51, 0x14, 0xf3, 0x51, 0xa7, 0x30, 0xfe, 0x81, 0x51, 0x60, 0xa2, 0x8f, 0x83,
	0x40, 0x93, 0x27, 0x70, 0x6e, 0x3d, 0x33, 0x7a, 0x75, 0x24, 0xe8, 0x1c, 0x8a, 0xe9, 0x98, 0x6b,
	0xf8, 0x86, 0x62, 0xba, 0x26, 0xcc, 0x59, 0xb6, 0x87, 0xdd, 0x36, 0xd6, 0x1f, 0xd0, 0x10, 0x85,
	0x36, 0x2f, 0xf2, 0x38, 0x93, 0x06, 0x04, 0x4a, 0x08, 0x80, 0x07, 0x16, 0x9f, 0xc1, 0x7c, 0x18,
	0xd4, 0x5f, 0x82, 0xb3, 0x73, 0x3b, 0x6c, 0x86, 0x07, 0xb0, 0x7e, 0x0a, 0x25, 0x04, 0x54, 0x17,
	0xd3, 0x7e, 0x0f, 0xe2, 0xfc, 0xc8, 0x2e, 0x12, 0xa5, 0xb7, 0x9f, 0x75, 0xda, 0x79, 0x2a, 0x40,
	0x15, 0x68, 0xb9, 0x3f, 0x96, 0x60, 0x26, 0xbc, 0xdc, 0xc8, 0x02, 0x99, 0xf5, 0xdd, 0x67, 0xa7,
	0x68, 0x79, 0x93, 0x46, 0xa5, 0xac, 0x90, 0xad, 0xc1, 0xfb, 0xcf, 0xbc, 0x06, 0x1c, 0x42, 0x98,
	0x52, 0xdd, 0xa4, 0xa1, 0x8e, 0xe9, 0x3a, 0xdd, 0x41, 0xa2, 0x3c, 0xaa, 0xca, 0x54, 0x40, 0xa3,
	0xb7, 0xdc, 0x6f, 0x41, 0x32, 0x30, 0x94, 0xd0, 0x59, 0x3d, 0xfa, 0x35, 0x9e, 0xd5, 0xcf, 0x6c,
	0xbf, 0x0a, 0xe9, 0xa1, 0x19, 0x43, 0x57, 0x83, 0x3e, 0xc4, 0xca, 0x71, 0xde, 0x87, 0x73, 0x51,
	0x0a, 0x3f, 0x8f, 0xc3, 0xfc, 0x49, 0x4c, 0xfb, 0x09, 0x28, 0x21, 0xde, 0xd2, 0xda, 0x16, 0xf1,
	0xc4, 0x7e, 0xba, 0x71, 0xf6, 0xd1, 0x32, 0x44, 0x7e, 0xc2, 0x5a, 0x32, 0xee, 0x30, 0x25, 0x7e,
	0x1f, 0x32, 0x26, 0xef, 0xb8, 0x26, 0x36, 0x6a, 0xf4, 0xdc, 0x13, 0xe1, 0x09, 0x04, 0x28, 0xd0,
	0xd3, 0x66, 0xa8, 0x88, 0xb0, 0x1b, 0x04, 0x1f, 0x3d, 0xc8, 0xd2, 0x58, 0x26, 0xdb, 0x3d, 0xe9,
	0x72, 0xf3, 0xb8, 0x9f, 0x9f, 0x13, 0x58, 0x7e, 0x5a, 0xe6, 0xd2, 0x2b, 0x35, 0x67, 0x8e, 0x00,
	0x9a, 0xd4, 0x81, 0xd2, 0x72, 0xda, 0xf0, 0xf4, 0xc0, 0x81, 0xd2, 0x7d, 0x74, 0x79, 0x07, 0x4a,
	0x7f, 0xd6, 0x4d, 0xf4, 0x7b, 0x12, 0xcc, 0xf1, 0x1c, 0x6d, 0xa7, 0xe7, 0xe9, 0x3c, 0xf1, 0xee,
	0x9f, 0x34, 0x3f, 0x39, 0xee, 0xe7, 0x67, 0xd9, 0x84, 0x6c, 0x88, 0x32, 0xd6, 0x6c, 0xf9, 0x59,
	0x9b, 0x1d, 0xa0, 0x88, 0xd3, 0x57, 0x20, 0x30, 0xd1, 0x3a, 0x64, 0xf8, 0xb1, 0x59, 0xa3, 0x07,
	0x47, 0xcb, 0xb1, 0xd9, 0x11, 0x34, 0x5d, 0x7e, 0xf1, 0x69, 0x3f, 0xbf, 0x74, 0x82, 0x65, 0xf1,
	0x13, 0xf7, 0x3d, 0xae, 0xab, 0xa6, 0xf7, 0xc2, 0x9f, 0xc8, 0x80, 0x74, 0x60, 0x1a, 0x47, 0x5d,
	0x71, 0x62, 0xbd, 0xbc, 0x2b, 0x9b, 0xf1, 0x6d, 0x84, 0x62, 0xa2, 0x7d, 0x98, 0xf5, 0x1b, 0xe1,
	0x0e, 0x9d, 0x64, 0x93, 0x5f, 0x4b, 0x33, 0xbe, 0x59, 0xf3, 0x51, 0x13, 0x91, 0x3c, 0xb9, 0x0a,
	0x0b, 0x27, 0x46, 0x39, 0x5f, 0xc6, 0xe1, 0xea, 0x30, 0x11, 0x06, 0x71, 0x88, 0x36, 0xea, 0x21,
	0xdf, 0x9f, 0x98, 0x4c, 0x7d, 0x0c, 0x4e, 0x66, 0xfe, 0xd7, 0xa8, 0x8f, 0xfc, 0x6c, 0xc4, 0x47,
	0x3e, 0x03, 0x3e, 0x33, 0xaf, 0x11, 0x7c, 0xdf, 0x51, 0x7e, 0x1c, 0xf8, 0x02, 0x9e, 0x7f, 0xf9,
	0xe0, 0x19, 0xe0, 0x59, 0x7d, 0xff, 0x33, 0xf0, 0x06, 0xff, 0x2c, 0x41, 0x7a, 0x68, 0x64, 0xbf,
	0x4c, 0x77, 0xb0, 0x1d, 0x44, 0x43, 0xfc, 0xa1, 0xc4, 0xdb, 0x17, 0x1f, 0xd6, 0x70, 0x90, 0x94,
	0xfb, 0x7b, 0x09, 0xd2, 0x43, 0x13, 0xf9, 0x0d, 0x39, 0x92, 0xaf, 0xbf, 0xe7, 0x2d, 0xc8, 0x0c,
	0x2f, 0x51, 0xa8, 0x0d, 0xe9, 0xeb, 0x69, 0xa3, 0xf0, 0x3d, 0x88, 0x73, 0x09, 0x42, 0x90, 0xf9,
	0xa8, 0x54, 0xdf, 0xa9, 0x6f, 0xae, 0x6a, 0x77, 0xb6, 0x54, 0x6d, 0xb5, 0xa2, 0x4c, 0xa1, 0x19,
	0x90, 0xab, 0xb5, 0xbb, 0x35, 0x2a, 0x54, 0x24, 0x94, 0x82, 0x04, 0xfb, 0xaa, 0x55, 0x95, 0x48,
	0xa1, 0x0c, 0x0a, 0xc7, 0xde, 0xc3, 0xd4, 0x31, 0xd0, 0xb8, 0x1f, 0x15, 0x61, 0x9e, 0x05, 0xe9,
	0x1d, 0x1a, 0xbf, 0x51, 0x57, 0xa8, 0x85, 0xa2, 0xe7, 0xb9, 0xa0, 0x88, 0x3a, 0xc5, 0x4d, 0xbd,
	0x83, 0x0b, 0x7f, 0x17, 0x83, 0xb9, 0x01, 0x88, 0xef, 0x16, 0x5f, 0x06, 0x99, 0x58, 0xf6, 0xa1,
	0x36, 0xb8, 0xfe, 0xe6, 0x29, 0x31, 0xcb, 0x3e, 0xdc, 0x55, 0xeb, 0x6a, 0x82, 0x16, 0xee, 0xba,
	0x16, 0x6a, 0x40, 0xcc, 0xe9, 0x7a, 0xfe, 0x69, 0xf0, 0xad, 0x33, 0xa6, 0x62, 0xac, 0x8d, 0xe2,
	0x56, 0xd7, 0x13, 0x67, 0x79, 0x86, 0x81, 0xfe, 0x5a, 0x1a, 0x9c, 0x7a, 0xf8, 0xb9, 0xef, 0x9d,
	0x0b, 0xe1, 0xf1, 0x09, 0x10, 0x77, 0x91, 0x1f, 0xd1, 0x8d, 0xfa, 0xb4, 0x9f, 0x9f, 0x1b, 0x9d,
	0x20, 0x72, 0xc9, 0x4b, 0x4a, 0xbf, 0x8b, 0xa8, 0xc1, 0xaf, 0xc7, 0x06, 0x13, 0xcd, 0x1c, 0xc2,
	0x84, 0x37, 0x90, 0xe9, 0xa1, 0x85, 0xc8, 0xed, 0xc3, 0x4c, 0xb8, 0xf7, 0x27, 0xe4, 0xbd, 0x4b,
	0xc3, 0x09, 0x86, 0x57, 0x27, 0x9a, 0x19, 0x71, 0x24, 0x0c, 0x25, 0xdb, 0xbf, 0x07, 0xc9, 0x60,
	0xda, 0x2f, 0x92, 0xa5, 0xe7, 0x1c, 0x1f, 0xa4, 0xbd, 0xa6, 0x95, 0x78, 0xe1, 0x6f, 0x24, 0x98,
	0x51, 0x31, 0x71, 0xda, 0x0f, 0xb0, 0x49, 0x63, 0x9e, 0xe0, 0x55, 0x89, 0x34, 0xf9, 0xab, 0x92,
	0x12, 0x24, 0x83, 0xbc, 0xe4, 0x45, 0x5e, 0x68, 0x0c, 0x6a, 0xa1, 0x1b, 0xa0, 0xb4, 0x9c, 0x9e,
	0x6d, 0xea, 0xee, 0x91, 0xe6, 0x62, 0xdd, 0x38, 0xc0, 0xa6, 0xb8, 0x83, 0x99, 0xf5, 0xe5, 0x2a,
	0x17, 0x17, 0x7e, 0x1c, 0x01, 0x34, 0x98, 0x9c, 0x10, 0x15, 0xd1, 0xc8, 0x8d, 0x8d, 0x43, 0x1c,
	0x5e, 0x23, 0x27, 0xde, 0x9a, 0x8d, 0x04, 0x80, 0xc1, 0xc0, 0xfd, 0x25, 0x75, 0x43, 0x32, 0x82,
	0xfe, 0xe8, 0xec, 0xec, 0x6b, 0x94, 0x65, 0x5f, 0x99, 0x95, 0xfe, 0x52, 0x33, 0xb0, 0xc2, 0x59,
	0xff, 0x77, 0x0c, 0x50, 0xc5, 0xc5, 0xba, 0x87, 0x29, 0xf3, 0x90, 0xb3, 0xce, 0xda, 0x65, 0x98,
	0xe6, 0x07, 0xb3, 0xc8, 0x45, 0x0e, 0x66, 0x62, 0x52, 0x78, 0x55, 0xf4, 0x03, 0x98, 0x31, 0x9c,
	0x76, 0xaf, 0x63, 0x6b, 0xec, 0xee, 0x58, 0x04, 0xc2, 0xdf, 0x3d, 0xcb, 0x88, 0xc7, 0x3a, 0x57,
	0xac, 0x38, 0x6d, 0xfa, 0xed, 0xe7, 0x0e, 0x38, 0x20, 0xd3, 0x40, 0xcf, 0x41, 0x32, 0xd8, 0x50,
	0x2c, 0x04, 0x4e, 0xaa, 0x03, 0x01, 0x5a, 0x81, 0x69, 0x9d, 0x68, 0xce, 0x1e, 0x8b, 0x51, 0xcf,
	0xb3, 0x30, 0x35, 0xa6, 0x93, 0xad, 0x3d, 0xf4, 0x26, 0xa4, 0xf7, 0xee, 0xf3, 0xb8, 0x9d, 0x13,
	0x28, 0xbf, 0xd2, 0x9f, 0x3d, 0xee, 0xe7, 0x53, 0x77, 0x3e, 0x64, 0x83, 0xa5, 0xf4, 0xa9, 0xa6,
	0xf6, 0xee, 0x07, 0x1f, 0xe8, 0x26, 0xcc, 0x75, 0xf4, 0x47, 0xda, 0x9e, 0xab, 0x1b, 0x22, 0x50,
	0x6d, 0x73, 0x56, 0x90, 0xd4, 0xd9, 0x8e, 0xfe, 0xe8, 0x8e, 0x90, 0xd7, 0xcd, 0x36, 0xce, 0xfd,
	0x97, 0x04, 0x09, 0x31, 0x22, 0xd4, 0x05, 0x10, 0xd3, 0x63, 0x99, 0x3c, 0x14, 0x4a, 0x97, 0x3f,
	0x3c, 0xee, 0xe7, 0x93, 0x15, 0x26, 0xad, 0x57, 0xc9, 0xd3, 0x7e, 0xfe, 0x83, 0x67, 0x25, 0x2d,
	0x1f, 0x44, 0x4d, 0xf2, 0x46, 0xea, 0x26, 0x4b, 0x0d, 0x1e, 0xe8, 0x44, 0x3b, 0xb0, 0x88, 0xe7,
	0xec, 0xbb, 0x7a, 0x87, 0x2d, 0xae, 0xac, 0xce, 0x1c, 0xe8, 0x64, 0xcd, 0x97, 0xa1, 0x1c, 0x0d,
	0x39, 0x1e, 0xf0, 0xab, 0x7f, 0xbe, 0xa5, 0x82, 0x6f, 0xb4, 0x02, 0x57, 0x82, 0xca, 0x1a, 0x1d,
	0x74, 0xab, 0x67, 0x1c, 0x62, 0xe6, 0x09, 0x28, 0x67, 0xcd, 0x07, 0x85, 0x1b, 0xfa, 0xa3, 0x32,
	0x2f, 0x2a, 0x5c, 0x81, 0xf9, 0xd0, 0xb2, 0x06, 0x01, 0xe2, 0x5f, 0xcd, 0x40, 0x62, 0x5b, 0x3f,
	0x6a, 0x3b, 0xba, 0x89, 0x96, 0x20, 0xe5, 0x5f, 0xd9, 0xd3, 0x10, 0x9b, 0xdb, 0x61, 0x58, 0x84,
	0x2c, 0xc8, 0xf4, 0x08, 0x76, 0xe9, 0x9a, 0x68, 0xec, 0x11, 0x2a, 0xe7, 0xaa, 0x72, 0xf9, 0x69,
	0x3f, 0x7f, 0x7b, 0xb2, 0x29, 0xc2, 0x46, 0xcf, 0xb5, 0xbc, 0xa3, 0x62, 0xf3, 0xc3, 0xbb, 0xbb,
	0x02, 0x8a, 0x6e, 0x24, 0x47, 0x4d, 0xf7, 0xc2, 0x9f, 0xe2, 0x01, 0x04, 0x1d, 0xae, 0xd6, 0xb1,
	0x0c, 0xd7, 0x21, 0x7e, 0x9e, 0x5c, 0x48, 0x37, 0x98, 0x10, 0xbd, 0x02, 0xb3, 0x7b, 0x96, 0xcd,
	0xee, 0x68, 0x7c, 0x3d, 0x9e, 0x22, 0xcf, 0xf8, 0x62, 0xa1, 0xf8, 0x00, 0x32, 0xa1, 0x47, 0x0f,
	0x74, 0xa9, 0xe3, 0x6c, 0xa9, 0xb7, 0x8e, 0xfb, 0xf9, 0xf4, 0x60, 0xeb, 0xf0, 0xe5, 0xbe, 0x8c,
	0x8f, 0x4a, 0x0f, 0x9a, 0xa1, 0x8b, 0xbd, 0x00, 0xd3, 0xec, 0xf1, 0x31, 0x7f, 0xe7, 0xa4, 0xf2,
	0x0f, 0xf4, 0x16, 0x4c, 0xb7, 0xb1, 0x4e, 0xb0, 0x78, 0xc2, 0xb4, 0x74, 0xc6, 0x66, 0x64, 0x6f,
	0x7c, 0x55, 0xae, 0x8e, 0xca, 0x10, 0xe7, 0xb7, 0x6e, 0xec, 0xae, 0x6c, 0x3c, 0x35, 0x79, 0xea,
	0x6b, 0xb5, 0xb5, 0x29, 0x55, 0xd4, 0x44, 0x35, 0x48, 0xb8, 0xfc, 0xa2, 0x95, 0xdd, 0xa0, 0x9d,
	0x7b, 0xd8, 0x0e, 0xdd, 0xe3, 0xae, 0x4d, 0xa9, 0x7e, 0x5d, 0xb4, 0xe3, 0xbf, 0x76, 0xe0, 0xac,
	0x2e, 0x1e, 0x73, 0x14, 0x27, 0x0c, 0xc8, 0x06, 0x80, 0x43, 0x28, 0x74, 0x80, 0x16, 0xcb, 0xba,
	0xb3, 0x8b, 0xb8, 0xb3, 0x07, 0x38, 0x74, 0x83, 0x4b, 0x07, 0xc8, 0x6b, 0xa2, 0x4d, 0x00, 0x23,
	0xf0, 0x34, 0xec, 0x8a, 0x2e, 0xb5, 0xf2, 0xda, 0x45, 0xa2, 0x99, 0xb5, 0x29, 0x35, 0x84, 0x80,
	0x3e, 0x84, 0x94, 0x31, 0xd8, 0x3a, 0xd9, 0x59, 0x06, 0xf8, 0xfa, 0x85, 0xf8, 0x73, 0x8d, 0x72,
	0xe6, 0x40, 0x3a, 0xcc, 0x99, 0xca, 0x28, 0x67, 0xd6, 0x20, 0x2d, 0xf2, 0x22, 0xfc, 0xdd, 0x7a,
	0x76, 0x8e, 0x51, 0x76, 0xd8, 0x4a, 0xfc, 0x97, 0xed, 0xc5, 0x9a, 0x6d, 0x38, 0x26, 0x36, 0x6b,
	0xf4, 0x5b, 0x15, 0x69, 0x60, 0xf6, 0x41, 0xd0, 0x2a, 0x64, 0x8c, 0x36, 0xd6, 0xed, 0x5e, 0xd7,
	0xc7, 0x41, 0x13, 0xe2, 0xa4, 0x45, 0x3d, 0x01, 0xb4, 0x09, 0x68, 0x8f, 0xbd, 0x90, 0x08, 0xf7,
	0x8a, 0xdd, 0xf4, 0x4d, 0x02, 0xa6, 0xb0, 0xba, 0xea, 0xa0, 0x67, 0xe8, 0x45, 0x48, 0xdb, 0x8e,
	0x6d, 0xe8, 0xb6, 0x81, 0xdb, 0xcc, 0xbb, 0xf1, 0xcb, 0xc1, 0x61, 0x21, 0xfa, 0x14, 0x32, 0x64,
	0x28, 0x84, 0xcf, 0x5e, 0x61, 0x2d, 0xbe, 0x71, 0xd1, 0xa4, 0xdf, 0xda, 0x94, 0x3a, 0x82, 0x84,
	0x7e, 0x0d, 0x14, 0x6f, 0xe4, 0x66, 0x80, 0x5d, 0x33, 0x9e, 0xfd, 0x1a, 0xe9, 0x94, 0xab, 0x8c,
	0xb5, 0x29, 0x75, 0x0c, 0x0d, 0x7d, 0x06, 0xb3, 0x64, 0xf8, 0xbd, 0x6d, 0xf6, 0x1a, 0x6b, 0xe0,
	0x3b, 0x67, 0xa6, 0xb7, 0x4f, 0x7a, 0xa2, 0xbc, 0x36, 0xa5, 0x8e, 0x62, 0x51, 0x78, 0x7b, 0xf8,
	0x82, 0x21, 0x9b, 0x3d, 0x17, 0xfe, 0xe4, 0x0b, 0x0f, 0x0a, 0x3f, 0x82, 0x55, 0x4e, 0x42, 0x42,
	0xdc, 0x02, 0x05, 0x77, 0xab, 0x09, 0x45, 0x2e, 0xfc, 0xa5, 0x0c, 0x72, 0x10, 0xba, 0x2d, 0x03,
	0x0a, 0x9c, 0xed, 0xe0, 0x41, 0x1b, 0xf5, 0x1a, 0x91, 0xb5, 0x29, 0x75, 0xce, 0x2f, 0x1b, 0xbc,
	0x69, 0x7b, 0x05, 0x66, 0x3b, 0x8e, 0x69, 0xed, 0x59, 0x03, 0xae, 0xe6, 0x99, 0xc2, 0x8c, 0x2f,
	0x16, 0x5c, 0x7d, 0x7b, 0xe8, 0xdd, 0xc7, 0x24, 0xef, 0x9d, 0xd7, 0xa6, 0x42, 0x0f, 0x43, 0xa8,
	0xef, 0x70, 0x7b, 0xb6, 0x6d, 0xd9, 0xfb, 0x9a, 0x38, 0x2d, 0xf2, 0xb0, 0x24, 0x2d, 0xa4, 0xe2,
	0xc0, 0x57, 0x19, 0x21, 0xd3, 0x1b, 0xe7, 0x92, 0xa9, 0x3f, 0xf6, 0x35, 0x29, 0x60, 0xd3, 0x3b,
	0xa3, 0x6c, 0x7a, 0xf3, 0x7c, 0x36, 0x0d, 0xc1, 0x04, 0x74, 0xba, 0x7b, 0x22, 0x9d, 0x2e, 0x4f,
	0x68, 0xeb, 0x21, 0xc4, 0x61, 0x3e, 0xad, 0x8c, 0xf0, 0xe9, 0x8d, 0x73, 0xf9, 0x34, 0x3c, 0x46,
	0x41, 0xa8, 0x5b, 0x27, 0x10, 0xea, 0xeb, 0x13, 0x11, 0x6a, 0x08, 0x2c, 0xcc, 0xa8, 0xea, 0x49,
	0x8c, 0x5a, 0x9c, 0x8c, 0x51, 0x43, 0x90, 0x43, 0x94, 0xfa, 0xfd, 0x31, 0xba, 0x50, 0xce, 0xdf,
	0x6f, 0x27, 0xa6, 0x08, 0xd6, 0xa4, 0x31, 0xbe, 0xd0, 0x4f, 0xe0, 0x8b, 0x39, 0x06, 0xff, 0xe6,
	0x05, 0xf8, 0x22, 0xd4, 0xc0, 0x38, 0x61, 0x7c, 0x0c, 0x33, 0xe1, 0x4d, 0xce, 0xde, 0x57, 0x9c,
	0x4d, 0x47, 0xa7, 0xbc, 0xe7, 0x67, 0x36, 0x10, 0x2a, 0x42, 0x3f, 0x18, 0xe7, 0x8a, 0xf9, 0x73,
	0xc1, 0x4f, 0xb9, 0xbe, 0x5c, 0x93, 0xc6, 0xc9, 0x02, 0x40, 0xf6, 0x6f, 0xa6, 0x43, 0xc4, 0x51,
	0xf8, 0x43, 0x09, 0xa2, 0x0d, 0xa7, 0x85, 0x32, 0x83, 0x6c, 0x13, 0xcb, 0x13, 0xbd, 0x3f, 0x50,
	0x17, 0xc7, 0x9a, 0x17, 0xce, 0xe8, 0x47, 0x90, 0x9d, 0x0b, 0x2a, 0xa1, 0x77, 0x21, 0xd1, 0xe5,
	0x21, 0xab, 0xe0, 0x86, 0xc2, 0x59, 0xf5, 0xb9, 0xa6, 0xea, 0x57, 0xb9, 0x79, 0x23, 0xfc, 0x9f,
	0x71, 0x36, 0x1c, 0x13, 0xa3, 0x0c, 0xc0, 0xb6, 0x4e, 0x48, 0xf7, 0xc0, 0xd5, 0x09, 0x56, 0xa6,
	0x50, 0x02, 0xa2, 0xeb, 0x1b, 0x4d, 0x45, 0xba, 0xf9, 0x71, 0x38, 0x37, 0x54, 0x55, 0x4b, 0xf5,
	0xcd, 0xfa, 0xe6, 0xaa, 0xb6, 0x59, 0xda, 0xa8, 0x35, 0x95, 0x29, 0x94, 0x85, 0x85, 0x8f, 0x4a,
	0xf5, 0x1d, 0x91, 0x2c, 0xd2, 0xea, 0x9b, 0x3b, 0x35, 0xf5, 0x5e, 0xe9, 0xae, 0x22, 0xa1, 0xab,
	0x80, 0xd4, 0xad, 0xca, 0x7a, 0xb3, 0x5a, 0xd6, 0x2a, 0x5b, 0x1b, 0xdb, 0xa5, 0xca, 0x4e, 0x7d,
	0x6b, 0x53, 0x89, 0x20, 0x19, 0x62, 0xd5, 0xad, 0xcd, 0x9a, 0x02, 0x37, 0x7f, 0x11, 0x85, 0x18,
	0xb5, 0x0e, 0xf4, 0x22, 0xa4, 0x76, 0x37, 0x9b, 0xdb, 0xb5, 0x4a, 0xfd, 0x4e, 0xbd, 0x56, 0x55,
	0xa6, 0x72, 0xf3, 0x8f, 0x9f, 0x2c, 0xcd, 0xd2, 0xa2, 0x5d, 0x9b, 0x74, 0xb1, 0xc1, 0x68, 0x11,
	0xe5, 0x20, 0x5e, 0x2e, 0x55, 0xd6, 0x77, 0xb7, 0x15, 0x29, 0x97, 0x79, 0xfc, 0x64, 0x09, 0xa8,
	0x02, 0xa7, 0x24, 0xf4, 0x1c, 0x24, 0xd4, 0x5a, 0x73, 0x67, 0x4b, 0xad, 0x29, 0x91, 0xdc, 0xec,
	0xe3, 0x27, 0x4b, 0x29, 0x5a, 0x28, 0x98, 0x06, 0xbd, 0x02, 0xe9, 0x66, 0x65, 0xad, 0xb6, 0x51,
	0xd2, 0x2a, 0x6b, 0xa5, 0xcd, 0xd5, 0x9a, 0x12, 0xcd, 0x2d, 0x3c, 0x7e, 0xb2, 0xa4, 0x8c, 0x9a,
	0x26, 0x6d, 0xa2, 0xbe, 0xb1, 0xbd, 0xa5, 0xee, 0x28, 0xb1, 0x41, 0x13, 0x9c, 0x11, 0x50, 0x01,
	0x80, 0xd7, 0xbe, 0x53, 0xab, 0x55, 0x95, 0xe9, 0x1c, 0x7a, 0xfc, 0x64, 0x29, 0x43, 0xcb, 0x07,
	0x1b, 0x1d, 0xbd, 0x04, 0x33, 0x15, 0xb5, 0x56, 0xda, 0xa9, 0x69, 0xcd, 0x9d, 0xd2, 0x4e, 0x53,
	0x89, 0x0f, 0x46, 0x12, 0xda, 0xbc, 0xa8, 0x08, 0x73, 0xa5, 0xdd, 0x9d, 0x2d, 0x6d, 0x48, 0x37,
	0x91, 0xbb, 0xf6, 0xf8, 0xc9, 0xd2, 0x3c, 0xd5, 0x2d, 0xf5, 0x3c, 0x27, 0xac, 0xff, 0x1a, 0x28,
	0x43, 0xfd, 0xd7, 0x56, 0x2b, 0x8a, 0x9c, 0xbb, 0xfa, 0xf8, 0xc9, 0x12, 0x1a, 0x1d, 0xc2, 0x6a,
	0x05, 0xfd, 0x7f, 0xb8, 0xba, 0xf3, 0xc9, 0x76, 0xad, 0x5a, 0x6b, 0x56, 0xb4, 0xe1, 0x61, 0x27,
	0x73, 0xd9, 0xc7, 0x4f, 0x96, 0x16, 0x68, 0x9d, 0xb1, 0xa1, 0xbf, 0x0e, 0x4a, 0x73, 0x47, 0xad,
	0x95, 0x36, 0xb4, 0xfa, 0xe6, 0x6a, 0xad, 0xc9, 0x16, 0x0b, 0x06, 0x5d, 0x1a, 0xd9, 0x66, 0x74,
	0x08, 0x9b, 0xb5, 0x8f, 0x46, 0xf0, 0x53, 0x03, 0xfd, 0x91, 0x9d, 0x93, 0x93, 0x7f, 0xfc, 0xe7,
	0x8b, 0x53, 0x7f, 0xf1, 0x93, 0xc5, 0xa9, 0xf2, 0xf5, 0x2f, 0xfe, 0x63, 0x71, 0xea, 0x8b, 0xe3,
	0x45, 0xe9, 0x67, 0xc7, 0x8b, 0xd2, 0x97, 0xc7, 0x8b, 0xd2, 0xbf, 0x1f, 0x2f, 0x4a, 0xbf, 0xff,
	0xd5, 0xe2, 0xd4, 0xcf, 0xbe, 0x5a, 0x9c, 0xfa, 0xf2, 0xab, 0xc5, 0xa9, 0x4f, 0xe3, 0xdc, 0x6a,
	0x5b, 0x71, 0x76, 0xba, 0x7a, 0xf3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x14, 0x3b, 0x78,
	0xf5, 0x38, 0x00, 0x00,
}
