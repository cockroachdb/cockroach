// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/index_usage_stats.proto

package roachpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IndexUsageStatistics represents the index usage statistics per index.
// Note that these stats are cleared for every
// sql.metrics.index_usage_stats.reset_interval.
// N.B. When fields are added to this struct, make sure to update
// (*IndexUsageStatistics).Add in roachpb/index_usage_stats.go.
type IndexUsageStatistics struct {
	// FullScanCount is the number of times full scan is being performed on this
	// index.
	FullScanCount uint64 `protobuf:"varint,1,opt,name=full_scan_count,json=fullScanCount" json:"full_scan_count"`
	// NonFullScanCount is the number of times non-full scan is being performed on
	// this index. In contrast to a full scan, where the entirety of the index
	// is being scanned, a non full scan only scans a portion of the index. This
	// should not be confused with partial index. A complete scan of a partial
	// index is still considered a full scan.
	NonFullScanCount uint64 `protobuf:"varint,2,opt,name=non_full_scan_count,json=nonFullScanCount" json:"non_full_scan_count"`
	// LookupJoinCount is the number of times lookup join is being performed on
	// this index.
	LookupJoinCount uint64 `protobuf:"varint,3,opt,name=lookup_join_count,json=lookupJoinCount" json:"lookup_join_count"`
	// ZigzagCount is the number of times zigzag join is being performed on
	// this index.
	ZigzagJoinCount uint64 `protobuf:"varint,4,opt,name=zigzag_join_count,json=zigzagJoinCount" json:"zigzag_join_count"`
	// InvertedCount is the number of times inverted join is being performed on
	// this index.
	InvertedJoinCount uint64 `protobuf:"varint,5,opt,name=inverted_join_count,json=invertedJoinCount" json:"inverted_join_count"`
	// LastScan is the timestamp that this index is last being scanned.
	LastScan time.Time `protobuf:"bytes,6,opt,name=last_scan,json=lastScan,stdtime" json:"last_scan"`
	// TotalScanRows is the number rows that this index has been scanned. It
	// includes the rows returned by all scan and join operations.
	// TODO(azhng): Currently this field is unused.
	TotalScanRows uint64 `protobuf:"varint,7,opt,name=total_scan_rows,json=totalScanRows" json:"total_scan_rows"`
	// TotalUpdatedRows is the number rows that has been updated in this index.
	// TODO(azhng): Currently this field is unused.
	UpdateCounts uint64 `protobuf:"varint,8,opt,name=update_counts,json=updateCounts" json:"update_counts"`
	// LastScan is the timestamp that this index is last being either scanned by
	// either full scan or non full scan operation.
	// TODO(azhng): Currently this field is unused.
	TotalUpdatedRows uint64 `protobuf:"varint,9,opt,name=total_updated_rows,json=totalUpdatedRows" json:"total_updated_rows"`
	// LastUpdate is the timestamp that this index was last updated.
	// TODO(azhng): Currently this field is unused.
	LastUpdate time.Time `protobuf:"bytes,10,opt,name=last_update,json=lastUpdate,stdtime" json:"last_update"`
	// LastJoin is the timestamp that this index is last used for a join. This
	// includes lookup join, inverted join and zigzag join.
	LastJoin time.Time `protobuf:"bytes,11,opt,name=last_join,json=lastJoin,stdtime" json:"last_join"`
}

func (m *IndexUsageStatistics) Reset()         { *m = IndexUsageStatistics{} }
func (m *IndexUsageStatistics) String() string { return proto.CompactTextString(m) }
func (*IndexUsageStatistics) ProtoMessage()    {}
func (*IndexUsageStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_7523d71560a74d6c, []int{0}
}
func (m *IndexUsageStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexUsageStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexUsageStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexUsageStatistics.Merge(m, src)
}
func (m *IndexUsageStatistics) XXX_Size() int {
	return m.Size()
}
func (m *IndexUsageStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexUsageStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_IndexUsageStatistics proto.InternalMessageInfo

// IndexUsageKey uniquely identifies an index. It's a tuple of TableID and a
// IndexID.
type IndexUsageKey struct {
	// TableID is the ID of the table this index is created on. This is same as
	// descpb.TableID and is unique within the cluster.
	TableID TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,casttype=TableID" json:"table_id"`
	// IndexID is the ID of the index within the scope of the given table.
	IndexID IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
}

func (m *IndexUsageKey) Reset()         { *m = IndexUsageKey{} }
func (m *IndexUsageKey) String() string { return proto.CompactTextString(m) }
func (*IndexUsageKey) ProtoMessage()    {}
func (*IndexUsageKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7523d71560a74d6c, []int{1}
}
func (m *IndexUsageKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexUsageKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexUsageKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexUsageKey.Merge(m, src)
}
func (m *IndexUsageKey) XXX_Size() int {
	return m.Size()
}
func (m *IndexUsageKey) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexUsageKey.DiscardUnknown(m)
}

var xxx_messageInfo_IndexUsageKey proto.InternalMessageInfo

// CollectedIndexUsageStatistics wraps collected index key and its usage
// statistics.
type CollectedIndexUsageStatistics struct {
	Key   IndexUsageKey        `protobuf:"bytes,1,opt,name=key" json:"key"`
	Stats IndexUsageStatistics `protobuf:"bytes,2,opt,name=stats" json:"stats"`
}

func (m *CollectedIndexUsageStatistics) Reset()         { *m = CollectedIndexUsageStatistics{} }
func (m *CollectedIndexUsageStatistics) String() string { return proto.CompactTextString(m) }
func (*CollectedIndexUsageStatistics) ProtoMessage()    {}
func (*CollectedIndexUsageStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_7523d71560a74d6c, []int{2}
}
func (m *CollectedIndexUsageStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectedIndexUsageStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectedIndexUsageStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectedIndexUsageStatistics.Merge(m, src)
}
func (m *CollectedIndexUsageStatistics) XXX_Size() int {
	return m.Size()
}
func (m *CollectedIndexUsageStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectedIndexUsageStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_CollectedIndexUsageStatistics proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IndexUsageStatistics)(nil), "cockroach.sql.IndexUsageStatistics")
	proto.RegisterType((*IndexUsageKey)(nil), "cockroach.sql.IndexUsageKey")
	proto.RegisterType((*CollectedIndexUsageStatistics)(nil), "cockroach.sql.CollectedIndexUsageStatistics")
}

func init() { proto.RegisterFile("roachpb/index_usage_stats.proto", fileDescriptor_7523d71560a74d6c) }

var fileDescriptor_7523d71560a74d6c = []byte{
	// 532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0x6d, 0x9a, 0xe2, 0xf4, 0x8c, 0x55, 0xea, 0x76, 0xb0, 0x22, 0xb0, 0xab, 0xb2, 0xb4,
	0x12, 0x72, 0x50, 0x28, 0x33, 0x22, 0x05, 0xa4, 0xc0, 0xe6, 0xb6, 0x0b, 0x8b, 0x75, 0xb1, 0xaf,
	0xe6, 0x88, 0xeb, 0x67, 0x72, 0x67, 0x4a, 0x2b, 0xf1, 0x1d, 0x3a, 0xf1, 0x99, 0x32, 0x76, 0xec,
	0x54, 0xc0, 0x99, 0xf9, 0x02, 0x4c, 0xe8, 0xee, 0x1c, 0x7c, 0x41, 0x30, 0x74, 0xbb, 0xf8, 0xff,
	0xff, 0xbd, 0x7b, 0xef, 0xaf, 0x77, 0x41, 0xc1, 0x14, 0x70, 0xf2, 0xbe, 0x1c, 0xf7, 0x69, 0x91,
	0x92, 0xcf, 0x71, 0xc5, 0x70, 0x46, 0x62, 0xc6, 0x31, 0x67, 0x61, 0x39, 0x05, 0x0e, 0xae, 0x93,
	0x40, 0x32, 0x91, 0xa6, 0x90, 0x7d, 0xcc, 0x7b, 0x5b, 0x19, 0x64, 0x20, 0x95, 0xbe, 0x38, 0x29,
	0x53, 0x2f, 0xc8, 0x00, 0xb2, 0x9c, 0xf4, 0xe5, 0xaf, 0x71, 0x75, 0xd2, 0xe7, 0xf4, 0x94, 0x30,
	0x8e, 0x4f, 0x4b, 0x65, 0xd8, 0xf9, 0xd9, 0x41, 0x5b, 0x23, 0x71, 0xc3, 0xb1, 0xb8, 0xe0, 0x90,
	0x63, 0x4e, 0x19, 0xa7, 0x09, 0x73, 0x1f, 0xa3, 0xf5, 0x93, 0x2a, 0xcf, 0x63, 0x96, 0xe0, 0x22,
	0x4e, 0xa0, 0x2a, 0xb8, 0x67, 0x6e, 0x9b, 0xbb, 0x9d, 0x61, 0x67, 0x76, 0x13, 0x18, 0x91, 0x23,
	0xc4, 0xc3, 0x04, 0x17, 0x07, 0x42, 0x72, 0x9f, 0xa2, 0xcd, 0x02, 0x8a, 0xf8, 0x6f, 0xe2, 0x8e,
	0x46, 0xdc, 0x2f, 0xa0, 0x78, 0xbd, 0x04, 0x3d, 0x41, 0x1b, 0x39, 0xc0, 0xa4, 0x2a, 0xe3, 0x0f,
	0x40, 0x17, 0xc8, 0x8a, 0x86, 0xac, 0x2b, 0xf9, 0x0d, 0xd0, 0x96, 0xb8, 0xa0, 0xd9, 0x05, 0xce,
	0x74, 0xa2, 0xa3, 0x13, 0x4a, 0x6e, 0x89, 0x7d, 0xb4, 0x49, 0x8b, 0x4f, 0x64, 0xca, 0x49, 0xaa,
	0x33, 0xab, 0x1a, 0xb3, 0xb1, 0x30, 0xb4, 0xd4, 0x0b, 0xb4, 0x96, 0x63, 0xc6, 0xe5, 0x28, 0xde,
	0xdd, 0x6d, 0x73, 0xd7, 0x1e, 0xf4, 0x42, 0x15, 0x65, 0xb8, 0x88, 0x32, 0x3c, 0x5a, 0x44, 0x39,
	0xec, 0x8a, 0x3a, 0x97, 0xdf, 0x02, 0x33, 0xea, 0x0a, 0x4c, 0x4c, 0x28, 0xf2, 0xe3, 0xc0, 0x71,
	0x13, 0xc7, 0x14, 0xce, 0x98, 0x67, 0xe9, 0xf9, 0x49, 0x51, 0x38, 0x23, 0x38, 0x63, 0xee, 0x1e,
	0x72, 0xaa, 0x32, 0xc5, 0x9c, 0xa8, 0xfe, 0x98, 0xd7, 0xd5, 0xbc, 0xf7, 0x94, 0x24, 0x5b, 0x63,
	0xee, 0x00, 0xb9, 0xaa, 0xb0, 0xfa, 0x9a, 0xaa, 0xda, 0x6b, 0x7a, 0xd2, 0x52, 0x3f, 0x56, 0xb2,
	0x2c, 0xff, 0x0a, 0xd9, 0x72, 0x1e, 0x85, 0x78, 0xe8, 0x16, 0x13, 0x21, 0x01, 0xaa, 0x5a, 0x7f,
	0x62, 0x11, 0x41, 0x7a, 0xf6, 0x6d, 0x63, 0x11, 0xf1, 0xee, 0x7c, 0x41, 0x4e, 0xbb, 0x6e, 0x6f,
	0xc9, 0xb9, 0xfb, 0x0c, 0x75, 0x39, 0x1e, 0xe7, 0x24, 0xa6, 0xa9, 0x5c, 0x30, 0x67, 0xd8, 0x13,
	0x58, 0x7d, 0x13, 0x58, 0x47, 0xe2, 0xfb, 0xe8, 0xe5, 0xaf, 0xf6, 0x18, 0x59, 0xd2, 0x3b, 0x4a,
	0x05, 0xa6, 0x1e, 0x06, 0x4d, 0xe5, 0x96, 0x69, 0x98, 0xac, 0xaf, 0xb0, 0xe6, 0x18, 0x59, 0xd2,
	0x3b, 0x4a, 0x77, 0xbe, 0x9a, 0xe8, 0xe1, 0x01, 0xe4, 0x39, 0x49, 0x38, 0x49, 0xff, 0xb9, 0xf7,
	0xfb, 0x68, 0x65, 0x42, 0xce, 0x65, 0x2b, 0xf6, 0xe0, 0x41, 0xb8, 0xf4, 0xc8, 0xc2, 0xa5, 0xd6,
	0x9b, 0xb4, 0x85, 0xdd, 0x7d, 0x8e, 0x56, 0xe5, 0xdb, 0x94, 0xbd, 0xd8, 0x83, 0x47, 0xff, 0xe5,
	0xda, 0x9b, 0x1a, 0x5c, 0x71, 0xc3, 0xbd, 0xd9, 0x0f, 0xdf, 0x98, 0xd5, 0xbe, 0x79, 0x55, 0xfb,
	0xe6, 0x75, 0xed, 0x9b, 0xdf, 0x6b, 0xdf, 0xbc, 0x9c, 0xfb, 0xc6, 0xd5, 0xdc, 0x37, 0xae, 0xe7,
	0xbe, 0xf1, 0xce, 0x6a, 0xfe, 0x10, 0x7e, 0x07, 0x00, 0x00, 0xff, 0xff, 0x58, 0x8c, 0xf0, 0x7a,
	0x1a, 0x04, 0x00, 0x00,
}

func (m *IndexUsageStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexUsageStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexUsageStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastJoin, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastJoin):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x5a
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdate):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x52
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.TotalUpdatedRows))
	i--
	dAtA[i] = 0x48
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.UpdateCounts))
	i--
	dAtA[i] = 0x40
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.TotalScanRows))
	i--
	dAtA[i] = 0x38
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastScan, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastScan):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x32
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.InvertedJoinCount))
	i--
	dAtA[i] = 0x28
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.ZigzagJoinCount))
	i--
	dAtA[i] = 0x20
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.LookupJoinCount))
	i--
	dAtA[i] = 0x18
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.NonFullScanCount))
	i--
	dAtA[i] = 0x10
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.FullScanCount))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexUsageKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexUsageKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexUsageKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.IndexID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintIndexUsageStats(dAtA, i, uint64(m.TableID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *CollectedIndexUsageStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectedIndexUsageStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectedIndexUsageStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexUsageStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexUsageStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintIndexUsageStats(dAtA []byte, offset int, v uint64) int {
	offset -= sovIndexUsageStats(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IndexUsageStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexUsageStats(uint64(m.FullScanCount))
	n += 1 + sovIndexUsageStats(uint64(m.NonFullScanCount))
	n += 1 + sovIndexUsageStats(uint64(m.LookupJoinCount))
	n += 1 + sovIndexUsageStats(uint64(m.ZigzagJoinCount))
	n += 1 + sovIndexUsageStats(uint64(m.InvertedJoinCount))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastScan)
	n += 1 + l + sovIndexUsageStats(uint64(l))
	n += 1 + sovIndexUsageStats(uint64(m.TotalScanRows))
	n += 1 + sovIndexUsageStats(uint64(m.UpdateCounts))
	n += 1 + sovIndexUsageStats(uint64(m.TotalUpdatedRows))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovIndexUsageStats(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastJoin)
	n += 1 + l + sovIndexUsageStats(uint64(l))
	return n
}

func (m *IndexUsageKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexUsageStats(uint64(m.TableID))
	n += 1 + sovIndexUsageStats(uint64(m.IndexID))
	return n
}

func (m *CollectedIndexUsageStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovIndexUsageStats(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovIndexUsageStats(uint64(l))
	return n
}

func sovIndexUsageStats(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIndexUsageStats(x uint64) (n int) {
	return sovIndexUsageStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IndexUsageStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexUsageStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexUsageStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexUsageStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScanCount", wireType)
			}
			m.FullScanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullScanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonFullScanCount", wireType)
			}
			m.NonFullScanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NonFullScanCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupJoinCount", wireType)
			}
			m.LookupJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookupJoinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoinCount", wireType)
			}
			m.ZigzagJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZigzagJoinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedJoinCount", wireType)
			}
			m.InvertedJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedJoinCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastScan, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScanRows", wireType)
			}
			m.TotalScanRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalScanRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCounts", wireType)
			}
			m.UpdateCounts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateCounts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUpdatedRows", wireType)
			}
			m.TotalUpdatedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUpdatedRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastJoin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexUsageStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexUsageKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexUsageStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexUsageKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexUsageKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexUsageStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectedIndexUsageStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexUsageStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedIndexUsageStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedIndexUsageStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexUsageStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexUsageStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndexUsageStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndexUsageStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexUsageStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIndexUsageStats
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIndexUsageStats
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIndexUsageStats
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIndexUsageStats        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndexUsageStats          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIndexUsageStats = fmt.Errorf("proto: unexpected end of group")
)
