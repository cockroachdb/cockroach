// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/data.proto

package roachpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_storage_engine_enginepb "github.com/cockroachdb/cockroach/pkg/storage/engine/enginepb"
import cockroach_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"

import bytes "bytes"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ValueType defines a set of type constants placed in the "tag" field of Value
// messages. These are defined as a protocol buffer enumeration so that they
// can be used portably between our Go and C code. The tags are used by the
// RocksDB Merge Operator to perform specialized merges.
type ValueType int32

const (
	// This is a subset of the SQL column type values, representing the underlying
	// storage for various types. The DELIMITED_foo entries each represent a foo
	// variant that self-delimits length.
	ValueType_UNKNOWN           ValueType = 0
	ValueType_NULL              ValueType = 7
	ValueType_INT               ValueType = 1
	ValueType_FLOAT             ValueType = 2
	ValueType_BYTES             ValueType = 3
	ValueType_DELIMITED_BYTES   ValueType = 8
	ValueType_TIME              ValueType = 4
	ValueType_DECIMAL           ValueType = 5
	ValueType_DELIMITED_DECIMAL ValueType = 9
	ValueType_DURATION          ValueType = 6
	// TUPLE represents a DTuple, encoded as repeated pairs of varint field number
	// followed by a value encoded Datum.
	ValueType_TUPLE ValueType = 10
	// TIMESERIES is applied to values which contain InternalTimeSeriesData.
	ValueType_TIMESERIES ValueType = 100
)

var ValueType_name = map[int32]string{
	0:   "UNKNOWN",
	7:   "NULL",
	1:   "INT",
	2:   "FLOAT",
	3:   "BYTES",
	8:   "DELIMITED_BYTES",
	4:   "TIME",
	5:   "DECIMAL",
	9:   "DELIMITED_DECIMAL",
	6:   "DURATION",
	10:  "TUPLE",
	100: "TIMESERIES",
}
var ValueType_value = map[string]int32{
	"UNKNOWN":           0,
	"NULL":              7,
	"INT":               1,
	"FLOAT":             2,
	"BYTES":             3,
	"DELIMITED_BYTES":   8,
	"TIME":              4,
	"DECIMAL":           5,
	"DELIMITED_DECIMAL": 9,
	"DURATION":          6,
	"TUPLE":             10,
	"TIMESERIES":        100,
}

func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}
func (ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

// ReplicaChangeType is a parameter of ChangeReplicasTrigger.
type ReplicaChangeType int32

const (
	ADD_REPLICA    ReplicaChangeType = 0
	REMOVE_REPLICA ReplicaChangeType = 1
)

var ReplicaChangeType_name = map[int32]string{
	0: "ADD_REPLICA",
	1: "REMOVE_REPLICA",
}
var ReplicaChangeType_value = map[string]int32{
	"ADD_REPLICA":    0,
	"REMOVE_REPLICA": 1,
}

func (x ReplicaChangeType) String() string {
	return proto.EnumName(ReplicaChangeType_name, int32(x))
}
func (ReplicaChangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	1: "COMMITTED",
	2: "ABORTED",
}
var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}
func (TransactionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

// Span is supplied with every storage node request.
type Span struct {
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The end key is empty if the request spans only a single key. Otherwise,
	// it must order strictly after Key. In such a case, the header indicates
	// that the operation takes place on the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=Key" json:"end_key,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

// Value specifies the value at a key. Multiple values at the same key are
// supported based on timestamp. The data stored within a value is typed
// (ValueType) and custom encoded into the raw_bytes field. A custom encoding
// is used instead of separate proto fields to avoid proto overhead and to
// avoid unnecessary encoding and decoding as the value gets read from disk and
// passed through the network. The format is:
//
//   <4-byte-checksum><1-byte-tag><encoded-data>
//
// A CRC-32-IEEE checksum is computed from the associated key, tag and encoded
// data, in that order.
//
// TODO(peter): Is a 4-byte checksum overkill when most (all?) values
// will be less than 64KB?
type Value struct {
	// raw_bytes contains the encoded value and checksum.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
	// Timestamp of value.
	Timestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key   Key   `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Value Value `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"cluster_id"`
	NodeID    NodeID                                              `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	StoreID   StoreID                                             `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3,casttype=StoreID" json:"store_id,omitempty"`
}

func (m *StoreIdent) Reset()                    { *m = StoreIdent{} }
func (m *StoreIdent) String() string            { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()               {}
func (*StoreIdent) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) and the new range descriptor covering
// the right hand side of the split (right_desc). This information
// allows the final bookkeeping for the split to be completed and the
// new range put into operation.
type SplitTrigger struct {
	LeftDesc  RangeDescriptor `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc" json:"left_desc"`
	RightDesc RangeDescriptor `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc" json:"right_desc"`
}

func (m *SplitTrigger) Reset()                    { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string            { return proto.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()               {}
func (*SplitTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{4} }

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) that now encompasses what was
// originally both ranges and the soon-to-be-invalid range descriptor
// that used to cover the subsumed, right hand side of the merge
// (right_desc). This information allows the final bookkeeping for the
// merge to be completed and put into operation.
type MergeTrigger struct {
	LeftDesc  RangeDescriptor `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc" json:"left_desc"`
	RightDesc RangeDescriptor `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc" json:"right_desc"`
}

func (m *MergeTrigger) Reset()                    { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string            { return proto.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()               {}
func (*MergeTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5} }

type ChangeReplicasTrigger struct {
	ChangeType ReplicaChangeType `protobuf:"varint,1,opt,name=change_type,json=changeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"change_type,omitempty"`
	// The replica being modified.
	Replica ReplicaDescriptor `protobuf:"bytes,2,opt,name=replica" json:"replica"`
	// The new replica list with this change applied.
	UpdatedReplicas []ReplicaDescriptor `protobuf:"bytes,3,rep,name=updated_replicas,json=updatedReplicas" json:"updated_replicas"`
	NextReplicaID   ReplicaID           `protobuf:"varint,4,opt,name=next_replica_id,json=nextReplicaId,proto3,casttype=ReplicaID" json:"next_replica_id,omitempty"`
}

func (m *ChangeReplicasTrigger) Reset()                    { *m = ChangeReplicasTrigger{} }
func (*ChangeReplicasTrigger) ProtoMessage()               {}
func (*ChangeReplicasTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{6} }

// ModifiedSpanTrigger indicates that a specific span has been modified.
// This can be used to trigger scan-and-gossip for the given span.
type ModifiedSpanTrigger struct {
	SystemConfigSpan bool `protobuf:"varint,1,opt,name=system_config_span,json=systemConfigSpan,proto3" json:"system_config_span,omitempty"`
	// node_liveness_span is set to indicate that node liveness records
	// need re-gossiping after modification or range lease updates. The
	// span is set to a single key when nodes update their liveness records
	// with heartbeats to extend the expiration timestamp. Changes to the
	// range lease for the range containing node liveness triggers re-gossip
	// of the entire node liveness key range.
	NodeLivenessSpan *Span `protobuf:"bytes,2,opt,name=node_liveness_span,json=nodeLivenessSpan" json:"node_liveness_span,omitempty"`
}

func (m *ModifiedSpanTrigger) Reset()                    { *m = ModifiedSpanTrigger{} }
func (m *ModifiedSpanTrigger) String() string            { return proto.CompactTextString(m) }
func (*ModifiedSpanTrigger) ProtoMessage()               {}
func (*ModifiedSpanTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{7} }

// InternalCommitTrigger encapsulates all of the internal-only commit triggers.
// Only one may be set.
type InternalCommitTrigger struct {
	SplitTrigger          *SplitTrigger          `protobuf:"bytes,1,opt,name=split_trigger,json=splitTrigger" json:"split_trigger,omitempty"`
	MergeTrigger          *MergeTrigger          `protobuf:"bytes,2,opt,name=merge_trigger,json=mergeTrigger" json:"merge_trigger,omitempty"`
	ChangeReplicasTrigger *ChangeReplicasTrigger `protobuf:"bytes,3,opt,name=change_replicas_trigger,json=changeReplicasTrigger" json:"change_replicas_trigger,omitempty"`
	ModifiedSpanTrigger   *ModifiedSpanTrigger   `protobuf:"bytes,4,opt,name=modified_span_trigger,json=modifiedSpanTrigger" json:"modified_span_trigger,omitempty"`
}

func (m *InternalCommitTrigger) Reset()                    { *m = InternalCommitTrigger{} }
func (m *InternalCommitTrigger) String() string            { return proto.CompactTextString(m) }
func (*InternalCommitTrigger) ProtoMessage()               {}
func (*InternalCommitTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{8} }

func (m *InternalCommitTrigger) GetSplitTrigger() *SplitTrigger {
	if m != nil {
		return m.SplitTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetMergeTrigger() *MergeTrigger {
	if m != nil {
		return m.MergeTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetChangeReplicasTrigger() *ChangeReplicasTrigger {
	if m != nil {
		return m.ChangeReplicasTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetModifiedSpanTrigger() *ModifiedSpanTrigger {
	if m != nil {
		return m.ModifiedSpanTrigger
	}
	return nil
}

type ObservedTimestamp struct {
	NodeID    NodeID                       `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	Timestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *ObservedTimestamp) Reset()                    { *m = ObservedTimestamp{} }
func (m *ObservedTimestamp) String() string            { return proto.CompactTextString(m) }
func (*ObservedTimestamp) ProtoMessage()               {}
func (*ObservedTimestamp) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{9} }

// A Transaction is a unit of work performed on the database.
// Cockroach transactions support two isolation levels: snapshot
// isolation and serializable snapshot isolation. Each Cockroach
// transaction is assigned a random priority. This priority will be
// used to decide whether a transaction will be aborted during
// contention.
//
// If you add fields to Transaction you'll need to update
// Transaction.Clone. Failure to do so will result in test failures.
type Transaction struct {
	// The transaction metadata. These are persisted with every intent.
	cockroach_storage_engine_enginepb.TxnMeta `protobuf:"bytes,1,opt,name=meta,embedded=meta" json:"meta"`
	// A free-text identifier for debug purposes.
	Name          string                       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Status        TransactionStatus            `protobuf:"varint,4,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	LastHeartbeat cockroach_util_hlc.Timestamp `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat" json:"last_heartbeat"`
	// The original timestamp at which the transaction started. For serializable
	// transactions, if the timestamp drifts from the original timestamp, the
	// transaction will retry unless we manage to "refresh the reads" - see
	// refreshed_timestamp.
	//
	// This timestamp is the one at which all transactions will read, unless
	// refreshed_timestamp is set. It is also, surprisingly, the timestamp at
	// which transactions will provisionally _write_ (i.e. intents are written at
	// this orig_timestamp and, after commit, when the intents are resolved,
	// their timestamps are bumped to the to the commit timestamp), if
	// refreshed_timestamp isn't set.
	// This is ultimately because of correctness concerns around SNAPSHOT
	// transactions.
	//
	// Intuitively, one could think that the timestamp at which intents should be
	// written should be the provisional commit timestamp, and while this is
	// morally true, consider the following scenario, where txn1 is a SNAPSHOT
	// txn:
	//
	// - txn1 at orig_timestamp=5 reads key1: (value) 1.
	// - txn1 writes elsewhere, has its commit timestamp increased to 20.
	// - txn2 at orig_timestamp=10 reads key1: 1
	// - txn2 increases the value by 5: key1: 6 and commits
	// - txn1 increases the value by 1: key1: 2, attempts commit
	//
	// If txn1 uses its orig_timestamp for updating key1 (as it does), it
	// conflicts with txn2's committed value (which is at timestamp 10, in the
	// future of 5), and restarts.
	// Using instead its candidate commit timestamp, it wouldn't see a conflict
	// and commit, but this is not the expected outcome (the expected outcome is
	// {key1: 6} (since txn2 is not expected to commit)) and we would be
	// experiencing the Lost Update Anomaly.
	//
	// Note that in practice, before restarting, txn1 would still lay down an
	// intent (just above the committed value) not with the intent to commit it,
	// but to avoid being starved by short-lived transactions on that key which
	// would otherwise not have to go through conflict resolution with txn1.
	//
	// Again, keep in mind that, when the transaction commits, all the intents are
	// bumped to the commit timestamp (otherwise, pushing a transaction wouldn't
	// achieve anything).
	OrigTimestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,6,opt,name=orig_timestamp,json=origTimestamp" json:"orig_timestamp"`
	// Initial Timestamp + clock skew. Reads which encounter values with
	// timestamps between timestamp and max_timestamp trigger a txn
	// retry error, unless the node being read is listed in observed_timestamps
	// (in which case no more read uncertainty can occur).
	// The case max_timestamp < timestamp is possible for transactions which have
	// been pushed; in this case, max_timestamp should be ignored.
	MaxTimestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,7,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp"`
	// The refreshed timestamp is the timestamp at which the transaction
	// can commit without necessitating a serializable restart. This
	// value is forwarded to the transaction's current timestamp (meta.timestamp)
	// if the transaction coordinator is able to refresh all refreshable spans
	// encountered during the course of the txn. If set, this take precedence
	// over orig_timestamp and is the timestamp at which the transaction both
	// reads and writes going forward.
	RefreshedTimestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,15,opt,name=refreshed_timestamp,json=refreshedTimestamp" json:"refreshed_timestamp"`
	// A list of <NodeID, timestamp> pairs. The list maps NodeIDs to timestamps
	// as observed from their local clock during this transaction. The purpose of
	// this map is to avoid uncertainty related restarts which normally occur
	// when reading a value in the near future as per the max_timestamp field.
	//
	// Morally speaking, having an entry for a node in this map means that this
	// node has been visited before, and that no more uncertainty restarts are
	// expected for operations served from it. However, this is not entirely
	// accurate. For example, say a txn starts with orig_timestamp=1 (and some
	// large max_timestamp). It then reads key "a" from node A, registering an
	// entry `A -> 5` in the process (`5` happens to be a timestamp taken off
	// that node's clock at the end of the read).
	// Now assume that some other transaction writes and commits a value at key "b"
	// and timestamp 4 (again, served by node A), and our transaction attempts to
	// read that key. Since there is an entry in its observed_timestamps for A,
	// our uncertainty window is `[orig_timestamp, 5) = [1, 5)` but the value at
	// key "b" is in that window, and so we will restart. However, we will restart
	// with a timestamp that is at least high as our entry in the map for node A,
	// so no future operation on node A will be uncertain.
	//
	// Thus, expressed properly, you could say that when a node has been read from
	// successfully before, uncertainty on that node is restricted to values with
	// timestamps in the interval [orig_timestamp, first_visit_timestamp), and
	// that no node will trigger restarts more than once (and in fact, usually
	// the first restart also bumps the txn timestamp enough to clear all other
	// nodes).
	//
	// When this list holds a corresponding entry for the node the current
	// request is executing on, we can run the command with the map's timestamp
	// as the top boundary of our uncertainty interval, limiting (and often
	// avoiding) uncertainty restarts.
	//
	// When a transaction is first initialized on a node, it may use a timestamp
	// from the local hybrid logical clock to initialize the corresponding entry
	// in the map. In particular, if `orig_timestamp` is taken from that node's
	// clock, we may add that to the map, which eliminates read uncertainty for
	// reads on that node.
	//
	// The list of observed timestamps is kept sorted by NodeID. Use
	// Transaction.UpdateObservedTimestamp to maintain the sorted order.
	ObservedTimestamps []ObservedTimestamp `protobuf:"bytes,8,rep,name=observed_timestamps,json=observedTimestamps" json:"observed_timestamps"`
	// Writing is true if the transaction has previously executed a successful
	// write request, i.e. a request that may have left intents (across retries).
	Writing bool `protobuf:"varint,9,opt,name=writing,proto3" json:"writing,omitempty"`
	// If this is true, the transaction must retry. Relevant only for
	// SNAPSHOT transactions: a SERIALIZABLE transaction would have to
	// retry anyway due to its commit timestamp having moved forward.
	// This bool is set instead of immediately returning a txn retry
	// error so that intents can continue to be laid down, minimizing
	// work required on txn restart.
	WriteTooOld bool `protobuf:"varint,12,opt,name=write_too_old,json=writeTooOld,proto3" json:"write_too_old,omitempty"`
	// If retry_on_push is true, the transaction must retry in the event
	// that the commit timestamp is pushed forward. This flag is set if
	// the transaction contains any calls to DeleteRange, in order to
	// prevent the LostDeleteRange anomaly. This flag is relevant only
	// for SNAPSHOT transactions.
	RetryOnPush bool   `protobuf:"varint,13,opt,name=retry_on_push,json=retryOnPush,proto3" json:"retry_on_push,omitempty"`
	Intents     []Span `protobuf:"bytes,11,rep,name=intents" json:"intents"`
	// Epoch zero timestamp is used to keep track of the earliest timestamp
	// that any epoch of the transaction used. This is set only if the
	// transaction is restarted and the epoch is bumped. It is used during
	// intent resolution to more efficiently scan for intents.
	EpochZeroTimestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,14,opt,name=epoch_zero_timestamp,json=epochZeroTimestamp" json:"epoch_zero_timestamp"`
	// This flag is set if the transaction's original timestamp was
	// "leaked" beyond the transaction (i.e. if returned via NOW() or
	// transaction_timestamp()). If true, this prevents optimizations
	// which commit at a higher timestamp without resorting to a
	// client-side retry.
	OrigTimestampWasObserved bool `protobuf:"varint,16,opt,name=orig_timestamp_was_observed,json=origTimestampWasObserved,proto3" json:"orig_timestamp_was_observed,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{10} }

// A Intent is a Span together with a Transaction metadata and its status.
type Intent struct {
	Span   `protobuf:"bytes,1,opt,name=span,embedded=span" json:"span"`
	Txn    cockroach_storage_engine_enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn" json:"txn"`
	Status TransactionStatus                         `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
}

func (m *Intent) Reset()                    { *m = Intent{} }
func (m *Intent) String() string            { return proto.CompactTextString(m) }
func (*Intent) ProtoMessage()               {}
func (*Intent) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{11} }

// Lease contains information about range leases including the
// expiration and lease holder.
type Lease struct {
	// The start is a timestamp at which the lease begins. This value
	// must be greater than the last lease expiration or the lease request
	// is considered invalid.
	Start cockroach_util_hlc.Timestamp `protobuf:"bytes,1,opt,name=start" json:"start"`
	// The expiration is a timestamp at which the lease expires. This means that
	// a new lease can be granted for a later timestamp.
	Expiration *cockroach_util_hlc.Timestamp `protobuf:"bytes,2,opt,name=expiration" json:"expiration,omitempty" cockroachdb:"randnullable"`
	// The address of the would-be lease holder.
	Replica ReplicaDescriptor `protobuf:"bytes,3,opt,name=replica" json:"replica"`
	// The start of the lease stasis period. This field is deprecated.
	DeprecatedStartStasis *cockroach_util_hlc.Timestamp `protobuf:"bytes,4,opt,name=deprecated_start_stasis,json=deprecatedStartStasis" json:"deprecated_start_stasis,omitempty" cockroachdb:"randnullable"`
	// The current timestamp when this lease has been proposed. Used after a
	// transfer and after a node restart to enforce that a node only uses leases
	// proposed after the time of the said transfer or restart. This is nullable
	// to help with the rollout (such that a lease applied by some nodes before
	// the rollout and some nodes after the rollout is serialized the same).
	// TODO(andrei): Make this non-nullable after the rollout.
	ProposedTS *cockroach_util_hlc.Timestamp `protobuf:"bytes,5,opt,name=proposed_ts,json=proposedTs" json:"proposed_ts,omitempty"`
	// The epoch of the lease holder's node liveness entry. If this value
	// is non-zero, the start and expiration values are ignored.
	Epoch int64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// A zero-indexed sequence number which is incremented during the acquisition
	// of each new range lease that is not equivalent to the previous range lease
	// (i.e. an acquisition that implies a leaseholder change). The sequence
	// number is used to detect lease changes between command proposal and
	// application without requiring that we send the entire lease through Raft.
	// Lease sequence numbers are a reflection of the "lease equivalency" property
	// (see Lease.Equivalent). Two adjacent leases that are equivalent will have
	// the same sequence number and two adjacent leases that are not equivalent
	// will have different sequence numbers.
	Sequence LeaseSequence `protobuf:"varint,7,opt,name=sequence,proto3,casttype=LeaseSequence" json:"sequence,omitempty"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{12} }

// AbortSpanEntry contains information about a transaction which has
// been aborted. It's written to a range's AbortSpan if the range
// may have contained intents of the aborted txn. In the event that
// the same transaction attempts to read keys it may have written
// previously, this entry informs the transaction that it has aborted
// and must start fresh with an updated priority.
type AbortSpanEntry struct {
	// The key of the associated transaction.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The candidate commit timestamp the transaction record held at the time
	// it was aborted.
	Timestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// The priority of the transaction.
	Priority int32 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *AbortSpanEntry) Reset()                    { *m = AbortSpanEntry{} }
func (m *AbortSpanEntry) String() string            { return proto.CompactTextString(m) }
func (*AbortSpanEntry) ProtoMessage()               {}
func (*AbortSpanEntry) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{13} }

// TxnCoordMeta is metadata held by a transaction coordinator. This
// message is defined here because it is used in several layers of the
// system (internal/client, sql/distsqlrun, kv).
type TxnCoordMeta struct {
	// txn is a copy of the transaction record, updated with each request.
	Txn Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	// intents stores key spans affected by this transaction through
	// this coordinator. These spans allow the coordinator to set the
	// list of intent spans in the EndTransactionRequest when the
	// transaction is finalized.
	Intents []Span `protobuf:"bytes,2,rep,name=intents" json:"intents"`
	// command_count indicates how many requests have been sent through
	// this transaction. Reset on retryable txn errors.
	CommandCount int32 `protobuf:"varint,3,opt,name=command_count,json=commandCount,proto3" json:"command_count,omitempty"`
	// refresh_reads and refresh_writes store key spans which were read
	// or, less frequently, written during a transaction. These fields
	// are utilized for SERIALIZABLE transactions in the event a
	// transaction experiences a retry error. In that case, the
	// coordinator uses the Refresh and RefreshRange RPCs to verify that
	// no write has occurred to the spans more recently than the txn's
	// original timestamp, and updates the affected timestamp caches to
	// the transaction's refreshed timestamp. On failure, the retry
	// error is propagated. On success, the transaction's original and
	// current timestamps are forwarded to the refresh timestamp, and
	// the transaction can continue.
	RefreshReads  []Span `protobuf:"bytes,4,rep,name=refresh_reads,json=refreshReads" json:"refresh_reads"`
	RefreshWrites []Span `protobuf:"bytes,5,rep,name=refresh_writes,json=refreshWrites" json:"refresh_writes"`
	// refresh_valid indicates that all spans encountered during the
	// transaction which need refreshing have been collected to the
	// refresh_reads and refresh_writes span slices. This is false if
	// any spans were discarded or not collected (i.e. because of a dist
	// SQL processor running a version before refreshing was introduced).
	RefreshValid bool `protobuf:"varint,6,opt,name=refresh_valid,json=refreshValid,proto3" json:"refresh_valid,omitempty"`
}

func (m *TxnCoordMeta) Reset()                    { *m = TxnCoordMeta{} }
func (m *TxnCoordMeta) String() string            { return proto.CompactTextString(m) }
func (*TxnCoordMeta) ProtoMessage()               {}
func (*TxnCoordMeta) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{14} }

func init() {
	proto.RegisterType((*Span)(nil), "cockroach.roachpb.Span")
	proto.RegisterType((*Value)(nil), "cockroach.roachpb.Value")
	proto.RegisterType((*KeyValue)(nil), "cockroach.roachpb.KeyValue")
	proto.RegisterType((*StoreIdent)(nil), "cockroach.roachpb.StoreIdent")
	proto.RegisterType((*SplitTrigger)(nil), "cockroach.roachpb.SplitTrigger")
	proto.RegisterType((*MergeTrigger)(nil), "cockroach.roachpb.MergeTrigger")
	proto.RegisterType((*ChangeReplicasTrigger)(nil), "cockroach.roachpb.ChangeReplicasTrigger")
	proto.RegisterType((*ModifiedSpanTrigger)(nil), "cockroach.roachpb.ModifiedSpanTrigger")
	proto.RegisterType((*InternalCommitTrigger)(nil), "cockroach.roachpb.InternalCommitTrigger")
	proto.RegisterType((*ObservedTimestamp)(nil), "cockroach.roachpb.ObservedTimestamp")
	proto.RegisterType((*Transaction)(nil), "cockroach.roachpb.Transaction")
	proto.RegisterType((*Intent)(nil), "cockroach.roachpb.Intent")
	proto.RegisterType((*Lease)(nil), "cockroach.roachpb.Lease")
	proto.RegisterType((*AbortSpanEntry)(nil), "cockroach.roachpb.AbortSpanEntry")
	proto.RegisterType((*TxnCoordMeta)(nil), "cockroach.roachpb.TxnCoordMeta")
	proto.RegisterEnum("cockroach.roachpb.ValueType", ValueType_name, ValueType_value)
	proto.RegisterEnum("cockroach.roachpb.ReplicaChangeType", ReplicaChangeType_name, ReplicaChangeType_value)
	proto.RegisterEnum("cockroach.roachpb.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
}
func (this *Span) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Span)
	if !ok {
		that2, ok := that.(Span)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.EndKey, that1.EndKey) {
		return false
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.RawBytes, that1.RawBytes) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *SplitTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SplitTrigger)
	if !ok {
		that2, ok := that.(SplitTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	return true
}
func (this *MergeTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MergeTrigger)
	if !ok {
		that2, ok := that.(MergeTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	return true
}
func (this *ChangeReplicasTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChangeReplicasTrigger)
	if !ok {
		that2, ok := that.(ChangeReplicasTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChangeType != that1.ChangeType {
		return false
	}
	if !this.Replica.Equal(&that1.Replica) {
		return false
	}
	if len(this.UpdatedReplicas) != len(that1.UpdatedReplicas) {
		return false
	}
	for i := range this.UpdatedReplicas {
		if !this.UpdatedReplicas[i].Equal(&that1.UpdatedReplicas[i]) {
			return false
		}
	}
	if this.NextReplicaID != that1.NextReplicaID {
		return false
	}
	return true
}
func (this *ModifiedSpanTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModifiedSpanTrigger)
	if !ok {
		that2, ok := that.(ModifiedSpanTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SystemConfigSpan != that1.SystemConfigSpan {
		return false
	}
	if !this.NodeLivenessSpan.Equal(that1.NodeLivenessSpan) {
		return false
	}
	return true
}
func (this *InternalCommitTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InternalCommitTrigger)
	if !ok {
		that2, ok := that.(InternalCommitTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SplitTrigger.Equal(that1.SplitTrigger) {
		return false
	}
	if !this.MergeTrigger.Equal(that1.MergeTrigger) {
		return false
	}
	if !this.ChangeReplicasTrigger.Equal(that1.ChangeReplicasTrigger) {
		return false
	}
	if !this.ModifiedSpanTrigger.Equal(that1.ModifiedSpanTrigger) {
		return false
	}
	return true
}
func (this *ObservedTimestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObservedTimestamp)
	if !ok {
		that2, ok := that.(ObservedTimestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *Transaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TxnMeta.Equal(&that1.TxnMeta) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.LastHeartbeat.Equal(&that1.LastHeartbeat) {
		return false
	}
	if !this.OrigTimestamp.Equal(&that1.OrigTimestamp) {
		return false
	}
	if !this.MaxTimestamp.Equal(&that1.MaxTimestamp) {
		return false
	}
	if !this.RefreshedTimestamp.Equal(&that1.RefreshedTimestamp) {
		return false
	}
	if len(this.ObservedTimestamps) != len(that1.ObservedTimestamps) {
		return false
	}
	for i := range this.ObservedTimestamps {
		if !this.ObservedTimestamps[i].Equal(&that1.ObservedTimestamps[i]) {
			return false
		}
	}
	if this.Writing != that1.Writing {
		return false
	}
	if this.WriteTooOld != that1.WriteTooOld {
		return false
	}
	if this.RetryOnPush != that1.RetryOnPush {
		return false
	}
	if len(this.Intents) != len(that1.Intents) {
		return false
	}
	for i := range this.Intents {
		if !this.Intents[i].Equal(&that1.Intents[i]) {
			return false
		}
	}
	if !this.EpochZeroTimestamp.Equal(&that1.EpochZeroTimestamp) {
		return false
	}
	if this.OrigTimestampWasObserved != that1.OrigTimestampWasObserved {
		return false
	}
	return true
}
func (this *Intent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Intent)
	if !ok {
		that2, ok := that.(Intent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Span.Equal(&that1.Span) {
		return false
	}
	if !this.Txn.Equal(&that1.Txn) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *AbortSpanEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AbortSpanEntry)
	if !ok {
		that2, ok := that.(AbortSpanEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RawBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.RawBytes)))
		i += copy(dAtA[i:], m.RawBytes)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Timestamp.Size()))
	n1, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Value.Size()))
	n2, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *StoreIdent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreIdent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.ClusterID.Size()))
	n3, err := m.ClusterID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.NodeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintData(dAtA, i, uint64(m.StoreID))
	}
	return i, nil
}

func (m *SplitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitTrigger) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.LeftDesc.Size()))
	n4, err := m.LeftDesc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.RightDesc.Size()))
	n5, err := m.RightDesc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *MergeTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeTrigger) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.LeftDesc.Size()))
	n6, err := m.LeftDesc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.RightDesc.Size()))
	n7, err := m.RightDesc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ChangeReplicasTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeReplicasTrigger) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChangeType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintData(dAtA, i, uint64(m.ChangeType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Replica.Size()))
	n8, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.UpdatedReplicas) > 0 {
		for _, msg := range m.UpdatedReplicas {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NextReplicaID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintData(dAtA, i, uint64(m.NextReplicaID))
	}
	return i, nil
}

func (m *ModifiedSpanTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifiedSpanTrigger) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SystemConfigSpan {
		dAtA[i] = 0x8
		i++
		if m.SystemConfigSpan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NodeLivenessSpan != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.NodeLivenessSpan.Size()))
		n9, err := m.NodeLivenessSpan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *InternalCommitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalCommitTrigger) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SplitTrigger != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(m.SplitTrigger.Size()))
		n10, err := m.SplitTrigger.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MergeTrigger != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.MergeTrigger.Size()))
		n11, err := m.MergeTrigger.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ChangeReplicasTrigger != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.ChangeReplicasTrigger.Size()))
		n12, err := m.ChangeReplicasTrigger.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ModifiedSpanTrigger != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(m.ModifiedSpanTrigger.Size()))
		n13, err := m.ModifiedSpanTrigger.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ObservedTimestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObservedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Timestamp.Size()))
	n14, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.TxnMeta.Size()))
	n15, err := m.TxnMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintData(dAtA, i, uint64(m.LastHeartbeat.Size()))
	n16, err := m.LastHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x32
	i++
	i = encodeVarintData(dAtA, i, uint64(m.OrigTimestamp.Size()))
	n17, err := m.OrigTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x3a
	i++
	i = encodeVarintData(dAtA, i, uint64(m.MaxTimestamp.Size()))
	n18, err := m.MaxTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.ObservedTimestamps) > 0 {
		for _, msg := range m.ObservedTimestamps {
			dAtA[i] = 0x42
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Writing {
		dAtA[i] = 0x48
		i++
		if m.Writing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WriteTooOld {
		dAtA[i] = 0x60
		i++
		if m.WriteTooOld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RetryOnPush {
		dAtA[i] = 0x68
		i++
		if m.RetryOnPush {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintData(dAtA, i, uint64(m.EpochZeroTimestamp.Size()))
	n19, err := m.EpochZeroTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x7a
	i++
	i = encodeVarintData(dAtA, i, uint64(m.RefreshedTimestamp.Size()))
	n20, err := m.RefreshedTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.OrigTimestampWasObserved {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.OrigTimestampWasObserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Intent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Intent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Span.Size()))
	n21, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Txn.Size()))
	n22, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Start.Size()))
	n23, err := m.Start.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if m.Expiration != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Expiration.Size()))
		n24, err := m.Expiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Replica.Size()))
	n25, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	if m.DeprecatedStartStasis != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintData(dAtA, i, uint64(m.DeprecatedStartStasis.Size()))
		n26, err := m.DeprecatedStartStasis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ProposedTS != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintData(dAtA, i, uint64(m.ProposedTS.Size()))
		n27, err := m.ProposedTS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Epoch))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Sequence))
	}
	return i, nil
}

func (m *AbortSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbortSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Timestamp.Size()))
	n28, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	if m.Priority != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintData(dAtA, i, uint64(m.Priority))
	}
	return i, nil
}

func (m *TxnCoordMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCoordMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintData(dAtA, i, uint64(m.Txn.Size()))
	n29, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n29
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			dAtA[i] = 0x12
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CommandCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintData(dAtA, i, uint64(m.CommandCount))
	}
	if len(m.RefreshReads) > 0 {
		for _, msg := range m.RefreshReads {
			dAtA[i] = 0x22
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RefreshWrites) > 0 {
		for _, msg := range m.RefreshWrites {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RefreshValid {
		dAtA[i] = 0x30
		i++
		if m.RefreshValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedSpan(r randyData, easy bool) *Span {
	this := &Span{}
	v1 := r.Intn(100)
	this.Key = make(Key, v1)
	for i := 0; i < v1; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v2 := r.Intn(100)
	this.EndKey = make(Key, v2)
	for i := 0; i < v2; i++ {
		this.EndKey[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObservedTimestamp(r randyData, easy bool) *ObservedTimestamp {
	this := &ObservedTimestamp{}
	this.NodeID = NodeID(r.Int31())
	if r.Intn(2) == 0 {
		this.NodeID *= -1
	}
	v3 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v3
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransaction(r randyData, easy bool) *Transaction {
	this := &Transaction{}
	v4 := cockroach_storage_engine_enginepb.NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v4
	this.Name = string(randStringData(r))
	this.Status = TransactionStatus([]int32{0, 1, 2}[r.Intn(3)])
	v5 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.LastHeartbeat = *v5
	v6 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.OrigTimestamp = *v6
	v7 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.MaxTimestamp = *v7
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.ObservedTimestamps = make([]ObservedTimestamp, v8)
		for i := 0; i < v8; i++ {
			v9 := NewPopulatedObservedTimestamp(r, easy)
			this.ObservedTimestamps[i] = *v9
		}
	}
	this.Writing = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Intents = make([]Span, v10)
		for i := 0; i < v10; i++ {
			v11 := NewPopulatedSpan(r, easy)
			this.Intents[i] = *v11
		}
	}
	this.WriteTooOld = bool(bool(r.Intn(2) == 0))
	this.RetryOnPush = bool(bool(r.Intn(2) == 0))
	v12 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.EpochZeroTimestamp = *v12
	v13 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.RefreshedTimestamp = *v13
	this.OrigTimestampWasObserved = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLease(r randyData, easy bool) *Lease {
	this := &Lease{}
	v14 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.Start = *v14
	if r.Intn(10) != 0 {
		this.Expiration = cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	}
	v15 := NewPopulatedReplicaDescriptor(r, easy)
	this.Replica = *v15
	if r.Intn(10) != 0 {
		this.DeprecatedStartStasis = cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ProposedTS = cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	}
	this.Epoch = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Epoch *= -1
	}
	this.Sequence = LeaseSequence(r.Int63())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAbortSpanEntry(r randyData, easy bool) *AbortSpanEntry {
	this := &AbortSpanEntry{}
	v16 := r.Intn(100)
	this.Key = make(Key, v16)
	for i := 0; i < v16; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v17 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v17
	this.Priority = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyData interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneData(r randyData) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringData(r randyData) string {
	v18 := r.Intn(100)
	tmps := make([]rune, v18)
	for i := 0; i < v18; i++ {
		tmps[i] = randUTF8RuneData(r)
	}
	return string(tmps)
}
func randUnrecognizedData(r randyData, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldData(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldData(dAtA []byte, r randyData, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		v19 := r.Int63()
		if r.Intn(2) == 0 {
			v19 *= -1
		}
		dAtA = encodeVarintPopulateData(dAtA, uint64(v19))
	case 1:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateData(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateData(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Span) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *KeyValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *StoreIdent) Size() (n int) {
	var l int
	_ = l
	l = m.ClusterID.Size()
	n += 1 + l + sovData(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovData(uint64(m.StoreID))
	}
	return n
}

func (m *SplitTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *MergeTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *ChangeReplicasTrigger) Size() (n int) {
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovData(uint64(m.ChangeType))
	}
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.UpdatedReplicas) > 0 {
		for _, e := range m.UpdatedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.NextReplicaID != 0 {
		n += 1 + sovData(uint64(m.NextReplicaID))
	}
	return n
}

func (m *ModifiedSpanTrigger) Size() (n int) {
	var l int
	_ = l
	if m.SystemConfigSpan {
		n += 2
	}
	if m.NodeLivenessSpan != nil {
		l = m.NodeLivenessSpan.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *InternalCommitTrigger) Size() (n int) {
	var l int
	_ = l
	if m.SplitTrigger != nil {
		l = m.SplitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MergeTrigger != nil {
		l = m.MergeTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChangeReplicasTrigger != nil {
		l = m.ChangeReplicasTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ModifiedSpanTrigger != nil {
		l = m.ModifiedSpanTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ObservedTimestamp) Size() (n int) {
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	l = m.LastHeartbeat.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.OrigTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.MaxTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.ObservedTimestamps) > 0 {
		for _, e := range m.ObservedTimestamps {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.Writing {
		n += 2
	}
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.WriteTooOld {
		n += 2
	}
	if m.RetryOnPush {
		n += 2
	}
	l = m.EpochZeroTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RefreshedTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.OrigTimestampWasObserved {
		n += 3
	}
	return n
}

func (m *Intent) Size() (n int) {
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	return n
}

func (m *Lease) Size() (n int) {
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	if m.DeprecatedStartStasis != nil {
		l = m.DeprecatedStartStasis.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ProposedTS != nil {
		l = m.ProposedTS.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovData(uint64(m.Epoch))
	}
	if m.Sequence != 0 {
		n += 1 + sovData(uint64(m.Sequence))
	}
	return n
}

func (m *AbortSpanEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovData(uint64(m.Priority))
	}
	return n
}

func (m *TxnCoordMeta) Size() (n int) {
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.CommandCount != 0 {
		n += 1 + sovData(uint64(m.CommandCount))
	}
	if len(m.RefreshReads) > 0 {
		for _, e := range m.RefreshReads {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.RefreshWrites) > 0 {
		for _, e := range m.RefreshWrites {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.RefreshValid {
		n += 2
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreIdent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= (StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicasTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= (ReplicaChangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedReplicas = append(m.UpdatedReplicas, ReplicaDescriptor{})
			if err := m.UpdatedReplicas[len(m.UpdatedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReplicaID", wireType)
			}
			m.NextReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifiedSpanTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemConfigSpan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemConfigSpan = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLivenessSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeLivenessSpan == nil {
				m.NodeLivenessSpan = &Span{}
			}
			if err := m.NodeLivenessSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalCommitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalCommitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalCommitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitTrigger == nil {
				m.SplitTrigger = &SplitTrigger{}
			}
			if err := m.SplitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTrigger == nil {
				m.MergeTrigger = &MergeTrigger{}
			}
			if err := m.MergeTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicasTrigger == nil {
				m.ChangeReplicasTrigger = &ChangeReplicasTrigger{}
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedSpanTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedSpanTrigger == nil {
				m.ModifiedSpanTrigger = &ModifiedSpanTrigger{}
			}
			if err := m.ModifiedSpanTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObservedTimestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObservedTimestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObservedTimestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrigTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedTimestamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedTimestamps = append(m.ObservedTimestamps, ObservedTimestamp{})
			if err := m.ObservedTimestamps[len(m.ObservedTimestamps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Writing = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, Span{})
			if err := m.Intents[len(m.Intents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTooOld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteTooOld = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOnPush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetryOnPush = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochZeroTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EpochZeroTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefreshedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigTimestampWasObserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrigTimestampWasObserved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Intent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Intent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Intent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &cockroach_util_hlc.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartStasis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedStartStasis == nil {
				m.DeprecatedStartStasis = &cockroach_util_hlc.Timestamp{}
			}
			if err := m.DeprecatedStartStasis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposedTS == nil {
				m.ProposedTS = &cockroach_util_hlc.Timestamp{}
			}
			if err := m.ProposedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (LeaseSequence(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCoordMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCoordMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCoordMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, Span{})
			if err := m.Intents[len(m.Intents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandCount", wireType)
			}
			m.CommandCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommandCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshReads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshReads = append(m.RefreshReads, Span{})
			if err := m.RefreshReads[len(m.RefreshReads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshWrites = append(m.RefreshWrites, Span{})
			if err := m.RefreshWrites[len(m.RefreshWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshValid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("roachpb/data.proto", fileDescriptorData) }

var fileDescriptorData = []byte{
	// 1741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x9f, 0xf6, 0xb7, 0x9f, 0xed, 0x99, 0x9e, 0x9a, 0xcc, 0xc6, 0xcc, 0x0a, 0x3b, 0x78, 0x11,
	0x8a, 0x22, 0xd6, 0x23, 0x12, 0x3e, 0xc4, 0x08, 0x90, 0xc6, 0x1f, 0xbb, 0xe9, 0x8d, 0x3f, 0x86,
	0x76, 0x4f, 0x22, 0xb2, 0x42, 0x4d, 0xbb, 0xbb, 0x62, 0xb7, 0x62, 0x77, 0x35, 0x55, 0xe5, 0xc9,
	0x98, 0xbf, 0x60, 0x6f, 0xec, 0x81, 0x03, 0xc7, 0x48, 0x70, 0x42, 0xe2, 0xce, 0x7f, 0x40, 0x2e,
	0x48, 0x2b, 0x71, 0x00, 0x71, 0xb0, 0xc0, 0x5c, 0x90, 0xb8, 0x71, 0x8c, 0xb4, 0x12, 0xaa, 0xea,
	0x6e, 0xbb, 0xb3, 0xe3, 0x44, 0x1e, 0xc2, 0x61, 0x2f, 0x33, 0x55, 0xaf, 0xde, 0xfb, 0xbd, 0x57,
	0xef, 0xb3, 0xda, 0x80, 0x28, 0xb1, 0xec, 0xb1, 0x3f, 0x3c, 0x76, 0x2c, 0x6e, 0xd5, 0x7d, 0x4a,
	0x38, 0x41, 0xfb, 0x36, 0xb1, 0x9f, 0x4a, 0x7a, 0x3d, 0x3c, 0x3d, 0x7a, 0x27, 0x62, 0x9b, 0x62,
	0x6e, 0xad, 0x59, 0x8f, 0xde, 0x63, 0x9c, 0x50, 0x6b, 0x84, 0x8f, 0xb1, 0x37, 0x72, 0xbd, 0xe8,
	0x9f, 0xe0, 0xbb, 0xb0, 0xed, 0x7b, 0x21, 0x53, 0x79, 0xc6, 0xdd, 0xc9, 0xf1, 0x78, 0x62, 0x1f,
	0x73, 0x77, 0x8a, 0x19, 0xb7, 0xa6, 0x7e, 0x78, 0x72, 0x63, 0x44, 0x46, 0x44, 0x2e, 0x8f, 0xc5,
	0x2a, 0xa0, 0xd6, 0x7e, 0x0c, 0xa9, 0x81, 0x6f, 0x79, 0xe8, 0x2b, 0x90, 0x7c, 0x8a, 0xe7, 0xe5,
	0xe4, 0x2d, 0xe5, 0x76, 0xb1, 0x91, 0x7d, 0xb9, 0xa8, 0x26, 0x1f, 0xe0, 0xb9, 0x2e, 0x68, 0xe8,
	0x16, 0x64, 0xb1, 0xe7, 0x98, 0xe2, 0x38, 0xf5, 0xea, 0x71, 0x06, 0x7b, 0xce, 0x03, 0x3c, 0x3f,
	0x29, 0xfe, 0xfa, 0x79, 0x75, 0xe7, 0x0f, 0xcf, 0xab, 0xca, 0xbf, 0x9e, 0x57, 0x95, 0xda, 0x14,
	0xd2, 0x0f, 0xad, 0xc9, 0x0c, 0xa3, 0x77, 0x21, 0x4f, 0xad, 0x67, 0xe6, 0x70, 0xce, 0x31, 0x2b,
	0x2b, 0x42, 0x54, 0xcf, 0x51, 0xeb, 0x59, 0x43, 0xec, 0xd1, 0x29, 0xe4, 0x57, 0x16, 0x96, 0x13,
	0xb7, 0x94, 0xdb, 0x85, 0xbb, 0x5f, 0xad, 0xaf, 0x9d, 0x21, 0xae, 0x51, 0x1f, 0x4f, 0xec, 0xba,
	0x11, 0x31, 0x35, 0x52, 0x2f, 0x16, 0xd5, 0x1d, 0x7d, 0x2d, 0x75, 0x92, 0x92, 0xea, 0x3e, 0x86,
	0xdc, 0x03, 0x3c, 0x0f, 0x34, 0x86, 0xb7, 0x50, 0x36, 0xdc, 0xe2, 0xdb, 0x90, 0xbe, 0x10, 0x3c,
	0xa1, 0xae, 0x72, 0xfd, 0x8a, 0xe3, 0xeb, 0x12, 0x23, 0x54, 0x13, 0x30, 0xd7, 0xfe, 0xa2, 0x00,
	0x0c, 0x38, 0xa1, 0x58, 0x73, 0xb0, 0xc7, 0xd1, 0x08, 0xc0, 0x9e, 0xcc, 0x18, 0xc7, 0xd4, 0x74,
	0x9d, 0x50, 0xcd, 0x7d, 0xc1, 0xff, 0xb7, 0x45, 0xf5, 0xde, 0xc8, 0xe5, 0xe3, 0xd9, 0xb0, 0x6e,
	0x93, 0xe9, 0xf1, 0x0a, 0xdb, 0x19, 0xae, 0xd7, 0xc7, 0xfe, 0xd3, 0xd1, 0xb1, 0x0c, 0xcf, 0x6c,
	0xe6, 0x3a, 0xf5, 0xf3, 0x73, 0xad, 0xb5, 0x5c, 0x54, 0xf3, 0xcd, 0x00, 0x50, 0x6b, 0xe9, 0xf9,
	0x10, 0x5b, 0x73, 0xd0, 0xfb, 0x90, 0xf5, 0x88, 0x83, 0x85, 0x16, 0x61, 0x6f, 0xba, 0x71, 0x63,
	0xb9, 0xa8, 0x66, 0x7a, 0xc4, 0xc1, 0x5a, 0xeb, 0xe5, 0x6a, 0xa5, 0x67, 0x04, 0x93, 0xe6, 0xa0,
	0x6f, 0x41, 0x4e, 0x24, 0x87, 0xe4, 0x4f, 0x4a, 0xfe, 0x77, 0x96, 0x8b, 0x6a, 0x36, 0xb0, 0x5c,
	0x08, 0x44, 0x4b, 0x3d, 0xcb, 0x82, 0xdb, 0xd4, 0x7e, 0xa7, 0x40, 0x71, 0xe0, 0x4f, 0x5c, 0x6e,
	0x50, 0x77, 0x34, 0xc2, 0x14, 0xb5, 0x21, 0x3f, 0xc1, 0x4f, 0xb8, 0xe9, 0x60, 0x66, 0xcb, 0xab,
	0x15, 0xee, 0xd6, 0x36, 0x38, 0x49, 0xb7, 0xbc, 0x11, 0x6e, 0x61, 0x66, 0x53, 0xd7, 0xe7, 0x84,
	0x86, 0xee, 0xca, 0x09, 0x51, 0x41, 0x45, 0x1f, 0x02, 0x50, 0x77, 0x34, 0x0e, 0x71, 0x12, 0xd7,
	0xc4, 0xc9, 0x4b, 0x59, 0x41, 0x0e, 0xa2, 0xfb, 0x51, 0x2a, 0x97, 0x54, 0x53, 0xb5, 0xdf, 0x2a,
	0x50, 0xec, 0x62, 0x3a, 0xc2, 0x5f, 0x6a, 0x63, 0x6b, 0x7f, 0x4a, 0xc0, 0x61, 0x73, 0x2c, 0x78,
	0x75, 0xec, 0x4f, 0x5c, 0xdb, 0x62, 0x6b, 0x7b, 0x0b, 0xb6, 0x3c, 0x30, 0xf9, 0xdc, 0xc7, 0xd2,
	0xe2, 0xdd, 0xbb, 0x5f, 0xdf, 0xa4, 0x29, 0x10, 0x0c, 0x50, 0x8c, 0xb9, 0x8f, 0x75, 0xb0, 0x57,
	0x6b, 0xd4, 0x82, 0x2c, 0x0d, 0x18, 0x42, 0x63, 0xdf, 0x00, 0x71, 0xc5, 0xdc, 0x48, 0x14, 0x9d,
	0x83, 0x3a, 0xf3, 0x1d, 0x8b, 0x63, 0xc7, 0x0c, 0x49, 0xac, 0x9c, 0xbc, 0x95, 0xbc, 0x26, 0xdc,
	0x5e, 0x88, 0x11, 0x5d, 0x15, 0x7d, 0x00, 0x7b, 0x1e, 0xbe, 0xe4, 0x11, 0xa6, 0xc8, 0xc5, 0x94,
	0xcc, 0xc5, 0xca, 0x72, 0x51, 0x2d, 0xf5, 0xf0, 0x25, 0x0f, 0x59, 0x65, 0x46, 0xe6, 0x57, 0x1b,
	0xbd, 0xe4, 0xc5, 0xce, 0x9c, 0x93, 0x9c, 0xe8, 0x26, 0xd2, 0x9f, 0x9f, 0x2a, 0x70, 0xd0, 0x25,
	0x8e, 0xfb, 0xc4, 0xc5, 0x8e, 0xe8, 0x52, 0x91, 0x37, 0xbf, 0x09, 0x88, 0xcd, 0x19, 0xc7, 0x53,
	0xd3, 0x26, 0xde, 0x13, 0x77, 0x64, 0x32, 0xdf, 0xf2, 0xa4, 0x53, 0x73, 0xba, 0x1a, 0x9c, 0x34,
	0xe5, 0x81, 0x6c, 0x6d, 0x6d, 0x40, 0xb2, 0x96, 0x26, 0xee, 0x05, 0xf6, 0x30, 0x63, 0x01, 0x77,
	0xe0, 0xbf, 0x9b, 0x1b, 0x2e, 0x2c, 0x84, 0x74, 0x55, 0x88, 0x74, 0x42, 0x09, 0x41, 0x09, 0x43,
	0xfc, 0xef, 0x04, 0x1c, 0x6a, 0x1e, 0xc7, 0xd4, 0xb3, 0x26, 0x4d, 0x32, 0x9d, 0xae, 0xeb, 0xa7,
	0x05, 0x25, 0x26, 0xea, 0xc9, 0xe4, 0x01, 0x21, 0x4c, 0xcb, 0xea, 0x46, 0x0d, 0xeb, 0xba, 0xd3,
	0x8b, 0x2c, 0x5e, 0x85, 0x2d, 0x28, 0x4d, 0x45, 0xa2, 0xaf, 0x50, 0x12, 0xaf, 0x45, 0x89, 0x17,
	0x84, 0x5e, 0x9c, 0xc6, 0xcb, 0xe3, 0x67, 0x70, 0x33, 0x4c, 0xb7, 0x28, 0xc0, 0x2b, 0xbc, 0xa4,
	0xc4, 0xbb, 0xbd, 0x01, 0x6f, 0x63, 0xe6, 0xea, 0x87, 0xf6, 0xc6, 0x84, 0x7e, 0x0c, 0x87, 0xd3,
	0x30, 0x32, 0xd2, 0x9f, 0x2b, 0xfc, 0x94, 0xc4, 0xff, 0xc6, 0x26, 0x7b, 0xaf, 0x46, 0x52, 0x3f,
	0x98, 0x5e, 0x25, 0x9e, 0xe4, 0x3e, 0x89, 0x46, 0xc9, 0x2f, 0x15, 0xd8, 0xef, 0x0f, 0x19, 0xa6,
	0x17, 0xd8, 0x59, 0x0d, 0x82, 0x78, 0x73, 0x54, 0xb6, 0x68, 0x8e, 0xff, 0x87, 0x49, 0x93, 0x5b,
	0x0d, 0xb7, 0xcf, 0x33, 0x50, 0x30, 0xa8, 0xe5, 0x31, 0xcb, 0xe6, 0x2e, 0xf1, 0xd0, 0x7d, 0x48,
	0x89, 0x31, 0x1d, 0x06, 0xfb, 0x4e, 0x0c, 0x37, 0x9c, 0xd6, 0xf5, 0x60, 0x4c, 0xd7, 0xa3, 0x69,
	0x5d, 0x37, 0x2e, 0xbd, 0x2e, 0xe6, 0x56, 0x23, 0x27, 0x94, 0x7c, 0xb6, 0xa8, 0x2a, 0xba, 0x44,
	0x40, 0x08, 0x52, 0x9e, 0x35, 0x0d, 0xe6, 0x53, 0x5e, 0x97, 0x6b, 0xf4, 0x03, 0xc8, 0x30, 0x6e,
	0xf1, 0x19, 0x93, 0x6e, 0xdd, 0xdc, 0x31, 0x62, 0xd6, 0x0c, 0x24, 0xaf, 0x1e, 0xca, 0xa0, 0x8f,
	0x60, 0x77, 0x62, 0x31, 0x6e, 0x8e, 0xb1, 0x45, 0xf9, 0x10, 0x5b, 0xbc, 0x9c, 0xde, 0xfe, 0xf6,
	0x25, 0x21, 0x7a, 0x3f, 0x92, 0x14, 0x58, 0x84, 0xba, 0x23, 0x73, 0xed, 0xc9, 0xcc, 0x35, 0xb0,
	0x84, 0xe8, 0x3a, 0x7e, 0xf7, 0xa1, 0x34, 0xb5, 0x2e, 0x63, 0x50, 0xd9, 0xed, 0xa1, 0x8a, 0x53,
	0xeb, 0x72, 0x8d, 0xf4, 0x31, 0x1c, 0x90, 0x30, 0x3d, 0xd6, 0x70, 0xac, 0x9c, 0x7b, 0x6d, 0x33,
	0xbb, 0x92, 0x4c, 0x21, 0x2c, 0x22, 0x5f, 0x3c, 0x60, 0xa8, 0x0c, 0xd9, 0x67, 0xd4, 0xe5, 0xae,
	0x37, 0x2a, 0xe7, 0x65, 0x6b, 0x89, 0xb6, 0xe8, 0x7b, 0x90, 0x75, 0x3d, 0x8e, 0x3d, 0xce, 0xca,
	0x05, 0xa9, 0xea, 0x75, 0x6d, 0x24, 0xea, 0xbc, 0x21, 0x37, 0xaa, 0x41, 0x49, 0x60, 0x60, 0x93,
	0x13, 0x62, 0x92, 0x89, 0x53, 0x2e, 0x4a, 0xe0, 0x82, 0x24, 0x1a, 0x84, 0xf4, 0x27, 0x8e, 0xe0,
	0xa1, 0x98, 0xd3, 0xb9, 0x49, 0x3c, 0xd3, 0x9f, 0xb1, 0x71, 0xb9, 0x14, 0xf0, 0x48, 0x62, 0xdf,
	0x3b, 0x9b, 0xb1, 0x31, 0x3a, 0x87, 0x1b, 0xd8, 0x27, 0xf6, 0xd8, 0xfc, 0x05, 0xa6, 0x24, 0xe6,
	0xc8, 0xdd, 0xed, 0x1d, 0x89, 0x24, 0xc0, 0x63, 0x4c, 0xc9, 0xda, 0x9d, 0x06, 0x1c, 0x50, 0xfc,
	0x84, 0x62, 0x36, 0x8e, 0xfb, 0xb3, 0xbc, 0x77, 0x0d, 0xd4, 0x95, 0xfc, 0x1a, 0xf5, 0x87, 0xf0,
	0xee, 0xab, 0xa9, 0x63, 0x3e, 0xb3, 0x98, 0x19, 0x39, 0xbc, 0xac, 0xca, 0xeb, 0x95, 0x5f, 0x49,
	0x91, 0x47, 0x16, 0x8b, 0x22, 0xf5, 0x85, 0xc7, 0xe5, 0x1f, 0x15, 0xc8, 0x68, 0xd2, 0x9b, 0xe8,
	0x3b, 0x90, 0x5a, 0xf5, 0xfd, 0x37, 0x84, 0x20, 0x56, 0x67, 0x82, 0x1d, 0x35, 0x20, 0xc9, 0x2f,
	0xa3, 0xfe, 0x7f, 0x9d, 0x82, 0x0d, 0x6e, 0x28, 0x84, 0x63, 0x75, 0x99, 0xbc, 0x7e, 0x5d, 0x86,
	0x93, 0xe4, 0xf3, 0x24, 0xa4, 0x3b, 0xd8, 0x62, 0x18, 0x7d, 0x1f, 0xd2, 0x8c, 0x5b, 0x94, 0x87,
	0x37, 0xd9, 0xca, 0xd1, 0x81, 0x04, 0xfa, 0x29, 0x00, 0xbe, 0xf4, 0x5d, 0x6a, 0x09, 0x35, 0xdb,
	0x35, 0xb7, 0xca, 0x7f, 0x16, 0xd5, 0xa3, 0xd8, 0x03, 0xf5, 0xa4, 0x46, 0x2d, 0xcf, 0xf1, 0x66,
	0x93, 0x89, 0x35, 0x9c, 0xe0, 0x9a, 0x1e, 0x03, 0x8c, 0xbf, 0x37, 0x92, 0xff, 0xfb, 0x7b, 0x63,
	0x06, 0x37, 0x1d, 0xec, 0x53, 0x6c, 0xcb, 0x27, 0x87, 0x34, 0x5c, 0xfc, 0x65, 0x2e, 0x0b, 0xa7,
	0xc5, 0x5b, 0x5a, 0x7c, 0xb8, 0x46, 0x1f, 0x08, 0xf0, 0x81, 0xc4, 0x46, 0x3d, 0x28, 0xf8, 0x94,
	0xf8, 0x84, 0x89, 0x64, 0x66, 0xdb, 0xf5, 0xbe, 0xdd, 0xe5, 0xa2, 0x0a, 0x67, 0xa1, 0x94, 0x31,
	0xd0, 0x21, 0x42, 0x30, 0x18, 0xba, 0x01, 0x69, 0x59, 0x33, 0xb2, 0xf3, 0x25, 0xf5, 0x60, 0x83,
	0xde, 0x87, 0x1c, 0xc3, 0x3f, 0x9f, 0x61, 0xcf, 0xc6, 0xb2, 0x8f, 0x25, 0x1b, 0xfb, 0x2f, 0x17,
	0xd5, 0x92, 0x8c, 0xec, 0x20, 0x3c, 0xd0, 0x57, 0x2c, 0xc1, 0xe3, 0x46, 0x64, 0x73, 0xed, 0x57,
	0x0a, 0xec, 0x9e, 0x0e, 0x09, 0xe5, 0x22, 0x4b, 0xdb, 0x1e, 0xa7, 0xf3, 0x37, 0x7d, 0xbe, 0xbc,
	0xfd, 0x10, 0x43, 0x47, 0x90, 0xf3, 0xa9, 0x4b, 0xa8, 0xcb, 0x83, 0xef, 0xbc, 0xb4, 0xbe, 0xda,
	0xc7, 0x06, 0xdc, 0x9f, 0x13, 0x50, 0x34, 0x2e, 0xbd, 0x26, 0x21, 0xd4, 0x11, 0x69, 0x8f, 0xbe,
	0x1b, 0xd4, 0x4b, 0x90, 0x9b, 0x95, 0x37, 0x27, 0x7a, 0xbc, 0x46, 0x62, 0x4d, 0x32, 0x71, 0xad,
	0x26, 0xf9, 0x1e, 0x94, 0x6c, 0x32, 0x9d, 0x5a, 0x9e, 0x63, 0xda, 0x64, 0xe6, 0xf1, 0xd0, 0xd8,
	0x62, 0x48, 0x6c, 0x0a, 0x1a, 0x6a, 0x88, 0x2e, 0x29, 0x5b, 0x8d, 0x49, 0xb1, 0xe5, 0x88, 0x4c,
	0xda, 0x42, 0x47, 0x31, 0x94, 0xd1, 0x85, 0x08, 0x6a, 0xc1, 0x6e, 0x84, 0x21, 0x1b, 0xb0, 0xc8,
	0x91, 0x2d, 0x40, 0x22, 0xc5, 0x8f, 0xa4, 0x8c, 0x30, 0x37, 0x42, 0xb9, 0xb0, 0x26, 0xae, 0x23,
	0xd3, 0x23, 0xb7, 0x52, 0xf5, 0x50, 0xd0, 0xee, 0xfc, 0x5e, 0x81, 0xbc, 0xfc, 0xbc, 0x94, 0xcf,
	0xf8, 0x02, 0x64, 0xcf, 0x7b, 0x0f, 0x7a, 0xfd, 0x47, 0x3d, 0x75, 0x07, 0xe5, 0x20, 0xd5, 0x3b,
	0xef, 0x74, 0xd4, 0x2c, 0xca, 0x42, 0x52, 0xeb, 0x19, 0xaa, 0x82, 0xf2, 0x90, 0xfe, 0xa0, 0xd3,
	0x3f, 0x35, 0xd4, 0x84, 0x58, 0x36, 0x7e, 0x62, 0xb4, 0x07, 0x6a, 0x12, 0x1d, 0xc0, 0x5e, 0xab,
	0xdd, 0xd1, 0xba, 0x9a, 0xd1, 0x6e, 0x99, 0x01, 0x31, 0x27, 0xa4, 0x0d, 0xad, 0xdb, 0x56, 0x53,
	0x02, 0xb4, 0xd5, 0x6e, 0x6a, 0xdd, 0xd3, 0x8e, 0x9a, 0x46, 0x87, 0xb0, 0xbf, 0xe6, 0x8d, 0xc8,
	0x79, 0x54, 0x84, 0x5c, 0xeb, 0x5c, 0x3f, 0x35, 0xb4, 0x7e, 0x4f, 0xcd, 0x08, 0x6c, 0xe3, 0xfc,
	0xac, 0xd3, 0x56, 0x01, 0xed, 0x02, 0x08, 0x98, 0x41, 0x5b, 0xd7, 0xda, 0x03, 0xd5, 0xb9, 0xf3,
	0x23, 0xd8, 0xbf, 0xf2, 0x25, 0x82, 0xf6, 0xa0, 0x70, 0xda, 0x6a, 0x99, 0x7a, 0xfb, 0xac, 0xa3,
	0x35, 0x4f, 0xd5, 0x1d, 0x84, 0x60, 0x57, 0x6f, 0x77, 0xfb, 0x0f, 0xdb, 0x2b, 0x9a, 0x72, 0x94,
	0xfa, 0xe4, 0x37, 0x95, 0x9d, 0x3b, 0x0d, 0xd8, 0xbf, 0xd2, 0xff, 0x84, 0x85, 0x67, 0xed, 0x5e,
	0x4b, 0xeb, 0x7d, 0xa8, 0xee, 0xa0, 0x12, 0xe4, 0x9b, 0xfd, 0x6e, 0x57, 0x33, 0x8c, 0x76, 0x4b,
	0x55, 0xc4, 0xd9, 0x69, 0xa3, 0xaf, 0x8b, 0x4d, 0x22, 0xc0, 0x68, 0x7c, 0xed, 0xc5, 0x3f, 0x2a,
	0x3b, 0x2f, 0x96, 0x15, 0xe5, 0xb3, 0x65, 0x45, 0xf9, 0xeb, 0xb2, 0xa2, 0xfc, 0x7d, 0x59, 0x51,
	0x3e, 0xfd, 0x67, 0x65, 0xe7, 0x71, 0x36, 0x8c, 0xca, 0x30, 0x23, 0x7f, 0xc4, 0xb8, 0xf7, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0xca, 0xd6, 0x79, 0x5a, 0x11, 0x00, 0x00,
}
