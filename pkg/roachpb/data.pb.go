// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/data.proto

package roachpb

import (
	bytes "bytes"
	fmt "fmt"
	lock "github.com/cockroachdb/cockroach/pkg/kv/kvserver/concurrency/lock"
	rspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/readsummary/rspb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_storage_enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ValueType defines a set of type constants placed in the "tag" field of Value
// messages. These are defined as a protocol buffer enumeration so that they
// can be used portably between our Go and C code. The tags are used by the
// RocksDB Merge Operator to perform specialized merges.
type ValueType int32

const (
	// This is a subset of the SQL column type values, representing the underlying
	// storage for various types. The DELIMITED_foo entries each represent a foo
	// variant that self-delimits length.
	ValueType_UNKNOWN           ValueType = 0
	ValueType_INT               ValueType = 1
	ValueType_FLOAT             ValueType = 2
	ValueType_BYTES             ValueType = 3
	ValueType_DELIMITED_BYTES   ValueType = 8
	ValueType_TIME              ValueType = 4
	ValueType_DECIMAL           ValueType = 5
	ValueType_DELIMITED_DECIMAL ValueType = 9
	ValueType_DURATION          ValueType = 6
	ValueType_TIMETZ            ValueType = 12
	ValueType_GEO               ValueType = 13
	ValueType_BOX2D             ValueType = 14
	// TUPLE represents a DTuple, encoded as repeated pairs of varint field number
	// followed by a value encoded Datum.
	ValueType_TUPLE    ValueType = 10
	ValueType_BITARRAY ValueType = 11
	// TIMESERIES is applied to values which contain InternalTimeSeriesData.
	ValueType_TIMESERIES ValueType = 100
)

var ValueType_name = map[int32]string{
	0:   "UNKNOWN",
	1:   "INT",
	2:   "FLOAT",
	3:   "BYTES",
	8:   "DELIMITED_BYTES",
	4:   "TIME",
	5:   "DECIMAL",
	9:   "DELIMITED_DECIMAL",
	6:   "DURATION",
	12:  "TIMETZ",
	13:  "GEO",
	14:  "BOX2D",
	10:  "TUPLE",
	11:  "BITARRAY",
	100: "TIMESERIES",
}

var ValueType_value = map[string]int32{
	"UNKNOWN":           0,
	"INT":               1,
	"FLOAT":             2,
	"BYTES":             3,
	"DELIMITED_BYTES":   8,
	"TIME":              4,
	"DECIMAL":           5,
	"DELIMITED_DECIMAL": 9,
	"DURATION":          6,
	"TIMETZ":            12,
	"GEO":               13,
	"BOX2D":             14,
	"TUPLE":             10,
	"BITARRAY":          11,
	"TIMESERIES":        100,
}

func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}

func (ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{0}
}

// ReplicaChangeType is a parameter of ChangeReplicasTrigger.
type ReplicaChangeType int32

const (
	ADD_VOTER        ReplicaChangeType = 0
	REMOVE_VOTER     ReplicaChangeType = 1
	ADD_NON_VOTER    ReplicaChangeType = 2
	REMOVE_NON_VOTER ReplicaChangeType = 3
)

var ReplicaChangeType_name = map[int32]string{
	0: "ADD_VOTER",
	1: "REMOVE_VOTER",
	2: "ADD_NON_VOTER",
	3: "REMOVE_NON_VOTER",
}

var ReplicaChangeType_value = map[string]int32{
	"ADD_VOTER":        0,
	"REMOVE_VOTER":     1,
	"ADD_NON_VOTER":    2,
	"REMOVE_NON_VOTER": 3,
}

func (x ReplicaChangeType) String() string {
	return proto.EnumName(ReplicaChangeType_name, int32(x))
}

func (ReplicaChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{1}
}

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// STAGING is the state for a transaction which has issued all of
	// its writes and is in the process of committing. Mutations made
	// as part of a transaction in this state may still be in-flight
	// and can not be assumed to have succeeded. A transaction may
	// transition from the STAGING to the COMMITTED state only if all
	// of its in-flight mutations are confirmed to have succeeded. A
	// transaction may transition from the STAGING to PENDING or ABORTED
	// state only if one of its in-flight requests is prevented from ever
	// succeeding.
	STAGING TransactionStatus = 3
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	3: "STAGING",
	1: "COMMITTED",
	2: "ABORTED",
}

var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"STAGING":   3,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{2}
}

// LeaseAcquisitionType indicates the type of lease acquisition event that
// resulted in the current lease.
type LeaseAcquisitionType int32

const (
	LeaseAcquisitionType_Unspecified LeaseAcquisitionType = 0
	// Transfer indicates that the current lease is a result of a (co-operative)
	// lease transfer.
	LeaseAcquisitionType_Transfer LeaseAcquisitionType = 1
	// Request indicates that the current lease is a result of a (non-cooperative)
	// lease request.
	LeaseAcquisitionType_Request LeaseAcquisitionType = 2
)

var LeaseAcquisitionType_name = map[int32]string{
	0: "Unspecified",
	1: "Transfer",
	2: "Request",
}

var LeaseAcquisitionType_value = map[string]int32{
	"Unspecified": 0,
	"Transfer":    1,
	"Request":     2,
}

func (x LeaseAcquisitionType) String() string {
	return proto.EnumName(LeaseAcquisitionType_name, int32(x))
}

func (LeaseAcquisitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{3}
}

// RangeClosedTimestampPolicy represents the policy used by the leaseholder of a
// range to establish and publish closed timestamps. The policy dictates how far
// in the past (lag) or in the future (lead) MVCC history is closed off.
type RangeClosedTimestampPolicy int32

const (
	// LAG_BY_CLUSTER_SETTING indicates that the range's closed timestamp is
	// configured to lag behind present time by the value configured for the
	// `kv.closed_timestamp.target_duration` cluster setting.
	LAG_BY_CLUSTER_SETTING RangeClosedTimestampPolicy = 0
	// LEAD_FOR_GLOBAL_READS indicates that the range's closed timestamp is
	// configured to lead present time such that all followers of the range are
	// able to serve consistent, present time reads. Because the policy describes
	// a goal and not the lead time itself, the lead time is allowed vary as a
	// function of maximum clock uncertainty and closed timestamp propagation time
	// (which itself is a function of leaseholder -> follower network latency and
	// closed timestamp update periodicity).
	LEAD_FOR_GLOBAL_READS RangeClosedTimestampPolicy = 1
	// Keep this sentinel value higher than the rest.
	MAX_CLOSED_TIMESTAMP_POLICY RangeClosedTimestampPolicy = 2
)

var RangeClosedTimestampPolicy_name = map[int32]string{
	0: "LAG_BY_CLUSTER_SETTING",
	1: "LEAD_FOR_GLOBAL_READS",
	2: "MAX_CLOSED_TIMESTAMP_POLICY",
}

var RangeClosedTimestampPolicy_value = map[string]int32{
	"LAG_BY_CLUSTER_SETTING":      0,
	"LEAD_FOR_GLOBAL_READS":       1,
	"MAX_CLOSED_TIMESTAMP_POLICY": 2,
}

func (x RangeClosedTimestampPolicy) String() string {
	return proto.EnumName(RangeClosedTimestampPolicy_name, int32(x))
}

func (RangeClosedTimestampPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{4}
}

// Span is a key range with an inclusive start Key and an exclusive end Key.
type Span struct {
	// The start key of the key range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The end key of the key range. The value is empty if the key range
	// contains only a single key. Otherwise, it must order strictly after Key.
	// In such a case, the Span encompasses the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=Key" json:"end_key,omitempty"`
}

func (m *Span) Reset()      { *m = Span{} }
func (*Span) ProtoMessage() {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{0}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

// Value specifies the value at a key. Multiple values at the same key are
// supported based on timestamp. The data stored within a value is typed
// (ValueType) and custom encoded into the raw_bytes field. A custom encoding
// is used instead of separate proto fields to avoid proto overhead and to
// avoid unnecessary encoding and decoding as the value gets read from disk and
// passed through the network. The format is:
//
//   <4-byte-checksum><1-byte-tag><encoded-data>
//
// A CRC-32-IEEE checksum is computed from the associated key, tag and encoded
// data, in that order.
//
// TODO(peter): Is a 4-byte checksum overkill when most (all?) values
// will be less than 64KB?
type Value struct {
	// raw_bytes contains the encoded value and checksum.
	//
	// Its contents may be modified on the next call to Value.SetFoo.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
	// Timestamp of value.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{1}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key   Key   `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Value Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{2}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"cluster_id"`
	NodeID    NodeID                                              `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	StoreID   StoreID                                             `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3,casttype=StoreID" json:"store_id,omitempty"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{3}
}
func (m *StoreIdent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreIdent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreIdent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreIdent.Merge(m, src)
}
func (m *StoreIdent) XXX_Size() int {
	return m.Size()
}
func (m *StoreIdent) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreIdent.DiscardUnknown(m)
}

var xxx_messageInfo_StoreIdent proto.InternalMessageInfo

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) and the new range descriptor covering
// the right hand side of the split (right_desc). This information
// allows the final bookkeeping for the split to be completed and the
// new range put into operation.
type SplitTrigger struct {
	LeftDesc  RangeDescriptor `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	RightDesc RangeDescriptor `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
}

func (m *SplitTrigger) Reset()         { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string { return proto.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()    {}
func (*SplitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{4}
}
func (m *SplitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitTrigger.Merge(m, src)
}
func (m *SplitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *SplitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_SplitTrigger proto.InternalMessageInfo

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated left hand side of the split's
// range descriptor (left_desc) that now encompasses what was
// originally both ranges and the soon-to-be-invalid range descriptor
// that used to cover the subsumed, right hand side of the merge
// (right_desc). This information allows the final bookkeeping for the
// merge to be completed and put into operation.
type MergeTrigger struct {
	LeftDesc       RangeDescriptor    `protobuf:"bytes,1,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	RightDesc      RangeDescriptor    `protobuf:"bytes,2,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
	RightMVCCStats enginepb.MVCCStats `protobuf:"bytes,4,opt,name=right_mvcc_stats,json=rightMvccStats,proto3" json:"right_mvcc_stats"`
	// FreezeStart is a timestamp that is guaranteed to be greater than the
	// timestamps at which any requests were serviced by the right-hand side range
	// before it stopped responding to requests altogether (in anticipation of
	// being subsumed). It is suitable for use as the timestamp cache's low water
	// mark for the keys previously owned by the subsumed range, though this role
	// is largely being... subsumed by the RightReadSummary.
	FreezeStart github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=freeze_start,json=freezeStart,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"freeze_start"`
	// right_closed_timestamp is the closed timestamp of the RHS at the moment of
	// the subsumption. Because the SubsumeRequest synchronizes with all other
	// requests, the range's closed timestamp does not advance past the snapshot
	// captured here.
	//
	// Like the freeze_start, this is used by the merged range to conditionally
	// bump the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// Note that the closed timestamp is also reflected in the right_read_summary.
	// However, we carry it explicitly too because, in case the leaseholders of
	// the two sides are collocated at merge time, we don't need to use the
	// read_summary and simply use this field.
	RightClosedTimestamp hlc.Timestamp `protobuf:"bytes,6,opt,name=right_closed_timestamp,json=rightClosedTimestamp,proto3" json:"right_closed_timestamp"`
	// RightReadSummary is a summary of the reads that have been performed on the
	// right-hand side up to the point of the Subsume request, which serializes
	// with past reads and begins blocking future reads. It is suitable for use to
	// update the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// RightReadSummary can be used in place of FreezeStart, when available. It
	// has two distinct advantages:
	// 1. it can transfer a higher-resolution snapshot of the reads on the range
	//    through a range merge, to make the merge less disruptive to writes on
	//    the post-merge range because the timestamp cache won't be bumped as
	//    high.
	// 2. it can transfer information about reads with synthetic timestamps, which
	//    are not otherwise captured by the FreezeStart clock timestamp.
	//
	// When a RightReadSummary is set in ReplicatedEvalResult.Merge.Trigger, there
	// is always also a write to the RangePriorReadSummaryKey in the corresponding
	// RaftCommand.WriteBatch. The persisted summary may be identical to the
	// summary in this field, but it does not have to be. Notably, we intended for
	// the summary included in the ReplicatedEvalResult.Merge.Trigger to
	// eventually be a much higher-resolution version of the ReadSummmary than the
	// version persisted. This scheme of persisting a compressed ReadSummary
	// indefinitely and including a higher-resolution ReadSummary on the
	// RaftCommand allows us to optimize for the common case where the merge is
	// applied on the LHS's leaseholder through Raft log application while
	// ensuring correctness in the case where the merge is applied on the LHS's
	// leaseholder through a Raft snapshot.
	RightReadSummary *rspb.ReadSummary `protobuf:"bytes,7,opt,name=right_read_summary,json=rightReadSummary,proto3" json:"right_read_summary,omitempty"`
}

func (m *MergeTrigger) Reset()         { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string { return proto.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()    {}
func (*MergeTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{5}
}
func (m *MergeTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeTrigger.Merge(m, src)
}
func (m *MergeTrigger) XXX_Size() int {
	return m.Size()
}
func (m *MergeTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_MergeTrigger proto.InternalMessageInfo

// ChangeReplicasTrigger carries out a replication change. The Added() and
// Removed() methods return the replicas being added and removed, respectively.
// If more than one change is specified (i.e. len(Added())+len(Removed())
// exceeds one), this initiates an atomic replication change in which the
// "removed" replicas are of type VOTER_OUTGOING or VOTER_DEMOTING_{LEARNER,
// NON_VOTER} (if they are to be turned into learners or non-voters instead); as
// a caveat a single demotion already counts as two changes (and is tracked as a
// Removal() only). This joint configuration is left via another
// ChangeReplicasTrigger which does not specify any additions nor removals.
type ChangeReplicasTrigger struct {
	// TODO(tbg): remove once we know that no trigger using this will ever be
	// applied (this will require something like #39182).
	//
	// TODO(tbg): when removing this, also rename internal_x_replicas to just
	// x_replicas and remove the getter.
	DeprecatedChangeType ReplicaChangeType `protobuf:"varint,1,opt,name=deprecated_change_type,json=deprecatedChangeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"deprecated_change_type,omitempty"`
	// The replica being modified.
	// TODO(tbg): remove once we know that no trigger using this will ever be
	// applied (this will require something like #39182).
	DeprecatedReplica ReplicaDescriptor `protobuf:"bytes,2,opt,name=deprecated_replica,json=deprecatedReplica,proto3" json:"deprecated_replica"`
	// The new replica list with this change applied.
	DeprecatedUpdatedReplicas []ReplicaDescriptor `protobuf:"bytes,3,rep,name=deprecated_updated_replicas,json=deprecatedUpdatedReplicas,proto3" json:"deprecated_updated_replicas"`
	// The next replica id to use with this change applied.
	DeprecatedNextReplicaID ReplicaID `protobuf:"varint,4,opt,name=deprecated_next_replica_id,json=deprecatedNextReplicaId,proto3,casttype=ReplicaID" json:"deprecated_next_replica_id,omitempty"`
	// The updated range descriptor. If desc is non-nil, then it overrides
	// updated_replicas and next_replica_id. This incremental addition is needed
	// to maintain backwards compatibility.
	// TODO(jeffreyxiao): Remove deprecated_updated_replicas and
	// deprecated_next_replica_id in 20.1.
	Desc *RangeDescriptor `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
	// The new replicas added to the range descriptor in this change, exactly as
	// they appear in the updated range descriptor.
	InternalAddedReplicas []ReplicaDescriptor `protobuf:"bytes,6,rep,name=internal_added_replicas,json=internalAddedReplicas,proto3" json:"internal_added_replicas"`
	// The replicas whose removal is being initiated in this change. If the
	// replica is still present as an outgoing voter in the updated descriptor
	// (i.e. if this is a full atomic replication change), then the replica here
	// must match that in the descriptor; otherwise it must match the replica
	// removed from the descriptor in the course of this change (which is itself
	// not visible to this trigger).
	InternalRemovedReplicas []ReplicaDescriptor `protobuf:"bytes,7,rep,name=internal_removed_replicas,json=internalRemovedReplicas,proto3" json:"internal_removed_replicas"`
}

func (m *ChangeReplicasTrigger) Reset()      { *m = ChangeReplicasTrigger{} }
func (*ChangeReplicasTrigger) ProtoMessage() {}
func (*ChangeReplicasTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{6}
}
func (m *ChangeReplicasTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeReplicasTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeReplicasTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeReplicasTrigger.Merge(m, src)
}
func (m *ChangeReplicasTrigger) XXX_Size() int {
	return m.Size()
}
func (m *ChangeReplicasTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeReplicasTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeReplicasTrigger proto.InternalMessageInfo

// ModifiedSpanTrigger indicates that a specific span has been modified.
// This can be used to trigger scan-and-gossip for the given span.
type ModifiedSpanTrigger struct {
	SystemConfigSpan bool `protobuf:"varint,1,opt,name=system_config_span,json=systemConfigSpan,proto3" json:"system_config_span,omitempty"`
	// node_liveness_span is set to indicate that node liveness records
	// need re-gossiping after modification or range lease updates. The
	// span is set to a single key when nodes update their liveness records
	// with heartbeats to extend the expiration timestamp. Changes to the
	// range lease for the range containing node liveness triggers re-gossip
	// of the entire node liveness key range.
	NodeLivenessSpan *Span `protobuf:"bytes,2,opt,name=node_liveness_span,json=nodeLivenessSpan,proto3" json:"node_liveness_span,omitempty"`
}

func (m *ModifiedSpanTrigger) Reset()         { *m = ModifiedSpanTrigger{} }
func (m *ModifiedSpanTrigger) String() string { return proto.CompactTextString(m) }
func (*ModifiedSpanTrigger) ProtoMessage()    {}
func (*ModifiedSpanTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{7}
}
func (m *ModifiedSpanTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifiedSpanTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ModifiedSpanTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifiedSpanTrigger.Merge(m, src)
}
func (m *ModifiedSpanTrigger) XXX_Size() int {
	return m.Size()
}
func (m *ModifiedSpanTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifiedSpanTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_ModifiedSpanTrigger proto.InternalMessageInfo

// StickyBitTrigger indicates that the sticky bit of a range should be changed.
// This trigger is used in two cases:
// 1. Unsplitting a range. Note that unsplitting and merging are different
//    operations. Unsplitting a range will only update the expiration time
//    associated with the range to hlc.Timestamp{}.
// 2. Splitting at the start key of a range. In this case, no range is split but
//    the sticky bit is might be updated, so we need to use this trigger instead
//    of SplitTrigger.
//
// Note that the sticky_bit should always be set to the same timestamp used to
// update the range descriptor and it's the client's responsibility that the
// timestamps are aligned.
type StickyBitTrigger struct {
	// Set to nil to remove a RangeDescriptor's sticky bit.
	StickyBit hlc.Timestamp `protobuf:"bytes,1,opt,name=sticky_bit,json=stickyBit,proto3" json:"sticky_bit"`
}

func (m *StickyBitTrigger) Reset()         { *m = StickyBitTrigger{} }
func (m *StickyBitTrigger) String() string { return proto.CompactTextString(m) }
func (*StickyBitTrigger) ProtoMessage()    {}
func (*StickyBitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{8}
}
func (m *StickyBitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickyBitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StickyBitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickyBitTrigger.Merge(m, src)
}
func (m *StickyBitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *StickyBitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_StickyBitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_StickyBitTrigger proto.InternalMessageInfo

// InternalCommitTrigger encapsulates all of the internal-only commit triggers.
// Only one may be set.
type InternalCommitTrigger struct {
	SplitTrigger          *SplitTrigger          `protobuf:"bytes,1,opt,name=split_trigger,json=splitTrigger,proto3" json:"split_trigger,omitempty"`
	MergeTrigger          *MergeTrigger          `protobuf:"bytes,2,opt,name=merge_trigger,json=mergeTrigger,proto3" json:"merge_trigger,omitempty"`
	ChangeReplicasTrigger *ChangeReplicasTrigger `protobuf:"bytes,3,opt,name=change_replicas_trigger,json=changeReplicasTrigger,proto3" json:"change_replicas_trigger,omitempty"`
	ModifiedSpanTrigger   *ModifiedSpanTrigger   `protobuf:"bytes,4,opt,name=modified_span_trigger,json=modifiedSpanTrigger,proto3" json:"modified_span_trigger,omitempty"`
	StickyBitTrigger      *StickyBitTrigger      `protobuf:"bytes,5,opt,name=sticky_bit_trigger,json=stickyBitTrigger,proto3" json:"sticky_bit_trigger,omitempty"`
}

func (m *InternalCommitTrigger) Reset()         { *m = InternalCommitTrigger{} }
func (m *InternalCommitTrigger) String() string { return proto.CompactTextString(m) }
func (*InternalCommitTrigger) ProtoMessage()    {}
func (*InternalCommitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{9}
}
func (m *InternalCommitTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InternalCommitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InternalCommitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InternalCommitTrigger.Merge(m, src)
}
func (m *InternalCommitTrigger) XXX_Size() int {
	return m.Size()
}
func (m *InternalCommitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_InternalCommitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_InternalCommitTrigger proto.InternalMessageInfo

func (m *InternalCommitTrigger) GetSplitTrigger() *SplitTrigger {
	if m != nil {
		return m.SplitTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetMergeTrigger() *MergeTrigger {
	if m != nil {
		return m.MergeTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetChangeReplicasTrigger() *ChangeReplicasTrigger {
	if m != nil {
		return m.ChangeReplicasTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetModifiedSpanTrigger() *ModifiedSpanTrigger {
	if m != nil {
		return m.ModifiedSpanTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetStickyBitTrigger() *StickyBitTrigger {
	if m != nil {
		return m.StickyBitTrigger
	}
	return nil
}

type ObservedTimestamp struct {
	NodeID    NodeID                                                       `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	Timestamp github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,2,opt,name=timestamp,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"timestamp"`
}

func (m *ObservedTimestamp) Reset()         { *m = ObservedTimestamp{} }
func (m *ObservedTimestamp) String() string { return proto.CompactTextString(m) }
func (*ObservedTimestamp) ProtoMessage()    {}
func (*ObservedTimestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{10}
}
func (m *ObservedTimestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObservedTimestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObservedTimestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObservedTimestamp.Merge(m, src)
}
func (m *ObservedTimestamp) XXX_Size() int {
	return m.Size()
}
func (m *ObservedTimestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_ObservedTimestamp.DiscardUnknown(m)
}

var xxx_messageInfo_ObservedTimestamp proto.InternalMessageInfo

// A Transaction is a unit of work performed on the database.
// Cockroach transactions always operate at the serializable isolation
// level. Each Cockroach transaction is assigned a random priority.
// This priority will be used to decide whether a transaction will be
// aborted during contention.
//
// If you add fields to Transaction you'll need to update
// Transaction.Clone. Failure to do so will result in test failures.
type Transaction struct {
	// The transaction metadata. This field includes the subset of information
	// that is persisted with every write intent.
	enginepb.TxnMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	// A free-text identifier for debug purposes.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The status of the transaction.
	Status TransactionStatus `protobuf:"varint,4,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// The last time that the transaction's record was sent a heartbeat by its
	// coordinator to indicate client activity. Concurrent transactions will
	// avoid aborting a transaction if it observes recent-enough activity.
	//
	// NOTE: this could use a ClockTimestamp type, but doing so results in a
	// large diff that doesn't seem worth it, given that we never feed this
	// timestamp back into a clock.
	LastHeartbeat hlc.Timestamp `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat,proto3" json:"last_heartbeat"`
	// This flag is set if the transaction's timestamp was "leaked" beyond the
	// transaction (e.g. via cluster_logical_timestamp()). If true, this prevents
	// the transaction's timestamp from being pushed, which means that the txn
	// can't commit at a higher timestamp without resorting to a client-side
	// retry.
	CommitTimestampFixed bool `protobuf:"varint,16,opt,name=commit_timestamp_fixed,json=commitTimestampFixed,proto3" json:"commit_timestamp_fixed,omitempty"`
	// The transaction's read timestamp. All reads are performed at this
	// timestamp, ensuring that the transaction runs on top of a consistent
	// snapshot of the database.
	// Writes are performed at the transaction's write timestamp (meta.timestamp).
	// The write timestamp can diverge from the read timestamp when a write is
	// "pushed": for example in case a write runs into the timestamp cache, we're
	// forced to write at a higher timestamp. Being serializable, the transaction
	// can't commit if the write timestamp diverged from the read timestamp unless
	// we prove that the read timestamp can also be advanced to match the
	// write timestamp; it can be advanced if the two timestamps are equivalent
	// for everything that the transaction has read (meaning that there's no
	// values in between the read timestamp and the write timestamp for any key in
	// the txn's read set). We call checking whether the read timestamp can
	// advance "refreshing the read set". So, the read timestamp advances after a
	// successful refresh or, if the refresh is unsuccessful, after a transaction
	// restart.
	ReadTimestamp hlc.Timestamp `protobuf:"bytes,15,opt,name=read_timestamp,json=readTimestamp,proto3" json:"read_timestamp"`
	// The transaction's global uncertainty limit is its initial timestamp +
	// maximum cluster-wide clock skew. This value defines the inclusive upper
	// bound of the transaction's uncertainty interval.
	//
	// Reads which encounter values with timestamps between read_timestamp and
	// global_uncertainty_limit ("within the uncertainty interval") trigger a
	// retry error (ReadWithinUncertaintyIntervalError). This forces the
	// transaction to increase its read timestamp, either through a refresh or a
	// retry, in order to ensure that the transaction observes the "uncertain"
	// value.
	//
	// However, the uncertainty limit applied to values can be reduced when
	// evaluating a request on a node from which the transaction has acquired an
	// observed timestamp. This reduced uncertainty limit is reflected in the
	// local_uncertainty_limit variable at the time of request evaluation.
	//
	// See pkg/kv/kvserver/observedts for more details.
	//
	// The case global_uncertainty_limit < read_timestamp is possible for
	// transactions which have been pushed or have refreshed; in this case,
	// global_uncertainty_limit should be ignored.
	GlobalUncertaintyLimit hlc.Timestamp `protobuf:"bytes,7,opt,name=global_uncertainty_limit,json=globalUncertaintyLimit,proto3" json:"global_uncertainty_limit"`
	// A list of <NodeID, timestamp> pairs. The list maps NodeIDs to timestamps
	// as observed from their local clock during this transaction. The purpose
	// of this list is to allow a transaction to avoid uncertainty related
	// restarts which occur when reading a value in the near future, per the
	// global_uncertainty_limit field. The list helps avoid these restarts by
	// establishing a lower local_uncertainty_limit when evaluating a request on
	// a node in the list.
	//
	// See pkg/kv/kvserver/observedts for more details.
	//
	// The slice of observed timestamps is kept sorted by NodeID. Use
	// Transaction.UpdateObservedTimestamp to maintain the sorted order. The
	// slice should be treated as immutable and all updates should be performed
	// on a copy of the slice.
	ObservedTimestamps []ObservedTimestamp `protobuf:"bytes,8,rep,name=observed_timestamps,json=observedTimestamps,proto3" json:"observed_timestamps"`
	// If set, a write performed by the transaction could not be performed at the
	// transaction's read timestamp because a newer value was present. Had our
	// write been performed, it would have overwritten the other value even though
	// that value might not have been read by a previous read in the transaction
	// (i.e. lost update anomaly). The write is still performed, but this flag is
	// set and the txn's write timestamp is bumped, so the client will not be able
	// to commit without performing a refresh.
	//
	// Since 20.1, errors do not carry this flag; only successful BatchResponses
	// do. When possible, such a BatchResponse is preferred to a WriteTooOldError
	// because the former leaves intents behind to act as locks.
	//
	// On the client, the txnSpanRefresher terminates this flag by refreshing
	// eagerly when the flag is set. If the key that generated the write too old
	// condition had been previously read by the transaction, a refresh of the
	// transaction's read span will surely fail. The client is not currently smart
	// enough to avoid hopeless refreshes, though.
	//
	// Historically, this field was also important for SNAPSHOT transactions which
	// could commit in other situations when the write timestamp is bumped, but
	// not when this flag is set (since lost updates cannot be tolerated even in
	// SNAPSHOT). In SERIALIZABLE isolation, transactions generally don't commit
	// with a bumped write timestamp, so this flag is only telling us that a
	// refresh is less likely to succeed than in other cases where
	// ReadTimestamp != WriteTimestamp.
	WriteTooOld bool `protobuf:"varint,12,opt,name=write_too_old,json=writeTooOld,proto3" json:"write_too_old,omitempty"`
	// Set of spans that the transaction has acquired locks within. These are
	// spans which must be resolved on txn completion. Note that these spans
	// may be condensed to cover aggregate spans if the keys locked by the
	// transaction exceeded a size threshold.
	//
	// The set logically extends to include the keys of all writes in the
	// in-flight write set. However, those keys are not stored in this set
	// to avoid duplication. This means that elements that are removed from
	// that set should be merged into this one.
	//
	// The slice is maintained in sorted order and all spans are maximally
	// merged such that no two spans here overlap each other. It should be
	// treated as immutable and all updates should be performed on a copy
	// of the slice.
	LockSpans []Span `protobuf:"bytes,11,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	// Set of in-flight intent writes that have been issued by the transaction but
	// which may not have succeeded yet. If any in-flight writes are provided, a
	// committing EndTxn request will move a PENDING transaction to the STAGING
	// status instead of the COMMITTED status. These in-flight writes must then
	// all be confirmed as successful before the transaction can be moved from
	// STAGING to COMMITTED. Because of this, the set will only ever contain
	// entries when the transaction is STAGING. For more, see txnCommitter.
	//
	// The slice is maintained in sorted order by sequence number. It should be
	// treated as immutable and all updates should be performed on a copy of the
	// slice.
	InFlightWrites []SequencedWrite `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// A list of ignored seqnum ranges.
	//
	// The slice is maintained as non-overlapping, non-contiguous (i.e. it must
	// coalesce ranges to avoid situations where a range's end seqnum is equal to
	// the next range's start seqnum), and sorted in seqnum order. It should be
	// treated as immutable and all updates should be performed on a copy of the
	// slice.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,18,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *Transaction) Reset()      { *m = Transaction{} }
func (*Transaction) ProtoMessage() {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{11}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

// A TransactionRecord message contains the subset of the fields in a
// Transaction message that must be persisted in a transaction record.
// It can be thought of as a mask for the fields in Transaction that
// end up persisted in a transaction record.
//
// The message type is wire-compatible with persisted Transaction protos,
// but avoids the overhead of the fields in Transaction that don't need to
// be persisted in a transaction record. It also serves as a specification
// for the fields that must be present in a transaction record.
//
// NOTE: any changes to this type must be reflected in the AsRecord and
// AsTransaction methods.
type TransactionRecord struct {
	// See comments on Transaction proto.
	enginepb.TxnMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Status           TransactionStatus             `protobuf:"varint,4,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	LastHeartbeat    hlc.Timestamp                 `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat,proto3" json:"last_heartbeat"`
	LockSpans        []Span                        `protobuf:"bytes,11,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	InFlightWrites   []SequencedWrite              `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	IgnoredSeqNums   []enginepb.IgnoredSeqNumRange `protobuf:"bytes,18,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *TransactionRecord) Reset()         { *m = TransactionRecord{} }
func (m *TransactionRecord) String() string { return proto.CompactTextString(m) }
func (*TransactionRecord) ProtoMessage()    {}
func (*TransactionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{12}
}
func (m *TransactionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRecord.Merge(m, src)
}
func (m *TransactionRecord) XXX_Size() int {
	return m.Size()
}
func (m *TransactionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRecord proto.InternalMessageInfo

// A Intent is a Span together with a Transaction metadata. Intents messages
// are used to reference persistent on-disk write intents. They are used on
// the return path of e.g. scans, to report the existence of a write intent
// on a key.
//
// Note: avoid constructing Intent directly; consider using MakeIntent() instead.
type Intent struct {
	Intent_SingleKeySpan `protobuf:"bytes,1,opt,name=single_key_span,json=singleKeySpan,proto3,embedded=single_key_span" json:"single_key_span"`
	Txn                  enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
}

func (m *Intent) Reset()         { *m = Intent{} }
func (m *Intent) String() string { return proto.CompactTextString(m) }
func (*Intent) ProtoMessage()    {}
func (*Intent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{13}
}
func (m *Intent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Intent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Intent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Intent.Merge(m, src)
}
func (m *Intent) XXX_Size() int {
	return m.Size()
}
func (m *Intent) XXX_DiscardUnknown() {
	xxx_messageInfo_Intent.DiscardUnknown(m)
}

var xxx_messageInfo_Intent proto.InternalMessageInfo

// SingleKeySpan preseves wire compatibility with an earlier version of this
// proto which used a Span. An Intent never spans keys, so there was no need
// for this to contain an EndKey.
type Intent_SingleKeySpan struct {
	// The start key of the key range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
}

func (m *Intent_SingleKeySpan) Reset()         { *m = Intent_SingleKeySpan{} }
func (m *Intent_SingleKeySpan) String() string { return proto.CompactTextString(m) }
func (*Intent_SingleKeySpan) ProtoMessage()    {}
func (*Intent_SingleKeySpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{13, 0}
}
func (m *Intent_SingleKeySpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Intent_SingleKeySpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Intent_SingleKeySpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Intent_SingleKeySpan.Merge(m, src)
}
func (m *Intent_SingleKeySpan) XXX_Size() int {
	return m.Size()
}
func (m *Intent_SingleKeySpan) XXX_DiscardUnknown() {
	xxx_messageInfo_Intent_SingleKeySpan.DiscardUnknown(m)
}

var xxx_messageInfo_Intent_SingleKeySpan proto.InternalMessageInfo

// A LockAcquisition represents the action of a Transaction acquiring a lock
// with a specified durbility level over a Span of keys.
type LockAcquisition struct {
	Span       `protobuf:"bytes,1,opt,name=span,proto3,embedded=span" json:"span"`
	Txn        enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	Durability lock.Durability  `protobuf:"varint,3,opt,name=durability,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Durability" json:"durability,omitempty"`
}

func (m *LockAcquisition) Reset()         { *m = LockAcquisition{} }
func (m *LockAcquisition) String() string { return proto.CompactTextString(m) }
func (*LockAcquisition) ProtoMessage()    {}
func (*LockAcquisition) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{14}
}
func (m *LockAcquisition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockAcquisition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockAcquisition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockAcquisition.Merge(m, src)
}
func (m *LockAcquisition) XXX_Size() int {
	return m.Size()
}
func (m *LockAcquisition) XXX_DiscardUnknown() {
	xxx_messageInfo_LockAcquisition.DiscardUnknown(m)
}

var xxx_messageInfo_LockAcquisition proto.InternalMessageInfo

// A LockUpdate is a Span together with Transaction state. LockUpdate messages
// are used to update all locks held by the transaction within the span to the
// transaction's authoritative state. As such, the message is used as input
// argument to intent resolution, to pass the current txn status, timestamps and
// ignored seqnum ranges to the resolution algorithm.
type LockUpdate struct {
	Span           `protobuf:"bytes,1,opt,name=span,proto3,embedded=span" json:"span"`
	Txn            enginepb.TxnMeta              `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	Status         TransactionStatus             `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,4,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *LockUpdate) Reset()         { *m = LockUpdate{} }
func (m *LockUpdate) String() string { return proto.CompactTextString(m) }
func (*LockUpdate) ProtoMessage()    {}
func (*LockUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{15}
}
func (m *LockUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LockUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockUpdate.Merge(m, src)
}
func (m *LockUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LockUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LockUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LockUpdate proto.InternalMessageInfo

// A SequencedWrite is a point write to a key with a certain sequence number.
type SequencedWrite struct {
	// The key that the write was made at.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The sequence number of the request that created the write.
	Sequence github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,2,opt,name=sequence,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"sequence,omitempty"`
}

func (m *SequencedWrite) Reset()         { *m = SequencedWrite{} }
func (m *SequencedWrite) String() string { return proto.CompactTextString(m) }
func (*SequencedWrite) ProtoMessage()    {}
func (*SequencedWrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{16}
}
func (m *SequencedWrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequencedWrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequencedWrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequencedWrite.Merge(m, src)
}
func (m *SequencedWrite) XXX_Size() int {
	return m.Size()
}
func (m *SequencedWrite) XXX_DiscardUnknown() {
	xxx_messageInfo_SequencedWrite.DiscardUnknown(m)
}

var xxx_messageInfo_SequencedWrite proto.InternalMessageInfo

// Lease contains information about range leases including the
// expiration and lease holder.
type Lease struct {
	// The start is a timestamp at which the lease begins. This value
	// must be greater than the last lease expiration or the lease request
	// is considered invalid.
	Start github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,1,opt,name=start,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"start"`
	// The expiration is a timestamp at which the lease expires. This means that a
	// new lease can be granted for a later timestamp. This field is only set for
	// expiration-based leases.
	Expiration *hlc.Timestamp `protobuf:"bytes,2,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// The address of the would-be lease holder.
	Replica ReplicaDescriptor `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica"`
	// The start of the lease stasis period. This field is deprecated.
	DeprecatedStartStasis *hlc.Timestamp `protobuf:"bytes,4,opt,name=deprecated_start_stasis,json=deprecatedStartStasis,proto3" json:"deprecated_start_stasis,omitempty"`
	// The current timestamp when this lease has been proposed. Used after a
	// transfer and after a node restart to enforce that a node only uses leases
	// proposed after the time of the said transfer or restart. This is nullable
	// to help with the rollout (such that a lease applied by some nodes before
	// the rollout and some nodes after the rollout is serialized the same).
	// TODO(andrei): Make this non-nullable after the rollout.
	ProposedTS *github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=proposed_ts,json=proposedTs,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"proposed_ts,omitempty"`
	// The epoch of the lease holder's node liveness entry. If this value is
	// non-zero, the expiration field is ignored.
	Epoch int64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// A zero-indexed sequence number which is incremented during the acquisition
	// of each new range lease that is not equivalent to the previous range lease
	// (i.e. an acquisition that implies a leaseholder change). The sequence
	// number is used to detect lease changes between command proposal and
	// application without requiring that we send the entire lease through Raft.
	// Lease sequence numbers are a reflection of the "lease equivalency" property
	// (see Lease.Equivalent). Two adjacent leases that are equivalent will have
	// the same sequence number and two adjacent leases that are not equivalent
	// will have different sequence numbers.
	Sequence LeaseSequence `protobuf:"varint,7,opt,name=sequence,proto3,casttype=LeaseSequence" json:"sequence,omitempty"`
	// The type of acquisition event that result in this lease (transfer or
	// request).
	AcquisitionType LeaseAcquisitionType `protobuf:"varint,8,opt,name=acquisition_type,json=acquisitionType,proto3,enum=cockroach.roachpb.LeaseAcquisitionType" json:"acquisition_type,omitempty"`
}

func (m *Lease) Reset()      { *m = Lease{} }
func (*Lease) ProtoMessage() {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{17}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(m, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

// AbortSpanEntry contains information about a transaction which has
// been aborted. It's written to a range's AbortSpan if the range
// may have contained intents of the aborted txn. In the event that
// the same transaction attempts to read keys it may have written
// previously, this entry informs the transaction that it has aborted
// and must start fresh with an updated priority.
type AbortSpanEntry struct {
	// The key of the associated transaction.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The candidate commit timestamp the transaction record held at the time
	// it was aborted.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	// The priority of the transaction.
	Priority github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority `protobuf:"varint,3,opt,name=priority,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnPriority" json:"priority,omitempty"`
}

func (m *AbortSpanEntry) Reset()         { *m = AbortSpanEntry{} }
func (m *AbortSpanEntry) String() string { return proto.CompactTextString(m) }
func (*AbortSpanEntry) ProtoMessage()    {}
func (*AbortSpanEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{18}
}
func (m *AbortSpanEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AbortSpanEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AbortSpanEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AbortSpanEntry.Merge(m, src)
}
func (m *AbortSpanEntry) XXX_Size() int {
	return m.Size()
}
func (m *AbortSpanEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AbortSpanEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AbortSpanEntry proto.InternalMessageInfo

// LeafTxnInputState is the state from a transaction coordinator
// necessary and sufficient to set up a leaf transaction coordinator
// on another node.
type LeafTxnInputState struct {
	// txn is a copy of the transaction record.
	Txn Transaction `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// refresh_invalid indicates that the root txn is not
	// collecting refresh spans so the leaf should also avoid
	// collecting them. This is an optimization: it avoids
	// the collection work in that cases and also possibly
	// reduces memory usage.
	RefreshInvalid bool `protobuf:"varint,7,opt,name=refresh_invalid,json=refreshInvalid,proto3" json:"refresh_invalid,omitempty"`
	// in_flight_writes stores all writes that are in-flight and have not yet
	// been proven to have succeeded. Overlapping requests must chain on to
	// their success using a QueryIntent request.
	InFlightWrites []SequencedWrite `protobuf:"bytes,8,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// Whether stepping mode is enabled. False indicates synchronous
	// read-own-writes, where every KV read is able to observe the
	// latest writes. True indicates that KV reads should be done at the
	// read_seq_num specified below.
	SteppingModeEnabled bool `protobuf:"varint,9,opt,name=stepping_mode_enabled,json=steppingModeEnabled,proto3" json:"stepping_mode_enabled,omitempty"`
	// Current read seqnum. When stepping_mode_enabled is true,
	// this field becomes the sequence number used for reads,
	// regardless of the current seqnum generated for writes. This is
	// updated via the (client.TxnSender).Step() operation.
	ReadSeqNum github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,10,opt,name=read_seq_num,json=readSeqNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"read_seq_num,omitempty"`
}

func (m *LeafTxnInputState) Reset()         { *m = LeafTxnInputState{} }
func (m *LeafTxnInputState) String() string { return proto.CompactTextString(m) }
func (*LeafTxnInputState) ProtoMessage()    {}
func (*LeafTxnInputState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{19}
}
func (m *LeafTxnInputState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafTxnInputState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeafTxnInputState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafTxnInputState.Merge(m, src)
}
func (m *LeafTxnInputState) XXX_Size() int {
	return m.Size()
}
func (m *LeafTxnInputState) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafTxnInputState.DiscardUnknown(m)
}

var xxx_messageInfo_LeafTxnInputState proto.InternalMessageInfo

// LeafTxnFinalState is the state from a leaf transaction coordinator
// necessary and sufficient to update a RootTxn on the gateway
// coordinator.
type LeafTxnFinalState struct {
	// txn is a copy of the transaction record.
	// TODO(knz,andrei): We don't actually need the fully txn
	// record. This can be simplified.
	// See: https://github.com/cockroachdb/cockroach/issues/43192
	Txn Transaction `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// deprecated_command_count indicates that at least one request
	// has been processed in this transaction.
	// Populated only for compatibility with pre-20.1 nodes.
	// TODO(knz,andrei): Remove this in 20.2.
	DeprecatedCommandCount int32 `protobuf:"varint,3,opt,name=deprecated_command_count,json=deprecatedCommandCount,proto3" json:"deprecated_command_count,omitempty"`
	// refresh_spans contains the key spans read by the leaf. The root will add
	// them to its own tracking of reads.
	RefreshSpans []Span `protobuf:"bytes,4,rep,name=refresh_spans,json=refreshSpans,proto3" json:"refresh_spans"`
	// refresh_invalid is set if refresh spans have not been collected. In this
	// case, refresh_spans is empty. It may be set because the leaf was asked not
	// to collect spans or because the leaf's reads exceeded the tracking memory
	// budget.
	RefreshInvalid bool `protobuf:"varint,7,opt,name=refresh_invalid,json=refreshInvalid,proto3" json:"refresh_invalid,omitempty"`
}

func (m *LeafTxnFinalState) Reset()         { *m = LeafTxnFinalState{} }
func (m *LeafTxnFinalState) String() string { return proto.CompactTextString(m) }
func (*LeafTxnFinalState) ProtoMessage()    {}
func (*LeafTxnFinalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{20}
}
func (m *LeafTxnFinalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeafTxnFinalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeafTxnFinalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeafTxnFinalState.Merge(m, src)
}
func (m *LeafTxnFinalState) XXX_Size() int {
	return m.Size()
}
func (m *LeafTxnFinalState) XXX_DiscardUnknown() {
	xxx_messageInfo_LeafTxnFinalState.DiscardUnknown(m)
}

var xxx_messageInfo_LeafTxnFinalState proto.InternalMessageInfo

// ClientRangeInfo represents the kvclient's knowledge about the state of the
// range (i.e. of the range descriptor, lease, and closed timestamp policy). The
// kvserver checks whether the client's info is up to date and, if it isn't, it
// will return a RangeInfo with up-to-date information.
type ClientRangeInfo struct {
	DescriptorGeneration  RangeGeneration            `protobuf:"varint,1,opt,name=descriptor_generation,json=descriptorGeneration,proto3,casttype=RangeGeneration" json:"descriptor_generation,omitempty"`
	LeaseSequence         LeaseSequence              `protobuf:"varint,2,opt,name=lease_sequence,json=leaseSequence,proto3,casttype=LeaseSequence" json:"lease_sequence,omitempty"`
	ClosedTimestampPolicy RangeClosedTimestampPolicy `protobuf:"varint,3,opt,name=closed_timestamp_policy,json=closedTimestampPolicy,proto3,enum=cockroach.roachpb.RangeClosedTimestampPolicy" json:"closed_timestamp_policy,omitempty"`
}

func (m *ClientRangeInfo) Reset()         { *m = ClientRangeInfo{} }
func (m *ClientRangeInfo) String() string { return proto.CompactTextString(m) }
func (*ClientRangeInfo) ProtoMessage()    {}
func (*ClientRangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{21}
}
func (m *ClientRangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientRangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClientRangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRangeInfo.Merge(m, src)
}
func (m *ClientRangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClientRangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRangeInfo proto.InternalMessageInfo

// RangeInfo describes a range which executed a request. It contains the range
// descriptor, lease information, and closed timestamp policy at the time of
// execution.
type RangeInfo struct {
	Desc                  RangeDescriptor            `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	Lease                 Lease                      `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	ClosedTimestampPolicy RangeClosedTimestampPolicy `protobuf:"varint,3,opt,name=closed_timestamp_policy,json=closedTimestampPolicy,proto3,enum=cockroach.roachpb.RangeClosedTimestampPolicy" json:"closed_timestamp_policy,omitempty"`
}

func (m *RangeInfo) Reset()      { *m = RangeInfo{} }
func (*RangeInfo) ProtoMessage() {}
func (*RangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6493e3a32c32e46b, []int{22}
}
func (m *RangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeInfo.Merge(m, src)
}
func (m *RangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.ValueType", ValueType_name, ValueType_value)
	proto.RegisterEnum("cockroach.roachpb.ReplicaChangeType", ReplicaChangeType_name, ReplicaChangeType_value)
	proto.RegisterEnum("cockroach.roachpb.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterEnum("cockroach.roachpb.LeaseAcquisitionType", LeaseAcquisitionType_name, LeaseAcquisitionType_value)
	proto.RegisterEnum("cockroach.roachpb.RangeClosedTimestampPolicy", RangeClosedTimestampPolicy_name, RangeClosedTimestampPolicy_value)
	proto.RegisterType((*Span)(nil), "cockroach.roachpb.Span")
	proto.RegisterType((*Value)(nil), "cockroach.roachpb.Value")
	proto.RegisterType((*KeyValue)(nil), "cockroach.roachpb.KeyValue")
	proto.RegisterType((*StoreIdent)(nil), "cockroach.roachpb.StoreIdent")
	proto.RegisterType((*SplitTrigger)(nil), "cockroach.roachpb.SplitTrigger")
	proto.RegisterType((*MergeTrigger)(nil), "cockroach.roachpb.MergeTrigger")
	proto.RegisterType((*ChangeReplicasTrigger)(nil), "cockroach.roachpb.ChangeReplicasTrigger")
	proto.RegisterType((*ModifiedSpanTrigger)(nil), "cockroach.roachpb.ModifiedSpanTrigger")
	proto.RegisterType((*StickyBitTrigger)(nil), "cockroach.roachpb.StickyBitTrigger")
	proto.RegisterType((*InternalCommitTrigger)(nil), "cockroach.roachpb.InternalCommitTrigger")
	proto.RegisterType((*ObservedTimestamp)(nil), "cockroach.roachpb.ObservedTimestamp")
	proto.RegisterType((*Transaction)(nil), "cockroach.roachpb.Transaction")
	proto.RegisterType((*TransactionRecord)(nil), "cockroach.roachpb.TransactionRecord")
	proto.RegisterType((*Intent)(nil), "cockroach.roachpb.Intent")
	proto.RegisterType((*Intent_SingleKeySpan)(nil), "cockroach.roachpb.Intent.SingleKeySpan")
	proto.RegisterType((*LockAcquisition)(nil), "cockroach.roachpb.LockAcquisition")
	proto.RegisterType((*LockUpdate)(nil), "cockroach.roachpb.LockUpdate")
	proto.RegisterType((*SequencedWrite)(nil), "cockroach.roachpb.SequencedWrite")
	proto.RegisterType((*Lease)(nil), "cockroach.roachpb.Lease")
	proto.RegisterType((*AbortSpanEntry)(nil), "cockroach.roachpb.AbortSpanEntry")
	proto.RegisterType((*LeafTxnInputState)(nil), "cockroach.roachpb.LeafTxnInputState")
	proto.RegisterType((*LeafTxnFinalState)(nil), "cockroach.roachpb.LeafTxnFinalState")
	proto.RegisterType((*ClientRangeInfo)(nil), "cockroach.roachpb.ClientRangeInfo")
	proto.RegisterType((*RangeInfo)(nil), "cockroach.roachpb.RangeInfo")
}

func init() { proto.RegisterFile("roachpb/data.proto", fileDescriptor_6493e3a32c32e46b) }

var fileDescriptor_6493e3a32c32e46b = []byte{
	// 2735 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcb, 0x6f, 0xe3, 0xd6,
	0xb9, 0x37, 0x2d, 0xca, 0xa2, 0x3e, 0x4b, 0x32, 0x7d, 0xc6, 0xf6, 0x68, 0x3c, 0xf7, 0x5a, 0x73,
	0x95, 0x7b, 0x6f, 0xa6, 0x83, 0x46, 0x42, 0x9d, 0x34, 0x08, 0xa6, 0x53, 0xa0, 0x7a, 0x8d, 0x23,
	0x8d, 0x1e, 0x0e, 0x45, 0x4f, 0xe2, 0x24, 0x05, 0x4b, 0x91, 0xc7, 0x32, 0x6b, 0x8a, 0xd4, 0x90,
	0x94, 0x63, 0x65, 0xd7, 0x4d, 0x11, 0x64, 0xd1, 0x16, 0x5d, 0x75, 0x19, 0xa0, 0xbb, 0x76, 0xd1,
	0x2e, 0x8b, 0xfe, 0x05, 0x59, 0x74, 0x91, 0x4d, 0x91, 0xb4, 0x05, 0x84, 0xd6, 0xd9, 0x64, 0xd1,
	0xbf, 0xc0, 0x68, 0x81, 0xe2, 0x9c, 0x43, 0x8a, 0xb4, 0x47, 0x76, 0xe5, 0x4c, 0x9a, 0x66, 0xd1,
	0x8d, 0x4d, 0x7e, 0x8f, 0xdf, 0x77, 0x1e, 0xdf, 0x8b, 0x9f, 0x00, 0x39, 0xb6, 0xaa, 0x1d, 0x0e,
	0x7b, 0x45, 0x5d, 0xf5, 0xd4, 0xc2, 0xd0, 0xb1, 0x3d, 0x1b, 0xad, 0x6a, 0xb6, 0x76, 0x44, 0xe9,
	0x05, 0x9f, 0xbb, 0x79, 0xef, 0xe8, 0xb8, 0x78, 0x74, 0xec, 0x62, 0xe7, 0x18, 0x3b, 0x45, 0xcd,
	0xb6, 0xb4, 0x91, 0xe3, 0x60, 0x4b, 0x1b, 0x17, 0x4d, 0x5b, 0x3b, 0xa2, 0x7f, 0x0c, 0xab, 0xcf,
	0xd4, 0xcf, 0xcb, 0x3a, 0x58, 0xd5, 0xdd, 0xd1, 0x60, 0xa0, 0x3a, 0xe3, 0xa2, 0xe3, 0x0e, 0x7b,
	0x45, 0xff, 0xc5, 0x97, 0xdd, 0x08, 0xcc, 0x0f, 0xb0, 0xa7, 0x86, 0x4b, 0xd8, 0xbc, 0xed, 0x7a,
	0xb6, 0xa3, 0xf6, 0x71, 0x11, 0x5b, 0x7d, 0xc3, 0xc2, 0x44, 0xe0, 0x58, 0xd3, 0x7c, 0xe6, 0x7f,
	0xcd, 0x64, 0xbe, 0xe8, 0x73, 0xb3, 0x23, 0xcf, 0x30, 0x8b, 0x87, 0xa6, 0x56, 0xf4, 0x8c, 0x01,
	0x76, 0x3d, 0x75, 0x30, 0xf4, 0x39, 0x6b, 0x7d, 0xbb, 0x6f, 0xd3, 0xc7, 0x22, 0x79, 0x62, 0xd4,
	0xfc, 0x3e, 0xf0, 0xdd, 0xa1, 0x6a, 0xa1, 0x5b, 0x10, 0x3b, 0xc2, 0xe3, 0x6c, 0xec, 0x0e, 0x77,
	0x37, 0x55, 0x4e, 0x9c, 0x4d, 0x72, 0xb1, 0x47, 0x78, 0x2c, 0x11, 0x1a, 0xba, 0x03, 0x09, 0x6c,
	0xe9, 0x0a, 0x61, 0xf3, 0xe7, 0xd9, 0x4b, 0xd8, 0xd2, 0x1f, 0xe1, 0xf1, 0x7d, 0xe1, 0x67, 0x1f,
	0xe4, 0x16, 0x7e, 0xf3, 0x41, 0x8e, 0x6b, 0xf0, 0x02, 0x27, 0x2e, 0x36, 0x78, 0x61, 0x51, 0x8c,
	0xe5, 0xfb, 0x10, 0x7f, 0xac, 0x9a, 0x23, 0x8c, 0x6e, 0x43, 0xd2, 0x51, 0xdf, 0x51, 0x7a, 0x63,
	0x0f, 0xbb, 0x59, 0x8e, 0x40, 0x48, 0x82, 0xa3, 0xbe, 0x53, 0x26, 0xef, 0xa8, 0x04, 0xc9, 0xe9,
	0x4a, 0xb3, 0x8b, 0x77, 0xb8, 0xbb, 0xcb, 0xdb, 0xff, 0x5d, 0x08, 0xaf, 0x80, 0x6c, 0xa7, 0x70,
	0x68, 0x6a, 0x05, 0x39, 0x10, 0x2a, 0xf3, 0x1f, 0x4e, 0x72, 0x0b, 0x52, 0xa8, 0x95, 0x7f, 0x0b,
	0x84, 0x47, 0x78, 0xcc, 0x6c, 0xf9, 0xfb, 0xe0, 0x66, 0xec, 0xe3, 0x25, 0x88, 0x1f, 0x13, 0x19,
	0xdf, 0x4a, 0xb6, 0xf0, 0xd4, 0x45, 0x17, 0x28, 0x86, 0x6f, 0x80, 0x09, 0xe7, 0x3f, 0xe6, 0x00,
	0xba, 0x9e, 0xed, 0xe0, 0xba, 0x8e, 0x2d, 0x0f, 0xf5, 0x01, 0x34, 0x73, 0xe4, 0x7a, 0xd8, 0x51,
	0x0c, 0xdd, 0x37, 0xf3, 0x2a, 0x91, 0xff, 0xe3, 0x24, 0xf7, 0x62, 0xdf, 0xf0, 0x0e, 0x47, 0xbd,
	0x82, 0x66, 0x0f, 0x8a, 0x53, 0x6c, 0xbd, 0x17, 0x3e, 0x17, 0x87, 0x47, 0xfd, 0x22, 0xbd, 0xa0,
	0xd1, 0xc8, 0xd0, 0x0b, 0x7b, 0x7b, 0xf5, 0xea, 0xe9, 0x24, 0x97, 0xac, 0x30, 0xc0, 0x7a, 0x55,
	0x4a, 0xfa, 0xd8, 0x75, 0x1d, 0xbd, 0x00, 0x09, 0xcb, 0xd6, 0x31, 0xb1, 0x42, 0xd6, 0x1b, 0x2f,
	0xaf, 0x9d, 0x4e, 0x72, 0x4b, 0x6d, 0x5b, 0xc7, 0xf5, 0xea, 0xd9, 0xf4, 0x49, 0x5a, 0x22, 0x42,
	0x75, 0x1d, 0x7d, 0x03, 0x04, 0xe2, 0x17, 0x54, 0x3e, 0x46, 0xe5, 0x37, 0x4e, 0x27, 0xb9, 0x04,
	0x5b, 0x39, 0x51, 0x08, 0x1e, 0xa5, 0x84, 0xcb, 0x76, 0x93, 0xff, 0x05, 0x07, 0xa9, 0xee, 0xd0,
	0x34, 0x3c, 0xd9, 0x31, 0xfa, 0x7d, 0xec, 0xa0, 0x1a, 0x24, 0x4d, 0x7c, 0xe0, 0x29, 0x3a, 0x76,
	0x35, 0xba, 0xb5, 0xe5, 0xed, 0xfc, 0x8c, 0x43, 0x92, 0x54, 0xab, 0x8f, 0xab, 0xd8, 0xd5, 0x1c,
	0x63, 0xe8, 0xd9, 0x8e, 0x7f, 0x5c, 0x02, 0x51, 0x25, 0x54, 0xb4, 0x03, 0xe0, 0x18, 0xfd, 0x43,
	0x1f, 0x67, 0xf1, 0x9a, 0x38, 0x49, 0xaa, 0x4b, 0xc8, 0xf7, 0xf9, 0xcf, 0x98, 0x4b, 0xc5, 0x44,
	0x3e, 0xff, 0x7b, 0x1e, 0x52, 0x2d, 0xec, 0xf4, 0xf1, 0x57, 0x74, 0xb1, 0xa8, 0x0f, 0x22, 0x03,
	0x22, 0xd1, 0xa8, 0xb8, 0x9e, 0xea, 0xb9, 0x34, 0x5c, 0x96, 0xb7, 0xff, 0x2f, 0x02, 0xe7, 0xc7,
	0x6e, 0x21, 0x88, 0xdd, 0x42, 0xeb, 0x71, 0xa5, 0xd2, 0x25, 0xc2, 0xe5, 0x0d, 0x82, 0x78, 0x3a,
	0xc9, 0x65, 0x24, 0x02, 0x33, 0xa5, 0x4b, 0x19, 0x0a, 0xdb, 0x3a, 0xd6, 0x34, 0xfa, 0x8e, 0x7e,
	0xc8, 0x41, 0xea, 0xc0, 0xc1, 0xf8, 0x5d, 0x4c, 0xac, 0x38, 0x5e, 0x36, 0x3e, 0x4f, 0xd0, 0x54,
	0x09, 0xfa, 0xd9, 0x24, 0xf7, 0x60, 0x7e, 0x1f, 0x25, 0x00, 0x15, 0x92, 0xdc, 0xa6, 0x28, 0xd2,
	0x32, 0x33, 0xdc, 0x25, 0x76, 0xd1, 0x3e, 0x6c, 0xb0, 0x1d, 0x6b, 0xa6, 0xed, 0x62, 0x5d, 0x09,
	0xc3, 0x78, 0x69, 0xfe, 0x30, 0x5e, 0xa3, 0x10, 0x15, 0x8a, 0x30, 0xe5, 0xa1, 0xb7, 0x01, 0x31,
	0x68, 0x92, 0x40, 0x15, 0x3f, 0x69, 0x66, 0x13, 0x14, 0xb6, 0x10, 0x81, 0x3d, 0x3a, 0x2e, 0x04,
	0xb9, 0xb6, 0x10, 0xc9, 0xb5, 0x05, 0x09, 0xab, 0x7a, 0x97, 0x3d, 0x4b, 0xec, 0x5a, 0x22, 0x94,
	0x73, 0x7e, 0xf5, 0xcb, 0x38, 0xac, 0x57, 0x0e, 0xc9, 0xe5, 0x4a, 0x78, 0x68, 0x1a, 0x9a, 0xea,
	0x06, 0x0e, 0xf6, 0x26, 0x6c, 0xe8, 0x78, 0xe8, 0x60, 0x4d, 0xf5, 0xb0, 0xae, 0x68, 0x54, 0x46,
	0xf1, 0xc6, 0x43, 0x4c, 0xbd, 0x2d, 0xb3, 0xfd, 0xbf, 0xb3, 0xbc, 0x84, 0x61, 0x30, 0x40, 0x79,
	0x3c, 0xc4, 0xd2, 0x5a, 0x88, 0x11, 0x52, 0xd1, 0x3e, 0xa0, 0x08, 0xb6, 0xc3, 0xb4, 0x7c, 0xef,
	0xbb, 0x02, 0xf7, 0x29, 0xff, 0x5b, 0x0d, 0x51, 0x7c, 0x11, 0xf4, 0x7d, 0xb8, 0x1d, 0x81, 0x1e,
	0x0d, 0xf5, 0xa8, 0x09, 0x37, 0x1b, 0xbb, 0x13, 0xbb, 0xa6, 0x8d, 0x5b, 0x21, 0xdc, 0x1e, 0x43,
	0x0b, 0x4e, 0x0a, 0x61, 0xd8, 0x8c, 0xd8, 0xb2, 0xf0, 0x89, 0x17, 0x18, 0x22, 0x69, 0x88, 0xa7,
	0x69, 0xe8, 0xee, 0xe9, 0x24, 0x77, 0xb3, 0x3a, 0x95, 0x6a, 0xe3, 0x13, 0xcf, 0xd7, 0xa7, 0x69,
	0x29, 0x39, 0x7d, 0x91, 0x6e, 0xea, 0x33, 0xa5, 0x74, 0xf4, 0x32, 0xf0, 0x34, 0x3a, 0xe3, 0xf3,
	0x46, 0xa7, 0x44, 0xe5, 0x51, 0x0f, 0x6e, 0x1a, 0x96, 0x87, 0x1d, 0x4b, 0x35, 0x15, 0x55, 0xd7,
	0xa3, 0xc7, 0xb0, 0x74, 0xed, 0x63, 0x58, 0x0f, 0xa0, 0x4a, 0x04, 0x69, 0x7a, 0x04, 0x07, 0x70,
	0x6b, 0x6a, 0xc3, 0xc1, 0x03, 0xfb, 0x38, 0x6a, 0x25, 0x71, 0x6d, 0x2b, 0xd3, 0x05, 0x4b, 0x0c,
	0x2b, 0xb0, 0x73, 0x9f, 0x27, 0x25, 0x36, 0xff, 0x3e, 0x07, 0x37, 0x5a, 0xb6, 0x6e, 0x1c, 0x18,
	0x58, 0x27, 0x65, 0x3b, 0xf0, 0xd5, 0xaf, 0x03, 0x72, 0xc7, 0xae, 0x87, 0x07, 0x8a, 0x66, 0x5b,
	0x07, 0x46, 0x5f, 0x71, 0x87, 0xaa, 0x45, 0xfd, 0x54, 0x90, 0x44, 0xc6, 0xa9, 0x50, 0x06, 0xad,
	0xf5, 0x35, 0x40, 0xb4, 0xb4, 0x98, 0xc6, 0x31, 0xb6, 0xb0, 0xeb, 0x32, 0x69, 0xe6, 0x7d, 0x37,
	0x67, 0x2c, 0x96, 0x28, 0x49, 0x22, 0x51, 0x69, 0xfa, 0x1a, 0x84, 0x92, 0x7f, 0x0c, 0x62, 0xd7,
	0x33, 0xb4, 0xa3, 0x71, 0x39, 0x2c, 0x21, 0x65, 0x00, 0x97, 0xd2, 0x94, 0x9e, 0xe1, 0xf9, 0x69,
	0x79, 0xbe, 0x72, 0xee, 0x06, 0x50, 0xf9, 0xdf, 0xc6, 0x60, 0xbd, 0xee, 0x1f, 0x43, 0xc5, 0x1e,
	0x0c, 0x42, 0xf4, 0x2a, 0xa4, 0x5d, 0x52, 0xb0, 0x14, 0x8f, 0x11, 0x7c, 0x03, 0xb9, 0x99, 0x6b,
	0x0e, 0x0b, 0x9b, 0x94, 0x72, 0xa3, 0x65, 0xae, 0x0a, 0xe9, 0x01, 0xa9, 0x24, 0x53, 0x94, 0xc5,
	0x4b, 0x51, 0xa2, 0x15, 0x47, 0x4a, 0x0d, 0xa2, 0xf5, 0xe7, 0x7b, 0x70, 0xd3, 0xcf, 0x09, 0xc1,
	0x75, 0x4f, 0xf1, 0x62, 0x14, 0xef, 0xee, 0x0c, 0xbc, 0x99, 0x99, 0x46, 0x5a, 0xd7, 0x2e, 0x49,
	0x40, 0xeb, 0x03, 0xff, 0xae, 0xe9, 0x0d, 0x4d, 0xf1, 0x59, 0x59, 0xf9, 0xff, 0x59, 0xeb, 0x7d,
	0xda, 0x37, 0xa4, 0x1b, 0x83, 0x19, 0x0e, 0xf3, 0x1a, 0xa0, 0xf0, 0x9e, 0xa6, 0xc0, 0x2c, 0xc0,
	0x9e, 0x9b, 0x75, 0x9c, 0x17, 0x2e, 0x5a, 0x12, 0xdd, 0x0b, 0x94, 0xfb, 0xfc, 0x7b, 0x1f, 0xe4,
	0xb8, 0xfc, 0xef, 0x38, 0x58, 0xed, 0xf4, 0x68, 0x4a, 0x8e, 0xe4, 0xf3, 0x48, 0x33, 0xc3, 0xcd,
	0xd1, 0xcc, 0xfc, 0x80, 0xbb, 0x76, 0x53, 0xf8, 0xc5, 0xd4, 0xb7, 0xd0, 0xea, 0x7d, 0x9e, 0xf4,
	0xb3, 0xf9, 0xb3, 0x25, 0x58, 0x96, 0x1d, 0xd5, 0x72, 0x55, 0xcd, 0x33, 0x6c, 0x0b, 0x95, 0x80,
	0x27, 0xbd, 0xba, 0xef, 0x78, 0xcf, 0x5d, 0x55, 0xd9, 0xe5, 0x13, 0xab, 0x85, 0x3d, 0xb5, 0x2c,
	0x90, 0x95, 0x7d, 0x34, 0xc9, 0x71, 0x12, 0x55, 0x45, 0x08, 0x78, 0x4b, 0x1d, 0xb0, 0x2e, 0x34,
	0x29, 0xd1, 0x67, 0xf4, 0x00, 0x96, 0x48, 0xc7, 0x30, 0x62, 0x2d, 0xc3, 0xec, 0xda, 0x12, 0x59,
	0x46, 0x97, 0xca, 0x4a, 0xbe, 0x0e, 0x6a, 0x40, 0xc6, 0x54, 0x5d, 0x4f, 0x39, 0xc4, 0xaa, 0xe3,
	0xf5, 0xb0, 0x3a, 0x67, 0x4b, 0xc0, 0x02, 0x2f, 0x4d, 0x54, 0x5f, 0x0d, 0x34, 0xd1, 0x4b, 0xb0,
	0xa1, 0xd1, 0x98, 0x0b, 0xcb, 0xb9, 0x72, 0x60, 0x9c, 0x60, 0x3d, 0x2b, 0xd2, 0x6c, 0xb2, 0xc6,
	0xb8, 0x53, 0x94, 0x87, 0x84, 0x47, 0x56, 0x40, 0x2b, 0x75, 0x78, 0x69, 0x2b, 0xd7, 0x58, 0x01,
	0x51, 0x0d, 0x7d, 0xe5, 0xbb, 0x90, 0xed, 0x9b, 0x76, 0x4f, 0x35, 0x95, 0x91, 0xa5, 0x61, 0xc7,
	0x53, 0x0d, 0xcb, 0x1b, 0x2b, 0xa6, 0x31, 0x30, 0x3c, 0xbf, 0x03, 0x98, 0x0b, 0x75, 0x83, 0x81,
	0xec, 0x85, 0x18, 0x4d, 0x02, 0x81, 0xde, 0x82, 0x1b, 0xb6, 0xef, 0x9f, 0xe1, 0x72, 0xdd, 0xac,
	0x70, 0x69, 0xaa, 0x7e, 0xca, 0x9b, 0x7d, 0x03, 0xc8, 0xbe, 0xc8, 0x70, 0x51, 0x1e, 0xd2, 0xef,
	0x38, 0x86, 0x87, 0x15, 0xcf, 0xb6, 0x15, 0xdb, 0xd4, 0xb3, 0x29, 0x7a, 0x68, 0xcb, 0x94, 0x28,
	0xdb, 0x76, 0xc7, 0xd4, 0xd1, 0x03, 0x00, 0xe2, 0x74, 0x34, 0xa4, 0xdd, 0xec, 0x32, 0xb5, 0x7b,
	0x59, 0xd6, 0x0d, 0x92, 0x23, 0x51, 0x20, 0xef, 0x2e, 0x7a, 0x0d, 0x44, 0xc3, 0x52, 0x0e, 0x4c,
	0xda, 0x1d, 0x51, 0x58, 0x37, 0xbb, 0x4a, 0x31, 0xfe, 0x67, 0x16, 0x06, 0x7e, 0x32, 0xc2, 0x96,
	0x86, 0xf5, 0xd7, 0x89, 0xa4, 0x8f, 0x96, 0x31, 0xac, 0x87, 0x54, 0x9f, 0x12, 0x5d, 0x64, 0xc3,
	0x8a, 0xd1, 0xb7, 0x6c, 0x87, 0xa4, 0x19, 0xfc, 0xc4, 0x1a, 0x0d, 0xdc, 0x2c, 0xa2, 0x88, 0x85,
	0xab, 0xdc, 0xbb, 0xce, 0x54, 0xba, 0xf8, 0x49, 0x7b, 0x34, 0xa0, 0xf5, 0x37, 0xec, 0x60, 0xcf,
	0xf1, 0x5c, 0x29, 0x63, 0x4c, 0xdf, 0x09, 0xfa, 0xb9, 0xcf, 0xc5, 0x98, 0xc8, 0x37, 0x78, 0x61,
	0x49, 0x4c, 0x34, 0x78, 0x21, 0x29, 0x42, 0x83, 0x17, 0xd2, 0x62, 0xa6, 0xc1, 0x0b, 0x19, 0x71,
	0x25, 0xff, 0x6b, 0x1e, 0x56, 0x23, 0x5e, 0x2f, 0x61, 0xcd, 0x76, 0xf4, 0x2f, 0x22, 0x04, 0xbf,
	0x3a, 0xe1, 0xf6, 0x1f, 0x67, 0xe0, 0x7d, 0x47, 0x58, 0x14, 0x63, 0x17, 0xdc, 0x21, 0x21, 0x0a,
	0x0d, 0x5e, 0x10, 0xc4, 0xe4, 0xd4, 0x35, 0x40, 0x5c, 0x6e, 0xf0, 0x42, 0x4a, 0x4c, 0x47, 0xdd,
	0xa4, 0xc1, 0x0b, 0x2b, 0xa2, 0xd8, 0xe0, 0x05, 0x51, 0x5c, 0xcd, 0x4f, 0x38, 0x58, 0x22, 0xbd,
	0x83, 0x45, 0x3e, 0x4f, 0x56, 0x5c, 0xc3, 0xea, 0x9b, 0x58, 0x39, 0xc2, 0xe3, 0xb0, 0x21, 0x5a,
	0xde, 0x7e, 0x7e, 0xc6, 0xd9, 0x30, 0x9d, 0x42, 0x97, 0x2a, 0x3c, 0xc2, 0x63, 0x7a, 0xde, 0xa1,
	0xdb, 0xa4, 0xdd, 0x28, 0x03, 0x7d, 0x0b, 0x62, 0xde, 0x49, 0xd0, 0x31, 0xcd, 0xe5, 0x81, 0xec,
	0xb0, 0x89, 0xd6, 0xe6, 0x03, 0x48, 0x9f, 0x33, 0x73, 0xc5, 0xe8, 0x25, 0x3a, 0x4e, 0x69, 0xf0,
	0x02, 0x2f, 0xc6, 0xf3, 0x7f, 0xe0, 0x60, 0xa5, 0x69, 0x6b, 0x47, 0x25, 0xed, 0xc9, 0xc8, 0x70,
	0x0d, 0x5a, 0x94, 0xbe, 0x09, 0x7c, 0x64, 0x7b, 0x97, 0xba, 0x4f, 0x24, 0x0a, 0xdc, 0x67, 0xdd,
	0x05, 0x92, 0x00, 0xf4, 0x91, 0xa3, 0xf6, 0x0c, 0xd3, 0xf0, 0xd8, 0xda, 0x33, 0xdb, 0xdb, 0x97,
	0x7c, 0x99, 0x45, 0x26, 0x66, 0x05, 0xe2, 0xbc, 0x85, 0xea, 0x54, 0x53, 0x8a, 0xa0, 0xe4, 0x7f,
	0xb5, 0x08, 0x40, 0xf6, 0xc6, 0x3e, 0x33, 0xfe, 0x2d, 0xdb, 0x0a, 0x33, 0x43, 0xec, 0x73, 0x64,
	0x86, 0x19, 0xc1, 0xc3, 0xff, 0x2b, 0x83, 0x27, 0xff, 0x63, 0x0e, 0x32, 0xe7, 0xc3, 0xfa, 0xaa,
	0x01, 0xd8, 0xdb, 0x20, 0xb8, 0xbe, 0xb0, 0x3f, 0x53, 0xfa, 0xce, 0xdc, 0x1d, 0xd3, 0xc5, 0xa1,
	0x23, 0x39, 0xbc, 0x2e, 0x7e, 0x22, 0x4d, 0x11, 0xfd, 0x86, 0xe9, 0xa7, 0x71, 0x88, 0x37, 0xb1,
	0xea, 0x62, 0x34, 0x86, 0x38, 0x9b, 0x4f, 0x70, 0x5f, 0x5e, 0xff, 0xc6, 0x2c, 0xa2, 0x6f, 0x03,
	0xe0, 0x93, 0xa1, 0xe1, 0xa8, 0xe4, 0x8e, 0xe6, 0xea, 0x1f, 0xa5, 0x88, 0x02, 0xaa, 0x42, 0x22,
	0xf8, 0x24, 0x8f, 0x5d, 0xfb, 0x93, 0x3c, 0x50, 0x45, 0x7b, 0x10, 0xf9, 0xa0, 0x65, 0xa3, 0x1a,
	0xf2, 0xd7, 0x35, 0x82, 0xb9, 0xd0, 0x3f, 0x59, 0xd1, 0x7a, 0xa8, 0x4d, 0xe7, 0x2d, 0x5d, 0xaa,
	0x8b, 0x7e, 0xc4, 0xc1, 0xf2, 0xd0, 0xb1, 0x87, 0x6c, 0xe4, 0xe2, 0xce, 0x57, 0x7b, 0xda, 0xa7,
	0x93, 0x1c, 0xec, 0xfa, 0x5a, 0x72, 0xf7, 0x99, 0xcf, 0x19, 0x82, 0x15, 0xc8, 0x2e, 0x5a, 0x83,
	0x38, 0x1e, 0xda, 0xda, 0x21, 0x9d, 0xfa, 0xc4, 0x24, 0xf6, 0x82, 0x5e, 0x88, 0xf8, 0x1a, 0xe9,
	0xda, 0x62, 0xe5, 0xd5, 0xb3, 0x49, 0x2e, 0x4d, 0x5d, 0x23, 0xf0, 0xd8, 0xd0, 0x79, 0x90, 0x04,
	0xa2, 0x1a, 0x66, 0x34, 0x36, 0x66, 0x11, 0x68, 0x04, 0xce, 0xca, 0xd6, 0x14, 0x25, 0x92, 0x01,
	0xe9, 0xa4, 0x65, 0x45, 0x3d, 0x4f, 0x08, 0xdb, 0x8c, 0xfc, 0x9f, 0x38, 0xc8, 0x94, 0x7a, 0xb6,
	0xe3, 0x91, 0x84, 0x51, 0xb3, 0x3c, 0x67, 0x7c, 0x55, 0x98, 0x3c, 0xfb, 0x44, 0x1a, 0xa9, 0x20,
	0x0c, 0x1d, 0xc3, 0x76, 0x82, 0xdc, 0x18, 0x2f, 0xd7, 0xce, 0x26, 0xb9, 0xd2, 0xe7, 0x8e, 0xb4,
	0x5d, 0x1f, 0x4c, 0x9a, 0xc2, 0xde, 0x17, 0xc8, 0xce, 0x3e, 0x23, 0xbb, 0xfb, 0xfb, 0x22, 0xac,
	0x36, 0xb1, 0x7a, 0x20, 0x9f, 0x58, 0x75, 0x6b, 0x38, 0x22, 0x8e, 0xe2, 0x61, 0xf4, 0x32, 0x4b,
	0x83, 0x2c, 0xf8, 0xb6, 0xae, 0x4e, 0x63, 0xd1, 0x0c, 0xf8, 0x3c, 0xac, 0x38, 0xf8, 0xc0, 0xc1,
	0xee, 0xa1, 0x62, 0x58, 0xc7, 0xaa, 0x69, 0xe8, 0xf4, 0xfe, 0x04, 0x29, 0xe3, 0x93, 0xeb, 0x8c,
	0x3a, 0xb3, 0xf9, 0x10, 0x9e, 0xad, 0xf9, 0xd8, 0x86, 0x75, 0xd7, 0xc3, 0xc3, 0xa1, 0x61, 0xf5,
	0x95, 0x01, 0xf9, 0x5e, 0xc4, 0x96, 0xda, 0x33, 0xb1, 0x9e, 0x4d, 0xd2, 0x15, 0xdc, 0x08, 0x98,
	0x2d, 0x5b, 0xc7, 0x35, 0xc6, 0x42, 0x3d, 0x48, 0xb1, 0x21, 0x21, 0x7e, 0xa2, 0x58, 0xa3, 0x41,
	0x16, 0xbe, 0xa0, 0xc4, 0x06, 0x04, 0x95, 0xe5, 0xdd, 0x0b, 0xdd, 0x09, 0x2f, 0xc6, 0x1b, 0xbc,
	0x10, 0x17, 0x97, 0x58, 0xa7, 0x92, 0x7f, 0x3f, 0x3c, 0xff, 0x87, 0x86, 0xa5, 0x9a, 0xcf, 0x76,
	0xfe, 0xaf, 0x40, 0x36, 0x3a, 0x76, 0xb4, 0x07, 0x03, 0xd5, 0x22, 0xff, 0x47, 0x96, 0xc7, 0x5c,
	0x49, 0x8a, 0x8c, 0x25, 0x2b, 0x8c, 0x5d, 0x21, 0x5c, 0x54, 0x86, 0x74, 0x70, 0x73, 0xac, 0x9d,
	0xe4, 0xe7, 0x69, 0x27, 0x53, 0xbe, 0x0e, 0xeb, 0x28, 0xe7, 0xbd, 0xfd, 0xe9, 0x91, 0x4c, 0x8f,
	0x81, 0xb5, 0x6a, 0xf9, 0xbf, 0x71, 0xb0, 0x52, 0x31, 0x0d, 0x6c, 0x79, 0xb4, 0x92, 0xd5, 0xad,
	0x03, 0x1b, 0xbd, 0x0a, 0xeb, 0xfa, 0x34, 0x4d, 0x2a, 0x7d, 0x6c, 0x61, 0x3f, 0x33, 0x73, 0x34,
	0x31, 0xdc, 0x38, 0x9b, 0xe4, 0x56, 0xa8, 0xf4, 0xce, 0x94, 0x25, 0xad, 0x85, 0x1a, 0x21, 0x15,
	0xbd, 0x02, 0x19, 0x93, 0xc4, 0xbe, 0x72, 0xae, 0x8e, 0xcd, 0xcc, 0x2d, 0x69, 0x33, 0xfa, 0x8a,
	0x30, 0xdc, 0xbc, 0x38, 0xa6, 0x56, 0x86, 0xb6, 0x69, 0x68, 0x41, 0xf3, 0xf2, 0xc2, 0x65, 0x63,
	0xc5, 0x0b, 0xb3, 0xe9, 0x5d, 0xaa, 0x24, 0xad, 0x6b, 0xb3, 0xc8, 0xf9, 0xbf, 0x72, 0x90, 0x0c,
	0x37, 0xfe, 0xc0, 0x1f, 0x5c, 0x5e, 0xf7, 0xe7, 0x09, 0x36, 0xbe, 0x7c, 0x09, 0xe2, 0x74, 0x0f,
	0x57, 0xfc, 0x5e, 0x45, 0xb7, 0x1c, 0xfc, 0x5e, 0x45, 0x85, 0xbf, 0xa4, 0x8d, 0xb2, 0x79, 0xe4,
	0xbd, 0x8f, 0x39, 0x48, 0xd2, 0xdf, 0xcc, 0xe8, 0x54, 0x7b, 0x19, 0x12, 0x7b, 0xed, 0x47, 0xed,
	0xce, 0xeb, 0x6d, 0x71, 0x01, 0x25, 0x20, 0x56, 0x6f, 0xcb, 0x22, 0x87, 0x92, 0x10, 0x7f, 0xd8,
	0xec, 0x94, 0x64, 0x71, 0x91, 0x3c, 0x96, 0xf7, 0xe5, 0x5a, 0x57, 0x8c, 0xa1, 0x1b, 0xb0, 0x52,
	0xad, 0x35, 0xeb, 0xad, 0xba, 0x5c, 0xab, 0x2a, 0x8c, 0x28, 0x20, 0x01, 0x78, 0xb9, 0xde, 0xaa,
	0x89, 0x3c, 0x81, 0xaa, 0xd6, 0x2a, 0xf5, 0x56, 0xa9, 0x29, 0xc6, 0xd1, 0x3a, 0xac, 0x86, 0xb2,
	0x01, 0x39, 0x89, 0x52, 0x20, 0x54, 0xf7, 0xa4, 0x92, 0x5c, 0xef, 0xb4, 0xc5, 0x25, 0x04, 0xb0,
	0x44, 0x74, 0xe5, 0x37, 0xc5, 0x14, 0xb1, 0xbd, 0x53, 0xeb, 0x88, 0x69, 0x6a, 0xb0, 0xf3, 0xc6,
	0x76, 0x55, 0xcc, 0x90, 0x47, 0x79, 0x6f, 0xb7, 0x59, 0x13, 0x81, 0x28, 0x96, 0xeb, 0x72, 0x49,
	0x92, 0x4a, 0xfb, 0xe2, 0x32, 0xca, 0x00, 0x10, 0xc5, 0x6e, 0x4d, 0xaa, 0xd7, 0xba, 0xa2, 0x9e,
	0x27, 0x1f, 0x1e, 0x89, 0x7b, 0x1a, 0xac, 0x3e, 0x35, 0xcc, 0x47, 0x69, 0x48, 0x96, 0xaa, 0x55,
	0xe5, 0x71, 0x47, 0xae, 0x49, 0xe2, 0x02, 0x12, 0x21, 0x25, 0xd5, 0x5a, 0x9d, 0xc7, 0x35, 0x9f,
	0xc2, 0xa1, 0x55, 0x48, 0x13, 0x81, 0x76, 0xa7, 0xed, 0x93, 0x16, 0xd1, 0x1a, 0x88, 0xbe, 0x50,
	0x48, 0x8d, 0x6d, 0xf2, 0xef, 0xfd, 0x7c, 0x6b, 0xe1, 0x5e, 0xe7, 0xdc, 0xf7, 0x2d, 0x6b, 0x26,
	0xc9, 0xd6, 0x77, 0x6b, 0xed, 0x6a, 0xbd, 0xbd, 0x23, 0x2e, 0x90, 0x97, 0xae, 0x5c, 0xda, 0x21,
	0x2f, 0x31, 0x62, 0xbe, 0xd2, 0x69, 0xb5, 0xea, 0xb2, 0x5c, 0xab, 0x8a, 0x1c, 0xe1, 0x95, 0xca,
	0x1d, 0x89, 0xbc, 0x2c, 0xfa, 0x80, 0x65, 0x58, 0x9b, 0x55, 0x1b, 0xd1, 0x0a, 0x2c, 0xef, 0x59,
	0xee, 0x10, 0x6b, 0x74, 0x10, 0x28, 0x2e, 0x90, 0x23, 0xa0, 0x96, 0x0f, 0xb0, 0xc3, 0x90, 0x24,
	0x12, 0x28, 0xae, 0x27, 0x2e, 0xde, 0x7b, 0x17, 0x36, 0x2f, 0x77, 0x07, 0xb4, 0x09, 0x1b, 0xcd,
	0xd2, 0x8e, 0x52, 0xde, 0x57, 0x2a, 0xcd, 0xbd, 0xae, 0x5c, 0x93, 0x94, 0x6e, 0x4d, 0x96, 0xd9,
	0x62, 0x6f, 0xc1, 0x7a, 0xb3, 0x56, 0xaa, 0x2a, 0x0f, 0x3b, 0x92, 0xb2, 0xd3, 0xec, 0x94, 0x4b,
	0x4d, 0x45, 0xaa, 0x95, 0xaa, 0x5d, 0x91, 0x43, 0x39, 0xb8, 0xdd, 0x2a, 0xbd, 0xa1, 0x54, 0x9a,
	0x9d, 0x6e, 0xad, 0xaa, 0xd0, 0xf3, 0x96, 0x4b, 0xad, 0x5d, 0x65, 0xb7, 0xd3, 0xac, 0x57, 0xf6,
	0x83, 0xf5, 0x97, 0xbf, 0xf6, 0xe1, 0x5f, 0xb6, 0x16, 0x3e, 0x3c, 0xdd, 0xe2, 0x3e, 0x3a, 0xdd,
	0xe2, 0x3e, 0x39, 0xdd, 0xe2, 0xfe, 0x7c, 0xba, 0xc5, 0xfd, 0xe4, 0xd3, 0xad, 0x85, 0x8f, 0x3e,
	0xdd, 0x5a, 0xf8, 0xe4, 0xd3, 0xad, 0x85, 0x37, 0x13, 0xbe, 0xcb, 0xf6, 0x96, 0xe8, 0xef, 0xd7,
	0x2f, 0xfe, 0x23, 0x00, 0x00, 0xff, 0xff, 0x24, 0xe6, 0x58, 0xa6, 0xc3, 0x1f, 0x00, 0x00,
}

func (this *SplitTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SplitTrigger)
	if !ok {
		that2, ok := that.(SplitTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	return true
}
func (this *MergeTrigger) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MergeTrigger)
	if !ok {
		that2, ok := that.(MergeTrigger)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LeftDesc.Equal(&that1.LeftDesc) {
		return false
	}
	if !this.RightDesc.Equal(&that1.RightDesc) {
		return false
	}
	if !this.RightMVCCStats.Equal(&that1.RightMVCCStats) {
		return false
	}
	if !this.FreezeStart.Equal(&that1.FreezeStart) {
		return false
	}
	if !this.RightClosedTimestamp.Equal(&that1.RightClosedTimestamp) {
		return false
	}
	if !this.RightReadSummary.Equal(that1.RightReadSummary) {
		return false
	}
	return true
}
func (this *AbortSpanEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AbortSpanEntry)
	if !ok {
		that2, ok := that.(AbortSpanEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintData(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintData(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreIdent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreIdent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreIdent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ClusterID.Size()
		i -= size
		if _, err := m.ClusterID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SplitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RightReadSummary != nil {
		{
			size, err := m.RightReadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.RightClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.FreezeStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.RightMVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChangeReplicasTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeReplicasTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeReplicasTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalRemovedReplicas) > 0 {
		for iNdEx := len(m.InternalRemovedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalRemovedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InternalAddedReplicas) > 0 {
		for iNdEx := len(m.InternalAddedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalAddedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeprecatedNextReplicaID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DeprecatedNextReplicaID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeprecatedUpdatedReplicas) > 0 {
		for iNdEx := len(m.DeprecatedUpdatedReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeprecatedUpdatedReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.DeprecatedReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.DeprecatedChangeType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DeprecatedChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModifiedSpanTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifiedSpanTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifiedSpanTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeLivenessSpan != nil {
		{
			size, err := m.NodeLivenessSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SystemConfigSpan {
		i--
		if m.SystemConfigSpan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StickyBitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickyBitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StickyBitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StickyBit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InternalCommitTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalCommitTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InternalCommitTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StickyBitTrigger != nil {
		{
			size, err := m.StickyBitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ModifiedSpanTrigger != nil {
		{
			size, err := m.ModifiedSpanTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ChangeReplicasTrigger != nil {
		{
			size, err := m.ChangeReplicasTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MergeTrigger != nil {
		{
			size, err := m.MergeTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SplitTrigger != nil {
		{
			size, err := m.SplitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObservedTimestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObservedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObservedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NodeID != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.CommitTimestampFixed {
		i--
		if m.CommitTimestampFixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size, err := m.ReadTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if m.WriteTooOld {
		i--
		if m.WriteTooOld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ObservedTimestamps) > 0 {
		for iNdEx := len(m.ObservedTimestamps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObservedTimestamps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.GlobalUncertaintyLimit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.LastHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransactionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.LastHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Intent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Intent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Intent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Intent_SingleKeySpan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Intent_SingleKeySpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Intent_SingleKeySpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Intent_SingleKeySpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *LockAcquisition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockAcquisition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockAcquisition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Durability != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Durability))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Status != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SequencedWrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequencedWrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequencedWrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AcquisitionType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AcquisitionType))
		i--
		dAtA[i] = 0x40
	}
	if m.Sequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	if m.ProposedTS != nil {
		{
			size, err := m.ProposedTS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeprecatedStartStasis != nil {
		{
			size, err := m.DeprecatedStartStasis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AbortSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbortSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AbortSpanEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintData(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeafTxnInputState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafTxnInputState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafTxnInputState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadSeqNum != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReadSeqNum))
		i--
		dAtA[i] = 0x50
	}
	if m.SteppingModeEnabled {
		i--
		if m.SteppingModeEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RefreshInvalid {
		i--
		if m.RefreshInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeafTxnFinalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafTxnFinalState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeafTxnFinalState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefreshInvalid {
		i--
		if m.RefreshInvalid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RefreshSpans) > 0 {
		for iNdEx := len(m.RefreshSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RefreshSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DeprecatedCommandCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DeprecatedCommandCount))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClientRangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientRangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientRangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClosedTimestampPolicy != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClosedTimestampPolicy))
		i--
		dAtA[i] = 0x18
	}
	if m.LeaseSequence != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LeaseSequence))
		i--
		dAtA[i] = 0x10
	}
	if m.DescriptorGeneration != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DescriptorGeneration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClosedTimestampPolicy != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClosedTimestampPolicy))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	offset -= sovData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedSpan(r randyData, easy bool) *Span {
	this := &Span{}
	v1 := r.Intn(100)
	this.Key = make(Key, v1)
	for i := 0; i < v1; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v2 := r.Intn(100)
	this.EndKey = make(Key, v2)
	for i := 0; i < v2; i++ {
		this.EndKey[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedObservedTimestamp(r randyData, easy bool) *ObservedTimestamp {
	this := &ObservedTimestamp{}
	this.NodeID = NodeID(r.Int31())
	if r.Intn(2) == 0 {
		this.NodeID *= -1
	}
	v3 := github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	this.Timestamp = *v3
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransaction(r randyData, easy bool) *Transaction {
	this := &Transaction{}
	v4 := enginepb.NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v4
	this.Name = string(randStringData(r))
	this.Status = TransactionStatus([]int32{0, 3, 1, 2}[r.Intn(4)])
	v5 := hlc.NewPopulatedTimestamp(r, easy)
	this.LastHeartbeat = *v5
	v6 := hlc.NewPopulatedTimestamp(r, easy)
	this.GlobalUncertaintyLimit = *v6
	if r.Intn(5) != 0 {
		v7 := r.Intn(5)
		this.ObservedTimestamps = make([]ObservedTimestamp, v7)
		for i := 0; i < v7; i++ {
			v8 := NewPopulatedObservedTimestamp(r, easy)
			this.ObservedTimestamps[i] = *v8
		}
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(5)
		this.LockSpans = make([]Span, v9)
		for i := 0; i < v9; i++ {
			v10 := NewPopulatedSpan(r, easy)
			this.LockSpans[i] = *v10
		}
	}
	this.WriteTooOld = bool(bool(r.Intn(2) == 0))
	v11 := hlc.NewPopulatedTimestamp(r, easy)
	this.ReadTimestamp = *v11
	this.CommitTimestampFixed = bool(bool(r.Intn(2) == 0))
	if r.Intn(5) != 0 {
		v12 := r.Intn(5)
		this.InFlightWrites = make([]SequencedWrite, v12)
		for i := 0; i < v12; i++ {
			v13 := NewPopulatedSequencedWrite(r, easy)
			this.InFlightWrites[i] = *v13
		}
	}
	if r.Intn(5) != 0 {
		v14 := r.Intn(5)
		this.IgnoredSeqNums = make([]enginepb.IgnoredSeqNumRange, v14)
		for i := 0; i < v14; i++ {
			v15 := enginepb.NewPopulatedIgnoredSeqNumRange(r, easy)
			this.IgnoredSeqNums[i] = *v15
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransactionRecord(r randyData, easy bool) *TransactionRecord {
	this := &TransactionRecord{}
	v16 := enginepb.NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v16
	this.Status = TransactionStatus([]int32{0, 3, 1, 2}[r.Intn(4)])
	v17 := hlc.NewPopulatedTimestamp(r, easy)
	this.LastHeartbeat = *v17
	if r.Intn(5) != 0 {
		v18 := r.Intn(5)
		this.LockSpans = make([]Span, v18)
		for i := 0; i < v18; i++ {
			v19 := NewPopulatedSpan(r, easy)
			this.LockSpans[i] = *v19
		}
	}
	if r.Intn(5) != 0 {
		v20 := r.Intn(5)
		this.InFlightWrites = make([]SequencedWrite, v20)
		for i := 0; i < v20; i++ {
			v21 := NewPopulatedSequencedWrite(r, easy)
			this.InFlightWrites[i] = *v21
		}
	}
	if r.Intn(5) != 0 {
		v22 := r.Intn(5)
		this.IgnoredSeqNums = make([]enginepb.IgnoredSeqNumRange, v22)
		for i := 0; i < v22; i++ {
			v23 := enginepb.NewPopulatedIgnoredSeqNumRange(r, easy)
			this.IgnoredSeqNums[i] = *v23
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSequencedWrite(r randyData, easy bool) *SequencedWrite {
	this := &SequencedWrite{}
	v24 := r.Intn(100)
	this.Key = make(Key, v24)
	for i := 0; i < v24; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	this.Sequence = github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(r.Int31())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLease(r randyData, easy bool) *Lease {
	this := &Lease{}
	v25 := github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	this.Start = *v25
	if r.Intn(5) != 0 {
		this.Expiration = hlc.NewPopulatedTimestamp(r, easy)
	}
	v26 := NewPopulatedReplicaDescriptor(r, easy)
	this.Replica = *v26
	if r.Intn(5) != 0 {
		this.DeprecatedStartStasis = hlc.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(5) != 0 {
		this.ProposedTS = github_com_cockroachdb_cockroach_pkg_util_hlc.NewPopulatedClockTimestamp(r, easy)
	}
	this.Epoch = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Epoch *= -1
	}
	this.Sequence = LeaseSequence(r.Int63())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	this.AcquisitionType = LeaseAcquisitionType([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAbortSpanEntry(r randyData, easy bool) *AbortSpanEntry {
	this := &AbortSpanEntry{}
	v27 := r.Intn(100)
	this.Key = make(Key, v27)
	for i := 0; i < v27; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v28 := hlc.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v28
	this.Priority = github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyData interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneData(r randyData) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringData(r randyData) string {
	v29 := r.Intn(100)
	tmps := make([]rune, v29)
	for i := 0; i < v29; i++ {
		tmps[i] = randUTF8RuneData(r)
	}
	return string(tmps)
}
func randUnrecognizedData(r randyData, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldData(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldData(dAtA []byte, r randyData, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		v30 := r.Int63()
		if r.Intn(2) == 0 {
			v30 *= -1
		}
		dAtA = encodeVarintPopulateData(dAtA, uint64(v30))
	case 1:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateData(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateData(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateData(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *StoreIdent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterID.Size()
	n += 1 + l + sovData(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovData(uint64(m.StoreID))
	}
	return n
}

func (m *SplitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *MergeTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LeftDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightMVCCStats.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.FreezeStart.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.RightClosedTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.RightReadSummary != nil {
		l = m.RightReadSummary.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ChangeReplicasTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeprecatedChangeType != 0 {
		n += 1 + sovData(uint64(m.DeprecatedChangeType))
	}
	l = m.DeprecatedReplica.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.DeprecatedUpdatedReplicas) > 0 {
		for _, e := range m.DeprecatedUpdatedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.DeprecatedNextReplicaID != 0 {
		n += 1 + sovData(uint64(m.DeprecatedNextReplicaID))
	}
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.InternalAddedReplicas) > 0 {
		for _, e := range m.InternalAddedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.InternalRemovedReplicas) > 0 {
		for _, e := range m.InternalRemovedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *ModifiedSpanTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemConfigSpan {
		n += 2
	}
	if m.NodeLivenessSpan != nil {
		l = m.NodeLivenessSpan.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *StickyBitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StickyBit.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *InternalCommitTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SplitTrigger != nil {
		l = m.SplitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MergeTrigger != nil {
		l = m.MergeTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChangeReplicasTrigger != nil {
		l = m.ChangeReplicasTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ModifiedSpanTrigger != nil {
		l = m.ModifiedSpanTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.StickyBitTrigger != nil {
		l = m.StickyBitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ObservedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovData(uint64(m.NodeID))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	l = m.LastHeartbeat.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.GlobalUncertaintyLimit.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.ObservedTimestamps) > 0 {
		for _, e := range m.ObservedTimestamps {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.WriteTooOld {
		n += 2
	}
	l = m.ReadTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.CommitTimestampFixed {
		n += 3
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *TransactionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	l = m.LastHeartbeat.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *Intent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Intent_SingleKeySpan.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *Intent_SingleKeySpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *LockAcquisition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Durability != 0 {
		n += 1 + sovData(uint64(m.Durability))
	}
	return n
}

func (m *LockUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Status != 0 {
		n += 1 + sovData(uint64(m.Status))
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *SequencedWrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovData(uint64(m.Sequence))
	}
	return n
}

func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	if m.DeprecatedStartStasis != nil {
		l = m.DeprecatedStartStasis.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ProposedTS != nil {
		l = m.ProposedTS.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovData(uint64(m.Epoch))
	}
	if m.Sequence != 0 {
		n += 1 + sovData(uint64(m.Sequence))
	}
	if m.AcquisitionType != 0 {
		n += 1 + sovData(uint64(m.AcquisitionType))
	}
	return n
}

func (m *AbortSpanEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovData(uint64(m.Priority))
	}
	return n
}

func (m *LeafTxnInputState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.RefreshInvalid {
		n += 2
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.SteppingModeEnabled {
		n += 2
	}
	if m.ReadSeqNum != 0 {
		n += 1 + sovData(uint64(m.ReadSeqNum))
	}
	return n
}

func (m *LeafTxnFinalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	if m.DeprecatedCommandCount != 0 {
		n += 1 + sovData(uint64(m.DeprecatedCommandCount))
	}
	if len(m.RefreshSpans) > 0 {
		for _, e := range m.RefreshSpans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.RefreshInvalid {
		n += 2
	}
	return n
}

func (m *ClientRangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorGeneration != 0 {
		n += 1 + sovData(uint64(m.DescriptorGeneration))
	}
	if m.LeaseSequence != 0 {
		n += 1 + sovData(uint64(m.LeaseSequence))
	}
	if m.ClosedTimestampPolicy != 0 {
		n += 1 + sovData(uint64(m.ClosedTimestampPolicy))
	}
	return n
}

func (m *RangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovData(uint64(l))
	if m.ClosedTimestampPolicy != 0 {
		n += 1 + sovData(uint64(m.ClosedTimestampPolicy))
	}
	return n
}

func sovData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreIdent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightMVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightMVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreezeStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreezeStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightReadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightReadSummary == nil {
				m.RightReadSummary = &rspb.ReadSummary{}
			}
			if err := m.RightReadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicasTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedChangeType", wireType)
			}
			m.DeprecatedChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedChangeType |= ReplicaChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeprecatedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedUpdatedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedUpdatedReplicas = append(m.DeprecatedUpdatedReplicas, ReplicaDescriptor{})
			if err := m.DeprecatedUpdatedReplicas[len(m.DeprecatedUpdatedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedNextReplicaID", wireType)
			}
			m.DeprecatedNextReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedNextReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &RangeDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalAddedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalAddedReplicas = append(m.InternalAddedReplicas, ReplicaDescriptor{})
			if err := m.InternalAddedReplicas[len(m.InternalAddedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalRemovedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalRemovedReplicas = append(m.InternalRemovedReplicas, ReplicaDescriptor{})
			if err := m.InternalRemovedReplicas[len(m.InternalRemovedReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifiedSpanTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemConfigSpan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemConfigSpan = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLivenessSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeLivenessSpan == nil {
				m.NodeLivenessSpan = &Span{}
			}
			if err := m.NodeLivenessSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickyBitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickyBitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickyBitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickyBit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StickyBit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalCommitTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalCommitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalCommitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitTrigger == nil {
				m.SplitTrigger = &SplitTrigger{}
			}
			if err := m.SplitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTrigger == nil {
				m.MergeTrigger = &MergeTrigger{}
			}
			if err := m.MergeTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicasTrigger == nil {
				m.ChangeReplicasTrigger = &ChangeReplicasTrigger{}
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedSpanTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedSpanTrigger == nil {
				m.ModifiedSpanTrigger = &ModifiedSpanTrigger{}
			}
			if err := m.ModifiedSpanTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickyBitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickyBitTrigger == nil {
				m.StickyBitTrigger = &StickyBitTrigger{}
			}
			if err := m.StickyBitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObservedTimestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObservedTimestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObservedTimestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalUncertaintyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalUncertaintyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedTimestamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedTimestamps = append(m.ObservedTimestamps, ObservedTimestamp{})
			if err := m.ObservedTimestamps[len(m.ObservedTimestamps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTooOld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteTooOld = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTimestampFixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommitTimestampFixed = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Intent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Intent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Intent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent_SingleKeySpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Intent_SingleKeySpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Intent_SingleKeySpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleKeySpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleKeySpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockAcquisition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockAcquisition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockAcquisition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durability", wireType)
			}
			m.Durability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Durability |= lock.Durability(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequencedWrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequencedWrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequencedWrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &hlc.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartStasis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedStartStasis == nil {
				m.DeprecatedStartStasis = &hlc.Timestamp{}
			}
			if err := m.DeprecatedStartStasis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposedTS == nil {
				m.ProposedTS = &github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp{}
			}
			if err := m.ProposedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcquisitionType", wireType)
			}
			m.AcquisitionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcquisitionType |= LeaseAcquisitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafTxnInputState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafTxnInputState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafTxnInputState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshInvalid = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteppingModeEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SteppingModeEnabled = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSeqNum", wireType)
			}
			m.ReadSeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSeqNum |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafTxnFinalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafTxnFinalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafTxnFinalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedCommandCount", wireType)
			}
			m.DeprecatedCommandCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedCommandCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshSpans = append(m.RefreshSpans, Span{})
			if err := m.RefreshSpans[len(m.RefreshSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshInvalid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshInvalid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorGeneration", wireType)
			}
			m.DescriptorGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorGeneration |= RangeGeneration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseSequence", wireType)
			}
			m.LeaseSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseSequence |= LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestampPolicy", wireType)
			}
			m.ClosedTimestampPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedTimestampPolicy |= RangeClosedTimestampPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestampPolicy", wireType)
			}
			m.ClosedTimestampPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedTimestampPolicy |= RangeClosedTimestampPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupData = fmt.Errorf("proto: unexpected end of group")
)
