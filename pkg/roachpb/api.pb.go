// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/api.proto

package roachpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	lock "github.com/cockroachdb/cockroach/pkg/kv/kvserver/concurrency/lock"
	rspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/readsummary/rspb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_storage_enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReadConsistencyType specifies what type of consistency is observed
// during read operations.
type ReadConsistencyType int32

const (
	// CONSISTENT reads are guaranteed to read committed data; the
	// mechanism relies on clocks to determine lease expirations.
	CONSISTENT ReadConsistencyType = 0
	// READ_UNCOMMITTED reads return both committed and uncommitted data.
	// The consistency type is similar to INCONSISTENT in that using it
	// can result in dirty reads. However, like the CONSISTENT type, it
	// requires the replica performing the read to hold a valid read lease,
	// meaning that it can't return arbitrarily stale data.
	READ_UNCOMMITTED ReadConsistencyType = 1
	// INCONSISTENT reads return the latest available, committed values.
	// They are more efficient, but may read stale values as pending
	// intents are ignored.
	INCONSISTENT ReadConsistencyType = 2
)

var ReadConsistencyType_name = map[int32]string{
	0: "CONSISTENT",
	1: "READ_UNCOMMITTED",
	2: "INCONSISTENT",
}

var ReadConsistencyType_value = map[string]int32{
	"CONSISTENT":       0,
	"READ_UNCOMMITTED": 1,
	"INCONSISTENT":     2,
}

func (x ReadConsistencyType) String() string {
	return proto.EnumName(ReadConsistencyType_name, int32(x))
}

func (ReadConsistencyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{0}
}

// ScanFormat is an enumeration of the available response formats for MVCCScan
// operations.
type ScanFormat int32

const (
	// The standard MVCCScan format: a slice of KeyValue messages.
	KEY_VALUES ScanFormat = 0
	// The batch_response format: a byte slice of alternating keys and values,
	// each prefixed by their length as a varint.
	BATCH_RESPONSE ScanFormat = 1
)

var ScanFormat_name = map[int32]string{
	0: "KEY_VALUES",
	1: "BATCH_RESPONSE",
}

var ScanFormat_value = map[string]int32{
	"KEY_VALUES":     0,
	"BATCH_RESPONSE": 1,
}

func (x ScanFormat) String() string {
	return proto.EnumName(ScanFormat_name, int32(x))
}

func (ScanFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{1}
}

type ChecksumMode int32

const (
	// CHECK_VIA_QUEUE is set for requests made from the consistency queue. In
	// this mode, a full check is carried out, and depending on the result a
	// recursive consistency check is triggered:
	//
	// 1. no inconsistency found: if recomputed stats don't match persisted stats,
	//    trigger a RecomputeStatsRequest.
	// 2. inconsistency found: if a diff is available, print it and trigger fatal
	//    error. If no diff found, trigger recursive check with diff requested
	//    (which then triggers fatal error).
	//
	// TODO(tbg): these semantics are an artifact of how consistency checks were
	// first implemented. The extra behavior here should move to the consistency
	// check queue instead and this option dropped from the enum.
	ChecksumMode_CHECK_VIA_QUEUE ChecksumMode = 0
	// CHECK_FULL recomputes the hash of the replicate data in all replicas and
	// uses this to determine whether there is an inconsistency.
	ChecksumMode_CHECK_FULL ChecksumMode = 1
	// CHECK_STATS only hashes the persisted lease applied state (which notably
	// includes the persisted MVCCStats) only. This catches a large class of
	// replica inconsistencies observed in the wild (where replicas apply a
	// nonidentical log of commands, and as a result almost always have
	// divergent stats), while doing work independent of the size of the data
	// contained in the replicas.
	ChecksumMode_CHECK_STATS ChecksumMode = 2
)

var ChecksumMode_name = map[int32]string{
	0: "CHECK_VIA_QUEUE",
	1: "CHECK_FULL",
	2: "CHECK_STATS",
}

var ChecksumMode_value = map[string]int32{
	"CHECK_VIA_QUEUE": 0,
	"CHECK_FULL":      1,
	"CHECK_STATS":     2,
}

func (x ChecksumMode) String() string {
	return proto.EnumName(ChecksumMode_name, int32(x))
}

func (ChecksumMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{2}
}

// PushTxnType determines what action to take when pushing a transaction.
type PushTxnType int32

const (
	// Push the timestamp forward if possible to accommodate a concurrent reader.
	PUSH_TIMESTAMP PushTxnType = 0
	// Abort the transaction if possible to accommodate a concurrent writer.
	PUSH_ABORT PushTxnType = 1
	// Abort the transaction if it's abandoned, but don't attempt to mutate it
	// otherwise.
	PUSH_TOUCH PushTxnType = 2
)

var PushTxnType_name = map[int32]string{
	0: "PUSH_TIMESTAMP",
	1: "PUSH_ABORT",
	2: "PUSH_TOUCH",
}

var PushTxnType_value = map[string]int32{
	"PUSH_TIMESTAMP": 0,
	"PUSH_ABORT":     1,
	"PUSH_TOUCH":     2,
}

func (x PushTxnType) String() string {
	return proto.EnumName(PushTxnType_name, int32(x))
}

func (PushTxnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{3}
}

type ExternalStorageProvider int32

const (
	ExternalStorageProvider_Unknown   ExternalStorageProvider = 0
	ExternalStorageProvider_nodelocal ExternalStorageProvider = 1
	ExternalStorageProvider_http      ExternalStorageProvider = 2
	ExternalStorageProvider_s3        ExternalStorageProvider = 3
	ExternalStorageProvider_gs        ExternalStorageProvider = 4
	ExternalStorageProvider_azure     ExternalStorageProvider = 5
	ExternalStorageProvider_userfile  ExternalStorageProvider = 7
	ExternalStorageProvider_null      ExternalStorageProvider = 8
)

var ExternalStorageProvider_name = map[int32]string{
	0: "Unknown",
	1: "nodelocal",
	2: "http",
	3: "s3",
	4: "gs",
	5: "azure",
	7: "userfile",
	8: "null",
}

var ExternalStorageProvider_value = map[string]int32{
	"Unknown":   0,
	"nodelocal": 1,
	"http":      2,
	"s3":        3,
	"gs":        4,
	"azure":     5,
	"userfile":  7,
	"null":      8,
}

func (x ExternalStorageProvider) String() string {
	return proto.EnumName(ExternalStorageProvider_name, int32(x))
}

func (ExternalStorageProvider) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{4}
}

type MVCCFilter int32

const (
	MVCCFilter_Latest MVCCFilter = 0
	MVCCFilter_All    MVCCFilter = 1
)

var MVCCFilter_name = map[int32]string{
	0: "Latest",
	1: "All",
}

var MVCCFilter_value = map[string]int32{
	"Latest": 0,
	"All":    1,
}

func (x MVCCFilter) String() string {
	return proto.EnumName(MVCCFilter_name, int32(x))
}

func (MVCCFilter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{5}
}

type ResponseHeader_ResumeReason int32

const (
	// Zero value; no resume.
	RESUME_UNKNOWN ResponseHeader_ResumeReason = 0
	// The spanning operation didn't finish because the key limit was
	// exceeded.
	RESUME_KEY_LIMIT ResponseHeader_ResumeReason = 1
)

var ResponseHeader_ResumeReason_name = map[int32]string{
	0: "RESUME_UNKNOWN",
	1: "RESUME_KEY_LIMIT",
}

var ResponseHeader_ResumeReason_value = map[string]int32{
	"RESUME_UNKNOWN":   0,
	"RESUME_KEY_LIMIT": 1,
}

func (x ResponseHeader_ResumeReason) String() string {
	return proto.EnumName(ResponseHeader_ResumeReason_name, int32(x))
}

func (ResponseHeader_ResumeReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{1, 0}
}

type CheckConsistencyResponse_Status int32

const (
	// No inconsistency was detected, but not all replicas returned a checksum.
	CheckConsistencyResponse_RANGE_INDETERMINATE CheckConsistencyResponse_Status = 0
	// A definite inconsistency was detected.
	CheckConsistencyResponse_RANGE_INCONSISTENT CheckConsistencyResponse_Status = 1
	// All replicas of the range agreed on the checksum.
	CheckConsistencyResponse_RANGE_CONSISTENT CheckConsistencyResponse_Status = 2
	// Like RANGE_CONSISTENT, but the recomputed stats disagreed with the
	// persisted stats. The persisted stats indicates estimates, so this is
	// expected.
	CheckConsistencyResponse_RANGE_CONSISTENT_STATS_ESTIMATED CheckConsistencyResponse_Status = 3
	// Like RANGE_CONSISTENT_STATS_ESTIMATED, but the mismatch occurred with
	// persisted stats that claimed to be accurate. This is unexpected and
	// likely indicates a bug in our logic to incrementally update the stats
	// as commands are evaluated and applied.
	CheckConsistencyResponse_RANGE_CONSISTENT_STATS_INCORRECT CheckConsistencyResponse_Status = 4
)

var CheckConsistencyResponse_Status_name = map[int32]string{
	0: "RANGE_INDETERMINATE",
	1: "RANGE_INCONSISTENT",
	2: "RANGE_CONSISTENT",
	3: "RANGE_CONSISTENT_STATS_ESTIMATED",
	4: "RANGE_CONSISTENT_STATS_INCORRECT",
}

var CheckConsistencyResponse_Status_value = map[string]int32{
	"RANGE_INDETERMINATE":              0,
	"RANGE_INCONSISTENT":               1,
	"RANGE_CONSISTENT":                 2,
	"RANGE_CONSISTENT_STATS_ESTIMATED": 3,
	"RANGE_CONSISTENT_STATS_INCORRECT": 4,
}

func (x CheckConsistencyResponse_Status) String() string {
	return proto.EnumName(CheckConsistencyResponse_Status_name, int32(x))
}

func (CheckConsistencyResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{25, 0}
}

// Source represents the immediate source of a request. FROM_SQL represents
// a KV request originating in SQL, and ROOT_KV represents a request
// originating within KV, but at the root of the tree of requests.
// BatchRequests can cause other BatchRequests (e.g. to PushTransaction),
// which may result in yet more BatchRequests (e.g. to
// ResolveIndeterminateCommit). These can cause a deadlock when using slot
// based admission control. Only FROM_SQL and ROOT_KV requests are subject
// to admission control. This behavior errs on the side of no deadlock, if
// we overlooked an instrumentation point, since the default value of OTHER
// bypasses admission control.
type AdmissionHeader_Source int32

const (
	AdmissionHeader_OTHER    AdmissionHeader_Source = 0
	AdmissionHeader_FROM_SQL AdmissionHeader_Source = 1
	AdmissionHeader_ROOT_KV  AdmissionHeader_Source = 2
)

var AdmissionHeader_Source_name = map[int32]string{
	0: "OTHER",
	1: "FROM_SQL",
	2: "ROOT_KV",
}

var AdmissionHeader_Source_value = map[string]int32{
	"OTHER":    0,
	"FROM_SQL": 1,
	"ROOT_KV":  2,
}

func (x AdmissionHeader_Source) String() string {
	return proto.EnumName(AdmissionHeader_Source_name, int32(x))
}

func (AdmissionHeader_Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{95, 0}
}

// RequestHeader is supplied with every storage node request.
type RequestHeader struct {
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key Key `protobuf:"bytes,3,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The end key is empty if the request spans only a single key. Otherwise,
	// it must order strictly after Key. In such a case, the header indicates
	// that the operation takes place on the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=Key" json:"end_key,omitempty"`
	// A zero-indexed transactional sequence number.
	Sequence github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq `protobuf:"varint,5,opt,name=sequence,proto3,casttype=github.com/cockroachdb/cockroach/pkg/storage/enginepb.TxnSeq" json:"sequence,omitempty"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{0}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

// ResponseHeader is returned with every storage node response. Note that this is
// different from a BatchResponse's header.
type ResponseHeader struct {
	// txn is non-nil if the request specified a non-nil transaction.
	// The transaction timestamp and/or priority may have been updated,
	// depending on the outcome of the request.
	//
	// Once txn is merged into the BatchResponse_Header.Txn, it will be
	// reset to nil to avoid sending superfluous information over the
	// network.
	Txn *Transaction `protobuf:"bytes,3,opt,name=txn,proto3" json:"txn,omitempty"`
	// The next span to resume from when the response doesn't cover the full span
	// requested. This can happen when a bound on the keys is set through
	// max_span_request_keys in the batch header or when a scan has been stopped
	// before covering the requested data because of scan_options.
	//
	// ResumeSpan is unset when the entire span of keys have been
	// operated on. The span is set to the original span if the request
	// was ignored because max_span_request_keys was hit due to another
	// request in the batch. For a reverse scan the end_key is updated.
	ResumeSpan *Span `protobuf:"bytes,4,opt,name=resume_span,json=resumeSpan,proto3" json:"resume_span,omitempty"`
	// When resume_span is populated, this specifies the reason why the operation
	// wasn't completed and needs to be resumed.
	// This field appeared in v2.0. Responses from storage coming from older
	// servers will not contain it, but the conversion from a BatchResponse to a
	// client.Result always fills it in.
	ResumeReason ResponseHeader_ResumeReason `protobuf:"varint,7,opt,name=resume_reason,json=resumeReason,proto3,enum=cockroach.roachpb.ResponseHeader_ResumeReason" json:"resume_reason,omitempty"`
	// The number of keys operated on.
	NumKeys int64 `protobuf:"varint,5,opt,name=num_keys,json=numKeys,proto3" json:"num_keys,omitempty"`
	// The number of bytes returned. Only populated for requests that support it
	// (at the time of writing, Scan, ReverseScan and ExportRequest). The number
	// returned here corresponds to the (Header).TargetBytes field and loosely
	// measures the bytes in the timestamps, keys, and values of the returned
	// rows.
	NumBytes int64 `protobuf:"varint,8,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{1}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

// A GetRequest is the argument for the Get() method.
type GetRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired key-level locking mode used during this get. When set to None
	// (the default), no key-level locking mode is used - meaning that the get
	// does not acquire a lock. When set to any other strength, a lock of that
	// strength is acquired with the Unreplicated durability (i.e. best-effort)
	// the key, if it exists.
	KeyLocking lock.Strength `protobuf:"varint,2,opt,name=key_locking,json=keyLocking,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{2}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

// A GetResponse is the return value from the Get() method.
// If the key doesn't exist, Value will be nil.
type GetResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value          *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The intent seen, if any, when using the READ_UNCOMMITTED consistency level.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the value field may contain a
	// value that is being deleted by a corresponding intent. We should revisit
	// this decision if this ever becomes a problem.
	IntentValue *Value `protobuf:"bytes,3,opt,name=intent_value,json=intentValue,proto3" json:"intent_value,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{3}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

// A PutRequest is the argument to the Put() method.
type PutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// Specify as true to put the value without a corresponding
	// timestamp. This option should be used with care as it precludes
	// the use of this value with transactions.
	Inline bool `protobuf:"varint,3,opt,name=inline,proto3" json:"inline,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
}

func (m *PutRequest) Reset()         { *m = PutRequest{} }
func (m *PutRequest) String() string { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()    {}
func (*PutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{4}
}
func (m *PutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutRequest.Merge(m, src)
}
func (m *PutRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutRequest proto.InternalMessageInfo

// A PutResponse is the return value from the Put() method.
type PutResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *PutResponse) Reset()         { *m = PutResponse{} }
func (m *PutResponse) String() string { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()    {}
func (*PutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{5}
}
func (m *PutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResponse.Merge(m, src)
}
func (m *PutResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutResponse proto.InternalMessageInfo

// A ConditionalPutRequest is the argument to the ConditionalPut() method.
//
// - Returns true and sets value if exp_bytes equals existing value.
// - If key doesn't exist and exp_bytes is empty, sets value.
// - Otherwise, returns a ConditionFailedError containing the actual value of the key.
//
// Note that the client is free to send more requests after a
// ConditionFailedError. This is not generally allowed after other errors
// because of fears over the ambiguity of the side-effects of failed requests
// (in particular, the timestamps at which intents might have been written).
// ConditionFailedError is a special case as we ensure there's no ambiguity; the
// error carries a WriteTimestamp that's the upper bound of the timestamps
// intents were written at.
type ConditionalPutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The value to put.
	Value Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// deprecated_exp_val represents the expected existing value for the key. If
	// the existing value is different, the request will return a
	// ConditionFailedError. A missing (Go nil) deprecated_exp_value.raw_bytes
	// means that the key is expected to not exist.
	//
	// This is deprecated in 20.2 in favor of exp_bytes, which clarifies that the
	// checksum and timestamp of the expected value are irrelevant. Remove in
	// 21.1.
	DeprecatedExpValue *Value `protobuf:"bytes,3,opt,name=deprecated_exp_value,json=deprecatedExpValue,proto3" json:"deprecated_exp_value,omitempty"`
	// exp_bytes represents the expected existing value for the key. If empty, the
	// key is expected to not exist. If not empty, these bytes are expected to
	// contain the tag and data of the existing value (without the existing
	// value's checksum; the byte array is expected to come from
	// Value.TagAndDataBytes()). A value's checksum covers the key in addition to
	// covering the value, so not including a checksum here makes for a easier to
	// use API - the creator of the ConditionalPutRequest can simply put in bytes
	// coming from a different key.
	// Note that there's no such thing as expecting a key to exist, but have an
	// empty value. Such key-values don't exist.
	//
	// Note that the existing value's timestamp doesn't matter, only its data. So,
	// the CPut will succeed in ABA situations (if a reader got value A and checks
	// against it later, the check will succeed even if, in the meantime, there's
	// been a subsequent write of value B and another one back to value A).
	ExpBytes []byte `protobuf:"bytes,6,opt,name=exp_bytes,json=expBytes,proto3" json:"exp_bytes,omitempty"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,4,opt,name=blind,proto3" json:"blind,omitempty"`
	// Typically if a specific, non-empty expected value is supplied, it *must*
	// exist with that value. Passing this indicates that it is also OK if the key
	// does not exist. This is useful when a given value is expected but it is
	// possible it has not yet been written.
	AllowIfDoesNotExist bool `protobuf:"varint,5,opt,name=allow_if_does_not_exist,json=allowIfDoesNotExist,proto3" json:"allow_if_does_not_exist,omitempty"`
	// Specify as true to put the value without a corresponding
	// timestamp. This option should be used with care as it precludes
	// the use of this value with transactions.
	//
	// Callers should check the version gate clusterversion.CPutInline to make
	// sure this is supported.
	Inline bool `protobuf:"varint,7,opt,name=inline,proto3" json:"inline,omitempty"`
}

func (m *ConditionalPutRequest) Reset()         { *m = ConditionalPutRequest{} }
func (m *ConditionalPutRequest) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutRequest) ProtoMessage()    {}
func (*ConditionalPutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{6}
}
func (m *ConditionalPutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionalPutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutRequest.Merge(m, src)
}
func (m *ConditionalPutRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutRequest proto.InternalMessageInfo

// A ConditionalPutResponse is the return value from the
// ConditionalPut() method.
type ConditionalPutResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ConditionalPutResponse) Reset()         { *m = ConditionalPutResponse{} }
func (m *ConditionalPutResponse) String() string { return proto.CompactTextString(m) }
func (*ConditionalPutResponse) ProtoMessage()    {}
func (*ConditionalPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{7}
}
func (m *ConditionalPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionalPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionalPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionalPutResponse.Merge(m, src)
}
func (m *ConditionalPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConditionalPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionalPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionalPutResponse proto.InternalMessageInfo

// An InitPutRequest is the argument to the InitPut() method.
//
// - If key doesn't exist, sets value.
// - If key exists, returns a ConditionFailedError if value != existing value
//   If failOnTombstones is set to true, tombstone values count as mismatched
//   values and will cause a ConditionFailedError.
type InitPutRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// NOTE: For internal use only! Set to indicate that the put is
	// writing to virgin keyspace and no reads are necessary to
	// rationalize MVCC.
	Blind bool `protobuf:"varint,3,opt,name=blind,proto3" json:"blind,omitempty"`
	// If true, tombstones cause ConditionFailedErrors.
	FailOnTombstones bool `protobuf:"varint,4,opt,name=failOnTombstones,proto3" json:"failOnTombstones,omitempty"`
}

func (m *InitPutRequest) Reset()         { *m = InitPutRequest{} }
func (m *InitPutRequest) String() string { return proto.CompactTextString(m) }
func (*InitPutRequest) ProtoMessage()    {}
func (*InitPutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{8}
}
func (m *InitPutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitPutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitPutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitPutRequest.Merge(m, src)
}
func (m *InitPutRequest) XXX_Size() int {
	return m.Size()
}
func (m *InitPutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitPutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitPutRequest proto.InternalMessageInfo

// A InitPutResponse is the return value from the InitPut() method.
type InitPutResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *InitPutResponse) Reset()         { *m = InitPutResponse{} }
func (m *InitPutResponse) String() string { return proto.CompactTextString(m) }
func (*InitPutResponse) ProtoMessage()    {}
func (*InitPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{9}
}
func (m *InitPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitPutResponse.Merge(m, src)
}
func (m *InitPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *InitPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitPutResponse proto.InternalMessageInfo

// An IncrementRequest is the argument to the Increment() method. It
// increments the value for key, and returns the new value. If no
// value exists for a key, incrementing by 0 is not a noop, but will
// create a zero value. IncrementRequest cannot be called on a key set
// by Put() or ConditionalPut(). Similarly, Put() and ConditionalPut()
// cannot be invoked on an incremented key.
type IncrementRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Increment     int64 `protobuf:"varint,2,opt,name=increment,proto3" json:"increment,omitempty"`
}

func (m *IncrementRequest) Reset()         { *m = IncrementRequest{} }
func (m *IncrementRequest) String() string { return proto.CompactTextString(m) }
func (*IncrementRequest) ProtoMessage()    {}
func (*IncrementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{10}
}
func (m *IncrementRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IncrementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementRequest.Merge(m, src)
}
func (m *IncrementRequest) XXX_Size() int {
	return m.Size()
}
func (m *IncrementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementRequest proto.InternalMessageInfo

// An IncrementResponse is the return value from the Increment
// method. The new value after increment is specified in NewValue. If
// the value could not be decoded as specified, Error will be set.
type IncrementResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	NewValue       int64 `protobuf:"varint,2,opt,name=new_value,json=newValue,proto3" json:"new_value,omitempty"`
}

func (m *IncrementResponse) Reset()         { *m = IncrementResponse{} }
func (m *IncrementResponse) String() string { return proto.CompactTextString(m) }
func (*IncrementResponse) ProtoMessage()    {}
func (*IncrementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{11}
}
func (m *IncrementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IncrementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementResponse.Merge(m, src)
}
func (m *IncrementResponse) XXX_Size() int {
	return m.Size()
}
func (m *IncrementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementResponse proto.InternalMessageInfo

// A DeleteRequest is the argument to the Delete() method.
type DeleteRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{12}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(m, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

// A DeleteResponse is the return value from the Delete() method.
type DeleteResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{13}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(m, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

// A DeleteRangeRequest is the argument to the DeleteRange() method. It
// specifies the range of keys to delete.
//
// A DeleteRangeRequest populates the timestamp cache and is tracked for
// refreshes.
type DeleteRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// return the keys that are deleted in the response.
	ReturnKeys bool `protobuf:"varint,3,opt,name=return_keys,json=returnKeys,proto3" json:"return_keys,omitempty"`
	// delete "inline" keys which are stored without MVCC timestamps. Note that
	// an "inline" DeleteRange will fail if it attempts to delete any keys which
	// contain timestamped (non-inline) values; this option should only be used on
	// keys which are known to store inline values, such as data in cockroach's
	// time series system.
	//
	// Similarly, attempts to delete keys with inline values will fail unless this
	// flag is set to true; the setting must match the data being deleted.
	//
	// Inline values cannot be deleted transactionally; a DeleteRange with
	// "inline" set to true will fail if it is executed within a transaction.
	Inline bool `protobuf:"varint,4,opt,name=inline,proto3" json:"inline,omitempty"`
}

func (m *DeleteRangeRequest) Reset()         { *m = DeleteRangeRequest{} }
func (m *DeleteRangeRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRangeRequest) ProtoMessage()    {}
func (*DeleteRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{14}
}
func (m *DeleteRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRangeRequest.Merge(m, src)
}
func (m *DeleteRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRangeRequest proto.InternalMessageInfo

// A DeleteRangeResponse is the return value from the DeleteRange()
// method.
type DeleteRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// All the deleted keys if return_keys is set.
	Keys []Key `protobuf:"bytes,2,rep,name=keys,proto3,casttype=Key" json:"keys,omitempty"`
}

func (m *DeleteRangeResponse) Reset()         { *m = DeleteRangeResponse{} }
func (m *DeleteRangeResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteRangeResponse) ProtoMessage()    {}
func (*DeleteRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{15}
}
func (m *DeleteRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRangeResponse.Merge(m, src)
}
func (m *DeleteRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRangeResponse proto.InternalMessageInfo

// A ClearRangeRequest is the argument to the ClearRange() method. It
// specifies a range of keys to clear from the underlying engine. Note
// that this differs from the behavior of DeleteRange, which sets
// transactional intents and writes tombstones to the deleted
// keys. ClearRange is used when permanently dropping or truncating
// table data.
//
// ClearRange also updates the GC threshold for the range to the
// timestamp at which this command executes, to prevent reads at
// earlier timestamps from incorrectly returning empty results.
//
// NOTE: it is important that this method only be invoked on a key
// range which is guaranteed to be both inactive and not see future
// writes (until Deadline, if set, below).
// Ignoring this warning may result in data loss.
type ClearRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Deadline can be set to a time at or after which the server will refuse to
	// execute this ClearRange request, providing a form of replay protection:
	// if a caller sets this to a time in the near future, they can then wait for
	// that time (plus max offset) to have passed at which point they can reuse
	// the span they cleared without fear of this request being replayed later and
	// clearing subsequent writes.
	Deadline hlc.Timestamp `protobuf:"bytes,2,opt,name=deadline,proto3" json:"deadline"`
}

func (m *ClearRangeRequest) Reset()         { *m = ClearRangeRequest{} }
func (m *ClearRangeRequest) String() string { return proto.CompactTextString(m) }
func (*ClearRangeRequest) ProtoMessage()    {}
func (*ClearRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{16}
}
func (m *ClearRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRangeRequest.Merge(m, src)
}
func (m *ClearRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRangeRequest proto.InternalMessageInfo

// A ClearRangeResponse is the return value from the ClearRange() method.
type ClearRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ClearRangeResponse) Reset()         { *m = ClearRangeResponse{} }
func (m *ClearRangeResponse) String() string { return proto.CompactTextString(m) }
func (*ClearRangeResponse) ProtoMessage()    {}
func (*ClearRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{17}
}
func (m *ClearRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearRangeResponse.Merge(m, src)
}
func (m *ClearRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClearRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearRangeResponse proto.InternalMessageInfo

// A RevertRangeRequest specifies a range of keys in which to clear all MVCC
// revisions more recent than some TargetTime from the underlying engine, thus
// reverting the range (from the perspective of an MVCC scan) to that time.
type RevertRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// TargetTime specifies a the time to which to "revert" the range by clearing
	// any MVCC key with a strictly higher timestamp. TargetTime must be higher
	// than the GC Threshold for the replica - so that it is assured that the keys
	// for that time are still there â€” or the request will fail.
	TargetTime                          hlc.Timestamp `protobuf:"bytes,2,opt,name=target_time,json=targetTime,proto3" json:"target_time"`
	EnableTimeBoundIteratorOptimization bool          `protobuf:"varint,3,opt,name=enable_time_bound_iterator_optimization,json=enableTimeBoundIteratorOptimization,proto3" json:"enable_time_bound_iterator_optimization,omitempty"`
	// IgnoreGcThreshold can be set by a caller to ignore the target-time when
	// checking that the earliest time at which the command operates is above the
	// GC threshold. This is safe to set only in very specific situations, such as
	// when the target span was OFFLINE since the target time as it is during
	// IMPORT INTO. In this case, since the IMPORT knows it is the only writer and
	// it only writes new keys, no keys to which it would need to revert have been
	// shadowed / could have been GC'ed, so it can safely ignore the GC threshold.
	IgnoreGcThreshold bool `protobuf:"varint,4,opt,name=ignore_gc_threshold,json=ignoreGcThreshold,proto3" json:"ignore_gc_threshold,omitempty"`
}

func (m *RevertRangeRequest) Reset()         { *m = RevertRangeRequest{} }
func (m *RevertRangeRequest) String() string { return proto.CompactTextString(m) }
func (*RevertRangeRequest) ProtoMessage()    {}
func (*RevertRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{18}
}
func (m *RevertRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevertRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RevertRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevertRangeRequest.Merge(m, src)
}
func (m *RevertRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RevertRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RevertRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RevertRangeRequest proto.InternalMessageInfo

// A RevertRangeResponse is the return value from the RevertRange() method.
type RevertRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RevertRangeResponse) Reset()         { *m = RevertRangeResponse{} }
func (m *RevertRangeResponse) String() string { return proto.CompactTextString(m) }
func (*RevertRangeResponse) ProtoMessage()    {}
func (*RevertRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{19}
}
func (m *RevertRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevertRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RevertRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevertRangeResponse.Merge(m, src)
}
func (m *RevertRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RevertRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RevertRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RevertRangeResponse proto.InternalMessageInfo

// A ScanRequest is the argument to the Scan() method. It specifies the
// start and end keys for an ascending scan of [start,end) and the maximum
// number of results (unbounded if zero).
type ScanRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired format for the response. If set to BATCH_RESPONSE, the server
	// will set the batch_responses field in the ScanResponse instead of the rows
	// field.
	ScanFormat ScanFormat `protobuf:"varint,4,opt,name=scan_format,json=scanFormat,proto3,enum=cockroach.roachpb.ScanFormat" json:"scan_format,omitempty"`
	// The desired key-level locking mode used during this scan. When set to None
	// (the default), no key-level locking mode is used - meaning that the scan
	// does not acquire any locks. When set to any other strength, a lock of that
	// strength is acquired with the Unreplicated durability (i.e. best-effort) on
	// each of the keys scanned by the request, subject to any key limit applied
	// to the batch which limits the number of keys returned.
	//
	// NOTE: the locks acquire with this strength are point locks on each of the
	// keys returned by the request, not a single range lock over the entire span
	// scanned by the request.
	KeyLocking lock.Strength `protobuf:"varint,5,opt,name=key_locking,json=keyLocking,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking,omitempty"`
}

func (m *ScanRequest) Reset()         { *m = ScanRequest{} }
func (m *ScanRequest) String() string { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()    {}
func (*ScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{20}
}
func (m *ScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanRequest.Merge(m, src)
}
func (m *ScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanRequest proto.InternalMessageInfo

// A ScanResponse is the return value from the Scan() method.
type ScanResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Empty if no rows were scanned.
	Rows []KeyValue `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows"`
	// The intent rows seen when performing a scan at the READ_UNCOMMITTED
	// consistency level. These rows do not count against the MaxSpanRequestKeys
	// count.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the rows field may contain
	// key-values that are being deleted by corresponding intents. We should
	// revisit this decision if this ever becomes a problem.
	IntentRows []KeyValue `protobuf:"bytes,3,rep,name=intent_rows,json=intentRows,proto3" json:"intent_rows"`
	// If set, each item in this repeated bytes field contains part of the results
	// in batch format - the key/value pairs are a buffer of varint-prefixed
	// slices, alternating from key to value. Each entry in this field is
	// complete - there are no key/value pairs that are split across more than one
	// entry. There are num_keys total pairs across all entries, as defined by the
	// ResponseHeader. If set, rows will not be set and vice versa.
	BatchResponses [][]byte `protobuf:"bytes,4,rep,name=batch_responses,json=batchResponses,proto3" json:"batch_responses,omitempty"`
}

func (m *ScanResponse) Reset()         { *m = ScanResponse{} }
func (m *ScanResponse) String() string { return proto.CompactTextString(m) }
func (*ScanResponse) ProtoMessage()    {}
func (*ScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{21}
}
func (m *ScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanResponse.Merge(m, src)
}
func (m *ScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanResponse proto.InternalMessageInfo

// A ReverseScanRequest is the argument to the ReverseScan() method. It specifies the
// start and end keys for a descending scan of [start,end) and the maximum
// number of results (unbounded if zero).
type ReverseScanRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The desired format for the response. If set to BATCH_RESPONSE, the server
	// will set the batch_responses field in the ScanResponse instead of the rows
	// field.
	ScanFormat ScanFormat `protobuf:"varint,4,opt,name=scan_format,json=scanFormat,proto3,enum=cockroach.roachpb.ScanFormat" json:"scan_format,omitempty"`
	// The desired key-level locking mode used during this scan. When set to None
	// (the default), no key-level locking mode is used - meaning that the scan
	// does not acquire any locks. When set to any other strength, a lock of that
	// strength is acquired with the Unreplicated durability (i.e. best-effort) on
	// each of the keys scanned by the request, subject to any key limit applied
	// to the batch which limits the number of keys returned.
	//
	// NOTE: the locks acquire with this strength are point locks on each of the
	// keys returned by the request, not a single range lock over the entire span
	// scanned by the request.
	KeyLocking lock.Strength `protobuf:"varint,5,opt,name=key_locking,json=keyLocking,proto3,enum=cockroach.kv.kvserver.concurrency.lock.Strength" json:"key_locking,omitempty"`
}

func (m *ReverseScanRequest) Reset()         { *m = ReverseScanRequest{} }
func (m *ReverseScanRequest) String() string { return proto.CompactTextString(m) }
func (*ReverseScanRequest) ProtoMessage()    {}
func (*ReverseScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{22}
}
func (m *ReverseScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReverseScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseScanRequest.Merge(m, src)
}
func (m *ReverseScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReverseScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseScanRequest proto.InternalMessageInfo

// A ReverseScanResponse is the return value from the ReverseScan() method.
type ReverseScanResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Empty if no rows were scanned.
	Rows []KeyValue `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows"`
	// The intent rows seen when performing a scan at the READ_UNCOMMITTED
	// consistency level. These rows do not count against the MaxSpanRequestKeys
	// count.
	//
	// NOTE: this field is not currently populated with intents for deletion
	// tombstones. It probably should be because the rows field may contain
	// key-values that are being deleted by corresponding intents. We should
	// revisit this decision if this ever becomes a problem.
	IntentRows []KeyValue `protobuf:"bytes,3,rep,name=intent_rows,json=intentRows,proto3" json:"intent_rows"`
	// If set, each item in this repeated bytes field contains part of the results
	// in batch format - the key/value pairs are a buffer of varint-prefixed
	// slices, alternating from key to value. Each entry in this field is
	// complete - there are no key/value pairs that are split across more than one
	// entry. There are num_keys total pairs across all entries, as defined by the
	// ResponseHeader. If set, rows will not be set and vice versa.
	BatchResponses [][]byte `protobuf:"bytes,4,rep,name=batch_responses,json=batchResponses,proto3" json:"batch_responses,omitempty"`
}

func (m *ReverseScanResponse) Reset()         { *m = ReverseScanResponse{} }
func (m *ReverseScanResponse) String() string { return proto.CompactTextString(m) }
func (*ReverseScanResponse) ProtoMessage()    {}
func (*ReverseScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{23}
}
func (m *ReverseScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReverseScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseScanResponse.Merge(m, src)
}
func (m *ReverseScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReverseScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseScanResponse proto.InternalMessageInfo

// A CheckConsistencyRequest is the argument to the CheckConsistency() method.
// It specifies the start and end keys for a span of ranges to which a
// consistency check should be applied. A consistency check on a range involves
// running a ComputeChecksum on the range followed by a storage.CollectChecksum.
type CheckConsistencyRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// log a diff of inconsistencies if such inconsistencies are found. This is only
	// valid if mode == FROM_QUEUE
	WithDiff bool         `protobuf:"varint,2,opt,name=with_diff,json=withDiff,proto3" json:"with_diff,omitempty"`
	Mode     ChecksumMode `protobuf:"varint,3,opt,name=mode,proto3,enum=cockroach.roachpb.ChecksumMode" json:"mode,omitempty"`
	// Whether to create a RocksDB checkpoint on each replica at the log position
	// at which the SHA is computed. The checkpoint is essentially a cheap point-
	// in-time backup of the database. It will be put into the engines' auxiliary
	// directory and needs to be removed manually to avoid leaking disk space.
	Checkpoint bool `protobuf:"varint,4,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// A list of nodes that the consistency check wants to terminate. This is
	// typically set when Checkpoint above is also set, as part of a second round
	// after a first consistency check that did find a divergence. The second
	// round is concerned with damage control and wants the nodes it suspects hold
	// anomalous data to be shut down, so that this data isn't served to clients
	// (or worse, spread to other replicas).
	Terminate []ReplicaDescriptor `protobuf:"bytes,5,rep,name=terminate,proto3" json:"terminate"`
}

func (m *CheckConsistencyRequest) Reset()         { *m = CheckConsistencyRequest{} }
func (m *CheckConsistencyRequest) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyRequest) ProtoMessage()    {}
func (*CheckConsistencyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{24}
}
func (m *CheckConsistencyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyRequest.Merge(m, src)
}
func (m *CheckConsistencyRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyRequest proto.InternalMessageInfo

// A CheckConsistencyResponse is the return value from the CheckConsistency() method.
// It returns the status the range was found in.
type CheckConsistencyResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// result contains a Result for each Range checked, in no particular order.
	Result []CheckConsistencyResponse_Result `protobuf:"bytes,2,rep,name=result,proto3" json:"result"`
}

func (m *CheckConsistencyResponse) Reset()         { *m = CheckConsistencyResponse{} }
func (m *CheckConsistencyResponse) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyResponse) ProtoMessage()    {}
func (*CheckConsistencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{25}
}
func (m *CheckConsistencyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyResponse.Merge(m, src)
}
func (m *CheckConsistencyResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyResponse proto.InternalMessageInfo

type CheckConsistencyResponse_Result struct {
	RangeID RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=RangeID" json:"range_id,omitempty"`
	// start_key of the range corresponding to range_id (at the time of the
	// check). This is useful to send additional requests to only a subset of
	// ranges contained within a result later, as requests can only be routed by
	// key.
	StartKey []byte                          `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Status   CheckConsistencyResponse_Status `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.CheckConsistencyResponse_Status" json:"status,omitempty"`
	// detail contains information related to the operation. If no inconsistency
	// is found, it contains informational value such as observed stats. If an
	// inconsistency is found, it contains information about that inconsistency
	// including the involved replica and, if requested, the diff.
	Detail string `protobuf:"bytes,4,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *CheckConsistencyResponse_Result) Reset()         { *m = CheckConsistencyResponse_Result{} }
func (m *CheckConsistencyResponse_Result) String() string { return proto.CompactTextString(m) }
func (*CheckConsistencyResponse_Result) ProtoMessage()    {}
func (*CheckConsistencyResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{25, 0}
}
func (m *CheckConsistencyResponse_Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConsistencyResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConsistencyResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConsistencyResponse_Result.Merge(m, src)
}
func (m *CheckConsistencyResponse_Result) XXX_Size() int {
	return m.Size()
}
func (m *CheckConsistencyResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConsistencyResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConsistencyResponse_Result proto.InternalMessageInfo

// An RecomputeStatsRequest triggers a stats recomputation on the Range addressed by
// the request.
//
// An error will be returned if the start key does not match the start key of the
// target Range.
//
// The stats recomputation touches essentially the whole range, but the command
// avoids having to block other commands by taking care to not interleave
// with splits, and by using the commutativity of stats updates. As a result,
// it is safe to invoke at any time, including repeatedly, though it should be
// used conservatively due to performing a full scan of the Range.
type RecomputeStatsRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// When dry_run is true, the stats delta is computed, but no stats adjustment
	// is performed. This isn't useful outside of testing since RecomputeStats is
	// safe and idempotent.
	DryRun bool `protobuf:"varint,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (m *RecomputeStatsRequest) Reset()         { *m = RecomputeStatsRequest{} }
func (m *RecomputeStatsRequest) String() string { return proto.CompactTextString(m) }
func (*RecomputeStatsRequest) ProtoMessage()    {}
func (*RecomputeStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{26}
}
func (m *RecomputeStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecomputeStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecomputeStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecomputeStatsRequest.Merge(m, src)
}
func (m *RecomputeStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecomputeStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecomputeStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecomputeStatsRequest proto.InternalMessageInfo

// An RecomputeStatsResponse is the response to an RecomputeStatsRequest.
type RecomputeStatsResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// added_delta is the adjustment made to the range's stats, i.e. `new_stats = old_stats + added_delta`.
	AddedDelta enginepb.MVCCStatsDelta `protobuf:"bytes,2,opt,name=added_delta,json=addedDelta,proto3" json:"added_delta"`
}

func (m *RecomputeStatsResponse) Reset()         { *m = RecomputeStatsResponse{} }
func (m *RecomputeStatsResponse) String() string { return proto.CompactTextString(m) }
func (*RecomputeStatsResponse) ProtoMessage()    {}
func (*RecomputeStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{27}
}
func (m *RecomputeStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecomputeStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecomputeStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecomputeStatsResponse.Merge(m, src)
}
func (m *RecomputeStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecomputeStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecomputeStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecomputeStatsResponse proto.InternalMessageInfo

// An EndTxnRequest is the argument to the EndTxn() method. It specifies
// whether to commit or roll back an extant transaction.
type EndTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// False to abort and rollback.
	Commit bool `protobuf:"varint,2,opt,name=commit,proto3" json:"commit,omitempty"`
	// If set, deadline represents the maximum (exclusive) timestamp at which the
	// transaction can commit (i.e. the maximum timestamp for the txn's reads and
	// writes).
	// If EndTxn(Commit=true) finds that the txn's timestamp has been pushed above
	// this deadline, an error will be returned and the client is supposed to
	// rollback the txn.
	Deadline *hlc.Timestamp `protobuf:"bytes,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// commit triggers. Note that commit triggers are for
	// internal use only and will cause an error if requested through the
	// external-facing KV API.
	InternalCommitTrigger *InternalCommitTrigger `protobuf:"bytes,4,opt,name=internal_commit_trigger,json=internalCommitTrigger,proto3" json:"internal_commit_trigger,omitempty"`
	// Set of spans that the transaction has acquired locks within. These are
	// spans which must be resolved on txn completion. Note that these spans
	// may be condensed to cover aggregate spans if the keys locked by the
	// transaction exceeded a size threshold.
	//
	// The set logically extends to include the keys of all writes in the
	// in-flight write set. However, those keys are not stored in this set
	// to avoid duplication. This means that elements that are removed from
	// that set should be merged into this one.
	//
	// The slice is maintained in sorted order and all spans are maximally
	// merged such that no two spans here overlap each other.
	LockSpans []Span `protobuf:"bytes,5,rep,name=lock_spans,json=lockSpans,proto3" json:"lock_spans"`
	// Set of in-flight intent writes that have been issued by the transaction but
	// which may not have succeeded yet. If any promised writes are provided, a
	// committing EndTxn request will move a PENDING transaction to the STAGING
	// status instead of the COMMITTED status. These in-flight writes must then
	// all be confirmed as successful before the transaction can be moved from
	// STAGING to COMMITTED. For more, see txnCommitter.
	//
	// The slice is maintained in sorted order by sequence number. This provides
	// O(log n) access to individual writes in this set based on their sequence
	// number. See SequencedWriteBySeq.Find and its uses. The set can contain
	// multiple SequencedWrites with the same key, but all sequence numbers are
	// unique.
	InFlightWrites []SequencedWrite `protobuf:"bytes,17,rep,name=in_flight_writes,json=inFlightWrites,proto3" json:"in_flight_writes"`
	// Requires that the transaction completes as a 1 phase commit. This
	// guarantees that all writes are to the same range and that no
	// intents are left in the event of an error.
	//
	// Note(andrei): Use this flag with care; retriable errors are not generated
	// reliably for these transactions - a TransactionStatusError might be
	// returned instead if 1PC execution fails.
	Require1PC bool `protobuf:"varint,6,opt,name=require_1pc,json=require1pc,proto3" json:"require_1pc,omitempty"`
	// True to indicate that lock spans should be resolved with poison=true.
	// This is used when the transaction is being aborted independently of the
	// main thread of client operation, as in the case of an asynchronous abort
	// from the TxnCoordSender on a failed heartbeat. It should only be set to
	// true when commit=false.
	Poison bool `protobuf:"varint,9,opt,name=poison,proto3" json:"poison,omitempty"`
	// TxnHeartbeating indicates that the transaction's coordinator has launched
	// its heartbeat loop and that it may have created its transaction record as
	// PENDING through a HeartbeatTxn request by the time that this EndTxn request
	// evaluates. If the flag is not set and the transaction has not yet issued a
	// successful EndTxn requests, the transaction's record can not already exist
	// (but see the WARNING below).
	//
	// For details about transaction record state transitions, see the diagram on
	// CanCreateTxnRecord. This diagram demonstrates that only EndTxn requests and
	// HeartbeatTxn requests can create new transaction records.
	//
	// WARNING: this flag was introduced in the v20.2 release. v20.1 nodes may not
	// set this properly so it should not be relied upon for correctness.
	TxnHeartbeating bool `protobuf:"varint,10,opt,name=txn_heartbeating,json=txnHeartbeating,proto3" json:"txn_heartbeating,omitempty"`
}

func (m *EndTxnRequest) Reset()         { *m = EndTxnRequest{} }
func (m *EndTxnRequest) String() string { return proto.CompactTextString(m) }
func (*EndTxnRequest) ProtoMessage()    {}
func (*EndTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{28}
}
func (m *EndTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndTxnRequest.Merge(m, src)
}
func (m *EndTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *EndTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EndTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EndTxnRequest proto.InternalMessageInfo

// An EndTxnResponse is the return value from the EndTxn() method. The final
// transaction record is returned as part of the response header. In particular,
// transaction status and timestamp will be updated to reflect final committed
// values. Clients may propagate the transaction timestamp as the final txn
// commit timestamp in order to preserve causal ordering between subsequent
// transactions.
type EndTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// True if the transaction committed on the one phase commit path.
	// This means that all writes which were part of the transaction
	// were written as a single, atomic write batch to just one range.
	OnePhaseCommit bool `protobuf:"varint,4,opt,name=one_phase_commit,json=onePhaseCommit,proto3" json:"one_phase_commit,omitempty"`
	// The commit timestamp of the STAGING transaction record written
	// by the request. Only set if the transaction record was staged.
	StagingTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=staging_timestamp,json=stagingTimestamp,proto3" json:"staging_timestamp"`
}

func (m *EndTxnResponse) Reset()         { *m = EndTxnResponse{} }
func (m *EndTxnResponse) String() string { return proto.CompactTextString(m) }
func (*EndTxnResponse) ProtoMessage()    {}
func (*EndTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{29}
}
func (m *EndTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndTxnResponse.Merge(m, src)
}
func (m *EndTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *EndTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EndTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EndTxnResponse proto.InternalMessageInfo

// An AdminSplitRequest is the argument to the AdminSplit() method. The
// existing range which contains header.key is split by
// split_key. If split_key is not specified, then this method will
// determine a split key that is roughly halfway through the
// range. The existing range is resized to cover only its start key to
// the split key. The new range created by the split starts at the
// split key and extends to the original range's end key. If split_key
// is known, header.key should also be set to split_key.
//
// New range IDs for each of the split range's replica and a new Raft
// ID are generated by the operation. Split requests are done in the
// context of a distributed transaction which updates range addressing
// records, range metadata and finally, provides a commit trigger to
// update bookkeeping and instantiate the new range on commit.
//
// The new range contains range replicas located on the same stores;
// no range data is moved during this operation. The split can be
// thought of as a mostly logical operation, though some other
// metadata (e.g. abort span and range stats must be copied or
// recomputed).
//
// expiration_time represents the time that this split expires. Any split that
// is not expired will not be considered for automatic merging by the merge
// queue. Any split requested by the split queue will have an expiration time
// of hlc.Timestamp{} (I.E. The zero timestamp so they are always eligible for
// automatic merging).
type AdminSplitRequest struct {
	RequestHeader  `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	SplitKey       Key           `protobuf:"bytes,2,opt,name=split_key,json=splitKey,proto3,casttype=Key" json:"split_key,omitempty"`
	ExpirationTime hlc.Timestamp `protobuf:"bytes,4,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time"`
}

func (m *AdminSplitRequest) Reset()         { *m = AdminSplitRequest{} }
func (m *AdminSplitRequest) String() string { return proto.CompactTextString(m) }
func (*AdminSplitRequest) ProtoMessage()    {}
func (*AdminSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{30}
}
func (m *AdminSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminSplitRequest.Merge(m, src)
}
func (m *AdminSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminSplitRequest proto.InternalMessageInfo

// An AdminSplitResponse is the return value from the AdminSplit()
// method.
type AdminSplitResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminSplitResponse) Reset()         { *m = AdminSplitResponse{} }
func (m *AdminSplitResponse) String() string { return proto.CompactTextString(m) }
func (*AdminSplitResponse) ProtoMessage()    {}
func (*AdminSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{31}
}
func (m *AdminSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminSplitResponse.Merge(m, src)
}
func (m *AdminSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminSplitResponse proto.InternalMessageInfo

// An AdminUnsplitRequest is the argument to the AdminUnsplit()
// method. The sticky bit of the existing range whose starting key is
// header.key is removed.
//
// Ranges that do not have the sticky bit set are eligible for
// automatic merging.
type AdminUnsplitRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminUnsplitRequest) Reset()         { *m = AdminUnsplitRequest{} }
func (m *AdminUnsplitRequest) String() string { return proto.CompactTextString(m) }
func (*AdminUnsplitRequest) ProtoMessage()    {}
func (*AdminUnsplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{32}
}
func (m *AdminUnsplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminUnsplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminUnsplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminUnsplitRequest.Merge(m, src)
}
func (m *AdminUnsplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminUnsplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminUnsplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminUnsplitRequest proto.InternalMessageInfo

// An AdminUnsplitResponse is the return value from the
// AdminUnsplit() method.
type AdminUnsplitResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminUnsplitResponse) Reset()         { *m = AdminUnsplitResponse{} }
func (m *AdminUnsplitResponse) String() string { return proto.CompactTextString(m) }
func (*AdminUnsplitResponse) ProtoMessage()    {}
func (*AdminUnsplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{33}
}
func (m *AdminUnsplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminUnsplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminUnsplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminUnsplitResponse.Merge(m, src)
}
func (m *AdminUnsplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminUnsplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminUnsplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminUnsplitResponse proto.InternalMessageInfo

// An AdminMergeRequest is the argument to the AdminMerge() method. A
// merge is performed by calling AdminMerge on the left-hand range of
// two consecutive ranges (i.e. the range which contains keys which
// sort first). This range will be the subsuming range and the right
// hand range will be subsumed. After the merge operation, the
// subsumed range will no longer exist and the subsuming range will
// now encompass all keys from its original start key to the end key
// of the subsumed range. If AdminMerge is called on the final range
// in the key space, it is a noop.
// The request must be addressed to the start key of the left hand side.
type AdminMergeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminMergeRequest) Reset()         { *m = AdminMergeRequest{} }
func (m *AdminMergeRequest) String() string { return proto.CompactTextString(m) }
func (*AdminMergeRequest) ProtoMessage()    {}
func (*AdminMergeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{34}
}
func (m *AdminMergeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminMergeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminMergeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminMergeRequest.Merge(m, src)
}
func (m *AdminMergeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminMergeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminMergeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminMergeRequest proto.InternalMessageInfo

// An AdminMergeResponse is the return value from the AdminMerge()
// method.
type AdminMergeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminMergeResponse) Reset()         { *m = AdminMergeResponse{} }
func (m *AdminMergeResponse) String() string { return proto.CompactTextString(m) }
func (*AdminMergeResponse) ProtoMessage()    {}
func (*AdminMergeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{35}
}
func (m *AdminMergeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminMergeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminMergeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminMergeResponse.Merge(m, src)
}
func (m *AdminMergeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminMergeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminMergeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminMergeResponse proto.InternalMessageInfo

// An AdminTransferLeaseRequest is the argument to the AdminTransferLease()
// method. A lease transfer allows an external entity to control the lease
// holder for a range. The target of the lease transfer needs to be a valid
// replica of the range.
type AdminTransferLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Target        StoreID `protobuf:"varint,2,opt,name=target,proto3,casttype=StoreID" json:"target,omitempty"`
}

func (m *AdminTransferLeaseRequest) Reset()         { *m = AdminTransferLeaseRequest{} }
func (m *AdminTransferLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*AdminTransferLeaseRequest) ProtoMessage()    {}
func (*AdminTransferLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{36}
}
func (m *AdminTransferLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminTransferLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminTransferLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminTransferLeaseRequest.Merge(m, src)
}
func (m *AdminTransferLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminTransferLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminTransferLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminTransferLeaseRequest proto.InternalMessageInfo

type AdminTransferLeaseResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminTransferLeaseResponse) Reset()         { *m = AdminTransferLeaseResponse{} }
func (m *AdminTransferLeaseResponse) String() string { return proto.CompactTextString(m) }
func (*AdminTransferLeaseResponse) ProtoMessage()    {}
func (*AdminTransferLeaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{37}
}
func (m *AdminTransferLeaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminTransferLeaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminTransferLeaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminTransferLeaseResponse.Merge(m, src)
}
func (m *AdminTransferLeaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminTransferLeaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminTransferLeaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminTransferLeaseResponse proto.InternalMessageInfo

// A ReplicationChange specifies the type and target of a replication change operation.
type ReplicationChange struct {
	ChangeType ReplicaChangeType `protobuf:"varint,1,opt,name=change_type,json=changeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"change_type,omitempty"`
	Target     ReplicationTarget `protobuf:"bytes,2,opt,name=target,proto3" json:"target"`
}

func (m *ReplicationChange) Reset()         { *m = ReplicationChange{} }
func (m *ReplicationChange) String() string { return proto.CompactTextString(m) }
func (*ReplicationChange) ProtoMessage()    {}
func (*ReplicationChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{38}
}
func (m *ReplicationChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicationChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationChange.Merge(m, src)
}
func (m *ReplicationChange) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationChange.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationChange proto.InternalMessageInfo

// An AdminChangeReplicasRequest is the argument to the AdminChangeReplicas()
// method. A change replicas operation allows adding or removing a set of
// replicas for a range.
type AdminChangeReplicasRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Never access directly: use .Changes()
	//
	// TODO(tbg): remove in 20.1
	DeprecatedChangeType ReplicaChangeType `protobuf:"varint,2,opt,name=deprecated_change_type,json=deprecatedChangeType,proto3,enum=cockroach.roachpb.ReplicaChangeType" json:"deprecated_change_type,omitempty"`
	// Never access directly: use .Changes()
	//
	// TODO(tbg): remove in 20.1
	DeprecatedTargets []ReplicationTarget `protobuf:"bytes,3,rep,name=deprecated_targets,json=deprecatedTargets,proto3" json:"deprecated_targets"`
	// ExpDesc is the expected current range descriptor to modify. If the range
	// descriptor is not identical to ExpDesc for the request will fail.
	//
	// If there is more than one change specified in targets, this expectation
	// will be applied to the first change and subsequent changes will use the
	// resultant descriptor from successfully applying the previous change.
	// If a change with more than one target occurs concurrently with another
	// it is possible that an error will occur after partial application of the
	// change. Changes are applied in the order they appear in the request.
	ExpDesc RangeDescriptor `protobuf:"bytes,4,opt,name=exp_desc,json=expDesc,proto3" json:"exp_desc"`
	// The changes to apply to exp_desc. Never access directly: use .Changes().
	//
	// TODO(tbg): rename to 'changes' in 20.1 and remove Changes().
	InternalChanges []ReplicationChange `protobuf:"bytes,5,rep,name=internal_changes,json=internalChanges,proto3" json:"internal_changes"`
}

func (m *AdminChangeReplicasRequest) Reset()         { *m = AdminChangeReplicasRequest{} }
func (m *AdminChangeReplicasRequest) String() string { return proto.CompactTextString(m) }
func (*AdminChangeReplicasRequest) ProtoMessage()    {}
func (*AdminChangeReplicasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{39}
}
func (m *AdminChangeReplicasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminChangeReplicasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminChangeReplicasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminChangeReplicasRequest.Merge(m, src)
}
func (m *AdminChangeReplicasRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminChangeReplicasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminChangeReplicasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminChangeReplicasRequest proto.InternalMessageInfo

type AdminChangeReplicasResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Desc is the value of the range descriptor upon success.
	Desc RangeDescriptor `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc"`
}

func (m *AdminChangeReplicasResponse) Reset()         { *m = AdminChangeReplicasResponse{} }
func (m *AdminChangeReplicasResponse) String() string { return proto.CompactTextString(m) }
func (*AdminChangeReplicasResponse) ProtoMessage()    {}
func (*AdminChangeReplicasResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{40}
}
func (m *AdminChangeReplicasResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminChangeReplicasResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminChangeReplicasResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminChangeReplicasResponse.Merge(m, src)
}
func (m *AdminChangeReplicasResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminChangeReplicasResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminChangeReplicasResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminChangeReplicasResponse proto.InternalMessageInfo

// An AdminRelocateRangeRequest is the argument to the AdminRelocateRange()
// method. Relocates the replicas for a range to the specified target stores.
// The first store in the list of targets becomes the new leaseholder.
type AdminRelocateRangeRequest struct {
	RequestHeader   `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	VoterTargets    []ReplicationTarget `protobuf:"bytes,2,rep,name=voter_targets,json=voterTargets,proto3" json:"voter_targets"`
	NonVoterTargets []ReplicationTarget `protobuf:"bytes,3,rep,name=non_voter_targets,json=nonVoterTargets,proto3" json:"non_voter_targets"`
}

func (m *AdminRelocateRangeRequest) Reset()         { *m = AdminRelocateRangeRequest{} }
func (m *AdminRelocateRangeRequest) String() string { return proto.CompactTextString(m) }
func (*AdminRelocateRangeRequest) ProtoMessage()    {}
func (*AdminRelocateRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{41}
}
func (m *AdminRelocateRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRelocateRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminRelocateRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRelocateRangeRequest.Merge(m, src)
}
func (m *AdminRelocateRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminRelocateRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRelocateRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRelocateRangeRequest proto.InternalMessageInfo

type AdminRelocateRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AdminRelocateRangeResponse) Reset()         { *m = AdminRelocateRangeResponse{} }
func (m *AdminRelocateRangeResponse) String() string { return proto.CompactTextString(m) }
func (*AdminRelocateRangeResponse) ProtoMessage()    {}
func (*AdminRelocateRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{42}
}
func (m *AdminRelocateRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRelocateRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminRelocateRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRelocateRangeResponse.Merge(m, src)
}
func (m *AdminRelocateRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminRelocateRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRelocateRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRelocateRangeResponse proto.InternalMessageInfo

// A HeartbeatTxnRequest is arguments to the HeartbeatTxn()
// method. It's sent by transaction coordinators to let the system
// know that the transaction is still ongoing. Note that this
// heartbeat message is different from the heartbeat message in the
// gossip protocol.
type HeartbeatTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// NOTE: this could use a ClockTimestamp type, but doing so results in a
	// large diff that doesn't seem worth it, given that we never feed this
	// timestamp back into a clock.
	Now hlc.Timestamp `protobuf:"bytes,2,opt,name=now,proto3" json:"now"`
}

func (m *HeartbeatTxnRequest) Reset()         { *m = HeartbeatTxnRequest{} }
func (m *HeartbeatTxnRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatTxnRequest) ProtoMessage()    {}
func (*HeartbeatTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{43}
}
func (m *HeartbeatTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeartbeatTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatTxnRequest.Merge(m, src)
}
func (m *HeartbeatTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatTxnRequest proto.InternalMessageInfo

// A HeartbeatTxnResponse is the return value from the HeartbeatTxn()
// method. It returns the transaction info in the response header. The
// returned transaction lets the coordinator know the disposition of
// the transaction (i.e. aborted, committed, or pending).
type HeartbeatTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *HeartbeatTxnResponse) Reset()         { *m = HeartbeatTxnResponse{} }
func (m *HeartbeatTxnResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatTxnResponse) ProtoMessage()    {}
func (*HeartbeatTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{44}
}
func (m *HeartbeatTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeartbeatTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatTxnResponse.Merge(m, src)
}
func (m *HeartbeatTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatTxnResponse proto.InternalMessageInfo

// A GCRequest is arguments to the GC() method. It's sent by range
// lease holders after scanning range data to find expired MVCC values.
type GCRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Keys          []GCRequest_GCKey `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys"`
	// Threshold is the expiration timestamp.
	Threshold hlc.Timestamp `protobuf:"bytes,4,opt,name=threshold,proto3" json:"threshold"`
}

func (m *GCRequest) Reset()         { *m = GCRequest{} }
func (m *GCRequest) String() string { return proto.CompactTextString(m) }
func (*GCRequest) ProtoMessage()    {}
func (*GCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{45}
}
func (m *GCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest.Merge(m, src)
}
func (m *GCRequest) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest proto.InternalMessageInfo

type GCRequest_GCKey struct {
	Key       Key           `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *GCRequest_GCKey) Reset()         { *m = GCRequest_GCKey{} }
func (m *GCRequest_GCKey) String() string { return proto.CompactTextString(m) }
func (*GCRequest_GCKey) ProtoMessage()    {}
func (*GCRequest_GCKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{45, 0}
}
func (m *GCRequest_GCKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCRequest_GCKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCRequest_GCKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest_GCKey.Merge(m, src)
}
func (m *GCRequest_GCKey) XXX_Size() int {
	return m.Size()
}
func (m *GCRequest_GCKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest_GCKey.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest_GCKey proto.InternalMessageInfo

// A GCResponse is the return value from the GC() method.
type GCResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *GCResponse) Reset()         { *m = GCResponse{} }
func (m *GCResponse) String() string { return proto.CompactTextString(m) }
func (*GCResponse) ProtoMessage()    {}
func (*GCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{46}
}
func (m *GCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCResponse.Merge(m, src)
}
func (m *GCResponse) XXX_Size() int {
	return m.Size()
}
func (m *GCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GCResponse proto.InternalMessageInfo

// A PushTxnRequest is arguments to the PushTxn() method. It's sent by
// readers or writers which have encountered an "intent" laid down by
// another transaction. The goal is to resolve the conflict. Note that
// args.Key should be set to the txn ID of args.PusheeTxn, not
// args.PusherTxn. This RPC is addressed to the range which owns the pushee's
// txn record.
//
// Resolution is trivial if the txn which owns the intent has either
// been committed or aborted already. Otherwise, the existing txn can
// either be aborted (for write/write conflicts), or its commit
// timestamp can be moved forward (for read/write conflicts). The
// course of action is determined by the specified push type, and by
// the owning txn's status and priority.
type PushTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction which encountered the intent, if applicable. For a
	// non-transactional pusher, pusher_txn will only have the priority set (in
	// particular, ID won't be set). Used to compare priorities and timestamps if
	// priorities are equal.
	PusherTxn Transaction `protobuf:"bytes,2,opt,name=pusher_txn,json=pusherTxn,proto3" json:"pusher_txn"`
	// Transaction to be pushed, as specified at the intent which led to
	// the push transaction request. Note that this may not be the most
	// up-to-date value of the transaction record, but will be set or
	// merged as appropriate.
	PusheeTxn enginepb.TxnMeta `protobuf:"bytes,3,opt,name=pushee_txn,json=pusheeTxn,proto3" json:"pushee_txn"`
	// PushTo is the timestamp which PusheeTxn should be pushed to. During
	// conflict resolution, it should be set just after the timestamp of the
	// conflicting read or write.
	PushTo hlc.Timestamp `protobuf:"bytes,4,opt,name=push_to,json=pushTo,proto3" json:"push_to"`
	// Readers set this to PUSH_TIMESTAMP to move pushee_txn's provisional
	// commit timestamp forward. Writers set this to PUSH_ABORT to request
	// that pushee_txn be aborted if possible. Inconsistent readers set
	// this to PUSH_TOUCH to determine whether the pushee can be aborted
	// due to inactivity (based on the now field).
	PushType PushTxnType `protobuf:"varint,6,opt,name=push_type,json=pushType,proto3,enum=cockroach.roachpb.PushTxnType" json:"push_type,omitempty"`
	// Forces the push by overriding the normal expiration and priority checks
	// in PushTxn to either abort or push the timestamp.
	Force bool `protobuf:"varint,7,opt,name=force,proto3" json:"force,omitempty"`
}

func (m *PushTxnRequest) Reset()         { *m = PushTxnRequest{} }
func (m *PushTxnRequest) String() string { return proto.CompactTextString(m) }
func (*PushTxnRequest) ProtoMessage()    {}
func (*PushTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{47}
}
func (m *PushTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PushTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTxnRequest.Merge(m, src)
}
func (m *PushTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *PushTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PushTxnRequest proto.InternalMessageInfo

// A PushTxnResponse is the return value from the PushTxn() method. It
// returns success and the resulting state of PusheeTxn if the
// conflict was resolved in favor of the caller; the caller should
// subsequently invoke ResolveIntent() on the conflicted key. It
// returns an error otherwise.
type PushTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// pushee_txn is non-nil if the transaction was pushed and contains
	// the current value of the transaction.
	// TODO(tschottdorf): Maybe this can be a TxnMeta instead; probably requires
	// factoring out the new Priority.
	PusheeTxn Transaction `protobuf:"bytes,2,opt,name=pushee_txn,json=pusheeTxn,proto3" json:"pushee_txn"`
}

func (m *PushTxnResponse) Reset()         { *m = PushTxnResponse{} }
func (m *PushTxnResponse) String() string { return proto.CompactTextString(m) }
func (*PushTxnResponse) ProtoMessage()    {}
func (*PushTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{48}
}
func (m *PushTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PushTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushTxnResponse.Merge(m, src)
}
func (m *PushTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *PushTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PushTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PushTxnResponse proto.InternalMessageInfo

// A RecoverTxnRequest is arguments to the RecoverTxn() method. It is sent
// during the recovery process for a transaction abandoned in the STAGING state.
// The sender is expected to have queried all of the abandoned transaction's
// in-flight writes and determined whether they all succeeded or not. This is
// used to determine whether the result of the recovery should be committing the
// abandoned transaction or aborting it.
type RecoverTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction record to recover.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// Did all of the STAGING transaction's writes succeed? If so, the transaction
	// is implicitly committed and the commit can be made explicit by giving its
	// record a COMMITTED status. If not, the transaction can be aborted as long
	// as a write that was found to have failed was prevented from ever succeeding
	// in the future.
	ImplicitlyCommitted bool `protobuf:"varint,3,opt,name=implicitly_committed,json=implicitlyCommitted,proto3" json:"implicitly_committed,omitempty"`
}

func (m *RecoverTxnRequest) Reset()         { *m = RecoverTxnRequest{} }
func (m *RecoverTxnRequest) String() string { return proto.CompactTextString(m) }
func (*RecoverTxnRequest) ProtoMessage()    {}
func (*RecoverTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{49}
}
func (m *RecoverTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoverTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverTxnRequest.Merge(m, src)
}
func (m *RecoverTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecoverTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverTxnRequest proto.InternalMessageInfo

// A RecoverTxnResponse is the return value from the RecoverTxn() method.
type RecoverTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Contains the finalized state of the recovered transaction.
	RecoveredTxn Transaction `protobuf:"bytes,2,opt,name=recovered_txn,json=recoveredTxn,proto3" json:"recovered_txn"`
}

func (m *RecoverTxnResponse) Reset()         { *m = RecoverTxnResponse{} }
func (m *RecoverTxnResponse) String() string { return proto.CompactTextString(m) }
func (*RecoverTxnResponse) ProtoMessage()    {}
func (*RecoverTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{50}
}
func (m *RecoverTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoverTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverTxnResponse.Merge(m, src)
}
func (m *RecoverTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoverTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverTxnResponse proto.InternalMessageInfo

// A QueryTxnResponse is arguments to the QueryTxn() method. It's sent
// by transactions which are waiting to push another transaction because
// of conflicting write intents to fetch updates to either the pusher's
// or the pushee's transaction records.
type QueryTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Transaction record to query.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// If true, the query will not return until there are changes to either the
	// transaction status or priority -OR- to the set of dependent transactions.
	WaitForUpdate bool `protobuf:"varint,3,opt,name=wait_for_update,json=waitForUpdate,proto3" json:"wait_for_update,omitempty"`
	// Set of known dependent transactions.
	KnownWaitingTxns []github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,4,rep,name=known_waiting_txns,json=knownWaitingTxns,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"known_waiting_txns,omitempty"`
}

func (m *QueryTxnRequest) Reset()         { *m = QueryTxnRequest{} }
func (m *QueryTxnRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTxnRequest) ProtoMessage()    {}
func (*QueryTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{51}
}
func (m *QueryTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTxnRequest.Merge(m, src)
}
func (m *QueryTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTxnRequest proto.InternalMessageInfo

// A QueryTxnResponse is the return value from the QueryTxn() method.
type QueryTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Contains the current state of the queried transaction. If the queried
	// transaction record does not exist, this will be empty.
	QueriedTxn Transaction `protobuf:"bytes,2,opt,name=queried_txn,json=queriedTxn,proto3" json:"queried_txn"`
	// txn_record_exists is set if the queried_txn comes from a transaction record
	// read from the database. If not set, then the txn record was "synthesized".
	//
	// The field only started being populated in 20.2, so 20.1 nodes never set it.
	TxnRecordExists bool `protobuf:"varint,4,opt,name=txn_record_exists,json=txnRecordExists,proto3" json:"txn_record_exists,omitempty"`
	// Specifies a list of transaction IDs which are waiting on the txn.
	WaitingTxns []github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,3,rep,name=waiting_txns,json=waitingTxns,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"waiting_txns,omitempty"`
}

func (m *QueryTxnResponse) Reset()         { *m = QueryTxnResponse{} }
func (m *QueryTxnResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTxnResponse) ProtoMessage()    {}
func (*QueryTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{52}
}
func (m *QueryTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTxnResponse.Merge(m, src)
}
func (m *QueryTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTxnResponse proto.InternalMessageInfo

// A QueryIntentRequest is arguments to the QueryIntent() method. It visits
// the specified key and checks whether an intent is present for the given
// transaction. If the intent is found to be missing then it is prevented
// from ever being written in the future.
type QueryIntentRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The TxnMeta that the intent is expected to have. Specifically, whether an
	// intent is a match or not is defined as whether an intent exists that could
	// be committed by the provided transaction. If an intent is found at the
	// specified key, the intent is only considered a match if it has the same ID,
	// the same epoch, and a write timestamp that is equal to or less than that in
	// the provided transaction.
	//
	// Additionally, the intent is only considered a match if its sequence number
	// is equal to or greater than the expected txn's sequence number. The
	// requests doesn't require an exact sequence number match because the
	// transaction could have performed overlapping writes, in which case only the
	// latest sequence number will remain. We assume that if a transaction has
	// successfully written an intent at a larger sequence number then it must
	// have succeeeded in writing an intent at the smaller sequence number as
	// well.
	//
	// QueryIntentRequests may be issued in non-transactional BatchRequests or in
	// transactional BatchRequests. If issued inside of a transaction, the TxnMeta
	// must be a reference to the same transaction as the batch's transaction, or
	// the request will be rejected. In other words, a transaction can only query
	// its own intents. In these cases where the BatchRequest is transactional,
	// the TxnMeta's write timestamp is forwarded by the write timestamp of the
	// request header transaction for purposes of determining whether a matching
	// intent is found or not (see condition above). This is useful to avoid the
	// need to update each QueryIntentRequest when a transaction is querying its
	// own intent after having successfully refreshed.
	Txn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn,proto3" json:"txn"`
	// If true, return an IntentMissingError if a matching intent is not found.
	// Special-cased to return a SERIALIZABLE retry error if a SERIALIZABLE
	// transaction queries its own intent and finds it has been pushed.
	ErrorIfMissing bool `protobuf:"varint,3,opt,name=error_if_missing,json=errorIfMissing,proto3" json:"error_if_missing,omitempty"`
}

func (m *QueryIntentRequest) Reset()         { *m = QueryIntentRequest{} }
func (m *QueryIntentRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIntentRequest) ProtoMessage()    {}
func (*QueryIntentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{53}
}
func (m *QueryIntentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIntentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryIntentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIntentRequest.Merge(m, src)
}
func (m *QueryIntentRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIntentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIntentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIntentRequest proto.InternalMessageInfo

// A QueryIntentResponse is the return value from the QueryIntent() method.
type QueryIntentResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Whether an intent matching the expected transaction was found at the key.
	FoundIntent bool `protobuf:"varint,2,opt,name=found_intent,json=foundIntent,proto3" json:"found_intent,omitempty"`
}

func (m *QueryIntentResponse) Reset()         { *m = QueryIntentResponse{} }
func (m *QueryIntentResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIntentResponse) ProtoMessage()    {}
func (*QueryIntentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{54}
}
func (m *QueryIntentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIntentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryIntentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIntentResponse.Merge(m, src)
}
func (m *QueryIntentResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIntentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIntentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIntentResponse proto.InternalMessageInfo

// A ResolveIntentRequest is arguments to the ResolveIntent()
// method. It is sent by transaction coordinators after success
// calling PushTxn to clean up write intents: either to remove, commit
// or move them forward in time.
type ResolveIntentRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The transaction whose intent is being resolved.
	IntentTxn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=intent_txn,json=intentTxn,proto3" json:"intent_txn"`
	// The status of the transaction.
	Status TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// Optionally poison the abort span for the transaction on the intent's range.
	// The field is ignored if status != ABORTED (i.e. only intents from ABORTED
	// txns ever poison the abort spans).
	Poison bool `protobuf:"varint,4,opt,name=poison,proto3" json:"poison,omitempty"`
	// The list of ignored seqnum ranges as per the Transaction record.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,5,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *ResolveIntentRequest) Reset()         { *m = ResolveIntentRequest{} }
func (m *ResolveIntentRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRequest) ProtoMessage()    {}
func (*ResolveIntentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{55}
}
func (m *ResolveIntentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRequest.Merge(m, src)
}
func (m *ResolveIntentRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRequest proto.InternalMessageInfo

// A ResolveIntentResponse is the return value from the
// ResolveIntent() method.
type ResolveIntentResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ResolveIntentResponse) Reset()         { *m = ResolveIntentResponse{} }
func (m *ResolveIntentResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentResponse) ProtoMessage()    {}
func (*ResolveIntentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{56}
}
func (m *ResolveIntentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentResponse.Merge(m, src)
}
func (m *ResolveIntentResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentResponse proto.InternalMessageInfo

// A ResolveIntentRangeRequest is arguments to the ResolveIntentRange() method.
// It is sent by transaction coordinators after success calling PushTxn to
// clean up write intents: either to remove, commit or move them forward in
// time.
type ResolveIntentRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The transaction whose intents are being resolved.
	IntentTxn enginepb.TxnMeta `protobuf:"bytes,2,opt,name=intent_txn,json=intentTxn,proto3" json:"intent_txn"`
	// The status of the transaction.
	Status TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=cockroach.roachpb.TransactionStatus" json:"status,omitempty"`
	// Optionally poison the abort span for the transaction on all ranges on which
	// the intents reside. The field is ignored if status != ABORTED (i.e. only
	// intents from ABORTED txns ever poison the abort spans).
	Poison bool `protobuf:"varint,4,opt,name=poison,proto3" json:"poison,omitempty"`
	// The minimum timestamp for any intents written by this
	// transaction. If present, this value can be used to optimize the
	// iteration over the span to find intents to resolve.
	MinTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=min_timestamp,json=minTimestamp,proto3" json:"min_timestamp"`
	// The list of ignored seqnum ranges as per the Transaction record.
	IgnoredSeqNums []enginepb.IgnoredSeqNumRange `protobuf:"bytes,6,rep,name=ignored_seqnums,json=ignoredSeqnums,proto3" json:"ignored_seqnums"`
}

func (m *ResolveIntentRangeRequest) Reset()         { *m = ResolveIntentRangeRequest{} }
func (m *ResolveIntentRangeRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRangeRequest) ProtoMessage()    {}
func (*ResolveIntentRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{57}
}
func (m *ResolveIntentRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRangeRequest.Merge(m, src)
}
func (m *ResolveIntentRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRangeRequest proto.InternalMessageInfo

// A ResolveIntentRangeResponse is the return value from the
// ResolveIntent() method.
type ResolveIntentRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *ResolveIntentRangeResponse) Reset()         { *m = ResolveIntentRangeResponse{} }
func (m *ResolveIntentRangeResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveIntentRangeResponse) ProtoMessage()    {}
func (*ResolveIntentRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{58}
}
func (m *ResolveIntentRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIntentRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResolveIntentRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIntentRangeResponse.Merge(m, src)
}
func (m *ResolveIntentRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResolveIntentRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIntentRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIntentRangeResponse proto.InternalMessageInfo

// A MergeRequest contains arguments to the Merge() method. It
// specifies a key and a value which should be merged into the
// existing value at that key.
type MergeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Value         Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
}

func (m *MergeRequest) Reset()         { *m = MergeRequest{} }
func (m *MergeRequest) String() string { return proto.CompactTextString(m) }
func (*MergeRequest) ProtoMessage()    {}
func (*MergeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{59}
}
func (m *MergeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeRequest.Merge(m, src)
}
func (m *MergeRequest) XXX_Size() int {
	return m.Size()
}
func (m *MergeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MergeRequest proto.InternalMessageInfo

// MergeResponse is the response to a Merge() operation.
type MergeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *MergeResponse) Reset()         { *m = MergeResponse{} }
func (m *MergeResponse) String() string { return proto.CompactTextString(m) }
func (*MergeResponse) ProtoMessage()    {}
func (*MergeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{60}
}
func (m *MergeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MergeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeResponse.Merge(m, src)
}
func (m *MergeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MergeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MergeResponse proto.InternalMessageInfo

// TruncateLogRequest is used to remove a prefix of the raft log. While there
// is no requirement for correctness that the raft log truncation be synchronized across
// replicas, it is nice to preserve the property that all replicas of a range are as close
// to identical as possible. The raft leader can also inform decisions about the cutoff point
// with its knowledge of the replicas' acknowledgment status.
type TruncateLogRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Log entries < this index are to be discarded.
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// RangeID is used to double check that the correct range is being truncated.
	// The header specifies a span, start and end keys, but not the range id
	// itself. The range may have changed from the one specified in the header
	// in the case of a merge.
	RangeID RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3,casttype=RangeID" json:"range_id,omitempty"`
}

func (m *TruncateLogRequest) Reset()         { *m = TruncateLogRequest{} }
func (m *TruncateLogRequest) String() string { return proto.CompactTextString(m) }
func (*TruncateLogRequest) ProtoMessage()    {}
func (*TruncateLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{61}
}
func (m *TruncateLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TruncateLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateLogRequest.Merge(m, src)
}
func (m *TruncateLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *TruncateLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateLogRequest proto.InternalMessageInfo

// TruncateLogResponse is the response to a TruncateLog() operation.
type TruncateLogResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *TruncateLogResponse) Reset()         { *m = TruncateLogResponse{} }
func (m *TruncateLogResponse) String() string { return proto.CompactTextString(m) }
func (*TruncateLogResponse) ProtoMessage()    {}
func (*TruncateLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{62}
}
func (m *TruncateLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TruncateLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateLogResponse.Merge(m, src)
}
func (m *TruncateLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *TruncateLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateLogResponse proto.InternalMessageInfo

// A RequestLeaseRequest is arguments to the RequestLease()
// method. It is sent by the store on behalf of one of its ranges upon receipt
// of a command requiring a lease when none is found.
type RequestLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Lease         Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// The previous lease is specified by the caller to verify
	// it has not changed when executing this command.
	PrevLease Lease `protobuf:"bytes,3,opt,name=prev_lease,json=prevLease,proto3" json:"prev_lease"`
	// The MinLeaseProposedTS of the proposing replica to make sure that leases
	// issued after a node restart receive a new sequence number (instead of
	// counting as a lease extension). See #23204.
	MinProposedTS *github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,4,opt,name=min_proposed_ts,json=minProposedTs,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"min_proposed_ts,omitempty"`
}

func (m *RequestLeaseRequest) Reset()         { *m = RequestLeaseRequest{} }
func (m *RequestLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*RequestLeaseRequest) ProtoMessage()    {}
func (*RequestLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{63}
}
func (m *RequestLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLeaseRequest.Merge(m, src)
}
func (m *RequestLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *RequestLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLeaseRequest proto.InternalMessageInfo

// A TransferLeaseRequest represents the arguments to the TransferLease()
// method. It is sent by a replica that currently holds the range lease and
// wants to transfer it away.
//
// Like a RequestLeaseRequest, this request has the effect of instituting a new
// lease. The difference is that the new lease is allowed to overlap the
// existing one. It is a separate request because the RequestLeaseRequest is
// special - it's not subject to the same replay protection restrictions as
// other requests, instead being protected from replays by the fact that leases
// are not generally allowed to overlap. The TransferLeaseRequest is not
// special in this respect (for example, the proposer of this command is
// checked to have been holding the lease when the proposal was made).
type TransferLeaseRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Lease         Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// The previous lease is specified by the caller to verify
	// it has not changed when executing this command.
	PrevLease Lease `protobuf:"bytes,3,opt,name=prev_lease,json=prevLease,proto3" json:"prev_lease"`
}

func (m *TransferLeaseRequest) Reset()         { *m = TransferLeaseRequest{} }
func (m *TransferLeaseRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaseRequest) ProtoMessage()    {}
func (*TransferLeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{64}
}
func (m *TransferLeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransferLeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaseRequest.Merge(m, src)
}
func (m *TransferLeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaseRequest proto.InternalMessageInfo

// LeaseInfoRequest is the argument to the LeaseInfo() method, for getting
// information about a range's lease.
// It's a point request, so it addresses one single range, and returns the lease
// currently in effect for that range. This request is commonly set with
// ReadConsistency=INCONSISTENT in order for the request to be served by the
// node to whom the request was sent.
type LeaseInfoRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *LeaseInfoRequest) Reset()         { *m = LeaseInfoRequest{} }
func (m *LeaseInfoRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseInfoRequest) ProtoMessage()    {}
func (*LeaseInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{65}
}
func (m *LeaseInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeaseInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseInfoRequest.Merge(m, src)
}
func (m *LeaseInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseInfoRequest proto.InternalMessageInfo

// LeaseInfoResponse is the response to a LeaseInfo() operation.
type LeaseInfoResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The last lease known by the replica serving the request. It can also be the
	// tentative future lease, if a lease transfer is in progress.
	Lease Lease `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
	// current_lease is set if `lease` represents a tentative future lease. In
	// that case, current_lease represents the lease that's currently in effect.
	CurrentLease *Lease `protobuf:"bytes,3,opt,name=current_lease,json=currentLease,proto3" json:"current_lease,omitempty"`
	// evaluated_by returns the store that evaluated this request. This
	// corresponds to the leaseholder unless ReadConsistency=INCONSISTENT was
	// used. The response reflects the evaluator's view of the lease. When the
	// client cares to see a particular node's view, it can use this field to
	// check whether the node it intended query (by sending the request to that
	// node and using ReadConsistency=INCONSISTENT) indeed served it - it's
	// possible that even if ReadConsistency=INCONSISTENT was used, the request is
	// still not evaluated by the node it was sent to if that node's replica is a
	// learner or the node doesn't have a replica at all.
	EvaluatedBy StoreID `protobuf:"varint,4,opt,name=evaluated_by,json=evaluatedBy,proto3,casttype=StoreID" json:"evaluated_by,omitempty"`
}

func (m *LeaseInfoResponse) Reset()         { *m = LeaseInfoResponse{} }
func (m *LeaseInfoResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseInfoResponse) ProtoMessage()    {}
func (*LeaseInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{66}
}
func (m *LeaseInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeaseInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseInfoResponse.Merge(m, src)
}
func (m *LeaseInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseInfoResponse proto.InternalMessageInfo

// A RequestLeaseResponse is the response to a RequestLease() or TransferLease()
// operation.
type RequestLeaseResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RequestLeaseResponse) Reset()         { *m = RequestLeaseResponse{} }
func (m *RequestLeaseResponse) String() string { return proto.CompactTextString(m) }
func (*RequestLeaseResponse) ProtoMessage()    {}
func (*RequestLeaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{67}
}
func (m *RequestLeaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLeaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestLeaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLeaseResponse.Merge(m, src)
}
func (m *RequestLeaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestLeaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLeaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLeaseResponse proto.InternalMessageInfo

// A ComputeChecksumRequest is arguments to the ComputeChecksum() method, to
// start computing the checksum for the specified range at the snapshot for this
// request command. A response is returned without the checksum. The computed
// checksum is retrieved via a storage.CollectChecksumRequest.
type ComputeChecksumRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The version used to pick the checksum method. It allows us to use a
	// consistent checksumming method across replicas.
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// Compute a checksum along with a snapshot of the entire range, that will be
	// used in logging a diff during checksum verification.
	Snapshot bool `protobuf:"varint,4,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// The type of checksum to compute. See ChecksumMode.
	Mode ChecksumMode `protobuf:"varint,5,opt,name=mode,proto3,enum=cockroach.roachpb.ChecksumMode" json:"mode,omitempty"`
	// If set, a checkpoint (i.e. cheap backup) of the engine will be taken. This
	// is expected to be set only if we already know that there is a problem and
	// we want to preserve as much state as possible. The checkpoint will be stored
	// in the engine's auxiliary directory.
	Checkpoint bool `protobuf:"varint,6,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// If non-empty, specifies the replicas which are the most likely source of the
	// inconsistency. After evaluating the command, these replicas will terminate.
	//
	// See the field of the same name in CheckConsistencyRequest for details.
	Terminate []ReplicaDescriptor `protobuf:"bytes,7,rep,name=terminate,proto3" json:"terminate"`
}

func (m *ComputeChecksumRequest) Reset()         { *m = ComputeChecksumRequest{} }
func (m *ComputeChecksumRequest) String() string { return proto.CompactTextString(m) }
func (*ComputeChecksumRequest) ProtoMessage()    {}
func (*ComputeChecksumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{68}
}
func (m *ComputeChecksumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeChecksumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeChecksumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeChecksumRequest.Merge(m, src)
}
func (m *ComputeChecksumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComputeChecksumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeChecksumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeChecksumRequest proto.InternalMessageInfo

// A ComputeChecksumResponse is the response to a ComputeChecksum() operation.
type ComputeChecksumResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// ChecksumID is the unique identifier that can be used to get the computed
	// checksum in a future storage.CollectChecksumRequest.
	ChecksumID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,2,opt,name=checksum_id,json=checksumId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"checksum_id"`
}

func (m *ComputeChecksumResponse) Reset()         { *m = ComputeChecksumResponse{} }
func (m *ComputeChecksumResponse) String() string { return proto.CompactTextString(m) }
func (*ComputeChecksumResponse) ProtoMessage()    {}
func (*ComputeChecksumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{69}
}
func (m *ComputeChecksumResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeChecksumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeChecksumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeChecksumResponse.Merge(m, src)
}
func (m *ComputeChecksumResponse) XXX_Size() int {
	return m.Size()
}
func (m *ComputeChecksumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeChecksumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeChecksumResponse proto.InternalMessageInfo

type ExternalStorage struct {
	Provider          ExternalStorageProvider       `protobuf:"varint,1,opt,name=provider,proto3,enum=cockroach.roachpb.ExternalStorageProvider" json:"provider,omitempty"`
	LocalFile         ExternalStorage_LocalFilePath `protobuf:"bytes,2,opt,name=LocalFile,proto3" json:"LocalFile"`
	HttpPath          ExternalStorage_Http          `protobuf:"bytes,3,opt,name=HttpPath,proto3" json:"HttpPath"`
	GoogleCloudConfig *ExternalStorage_GCS          `protobuf:"bytes,4,opt,name=GoogleCloudConfig,proto3" json:"GoogleCloudConfig,omitempty"`
	S3Config          *ExternalStorage_S3           `protobuf:"bytes,5,opt,name=S3Config,proto3" json:"S3Config,omitempty"`
	AzureConfig       *ExternalStorage_Azure        `protobuf:"bytes,6,opt,name=AzureConfig,proto3" json:"AzureConfig,omitempty"`
	FileTableConfig   ExternalStorage_FileTable     `protobuf:"bytes,8,opt,name=FileTableConfig,proto3" json:"FileTableConfig"`
}

func (m *ExternalStorage) Reset()         { *m = ExternalStorage{} }
func (m *ExternalStorage) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage) ProtoMessage()    {}
func (*ExternalStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70}
}
func (m *ExternalStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage.Merge(m, src)
}
func (m *ExternalStorage) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage proto.InternalMessageInfo

type ExternalStorage_LocalFilePath struct {
	Path   string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	NodeID NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
}

func (m *ExternalStorage_LocalFilePath) Reset()         { *m = ExternalStorage_LocalFilePath{} }
func (m *ExternalStorage_LocalFilePath) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_LocalFilePath) ProtoMessage()    {}
func (*ExternalStorage_LocalFilePath) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 0}
}
func (m *ExternalStorage_LocalFilePath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_LocalFilePath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_LocalFilePath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_LocalFilePath.Merge(m, src)
}
func (m *ExternalStorage_LocalFilePath) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_LocalFilePath) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_LocalFilePath.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_LocalFilePath proto.InternalMessageInfo

type ExternalStorage_Http struct {
	BaseUri string `protobuf:"bytes,1,opt,name=baseUri,proto3" json:"baseUri,omitempty"`
}

func (m *ExternalStorage_Http) Reset()         { *m = ExternalStorage_Http{} }
func (m *ExternalStorage_Http) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_Http) ProtoMessage()    {}
func (*ExternalStorage_Http) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 1}
}
func (m *ExternalStorage_Http) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_Http) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_Http) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_Http.Merge(m, src)
}
func (m *ExternalStorage_Http) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_Http) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_Http.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_Http proto.InternalMessageInfo

type ExternalStorage_S3 struct {
	Bucket        string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix        string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	AccessKey     string `protobuf:"bytes,3,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	Secret        string `protobuf:"bytes,4,opt,name=secret,proto3" json:"secret,omitempty"`
	TempToken     string `protobuf:"bytes,5,opt,name=temp_token,json=tempToken,proto3" json:"temp_token,omitempty"`
	Endpoint      string `protobuf:"bytes,6,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region        string `protobuf:"bytes,7,opt,name=region,proto3" json:"region,omitempty"`
	Auth          string `protobuf:"bytes,8,opt,name=auth,proto3" json:"auth,omitempty"`
	ServerEncMode string `protobuf:"bytes,9,opt,name=server_enc_mode,json=serverEncMode,proto3" json:"server_enc_mode,omitempty"`
	ServerKMSID   string `protobuf:"bytes,10,opt,name=server_kms_id,json=serverKmsId,proto3" json:"server_kms_id,omitempty"`
}

func (m *ExternalStorage_S3) Reset()         { *m = ExternalStorage_S3{} }
func (m *ExternalStorage_S3) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_S3) ProtoMessage()    {}
func (*ExternalStorage_S3) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 2}
}
func (m *ExternalStorage_S3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_S3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_S3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_S3.Merge(m, src)
}
func (m *ExternalStorage_S3) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_S3) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_S3.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_S3 proto.InternalMessageInfo

type ExternalStorage_GCS struct {
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Auth   string `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
	// BillingProject if non-empty, is the Google Cloud project to bill for all storage requests.
	// This is required to be set if using a "requestor pays" bucket.
	BillingProject string `protobuf:"bytes,4,opt,name=billing_project,json=billingProject,proto3" json:"billing_project,omitempty"`
	Credentials    string `protobuf:"bytes,5,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (m *ExternalStorage_GCS) Reset()         { *m = ExternalStorage_GCS{} }
func (m *ExternalStorage_GCS) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_GCS) ProtoMessage()    {}
func (*ExternalStorage_GCS) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 3}
}
func (m *ExternalStorage_GCS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_GCS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_GCS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_GCS.Merge(m, src)
}
func (m *ExternalStorage_GCS) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_GCS) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_GCS.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_GCS proto.InternalMessageInfo

type ExternalStorage_Azure struct {
	Container   string `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	Prefix      string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	AccountName string `protobuf:"bytes,3,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	AccountKey  string `protobuf:"bytes,4,opt,name=account_key,json=accountKey,proto3" json:"account_key,omitempty"`
}

func (m *ExternalStorage_Azure) Reset()         { *m = ExternalStorage_Azure{} }
func (m *ExternalStorage_Azure) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_Azure) ProtoMessage()    {}
func (*ExternalStorage_Azure) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 4}
}
func (m *ExternalStorage_Azure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_Azure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_Azure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_Azure.Merge(m, src)
}
func (m *ExternalStorage_Azure) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_Azure) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_Azure.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_Azure proto.InternalMessageInfo

type ExternalStorage_FileTable struct {
	// User interacting with the external storage. This is used to check access
	// privileges of the requested user scoped tables.
	// This field is really of type security.SQLUsername. We can't use
	// the type directly however because it would create a circular dependency.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// QualifiedTableName specifies the database.schema.tablename which the
	// FileTableSystem should interact with when servicing reads/writes.
	QualifiedTableName string `protobuf:"bytes,2,opt,name=qualified_table_name,json=qualifiedTableName,proto3" json:"qualified_table_name,omitempty"`
	// Path is the filename being read/written to via the FileTableSystem.
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ExternalStorage_FileTable) Reset()         { *m = ExternalStorage_FileTable{} }
func (m *ExternalStorage_FileTable) String() string { return proto.CompactTextString(m) }
func (*ExternalStorage_FileTable) ProtoMessage()    {}
func (*ExternalStorage_FileTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{70, 5}
}
func (m *ExternalStorage_FileTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorage_FileTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExternalStorage_FileTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorage_FileTable.Merge(m, src)
}
func (m *ExternalStorage_FileTable) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorage_FileTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorage_FileTable.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorage_FileTable proto.InternalMessageInfo

// RetryTracingEvent is the trace recording used to track retries.
type RetryTracingEvent struct {
	Operation     string `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation,omitempty"`
	AttemptNumber int32  `protobuf:"varint,2,opt,name=attempt_number,json=attemptNumber,proto3" json:"attempt_number,omitempty"`
	RetryError    string `protobuf:"bytes,3,opt,name=retry_error,json=retryError,proto3" json:"retry_error,omitempty"`
}

func (m *RetryTracingEvent) Reset()         { *m = RetryTracingEvent{} }
func (m *RetryTracingEvent) String() string { return proto.CompactTextString(m) }
func (*RetryTracingEvent) ProtoMessage()    {}
func (*RetryTracingEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{71}
}
func (m *RetryTracingEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryTracingEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryTracingEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryTracingEvent.Merge(m, src)
}
func (m *RetryTracingEvent) XXX_Size() int {
	return m.Size()
}
func (m *RetryTracingEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryTracingEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RetryTracingEvent proto.InternalMessageInfo

// FileEncryptionOptions stores information needed by KV level requests (egs:
// ExportRequest) to encrypt or decrypt data.
type FileEncryptionOptions struct {
	// Key specifies the key to use for encryption or decryption.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *FileEncryptionOptions) Reset()         { *m = FileEncryptionOptions{} }
func (m *FileEncryptionOptions) String() string { return proto.CompactTextString(m) }
func (*FileEncryptionOptions) ProtoMessage()    {}
func (*FileEncryptionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{72}
}
func (m *FileEncryptionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileEncryptionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileEncryptionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileEncryptionOptions.Merge(m, src)
}
func (m *FileEncryptionOptions) XXX_Size() int {
	return m.Size()
}
func (m *FileEncryptionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_FileEncryptionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_FileEncryptionOptions proto.InternalMessageInfo

// ExportRequest is the argument to the Export() method, to dump a keyrange into
// files under a basepath.
type ExportRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Storage       ExternalStorage `protobuf:"bytes,2,opt,name=storage,proto3" json:"storage"`
	StartTime     hlc.Timestamp   `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	MVCCFilter    MVCCFilter      `protobuf:"varint,4,opt,name=mvcc_filter,json=mvccFilter,proto3,enum=cockroach.roachpb.MVCCFilter" json:"mvcc_filter,omitempty"`
	// Return the exported SST data in the response.
	ReturnSST bool `protobuf:"varint,5,opt,name=return_sst,json=returnSst,proto3" json:"return_sst,omitempty"`
	// EnableTimeBoundIteratorOptimization, if true, enables a performance
	// optimization that allows us to entirely skip over sstables in RocksDB that
	// don't have data relevant to the time bounds in this request.
	//
	// This can have a dramatic impact on performance, but we've seen a number of
	// extremely subtle and hard to detect correctness issues with this (see
	// #28358 #34819). As a result, we've decided to skip the optimization
	// everywhere that it isn't absolutely necessary for the feature to work
	// (leaving one place: poller-based changefeeds, which are being phased out
	// anyway). This will both give increased confidence in correctness as well as
	// eliminate any need to investigate time-bound iterators when/if someone hits
	// a correctness bug.
	EnableTimeBoundIteratorOptimization bool `protobuf:"varint,7,opt,name=enable_time_bound_iterator_optimization,json=enableTimeBoundIteratorOptimization,proto3" json:"enable_time_bound_iterator_optimization,omitempty"`
	// StorageByLocalityKV is a map of locality KVs to storage configurations. If
	// set, files will be written to the store that matches the most specific
	// locality KV in the map.
	StorageByLocalityKV map[string]*ExternalStorage `protobuf:"bytes,8,rep,name=storage_by_locality_kv,json=storageByLocalityKv,proto3" json:"storage_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Encryption          *FileEncryptionOptions      `protobuf:"bytes,9,opt,name=encryption,proto3" json:"encryption,omitempty"`
	// TargetFileSize is the byte size target for individual files in the
	// response. If the MVCCFilter is Latest, the returned files will only be
	// larger than this value if an individual KV pair is larger than this value.
	// If the MVCCFilter is All then the file may exceed this value by at most the
	// size of all versions of a single key. If TargetFileSize is non-positive
	// then there is no limit.
	TargetFileSize int64 `protobuf:"varint,10,opt,name=target_file_size,json=targetFileSize,proto3" json:"target_file_size,omitempty"`
	// ReturnSSTBelowSize is the threshold which (if non-zero) causes files which
	// are below that size threshold to be returned, as if ReturnSST were set,
	// instead of being written to the assigned storage location.
	// Note: returned SSTs are never encrypted.
	ReturnSstBelowSize int64 `protobuf:"varint,11,opt,name=return_sst_below_size,json=returnSstBelowSize,proto3" json:"return_sst_below_size,omitempty"`
}

func (m *ExportRequest) Reset()         { *m = ExportRequest{} }
func (m *ExportRequest) String() string { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()    {}
func (*ExportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{73}
}
func (m *ExportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportRequest.Merge(m, src)
}
func (m *ExportRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportRequest proto.InternalMessageInfo

// BulkOpSummary summarizes the data processed by an operation, counting the
// total size as well as number of entries processed in each index (from which
// row counts can be derived).
type BulkOpSummary struct {
	// DataSize is the sum of key and value lengths.
	DataSize int64 `protobuf:"varint,1,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	// DeprecatedRows contained the row count when "rows" were always defined as
	// entries in the index with ID 1, however since 20.1 and the introduction of
	// PK changes, the low-level counters that produce BulkOpSummaries are unable
	// to assume which index is primary and thus cannot distinguish "rows" vs
	// "index entries". Callers wishing to get a "row count" from a BulkOpSummary
	// should use EntryCounts instead, fetching the count for the table/index that
	// corresponds to the PK.
	DeprecatedRows int64 `protobuf:"varint,2,opt,name=deprecated_rows,json=deprecatedRows,proto3" json:"deprecated_rows,omitempty"`
	// DeprecatedIndexEntries contained the index entry count prior to 20.1. See
	// the comment on DeprecatedRows for details.
	DeprecatedIndexEntries int64 `protobuf:"varint,3,opt,name=deprecated_index_entries,json=deprecatedIndexEntries,proto3" json:"deprecated_index_entries,omitempty"`
	// EntryCounts contains the number of keys processed for each tableID/indexID
	// pair, stored under the key (tableID << 32) | indexID. This EntryCount key
	// generation logic is also available in the BulkOpSummaryID helper.
	EntryCounts map[uint64]int64 `protobuf:"bytes,5,rep,name=entry_counts,json=entryCounts,proto3" json:"entry_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *BulkOpSummary) Reset()         { *m = BulkOpSummary{} }
func (m *BulkOpSummary) String() string { return proto.CompactTextString(m) }
func (*BulkOpSummary) ProtoMessage()    {}
func (*BulkOpSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{74}
}
func (m *BulkOpSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkOpSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BulkOpSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkOpSummary.Merge(m, src)
}
func (m *BulkOpSummary) XXX_Size() int {
	return m.Size()
}
func (m *BulkOpSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkOpSummary.DiscardUnknown(m)
}

var xxx_messageInfo_BulkOpSummary proto.InternalMessageInfo

// ExportResponse is the response to an Export() operation.
type ExportResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Files          []ExportResponse_File `protobuf:"bytes,2,rep,name=files,proto3" json:"files"`
	StartTime      hlc.Timestamp         `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
}

func (m *ExportResponse) Reset()         { *m = ExportResponse{} }
func (m *ExportResponse) String() string { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()    {}
func (*ExportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{75}
}
func (m *ExportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse.Merge(m, src)
}
func (m *ExportResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse proto.InternalMessageInfo

// File describes a keyrange that has been dumped to a file at the given
// path.
type ExportResponse_File struct {
	Span       Span          `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	Path       string        `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Exported   BulkOpSummary `protobuf:"bytes,6,opt,name=exported,proto3" json:"exported"`
	SST        []byte        `protobuf:"bytes,7,opt,name=sst,proto3" json:"sst,omitempty"`
	LocalityKV string        `protobuf:"bytes,8,opt,name=locality_kv,json=localityKv,proto3" json:"locality_kv,omitempty"`
}

func (m *ExportResponse_File) Reset()         { *m = ExportResponse_File{} }
func (m *ExportResponse_File) String() string { return proto.CompactTextString(m) }
func (*ExportResponse_File) ProtoMessage()    {}
func (*ExportResponse_File) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{75, 0}
}
func (m *ExportResponse_File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportResponse_File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportResponse_File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportResponse_File.Merge(m, src)
}
func (m *ExportResponse_File) XXX_Size() int {
	return m.Size()
}
func (m *ExportResponse_File) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportResponse_File.DiscardUnknown(m)
}

var xxx_messageInfo_ExportResponse_File proto.InternalMessageInfo

// AdminScatterRequest is the argument to the AdminScatter() method, which moves
// replicas and leaseholders for a selection of ranges. Scatter is best-effort;
// ranges that cannot be moved will include an error detail in the response and
// won't fail the request.
type AdminScatterRequest struct {
	RequestHeader   `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	RandomizeLeases bool `protobuf:"varint,2,opt,name=randomize_leases,json=randomizeLeases,proto3" json:"randomize_leases,omitempty"`
}

func (m *AdminScatterRequest) Reset()         { *m = AdminScatterRequest{} }
func (m *AdminScatterRequest) String() string { return proto.CompactTextString(m) }
func (*AdminScatterRequest) ProtoMessage()    {}
func (*AdminScatterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{76}
}
func (m *AdminScatterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterRequest.Merge(m, src)
}
func (m *AdminScatterRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterRequest proto.InternalMessageInfo

// ScatterResponse is the response to a Scatter() operation.
type AdminScatterResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	RangeInfos     []RangeInfo `protobuf:"bytes,3,rep,name=range_infos,json=rangeInfos,proto3" json:"range_infos"`
}

func (m *AdminScatterResponse) Reset()         { *m = AdminScatterResponse{} }
func (m *AdminScatterResponse) String() string { return proto.CompactTextString(m) }
func (*AdminScatterResponse) ProtoMessage()    {}
func (*AdminScatterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{77}
}
func (m *AdminScatterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterResponse.Merge(m, src)
}
func (m *AdminScatterResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterResponse proto.InternalMessageInfo

type AdminScatterResponse_Range struct {
	Span Span `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
}

func (m *AdminScatterResponse_Range) Reset()         { *m = AdminScatterResponse_Range{} }
func (m *AdminScatterResponse_Range) String() string { return proto.CompactTextString(m) }
func (*AdminScatterResponse_Range) ProtoMessage()    {}
func (*AdminScatterResponse_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{77, 0}
}
func (m *AdminScatterResponse_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminScatterResponse_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminScatterResponse_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminScatterResponse_Range.Merge(m, src)
}
func (m *AdminScatterResponse_Range) XXX_Size() int {
	return m.Size()
}
func (m *AdminScatterResponse_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminScatterResponse_Range.DiscardUnknown(m)
}

var xxx_messageInfo_AdminScatterResponse_Range proto.InternalMessageInfo

// AdminVerifyProtectedTimestampRequest is the argument to the
// AdminVerifyProtectedTimestamp method which ensures that the specified record
// will be seen before data can be garbage collected at the timestamp.
type AdminVerifyProtectedTimestampRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// RecordID is the ID of the protected timestamp Record being verified.
	RecordID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,4,opt,name=record_id,json=recordId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"record_id"`
	// Protected is the timestamp at which the record with RecordID protects.
	Protected hlc.Timestamp `protobuf:"bytes,2,opt,name=protected,proto3" json:"protected"`
	// RecordAliveAt is a an hlc timestamp at which the record being verified is
	// known to exist. A value for RecordAliveAt is generally determined by
	// reading a Record from the database and using the timestamp at which that
	// read occurred.
	RecordAliveAt hlc.Timestamp `protobuf:"bytes,3,opt,name=record_alive_at,json=recordAliveAt,proto3" json:"record_alive_at"`
}

func (m *AdminVerifyProtectedTimestampRequest) Reset()         { *m = AdminVerifyProtectedTimestampRequest{} }
func (m *AdminVerifyProtectedTimestampRequest) String() string { return proto.CompactTextString(m) }
func (*AdminVerifyProtectedTimestampRequest) ProtoMessage()    {}
func (*AdminVerifyProtectedTimestampRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{78}
}
func (m *AdminVerifyProtectedTimestampRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminVerifyProtectedTimestampRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminVerifyProtectedTimestampRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminVerifyProtectedTimestampRequest.Merge(m, src)
}
func (m *AdminVerifyProtectedTimestampRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminVerifyProtectedTimestampRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminVerifyProtectedTimestampRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminVerifyProtectedTimestampRequest proto.InternalMessageInfo

// AdminVerifyProtectedTimestampResponse is the argument to the
// AdminVerifyProtectedTimestamp method which ensures that the specified record
// will be seen before data can be garbage collected at the timestamp.
type AdminVerifyProtectedTimestampResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Verified       bool `protobuf:"varint,2,opt,name=verified,proto3" json:"verified,omitempty"`
	// TODO(adityamaru): Remove in 21.2.
	DeprecatedFailedRanges   []RangeDescriptor                                   `protobuf:"bytes,3,rep,name=deprecated_failed_ranges,json=deprecatedFailedRanges,proto3" json:"deprecated_failed_ranges"`
	VerificationFailedRanges []AdminVerifyProtectedTimestampResponse_FailedRange `protobuf:"bytes,4,rep,name=verification_failed_ranges,json=verificationFailedRanges,proto3" json:"verification_failed_ranges"`
}

func (m *AdminVerifyProtectedTimestampResponse) Reset()         { *m = AdminVerifyProtectedTimestampResponse{} }
func (m *AdminVerifyProtectedTimestampResponse) String() string { return proto.CompactTextString(m) }
func (*AdminVerifyProtectedTimestampResponse) ProtoMessage()    {}
func (*AdminVerifyProtectedTimestampResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{79}
}
func (m *AdminVerifyProtectedTimestampResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminVerifyProtectedTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminVerifyProtectedTimestampResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminVerifyProtectedTimestampResponse.Merge(m, src)
}
func (m *AdminVerifyProtectedTimestampResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminVerifyProtectedTimestampResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminVerifyProtectedTimestampResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminVerifyProtectedTimestampResponse proto.InternalMessageInfo

type AdminVerifyProtectedTimestampResponse_FailedRange struct {
	RangeID  int64  `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	StartKey RKey   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=RKey" json:"start_key,omitempty"`
	EndKey   RKey   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3,casttype=RKey" json:"end_key,omitempty"`
	Reason   string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *AdminVerifyProtectedTimestampResponse_FailedRange) Reset() {
	*m = AdminVerifyProtectedTimestampResponse_FailedRange{}
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) String() string {
	return proto.CompactTextString(m)
}
func (*AdminVerifyProtectedTimestampResponse_FailedRange) ProtoMessage() {}
func (*AdminVerifyProtectedTimestampResponse_FailedRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{79, 0}
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminVerifyProtectedTimestampResponse_FailedRange.Merge(m, src)
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) XXX_Size() int {
	return m.Size()
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminVerifyProtectedTimestampResponse_FailedRange.DiscardUnknown(m)
}

var xxx_messageInfo_AdminVerifyProtectedTimestampResponse_FailedRange proto.InternalMessageInfo

// AddSSTableRequest is arguments to the AddSSTable() method, to link a file
// into the RocksDB log-structured merge-tree.
type AddSSTableRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// If set, indicates that AddSSTable will not allow ingestion of keys which
	// shadow already existing key entries. This disallows any key slice overlap
	// regardless of the timestamps.
	DisallowShadowing bool `protobuf:"varint,3,opt,name=disallow_shadowing,json=disallowShadowing,proto3" json:"disallow_shadowing,omitempty"`
	// MVCCStats, if set, is the MVCCStats for the contents of this SSTable and is
	// used as-is during evaluation of the AddSSTable command to update the range
	// MVCCStats, instead of computing the stats for the SSTable by iterating it.
	// Including these stats can make the evaluation of AddSSTable much cheaper.
	MVCCStats *enginepb.MVCCStats `protobuf:"bytes,4,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats,omitempty"`
	// IngestAsWrites causes the content of the provided SSTable to be ingested in
	// a regular WriteBatch, instead of directly adding the provided SST to the
	// storage engine. This is useful if the data size is so small that the fixed
	// costs of adding an extra file (file IO, triggering a flush, compactions)
	// would be higher than the marginal costs of the amount of data going though
	// the usual write pipeline (on-disk raft log, WAL, etc).
	// TODO(dt): https://github.com/cockroachdb/cockroach/issues/34579#issuecomment-544627193
	IngestAsWrites bool `protobuf:"varint,5,opt,name=ingest_as_writes,json=ingestAsWrites,proto3" json:"ingest_as_writes,omitempty"`
}

func (m *AddSSTableRequest) Reset()         { *m = AddSSTableRequest{} }
func (m *AddSSTableRequest) String() string { return proto.CompactTextString(m) }
func (*AddSSTableRequest) ProtoMessage()    {}
func (*AddSSTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{80}
}
func (m *AddSSTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddSSTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddSSTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSSTableRequest.Merge(m, src)
}
func (m *AddSSTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddSSTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSSTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddSSTableRequest proto.InternalMessageInfo

// AddSSTableResponse is the response to a AddSSTable() operation.
type AddSSTableResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *AddSSTableResponse) Reset()         { *m = AddSSTableResponse{} }
func (m *AddSSTableResponse) String() string { return proto.CompactTextString(m) }
func (*AddSSTableResponse) ProtoMessage()    {}
func (*AddSSTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{81}
}
func (m *AddSSTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddSSTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AddSSTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSSTableResponse.Merge(m, src)
}
func (m *AddSSTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddSSTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSSTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddSSTableResponse proto.InternalMessageInfo

// RefreshRequest is arguments to the Refresh() method, which verifies that no
// write has occurred since the refresh_from timestamp to the specified key.
// The timestamp cache is updated. A transaction must be supplied with this
// request. If the key has been written more recently than the provided txn
// timestamp, an error is returned and the timestamp cache is not updated.
//
// The timestamp cache is updated to txn.read_timestamp, like it is for all
// requests.
type RefreshRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// refresh_from specifies the lower-bound of the verification. The request verifies that
	// there's no write in the range [refresh_from, txn.read_timestamp].
	RefreshFrom hlc.Timestamp `protobuf:"bytes,3,opt,name=refresh_from,json=refreshFrom,proto3" json:"refresh_from"`
}

func (m *RefreshRequest) Reset()         { *m = RefreshRequest{} }
func (m *RefreshRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshRequest) ProtoMessage()    {}
func (*RefreshRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{82}
}
func (m *RefreshRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRequest.Merge(m, src)
}
func (m *RefreshRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRequest proto.InternalMessageInfo

// RefreshResponse is the response to a Refresh() operation.
type RefreshResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RefreshResponse) Reset()         { *m = RefreshResponse{} }
func (m *RefreshResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshResponse) ProtoMessage()    {}
func (*RefreshResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{83}
}
func (m *RefreshResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshResponse.Merge(m, src)
}
func (m *RefreshResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshResponse proto.InternalMessageInfo

// RefreshRangeRequest is arguments to the RefreshRange() method, which
// is similar to RefreshRequest (see comments above), but operates on
// a key span instead of a single key.
type RefreshRangeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// refresh_from specifies the lower-bound of the verification. The request verifies that
	// there's no write in the range [refresh_from, txn.read_timestamp].
	RefreshFrom hlc.Timestamp `protobuf:"bytes,3,opt,name=refresh_from,json=refreshFrom,proto3" json:"refresh_from"`
}

func (m *RefreshRangeRequest) Reset()         { *m = RefreshRangeRequest{} }
func (m *RefreshRangeRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshRangeRequest) ProtoMessage()    {}
func (*RefreshRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{84}
}
func (m *RefreshRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRangeRequest.Merge(m, src)
}
func (m *RefreshRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRangeRequest proto.InternalMessageInfo

// RefreshRangeResponse is the response to a RefreshRange() operation.
type RefreshRangeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RefreshRangeResponse) Reset()         { *m = RefreshRangeResponse{} }
func (m *RefreshRangeResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshRangeResponse) ProtoMessage()    {}
func (*RefreshRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{85}
}
func (m *RefreshRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RefreshRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRangeResponse.Merge(m, src)
}
func (m *RefreshRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRangeResponse proto.InternalMessageInfo

// SubsumeRequest is the argument to the Subsume() method, which freezes a range
// for merging with its left-hand neighbor.
//
// Subsume, when called correctly, provides important guarantees that ensure
// there is no moment in time where the ranges involved in the merge could both
// process commands for the same keys. See the comment on Subsume for details.
//
// Subsume may return stale MVCC statistics when used outside of a merge
// transaction. As a rule of thumb, it is incorrect to call Subsume, except from
// its carefully-chosen location within a merge transaction.
type SubsumeRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// The range descriptor for the left-hand side of the merge. Used by the
	// right-hand side to sanity-check the validity of the merge.
	LeftDesc RangeDescriptor `protobuf:"bytes,2,opt,name=left_desc,json=leftDesc,proto3" json:"left_desc"`
	// The range descriptor for the right-hand side of the merge. Should match
	// the range descriptor of the range evaluating this request.
	RightDesc RangeDescriptor `protobuf:"bytes,3,opt,name=right_desc,json=rightDesc,proto3" json:"right_desc"`
}

func (m *SubsumeRequest) Reset()         { *m = SubsumeRequest{} }
func (m *SubsumeRequest) String() string { return proto.CompactTextString(m) }
func (*SubsumeRequest) ProtoMessage()    {}
func (*SubsumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{86}
}
func (m *SubsumeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubsumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubsumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumeRequest.Merge(m, src)
}
func (m *SubsumeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubsumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumeRequest proto.InternalMessageInfo

// SubsumeResponse is the response to a SubsumeRequest.
type SubsumeResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// MVCCStats are the MVCC statistics for the range.
	MVCCStats enginepb.MVCCStats `protobuf:"bytes,3,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats"`
	// LeaseAppliedIndex is the lease applied index of the last applied command
	// at the time that the Subsume request executed. This is NOT intended to be
	// the lease index of the SubsumeRequest itself. Instead, it is intended to
	// provide the sender of the Subsume request with an upper bound on the lease
	// applied index of the CPut that left an intent on the local copy of the
	// right-hand range descriptor.
	LeaseAppliedIndex uint64 `protobuf:"varint,4,opt,name=lease_applied_index,json=leaseAppliedIndex,proto3" json:"lease_applied_index,omitempty"`
	// FreezeStart is a timestamp that is guaranteed to be greater than the
	// timestamps at which any requests were serviced by the responding replica
	// before it stopped responding to requests altogether (in anticipation of
	// being subsumed). It is suitable for use as the timestamp cache's low water
	// mark for the keys previously owned by the subsumed range though this role
	// is largely being... subsumed by the RightReadSummary.
	FreezeStart github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=freeze_start,json=freezeStart,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"freeze_start"`
	// closed_timestamp is the range's closed timestamp at the moment of the
	// subsumption. Because the SubsumeRequest synchronizes with all other
	// requests, the range's closed timestamp does not advance past the snapshot
	// captured here.
	//
	// Like the freeze_start, this is used by the merged range to conditionally
	// bump the timestamp cache for the keys previously owned by the subsumed
	// range.
	//
	// Note that the closed timestamp is also reflected in the read_summary.
	// However, we carry it explicitly too because, in case the leaseholders of
	// the two sides are collocated at merge time, we don't need to use the
	// read_summary and simply use this field.
	ClosedTimestamp hlc.Timestamp `protobuf:"bytes,6,opt,name=closed_timestamp,json=closedTimestamp,proto3" json:"closed_timestamp"`
	// ReadSummary is a summary of the reads that have been performed on the range
	// up to the point of the Subsume request, which serializes with past reads
	// and begins blocking future reads. It is suitable for use to update the
	// timestamp cache for the keys previously owned by the subsumed range.
	//
	// ReadSummary can be used in place of FreezeStart, when available. It has two
	// distinct advantages:
	// 1. it can transfer a higher-resolution snapshot of the reads on the range
	//    through a range merge, to make the merge less disruptive to writes on
	//    the post-merge range because the timestamp cache won't be bumped as
	//    high.
	// 2. it can transfer information about reads with synthetic timestamps, which
	//    are not otherwise captured by the FreezeStart clock timestamp.
	ReadSummary *rspb.ReadSummary `protobuf:"bytes,7,opt,name=read_summary,json=readSummary,proto3" json:"read_summary,omitempty"`
}

func (m *SubsumeResponse) Reset()         { *m = SubsumeResponse{} }
func (m *SubsumeResponse) String() string { return proto.CompactTextString(m) }
func (*SubsumeResponse) ProtoMessage()    {}
func (*SubsumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{87}
}
func (m *SubsumeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubsumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubsumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubsumeResponse.Merge(m, src)
}
func (m *SubsumeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubsumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubsumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubsumeResponse proto.InternalMessageInfo

// RangeStatsRequest is the argument to the RangeStats() method. It requests the
// MVCC statistics of the receiving range.
type RangeStatsRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *RangeStatsRequest) Reset()         { *m = RangeStatsRequest{} }
func (m *RangeStatsRequest) String() string { return proto.CompactTextString(m) }
func (*RangeStatsRequest) ProtoMessage()    {}
func (*RangeStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{88}
}
func (m *RangeStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatsRequest.Merge(m, src)
}
func (m *RangeStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatsRequest proto.InternalMessageInfo

// RangeStatsResponse is the response to a RangeStatsRequest.
type RangeStatsResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// MVCCStats are the MVCC statistics for the range that processed the
	// request.
	MVCCStats enginepb.MVCCStats `protobuf:"bytes,2,opt,name=mvcc_stats,json=mvccStats,proto3" json:"mvcc_stats"`
	// DeprecatedLastQueriesPerSecond is the most recent rate of request/s or QPS
	// for the range. The field is deprecated in favor of MaxQueriesPerSecond.
	//
	// TODO(nvanbenschoten): remove this field in v22.1 when all nodes in the
	// cluster are guaranteed to return MaxQueriesPerSecond.
	DeprecatedLastQueriesPerSecond float64 `protobuf:"fixed64,3,opt,name=deprecated_last_queries_per_second,json=deprecatedLastQueriesPerSecond,proto3" json:"deprecated_last_queries_per_second,omitempty"`
	// MaxQueriesPerSecond is the maximum rate of request/s or QPS that the range
	// has served over a configured measurement period. Set to -1 if the replica
	// serving the RangeStats request has not been the leaseholder long enough to
	// have recorded request rates for at least a full measurement period. In such
	// cases, the recipient should not consider the QPS value reliable enough to
	// base important decisions off of.
	MaxQueriesPerSecond float64 `protobuf:"fixed64,5,opt,name=max_queries_per_second,json=maxQueriesPerSecond,proto3" json:"max_queries_per_second,omitempty"`
	// MaxQueriesPerSecondSet indicates that the MaxQueriesPerSecond field is set
	// by the server. Used to distinguish 0 qps set by a new server from the field
	// not being set at all by an old server.
	//
	// TODO(nvanbenschoten): stop consulting this field on the receiver in v22.1
	// when all nodes in the cluster are guaranteed to return MaxQueriesPerSecond.
	//
	// TODO(nvanbenschoten): stop setting this field and remove it in v22.2 when
	// no nodes in the cluster consult this field.
	MaxQueriesPerSecondSet bool `protobuf:"varint,6,opt,name=max_queries_per_second_set,json=maxQueriesPerSecondSet,proto3" json:"max_queries_per_second_set,omitempty"`
	// range_info contains descriptor and lease information.
	RangeInfo RangeInfo `protobuf:"bytes,4,opt,name=range_info,json=rangeInfo,proto3" json:"range_info"`
}

func (m *RangeStatsResponse) Reset()         { *m = RangeStatsResponse{} }
func (m *RangeStatsResponse) String() string { return proto.CompactTextString(m) }
func (*RangeStatsResponse) ProtoMessage()    {}
func (*RangeStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{89}
}
func (m *RangeStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatsResponse.Merge(m, src)
}
func (m *RangeStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatsResponse proto.InternalMessageInfo

// MigrateRequest is used instruct all ranges overlapping with it to exercise
// any relevant (below-raft) migrations in order for its range state to conform
// to what's needed by the specified version. It's a core primitive used in our
// migrations infrastructure to phase out legacy code below raft.
//
// KV waits for this command to durably apply on all replicas before returning,
// guaranteeing to the caller that all pre-migration state has been completely
// purged from the system.
type MigrateRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// Version is used to select the specific migration to exercise.
	Version Version `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *MigrateRequest) Reset()         { *m = MigrateRequest{} }
func (m *MigrateRequest) String() string { return proto.CompactTextString(m) }
func (*MigrateRequest) ProtoMessage()    {}
func (*MigrateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{90}
}
func (m *MigrateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MigrateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateRequest.Merge(m, src)
}
func (m *MigrateRequest) XXX_Size() int {
	return m.Size()
}
func (m *MigrateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateRequest proto.InternalMessageInfo

// MigrateResponse is the response to a Migrate operation.
type MigrateResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
}

func (m *MigrateResponse) Reset()         { *m = MigrateResponse{} }
func (m *MigrateResponse) String() string { return proto.CompactTextString(m) }
func (*MigrateResponse) ProtoMessage()    {}
func (*MigrateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{91}
}
func (m *MigrateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MigrateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateResponse.Merge(m, src)
}
func (m *MigrateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MigrateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateResponse proto.InternalMessageInfo

// A RequestUnion contains exactly one of the requests.
// The values added here must match those in ResponseUnion.
//
// Be cautious about deprecating fields as doing so can lead to inconsistencies
// between replicas.
type RequestUnion struct {
	// Types that are valid to be assigned to Value:
	//	*RequestUnion_Get
	//	*RequestUnion_Put
	//	*RequestUnion_ConditionalPut
	//	*RequestUnion_Increment
	//	*RequestUnion_Delete
	//	*RequestUnion_DeleteRange
	//	*RequestUnion_ClearRange
	//	*RequestUnion_RevertRange
	//	*RequestUnion_Scan
	//	*RequestUnion_EndTxn
	//	*RequestUnion_AdminSplit
	//	*RequestUnion_AdminUnsplit
	//	*RequestUnion_AdminMerge
	//	*RequestUnion_AdminTransferLease
	//	*RequestUnion_AdminChangeReplicas
	//	*RequestUnion_AdminRelocateRange
	//	*RequestUnion_HeartbeatTxn
	//	*RequestUnion_Gc
	//	*RequestUnion_PushTxn
	//	*RequestUnion_RecoverTxn
	//	*RequestUnion_ResolveIntent
	//	*RequestUnion_ResolveIntentRange
	//	*RequestUnion_Merge
	//	*RequestUnion_TruncateLog
	//	*RequestUnion_RequestLease
	//	*RequestUnion_ReverseScan
	//	*RequestUnion_ComputeChecksum
	//	*RequestUnion_CheckConsistency
	//	*RequestUnion_InitPut
	//	*RequestUnion_TransferLease
	//	*RequestUnion_LeaseInfo
	//	*RequestUnion_Export
	//	*RequestUnion_QueryTxn
	//	*RequestUnion_QueryIntent
	//	*RequestUnion_AdminScatter
	//	*RequestUnion_AddSstable
	//	*RequestUnion_RecomputeStats
	//	*RequestUnion_Refresh
	//	*RequestUnion_RefreshRange
	//	*RequestUnion_Subsume
	//	*RequestUnion_RangeStats
	//	*RequestUnion_AdminVerifyProtectedTimestamp
	//	*RequestUnion_Migrate
	Value isRequestUnion_Value `protobuf_oneof:"value"`
}

func (m *RequestUnion) Reset()         { *m = RequestUnion{} }
func (m *RequestUnion) String() string { return proto.CompactTextString(m) }
func (*RequestUnion) ProtoMessage()    {}
func (*RequestUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{92}
}
func (m *RequestUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RequestUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestUnion.Merge(m, src)
}
func (m *RequestUnion) XXX_Size() int {
	return m.Size()
}
func (m *RequestUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestUnion.DiscardUnknown(m)
}

var xxx_messageInfo_RequestUnion proto.InternalMessageInfo

type isRequestUnion_Value interface {
	isRequestUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RequestUnion_Get struct {
	Get *GetRequest `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type RequestUnion_Put struct {
	Put *PutRequest `protobuf:"bytes,2,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type RequestUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutRequest `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof" json:"conditional_put,omitempty"`
}
type RequestUnion_Increment struct {
	Increment *IncrementRequest `protobuf:"bytes,4,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type RequestUnion_Delete struct {
	Delete *DeleteRequest `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type RequestUnion_DeleteRange struct {
	DeleteRange *DeleteRangeRequest `protobuf:"bytes,6,opt,name=delete_range,json=deleteRange,proto3,oneof" json:"delete_range,omitempty"`
}
type RequestUnion_ClearRange struct {
	ClearRange *ClearRangeRequest `protobuf:"bytes,38,opt,name=clear_range,json=clearRange,proto3,oneof" json:"clear_range,omitempty"`
}
type RequestUnion_RevertRange struct {
	RevertRange *RevertRangeRequest `protobuf:"bytes,48,opt,name=revert_range,json=revertRange,proto3,oneof" json:"revert_range,omitempty"`
}
type RequestUnion_Scan struct {
	Scan *ScanRequest `protobuf:"bytes,7,opt,name=scan,proto3,oneof" json:"scan,omitempty"`
}
type RequestUnion_EndTxn struct {
	EndTxn *EndTxnRequest `protobuf:"bytes,9,opt,name=end_txn,json=endTxn,proto3,oneof" json:"end_txn,omitempty"`
}
type RequestUnion_AdminSplit struct {
	AdminSplit *AdminSplitRequest `protobuf:"bytes,10,opt,name=admin_split,json=adminSplit,proto3,oneof" json:"admin_split,omitempty"`
}
type RequestUnion_AdminUnsplit struct {
	AdminUnsplit *AdminUnsplitRequest `protobuf:"bytes,47,opt,name=admin_unsplit,json=adminUnsplit,proto3,oneof" json:"admin_unsplit,omitempty"`
}
type RequestUnion_AdminMerge struct {
	AdminMerge *AdminMergeRequest `protobuf:"bytes,11,opt,name=admin_merge,json=adminMerge,proto3,oneof" json:"admin_merge,omitempty"`
}
type RequestUnion_AdminTransferLease struct {
	AdminTransferLease *AdminTransferLeaseRequest `protobuf:"bytes,29,opt,name=admin_transfer_lease,json=adminTransferLease,proto3,oneof" json:"admin_transfer_lease,omitempty"`
}
type RequestUnion_AdminChangeReplicas struct {
	AdminChangeReplicas *AdminChangeReplicasRequest `protobuf:"bytes,35,opt,name=admin_change_replicas,json=adminChangeReplicas,proto3,oneof" json:"admin_change_replicas,omitempty"`
}
type RequestUnion_AdminRelocateRange struct {
	AdminRelocateRange *AdminRelocateRangeRequest `protobuf:"bytes,45,opt,name=admin_relocate_range,json=adminRelocateRange,proto3,oneof" json:"admin_relocate_range,omitempty"`
}
type RequestUnion_HeartbeatTxn struct {
	HeartbeatTxn *HeartbeatTxnRequest `protobuf:"bytes,12,opt,name=heartbeat_txn,json=heartbeatTxn,proto3,oneof" json:"heartbeat_txn,omitempty"`
}
type RequestUnion_Gc struct {
	Gc *GCRequest `protobuf:"bytes,13,opt,name=gc,proto3,oneof" json:"gc,omitempty"`
}
type RequestUnion_PushTxn struct {
	PushTxn *PushTxnRequest `protobuf:"bytes,14,opt,name=push_txn,json=pushTxn,proto3,oneof" json:"push_txn,omitempty"`
}
type RequestUnion_RecoverTxn struct {
	RecoverTxn *RecoverTxnRequest `protobuf:"bytes,46,opt,name=recover_txn,json=recoverTxn,proto3,oneof" json:"recover_txn,omitempty"`
}
type RequestUnion_ResolveIntent struct {
	ResolveIntent *ResolveIntentRequest `protobuf:"bytes,16,opt,name=resolve_intent,json=resolveIntent,proto3,oneof" json:"resolve_intent,omitempty"`
}
type RequestUnion_ResolveIntentRange struct {
	ResolveIntentRange *ResolveIntentRangeRequest `protobuf:"bytes,17,opt,name=resolve_intent_range,json=resolveIntentRange,proto3,oneof" json:"resolve_intent_range,omitempty"`
}
type RequestUnion_Merge struct {
	Merge *MergeRequest `protobuf:"bytes,18,opt,name=merge,proto3,oneof" json:"merge,omitempty"`
}
type RequestUnion_TruncateLog struct {
	TruncateLog *TruncateLogRequest `protobuf:"bytes,19,opt,name=truncate_log,json=truncateLog,proto3,oneof" json:"truncate_log,omitempty"`
}
type RequestUnion_RequestLease struct {
	RequestLease *RequestLeaseRequest `protobuf:"bytes,20,opt,name=request_lease,json=requestLease,proto3,oneof" json:"request_lease,omitempty"`
}
type RequestUnion_ReverseScan struct {
	ReverseScan *ReverseScanRequest `protobuf:"bytes,21,opt,name=reverse_scan,json=reverseScan,proto3,oneof" json:"reverse_scan,omitempty"`
}
type RequestUnion_ComputeChecksum struct {
	ComputeChecksum *ComputeChecksumRequest `protobuf:"bytes,22,opt,name=compute_checksum,json=computeChecksum,proto3,oneof" json:"compute_checksum,omitempty"`
}
type RequestUnion_CheckConsistency struct {
	CheckConsistency *CheckConsistencyRequest `protobuf:"bytes,24,opt,name=check_consistency,json=checkConsistency,proto3,oneof" json:"check_consistency,omitempty"`
}
type RequestUnion_InitPut struct {
	InitPut *InitPutRequest `protobuf:"bytes,26,opt,name=init_put,json=initPut,proto3,oneof" json:"init_put,omitempty"`
}
type RequestUnion_TransferLease struct {
	TransferLease *TransferLeaseRequest `protobuf:"bytes,28,opt,name=transfer_lease,json=transferLease,proto3,oneof" json:"transfer_lease,omitempty"`
}
type RequestUnion_LeaseInfo struct {
	LeaseInfo *LeaseInfoRequest `protobuf:"bytes,30,opt,name=lease_info,json=leaseInfo,proto3,oneof" json:"lease_info,omitempty"`
}
type RequestUnion_Export struct {
	Export *ExportRequest `protobuf:"bytes,32,opt,name=export,proto3,oneof" json:"export,omitempty"`
}
type RequestUnion_QueryTxn struct {
	QueryTxn *QueryTxnRequest `protobuf:"bytes,33,opt,name=query_txn,json=queryTxn,proto3,oneof" json:"query_txn,omitempty"`
}
type RequestUnion_QueryIntent struct {
	QueryIntent *QueryIntentRequest `protobuf:"bytes,42,opt,name=query_intent,json=queryIntent,proto3,oneof" json:"query_intent,omitempty"`
}
type RequestUnion_AdminScatter struct {
	AdminScatter *AdminScatterRequest `protobuf:"bytes,36,opt,name=admin_scatter,json=adminScatter,proto3,oneof" json:"admin_scatter,omitempty"`
}
type RequestUnion_AddSstable struct {
	AddSstable *AddSSTableRequest `protobuf:"bytes,37,opt,name=add_sstable,json=addSstable,proto3,oneof" json:"add_sstable,omitempty"`
}
type RequestUnion_RecomputeStats struct {
	RecomputeStats *RecomputeStatsRequest `protobuf:"bytes,39,opt,name=recompute_stats,json=recomputeStats,proto3,oneof" json:"recompute_stats,omitempty"`
}
type RequestUnion_Refresh struct {
	Refresh *RefreshRequest `protobuf:"bytes,40,opt,name=refresh,proto3,oneof" json:"refresh,omitempty"`
}
type RequestUnion_RefreshRange struct {
	RefreshRange *RefreshRangeRequest `protobuf:"bytes,41,opt,name=refresh_range,json=refreshRange,proto3,oneof" json:"refresh_range,omitempty"`
}
type RequestUnion_Subsume struct {
	Subsume *SubsumeRequest `protobuf:"bytes,43,opt,name=subsume,proto3,oneof" json:"subsume,omitempty"`
}
type RequestUnion_RangeStats struct {
	RangeStats *RangeStatsRequest `protobuf:"bytes,44,opt,name=range_stats,json=rangeStats,proto3,oneof" json:"range_stats,omitempty"`
}
type RequestUnion_AdminVerifyProtectedTimestamp struct {
	AdminVerifyProtectedTimestamp *AdminVerifyProtectedTimestampRequest `protobuf:"bytes,49,opt,name=admin_verify_protected_timestamp,json=adminVerifyProtectedTimestamp,proto3,oneof" json:"admin_verify_protected_timestamp,omitempty"`
}
type RequestUnion_Migrate struct {
	Migrate *MigrateRequest `protobuf:"bytes,50,opt,name=migrate,proto3,oneof" json:"migrate,omitempty"`
}

func (*RequestUnion_Get) isRequestUnion_Value()                           {}
func (*RequestUnion_Put) isRequestUnion_Value()                           {}
func (*RequestUnion_ConditionalPut) isRequestUnion_Value()                {}
func (*RequestUnion_Increment) isRequestUnion_Value()                     {}
func (*RequestUnion_Delete) isRequestUnion_Value()                        {}
func (*RequestUnion_DeleteRange) isRequestUnion_Value()                   {}
func (*RequestUnion_ClearRange) isRequestUnion_Value()                    {}
func (*RequestUnion_RevertRange) isRequestUnion_Value()                   {}
func (*RequestUnion_Scan) isRequestUnion_Value()                          {}
func (*RequestUnion_EndTxn) isRequestUnion_Value()                        {}
func (*RequestUnion_AdminSplit) isRequestUnion_Value()                    {}
func (*RequestUnion_AdminUnsplit) isRequestUnion_Value()                  {}
func (*RequestUnion_AdminMerge) isRequestUnion_Value()                    {}
func (*RequestUnion_AdminTransferLease) isRequestUnion_Value()            {}
func (*RequestUnion_AdminChangeReplicas) isRequestUnion_Value()           {}
func (*RequestUnion_AdminRelocateRange) isRequestUnion_Value()            {}
func (*RequestUnion_HeartbeatTxn) isRequestUnion_Value()                  {}
func (*RequestUnion_Gc) isRequestUnion_Value()                            {}
func (*RequestUnion_PushTxn) isRequestUnion_Value()                       {}
func (*RequestUnion_RecoverTxn) isRequestUnion_Value()                    {}
func (*RequestUnion_ResolveIntent) isRequestUnion_Value()                 {}
func (*RequestUnion_ResolveIntentRange) isRequestUnion_Value()            {}
func (*RequestUnion_Merge) isRequestUnion_Value()                         {}
func (*RequestUnion_TruncateLog) isRequestUnion_Value()                   {}
func (*RequestUnion_RequestLease) isRequestUnion_Value()                  {}
func (*RequestUnion_ReverseScan) isRequestUnion_Value()                   {}
func (*RequestUnion_ComputeChecksum) isRequestUnion_Value()               {}
func (*RequestUnion_CheckConsistency) isRequestUnion_Value()              {}
func (*RequestUnion_InitPut) isRequestUnion_Value()                       {}
func (*RequestUnion_TransferLease) isRequestUnion_Value()                 {}
func (*RequestUnion_LeaseInfo) isRequestUnion_Value()                     {}
func (*RequestUnion_Export) isRequestUnion_Value()                        {}
func (*RequestUnion_QueryTxn) isRequestUnion_Value()                      {}
func (*RequestUnion_QueryIntent) isRequestUnion_Value()                   {}
func (*RequestUnion_AdminScatter) isRequestUnion_Value()                  {}
func (*RequestUnion_AddSstable) isRequestUnion_Value()                    {}
func (*RequestUnion_RecomputeStats) isRequestUnion_Value()                {}
func (*RequestUnion_Refresh) isRequestUnion_Value()                       {}
func (*RequestUnion_RefreshRange) isRequestUnion_Value()                  {}
func (*RequestUnion_Subsume) isRequestUnion_Value()                       {}
func (*RequestUnion_RangeStats) isRequestUnion_Value()                    {}
func (*RequestUnion_AdminVerifyProtectedTimestamp) isRequestUnion_Value() {}
func (*RequestUnion_Migrate) isRequestUnion_Value()                       {}

func (m *RequestUnion) GetValue() isRequestUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RequestUnion) GetGet() *GetRequest {
	if x, ok := m.GetValue().(*RequestUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *RequestUnion) GetPut() *PutRequest {
	if x, ok := m.GetValue().(*RequestUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *RequestUnion) GetConditionalPut() *ConditionalPutRequest {
	if x, ok := m.GetValue().(*RequestUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *RequestUnion) GetIncrement() *IncrementRequest {
	if x, ok := m.GetValue().(*RequestUnion_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *RequestUnion) GetDelete() *DeleteRequest {
	if x, ok := m.GetValue().(*RequestUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *RequestUnion) GetDeleteRange() *DeleteRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_DeleteRange); ok {
		return x.DeleteRange
	}
	return nil
}

func (m *RequestUnion) GetClearRange() *ClearRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_ClearRange); ok {
		return x.ClearRange
	}
	return nil
}

func (m *RequestUnion) GetRevertRange() *RevertRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_RevertRange); ok {
		return x.RevertRange
	}
	return nil
}

func (m *RequestUnion) GetScan() *ScanRequest {
	if x, ok := m.GetValue().(*RequestUnion_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *RequestUnion) GetEndTxn() *EndTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_EndTxn); ok {
		return x.EndTxn
	}
	return nil
}

func (m *RequestUnion) GetAdminSplit() *AdminSplitRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminSplit); ok {
		return x.AdminSplit
	}
	return nil
}

func (m *RequestUnion) GetAdminUnsplit() *AdminUnsplitRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminUnsplit); ok {
		return x.AdminUnsplit
	}
	return nil
}

func (m *RequestUnion) GetAdminMerge() *AdminMergeRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminMerge); ok {
		return x.AdminMerge
	}
	return nil
}

func (m *RequestUnion) GetAdminTransferLease() *AdminTransferLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminTransferLease); ok {
		return x.AdminTransferLease
	}
	return nil
}

func (m *RequestUnion) GetAdminChangeReplicas() *AdminChangeReplicasRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminChangeReplicas); ok {
		return x.AdminChangeReplicas
	}
	return nil
}

func (m *RequestUnion) GetAdminRelocateRange() *AdminRelocateRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminRelocateRange); ok {
		return x.AdminRelocateRange
	}
	return nil
}

func (m *RequestUnion) GetHeartbeatTxn() *HeartbeatTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_HeartbeatTxn); ok {
		return x.HeartbeatTxn
	}
	return nil
}

func (m *RequestUnion) GetGc() *GCRequest {
	if x, ok := m.GetValue().(*RequestUnion_Gc); ok {
		return x.Gc
	}
	return nil
}

func (m *RequestUnion) GetPushTxn() *PushTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_PushTxn); ok {
		return x.PushTxn
	}
	return nil
}

func (m *RequestUnion) GetRecoverTxn() *RecoverTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_RecoverTxn); ok {
		return x.RecoverTxn
	}
	return nil
}

func (m *RequestUnion) GetResolveIntent() *ResolveIntentRequest {
	if x, ok := m.GetValue().(*RequestUnion_ResolveIntent); ok {
		return x.ResolveIntent
	}
	return nil
}

func (m *RequestUnion) GetResolveIntentRange() *ResolveIntentRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_ResolveIntentRange); ok {
		return x.ResolveIntentRange
	}
	return nil
}

func (m *RequestUnion) GetMerge() *MergeRequest {
	if x, ok := m.GetValue().(*RequestUnion_Merge); ok {
		return x.Merge
	}
	return nil
}

func (m *RequestUnion) GetTruncateLog() *TruncateLogRequest {
	if x, ok := m.GetValue().(*RequestUnion_TruncateLog); ok {
		return x.TruncateLog
	}
	return nil
}

func (m *RequestUnion) GetRequestLease() *RequestLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_RequestLease); ok {
		return x.RequestLease
	}
	return nil
}

func (m *RequestUnion) GetReverseScan() *ReverseScanRequest {
	if x, ok := m.GetValue().(*RequestUnion_ReverseScan); ok {
		return x.ReverseScan
	}
	return nil
}

func (m *RequestUnion) GetComputeChecksum() *ComputeChecksumRequest {
	if x, ok := m.GetValue().(*RequestUnion_ComputeChecksum); ok {
		return x.ComputeChecksum
	}
	return nil
}

func (m *RequestUnion) GetCheckConsistency() *CheckConsistencyRequest {
	if x, ok := m.GetValue().(*RequestUnion_CheckConsistency); ok {
		return x.CheckConsistency
	}
	return nil
}

func (m *RequestUnion) GetInitPut() *InitPutRequest {
	if x, ok := m.GetValue().(*RequestUnion_InitPut); ok {
		return x.InitPut
	}
	return nil
}

func (m *RequestUnion) GetTransferLease() *TransferLeaseRequest {
	if x, ok := m.GetValue().(*RequestUnion_TransferLease); ok {
		return x.TransferLease
	}
	return nil
}

func (m *RequestUnion) GetLeaseInfo() *LeaseInfoRequest {
	if x, ok := m.GetValue().(*RequestUnion_LeaseInfo); ok {
		return x.LeaseInfo
	}
	return nil
}

func (m *RequestUnion) GetExport() *ExportRequest {
	if x, ok := m.GetValue().(*RequestUnion_Export); ok {
		return x.Export
	}
	return nil
}

func (m *RequestUnion) GetQueryTxn() *QueryTxnRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryTxn); ok {
		return x.QueryTxn
	}
	return nil
}

func (m *RequestUnion) GetQueryIntent() *QueryIntentRequest {
	if x, ok := m.GetValue().(*RequestUnion_QueryIntent); ok {
		return x.QueryIntent
	}
	return nil
}

func (m *RequestUnion) GetAdminScatter() *AdminScatterRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminScatter); ok {
		return x.AdminScatter
	}
	return nil
}

func (m *RequestUnion) GetAddSstable() *AddSSTableRequest {
	if x, ok := m.GetValue().(*RequestUnion_AddSstable); ok {
		return x.AddSstable
	}
	return nil
}

func (m *RequestUnion) GetRecomputeStats() *RecomputeStatsRequest {
	if x, ok := m.GetValue().(*RequestUnion_RecomputeStats); ok {
		return x.RecomputeStats
	}
	return nil
}

func (m *RequestUnion) GetRefresh() *RefreshRequest {
	if x, ok := m.GetValue().(*RequestUnion_Refresh); ok {
		return x.Refresh
	}
	return nil
}

func (m *RequestUnion) GetRefreshRange() *RefreshRangeRequest {
	if x, ok := m.GetValue().(*RequestUnion_RefreshRange); ok {
		return x.RefreshRange
	}
	return nil
}

func (m *RequestUnion) GetSubsume() *SubsumeRequest {
	if x, ok := m.GetValue().(*RequestUnion_Subsume); ok {
		return x.Subsume
	}
	return nil
}

func (m *RequestUnion) GetRangeStats() *RangeStatsRequest {
	if x, ok := m.GetValue().(*RequestUnion_RangeStats); ok {
		return x.RangeStats
	}
	return nil
}

func (m *RequestUnion) GetAdminVerifyProtectedTimestamp() *AdminVerifyProtectedTimestampRequest {
	if x, ok := m.GetValue().(*RequestUnion_AdminVerifyProtectedTimestamp); ok {
		return x.AdminVerifyProtectedTimestamp
	}
	return nil
}

func (m *RequestUnion) GetMigrate() *MigrateRequest {
	if x, ok := m.GetValue().(*RequestUnion_Migrate); ok {
		return x.Migrate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RequestUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RequestUnion_Get)(nil),
		(*RequestUnion_Put)(nil),
		(*RequestUnion_ConditionalPut)(nil),
		(*RequestUnion_Increment)(nil),
		(*RequestUnion_Delete)(nil),
		(*RequestUnion_DeleteRange)(nil),
		(*RequestUnion_ClearRange)(nil),
		(*RequestUnion_RevertRange)(nil),
		(*RequestUnion_Scan)(nil),
		(*RequestUnion_EndTxn)(nil),
		(*RequestUnion_AdminSplit)(nil),
		(*RequestUnion_AdminUnsplit)(nil),
		(*RequestUnion_AdminMerge)(nil),
		(*RequestUnion_AdminTransferLease)(nil),
		(*RequestUnion_AdminChangeReplicas)(nil),
		(*RequestUnion_AdminRelocateRange)(nil),
		(*RequestUnion_HeartbeatTxn)(nil),
		(*RequestUnion_Gc)(nil),
		(*RequestUnion_PushTxn)(nil),
		(*RequestUnion_RecoverTxn)(nil),
		(*RequestUnion_ResolveIntent)(nil),
		(*RequestUnion_ResolveIntentRange)(nil),
		(*RequestUnion_Merge)(nil),
		(*RequestUnion_TruncateLog)(nil),
		(*RequestUnion_RequestLease)(nil),
		(*RequestUnion_ReverseScan)(nil),
		(*RequestUnion_ComputeChecksum)(nil),
		(*RequestUnion_CheckConsistency)(nil),
		(*RequestUnion_InitPut)(nil),
		(*RequestUnion_TransferLease)(nil),
		(*RequestUnion_LeaseInfo)(nil),
		(*RequestUnion_Export)(nil),
		(*RequestUnion_QueryTxn)(nil),
		(*RequestUnion_QueryIntent)(nil),
		(*RequestUnion_AdminScatter)(nil),
		(*RequestUnion_AddSstable)(nil),
		(*RequestUnion_RecomputeStats)(nil),
		(*RequestUnion_Refresh)(nil),
		(*RequestUnion_RefreshRange)(nil),
		(*RequestUnion_Subsume)(nil),
		(*RequestUnion_RangeStats)(nil),
		(*RequestUnion_AdminVerifyProtectedTimestamp)(nil),
		(*RequestUnion_Migrate)(nil),
	}
}

// A ResponseUnion contains exactly one of the responses.
// The values added here must match those in RequestUnion.
type ResponseUnion struct {
	// Types that are valid to be assigned to Value:
	//	*ResponseUnion_Get
	//	*ResponseUnion_Put
	//	*ResponseUnion_ConditionalPut
	//	*ResponseUnion_Increment
	//	*ResponseUnion_Delete
	//	*ResponseUnion_DeleteRange
	//	*ResponseUnion_ClearRange
	//	*ResponseUnion_RevertRange
	//	*ResponseUnion_Scan
	//	*ResponseUnion_EndTxn
	//	*ResponseUnion_AdminSplit
	//	*ResponseUnion_AdminUnsplit
	//	*ResponseUnion_AdminMerge
	//	*ResponseUnion_AdminTransferLease
	//	*ResponseUnion_AdminChangeReplicas
	//	*ResponseUnion_AdminRelocateRange
	//	*ResponseUnion_HeartbeatTxn
	//	*ResponseUnion_Gc
	//	*ResponseUnion_PushTxn
	//	*ResponseUnion_RecoverTxn
	//	*ResponseUnion_ResolveIntent
	//	*ResponseUnion_ResolveIntentRange
	//	*ResponseUnion_Merge
	//	*ResponseUnion_TruncateLog
	//	*ResponseUnion_RequestLease
	//	*ResponseUnion_ReverseScan
	//	*ResponseUnion_ComputeChecksum
	//	*ResponseUnion_CheckConsistency
	//	*ResponseUnion_InitPut
	//	*ResponseUnion_LeaseInfo
	//	*ResponseUnion_Export
	//	*ResponseUnion_QueryTxn
	//	*ResponseUnion_QueryIntent
	//	*ResponseUnion_AdminScatter
	//	*ResponseUnion_AddSstable
	//	*ResponseUnion_RecomputeStats
	//	*ResponseUnion_Refresh
	//	*ResponseUnion_RefreshRange
	//	*ResponseUnion_Subsume
	//	*ResponseUnion_RangeStats
	//	*ResponseUnion_AdminVerifyProtectedTimestamp
	//	*ResponseUnion_Migrate
	Value isResponseUnion_Value `protobuf_oneof:"value"`
}

func (m *ResponseUnion) Reset()         { *m = ResponseUnion{} }
func (m *ResponseUnion) String() string { return proto.CompactTextString(m) }
func (*ResponseUnion) ProtoMessage()    {}
func (*ResponseUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{93}
}
func (m *ResponseUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseUnion.Merge(m, src)
}
func (m *ResponseUnion) XXX_Size() int {
	return m.Size()
}
func (m *ResponseUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseUnion.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseUnion proto.InternalMessageInfo

type isResponseUnion_Value interface {
	isResponseUnion_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseUnion_Get struct {
	Get *GetResponse `protobuf:"bytes,1,opt,name=get,proto3,oneof" json:"get,omitempty"`
}
type ResponseUnion_Put struct {
	Put *PutResponse `protobuf:"bytes,2,opt,name=put,proto3,oneof" json:"put,omitempty"`
}
type ResponseUnion_ConditionalPut struct {
	ConditionalPut *ConditionalPutResponse `protobuf:"bytes,3,opt,name=conditional_put,json=conditionalPut,proto3,oneof" json:"conditional_put,omitempty"`
}
type ResponseUnion_Increment struct {
	Increment *IncrementResponse `protobuf:"bytes,4,opt,name=increment,proto3,oneof" json:"increment,omitempty"`
}
type ResponseUnion_Delete struct {
	Delete *DeleteResponse `protobuf:"bytes,5,opt,name=delete,proto3,oneof" json:"delete,omitempty"`
}
type ResponseUnion_DeleteRange struct {
	DeleteRange *DeleteRangeResponse `protobuf:"bytes,6,opt,name=delete_range,json=deleteRange,proto3,oneof" json:"delete_range,omitempty"`
}
type ResponseUnion_ClearRange struct {
	ClearRange *ClearRangeResponse `protobuf:"bytes,38,opt,name=clear_range,json=clearRange,proto3,oneof" json:"clear_range,omitempty"`
}
type ResponseUnion_RevertRange struct {
	RevertRange *RevertRangeResponse `protobuf:"bytes,48,opt,name=revert_range,json=revertRange,proto3,oneof" json:"revert_range,omitempty"`
}
type ResponseUnion_Scan struct {
	Scan *ScanResponse `protobuf:"bytes,7,opt,name=scan,proto3,oneof" json:"scan,omitempty"`
}
type ResponseUnion_EndTxn struct {
	EndTxn *EndTxnResponse `protobuf:"bytes,9,opt,name=end_txn,json=endTxn,proto3,oneof" json:"end_txn,omitempty"`
}
type ResponseUnion_AdminSplit struct {
	AdminSplit *AdminSplitResponse `protobuf:"bytes,10,opt,name=admin_split,json=adminSplit,proto3,oneof" json:"admin_split,omitempty"`
}
type ResponseUnion_AdminUnsplit struct {
	AdminUnsplit *AdminUnsplitResponse `protobuf:"bytes,47,opt,name=admin_unsplit,json=adminUnsplit,proto3,oneof" json:"admin_unsplit,omitempty"`
}
type ResponseUnion_AdminMerge struct {
	AdminMerge *AdminMergeResponse `protobuf:"bytes,11,opt,name=admin_merge,json=adminMerge,proto3,oneof" json:"admin_merge,omitempty"`
}
type ResponseUnion_AdminTransferLease struct {
	AdminTransferLease *AdminTransferLeaseResponse `protobuf:"bytes,29,opt,name=admin_transfer_lease,json=adminTransferLease,proto3,oneof" json:"admin_transfer_lease,omitempty"`
}
type ResponseUnion_AdminChangeReplicas struct {
	AdminChangeReplicas *AdminChangeReplicasResponse `protobuf:"bytes,35,opt,name=admin_change_replicas,json=adminChangeReplicas,proto3,oneof" json:"admin_change_replicas,omitempty"`
}
type ResponseUnion_AdminRelocateRange struct {
	AdminRelocateRange *AdminRelocateRangeResponse `protobuf:"bytes,45,opt,name=admin_relocate_range,json=adminRelocateRange,proto3,oneof" json:"admin_relocate_range,omitempty"`
}
type ResponseUnion_HeartbeatTxn struct {
	HeartbeatTxn *HeartbeatTxnResponse `protobuf:"bytes,12,opt,name=heartbeat_txn,json=heartbeatTxn,proto3,oneof" json:"heartbeat_txn,omitempty"`
}
type ResponseUnion_Gc struct {
	Gc *GCResponse `protobuf:"bytes,13,opt,name=gc,proto3,oneof" json:"gc,omitempty"`
}
type ResponseUnion_PushTxn struct {
	PushTxn *PushTxnResponse `protobuf:"bytes,14,opt,name=push_txn,json=pushTxn,proto3,oneof" json:"push_txn,omitempty"`
}
type ResponseUnion_RecoverTxn struct {
	RecoverTxn *RecoverTxnResponse `protobuf:"bytes,46,opt,name=recover_txn,json=recoverTxn,proto3,oneof" json:"recover_txn,omitempty"`
}
type ResponseUnion_ResolveIntent struct {
	ResolveIntent *ResolveIntentResponse `protobuf:"bytes,16,opt,name=resolve_intent,json=resolveIntent,proto3,oneof" json:"resolve_intent,omitempty"`
}
type ResponseUnion_ResolveIntentRange struct {
	ResolveIntentRange *ResolveIntentRangeResponse `protobuf:"bytes,17,opt,name=resolve_intent_range,json=resolveIntentRange,proto3,oneof" json:"resolve_intent_range,omitempty"`
}
type ResponseUnion_Merge struct {
	Merge *MergeResponse `protobuf:"bytes,18,opt,name=merge,proto3,oneof" json:"merge,omitempty"`
}
type ResponseUnion_TruncateLog struct {
	TruncateLog *TruncateLogResponse `protobuf:"bytes,19,opt,name=truncate_log,json=truncateLog,proto3,oneof" json:"truncate_log,omitempty"`
}
type ResponseUnion_RequestLease struct {
	RequestLease *RequestLeaseResponse `protobuf:"bytes,20,opt,name=request_lease,json=requestLease,proto3,oneof" json:"request_lease,omitempty"`
}
type ResponseUnion_ReverseScan struct {
	ReverseScan *ReverseScanResponse `protobuf:"bytes,21,opt,name=reverse_scan,json=reverseScan,proto3,oneof" json:"reverse_scan,omitempty"`
}
type ResponseUnion_ComputeChecksum struct {
	ComputeChecksum *ComputeChecksumResponse `protobuf:"bytes,22,opt,name=compute_checksum,json=computeChecksum,proto3,oneof" json:"compute_checksum,omitempty"`
}
type ResponseUnion_CheckConsistency struct {
	CheckConsistency *CheckConsistencyResponse `protobuf:"bytes,24,opt,name=check_consistency,json=checkConsistency,proto3,oneof" json:"check_consistency,omitempty"`
}
type ResponseUnion_InitPut struct {
	InitPut *InitPutResponse `protobuf:"bytes,26,opt,name=init_put,json=initPut,proto3,oneof" json:"init_put,omitempty"`
}
type ResponseUnion_LeaseInfo struct {
	LeaseInfo *LeaseInfoResponse `protobuf:"bytes,30,opt,name=lease_info,json=leaseInfo,proto3,oneof" json:"lease_info,omitempty"`
}
type ResponseUnion_Export struct {
	Export *ExportResponse `protobuf:"bytes,32,opt,name=export,proto3,oneof" json:"export,omitempty"`
}
type ResponseUnion_QueryTxn struct {
	QueryTxn *QueryTxnResponse `protobuf:"bytes,33,opt,name=query_txn,json=queryTxn,proto3,oneof" json:"query_txn,omitempty"`
}
type ResponseUnion_QueryIntent struct {
	QueryIntent *QueryIntentResponse `protobuf:"bytes,42,opt,name=query_intent,json=queryIntent,proto3,oneof" json:"query_intent,omitempty"`
}
type ResponseUnion_AdminScatter struct {
	AdminScatter *AdminScatterResponse `protobuf:"bytes,36,opt,name=admin_scatter,json=adminScatter,proto3,oneof" json:"admin_scatter,omitempty"`
}
type ResponseUnion_AddSstable struct {
	AddSstable *AddSSTableResponse `protobuf:"bytes,37,opt,name=add_sstable,json=addSstable,proto3,oneof" json:"add_sstable,omitempty"`
}
type ResponseUnion_RecomputeStats struct {
	RecomputeStats *RecomputeStatsResponse `protobuf:"bytes,39,opt,name=recompute_stats,json=recomputeStats,proto3,oneof" json:"recompute_stats,omitempty"`
}
type ResponseUnion_Refresh struct {
	Refresh *RefreshResponse `protobuf:"bytes,40,opt,name=refresh,proto3,oneof" json:"refresh,omitempty"`
}
type ResponseUnion_RefreshRange struct {
	RefreshRange *RefreshRangeResponse `protobuf:"bytes,41,opt,name=refresh_range,json=refreshRange,proto3,oneof" json:"refresh_range,omitempty"`
}
type ResponseUnion_Subsume struct {
	Subsume *SubsumeResponse `protobuf:"bytes,43,opt,name=subsume,proto3,oneof" json:"subsume,omitempty"`
}
type ResponseUnion_RangeStats struct {
	RangeStats *RangeStatsResponse `protobuf:"bytes,44,opt,name=range_stats,json=rangeStats,proto3,oneof" json:"range_stats,omitempty"`
}
type ResponseUnion_AdminVerifyProtectedTimestamp struct {
	AdminVerifyProtectedTimestamp *AdminVerifyProtectedTimestampResponse `protobuf:"bytes,49,opt,name=admin_verify_protected_timestamp,json=adminVerifyProtectedTimestamp,proto3,oneof" json:"admin_verify_protected_timestamp,omitempty"`
}
type ResponseUnion_Migrate struct {
	Migrate *MigrateResponse `protobuf:"bytes,50,opt,name=migrate,proto3,oneof" json:"migrate,omitempty"`
}

func (*ResponseUnion_Get) isResponseUnion_Value()                           {}
func (*ResponseUnion_Put) isResponseUnion_Value()                           {}
func (*ResponseUnion_ConditionalPut) isResponseUnion_Value()                {}
func (*ResponseUnion_Increment) isResponseUnion_Value()                     {}
func (*ResponseUnion_Delete) isResponseUnion_Value()                        {}
func (*ResponseUnion_DeleteRange) isResponseUnion_Value()                   {}
func (*ResponseUnion_ClearRange) isResponseUnion_Value()                    {}
func (*ResponseUnion_RevertRange) isResponseUnion_Value()                   {}
func (*ResponseUnion_Scan) isResponseUnion_Value()                          {}
func (*ResponseUnion_EndTxn) isResponseUnion_Value()                        {}
func (*ResponseUnion_AdminSplit) isResponseUnion_Value()                    {}
func (*ResponseUnion_AdminUnsplit) isResponseUnion_Value()                  {}
func (*ResponseUnion_AdminMerge) isResponseUnion_Value()                    {}
func (*ResponseUnion_AdminTransferLease) isResponseUnion_Value()            {}
func (*ResponseUnion_AdminChangeReplicas) isResponseUnion_Value()           {}
func (*ResponseUnion_AdminRelocateRange) isResponseUnion_Value()            {}
func (*ResponseUnion_HeartbeatTxn) isResponseUnion_Value()                  {}
func (*ResponseUnion_Gc) isResponseUnion_Value()                            {}
func (*ResponseUnion_PushTxn) isResponseUnion_Value()                       {}
func (*ResponseUnion_RecoverTxn) isResponseUnion_Value()                    {}
func (*ResponseUnion_ResolveIntent) isResponseUnion_Value()                 {}
func (*ResponseUnion_ResolveIntentRange) isResponseUnion_Value()            {}
func (*ResponseUnion_Merge) isResponseUnion_Value()                         {}
func (*ResponseUnion_TruncateLog) isResponseUnion_Value()                   {}
func (*ResponseUnion_RequestLease) isResponseUnion_Value()                  {}
func (*ResponseUnion_ReverseScan) isResponseUnion_Value()                   {}
func (*ResponseUnion_ComputeChecksum) isResponseUnion_Value()               {}
func (*ResponseUnion_CheckConsistency) isResponseUnion_Value()              {}
func (*ResponseUnion_InitPut) isResponseUnion_Value()                       {}
func (*ResponseUnion_LeaseInfo) isResponseUnion_Value()                     {}
func (*ResponseUnion_Export) isResponseUnion_Value()                        {}
func (*ResponseUnion_QueryTxn) isResponseUnion_Value()                      {}
func (*ResponseUnion_QueryIntent) isResponseUnion_Value()                   {}
func (*ResponseUnion_AdminScatter) isResponseUnion_Value()                  {}
func (*ResponseUnion_AddSstable) isResponseUnion_Value()                    {}
func (*ResponseUnion_RecomputeStats) isResponseUnion_Value()                {}
func (*ResponseUnion_Refresh) isResponseUnion_Value()                       {}
func (*ResponseUnion_RefreshRange) isResponseUnion_Value()                  {}
func (*ResponseUnion_Subsume) isResponseUnion_Value()                       {}
func (*ResponseUnion_RangeStats) isResponseUnion_Value()                    {}
func (*ResponseUnion_AdminVerifyProtectedTimestamp) isResponseUnion_Value() {}
func (*ResponseUnion_Migrate) isResponseUnion_Value()                       {}

func (m *ResponseUnion) GetValue() isResponseUnion_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ResponseUnion) GetGet() *GetResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Get); ok {
		return x.Get
	}
	return nil
}

func (m *ResponseUnion) GetPut() *PutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Put); ok {
		return x.Put
	}
	return nil
}

func (m *ResponseUnion) GetConditionalPut() *ConditionalPutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ConditionalPut); ok {
		return x.ConditionalPut
	}
	return nil
}

func (m *ResponseUnion) GetIncrement() *IncrementResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Increment); ok {
		return x.Increment
	}
	return nil
}

func (m *ResponseUnion) GetDelete() *DeleteResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Delete); ok {
		return x.Delete
	}
	return nil
}

func (m *ResponseUnion) GetDeleteRange() *DeleteRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_DeleteRange); ok {
		return x.DeleteRange
	}
	return nil
}

func (m *ResponseUnion) GetClearRange() *ClearRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ClearRange); ok {
		return x.ClearRange
	}
	return nil
}

func (m *ResponseUnion) GetRevertRange() *RevertRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RevertRange); ok {
		return x.RevertRange
	}
	return nil
}

func (m *ResponseUnion) GetScan() *ScanResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *ResponseUnion) GetEndTxn() *EndTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_EndTxn); ok {
		return x.EndTxn
	}
	return nil
}

func (m *ResponseUnion) GetAdminSplit() *AdminSplitResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminSplit); ok {
		return x.AdminSplit
	}
	return nil
}

func (m *ResponseUnion) GetAdminUnsplit() *AdminUnsplitResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminUnsplit); ok {
		return x.AdminUnsplit
	}
	return nil
}

func (m *ResponseUnion) GetAdminMerge() *AdminMergeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminMerge); ok {
		return x.AdminMerge
	}
	return nil
}

func (m *ResponseUnion) GetAdminTransferLease() *AdminTransferLeaseResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminTransferLease); ok {
		return x.AdminTransferLease
	}
	return nil
}

func (m *ResponseUnion) GetAdminChangeReplicas() *AdminChangeReplicasResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminChangeReplicas); ok {
		return x.AdminChangeReplicas
	}
	return nil
}

func (m *ResponseUnion) GetAdminRelocateRange() *AdminRelocateRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminRelocateRange); ok {
		return x.AdminRelocateRange
	}
	return nil
}

func (m *ResponseUnion) GetHeartbeatTxn() *HeartbeatTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_HeartbeatTxn); ok {
		return x.HeartbeatTxn
	}
	return nil
}

func (m *ResponseUnion) GetGc() *GCResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Gc); ok {
		return x.Gc
	}
	return nil
}

func (m *ResponseUnion) GetPushTxn() *PushTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_PushTxn); ok {
		return x.PushTxn
	}
	return nil
}

func (m *ResponseUnion) GetRecoverTxn() *RecoverTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RecoverTxn); ok {
		return x.RecoverTxn
	}
	return nil
}

func (m *ResponseUnion) GetResolveIntent() *ResolveIntentResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ResolveIntent); ok {
		return x.ResolveIntent
	}
	return nil
}

func (m *ResponseUnion) GetResolveIntentRange() *ResolveIntentRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ResolveIntentRange); ok {
		return x.ResolveIntentRange
	}
	return nil
}

func (m *ResponseUnion) GetMerge() *MergeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Merge); ok {
		return x.Merge
	}
	return nil
}

func (m *ResponseUnion) GetTruncateLog() *TruncateLogResponse {
	if x, ok := m.GetValue().(*ResponseUnion_TruncateLog); ok {
		return x.TruncateLog
	}
	return nil
}

func (m *ResponseUnion) GetRequestLease() *RequestLeaseResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RequestLease); ok {
		return x.RequestLease
	}
	return nil
}

func (m *ResponseUnion) GetReverseScan() *ReverseScanResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ReverseScan); ok {
		return x.ReverseScan
	}
	return nil
}

func (m *ResponseUnion) GetComputeChecksum() *ComputeChecksumResponse {
	if x, ok := m.GetValue().(*ResponseUnion_ComputeChecksum); ok {
		return x.ComputeChecksum
	}
	return nil
}

func (m *ResponseUnion) GetCheckConsistency() *CheckConsistencyResponse {
	if x, ok := m.GetValue().(*ResponseUnion_CheckConsistency); ok {
		return x.CheckConsistency
	}
	return nil
}

func (m *ResponseUnion) GetInitPut() *InitPutResponse {
	if x, ok := m.GetValue().(*ResponseUnion_InitPut); ok {
		return x.InitPut
	}
	return nil
}

func (m *ResponseUnion) GetLeaseInfo() *LeaseInfoResponse {
	if x, ok := m.GetValue().(*ResponseUnion_LeaseInfo); ok {
		return x.LeaseInfo
	}
	return nil
}

func (m *ResponseUnion) GetExport() *ExportResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Export); ok {
		return x.Export
	}
	return nil
}

func (m *ResponseUnion) GetQueryTxn() *QueryTxnResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryTxn); ok {
		return x.QueryTxn
	}
	return nil
}

func (m *ResponseUnion) GetQueryIntent() *QueryIntentResponse {
	if x, ok := m.GetValue().(*ResponseUnion_QueryIntent); ok {
		return x.QueryIntent
	}
	return nil
}

func (m *ResponseUnion) GetAdminScatter() *AdminScatterResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminScatter); ok {
		return x.AdminScatter
	}
	return nil
}

func (m *ResponseUnion) GetAddSstable() *AddSSTableResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AddSstable); ok {
		return x.AddSstable
	}
	return nil
}

func (m *ResponseUnion) GetRecomputeStats() *RecomputeStatsResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RecomputeStats); ok {
		return x.RecomputeStats
	}
	return nil
}

func (m *ResponseUnion) GetRefresh() *RefreshResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Refresh); ok {
		return x.Refresh
	}
	return nil
}

func (m *ResponseUnion) GetRefreshRange() *RefreshRangeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RefreshRange); ok {
		return x.RefreshRange
	}
	return nil
}

func (m *ResponseUnion) GetSubsume() *SubsumeResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Subsume); ok {
		return x.Subsume
	}
	return nil
}

func (m *ResponseUnion) GetRangeStats() *RangeStatsResponse {
	if x, ok := m.GetValue().(*ResponseUnion_RangeStats); ok {
		return x.RangeStats
	}
	return nil
}

func (m *ResponseUnion) GetAdminVerifyProtectedTimestamp() *AdminVerifyProtectedTimestampResponse {
	if x, ok := m.GetValue().(*ResponseUnion_AdminVerifyProtectedTimestamp); ok {
		return x.AdminVerifyProtectedTimestamp
	}
	return nil
}

func (m *ResponseUnion) GetMigrate() *MigrateResponse {
	if x, ok := m.GetValue().(*ResponseUnion_Migrate); ok {
		return x.Migrate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ResponseUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ResponseUnion_Get)(nil),
		(*ResponseUnion_Put)(nil),
		(*ResponseUnion_ConditionalPut)(nil),
		(*ResponseUnion_Increment)(nil),
		(*ResponseUnion_Delete)(nil),
		(*ResponseUnion_DeleteRange)(nil),
		(*ResponseUnion_ClearRange)(nil),
		(*ResponseUnion_RevertRange)(nil),
		(*ResponseUnion_Scan)(nil),
		(*ResponseUnion_EndTxn)(nil),
		(*ResponseUnion_AdminSplit)(nil),
		(*ResponseUnion_AdminUnsplit)(nil),
		(*ResponseUnion_AdminMerge)(nil),
		(*ResponseUnion_AdminTransferLease)(nil),
		(*ResponseUnion_AdminChangeReplicas)(nil),
		(*ResponseUnion_AdminRelocateRange)(nil),
		(*ResponseUnion_HeartbeatTxn)(nil),
		(*ResponseUnion_Gc)(nil),
		(*ResponseUnion_PushTxn)(nil),
		(*ResponseUnion_RecoverTxn)(nil),
		(*ResponseUnion_ResolveIntent)(nil),
		(*ResponseUnion_ResolveIntentRange)(nil),
		(*ResponseUnion_Merge)(nil),
		(*ResponseUnion_TruncateLog)(nil),
		(*ResponseUnion_RequestLease)(nil),
		(*ResponseUnion_ReverseScan)(nil),
		(*ResponseUnion_ComputeChecksum)(nil),
		(*ResponseUnion_CheckConsistency)(nil),
		(*ResponseUnion_InitPut)(nil),
		(*ResponseUnion_LeaseInfo)(nil),
		(*ResponseUnion_Export)(nil),
		(*ResponseUnion_QueryTxn)(nil),
		(*ResponseUnion_QueryIntent)(nil),
		(*ResponseUnion_AdminScatter)(nil),
		(*ResponseUnion_AddSstable)(nil),
		(*ResponseUnion_RecomputeStats)(nil),
		(*ResponseUnion_Refresh)(nil),
		(*ResponseUnion_RefreshRange)(nil),
		(*ResponseUnion_Subsume)(nil),
		(*ResponseUnion_RangeStats)(nil),
		(*ResponseUnion_AdminVerifyProtectedTimestamp)(nil),
		(*ResponseUnion_Migrate)(nil),
	}
}

// A Header is attached to a BatchRequest, encapsulating routing and auxiliary
// information required for executing it.
type Header struct {
	// timestamp specifies time at which reads or writes should be performed. If
	// the timestamp is set to zero value, its value is initialized to the wall
	// time of the server node.
	//
	// Transactional requests are not allowed to set this field; they must rely on
	// the server to set it from txn.ReadTimestamp. Also, for transactional
	// requests, writes are performed at the provisional commit timestamp
	// (txn.WriteTimestamp).
	Timestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp"`
	// replica specifies the destination of the request.
	Replica ReplicaDescriptor `protobuf:"bytes,2,opt,name=replica,proto3" json:"replica"`
	// range_id specifies the ID of the Raft consensus group which the key
	// range belongs to. This is used by the receiving node to route the
	// request to the correct range.
	RangeID RangeID `protobuf:"varint,3,opt,name=range_id,json=rangeId,proto3,casttype=RangeID" json:"range_id,omitempty"`
	// user_priority allows any command's priority to be biased from the
	// default random priority. It specifies a multiple. If set to 0.5,
	// the chosen priority will be 1/2x as likely to beat any default
	// random priority. If set to 1, a default random priority is
	// chosen. If set to 2, the chosen priority will be 2x as likely to
	// beat any default random priority, and so on. As a special case, 0
	// priority is treated the same as 1. This value is ignored if txn
	// is specified. The min and max user priorities are set via
	// MinUserPriority and MaxUserPriority in data.go.
	UserPriority UserPriority `protobuf:"fixed64,4,opt,name=user_priority,json=userPriority,proto3,casttype=UserPriority" json:"user_priority,omitempty"`
	// txn is set non-nil if a transaction is underway. To start a txn,
	// the first request should set this field to non-nil with name and
	// isolation level set as desired. The response will contain the
	// fully-initialized transaction with txn ID, priority, initial
	// timestamp, and maximum timestamp.
	Txn *Transaction `protobuf:"bytes,5,opt,name=txn,proto3" json:"txn,omitempty"`
	// read_consistency specifies the consistency for read
	// operations. The default is CONSISTENT. This value is ignored for
	// write operations.
	ReadConsistency ReadConsistencyType `protobuf:"varint,6,opt,name=read_consistency,json=readConsistency,proto3,enum=cockroach.roachpb.ReadConsistencyType" json:"read_consistency,omitempty"`
	// wait_policy specifies the desired behavior for the batch request if it
	// encounters a conflicting lock held by another active transaction.
	//
	// If an Error wait policy is set and a conflicting lock held by an active
	// transaction is encountered, a WriteIntentError will be returned.
	//
	// If the desired behavior is to block on the conflicting lock up to some
	// maximum duration, use the Block wait policy and set a context timeout.
	WaitPolicy lock.WaitPolicy `protobuf:"varint,18,opt,name=wait_policy,json=waitPolicy,proto3,enum=cockroach.kv.kvserver.concurrency.lock.WaitPolicy" json:"wait_policy,omitempty"`
	// If set to a non-zero value, the total number of keys touched by requests in
	// the batch is limited. A resume span will be provided on the response of the
	// requests that were not able to run to completion before the limit was
	// reached.
	//
	// Overlapping requests
	//
	// The spans accessed by the requests are allowed to overlap. However, if any
	// requests overlap, the caller must be prepared to handle *multiple* partial
	// responses in the corresponding BatchResponse. If no requests overlap, then
	// only up to one request will return a partial result. Additionally, if two
	// requests touch the same key, it is double counted towards the key limit.
	//
	// Unordered requests
	//
	// The spans accessed by requests do not need to be in sorted order. However,
	// if the requests are not in sorted order (e.g. increasing key order for
	// Scans and other forward requests, decreasing key order for ReverseScans),
	// the caller must be prepared to handle empty responses interleaved with full
	// responses and one (or more, see "Overlapping requests") partial response
	// in the corresponding BatchResponse. If the requests are in sorted order,
	// the caller can expect to receive a group of full responses, one (or more)
	// partial responses, and a group of empty responses.
	//
	// Pagination of requests
	//
	// As discussed above, overlapping requests or unordered requests in batches
	// with a limit can lead to response batches with multiple partial responses.
	// In practice, this is because DistSender paginates request evaluation over
	// ranges in increasing key order (decreasing for reverse batches). As ranges
	// are iterated over in order, all requests that target a given range are sent
	// to it, regardless of their position in the batch. Once split and delivered
	// to a range, the applicable requests are executed in-full according to their
	// order in the batch.
	//
	// This behavior makes it difficult to make assumptions about the resume spans
	// of individual responses in batches that contain either overlapping requests
	// or unordered requests. As such, clients should not make assumptions about
	// resume spans and should instead inspect the result for every request in the
	// batch if if cannot guarantee that the batch is ordered with no overlapping
	// requests.
	//
	// Supported requests
	//
	// If a limit is provided, the batch can contain only the following range
	// request types:
	// - ScanRequest
	// - ReverseScanRequest
	// - DeleteRangeRequest(*)
	// - GetRequest
	// - RevertRangeRequest
	// - ResolveIntentRangeRequest
	//
	// The following two requests types are also allowed in the batch, although
	// the limit has no effect on them:
	// - QueryIntentRequest
	// - EndTxnRequest
	//
	// [*] DeleteRangeRequests are generally not allowed to be batched together
	// with a commit (i.e. 1PC), except if Require1PC is also set. See #37457.
	//
	// Forward requests and reverse requests cannot be mixed in the same batch if
	// a limit is set. There doesn't seem to be a fundamental reason for this
	// restriction, but a batch that mixed forward and reverse requests would be
	// impossible to order, so it would unavoidably have to deal with the added
	// complications discussed in "Unordered requests". For now, that's a good
	// enough reason to disallow such batches.
	MaxSpanRequestKeys int64 `protobuf:"varint,8,opt,name=max_span_request_keys,json=maxSpanRequestKeys,proto3" json:"max_span_request_keys,omitempty"`
	// If set to a non-zero value, sets a target (in bytes) for how large the
	// response may grow. This is only supported for (forward and reverse) scans
	// and limits the number of rows scanned (and returned). The target will be
	// overshot; in particular, at least one row will always be returned (assuming
	// one exists). A suitable resume span will be returned.
	//
	// The semantics around overlapping requests, unordered requests, and
	// supported requests from max_span_request_keys apply to the target_bytes
	// option as well.
	TargetBytes int64 `protobuf:"varint,15,opt,name=target_bytes,json=targetBytes,proto3" json:"target_bytes,omitempty"`
	// If set, all of the spans in the batch are distinct. Note that the
	// calculation of distinct spans does not include intents in an
	// EndTxnRequest. Currently set conservatively: a request might be
	// composed of distinct spans yet have this field set to false.
	DistinctSpans bool `protobuf:"varint,9,opt,name=distinct_spans,json=distinctSpans,proto3" json:"distinct_spans,omitempty"`
	// client_range_info represents the kvclient's knowledge about the state of
	// the range (i.e. of the range descriptor and lease). The kvserver checks
	// whether the client's info is up to date and, if it isn't, it will return a
	// RangeInfo with up-to-date information.
	ClientRangeInfo ClientRangeInfo `protobuf:"bytes,17,opt,name=client_range_info,json=clientRangeInfo,proto3" json:"client_range_info"`
	// gateway_node_id is the ID of the gateway node where the request originated.
	GatewayNodeID NodeID `protobuf:"varint,11,opt,name=gateway_node_id,json=gatewayNodeId,proto3,casttype=NodeID" json:"gateway_node_id,omitempty"`
	// If set, the request will return to the client before proposing the
	// request into Raft. All consensus processing will be performed
	// asynchronously. Because consensus may fail, this means that the
	// request cannot be expected to succeed. Instead, its success must
	// be verified.
	// TODO(nvanbenschoten): Handling cases where consensus fails would
	// be much more straightforward if all transactional requests were
	// idempotent. We could just re-issue requests. See #26915.
	AsyncConsensus bool `protobuf:"varint,13,opt,name=async_consensus,json=asyncConsensus,proto3" json:"async_consensus,omitempty"`
	// can_forward_read_timestamp indicates that the batch can be evaluated at a
	// higher timestamp than the transaction's read timestamp. The flag is only
	// applicable to transactional batches and is assumed to be true for all
	// non-transactional batches. It is set by the client if the transaction
	// has not performed any reads that must be refreshed prior to sending this
	// current batch. When set, it allows the server to handle pushes and write
	// too old conditions locally.
	CanForwardReadTimestamp bool `protobuf:"varint,16,opt,name=can_forward_read_timestamp,json=canForwardReadTimestamp,proto3" json:"can_forward_read_timestamp,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{94}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// AdmissionHeader contains information utilized by admission control for the
// request.
type AdmissionHeader struct {
	// Priority is utilized within a tenant. See admission.WorkPriority.
	Priority int32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// CreateTime is equivalent to Time.UnixNano() at the creation time of this
	// request or a parent request. See admission.WorkInfo.Priority for details.
	// It is used to give preference to older requests.
	CreateTime int64                  `protobuf:"varint,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	Source     AdmissionHeader_Source `protobuf:"varint,3,opt,name=source,proto3,enum=cockroach.roachpb.AdmissionHeader_Source" json:"source,omitempty"`
}

func (m *AdmissionHeader) Reset()         { *m = AdmissionHeader{} }
func (m *AdmissionHeader) String() string { return proto.CompactTextString(m) }
func (*AdmissionHeader) ProtoMessage()    {}
func (*AdmissionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{95}
}
func (m *AdmissionHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdmissionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionHeader.Merge(m, src)
}
func (m *AdmissionHeader) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionHeader proto.InternalMessageInfo

// A BatchRequest contains one or more requests to be executed in
// parallel, or if applicable (based on write-only commands and
// range-locality), as a single update.
type BatchRequest struct {
	Header          `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Requests        []RequestUnion  `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	AdmissionHeader AdmissionHeader `protobuf:"bytes,3,opt,name=admission_header,json=admissionHeader,proto3" json:"admission_header"`
}

func (m *BatchRequest) Reset()      { *m = BatchRequest{} }
func (*BatchRequest) ProtoMessage() {}
func (*BatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{96}
}
func (m *BatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchRequest.Merge(m, src)
}
func (m *BatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchRequest proto.InternalMessageInfo

// A BatchResponse contains one or more responses, one per request
// corresponding to the requests in the matching BatchRequest. The
// error in the response header is set to the first error from the
// slice of responses, if applicable.
type BatchResponse struct {
	BatchResponse_Header `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Responses            []ResponseUnion `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
}

func (m *BatchResponse) Reset()      { *m = BatchResponse{} }
func (*BatchResponse) ProtoMessage() {}
func (*BatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{97}
}
func (m *BatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse.Merge(m, src)
}
func (m *BatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse proto.InternalMessageInfo

type BatchResponse_Header struct {
	// error communicates a structured error (i.e. one originating from a Node)
	// while the BatchResponse is sent over the network. If the code were
	// written today, the RPC endpoint would return a message containing both a
	// BatchResponse and an Error, and this embedding would go away. However, it
	// returns only a BatchResponse, and so the Error needs to be tucked away
	// somewhere (the structured error cannot be communicated via an RPC-level
	// error).
	//
	// Outside of the RPC boundaries, this field is nil and must neither be
	// checked nor populated (it is reset by the DistSender, which extracts this
	// error and returns it separately). In effect, nearly no usage of
	// BatchResponse needs to care about this field.
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// timestamp denotes the timestamp at which the batch's reads executed. The
	// timestamp cache is updated at this timestamp.
	//
	// TODO(tbg): for transactional requests, this duplicates `Txn.ReadTimestamp`,
	// which is awkward. We could consider making this field optional and only
	// populate it for non-transactional requests. The timestamp cache would then
	// use an accessor on BatchResponse to pick the one that matters.
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=Timestamp,proto3" json:"Timestamp"`
	// txn is non-nil if the request specified a non-nil
	// transaction. The transaction timestamp and/or priority may have
	// been updated, depending on the outcome of the request.
	Txn *Transaction `protobuf:"bytes,3,opt,name=txn,proto3" json:"txn,omitempty"`
	// now is the highest current time from any node contacted during the request.
	// It can be used by the receiver to update its local HLC.
	Now github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,5,opt,name=now,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"now"`
	// collected_spans stores trace spans recorded during the execution of this
	// request.
	CollectedSpans []tracingpb.RecordedSpan `protobuf:"bytes,6,rep,name=collected_spans,json=collectedSpans,proto3" json:"collected_spans"`
	// Range used to execute the request. The server only populates this if the
	// server detects the client's client_range_info to be stale. Otherwise, it
	// is left empty. Not set when Error is set.
	//
	// The server may also include additional RangeInfo objects if it suspects
	// that the client may be interested in them. This is currently the case
	// immediately after a Range split, where a stale client_range_info from
	// before the split is taken to be an indication that the client may be
	// interested in information about both the LHS and RHS post-split ranges.
	//
	// The field is cleared by the DistSender because it refers routing
	// information not exposed by the KV API.
	RangeInfos []RangeInfo `protobuf:"bytes,7,rep,name=range_infos,json=rangeInfos,proto3" json:"range_infos"`
}

func (m *BatchResponse_Header) Reset()         { *m = BatchResponse_Header{} }
func (m *BatchResponse_Header) String() string { return proto.CompactTextString(m) }
func (*BatchResponse_Header) ProtoMessage()    {}
func (*BatchResponse_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{97, 0}
}
func (m *BatchResponse_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchResponse_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BatchResponse_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchResponse_Header.Merge(m, src)
}
func (m *BatchResponse_Header) XXX_Size() int {
	return m.Size()
}
func (m *BatchResponse_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchResponse_Header.DiscardUnknown(m)
}

var xxx_messageInfo_BatchResponse_Header proto.InternalMessageInfo

// RangeLookupRequest is a request to proxy a RangeLookup through a Tenant
// service. Its fields correspond to a subset of the args of kv.RangeLookup.
type RangeLookupRequest struct {
	Key             RKey                `protobuf:"bytes,1,opt,name=key,proto3,casttype=RKey" json:"key,omitempty"`
	ReadConsistency ReadConsistencyType `protobuf:"varint,2,opt,name=read_consistency,json=readConsistency,proto3,enum=cockroach.roachpb.ReadConsistencyType" json:"read_consistency,omitempty"`
	PrefetchNum     int64               `protobuf:"varint,3,opt,name=prefetch_num,json=prefetchNum,proto3" json:"prefetch_num,omitempty"`
	PrefetchReverse bool                `protobuf:"varint,4,opt,name=prefetch_reverse,json=prefetchReverse,proto3" json:"prefetch_reverse,omitempty"`
}

func (m *RangeLookupRequest) Reset()         { *m = RangeLookupRequest{} }
func (m *RangeLookupRequest) String() string { return proto.CompactTextString(m) }
func (*RangeLookupRequest) ProtoMessage()    {}
func (*RangeLookupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{98}
}
func (m *RangeLookupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLookupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLookupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLookupRequest.Merge(m, src)
}
func (m *RangeLookupRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeLookupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLookupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLookupRequest proto.InternalMessageInfo

// RangeLookupResponse is returned from a RangeLookup request proxied through a
// Tenant service. Its fields correspond to the return values of kv.RangeLookup.
type RangeLookupResponse struct {
	Descriptors           []RangeDescriptor `protobuf:"bytes,1,rep,name=descriptors,proto3" json:"descriptors"`
	PrefetchedDescriptors []RangeDescriptor `protobuf:"bytes,2,rep,name=prefetched_descriptors,json=prefetchedDescriptors,proto3" json:"prefetched_descriptors"`
	// If non-nil, the other fields will be empty.
	Error *Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RangeLookupResponse) Reset()         { *m = RangeLookupResponse{} }
func (m *RangeLookupResponse) String() string { return proto.CompactTextString(m) }
func (*RangeLookupResponse) ProtoMessage()    {}
func (*RangeLookupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{99}
}
func (m *RangeLookupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeLookupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeLookupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeLookupResponse.Merge(m, src)
}
func (m *RangeLookupResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeLookupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeLookupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeLookupResponse proto.InternalMessageInfo

// RangeFeedRequest is a request that expresses the intention to establish a
// RangeFeed stream over the provided span, starting at the specified timestamp.
type RangeFeedRequest struct {
	Header `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	Span   Span `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
	// with_diff specifies whether RangeFeedValue updates should contain the
	// previous value that was overwritten.
	WithDiff bool `protobuf:"varint,3,opt,name=with_diff,json=withDiff,proto3" json:"with_diff,omitempty"`
	// AdmissionHeader is used only at the start of the range feed stream, since
	// the initial catch-up scan be expensive.
	AdmissionHeader AdmissionHeader `protobuf:"bytes,4,opt,name=admission_header,json=admissionHeader,proto3" json:"admission_header"`
}

func (m *RangeFeedRequest) Reset()         { *m = RangeFeedRequest{} }
func (m *RangeFeedRequest) String() string { return proto.CompactTextString(m) }
func (*RangeFeedRequest) ProtoMessage()    {}
func (*RangeFeedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{100}
}
func (m *RangeFeedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedRequest.Merge(m, src)
}
func (m *RangeFeedRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedRequest proto.InternalMessageInfo

// RangeFeedValue is a variant of RangeFeedEvent that represents an update to
// the specified key with the provided value.
type RangeFeedValue struct {
	Key   Key   `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Value Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	// prev_value is only populated if both:
	// 1. with_diff was passed in the corresponding RangeFeedRequest.
	// 2. the key-value was present and not a deletion tombstone before
	//    this event.
	PrevValue Value `protobuf:"bytes,3,opt,name=prev_value,json=prevValue,proto3" json:"prev_value"`
}

func (m *RangeFeedValue) Reset()         { *m = RangeFeedValue{} }
func (m *RangeFeedValue) String() string { return proto.CompactTextString(m) }
func (*RangeFeedValue) ProtoMessage()    {}
func (*RangeFeedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{101}
}
func (m *RangeFeedValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedValue.Merge(m, src)
}
func (m *RangeFeedValue) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedValue.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedValue proto.InternalMessageInfo

// RangeFeedCheckpoint is a variant of RangeFeedEvent that represents the
// promise that no more RangeFeedValue events with keys in the specified span
// with timestamps less than or equal to the specified resolved timestamp will
// be emitted on the RangeFeed response stream.
//
// Note that these resolved timestamps may be lower than the timestamp used in
// the RangeFeedRequest used to start the RangeFeed.
type RangeFeedCheckpoint struct {
	Span       Span          `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	ResolvedTS hlc.Timestamp `protobuf:"bytes,2,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts"`
}

func (m *RangeFeedCheckpoint) Reset()         { *m = RangeFeedCheckpoint{} }
func (m *RangeFeedCheckpoint) String() string { return proto.CompactTextString(m) }
func (*RangeFeedCheckpoint) ProtoMessage()    {}
func (*RangeFeedCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{102}
}
func (m *RangeFeedCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedCheckpoint.Merge(m, src)
}
func (m *RangeFeedCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedCheckpoint proto.InternalMessageInfo

// RangeFeedError is a variant of RangeFeedEvent that indicates that an error
// occurred during the processing of the RangeFeed. If emitted, a RangeFeedError
// event will always be the final event on a RangeFeed response stream before
// it is torn down.
type RangeFeedError struct {
	Error Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
}

func (m *RangeFeedError) Reset()         { *m = RangeFeedError{} }
func (m *RangeFeedError) String() string { return proto.CompactTextString(m) }
func (*RangeFeedError) ProtoMessage()    {}
func (*RangeFeedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{103}
}
func (m *RangeFeedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedError.Merge(m, src)
}
func (m *RangeFeedError) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedError proto.InternalMessageInfo

// RangeFeedEvent is a union of all event types that may be returned on a
// RangeFeed response stream.
type RangeFeedEvent struct {
	Val        *RangeFeedValue      `protobuf:"bytes,1,opt,name=val,proto3" json:"val,omitempty"`
	Checkpoint *RangeFeedCheckpoint `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	Error      *RangeFeedError      `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RangeFeedEvent) Reset()         { *m = RangeFeedEvent{} }
func (m *RangeFeedEvent) String() string { return proto.CompactTextString(m) }
func (*RangeFeedEvent) ProtoMessage()    {}
func (*RangeFeedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{104}
}
func (m *RangeFeedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeFeedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RangeFeedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeFeedEvent.Merge(m, src)
}
func (m *RangeFeedEvent) XXX_Size() int {
	return m.Size()
}
func (m *RangeFeedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeFeedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RangeFeedEvent proto.InternalMessageInfo

// ResetQuorumRequest makes a range that is unavailable due to lost quorum
// available again, at the cost of losing all of the data in the range. Any
// existing replica, even one residing on the target node, will irrevocably
// be removed. ResetQuorumRequest first uses meta2 to identify the range
// descriptor. Then, it removes all replicas from the range descriptor and
// adds a store from the target node as the one designated survivor replica.
// This change is then written to meta2 and sent as a snapshot to a store
// local to the target node.
//
// This RPC is called by the user directly and will not work for ranges
// that have not lost quorum or for a meta range.
type ResetQuorumRequest struct {
	RangeID int32 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *ResetQuorumRequest) Reset()         { *m = ResetQuorumRequest{} }
func (m *ResetQuorumRequest) String() string { return proto.CompactTextString(m) }
func (*ResetQuorumRequest) ProtoMessage()    {}
func (*ResetQuorumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{105}
}
func (m *ResetQuorumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetQuorumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetQuorumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetQuorumRequest.Merge(m, src)
}
func (m *ResetQuorumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetQuorumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetQuorumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetQuorumRequest proto.InternalMessageInfo

type ResetQuorumResponse struct {
}

func (m *ResetQuorumResponse) Reset()         { *m = ResetQuorumResponse{} }
func (m *ResetQuorumResponse) String() string { return proto.CompactTextString(m) }
func (*ResetQuorumResponse) ProtoMessage()    {}
func (*ResetQuorumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{106}
}
func (m *ResetQuorumResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetQuorumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResetQuorumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetQuorumResponse.Merge(m, src)
}
func (m *ResetQuorumResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetQuorumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetQuorumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetQuorumResponse proto.InternalMessageInfo

// GossipSubscriptionRequest initiates a game of telephone. It establishes an
// indefinite stream that proxies gossip information overheard by the recipient
// node back to the caller. Gossip information is filtered down to just those
// identified by a key matching any of the specified patterns.
//
// Upon establishment of the stream, all existing information that matches one
// or more of the patterns is returned. After this point, only new information
// matching the patterns is returned.
type GossipSubscriptionRequest struct {
	Patterns []string `protobuf:"bytes,1,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (m *GossipSubscriptionRequest) Reset()         { *m = GossipSubscriptionRequest{} }
func (m *GossipSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*GossipSubscriptionRequest) ProtoMessage()    {}
func (*GossipSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{107}
}
func (m *GossipSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GossipSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipSubscriptionRequest.Merge(m, src)
}
func (m *GossipSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GossipSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GossipSubscriptionRequest proto.InternalMessageInfo

// GossipSubscriptionEvent is a single piece of proxied gossip information.
type GossipSubscriptionEvent struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Content Value  `protobuf:"bytes,2,opt,name=content,proto3" json:"content"`
	// Which pattern does this gossip information match?
	PatternMatched string `protobuf:"bytes,3,opt,name=pattern_matched,json=patternMatched,proto3" json:"pattern_matched,omitempty"`
	// If non-nil, the other fields will be empty and this will be the final event
	// send on the stream before it is terminated.
	Error *Error `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *GossipSubscriptionEvent) Reset()         { *m = GossipSubscriptionEvent{} }
func (m *GossipSubscriptionEvent) String() string { return proto.CompactTextString(m) }
func (*GossipSubscriptionEvent) ProtoMessage()    {}
func (*GossipSubscriptionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{108}
}
func (m *GossipSubscriptionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipSubscriptionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GossipSubscriptionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipSubscriptionEvent.Merge(m, src)
}
func (m *GossipSubscriptionEvent) XXX_Size() int {
	return m.Size()
}
func (m *GossipSubscriptionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipSubscriptionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_GossipSubscriptionEvent proto.InternalMessageInfo

// JoinNodeRequest is used to specify to the server node what the client's
// binary version is. If it's not compatible with the rest of the cluster, the
// join attempt is refused.
type JoinNodeRequest struct {
	BinaryVersion *Version `protobuf:"bytes,1,opt,name=binary_version,json=binaryVersion,proto3" json:"binary_version,omitempty"`
}

func (m *JoinNodeRequest) Reset()         { *m = JoinNodeRequest{} }
func (m *JoinNodeRequest) String() string { return proto.CompactTextString(m) }
func (*JoinNodeRequest) ProtoMessage()    {}
func (*JoinNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{109}
}
func (m *JoinNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JoinNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinNodeRequest.Merge(m, src)
}
func (m *JoinNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *JoinNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinNodeRequest proto.InternalMessageInfo

// JoinNodeResponse informs the joining node what the cluster id is, what
// node id was allocated to it, and what store ID to use for its first store. It
// also informs the node what the current active version is.
type JoinNodeResponse struct {
	ClusterID     []byte   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	NodeID        int32    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StoreID       int32    `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	ActiveVersion *Version `protobuf:"bytes,4,opt,name=active_version,json=activeVersion,proto3" json:"active_version,omitempty"`
}

func (m *JoinNodeResponse) Reset()         { *m = JoinNodeResponse{} }
func (m *JoinNodeResponse) String() string { return proto.CompactTextString(m) }
func (*JoinNodeResponse) ProtoMessage()    {}
func (*JoinNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{110}
}
func (m *JoinNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JoinNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinNodeResponse.Merge(m, src)
}
func (m *JoinNodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *JoinNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JoinNodeResponse proto.InternalMessageInfo

// ContentionEvent is a message that will be attached to BatchResponses
// indicating any conflicts with another transaction during replica evaluation.
type ContentionEvent struct {
	// Key is the key that this and the other transaction conflicted on.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// TxnMeta is the transaction conflicted
	// with, i.e. the transaction holding a lock.
	TxnMeta enginepb.TxnMeta `protobuf:"bytes,2,opt,name=txn_meta,json=txnMeta,proto3" json:"txn_meta"`
	// Duration spent contending against the other transaction.
	Duration time.Duration `protobuf:"bytes,3,opt,name=duration,proto3,stdduration" json:"duration"`
}

func (m *ContentionEvent) Reset()      { *m = ContentionEvent{} }
func (*ContentionEvent) ProtoMessage() {}
func (*ContentionEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e08772acc330f58b, []int{111}
}
func (m *ContentionEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentionEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContentionEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentionEvent.Merge(m, src)
}
func (m *ContentionEvent) XXX_Size() int {
	return m.Size()
}
func (m *ContentionEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentionEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ContentionEvent proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.ReadConsistencyType", ReadConsistencyType_name, ReadConsistencyType_value)
	proto.RegisterEnum("cockroach.roachpb.ScanFormat", ScanFormat_name, ScanFormat_value)
	proto.RegisterEnum("cockroach.roachpb.ChecksumMode", ChecksumMode_name, ChecksumMode_value)
	proto.RegisterEnum("cockroach.roachpb.PushTxnType", PushTxnType_name, PushTxnType_value)
	proto.RegisterEnum("cockroach.roachpb.ExternalStorageProvider", ExternalStorageProvider_name, ExternalStorageProvider_value)
	proto.RegisterEnum("cockroach.roachpb.MVCCFilter", MVCCFilter_name, MVCCFilter_value)
	proto.RegisterEnum("cockroach.roachpb.ResponseHeader_ResumeReason", ResponseHeader_ResumeReason_name, ResponseHeader_ResumeReason_value)
	proto.RegisterEnum("cockroach.roachpb.CheckConsistencyResponse_Status", CheckConsistencyResponse_Status_name, CheckConsistencyResponse_Status_value)
	proto.RegisterEnum("cockroach.roachpb.AdmissionHeader_Source", AdmissionHeader_Source_name, AdmissionHeader_Source_value)
	proto.RegisterType((*RequestHeader)(nil), "cockroach.roachpb.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "cockroach.roachpb.ResponseHeader")
	proto.RegisterType((*GetRequest)(nil), "cockroach.roachpb.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "cockroach.roachpb.GetResponse")
	proto.RegisterType((*PutRequest)(nil), "cockroach.roachpb.PutRequest")
	proto.RegisterType((*PutResponse)(nil), "cockroach.roachpb.PutResponse")
	proto.RegisterType((*ConditionalPutRequest)(nil), "cockroach.roachpb.ConditionalPutRequest")
	proto.RegisterType((*ConditionalPutResponse)(nil), "cockroach.roachpb.ConditionalPutResponse")
	proto.RegisterType((*InitPutRequest)(nil), "cockroach.roachpb.InitPutRequest")
	proto.RegisterType((*InitPutResponse)(nil), "cockroach.roachpb.InitPutResponse")
	proto.RegisterType((*IncrementRequest)(nil), "cockroach.roachpb.IncrementRequest")
	proto.RegisterType((*IncrementResponse)(nil), "cockroach.roachpb.IncrementResponse")
	proto.RegisterType((*DeleteRequest)(nil), "cockroach.roachpb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "cockroach.roachpb.DeleteResponse")
	proto.RegisterType((*DeleteRangeRequest)(nil), "cockroach.roachpb.DeleteRangeRequest")
	proto.RegisterType((*DeleteRangeResponse)(nil), "cockroach.roachpb.DeleteRangeResponse")
	proto.RegisterType((*ClearRangeRequest)(nil), "cockroach.roachpb.ClearRangeRequest")
	proto.RegisterType((*ClearRangeResponse)(nil), "cockroach.roachpb.ClearRangeResponse")
	proto.RegisterType((*RevertRangeRequest)(nil), "cockroach.roachpb.RevertRangeRequest")
	proto.RegisterType((*RevertRangeResponse)(nil), "cockroach.roachpb.RevertRangeResponse")
	proto.RegisterType((*ScanRequest)(nil), "cockroach.roachpb.ScanRequest")
	proto.RegisterType((*ScanResponse)(nil), "cockroach.roachpb.ScanResponse")
	proto.RegisterType((*ReverseScanRequest)(nil), "cockroach.roachpb.ReverseScanRequest")
	proto.RegisterType((*ReverseScanResponse)(nil), "cockroach.roachpb.ReverseScanResponse")
	proto.RegisterType((*CheckConsistencyRequest)(nil), "cockroach.roachpb.CheckConsistencyRequest")
	proto.RegisterType((*CheckConsistencyResponse)(nil), "cockroach.roachpb.CheckConsistencyResponse")
	proto.RegisterType((*CheckConsistencyResponse_Result)(nil), "cockroach.roachpb.CheckConsistencyResponse.Result")
	proto.RegisterType((*RecomputeStatsRequest)(nil), "cockroach.roachpb.RecomputeStatsRequest")
	proto.RegisterType((*RecomputeStatsResponse)(nil), "cockroach.roachpb.RecomputeStatsResponse")
	proto.RegisterType((*EndTxnRequest)(nil), "cockroach.roachpb.EndTxnRequest")
	proto.RegisterType((*EndTxnResponse)(nil), "cockroach.roachpb.EndTxnResponse")
	proto.RegisterType((*AdminSplitRequest)(nil), "cockroach.roachpb.AdminSplitRequest")
	proto.RegisterType((*AdminSplitResponse)(nil), "cockroach.roachpb.AdminSplitResponse")
	proto.RegisterType((*AdminUnsplitRequest)(nil), "cockroach.roachpb.AdminUnsplitRequest")
	proto.RegisterType((*AdminUnsplitResponse)(nil), "cockroach.roachpb.AdminUnsplitResponse")
	proto.RegisterType((*AdminMergeRequest)(nil), "cockroach.roachpb.AdminMergeRequest")
	proto.RegisterType((*AdminMergeResponse)(nil), "cockroach.roachpb.AdminMergeResponse")
	proto.RegisterType((*AdminTransferLeaseRequest)(nil), "cockroach.roachpb.AdminTransferLeaseRequest")
	proto.RegisterType((*AdminTransferLeaseResponse)(nil), "cockroach.roachpb.AdminTransferLeaseResponse")
	proto.RegisterType((*ReplicationChange)(nil), "cockroach.roachpb.ReplicationChange")
	proto.RegisterType((*AdminChangeReplicasRequest)(nil), "cockroach.roachpb.AdminChangeReplicasRequest")
	proto.RegisterType((*AdminChangeReplicasResponse)(nil), "cockroach.roachpb.AdminChangeReplicasResponse")
	proto.RegisterType((*AdminRelocateRangeRequest)(nil), "cockroach.roachpb.AdminRelocateRangeRequest")
	proto.RegisterType((*AdminRelocateRangeResponse)(nil), "cockroach.roachpb.AdminRelocateRangeResponse")
	proto.RegisterType((*HeartbeatTxnRequest)(nil), "cockroach.roachpb.HeartbeatTxnRequest")
	proto.RegisterType((*HeartbeatTxnResponse)(nil), "cockroach.roachpb.HeartbeatTxnResponse")
	proto.RegisterType((*GCRequest)(nil), "cockroach.roachpb.GCRequest")
	proto.RegisterType((*GCRequest_GCKey)(nil), "cockroach.roachpb.GCRequest.GCKey")
	proto.RegisterType((*GCResponse)(nil), "cockroach.roachpb.GCResponse")
	proto.RegisterType((*PushTxnRequest)(nil), "cockroach.roachpb.PushTxnRequest")
	proto.RegisterType((*PushTxnResponse)(nil), "cockroach.roachpb.PushTxnResponse")
	proto.RegisterType((*RecoverTxnRequest)(nil), "cockroach.roachpb.RecoverTxnRequest")
	proto.RegisterType((*RecoverTxnResponse)(nil), "cockroach.roachpb.RecoverTxnResponse")
	proto.RegisterType((*QueryTxnRequest)(nil), "cockroach.roachpb.QueryTxnRequest")
	proto.RegisterType((*QueryTxnResponse)(nil), "cockroach.roachpb.QueryTxnResponse")
	proto.RegisterType((*QueryIntentRequest)(nil), "cockroach.roachpb.QueryIntentRequest")
	proto.RegisterType((*QueryIntentResponse)(nil), "cockroach.roachpb.QueryIntentResponse")
	proto.RegisterType((*ResolveIntentRequest)(nil), "cockroach.roachpb.ResolveIntentRequest")
	proto.RegisterType((*ResolveIntentResponse)(nil), "cockroach.roachpb.ResolveIntentResponse")
	proto.RegisterType((*ResolveIntentRangeRequest)(nil), "cockroach.roachpb.ResolveIntentRangeRequest")
	proto.RegisterType((*ResolveIntentRangeResponse)(nil), "cockroach.roachpb.ResolveIntentRangeResponse")
	proto.RegisterType((*MergeRequest)(nil), "cockroach.roachpb.MergeRequest")
	proto.RegisterType((*MergeResponse)(nil), "cockroach.roachpb.MergeResponse")
	proto.RegisterType((*TruncateLogRequest)(nil), "cockroach.roachpb.TruncateLogRequest")
	proto.RegisterType((*TruncateLogResponse)(nil), "cockroach.roachpb.TruncateLogResponse")
	proto.RegisterType((*RequestLeaseRequest)(nil), "cockroach.roachpb.RequestLeaseRequest")
	proto.RegisterType((*TransferLeaseRequest)(nil), "cockroach.roachpb.TransferLeaseRequest")
	proto.RegisterType((*LeaseInfoRequest)(nil), "cockroach.roachpb.LeaseInfoRequest")
	proto.RegisterType((*LeaseInfoResponse)(nil), "cockroach.roachpb.LeaseInfoResponse")
	proto.RegisterType((*RequestLeaseResponse)(nil), "cockroach.roachpb.RequestLeaseResponse")
	proto.RegisterType((*ComputeChecksumRequest)(nil), "cockroach.roachpb.ComputeChecksumRequest")
	proto.RegisterType((*ComputeChecksumResponse)(nil), "cockroach.roachpb.ComputeChecksumResponse")
	proto.RegisterType((*ExternalStorage)(nil), "cockroach.roachpb.ExternalStorage")
	proto.RegisterType((*ExternalStorage_LocalFilePath)(nil), "cockroach.roachpb.ExternalStorage.LocalFilePath")
	proto.RegisterType((*ExternalStorage_Http)(nil), "cockroach.roachpb.ExternalStorage.Http")
	proto.RegisterType((*ExternalStorage_S3)(nil), "cockroach.roachpb.ExternalStorage.S3")
	proto.RegisterType((*ExternalStorage_GCS)(nil), "cockroach.roachpb.ExternalStorage.GCS")
	proto.RegisterType((*ExternalStorage_Azure)(nil), "cockroach.roachpb.ExternalStorage.Azure")
	proto.RegisterType((*ExternalStorage_FileTable)(nil), "cockroach.roachpb.ExternalStorage.FileTable")
	proto.RegisterType((*RetryTracingEvent)(nil), "cockroach.roachpb.RetryTracingEvent")
	proto.RegisterType((*FileEncryptionOptions)(nil), "cockroach.roachpb.FileEncryptionOptions")
	proto.RegisterType((*ExportRequest)(nil), "cockroach.roachpb.ExportRequest")
	proto.RegisterMapType((map[string]*ExternalStorage)(nil), "cockroach.roachpb.ExportRequest.StorageByLocalityKvEntry")
	proto.RegisterType((*BulkOpSummary)(nil), "cockroach.roachpb.BulkOpSummary")
	proto.RegisterMapType((map[uint64]int64)(nil), "cockroach.roachpb.BulkOpSummary.EntryCountsEntry")
	proto.RegisterType((*ExportResponse)(nil), "cockroach.roachpb.ExportResponse")
	proto.RegisterType((*ExportResponse_File)(nil), "cockroach.roachpb.ExportResponse.File")
	proto.RegisterType((*AdminScatterRequest)(nil), "cockroach.roachpb.AdminScatterRequest")
	proto.RegisterType((*AdminScatterResponse)(nil), "cockroach.roachpb.AdminScatterResponse")
	proto.RegisterType((*AdminScatterResponse_Range)(nil), "cockroach.roachpb.AdminScatterResponse.Range")
	proto.RegisterType((*AdminVerifyProtectedTimestampRequest)(nil), "cockroach.roachpb.AdminVerifyProtectedTimestampRequest")
	proto.RegisterType((*AdminVerifyProtectedTimestampResponse)(nil), "cockroach.roachpb.AdminVerifyProtectedTimestampResponse")
	proto.RegisterType((*AdminVerifyProtectedTimestampResponse_FailedRange)(nil), "cockroach.roachpb.AdminVerifyProtectedTimestampResponse.FailedRange")
	proto.RegisterType((*AddSSTableRequest)(nil), "cockroach.roachpb.AddSSTableRequest")
	proto.RegisterType((*AddSSTableResponse)(nil), "cockroach.roachpb.AddSSTableResponse")
	proto.RegisterType((*RefreshRequest)(nil), "cockroach.roachpb.RefreshRequest")
	proto.RegisterType((*RefreshResponse)(nil), "cockroach.roachpb.RefreshResponse")
	proto.RegisterType((*RefreshRangeRequest)(nil), "cockroach.roachpb.RefreshRangeRequest")
	proto.RegisterType((*RefreshRangeResponse)(nil), "cockroach.roachpb.RefreshRangeResponse")
	proto.RegisterType((*SubsumeRequest)(nil), "cockroach.roachpb.SubsumeRequest")
	proto.RegisterType((*SubsumeResponse)(nil), "cockroach.roachpb.SubsumeResponse")
	proto.RegisterType((*RangeStatsRequest)(nil), "cockroach.roachpb.RangeStatsRequest")
	proto.RegisterType((*RangeStatsResponse)(nil), "cockroach.roachpb.RangeStatsResponse")
	proto.RegisterType((*MigrateRequest)(nil), "cockroach.roachpb.MigrateRequest")
	proto.RegisterType((*MigrateResponse)(nil), "cockroach.roachpb.MigrateResponse")
	proto.RegisterType((*RequestUnion)(nil), "cockroach.roachpb.RequestUnion")
	proto.RegisterType((*ResponseUnion)(nil), "cockroach.roachpb.ResponseUnion")
	proto.RegisterType((*Header)(nil), "cockroach.roachpb.Header")
	proto.RegisterType((*AdmissionHeader)(nil), "cockroach.roachpb.AdmissionHeader")
	proto.RegisterType((*BatchRequest)(nil), "cockroach.roachpb.BatchRequest")
	proto.RegisterType((*BatchResponse)(nil), "cockroach.roachpb.BatchResponse")
	proto.RegisterType((*BatchResponse_Header)(nil), "cockroach.roachpb.BatchResponse.Header")
	proto.RegisterType((*RangeLookupRequest)(nil), "cockroach.roachpb.RangeLookupRequest")
	proto.RegisterType((*RangeLookupResponse)(nil), "cockroach.roachpb.RangeLookupResponse")
	proto.RegisterType((*RangeFeedRequest)(nil), "cockroach.roachpb.RangeFeedRequest")
	proto.RegisterType((*RangeFeedValue)(nil), "cockroach.roachpb.RangeFeedValue")
	proto.RegisterType((*RangeFeedCheckpoint)(nil), "cockroach.roachpb.RangeFeedCheckpoint")
	proto.RegisterType((*RangeFeedError)(nil), "cockroach.roachpb.RangeFeedError")
	proto.RegisterType((*RangeFeedEvent)(nil), "cockroach.roachpb.RangeFeedEvent")
	proto.RegisterType((*ResetQuorumRequest)(nil), "cockroach.roachpb.ResetQuorumRequest")
	proto.RegisterType((*ResetQuorumResponse)(nil), "cockroach.roachpb.ResetQuorumResponse")
	proto.RegisterType((*GossipSubscriptionRequest)(nil), "cockroach.roachpb.GossipSubscriptionRequest")
	proto.RegisterType((*GossipSubscriptionEvent)(nil), "cockroach.roachpb.GossipSubscriptionEvent")
	proto.RegisterType((*JoinNodeRequest)(nil), "cockroach.roachpb.JoinNodeRequest")
	proto.RegisterType((*JoinNodeResponse)(nil), "cockroach.roachpb.JoinNodeResponse")
	proto.RegisterType((*ContentionEvent)(nil), "cockroach.roachpb.ContentionEvent")
}

func init() { proto.RegisterFile("roachpb/api.proto", fileDescriptor_e08772acc330f58b) }

var fileDescriptor_e08772acc330f58b = []byte{
	// 8195 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x7d, 0x5f, 0x6c, 0x23, 0x49,
	0x7a, 0x9f, 0x9a, 0xa4, 0x24, 0xf2, 0xa3, 0x44, 0xb6, 0x4a, 0xf3, 0x47, 0xa3, 0xdd, 0x95, 0x66,
	0x7a, 0x76, 0xfe, 0xfa, 0x96, 0xda, 0x99, 0xb9, 0xcb, 0xad, 0x77, 0xd7, 0x7b, 0x16, 0x29, 0xce,
	0x90, 0xd2, 0x48, 0xa3, 0x69, 0x52, 0x33, 0xd8, 0xf5, 0x39, 0xed, 0x56, 0x77, 0x89, 0xea, 0x13,
	0xd9, 0xcd, 0xe9, 0x6e, 0x6a, 0xc4, 0x05, 0xf2, 0x90, 0xc4, 0x70, 0xee, 0x29, 0xb8, 0x00, 0x01,
	0x7c, 0x07, 0x07, 0xc1, 0x39, 0x36, 0x92, 0x87, 0x3c, 0x24, 0x88, 0x83, 0xfc, 0x43, 0x12, 0x23,
	0x4f, 0x39, 0x04, 0x87, 0xdc, 0x19, 0xc8, 0x83, 0x11, 0x20, 0x8a, 0xa3, 0xcb, 0x43, 0x0c, 0x23,
	0x48, 0x10, 0x04, 0x30, 0xb0, 0x40, 0x82, 0xa0, 0xfe, 0xf4, 0x3f, 0xb2, 0x49, 0x51, 0xb3, 0x7d,
	0xf1, 0x02, 0x7e, 0x91, 0xd8, 0x5f, 0xd5, 0xf7, 0x75, 0xd5, 0x57, 0x55, 0x5f, 0x7d, 0xbf, 0xaa,
	0xaf, 0xaa, 0x61, 0xc1, 0xb6, 0x54, 0xed, 0xb0, 0xbb, 0xbf, 0xa6, 0x76, 0x8d, 0x52, 0xd7, 0xb6,
	0x5c, 0x0b, 0x2d, 0x68, 0x96, 0x76, 0x44, 0xc9, 0x25, 0x9e, 0xb8, 0x7c, 0xff, 0xe8, 0x78, 0xed,
	0xe8, 0xd8, 0xc1, 0xf6, 0x31, 0xb6, 0xd7, 0x34, 0xcb, 0xd4, 0x7a, 0xb6, 0x8d, 0x4d, 0xad, 0xbf,
	0xd6, 0xb6, 0xb4, 0x23, 0xfa, 0xc7, 0x30, 0x5b, 0x8c, 0x3d, 0x9a, 0xd7, 0xc6, 0xaa, 0xee, 0xf4,
	0x3a, 0x1d, 0xd5, 0xee, 0xaf, 0xd9, 0x4e, 0x77, 0x7f, 0x8d, 0x3f, 0xf0, 0xbc, 0xc8, 0x7b, 0xbb,
	0xae, 0xba, 0x2a, 0xa7, 0x5d, 0xf2, 0x68, 0xd8, 0xb6, 0x2d, 0xdb, 0xe1, 0xd4, 0x2b, 0x1e, 0xb5,
	0x83, 0x5d, 0x35, 0x94, 0xfb, 0x2d, 0xc7, 0xb5, 0x6c, 0xb5, 0x85, 0xd7, 0xb0, 0xd9, 0x32, 0x4c,
	0x4c, 0x32, 0x1c, 0x6b, 0x1a, 0x4f, 0x7c, 0x3b, 0x36, 0xf1, 0x11, 0x4f, 0x5d, 0xea, 0xb9, 0x46,
	0x7b, 0xed, 0xb0, 0xad, 0xad, 0xb9, 0x46, 0x07, 0x3b, 0xae, 0xda, 0xe9, 0x7a, 0x55, 0xa0, 0x29,
	0xae, 0xad, 0x6a, 0x86, 0xd9, 0xf2, 0xfe, 0x77, 0xf7, 0xd7, 0x6c, 0xac, 0x59, 0xb6, 0x8e, 0x75,
	0xc5, 0xe9, 0xaa, 0xa6, 0x57, 0xdc, 0x96, 0xd5, 0xb2, 0xe8, 0xcf, 0x35, 0xf2, 0x8b, 0x53, 0x57,
	0x5a, 0x96, 0xd5, 0x6a, 0xe3, 0x35, 0xfa, 0xb4, 0xdf, 0x3b, 0x58, 0xd3, 0x7b, 0xb6, 0xea, 0x1a,
	0x16, 0xe7, 0x92, 0xfe, 0x89, 0x00, 0xf3, 0x32, 0x7e, 0xd5, 0xc3, 0x8e, 0x5b, 0xc3, 0xaa, 0x8e,
	0x6d, 0x74, 0x0d, 0xd2, 0x47, 0xb8, 0xbf, 0x94, 0xbe, 0x2e, 0xdc, 0x9d, 0x2b, 0xcf, 0x7e, 0x71,
	0xba, 0x9a, 0xde, 0xc2, 0x7d, 0x99, 0xd0, 0xd0, 0x75, 0x98, 0xc5, 0xa6, 0xae, 0x90, 0xe4, 0x4c,
	0x34, 0x79, 0x06, 0x9b, 0xfa, 0x16, 0xee, 0xa3, 0x6f, 0x43, 0xd6, 0x21, 0xd2, 0x4c, 0x0d, 0x2f,
	0x4d, 0x5f, 0x17, 0xee, 0x4e, 0x97, 0x7f, 0xf9, 0x8b, 0xd3, 0xd5, 0x8f, 0x5b, 0x86, 0x7b, 0xd8,
	0xdb, 0x2f, 0x69, 0x56, 0x67, 0xcd, 0x6f, 0x53, 0x7d, 0x3f, 0xf8, 0xbd, 0xd6, 0x3d, 0x6a, 0xad,
	0x0d, 0xea, 0xa8, 0xd4, 0x3c, 0x31, 0x1b, 0xf8, 0x95, 0xec, 0x4b, 0xdc, 0xcc, 0x64, 0x05, 0x31,
	0xb5, 0x99, 0xc9, 0xa6, 0xc4, 0xb4, 0xf4, 0x93, 0x14, 0x14, 0x64, 0xec, 0x74, 0x2d, 0xd3, 0xc1,
	0xbc, 0xe4, 0xef, 0x43, 0xda, 0x3d, 0x31, 0x69, 0xc9, 0xf3, 0x0f, 0x57, 0x4a, 0x43, 0xbd, 0xa7,
	0xd4, 0xb4, 0x55, 0xd3, 0x51, 0x35, 0x52, 0x7d, 0x99, 0x64, 0x45, 0x1f, 0x40, 0xde, 0xc6, 0x4e,
	0xaf, 0x83, 0xa9, 0x22, 0x69, 0xa5, 0xf2, 0x0f, 0xaf, 0xc6, 0x70, 0x36, 0xba, 0xaa, 0x29, 0x03,
	0xcb, 0x4b, 0x7e, 0xa3, 0x06, 0xcc, 0x73, 0x4e, 0x1b, 0xab, 0x8e, 0x65, 0x2e, 0xcd, 0x5e, 0x17,
	0xee, 0x16, 0x1e, 0x96, 0x62, 0x78, 0xa3, 0xa5, 0x24, 0x8f, 0xbd, 0x0e, 0x96, 0x29, 0x97, 0x3c,
	0x67, 0x87, 0x9e, 0xd0, 0x35, 0xc8, 0x9a, 0xbd, 0x0e, 0xd1, 0xaf, 0x43, 0xb5, 0x97, 0x96, 0x67,
	0xcd, 0x5e, 0x67, 0x0b, 0xf7, 0x1d, 0xf4, 0x16, 0xe4, 0x48, 0xd2, 0x7e, 0xdf, 0xc5, 0xce, 0x52,
	0x96, 0xa6, 0x91, 0xbc, 0x65, 0xf2, 0x2c, 0x7d, 0x02, 0x73, 0x61, 0xa9, 0x08, 0x41, 0x41, 0xae,
	0x36, 0xf6, 0xb6, 0xab, 0xca, 0xde, 0xce, 0xd6, 0xce, 0xb3, 0x97, 0x3b, 0xe2, 0x14, 0xba, 0x04,
	0x22, 0xa7, 0x6d, 0x55, 0x3f, 0x55, 0x9e, 0xd6, 0xb7, 0xeb, 0x4d, 0x51, 0x58, 0xce, 0x7c, 0xf7,
	0x77, 0x56, 0xa6, 0x36, 0x33, 0xd9, 0x19, 0x71, 0x56, 0xfa, 0x1d, 0x01, 0xe0, 0x09, 0x76, 0x79,
	0x6f, 0x40, 0x65, 0x98, 0x39, 0xa4, 0x25, 0x5e, 0x12, 0xa8, 0x5a, 0xae, 0xc7, 0x56, 0x2d, 0xd4,
	0x73, 0xca, 0xd9, 0x1f, 0x9d, 0xae, 0x4e, 0xfd, 0xf4, 0x74, 0x55, 0x90, 0x39, 0x27, 0x7a, 0x0e,
	0xf9, 0x23, 0xdc, 0x57, 0xf8, 0xb8, 0x5c, 0x4a, 0x51, 0x1d, 0xbd, 0x1f, 0x12, 0x74, 0x74, 0x5c,
	0xf2, 0x86, 0x68, 0x29, 0x34, 0x9c, 0x4b, 0x84, 0xa3, 0xd4, 0x70, 0x6d, 0x6c, 0xb6, 0xdc, 0x43,
	0x19, 0x8e, 0x70, 0xff, 0x29, 0x93, 0x21, 0xfd, 0xbe, 0x00, 0x79, 0x5a, 0x4a, 0xa6, 0x54, 0x54,
	0x19, 0x28, 0xe6, 0x8d, 0x73, 0x5b, 0x20, 0xa6, 0x9c, 0x25, 0x98, 0x3e, 0x56, 0xdb, 0x3d, 0x4c,
	0x4b, 0x98, 0x7f, 0xb8, 0x14, 0x23, 0xe3, 0x05, 0x49, 0x97, 0x59, 0x36, 0xf4, 0x11, 0xcc, 0x19,
	0xa6, 0x8b, 0x4d, 0x57, 0x61, 0x6c, 0xe9, 0x73, 0xd8, 0xf2, 0x2c, 0x37, 0x7d, 0x90, 0xfe, 0xb1,
	0x00, 0xb0, 0xdb, 0x4b, 0x54, 0xcf, 0x5f, 0x9f, 0xb0, 0xfc, 0xe5, 0x0c, 0x61, 0xf5, 0x6a, 0x71,
	0x05, 0x66, 0x0c, 0xb3, 0x6d, 0x98, 0xac, 0xfc, 0x59, 0x99, 0x3f, 0xa1, 0x4b, 0x30, 0xbd, 0xdf,
	0x36, 0x4c, 0x9d, 0x8e, 0x87, 0xac, 0xcc, 0x1e, 0x24, 0x19, 0xf2, 0xb4, 0xd4, 0x09, 0xea, 0x5d,
	0x3a, 0x4d, 0xc1, 0xe5, 0x8a, 0x65, 0xea, 0x06, 0x19, 0x92, 0x6a, 0xfb, 0x2b, 0xa1, 0x95, 0x4d,
	0xb8, 0xa4, 0xe3, 0xae, 0x8d, 0x35, 0xd5, 0xc5, 0xba, 0x82, 0x4f, 0xba, 0x13, 0xb6, 0x31, 0x0a,
	0xb8, 0xaa, 0x27, 0x5d, 0x4a, 0x23, 0xa3, 0x96, 0x08, 0x60, 0xa3, 0x76, 0x86, 0x98, 0x4c, 0x39,
	0x8b, 0x4f, 0xba, 0x74, 0xd4, 0xc6, 0xab, 0x19, 0x7d, 0x1d, 0xae, 0xaa, 0xed, 0xb6, 0xf5, 0x5a,
	0x31, 0x0e, 0x14, 0xdd, 0xc2, 0x8e, 0x62, 0x5a, 0xae, 0x82, 0x4f, 0x0c, 0xc7, 0xa5, 0x26, 0x21,
	0x2b, 0x2f, 0xd2, 0xe4, 0xfa, 0xc1, 0x86, 0x85, 0x9d, 0x1d, 0xcb, 0xad, 0x92, 0xa4, 0x50, 0x53,
	0xce, 0x86, 0x9b, 0x52, 0xfa, 0x55, 0xb8, 0x32, 0xa8, 0xdf, 0x24, 0xdb, 0xef, 0xc7, 0x02, 0x14,
	0xea, 0xa6, 0xe1, 0x7e, 0x25, 0x1a, 0xce, 0xd7, 0x67, 0x3a, 0xac, 0xcf, 0xfb, 0x20, 0x1e, 0xa8,
	0x46, 0xfb, 0x99, 0xd9, 0xb4, 0x3a, 0xfb, 0x8e, 0x6b, 0x99, 0xd8, 0xe1, 0x0a, 0x1f, 0xa2, 0x4b,
	0x2f, 0xa0, 0xe8, 0xd7, 0x26, 0x49, 0x35, 0xb9, 0x20, 0xd6, 0x4d, 0xcd, 0xc6, 0x1d, 0x6c, 0x26,
	0xaa, 0xa7, 0xb7, 0x21, 0x67, 0x78, 0x72, 0xa9, 0xae, 0xd2, 0x72, 0x40, 0x90, 0x7a, 0xb0, 0x10,
	0x7a, 0x6b, 0x92, 0xe6, 0x92, 0x4c, 0x46, 0xf8, 0xb5, 0x12, 0xb4, 0x11, 0x99, 0x8c, 0xf0, 0x6b,
	0x66, 0xde, 0x1a, 0x30, 0xbf, 0x81, 0xdb, 0xd8, 0xc5, 0x09, 0xd6, 0x54, 0xda, 0x83, 0x82, 0x27,
	0x34, 0xc9, 0x86, 0xf9, 0x4d, 0x01, 0x10, 0x97, 0xab, 0x9a, 0xad, 0x24, 0x4b, 0x8c, 0x56, 0x89,
	0x6b, 0xe1, 0xf6, 0x6c, 0x93, 0x4d, 0xe7, 0xac, 0x4f, 0x02, 0x23, 0xd1, 0x19, 0x3d, 0x18, 0xb2,
	0x99, 0xf0, 0x90, 0xe5, 0xee, 0xcd, 0x6b, 0x58, 0x8c, 0x14, 0x2c, 0xd9, 0xe6, 0xcb, 0xd0, 0x32,
	0xa5, 0xae, 0xa7, 0xc3, 0x3e, 0x1c, 0x25, 0x4a, 0xdf, 0x17, 0x60, 0xa1, 0xd2, 0xc6, 0xaa, 0x9d,
	0xb8, 0x46, 0xbe, 0x05, 0x59, 0x1d, 0xab, 0x3a, 0xad, 0x32, 0x1b, 0xd8, 0xef, 0x84, 0xa4, 0x10,
	0x4f, 0xb7, 0x74, 0xd8, 0xd6, 0x4a, 0x4d, 0xcf, 0x07, 0xe6, 0xa3, 0xdb, 0x67, 0x92, 0x3e, 0x05,
	0x14, 0x2e, 0x59, 0x92, 0x1d, 0xe1, 0x77, 0x53, 0x80, 0x64, 0x7c, 0x8c, 0x6d, 0x37, 0xf1, 0x6a,
	0x6f, 0x40, 0xde, 0x55, 0xed, 0x16, 0x76, 0x15, 0xe2, 0xdd, 0x5f, 0xa4, 0xe6, 0xc0, 0xf8, 0x08,
	0x19, 0x35, 0xe1, 0x0e, 0x36, 0xd5, 0xfd, 0x36, 0xa6, 0x52, 0x94, 0x7d, 0xab, 0x67, 0xea, 0x8a,
	0xe1, 0x62, 0x5b, 0x75, 0x2d, 0x5b, 0xb1, 0xba, 0xae, 0xd1, 0x31, 0x3e, 0xa7, 0x8e, 0x3d, 0xef,
	0x6a, 0x37, 0x59, 0x76, 0xc2, 0x5c, 0x26, 0x99, 0xeb, 0x3c, 0xef, 0xb3, 0x50, 0x56, 0x54, 0x82,
	0x45, 0xa3, 0x65, 0x5a, 0x36, 0x56, 0x5a, 0x9a, 0xe2, 0x1e, 0xda, 0xd8, 0x39, 0xb4, 0xda, 0xde,
	0x84, 0xb4, 0xc0, 0x92, 0x9e, 0x68, 0x4d, 0x2f, 0x41, 0xfa, 0x0c, 0x16, 0x23, 0x5a, 0x4a, 0xb2,
	0x09, 0xfe, 0xa7, 0x00, 0xf9, 0x86, 0xa6, 0x9a, 0x49, 0xea, 0xfe, 0x13, 0xc8, 0x3b, 0x9a, 0x6a,
	0x2a, 0x07, 0x96, 0xdd, 0x51, 0x5d, 0x5a, 0xaf, 0x42, 0x44, 0xf7, 0xbe, 0x7f, 0xaf, 0xa9, 0xe6,
	0x63, 0x9a, 0x49, 0x06, 0xc7, 0xff, 0x3d, 0xe8, 0xbf, 0x4e, 0x7f, 0x79, 0xff, 0x95, 0x0d, 0xef,
	0xcd, 0x4c, 0x36, 0x2d, 0x66, 0xa4, 0x3f, 0x15, 0x60, 0x8e, 0x55, 0x39, 0xc9, 0xe1, 0xfd, 0x0d,
	0xc8, 0xd8, 0xd6, 0x6b, 0x36, 0xbc, 0xf3, 0x0f, 0xdf, 0x8a, 0x11, 0xb1, 0x85, 0xfb, 0xe1, 0xf9,
	0x93, 0x66, 0x47, 0x65, 0xe0, 0x5e, 0xaa, 0x42, 0xb9, 0xd3, 0x93, 0x72, 0x03, 0xe3, 0x92, 0x89,
	0x8c, 0x3b, 0x50, 0xdc, 0x57, 0x5d, 0xed, 0x50, 0xb1, 0x79, 0x21, 0xc9, 0x5c, 0x9b, 0xbe, 0x3b,
	0x27, 0x17, 0x28, 0xd9, 0x2b, 0xba, 0x43, 0x6a, 0xce, 0xc6, 0x9b, 0x83, 0xff, 0x9c, 0xb5, 0xf9,
	0xff, 0x15, 0xf8, 0x18, 0xf2, 0x6a, 0xfe, 0xe7, 0xad, 0xe9, 0x7f, 0x90, 0x82, 0xab, 0x95, 0x43,
	0xac, 0x1d, 0x55, 0x2c, 0xd3, 0x31, 0x1c, 0x97, 0xe8, 0x2e, 0xc9, 0xf6, 0x7f, 0x0b, 0x72, 0xaf,
	0x0d, 0xf7, 0x50, 0xd1, 0x8d, 0x83, 0x03, 0x6a, 0x6d, 0xb3, 0x72, 0x96, 0x10, 0x36, 0x8c, 0x83,
	0x03, 0xf4, 0x08, 0x32, 0x1d, 0x4b, 0x67, 0xce, 0x7c, 0xe1, 0xe1, 0x6a, 0x8c, 0x78, 0x5a, 0x34,
	0xa7, 0xd7, 0xd9, 0xb6, 0x74, 0x2c, 0xd3, 0xcc, 0x68, 0x05, 0x40, 0x23, 0xd4, 0xae, 0x65, 0x98,
	0x2e, 0x37, 0x8e, 0x21, 0x0a, 0xaa, 0x41, 0xce, 0xc5, 0x76, 0xc7, 0x30, 0x55, 0x17, 0x2f, 0x4d,
	0x53, 0xe5, 0xbd, 0x1b, 0x5b, 0xf0, 0x6e, 0xdb, 0xd0, 0xd4, 0x0d, 0xec, 0x68, 0xb6, 0xd1, 0x75,
	0x2d, 0x9b, 0x6b, 0x31, 0x60, 0x96, 0xfe, 0x7a, 0x06, 0x96, 0x86, 0x75, 0x93, 0x64, 0x0f, 0xd9,
	0x85, 0x19, 0x1b, 0x3b, 0xbd, 0xb6, 0xcb, 0xfb, 0xc8, 0xc3, 0x51, 0x2a, 0x88, 0x29, 0x01, 0x5d,
	0xba, 0x68, 0xbb, 0xbc, 0xd8, 0x5c, 0xce, 0xf2, 0xbf, 0x14, 0x60, 0x86, 0x25, 0xa0, 0x07, 0x90,
	0xb5, 0xc9, 0xc4, 0xa0, 0x18, 0x3a, 0x2d, 0x63, 0xba, 0x7c, 0xe5, 0xec, 0x74, 0x75, 0x96, 0x4e,
	0x16, 0xf5, 0x8d, 0x2f, 0x82, 0x9f, 0xf2, 0x2c, 0xcd, 0x57, 0xd7, 0x49, 0x6b, 0x39, 0xae, 0x6a,
	0xbb, 0x74, 0x51, 0x29, 0xc5, 0x10, 0x12, 0x25, 0x6c, 0xe1, 0x3e, 0xda, 0x84, 0x19, 0xc7, 0x55,
	0xdd, 0x9e, 0xc3, 0xdb, 0xeb, 0x42, 0x85, 0x6d, 0x50, 0x4e, 0x99, 0x4b, 0x20, 0xee, 0x96, 0x8e,
	0x5d, 0xd5, 0x68, 0xd3, 0x06, 0xcc, 0xc9, 0xfc, 0x49, 0xfa, 0x2d, 0x01, 0x66, 0x58, 0x56, 0x74,
	0x15, 0x16, 0xe5, 0xf5, 0x9d, 0x27, 0x55, 0xa5, 0xbe, 0xb3, 0x51, 0x6d, 0x56, 0xe5, 0xed, 0xfa,
	0xce, 0x7a, 0xb3, 0x2a, 0x4e, 0xa1, 0x2b, 0x80, 0xbc, 0x84, 0xca, 0xb3, 0x9d, 0x46, 0xbd, 0xd1,
	0xac, 0xee, 0x34, 0x45, 0x81, 0xae, 0xa9, 0x50, 0x7a, 0x88, 0x9a, 0x42, 0xef, 0xc2, 0xf5, 0x41,
	0xaa, 0xd2, 0x68, 0xae, 0x37, 0x1b, 0x4a, 0xb5, 0xd1, 0xac, 0x6f, 0xaf, 0x37, 0xab, 0x1b, 0x62,
	0x7a, 0x4c, 0x2e, 0xf2, 0x12, 0x59, 0xae, 0x56, 0x9a, 0x62, 0x46, 0x72, 0xe1, 0xb2, 0x8c, 0x35,
	0xab, 0xd3, 0xed, 0xb9, 0x98, 0x94, 0xd2, 0x49, 0x72, 0xa4, 0x5c, 0x85, 0x59, 0xdd, 0xee, 0x2b,
	0x76, 0xcf, 0xe4, 0xe3, 0x64, 0x46, 0xb7, 0xfb, 0x72, 0xcf, 0x94, 0xfe, 0xa1, 0x00, 0x57, 0x06,
	0x5f, 0x9b, 0x64, 0x27, 0x7c, 0x0e, 0x79, 0x55, 0xd7, 0xb1, 0xae, 0xe8, 0xb8, 0xed, 0xaa, 0xdc,
	0x25, 0xba, 0x1f, 0x92, 0xc4, 0x97, 0x02, 0x4b, 0xfe, 0x52, 0xe0, 0xf6, 0x8b, 0x4a, 0x85, 0x16,
	0x64, 0x83, 0x70, 0x78, 0xe6, 0x87, 0x0a, 0xa1, 0x14, 0xe9, 0x07, 0x19, 0x98, 0xaf, 0x9a, 0x7a,
	0xf3, 0x24, 0xd1, 0xb9, 0xe4, 0x0a, 0xcc, 0x68, 0x56, 0xa7, 0x63, 0xb8, 0x9e, 0x82, 0xd8, 0x13,
	0xfa, 0xc5, 0x90, 0x2b, 0x9b, 0x9e, 0xc0, 0xa1, 0x0b, 0x9c, 0x58, 0xf4, 0x6b, 0x70, 0x95, 0x58,
	0x4d, 0xdb, 0x54, 0xdb, 0x0a, 0x93, 0xa6, 0xb8, 0xb6, 0xd1, 0x6a, 0x61, 0x9b, 0x2f, 0x3f, 0xde,
	0x8d, 0x29, 0x67, 0x9d, 0x73, 0x54, 0x28, 0x43, 0x93, 0xe5, 0x97, 0x2f, 0x1b, 0x71, 0x64, 0xf4,
	0x31, 0x00, 0x99, 0x8a, 0xe8, 0x92, 0xa6, 0xc3, 0xed, 0xd1, 0xa8, 0x35, 0x4d, 0xcf, 0x04, 0x11,
	0x06, 0xf2, 0xec, 0xa0, 0xe7, 0x20, 0x1a, 0xa6, 0x72, 0xd0, 0x36, 0x5a, 0x87, 0xae, 0xf2, 0xda,
	0x36, 0x5c, 0xec, 0x2c, 0x2d, 0x50, 0x19, 0x71, 0x4d, 0xdd, 0xe0, 0x4b, 0xb3, 0xfa, 0x4b, 0x92,
	0x93, 0x4b, 0x2b, 0x18, 0xe6, 0x63, 0xca, 0x4f, 0x89, 0x0e, 0x5a, 0x23, 0x50, 0xe8, 0x55, 0xcf,
	0xb0, 0xb1, 0xf2, 0xa0, 0xab, 0xd1, 0x75, 0x90, 0x6c, 0xb9, 0x70, 0x76, 0xba, 0x0a, 0x32, 0x23,
	0x3f, 0xd8, 0xad, 0x10, 0x68, 0xc4, 0x7e, 0x77, 0x35, 0xa2, 0xf6, 0xae, 0x65, 0x38, 0x96, 0xb9,
	0x94, 0x63, 0x6a, 0x67, 0x4f, 0xe8, 0x1e, 0x88, 0xee, 0x89, 0xa9, 0x1c, 0x62, 0xd5, 0x76, 0xf7,
	0xb1, 0xea, 0x92, 0xf9, 0x19, 0x68, 0x8e, 0xa2, 0x7b, 0x62, 0xd6, 0x42, 0xe4, 0xcd, 0x4c, 0x76,
	0x56, 0xcc, 0x6e, 0x66, 0xb2, 0x59, 0x31, 0x27, 0xfd, 0x27, 0x01, 0x0a, 0x5e, 0xdf, 0x48, 0xb2,
	0x1b, 0xdf, 0x05, 0xd1, 0x32, 0xb1, 0xd2, 0x3d, 0x54, 0x1d, 0xcc, 0xdb, 0x92, 0xcf, 0x0e, 0x05,
	0xcb, 0xc4, 0xbb, 0x84, 0xcc, 0x5a, 0x06, 0xed, 0xc2, 0x82, 0xe3, 0xaa, 0x2d, 0xc3, 0x6c, 0x29,
	0xfe, 0x12, 0x3f, 0xf5, 0x2c, 0x26, 0x44, 0x02, 0x22, 0xe7, 0xf6, 0xe9, 0x11, 0x97, 0xe2, 0x0f,
	0x04, 0x58, 0x58, 0xd7, 0x3b, 0x86, 0xd9, 0xe8, 0xb6, 0x8d, 0x44, 0x17, 0x18, 0xde, 0x85, 0x9c,
	0x43, 0x64, 0x06, 0xd6, 0x39, 0x80, 0x8b, 0x59, 0x9a, 0x42, 0xcc, 0xf4, 0x53, 0x28, 0xe2, 0x93,
	0xae, 0xc1, 0xf6, 0x15, 0x18, 0xca, 0xc9, 0x4c, 0x5e, 0xb7, 0x42, 0xc0, 0x4b, 0x92, 0x78, 0x9d,
	0x3e, 0x05, 0x14, 0xae, 0x52, 0x92, 0x40, 0xe3, 0x53, 0x58, 0xa4, 0xa2, 0xf7, 0x4c, 0x27, 0x61,
	0x7d, 0x49, 0xbf, 0x02, 0x97, 0xa2, 0xa2, 0x93, 0x2c, 0xf7, 0x4b, 0xde, 0xca, 0xdb, 0xd8, 0x4e,
	0x14, 0xa1, 0xfa, 0xba, 0xe6, 0x82, 0x93, 0x2c, 0xf3, 0xaf, 0x0b, 0x70, 0x8d, 0xca, 0xa6, 0x5b,
	0x2f, 0x07, 0xd8, 0x7e, 0x8a, 0x55, 0x27, 0x51, 0x78, 0x7d, 0x13, 0x66, 0x18, 0x4c, 0xa6, 0xfd,
	0x73, 0xba, 0x9c, 0x27, 0x6e, 0x46, 0xc3, 0xb5, 0x6c, 0xe2, 0x66, 0xf0, 0x24, 0x49, 0x85, 0xe5,
	0xb8, 0x52, 0x24, 0x59, 0xd3, 0xbf, 0x2d, 0xc0, 0x02, 0xf7, 0xf0, 0x48, 0x57, 0xae, 0x1c, 0x12,
	0x07, 0x07, 0x55, 0x21, 0xaf, 0xd1, 0x5f, 0x8a, 0xdb, 0xef, 0x62, 0x2a, 0xbf, 0x30, 0xce, 0x39,
	0x64, 0x6c, 0xcd, 0x7e, 0x17, 0x13, 0x0f, 0xd3, 0xfb, 0x4d, 0x14, 0x15, 0xaa, 0xe4, 0x58, 0xf7,
	0x92, 0x8e, 0x23, 0x9a, 0xd7, 0xf3, 0xd3, 0xb8, 0x0e, 0x7e, 0x2f, 0xcd, 0x95, 0xc0, 0xde, 0xc1,
	0xb3, 0x27, 0xea, 0x50, 0x7c, 0x06, 0x57, 0x42, 0x4b, 0xe7, 0xe1, 0x8a, 0xa7, 0x2e, 0x50, 0xf1,
	0xd0, 0xf2, 0x7b, 0x40, 0x45, 0x9f, 0x42, 0x68, 0x81, 0x5d, 0x61, 0x75, 0xf2, 0xa0, 0xca, 0x45,
	0xd4, 0xb1, 0x10, 0x48, 0x61, 0x74, 0x07, 0x55, 0x20, 0x8b, 0x4f, 0xba, 0x8a, 0x8e, 0x1d, 0x8d,
	0x1b, 0x2e, 0x29, 0x4e, 0x20, 0x29, 0xca, 0x90, 0xf3, 0x3e, 0x8b, 0x4f, 0xba, 0x84, 0x88, 0xf6,
	0xc8, 0xbc, 0xe9, 0xcd, 0xeb, 0xb4, 0xd8, 0xce, 0xf9, 0x58, 0x20, 0xe8, 0x29, 0x5c, 0x5c, 0xd1,
	0x9f, 0xd2, 0x99, 0x08, 0xe9, 0x87, 0x02, 0xbc, 0x15, 0xdb, 0x6a, 0x49, 0x4e, 0x64, 0x1f, 0x43,
	0x86, 0x56, 0x3e, 0x75, 0xc1, 0xca, 0x53, 0x2e, 0xe9, 0xbb, 0x29, 0x3e, 0xc6, 0x65, 0xdc, 0xb6,
	0x88, 0x62, 0x13, 0x5f, 0x42, 0x7b, 0x06, 0xf3, 0xc7, 0x96, 0x8b, 0x6d, 0xbf, 0xd9, 0x53, 0x17,
	0x6e, 0xf6, 0x39, 0x2a, 0xc0, 0x6b, 0xf1, 0x17, 0xb0, 0x60, 0x5a, 0xa6, 0x12, 0x15, 0x7a, 0xf1,
	0xbe, 0x54, 0x34, 0x2d, 0xf3, 0x45, 0x48, 0xae, 0x6f, 0x67, 0x06, 0x34, 0x91, 0xa4, 0x9d, 0xf9,
	0x9e, 0x00, 0x8b, 0xbe, 0xa7, 0x93, 0xb0, 0xbb, 0xfb, 0x0d, 0x48, 0x9b, 0xd6, 0xeb, 0x8b, 0x2c,
	0x51, 0x92, 0xfc, 0x64, 0xd6, 0x8b, 0x96, 0x28, 0xc9, 0xfa, 0xfe, 0xab, 0x14, 0xe4, 0x9e, 0x54,
	0x92, 0xac, 0xe5, 0xc7, 0x7c, 0xf9, 0x9b, 0xb5, 0x77, 0x5c, 0x6f, 0xf7, 0xdf, 0x57, 0x7a, 0x52,
	0xd9, 0xc2, 0x7d, 0xaf, 0xb7, 0x13, 0x2e, 0xb4, 0x0e, 0xb9, 0xe8, 0x42, 0xe9, 0x84, 0x9a, 0x0a,
	0xb8, 0x96, 0x31, 0x4c, 0x53, 0xb9, 0x5e, 0xa8, 0x85, 0x10, 0x13, 0x6a, 0x41, 0x5e, 0xe3, 0x7b,
	0x8a, 0xa9, 0x8b, 0xbc, 0x26, 0xe4, 0x22, 0x4e, 0x8b, 0x33, 0xd2, 0x73, 0x00, 0x52, 0x9d, 0x24,
	0x9b, 0xe4, 0x37, 0xd2, 0x50, 0xd8, 0xed, 0x39, 0x87, 0x09, 0xf7, 0xbe, 0x0a, 0x40, 0xb7, 0xe7,
	0x1c, 0x92, 0x11, 0x79, 0x62, 0xf2, 0x3a, 0x9f, 0x13, 0xc5, 0xe1, 0x55, 0x9a, 0xf1, 0x35, 0x4f,
	0x4c, 0x54, 0xe3, 0x42, 0xb0, 0x12, 0x84, 0x82, 0xdc, 0x1c, 0x87, 0x2c, 0x9b, 0x27, 0xe6, 0x36,
	0xf6, 0x21, 0x25, 0x93, 0x84, 0x89, 0xa4, 0x8f, 0x61, 0x96, 0x3c, 0x28, 0xae, 0x75, 0x91, 0x66,
	0x9e, 0x21, 0x3c, 0x4d, 0x0b, 0x7d, 0x04, 0x39, 0xc6, 0x4d, 0x66, 0xbf, 0x19, 0x3a, 0xfb, 0xc5,
	0xd5, 0x85, 0xab, 0x91, 0xce, 0x7b, 0x59, 0xca, 0x4a, 0xe6, 0xba, 0x4b, 0x30, 0x7d, 0x60, 0xd9,
	0x9a, 0xb7, 0x99, 0xcb, 0x1e, 0x58, 0x7b, 0x32, 0x48, 0xb3, 0x99, 0xc9, 0xe6, 0x44, 0x90, 0x7e,
	0x4b, 0x80, 0xa2, 0xdf, 0x10, 0x49, 0x4e, 0x08, 0x95, 0x88, 0x16, 0x2f, 0xde, 0x14, 0x44, 0x81,
	0xd2, 0xbf, 0xa5, 0x1e, 0x91, 0x66, 0x1d, 0xd3, 0x96, 0x49, 0xb2, 0xa7, 0x7c, 0xc4, 0x02, 0x7d,
	0x52, 0x17, 0x6d, 0x5d, 0x1a, 0xf3, 0xf3, 0x00, 0x2e, 0x19, 0x1d, 0x62, 0xcf, 0x0d, 0xb7, 0xdd,
	0xe7, 0xb0, 0xcd, 0xc5, 0xde, 0xae, 0xf1, 0x62, 0x90, 0x56, 0xf1, 0x92, 0xa4, 0xdf, 0xa5, 0xab,
	0xd5, 0x41, 0x4d, 0x92, 0x54, 0x75, 0x1d, 0xe6, 0x6d, 0x26, 0x9a, 0xb8, 0x35, 0x17, 0xd4, 0xf6,
	0x9c, 0xcf, 0x4a, 0x14, 0xfe, 0xdb, 0x29, 0x28, 0x3e, 0xef, 0x61, 0xbb, 0xff, 0x55, 0x52, 0xf7,
	0x6d, 0x28, 0xbe, 0x56, 0x0d, 0x57, 0x39, 0xb0, 0x6c, 0xa5, 0xd7, 0xd5, 0x55, 0xd7, 0x8b, 0x36,
	0x99, 0x27, 0xe4, 0xc7, 0x96, 0xbd, 0x47, 0x89, 0x08, 0x03, 0x3a, 0x32, 0xad, 0xd7, 0xa6, 0x42,
	0xc8, 0x14, 0x28, 0x9f, 0x98, 0x7c, 0x09, 0xb9, 0xfc, 0xcd, 0xff, 0x78, 0xba, 0xfa, 0x68, 0xa2,
	0x18, 0x32, 0x1a, 0x2f, 0xd7, 0xeb, 0x19, 0x7a, 0x69, 0x6f, 0xaf, 0xbe, 0x21, 0x8b, 0x54, 0xe4,
	0x4b, 0x26, 0xb1, 0x79, 0x62, 0x3a, 0xd2, 0xdf, 0x4d, 0x81, 0x18, 0xe8, 0x28, 0xc9, 0x86, 0xac,
	0x42, 0xfe, 0x55, 0x0f, 0xdb, 0xc6, 0x1b, 0x34, 0x23, 0x70, 0x46, 0x62, 0x76, 0xee, 0xc3, 0x82,
	0x7b, 0x62, 0x2a, 0x2c, 0xc2, 0x8f, 0x05, 0x7e, 0x78, 0x01, 0x0b, 0x45, 0x97, 0x94, 0x99, 0xd0,
	0x69, 0xd0, 0x87, 0x83, 0x3e, 0x83, 0xb9, 0x88, 0xb6, 0xd2, 0x5f, 0x4e, 0x5b, 0xf9, 0xd7, 0x21,
	0x45, 0xfd, 0xbe, 0x00, 0x88, 0x2a, 0xaa, 0xce, 0xd6, 0xf8, 0xbf, 0x2a, 0xfd, 0xe9, 0x2e, 0x88,
	0x34, 0x1e, 0x53, 0x31, 0x0e, 0x94, 0x8e, 0xe1, 0x38, 0x86, 0xd9, 0xe2, 0x1d, 0xaa, 0x40, 0xe9,
	0xf5, 0x83, 0x6d, 0x46, 0x95, 0xfe, 0x12, 0x2c, 0x46, 0x2a, 0x90, 0x64, 0x63, 0xdf, 0x80, 0xb9,
	0x03, 0xb6, 0x05, 0x4b, 0x85, 0xf3, 0xe5, 0xc1, 0x3c, 0xa5, 0xb1, 0xf7, 0x49, 0x7f, 0x92, 0x82,
	0x4b, 0x32, 0x76, 0xac, 0xf6, 0x31, 0x4e, 0x5e, 0x85, 0x35, 0xe0, 0x7b, 0x2f, 0xca, 0x1b, 0x69,
	0x32, 0xc7, 0x98, 0xd9, 0x34, 0x17, 0x5d, 0x63, 0x7f, 0x77, 0x7c, 0x8f, 0x1d, 0x5e, 0x55, 0xe7,
	0x2b, 0x75, 0x99, 0xc8, 0x4a, 0x9d, 0x05, 0x45, 0xb6, 0x7b, 0xac, 0x2b, 0x0e, 0x7e, 0x65, 0xf6,
	0x3a, 0x1e, 0x18, 0x2a, 0x8d, 0x2b, 0x64, 0x9d, 0xb1, 0x34, 0xf0, 0xab, 0x9d, 0x5e, 0x87, 0xfa,
	0xce, 0xe5, 0x2b, 0xa4, 0xbc, 0x67, 0xa7, 0xab, 0x85, 0x48, 0x9a, 0x23, 0x17, 0x0c, 0xff, 0x99,
	0x48, 0x97, 0xbe, 0x0d, 0x97, 0x07, 0x94, 0x9d, 0xa4, 0xc7, 0xf3, 0x2f, 0xd2, 0x70, 0x2d, 0x2a,
	0x3e, 0x69, 0x88, 0xf3, 0x55, 0x6f, 0xd0, 0x1a, 0xcc, 0x77, 0x0c, 0xf3, 0xcd, 0x56, 0x2f, 0xe7,
	0x3a, 0x86, 0xe9, 0xd3, 0xe2, 0xba, 0xc6, 0xcc, 0xcf, 0xb5, 0x6b, 0xa8, 0xb0, 0x1c, 0xd7, 0x76,
	0x49, 0xf6, 0x8f, 0xef, 0x0a, 0x30, 0x97, 0xf4, 0xb2, 0xdc, 0x9b, 0x45, 0xc1, 0x49, 0x4d, 0x98,
	0xff, 0x39, 0xac, 0xe3, 0xfd, 0xb6, 0x00, 0xa8, 0x69, 0xf7, 0x4c, 0x02, 0x6a, 0x9f, 0x5a, 0xad,
	0x24, 0xab, 0x79, 0x09, 0xa6, 0x0d, 0x53, 0xc7, 0x27, 0xb4, 0x9a, 0x19, 0x99, 0x3d, 0x44, 0xb6,
	0x12, 0xd3, 0x13, 0x6d, 0x25, 0x4a, 0x9f, 0xc1, 0x62, 0xa4, 0x88, 0x49, 0xd6, 0xff, 0x8f, 0x53,
	0xb0, 0xc8, 0x2b, 0x92, 0xf8, 0x0a, 0xe6, 0xd7, 0x61, 0xba, 0x4d, 0x64, 0x8e, 0x69, 0x67, 0xfa,
	0x4e, 0xaf, 0x9d, 0x69, 0x66, 0xf4, 0x4b, 0x00, 0x5d, 0x1b, 0x1f, 0x2b, 0x8c, 0x35, 0x3d, 0x11,
	0x6b, 0x8e, 0x70, 0x50, 0x02, 0xfa, 0xbe, 0x00, 0x45, 0x32, 0xa0, 0xbb, 0xb6, 0xd5, 0xb5, 0x1c,
	0xe2, 0xb3, 0x38, 0x93, 0xc1, 0x9c, 0xe7, 0x67, 0xa7, 0xab, 0xf3, 0xdb, 0x86, 0xb9, 0xcb, 0x19,
	0x9b, 0x8d, 0x89, 0x03, 0xfc, 0xbd, 0x63, 0x0e, 0xa5, 0x4a, 0xdb, 0xd2, 0x8e, 0x82, 0xcd, 0x31,
	0x62, 0x59, 0x7c, 0x71, 0x8e, 0xf4, 0x13, 0x01, 0x2e, 0xfd, 0xdc, 0x96, 0x8b, 0xff, 0x2c, 0x94,
	0x2d, 0xbd, 0x00, 0x91, 0xfe, 0xa8, 0x9b, 0x07, 0x56, 0x92, 0x0b, 0xf7, 0xff, 0x47, 0x80, 0x85,
	0x90, 0xe0, 0x24, 0x1d, 0x9c, 0x37, 0xd5, 0xd3, 0x3c, 0x0b, 0x87, 0x71, 0x27, 0x53, 0x95, 0x3c,
	0xc7, 0xb3, 0xb3, 0x4e, 0x59, 0x82, 0x39, 0x4c, 0xac, 0x18, 0x5d, 0xe2, 0xdd, 0x67, 0x87, 0x4c,
	0x06, 0x56, 0xf4, 0xf3, 0x7e, 0x86, 0x72, 0x5f, 0xfa, 0x15, 0xe2, 0x61, 0x85, 0x07, 0x65, 0x92,
	0x43, 0xfe, 0x9f, 0xa6, 0xe0, 0x4a, 0x85, 0x6d, 0x81, 0x7b, 0x31, 0x21, 0x49, 0x76, 0xc4, 0x25,
	0x98, 0x3d, 0xc6, 0xb6, 0x63, 0x58, 0x6c, 0xb6, 0x9f, 0x97, 0xbd, 0x47, 0xb4, 0x0c, 0x59, 0xc7,
	0x54, 0xbb, 0xce, 0xa1, 0xe5, 0x6d, 0x27, 0xfa, 0xcf, 0x7e, 0xfc, 0xca, 0xf4, 0x9b, 0xc7, 0xaf,
	0xcc, 0x8c, 0x8f, 0x5f, 0x99, 0xfd, 0x12, 0xf1, 0x2b, 0x7c, 0xef, 0xee, 0xdf, 0x09, 0x70, 0x75,
	0x48, 0x73, 0x49, 0x76, 0xce, 0xef, 0x40, 0x5e, 0xe3, 0x82, 0xc9, 0xfc, 0xc0, 0x36, 0x26, 0xeb,
	0x24, 0xdb, 0x1b, 0x42, 0x9f, 0xb3, 0xd3, 0x55, 0xf0, 0x8a, 0x5a, 0xdf, 0xe0, 0xca, 0x21, 0xbf,
	0x75, 0xe9, 0xbf, 0x03, 0x14, 0xab, 0x27, 0x6c, 0x51, 0xbe, 0xc1, 0xbc, 0x12, 0xf4, 0x18, 0xb2,
	0x5d, 0xdb, 0x3a, 0x36, 0xbc, 0x6a, 0x14, 0x22, 0xc1, 0x0b, 0x5e, 0x35, 0x06, 0xb8, 0x76, 0x39,
	0x87, 0xec, 0xf3, 0xa2, 0x26, 0xe4, 0x9e, 0x5a, 0x9a, 0xda, 0x7e, 0x6c, 0xb4, 0xbd, 0x81, 0xf6,
	0xfe, 0xf9, 0x82, 0x4a, 0x3e, 0xcf, 0xae, 0xea, 0x1e, 0x7a, 0x8d, 0xe0, 0x13, 0x51, 0x1d, 0xb2,
	0x35, 0xd7, 0xed, 0x92, 0x44, 0x3e, 0xfe, 0xee, 0x4c, 0x20, 0x94, 0xb0, 0x78, 0x11, 0xb7, 0x1e,
	0x3b, 0x6a, 0xc2, 0xc2, 0x13, 0x7a, 0x7e, 0xac, 0xd2, 0xb6, 0x7a, 0x7a, 0xc5, 0x32, 0x0f, 0x8c,
	0x16, 0x9f, 0x26, 0x6e, 0x4f, 0x20, 0xf3, 0x49, 0xa5, 0x21, 0x0f, 0x0b, 0x40, 0xeb, 0x90, 0x6d,
	0x3c, 0xe2, 0xc2, 0x98, 0x1b, 0x79, 0x6b, 0x02, 0x61, 0x8d, 0x47, 0xb2, 0xcf, 0x86, 0x36, 0x21,
	0xbf, 0xfe, 0x79, 0xcf, 0xc6, 0x5c, 0xca, 0xcc, 0xc8, 0xc8, 0x89, 0x41, 0x29, 0x94, 0x4b, 0x0e,
	0x33, 0xa3, 0x6f, 0x43, 0x91, 0xe8, 0xad, 0xa9, 0xee, 0xb7, 0x3d, 0x79, 0x59, 0x2a, 0xef, 0x6b,
	0x13, 0xc8, 0xf3, 0x39, 0xbd, 0x2d, 0x81, 0x01, 0x51, 0xcb, 0x32, 0xcc, 0x47, 0xda, 0x0b, 0x21,
	0xc8, 0x74, 0x49, 0xd3, 0x08, 0x34, 0x0c, 0x89, 0xfe, 0x46, 0xef, 0xc1, 0xac, 0x69, 0xe9, 0xd8,
	0xeb, 0xcc, 0xf3, 0xe5, 0x4b, 0x67, 0xa7, 0xab, 0x33, 0x3b, 0x96, 0xce, 0x7c, 0x1d, 0xfe, 0x4b,
	0x9e, 0x21, 0x99, 0xea, 0xfa, 0xf2, 0x75, 0xc8, 0x90, 0x26, 0x22, 0x36, 0x64, 0x5f, 0x75, 0xf0,
	0x9e, 0x6d, 0x70, 0x69, 0xde, 0xe3, 0xf2, 0x3f, 0x48, 0x41, 0xaa, 0xf1, 0x88, 0x78, 0xf3, 0xfb,
	0x3d, 0xed, 0x08, 0xbb, 0x3c, 0x9d, 0x3f, 0x51, 0x2f, 0xdf, 0xc6, 0x07, 0x06, 0x73, 0xba, 0x72,
	0x32, 0x7f, 0x42, 0xef, 0x00, 0xa8, 0x9a, 0x86, 0x1d, 0x47, 0xf1, 0x8e, 0x00, 0xe6, 0xe4, 0x1c,
	0xa3, 0x6c, 0xe1, 0x3e, 0x61, 0x73, 0xb0, 0x66, 0x63, 0xd7, 0x8b, 0xa1, 0x62, 0x4f, 0x84, 0xcd,
	0xc5, 0x9d, 0xae, 0xe2, 0x5a, 0x47, 0xd8, 0xa4, 0x4d, 0x9a, 0x23, 0x56, 0xa1, 0xd3, 0x6d, 0x12,
	0x02, 0x31, 0x68, 0xd8, 0xd4, 0x03, 0xeb, 0x93, 0x93, 0xfd, 0x67, 0x22, 0xd2, 0xc6, 0x2d, 0x83,
	0x1f, 0xa0, 0xcb, 0xc9, 0xfc, 0x89, 0x68, 0x49, 0xed, 0xb9, 0x87, 0xb4, 0x25, 0x72, 0x32, 0xfd,
	0x8d, 0x6e, 0x43, 0x91, 0x85, 0x5d, 0x2a, 0xd8, 0xd4, 0x14, 0x6a, 0x07, 0x73, 0x34, 0x79, 0x9e,
	0x91, 0xab, 0xa6, 0x46, 0xac, 0x1e, 0x7a, 0x04, 0x9c, 0xa0, 0x1c, 0x75, 0x1c, 0xa2, 0x53, 0x20,
	0xb9, 0xca, 0xc5, 0xb3, 0xd3, 0xd5, 0x7c, 0x83, 0x26, 0x6c, 0x6d, 0x37, 0xc8, 0x5c, 0xc2, 0x72,
	0x6d, 0x75, 0x9c, 0xba, 0xbe, 0xfc, 0x37, 0x05, 0x48, 0x3f, 0xa9, 0x34, 0x2e, 0xac, 0x32, 0xaf,
	0xa0, 0xe9, 0x50, 0x41, 0xef, 0x40, 0x71, 0xdf, 0x68, 0xb7, 0x0d, 0xb3, 0x45, 0xfc, 0xab, 0xef,
	0x60, 0xcd, 0x53, 0x58, 0x81, 0x93, 0x77, 0x19, 0x15, 0x5d, 0x87, 0xbc, 0x66, 0x63, 0x1d, 0x9b,
	0xae, 0xa1, 0xb6, 0x1d, 0xae, 0xb9, 0x30, 0x69, 0xf9, 0x2f, 0x0b, 0x30, 0x4d, 0x3b, 0x2b, 0x7a,
	0x1b, 0x72, 0x9a, 0x65, 0xba, 0xaa, 0x61, 0x72, 0xab, 0x93, 0x93, 0x03, 0xc2, 0xc8, 0xe2, 0xdd,
	0x80, 0x39, 0x55, 0xd3, 0xac, 0x9e, 0xe9, 0x2a, 0xa6, 0xda, 0xc1, 0xbc, 0x98, 0x79, 0x4e, 0xdb,
	0x51, 0x3b, 0x18, 0xad, 0x82, 0xf7, 0xe8, 0x9f, 0xec, 0xcc, 0xc9, 0xc0, 0x49, 0x5b, 0xb8, 0xbf,
	0x8c, 0x21, 0xe7, 0xf7, 0x6a, 0x52, 0xdf, 0x9e, 0xe3, 0x97, 0x80, 0xfe, 0x46, 0xef, 0xc3, 0xa5,
	0x57, 0x3d, 0xb5, 0x6d, 0x1c, 0xd0, 0xc5, 0x2f, 0x1a, 0xa5, 0x4e, 0x5f, 0xc6, 0x8a, 0x82, 0xfc,
	0x34, 0x2a, 0x81, 0xbe, 0xd3, 0x1b, 0x04, 0xe9, 0x60, 0x10, 0xb0, 0x90, 0x1d, 0xa9, 0x0f, 0x0b,
	0x32, 0x76, 0xed, 0x7e, 0x93, 0x1d, 0x76, 0xad, 0x1e, 0x63, 0xd3, 0x25, 0x75, 0xb7, 0xba, 0x98,
	0x05, 0x89, 0x78, 0x75, 0xf7, 0x09, 0xe8, 0x16, 0x14, 0x54, 0x97, 0x74, 0x37, 0x57, 0x31, 0x7b,
	0x9d, 0x7d, 0x6c, 0xb3, 0x50, 0x00, 0x79, 0x9e, 0x53, 0x77, 0x28, 0x91, 0x9f, 0xc8, 0xb0, 0xfb,
	0x0a, 0x5d, 0x27, 0xe2, 0xaf, 0x06, 0x4a, 0xaa, 0x12, 0x8a, 0x74, 0x0f, 0x2e, 0x93, 0x7a, 0x56,
	0x4d, 0xcd, 0xee, 0x77, 0x89, 0xe4, 0x67, 0xf4, 0xaf, 0x83, 0xc4, 0xd0, 0x3e, 0x0d, 0xdd, 0x9e,
	0x91, 0x7e, 0x3c, 0x03, 0xf3, 0xd5, 0x93, 0xae, 0x65, 0x27, 0xba, 0xaa, 0x53, 0x86, 0x59, 0x0e,
	0x7c, 0xc7, 0x6c, 0xc5, 0x0e, 0x58, 0x20, 0x6f, 0x1f, 0x9a, 0x33, 0xa2, 0x32, 0x00, 0x0b, 0xa8,
	0xa4, 0x71, 0x38, 0xe9, 0x0b, 0xec, 0x1c, 0x51, 0x36, 0x7a, 0xd8, 0x60, 0x07, 0xf2, 0x9d, 0x63,
	0x4d, 0x53, 0x0e, 0x8c, 0xb6, 0xcb, 0xe3, 0xd2, 0xe2, 0x43, 0xa8, 0xb7, 0x5f, 0x54, 0x2a, 0x8f,
	0x69, 0x26, 0x16, 0xcf, 0x15, 0x3c, 0xcb, 0x40, 0x24, 0xb0, 0xdf, 0xe8, 0x6b, 0xc0, 0x0f, 0xbe,
	0x28, 0x8e, 0x77, 0x8c, 0xad, 0x3c, 0x7f, 0x76, 0xba, 0x9a, 0x93, 0x29, 0xb5, 0xd1, 0x68, 0xca,
	0x39, 0x96, 0xa1, 0xe1, 0xb8, 0x17, 0x39, 0xea, 0x30, 0x3b, 0xf9, 0x51, 0x87, 0xbf, 0x26, 0xc0,
	0x15, 0xae, 0x23, 0x65, 0x9f, 0x86, 0x77, 0xab, 0x6d, 0xc3, 0xed, 0x2b, 0x47, 0xc7, 0x4b, 0x59,
	0xea, 0xf2, 0xfc, 0x62, 0xac, 0xae, 0x43, 0x4d, 0x5c, 0xf2, 0x34, 0xde, 0x7f, 0xca, 0x99, 0xb7,
	0x8e, 0xab, 0xa6, 0x6b, 0xf7, 0xcb, 0x57, 0xcf, 0x4e, 0x57, 0x17, 0x87, 0x53, 0x5f, 0xc8, 0x8b,
	0xce, 0x30, 0x0b, 0xaa, 0x01, 0x60, 0xbf, 0x8b, 0x51, 0x0b, 0x16, 0x3f, 0x75, 0xc5, 0xf6, 0x45,
	0x39, 0xc4, 0x8b, 0xee, 0x82, 0xc8, 0x8f, 0x96, 0x1c, 0x18, 0x6d, 0xac, 0x38, 0xc6, 0xe7, 0x98,
	0xda, 0xba, 0xb4, 0x5c, 0x60, 0x74, 0x22, 0xa2, 0x61, 0x7c, 0x8e, 0xd1, 0x03, 0xb8, 0x1c, 0xb4,
	0x80, 0xb2, 0x8f, 0xdb, 0xd6, 0x6b, 0x96, 0x3d, 0x4f, 0xb3, 0x23, 0x5f, 0xfb, 0x65, 0x92, 0x44,
	0x58, 0x96, 0xbf, 0x03, 0x4b, 0xa3, 0x2a, 0x1c, 0x1e, 0x10, 0x39, 0xb6, 0x5f, 0xf9, 0x41, 0x74,
	0xb1, 0x62, 0x82, 0x8e, 0xcb, 0x17, 0x2c, 0x3e, 0x4c, 0x7d, 0x20, 0x48, 0x7f, 0x3f, 0x05, 0xf3,
	0xe5, 0x5e, 0xfb, 0xe8, 0x59, 0xb7, 0xc1, 0x8e, 0xe5, 0xa3, 0xb7, 0x20, 0xa7, 0xab, 0xae, 0xca,
	0x0a, 0x29, 0xb0, 0x23, 0x66, 0x84, 0x40, 0x6b, 0x73, 0x07, 0x8a, 0xa1, 0x58, 0x10, 0x1e, 0xf1,
	0x4e, 0xab, 0x1d, 0x90, 0x69, 0x50, 0xfa, 0x07, 0xb0, 0x14, 0xca, 0x48, 0x57, 0x16, 0x14, 0x6c,
	0xba, 0xb6, 0x81, 0xd9, 0xea, 0x58, 0x5a, 0x0e, 0x05, 0xac, 0xd4, 0x49, 0x72, 0x95, 0xa5, 0xa2,
	0x26, 0xcc, 0x91, 0x8c, 0x7d, 0x85, 0x5a, 0x41, 0x6f, 0xf5, 0xf2, 0x41, 0x4c, 0xb5, 0x22, 0xe5,
	0x2e, 0x51, 0xfd, 0x54, 0x28, 0x0f, 0xfd, 0x29, 0xe7, 0x71, 0x40, 0x59, 0xfe, 0x04, 0xc4, 0xc1,
	0x0c, 0x61, 0x5d, 0x66, 0x98, 0x2e, 0x2f, 0x85, 0x75, 0x99, 0x0e, 0xe9, 0x69, 0x33, 0x93, 0xcd,
	0x88, 0xd3, 0xd2, 0x4f, 0xd2, 0x50, 0xf0, 0x7a, 0x66, 0x92, 0x6e, 0x75, 0x19, 0xa6, 0x49, 0x3f,
	0xf2, 0xc2, 0x2b, 0x6e, 0x8f, 0x19, 0x10, 0x3c, 0xc6, 0x9a, 0xf4, 0x2f, 0x0f, 0x01, 0x52, 0xd6,
	0x24, 0xcc, 0xcf, 0xf2, 0xff, 0x10, 0x20, 0x43, 0x3d, 0xd9, 0x07, 0x90, 0xa1, 0xe7, 0xf2, 0x85,
	0xb1, 0xe7, 0xf2, 0xbd, 0xed, 0x79, 0x92, 0xd5, 0x9f, 0x58, 0x52, 0x21, 0xef, 0xaa, 0x4c, 0xe3,
	0x7b, 0x2c, 0xdb, 0xc5, 0x3a, 0xf7, 0x14, 0xaf, 0x9f, 0xd7, 0x8e, 0x9e, 0x27, 0xec, 0xf1, 0xa1,
	0x6b, 0x90, 0x26, 0xb6, 0x6b, 0x96, 0x6d, 0xd5, 0x9f, 0x9d, 0xae, 0xa6, 0x89, 0xd5, 0x22, 0x34,
	0xb4, 0x06, 0xf9, 0xa8, 0x35, 0x21, 0xce, 0x06, 0x35, 0x87, 0x21, 0x4b, 0x00, 0x6d, 0x7f, 0x08,
	0x31, 0x94, 0xc4, 0xda, 0x92, 0x6f, 0xd2, 0xff, 0xba, 0xc0, 0x63, 0x12, 0x1b, 0x1a, 0x99, 0xb3,
	0xec, 0x24, 0x27, 0x95, 0x7b, 0x20, 0xda, 0xaa, 0xa9, 0x5b, 0x1d, 0xe3, 0x73, 0xcc, 0x50, 0xb9,
	0xc3, 0xb7, 0x2b, 0x8a, 0x3e, 0x9d, 0xc2, 0x67, 0x47, 0xfa, 0x6f, 0x02, 0x8f, 0x5f, 0xf4, 0x8b,
	0x91, 0xec, 0xa6, 0x72, 0x9e, 0x2f, 0xe9, 0x99, 0x07, 0x96, 0x17, 0x7e, 0xf1, 0xf6, 0xa8, 0x60,
	0xa3, 0xba, 0x79, 0x60, 0x79, 0xdb, 0x63, 0xb6, 0x47, 0x70, 0x96, 0x7f, 0x19, 0xa6, 0x69, 0xf2,
	0x1b, 0xf4, 0x0d, 0x3f, 0x66, 0x36, 0x25, 0xa6, 0xa5, 0x3f, 0x4a, 0xc1, 0xbb, 0xb4, 0xaa, 0x2f,
	0xb0, 0x6d, 0x1c, 0xf4, 0x77, 0x6d, 0xcb, 0xc5, 0x9a, 0x8b, 0xf5, 0x60, 0x55, 0x2a, 0xc1, 0x26,
	0xd0, 0x21, 0xc7, 0xf7, 0xf3, 0x0c, 0x9d, 0xdf, 0x9c, 0xf1, 0xe4, 0xcb, 0xa1, 0xd5, 0x2c, 0xdb,
	0x07, 0xac, 0x6f, 0xc8, 0x59, 0x26, 0xb9, 0xae, 0xa3, 0x75, 0xc8, 0x75, 0xbd, 0x6a, 0x5c, 0x28,
	0x64, 0xc4, 0xe7, 0x42, 0x5b, 0x50, 0xe4, 0x05, 0x55, 0xdb, 0xc6, 0x31, 0x56, 0x54, 0xf7, 0x22,
	0x43, 0x78, 0x9e, 0xf1, 0xae, 0x13, 0xd6, 0x75, 0x57, 0xfa, 0x1b, 0x19, 0xb8, 0x75, 0x8e, 0x8a,
	0x93, 0xec, 0x5e, 0xcb, 0x90, 0x3d, 0x26, 0x2f, 0x32, 0x78, 0xed, 0xb3, 0xb2, 0xff, 0x8c, 0xf6,
	0x23, 0xf3, 0xc0, 0x81, 0x6a, 0xb4, 0xc9, 0xbc, 0xc1, 0x82, 0xf4, 0x46, 0x87, 0x01, 0xc5, 0x07,
	0xbd, 0x85, 0x66, 0x8c, 0xc7, 0x54, 0x10, 0xcd, 0xe6, 0xa0, 0xef, 0x0a, 0xb0, 0xcc, 0x5e, 0xc8,
	0x22, 0xc5, 0x06, 0x5e, 0x93, 0xa1, 0xaf, 0xd9, 0x88, 0x79, 0xcd, 0x44, 0x3a, 0x2a, 0x85, 0xde,
	0xc5, 0x0b, 0xb2, 0x14, 0x7e, 0x5b, 0xb8, 0x28, 0xcb, 0xbf, 0x29, 0x40, 0x3e, 0x44, 0x40, 0xb7,
	0x87, 0xce, 0xe5, 0xe4, 0xcf, 0xe2, 0x0e, 0xe3, 0xdc, 0x1a, 0x3a, 0x8c, 0x53, 0xce, 0x7e, 0x71,
	0xba, 0x9a, 0x91, 0x59, 0xbc, 0xb7, 0x77, 0x2c, 0xe7, 0x46, 0x70, 0x0d, 0x4c, 0x7a, 0x20, 0x93,
	0x77, 0x0f, 0x0c, 0x85, 0x75, 0xaa, 0xb7, 0x8d, 0x44, 0x61, 0x1d, 0x79, 0x92, 0x7e, 0x90, 0x82,
	0x85, 0x75, 0x5d, 0x6f, 0x34, 0x28, 0x14, 0x48, 0x72, 0x8c, 0x21, 0xc8, 0x10, 0xff, 0x80, 0x9f,
	0x21, 0xa2, 0xbf, 0xd1, 0x7b, 0x80, 0x74, 0xc3, 0x61, 0xd7, 0x29, 0x38, 0x87, 0xaa, 0x6e, 0xbd,
	0x0e, 0x76, 0x8b, 0x17, 0xbc, 0x94, 0x86, 0x97, 0x80, 0x1a, 0x40, 0x9d, 0x56, 0xc5, 0x71, 0x55,
	0x7f, 0x35, 0xfc, 0xd6, 0x44, 0xa7, 0x52, 0x98, 0x37, 0xeb, 0x3f, 0xca, 0x39, 0x22, 0x87, 0xfe,
	0x24, 0x3e, 0x9a, 0x41, 0x1a, 0xc5, 0x55, 0x54, 0xc7, 0x3b, 0x4f, 0xc1, 0x2e, 0x72, 0x28, 0x30,
	0xfa, 0xba, 0xc3, 0x8e, 0x49, 0xb0, 0x30, 0xec, 0x40, 0x35, 0x49, 0xae, 0x65, 0xfe, 0x1d, 0x01,
	0x0a, 0x32, 0x3e, 0xb0, 0xb1, 0x73, 0x98, 0xa4, 0xce, 0x1f, 0xc3, 0x9c, 0xcd, 0xa4, 0x2a, 0x07,
	0xb6, 0xd5, 0xb9, 0x88, 0xad, 0xc8, 0x73, 0xc6, 0xc7, 0xb6, 0xd5, 0xe1, 0x26, 0xf9, 0x05, 0x14,
	0xfd, 0x32, 0x26, 0x59, 0xf9, 0xbf, 0x47, 0x4f, 0x5c, 0x32, 0xc1, 0x49, 0x6f, 0xdb, 0x26, 0xab,
	0x01, 0xba, 0x9e, 0x1d, 0x2e, 0x68, 0x92, 0x6a, 0xf8, 0xaf, 0x02, 0x14, 0x1a, 0xbd, 0x7d, 0x76,
	0x4d, 0x50, 0x72, 0x1a, 0xa8, 0x42, 0xae, 0x8d, 0x0f, 0x5c, 0xe5, 0x8d, 0x02, 0x88, 0xb3, 0x84,
	0x95, 0x86, 0x4f, 0x3f, 0x01, 0xb0, 0xe9, 0x91, 0x23, 0x2a, 0x27, 0x7d, 0x41, 0x39, 0x39, 0xca,
	0x4b, 0xc8, 0x64, 0xd6, 0x29, 0xfa, 0xd5, 0x4c, 0x72, 0x7e, 0x79, 0x19, 0xb1, 0x0e, 0xe9, 0x8b,
	0x58, 0x87, 0x05, 0xbe, 0x53, 0x1d, 0x6f, 0x21, 0x4a, 0xb0, 0x48, 0xdd, 0x32, 0x45, 0xed, 0x76,
	0xdb, 0x86, 0x87, 0x53, 0xa8, 0xfd, 0xc9, 0xc8, 0x0b, 0x34, 0x69, 0x9d, 0xa5, 0x50, 0x84, 0x82,
	0x7e, 0x43, 0x80, 0xb9, 0x03, 0x1b, 0xe3, 0xcf, 0xb1, 0x42, 0x4d, 0xf2, 0x64, 0x5b, 0xf1, 0x1b,
	0xa4, 0x0c, 0x5f, 0x7a, 0xab, 0x2e, 0xcf, 0x5e, 0xdc, 0x20, 0xef, 0x45, 0x3b, 0x20, 0x6a, 0x6d,
	0xb6, 0x79, 0xe8, 0x87, 0x05, 0xcc, 0x4c, 0x3e, 0x00, 0x8a, 0x8c, 0x39, 0x88, 0x0c, 0x78, 0x4e,
	0x06, 0x93, 0xaa, 0x2b, 0xfc, 0x6a, 0x36, 0xea, 0x6c, 0x47, 0xc3, 0x02, 0xc2, 0x47, 0xaf, 0x43,
	0x37, 0xba, 0x95, 0x64, 0xac, 0xea, 0xdc, 0x73, 0x27, 0xe3, 0xca, 0x7f, 0xe0, 0xe3, 0xea, 0x25,
	0x2c, 0xd0, 0x7e, 0x93, 0xf4, 0x09, 0x4a, 0xe9, 0x1f, 0xa5, 0x01, 0x85, 0x25, 0xff, 0xfc, 0xfa,
	0x5b, 0x2a, 0xb9, 0xfe, 0xb6, 0x09, 0x52, 0xc8, 0x19, 0x6a, 0xab, 0x8e, 0xab, 0xb0, 0xf8, 0x33,
	0x47, 0xe9, 0x62, 0x5b, 0x71, 0xb0, 0x66, 0xf1, 0x4b, 0x74, 0x04, 0x79, 0x25, 0xc8, 0xf9, 0x54,
	0x75, 0xdc, 0xe7, 0x2c, 0xdf, 0x2e, 0xb6, 0x1b, 0x34, 0x17, 0x7a, 0x04, 0x57, 0x3a, 0xea, 0x49,
	0x1c, 0xff, 0x34, 0xe5, 0x5f, 0xec, 0xa8, 0x27, 0x43, 0x4c, 0x1f, 0xc2, 0x72, 0x3c, 0x93, 0xe2,
	0x60, 0x6f, 0x7f, 0xea, 0x4a, 0x0c, 0x63, 0x03, 0xbb, 0x68, 0x1d, 0x20, 0x00, 0x11, 0x7c, 0x8e,
	0x9e, 0x04, 0x43, 0xe4, 0x7c, 0x0c, 0x21, 0x7d, 0x4f, 0x80, 0xc2, 0xb6, 0xd1, 0xb2, 0xd5, 0x44,
	0xaf, 0xa8, 0x41, 0x1f, 0x46, 0x37, 0xf4, 0xf2, 0x0f, 0x97, 0xe3, 0x02, 0x36, 0x58, 0x0e, 0x6f,
	0xd1, 0x8e, 0x33, 0x90, 0xa9, 0xcf, 0x2f, 0x51, 0x92, 0x36, 0xff, 0x3f, 0x5c, 0x83, 0x39, 0x5e,
	0xee, 0x3d, 0xd3, 0xb0, 0x4c, 0xf4, 0x00, 0xd2, 0x2d, 0xbe, 0xb4, 0x9d, 0x8f, 0x5d, 0xd1, 0x0b,
	0x2e, 0x80, 0xab, 0x4d, 0xc9, 0x24, 0x2f, 0x61, 0xe9, 0xf6, 0xdc, 0x18, 0x40, 0x11, 0xc4, 0x30,
	0x87, 0x59, 0xba, 0x3d, 0x17, 0x35, 0xa0, 0xa8, 0x05, 0xb7, 0x4e, 0x29, 0x84, 0x3d, 0x3d, 0x72,
	0x99, 0x2b, 0xf6, 0xfe, 0xaf, 0xda, 0x94, 0x5c, 0xd0, 0x22, 0x09, 0xa8, 0x12, 0xbe, 0xec, 0x28,
	0x33, 0x14, 0x20, 0x15, 0x1c, 0x95, 0x8d, 0x5e, 0xb4, 0x54, 0x9b, 0x0a, 0xdd, 0x89, 0x84, 0x3e,
	0x84, 0x19, 0x9d, 0x5e, 0xab, 0xc3, 0x8d, 0x66, 0x5c, 0x43, 0x47, 0x6e, 0x2f, 0xaa, 0x4d, 0xc9,
	0x9c, 0x03, 0x6d, 0xc2, 0x1c, 0xfb, 0xc5, 0x5c, 0x7a, 0x6e, 0xea, 0x6e, 0x8d, 0x96, 0x10, 0x72,
	0x36, 0x6a, 0x53, 0x72, 0x5e, 0x0f, 0xa8, 0xe8, 0x09, 0xe4, 0xb5, 0x36, 0x56, 0x6d, 0x2e, 0xea,
	0xf6, 0xc8, 0x53, 0x5d, 0x43, 0x57, 0xf1, 0xd4, 0xa6, 0x64, 0xd0, 0x7c, 0x22, 0x29, 0x94, 0x4d,
	0x6f, 0x64, 0xe1, 0x92, 0xde, 0x1f, 0x59, 0xa8, 0xe1, 0xeb, 0x6d, 0x6a, 0xd4, 0x09, 0xf1, 0xa9,
	0xe8, 0xeb, 0x90, 0x71, 0x34, 0xd5, 0xe4, 0x76, 0x77, 0x65, 0xc4, 0x95, 0x19, 0x01, 0x33, 0xcd,
	0x8d, 0x3e, 0x62, 0x68, 0xc0, 0x3d, 0xf1, 0xd6, 0x32, 0xe3, 0x74, 0x1a, 0x39, 0x9a, 0x4d, 0x74,
	0x8a, 0x29, 0x81, 0xe8, 0x41, 0x25, 0xf0, 0x47, 0xa1, 0xe7, 0x25, 0xe9, 0xe2, 0x65, 0xbc, 0x1e,
	0x86, 0xce, 0xb7, 0xd6, 0xe8, 0xf9, 0x6f, 0x8f, 0x88, 0xb6, 0x61, 0x9e, 0x09, 0xea, 0xb1, 0xa3,
	0x97, 0x4b, 0x6b, 0x23, 0x77, 0x29, 0x63, 0x0e, 0x7f, 0xd6, 0xa6, 0xe4, 0x39, 0x35, 0x44, 0x0e,
	0xca, 0xd5, 0xc1, 0x76, 0x8b, 0xad, 0x92, 0x8e, 0x29, 0x57, 0x38, 0xf4, 0xcb, 0x2f, 0x17, 0x25,
	0xa2, 0x5f, 0x83, 0x4b, 0x4c, 0x90, 0xcb, 0x23, 0x5a, 0x78, 0x60, 0xc4, 0x3b, 0x23, 0x77, 0x18,
	0x47, 0x1e, 0x97, 0xac, 0x4d, 0xc9, 0x48, 0x1d, 0x4a, 0x44, 0x1a, 0x5c, 0x66, 0x6f, 0xe0, 0xe7,
	0xed, 0x6c, 0x7e, 0x44, 0x6c, 0xe9, 0x26, 0x7d, 0xc5, 0x7b, 0xa3, 0x5e, 0x11, 0x7b, 0x0c, 0xb0,
	0x36, 0x25, 0x2f, 0xaa, 0xc3, 0xa9, 0x41, 0x35, 0x6c, 0x7e, 0xb2, 0x89, 0x77, 0xb7, 0xf7, 0xc6,
	0x57, 0x23, 0xee, 0x44, 0x98, 0x5f, 0x8d, 0x48, 0x22, 0x69, 0x40, 0xff, 0x5c, 0x37, 0xed, 0x4c,
	0x73, 0x23, 0x1b, 0x30, 0xe6, 0xf8, 0x13, 0x69, 0xc0, 0xc3, 0x10, 0x19, 0x95, 0x20, 0xd5, 0xd2,
	0x96, 0xe6, 0x47, 0xce, 0x0f, 0xfe, 0x11, 0x9f, 0xda, 0x94, 0x9c, 0x6a, 0x69, 0xe8, 0x13, 0xc8,
	0xb2, 0xf3, 0x1a, 0x27, 0xe6, 0x52, 0x61, 0xa4, 0xc1, 0x8d, 0x9e, 0x7a, 0xa9, 0x4d, 0xc9, 0xf4,
	0x88, 0x08, 0xef, 0xc8, 0x3c, 0x16, 0x9f, 0x8a, 0x28, 0x8d, 0x39, 0xa6, 0x39, 0x70, 0x22, 0x82,
	0x74, 0x18, 0xdb, 0x27, 0xa2, 0x5d, 0x28, 0xd8, 0x2c, 0x5a, 0xd1, 0x8b, 0x2d, 0x16, 0x47, 0xee,
	0xe1, 0xc7, 0x85, 0x17, 0xd7, 0xe8, 0x3a, 0x4c, 0x88, 0x4e, 0xda, 0x2e, 0x2a, 0x91, 0xb7, 0xdd,
	0xc2, 0xc8, 0xb6, 0x1b, 0x19, 0xea, 0x4a, 0xda, 0xce, 0x1e, 0x4a, 0x44, 0xdf, 0x84, 0x69, 0x36,
	0x4e, 0x10, 0x15, 0x19, 0x17, 0x96, 0x32, 0x30, 0x44, 0x58, 0x7e, 0x62, 0xbd, 0x5c, 0x1e, 0xb2,
	0xa7, 0xb4, 0xad, 0xd6, 0xd2, 0xe2, 0x48, 0xeb, 0x35, 0x1c, 0x7c, 0x48, 0xac, 0x97, 0x1b, 0x50,
	0x49, 0x07, 0xb2, 0x59, 0x0a, 0x1f, 0x62, 0x97, 0x46, 0x76, 0xa0, 0x98, 0x48, 0xbe, 0x1a, 0x3d,
	0x4c, 0x11, 0x90, 0x7d, 0xc3, 0xea, 0x60, 0x85, 0x1a, 0xc5, 0xcb, 0xe3, 0x0d, 0x6b, 0xe4, 0x1e,
	0x23, 0xdf, 0xb0, 0x32, 0x2a, 0x7a, 0x01, 0x22, 0xbf, 0x4c, 0x43, 0xf1, 0x22, 0x4b, 0x96, 0xae,
	0x50, 0x79, 0xf7, 0x62, 0x27, 0xc4, 0xb8, 0xa0, 0xa3, 0x1a, 0x71, 0x98, 0xa3, 0x29, 0xe8, 0x53,
	0x58, 0xa0, 0xf2, 0x14, 0x2d, 0xb8, 0xff, 0x64, 0x69, 0x69, 0xe8, 0x36, 0x8d, 0xd1, 0x57, 0xa5,
	0x78, 0x92, 0x45, 0x6d, 0x20, 0x89, 0x8c, 0x07, 0xc3, 0x34, 0x5c, 0x3a, 0x77, 0x2f, 0x8f, 0x1c,
	0x0f, 0xd1, 0xbb, 0x1f, 0xc9, 0x78, 0x30, 0x18, 0x85, 0x74, 0xe3, 0x01, 0x8b, 0xf7, 0xf6, 0xc8,
	0x6e, 0x3c, 0xc2, 0xd8, 0xcd, 0xbb, 0x11, 0x3b, 0xb7, 0x01, 0xc0, 0x60, 0x12, 0xf5, 0xfc, 0x56,
	0x46, 0x3a, 0x00, 0x83, 0x91, 0x76, 0xc4, 0x01, 0x68, 0x7b, 0x34, 0xe2, 0x00, 0xb0, 0x35, 0xfd,
	0xa5, 0xeb, 0xa3, 0x27, 0xab, 0xf0, 0xae, 0x1f, 0x9d, 0xac, 0x28, 0x01, 0xad, 0x43, 0x8e, 0xf8,
	0xac, 0x7d, 0x3a, 0xc2, 0x6f, 0x8c, 0x84, 0xa8, 0x03, 0x47, 0x70, 0x6a, 0x53, 0x72, 0xf6, 0x15,
	0x27, 0x91, 0x5e, 0xc5, 0x44, 0xf0, 0xb1, 0x7d, 0x7f, 0x64, 0xaf, 0x1a, 0x3e, 0x7b, 0x41, 0x7a,
	0xd5, 0xab, 0x80, 0x1a, 0x4c, 0x79, 0x0e, 0x5b, 0xad, 0x5f, 0x7a, 0x77, 0xfc, 0x94, 0x17, 0xdd,
	0x5b, 0xf0, 0xa7, 0x3c, 0x4e, 0x66, 0x53, 0x9e, 0xae, 0x38, 0x0e, 0xdd, 0xc0, 0x5f, 0xba, 0x35,
	0x66, 0xca, 0x1b, 0x58, 0xbf, 0x63, 0x53, 0x9e, 0xde, 0x60, 0x9c, 0xc4, 0xfb, 0xb3, 0xbd, 0xcb,
	0x63, 0x38, 0x7a, 0xb9, 0x33, 0xd2, 0xfb, 0x8b, 0xbd, 0xdd, 0x86, 0x78, 0x7f, 0x76, 0x24, 0x01,
	0xfd, 0x12, 0xcc, 0xf2, 0xf5, 0x92, 0xa5, 0xbb, 0x63, 0xfc, 0xe1, 0xf0, 0x12, 0x17, 0xe9, 0x8e,
	0x9c, 0x87, 0x19, 0x07, 0xb6, 0x4e, 0xc3, 0x8c, 0xdf, 0xbd, 0x31, 0xc6, 0x61, 0x68, 0xa9, 0x88,
	0x19, 0x87, 0x80, 0x4c, 0x4a, 0xe3, 0xb0, 0x35, 0x86, 0xa5, 0x5f, 0x18, 0x59, 0x9a, 0xe8, 0x62,
	0x0b, 0x29, 0x0d, 0xe7, 0xa1, 0x93, 0x05, 0x9d, 0xab, 0x99, 0x76, 0xbe, 0x36, 0x7a, 0xb2, 0x18,
	0x44, 0xad, 0x35, 0x6f, 0x37, 0x84, 0x69, 0xe5, 0xaf, 0x08, 0x70, 0x9d, 0xf5, 0x01, 0xba, 0x16,
	0xdc, 0x57, 0xfc, 0xa5, 0xfc, 0x10, 0x24, 0x7f, 0x40, 0xc5, 0x7f, 0xf3, 0xe2, 0x2b, 0xcf, 0xde,
	0x1b, 0xdf, 0x51, 0xc7, 0xe5, 0x23, 0xca, 0xe8, 0x30, 0xf0, 0xb2, 0xf4, 0x70, 0xa4, 0x32, 0xa2,
	0x80, 0x8b, 0x28, 0x83, 0xf3, 0x94, 0x67, 0xf9, 0x6e, 0xa7, 0x7f, 0xb2, 0xb1, 0x28, 0x8a, 0x9b,
	0x99, 0xec, 0x55, 0x71, 0x69, 0x33, 0x93, 0xbd, 0x26, 0x2e, 0x6f, 0x66, 0xb2, 0x6f, 0x89, 0x6f,
	0x6f, 0x66, 0xb2, 0xab, 0xe2, 0xf5, 0xcd, 0x4c, 0x56, 0x12, 0x6f, 0x4a, 0xbf, 0x77, 0x0d, 0xe6,
	0x3d, 0xec, 0xc3, 0x70, 0xcd, 0xc3, 0x30, 0xae, 0x59, 0x19, 0x85, 0x6b, 0x38, 0x5a, 0xe2, 0xc0,
	0xe6, 0x61, 0x18, 0xd8, 0xac, 0x8c, 0x02, 0x36, 0x01, 0x0f, 0x41, 0x36, 0xcd, 0x51, 0xc8, 0xe6,
	0xde, 0x04, 0xc8, 0xc6, 0x17, 0x35, 0x08, 0x6d, 0x36, 0x86, 0xa1, 0xcd, 0xbb, 0xe3, 0xa1, 0x8d,
	0x2f, 0x2a, 0x84, 0x6d, 0x3e, 0x1a, 0xc0, 0x36, 0x37, 0xc6, 0x60, 0x1b, 0x9f, 0xdf, 0x03, 0x37,
	0x5b, 0xb1, 0xe0, 0xe6, 0xf6, 0x79, 0xe0, 0xc6, 0x97, 0x13, 0x41, 0x37, 0xb5, 0x38, 0x74, 0x73,
	0xeb, 0x1c, 0x74, 0xe3, 0x8b, 0x0a, 0xc3, 0x9b, 0xad, 0x58, 0x78, 0x73, 0xfb, 0x3c, 0x78, 0x13,
	0x14, 0x2b, 0x8c, 0x6f, 0xbe, 0x11, 0xc1, 0x37, 0xab, 0x23, 0xf1, 0x8d, 0xcf, 0xcd, 0x00, 0xce,
	0xc7, 0x83, 0x00, 0xe7, 0xc6, 0x18, 0x80, 0x13, 0x28, 0x96, 0x23, 0x9c, 0x5a, 0x1c, 0xc2, 0xb9,
	0x75, 0x0e, 0xc2, 0x09, 0x74, 0x11, 0x82, 0x38, 0x3b, 0xf1, 0x10, 0xe7, 0xce, 0xb9, 0x10, 0xc7,
	0x97, 0x16, 0xc5, 0x38, 0xb5, 0x38, 0x8c, 0x73, 0xeb, 0x1c, 0x8c, 0x33, 0x50, 0x32, 0x06, 0x72,
	0xd4, 0xb1, 0x20, 0xe7, 0xbd, 0x09, 0x41, 0x8e, 0x2f, 0x3a, 0x0e, 0xe5, 0xe8, 0xe3, 0x51, 0x4e,
	0x69, 0x52, 0x94, 0xe3, 0xbf, 0x24, 0x16, 0xe6, 0xa8, 0x63, 0x61, 0xce, 0x7b, 0x13, 0xc2, 0x9c,
	0x81, 0x8a, 0x44, 0x71, 0xce, 0x4e, 0x3c, 0xce, 0xb9, 0x73, 0x2e, 0xce, 0x09, 0x5a, 0x31, 0x02,
	0x74, 0xd6, 0x42, 0x40, 0xe7, 0x9d, 0x11, 0x40, 0xc7, 0x67, 0x25, 0x48, 0xe7, 0x5b, 0x43, 0x48,
	0x47, 0x1a, 0x87, 0x74, 0x7c, 0x5e, 0x1f, 0xea, 0xd4, 0xe2, 0xa0, 0xce, 0xad, 0x73, 0xa0, 0x4e,
	0xd0, 0x6f, 0x42, 0x58, 0xe7, 0xf9, 0x08, 0xac, 0x73, 0xf7, 0x7c, 0xac, 0xe3, 0xcb, 0x1b, 0x00,
	0x3b, 0xea, 0x58, 0xb0, 0xf3, 0xde, 0x84, 0x60, 0x27, 0x68, 0xc1, 0x18, 0xb4, 0xf3, 0x41, 0x14,
	0xed, 0x5c, 0x1f, 0x8d, 0x76, 0x7c, 0x31, 0x1c, 0xee, 0x6c, 0xc5, 0xc2, 0x9d, 0xdb, 0xe7, 0xc1,
	0x9d, 0xc0, 0x9a, 0x85, 0xf1, 0xce, 0x4e, 0x3c, 0xde, 0xb9, 0x73, 0x2e, 0xde, 0x09, 0x3a, 0x52,
	0x04, 0xf0, 0x6c, 0xc5, 0x02, 0x9e, 0xdb, 0xe7, 0x01, 0x9e, 0x01, 0x53, 0xcb, 0x11, 0xcf, 0xcb,
	0x91, 0x88, 0xe7, 0xfe, 0x24, 0x88, 0xc7, 0x17, 0x3a, 0x04, 0x79, 0x3e, 0x1b, 0x0d, 0x79, 0x7e,
	0xe1, 0x02, 0xb7, 0x43, 0xc6, 0x62, 0x9e, 0x6f, 0x0d, 0x61, 0x1e, 0x69, 0x1c, 0xe6, 0x09, 0x46,
	0x86, 0x07, 0x7a, 0xaa, 0x31, 0x10, 0xe5, 0xdd, 0xf1, 0x10, 0x25, 0x98, 0xc8, 0x03, 0x8c, 0xf2,
	0xd1, 0x00, 0x46, 0xb9, 0x71, 0x6e, 0x20, 0x56, 0x08, 0xa4, 0x94, 0x87, 0x41, 0xca, 0xcd, 0xb1,
	0x20, 0xc5, 0x97, 0x10, 0xa0, 0x94, 0xad, 0x58, 0x94, 0x72, 0xfb, 0x3c, 0x94, 0x12, 0x74, 0x85,
	0x30, 0x4c, 0xd9, 0x89, 0x87, 0x29, 0x77, 0xce, 0x85, 0x29, 0x03, 0xd3, 0x96, 0x87, 0x53, 0x6a,
	0x71, 0x38, 0xe5, 0xd6, 0x39, 0x38, 0x25, 0x3c, 0x6d, 0xf9, 0x40, 0xa5, 0x39, 0x0a, 0xa8, 0xdc,
	0x9b, 0x00, 0xa8, 0x04, 0xce, 0xdc, 0x00, 0x52, 0xf9, 0x64, 0x10, 0xa9, 0x48, 0xe3, 0x90, 0x4a,
	0xd0, 0x89, 0x3c, 0xa8, 0xb2, 0x13, 0x0f, 0x55, 0xee, 0x9c, 0x0b, 0x55, 0xc2, 0xe3, 0x3a, 0x84,
	0x55, 0x3e, 0x19, 0xc4, 0x2a, 0xd2, 0x38, 0xac, 0x12, 0x94, 0xc7, 0x03, 0x2b, 0xb5, 0x38, 0xb0,
	0x72, 0xeb, 0x1c, 0xb0, 0x12, 0x32, 0xf7, 0x01, 0x5a, 0xf9, 0xab, 0x93, 0xa3, 0x95, 0x0f, 0xde,
	0x34, 0x4e, 0xe6, 0x7c, 0xb8, 0xf2, 0xc9, 0x20, 0x5c, 0x91, 0xc6, 0xc1, 0x95, 0x40, 0x1f, 0x17,
	0xc6, 0x2b, 0x6f, 0x8b, 0xef, 0x44, 0x50, 0xcb, 0x9f, 0xcc, 0xc0, 0x0c, 0xff, 0x52, 0x51, 0xe4,
	0x76, 0x1f, 0xe1, 0x4d, 0x6e, 0xf7, 0x41, 0x1b, 0xa4, 0x9b, 0x51, 0xb7, 0xe5, 0xfc, 0x3b, 0xe1,
	0x86, 0x6f, 0x2d, 0xe3, 0xac, 0x6f, 0x70, 0xcc, 0x16, 0x7d, 0x03, 0xe6, 0x7b, 0x0e, 0xb6, 0x95,
	0xae, 0x6d, 0x58, 0xb6, 0xe1, 0xb2, 0x03, 0x03, 0x42, 0x59, 0xfc, 0xe2, 0x74, 0x75, 0x6e, 0xcf,
	0xc1, 0xf6, 0x2e, 0xa7, 0xcb, 0x73, 0xbd, 0xd0, 0x93, 0xf7, 0x71, 0xa6, 0xe9, 0xc9, 0x3f, 0xce,
	0xf4, 0x1c, 0x44, 0xba, 0x1d, 0x1c, 0xb6, 0xf4, 0xec, 0x26, 0x9d, 0xf8, 0x49, 0x49, 0xd5, 0x43,
	0xc6, 0x9c, 0xde, 0xa8, 0x53, 0xb4, 0xa3, 0x44, 0xd4, 0x00, 0x7a, 0xc7, 0x85, 0xd2, 0xb5, 0xda,
	0x86, 0xd6, 0xa7, 0x13, 0x78, 0xf4, 0x56, 0xe1, 0xb1, 0x77, 0x7b, 0xbf, 0x54, 0x0d, 0x77, 0x97,
	0x72, 0xca, 0xf0, 0xda, 0xff, 0x8d, 0x1e, 0xc0, 0xe5, 0x8e, 0x7a, 0x42, 0xaf, 0x5b, 0x55, 0xbc,
	0x19, 0x99, 0x5e, 0x30, 0xc5, 0x3e, 0xd3, 0x84, 0x3a, 0xea, 0x09, 0xfd, 0x7c, 0x14, 0x4b, 0xa2,
	0xdf, 0x7e, 0xb8, 0x01, 0x73, 0x3c, 0x70, 0x9b, 0x7d, 0x1a, 0xa6, 0x48, 0x73, 0xf2, 0xef, 0x04,
	0xb0, 0xaf, 0xc3, 0xdc, 0x82, 0x82, 0x6e, 0x38, 0xae, 0x61, 0x6a, 0x2e, 0xbf, 0xc9, 0x95, 0xdd,
	0x85, 0x3a, 0xef, 0x51, 0xd9, 0x75, 0xad, 0x4d, 0x58, 0xd0, 0xda, 0x86, 0xef, 0xe7, 0xb0, 0x99,
	0x67, 0x61, 0x64, 0xbf, 0xae, 0xd0, 0xbc, 0x83, 0x9b, 0xa3, 0x45, 0x2d, 0x4a, 0x46, 0x15, 0x28,
	0xb6, 0x54, 0x17, 0xbf, 0x56, 0xfb, 0x8a, 0x77, 0x2e, 0x29, 0x4f, 0xcf, 0x62, 0xbe, 0x75, 0x76,
	0xba, 0x3a, 0xff, 0x84, 0x25, 0x0d, 0x1d, 0x4f, 0x9a, 0x6f, 0x85, 0x12, 0x74, 0x74, 0x07, 0x8a,
	0xaa, 0xd3, 0x37, 0x35, 0xda, 0x80, 0xd8, 0x74, 0x7a, 0x0e, 0x75, 0x53, 0xb3, 0x72, 0x81, 0x92,
	0x2b, 0x1e, 0x15, 0x7d, 0x04, 0xcb, 0xfc, 0xc2, 0xf6, 0xd7, 0xaa, 0xad, 0x2b, 0xb4, 0xd1, 0x83,
	0xe1, 0x21, 0x52, 0x9e, 0xab, 0xec, 0x82, 0x76, 0x92, 0x81, 0xb4, 0x74, 0xf8, 0x22, 0x54, 0x76,
	0xd1, 0x2b, 0x88, 0xf9, 0xcd, 0x4c, 0x76, 0x4e, 0x9c, 0xdf, 0xcc, 0x64, 0x0b, 0x62, 0x51, 0xfa,
	0x37, 0x02, 0x14, 0x89, 0xc5, 0x70, 0x1c, 0xc3, 0x32, 0x6b, 0x7e, 0x88, 0xa0, 0xdf, 0x6b, 0x05,
	0x7a, 0x44, 0xc4, 0x7f, 0x46, 0xab, 0xf4, 0x28, 0x0e, 0xf1, 0xcc, 0xfc, 0xcf, 0x34, 0xa4, 0x65,
	0x60, 0x24, 0x7a, 0x28, 0x62, 0x1d, 0x66, 0x1c, 0xab, 0x67, 0x6b, 0xde, 0xe5, 0xe1, 0xf7, 0x46,
	0x98, 0xa8, 0xd0, 0x0b, 0x4b, 0x0d, 0xca, 0x20, 0x73, 0x46, 0xa9, 0x04, 0x33, 0x8c, 0x82, 0x72,
	0x30, 0xfd, 0xac, 0x59, 0xab, 0xca, 0xe2, 0x14, 0x9a, 0x83, 0xec, 0x63, 0xf9, 0xd9, 0xb6, 0xd2,
	0x78, 0xfe, 0x54, 0x14, 0x50, 0x1e, 0x66, 0xe5, 0x67, 0xcf, 0x9a, 0xca, 0xd6, 0x0b, 0x31, 0x25,
	0xfd, 0xb1, 0x00, 0x73, 0x65, 0x76, 0x7b, 0x3a, 0xdb, 0xa7, 0xfe, 0x68, 0x60, 0x53, 0xf8, 0x5a,
	0x3c, 0x6a, 0x88, 0xdf, 0xa0, 0x5e, 0x87, 0x2c, 0xef, 0x9e, 0x5e, 0x84, 0xf7, 0xea, 0x68, 0x5f,
	0x91, 0x2e, 0xab, 0x78, 0x51, 0x3a, 0x1e, 0x1b, 0x6a, 0x80, 0xa8, 0x7a, 0x55, 0x54, 0x78, 0x49,
	0x46, 0xc7, 0xea, 0x0c, 0x68, 0xc3, 0xeb, 0x6c, 0x6a, 0x94, 0xfc, 0x61, 0xe6, 0xfb, 0x3f, 0x5c,
	0x9d, 0x92, 0xfe, 0x34, 0x03, 0xf3, 0xe5, 0xf0, 0x4d, 0xf1, 0xa8, 0x3e, 0x50, 0xd9, 0xb8, 0x19,
	0x30, 0xc2, 0x51, 0x1a, 0xf3, 0x0d, 0x8e, 0x5c, 0x70, 0x2d, 0x3d, 0xab, 0xfb, 0xf5, 0x31, 0xfb,
	0xe9, 0xe1, 0xca, 0x07, 0x8c, 0xcb, 0xff, 0x3e, 0xed, 0x1b, 0xf0, 0x12, 0x4c, 0xb3, 0x53, 0x44,
	0xc2, 0xd0, 0x01, 0x67, 0x6a, 0x42, 0x88, 0x87, 0x46, 0xd2, 0x65, 0x96, 0x8d, 0x18, 0xfc, 0xe6,
	0x1b, 0x5d, 0xe7, 0x16, 0xcc, 0x5b, 0x17, 0xff, 0xba, 0x5d, 0x8f, 0x5d, 0xe7, 0xf7, 0xff, 0x31,
	0x3c, 0x88, 0xbc, 0x0f, 0xfd, 0x2a, 0x14, 0x35, 0xab, 0xdd, 0x66, 0x13, 0x3b, 0x33, 0x5d, 0xc3,
	0x17, 0x7c, 0xd0, 0x22, 0xf0, 0x0f, 0x1a, 0x96, 0xfc, 0x0f, 0x1b, 0x96, 0x64, 0xfe, 0x61, 0xc3,
	0x50, 0xec, 0x76, 0xc1, 0x17, 0xc6, 0x2c, 0xde, 0x40, 0x18, 0xf9, 0xec, 0x9b, 0x84, 0x91, 0xb3,
	0xe0, 0x7b, 0xde, 0xf3, 0xfe, 0x40, 0xe0, 0x41, 0x3c, 0x4f, 0x2d, 0xeb, 0xa8, 0xe7, 0x07, 0x7e,
	0x2f, 0x87, 0x2f, 0xe7, 0x0b, 0x22, 0x5c, 0xe9, 0x09, 0x8d, 0xb8, 0xa9, 0x29, 0xf5, 0xe5, 0xa6,
	0xa6, 0x1b, 0x30, 0xd7, 0xb5, 0xf1, 0x01, 0x76, 0xb5, 0x43, 0xc5, 0xec, 0x75, 0xf8, 0xf1, 0x94,
	0xbc, 0x47, 0xdb, 0xe9, 0x75, 0xd0, 0x3d, 0x10, 0xfd, 0x2c, 0x1c, 0x6c, 0x79, 0x37, 0x43, 0x79,
	0x74, 0x0e, 0xcd, 0xa4, 0xff, 0x25, 0xc0, 0x62, 0xa4, 0x4e, 0x7c, 0x4c, 0x6d, 0x42, 0x5e, 0xf7,
	0x9d, 0x01, 0x67, 0x49, 0xb8, 0x60, 0xec, 0x73, 0x98, 0x19, 0x29, 0x70, 0xc5, 0x7b, 0x2d, 0xbd,
	0xca, 0x3d, 0x10, 0x9b, 0xba, 0xa0, 0xd8, 0xcb, 0x81, 0x9c, 0x8d, 0xd0, 0x0b, 0xfc, 0x41, 0x96,
	0x9e, 0x68, 0x90, 0x49, 0xff, 0x5b, 0x00, 0x91, 0xbe, 0xe0, 0x31, 0xc6, 0x7a, 0x22, 0x26, 0xd3,
	0x3b, 0x64, 0x90, 0x9a, 0xfc, 0x00, 0x4a, 0xe4, 0xf3, 0x13, 0xe9, 0x81, 0xcf, 0x4f, 0xc4, 0xd9,
	0xcf, 0xcc, 0x97, 0xb4, 0x9f, 0xd2, 0x0f, 0x05, 0x28, 0xf8, 0xd5, 0x66, 0xdf, 0x9d, 0x1b, 0x73,
	0xb1, 0xe4, 0x9b, 0x7d, 0x5b, 0xcd, 0xbb, 0x00, 0x63, 0xa2, 0x4f, 0xe1, 0x85, 0x2f, 0xc0, 0x60,
	0xdf, 0x04, 0xfb, 0x5b, 0x5e, 0x77, 0x24, 0x45, 0xac, 0x04, 0x37, 0x0f, 0xbc, 0xc1, 0x01, 0x1f,
	0x99, 0x7e, 0xb2, 0xd3, 0x6a, 0x1f, 0xb3, 0x3b, 0x4b, 0x26, 0xb2, 0xa5, 0x88, 0xc7, 0xc3, 0x01,
	0x5f, 0xeb, 0xd1, 0x9b, 0x0d, 0xfa, 0x31, 0x4f, 0xf6, 0xdb, 0x91, 0x1e, 0x87, 0x14, 0x48, 0x7b,
	0x14, 0xd1, 0xd2, 0x44, 0xf6, 0xdd, 0xd3, 0x12, 0xeb, 0x80, 0x3f, 0x0e, 0xb7, 0x04, 0x3b, 0xb9,
	0xfa, 0x08, 0xd2, 0xc7, 0x6a, 0x7b, 0x5c, 0x0c, 0x57, 0xa4, 0xe5, 0x64, 0x92, 0x1b, 0x3d, 0x8e,
	0x5c, 0xd8, 0x90, 0x1a, 0xbd, 0x10, 0x33, 0xac, 0xd2, 0xc8, 0xc5, 0x0e, 0xdf, 0x8c, 0x0e, 0xa0,
	0xb1, 0xaf, 0x0f, 0x8f, 0xa4, 0x0f, 0x33, 0x3f, 0xfa, 0xe1, 0xaa, 0x20, 0x7d, 0x0c, 0x48, 0xc6,
	0x0e, 0x76, 0x9f, 0xf7, 0x2c, 0x3b, 0xb8, 0xfc, 0x62, 0xf0, 0x30, 0xc1, 0x74, 0xfc, 0x61, 0x02,
	0xe9, 0x32, 0x2c, 0x46, 0xb8, 0x99, 0x05, 0x92, 0xbe, 0x09, 0xd7, 0x9e, 0x58, 0x8e, 0x63, 0x74,
	0x09, 0xe4, 0xa4, 0x43, 0x9d, 0xcc, 0x57, 0xbe, 0xcd, 0xcd, 0x76, 0x29, 0xca, 0x37, 0x99, 0x6d,
	0xca, 0xc9, 0xfe, 0xb3, 0xf4, 0xaf, 0x05, 0xb8, 0x3a, 0xcc, 0xc9, 0xb4, 0x1c, 0x77, 0x1e, 0x71,
	0x56, 0xb3, 0x82, 0xbb, 0xd9, 0xce, 0xef, 0xad, 0x5e, 0x76, 0xe2, 0xb6, 0xf2, 0x77, 0x2a, 0x1d,
	0x95, 0xda, 0x24, 0x7e, 0x54, 0xb8, 0xc0, 0xc9, 0xdb, 0x8c, 0x1a, 0x98, 0xa7, 0xcc, 0x64, 0xe6,
	0xa9, 0x09, 0xc5, 0x4d, 0xcb, 0x30, 0x89, 0x77, 0xec, 0xd5, 0x77, 0x1d, 0x0a, 0xfb, 0x86, 0xa9,
	0xda, 0x7d, 0xc5, 0x0b, 0x1d, 0x14, 0xce, 0x0b, 0x1d, 0x94, 0xe7, 0x19, 0x07, 0x7f, 0x94, 0x7e,
	0x2a, 0x80, 0x18, 0x88, 0xe5, 0x66, 0xfe, 0x6b, 0x00, 0x5a, 0xbb, 0xe7, 0xb8, 0xd8, 0xf6, 0x5a,
	0x69, 0x8e, 0x1d, 0x51, 0xa8, 0x30, 0x6a, 0x7d, 0x43, 0xce, 0xf1, 0x0c, 0x75, 0x1d, 0xdd, 0x8c,
	0xde, 0x3e, 0x30, 0x5d, 0x86, 0xb3, 0xa1, 0x3b, 0x07, 0x48, 0xb3, 0x3b, 0xae, 0x65, 0xfb, 0x48,
	0x91, 0x37, 0xbb, 0x77, 0x2f, 0x0b, 0x3d, 0x7f, 0x8c, 0xe9, 0x29, 0xa4, 0x02, 0xf1, 0x41, 0x8e,
	0xb1, 0x5f, 0xa5, 0xcc, 0xf9, 0x55, 0x62, 0x1c, 0x5e, 0x95, 0xfe, 0xb9, 0x00, 0xc5, 0x0a, 0x6b,
	0x0d, 0xbf, 0x85, 0xc7, 0x58, 0xb4, 0x0d, 0xc8, 0xba, 0x27, 0xa6, 0xd2, 0xc1, 0xfe, 0xa7, 0x44,
	0x2e, 0x70, 0x71, 0xda, 0xac, 0xcb, 0x1e, 0xe9, 0xd7, 0xe9, 0xf8, 0xa7, 0x91, 0xf9, 0x70, 0xb9,
	0x56, 0x62, 0xdf, 0x4e, 0x2e, 0x79, 0xdf, 0x4e, 0x2e, 0x6d, 0xf0, 0x0c, 0x6c, 0xa6, 0xf8, 0xfe,
	0x7f, 0x5e, 0x15, 0x64, 0x9f, 0x89, 0x39, 0x13, 0xf7, 0x1b, 0xa4, 0xd7, 0x0f, 0x4d, 0xf7, 0xa8,
	0x00, 0x10, 0xfa, 0x46, 0x0c, 0xff, 0x1a, 0xef, 0xfa, 0x86, 0xb2, 0xb7, 0x53, 0x79, 0xb6, 0xbd,
	0x5d, 0x6f, 0x36, 0xab, 0x1b, 0xa2, 0x80, 0x44, 0x98, 0x8b, 0x7c, 0x61, 0x26, 0xc5, 0xbe, 0xcf,
	0x7b, 0xff, 0x2f, 0x00, 0x04, 0x1f, 0xab, 0x22, 0xb2, 0xb6, 0xaa, 0x9f, 0x2a, 0x2f, 0xd6, 0x9f,
	0xee, 0x55, 0x1b, 0xe2, 0x14, 0x42, 0x50, 0x28, 0xaf, 0x37, 0x2b, 0x35, 0x45, 0xae, 0x36, 0x76,
	0x9f, 0xed, 0x34, 0xaa, 0xde, 0x77, 0x7d, 0xef, 0x6f, 0xc0, 0x5c, 0xf8, 0x3a, 0x18, 0xb4, 0x08,
	0xc5, 0x4a, 0xad, 0x5a, 0xd9, 0x52, 0x5e, 0xd4, 0xd7, 0x95, 0xe7, 0x7b, 0xd5, 0xbd, 0xaa, 0x38,
	0x45, 0x8b, 0x46, 0x89, 0x8f, 0xf7, 0x9e, 0x12, 0x04, 0x52, 0x84, 0x3c, 0x7b, 0xa6, 0x5f, 0xa3,
	0x11, 0x53, 0xf7, 0xb7, 0x21, 0x1f, 0xba, 0xa6, 0x96, 0xbc, 0x6e, 0x77, 0xaf, 0x51, 0x53, 0x9a,
	0xf5, 0xed, 0x6a, 0xa3, 0xb9, 0xbe, 0xbd, 0xcb, 0x64, 0x50, 0xda, 0x7a, 0xf9, 0x99, 0xdc, 0x14,
	0x05, 0xff, 0xb9, 0xf9, 0x6c, 0xaf, 0x52, 0xf3, 0xaa, 0x21, 0x65, 0xb2, 0x69, 0x31, 0x7d, 0xff,
	0x04, 0xae, 0x8e, 0xb8, 0x19, 0x85, 0x80, 0x9f, 0x3d, 0x93, 0x5e, 0xd9, 0x29, 0x4e, 0xa1, 0x79,
	0xc8, 0x91, 0xae, 0x47, 0xcf, 0x4d, 0x8a, 0x02, 0xca, 0x42, 0xe6, 0xd0, 0x75, 0xbb, 0x62, 0x0a,
	0xcd, 0x40, 0xca, 0x79, 0x24, 0xa6, 0xc9, 0xff, 0x96, 0x23, 0x66, 0x08, 0x96, 0x52, 0x3f, 0xef,
	0xd9, 0x58, 0x9c, 0x26, 0x58, 0xaa, 0xe7, 0x60, 0xfb, 0xc0, 0x68, 0x63, 0x71, 0x96, 0xb0, 0x98,
	0xbd, 0x76, 0x5b, 0xcc, 0x4a, 0x99, 0xec, 0x8c, 0x38, 0x73, 0xff, 0x06, 0x84, 0x0e, 0xa8, 0x23,
	0x80, 0x99, 0xa7, 0xaa, 0x8b, 0x1d, 0x57, 0x9c, 0x42, 0xb3, 0x90, 0x5e, 0x6f, 0xb7, 0x45, 0xe1,
	0xe1, 0x3f, 0xcb, 0x40, 0xd6, 0xfb, 0xd8, 0x0a, 0x7a, 0x0a, 0xd3, 0x14, 0x5f, 0xa0, 0xd5, 0xd1,
	0xc8, 0x83, 0x8e, 0xe3, 0xe5, 0xeb, 0xe7, 0x41, 0x13, 0x69, 0x0a, 0xfd, 0x45, 0xc8, 0x87, 0x3c,
	0x32, 0x34, 0x72, 0x05, 0x2d, 0xe2, 0x85, 0x2e, 0xdf, 0x3e, 0x2f, 0x9b, 0x2f, 0xff, 0x25, 0xe4,
	0x7c, 0x63, 0x8e, 0x6e, 0x8e, 0x33, 0xf5, 0x9e, 0xec, 0xf1, 0xf3, 0x01, 0x19, 0x76, 0xd2, 0xd4,
	0xfb, 0x02, 0xb2, 0x01, 0x0d, 0xdb, 0x5d, 0x14, 0x17, 0x37, 0x36, 0xd2, 0xb0, 0x2f, 0xdf, 0x9f,
	0x28, 0x77, 0xf0, 0x4e, 0xa2, 0xac, 0x60, 0xf2, 0x88, 0x57, 0xd6, 0xd0, 0xd4, 0x14, 0xaf, 0xac,
	0x98, 0x39, 0x68, 0x0a, 0x3d, 0x87, 0x0c, 0x31, 0x9a, 0x28, 0xce, 0xed, 0x1a, 0x30, 0xd2, 0xcb,
	0x37, 0xc7, 0xe6, 0xf1, 0x44, 0x96, 0xef, 0xfd, 0xe8, 0xbf, 0xac, 0x4c, 0xfd, 0xe8, 0x6c, 0x45,
	0xf8, 0xe9, 0xd9, 0x8a, 0xf0, 0x87, 0x67, 0x2b, 0xc2, 0x1f, 0x9d, 0xad, 0x08, 0xdf, 0xfb, 0xd9,
	0xca, 0xd4, 0x4f, 0x7f, 0xb6, 0x32, 0xf5, 0x87, 0x3f, 0x5b, 0x99, 0xfa, 0x6c, 0x96, 0x73, 0xef,
	0xcf, 0x50, 0x8b, 0xf2, 0xe8, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x47, 0x4a, 0x72, 0x7d, 0xf4,
	0x7e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InternalClient is the client API for Internal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InternalClient interface {
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error)
	RangeFeed(ctx context.Context, in *RangeFeedRequest, opts ...grpc.CallOption) (Internal_RangeFeedClient, error)
	GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (Internal_GossipSubscriptionClient, error)
	ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error)
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error)
}

type internalClient struct {
	cc *grpc.ClientConn
}

func NewInternalClient(cc *grpc.ClientConn) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/Batch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) RangeLookup(ctx context.Context, in *RangeLookupRequest, opts ...grpc.CallOption) (*RangeLookupResponse, error) {
	out := new(RangeLookupResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/RangeLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) RangeFeed(ctx context.Context, in *RangeFeedRequest, opts ...grpc.CallOption) (Internal_RangeFeedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[0], "/cockroach.roachpb.Internal/RangeFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalRangeFeedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_RangeFeedClient interface {
	Recv() (*RangeFeedEvent, error)
	grpc.ClientStream
}

type internalRangeFeedClient struct {
	grpc.ClientStream
}

func (x *internalRangeFeedClient) Recv() (*RangeFeedEvent, error) {
	m := new(RangeFeedEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) GossipSubscription(ctx context.Context, in *GossipSubscriptionRequest, opts ...grpc.CallOption) (Internal_GossipSubscriptionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Internal_serviceDesc.Streams[1], "/cockroach.roachpb.Internal/GossipSubscription", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalGossipSubscriptionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_GossipSubscriptionClient interface {
	Recv() (*GossipSubscriptionEvent, error)
	grpc.ClientStream
}

type internalGossipSubscriptionClient struct {
	grpc.ClientStream
}

func (x *internalGossipSubscriptionClient) Recv() (*GossipSubscriptionEvent, error) {
	m := new(GossipSubscriptionEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) ResetQuorum(ctx context.Context, in *ResetQuorumRequest, opts ...grpc.CallOption) (*ResetQuorumResponse, error) {
	out := new(ResetQuorumResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/ResetQuorum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) Join(ctx context.Context, in *JoinNodeRequest, opts ...grpc.CallOption) (*JoinNodeResponse, error) {
	out := new(JoinNodeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.roachpb.Internal/Join", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalServer is the server API for Internal service.
type InternalServer interface {
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
	RangeLookup(context.Context, *RangeLookupRequest) (*RangeLookupResponse, error)
	RangeFeed(*RangeFeedRequest, Internal_RangeFeedServer) error
	GossipSubscription(*GossipSubscriptionRequest, Internal_GossipSubscriptionServer) error
	ResetQuorum(context.Context, *ResetQuorumRequest) (*ResetQuorumResponse, error)
	// Join a bootstrapped cluster. If the target node is itself not part of a
	// bootstrapped cluster, an appropriate error is returned.
	Join(context.Context, *JoinNodeRequest) (*JoinNodeResponse, error)
}

// UnimplementedInternalServer can be embedded to have forward compatible implementations.
type UnimplementedInternalServer struct {
}

func (*UnimplementedInternalServer) Batch(ctx context.Context, req *BatchRequest) (*BatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Batch not implemented")
}
func (*UnimplementedInternalServer) RangeLookup(ctx context.Context, req *RangeLookupRequest) (*RangeLookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RangeLookup not implemented")
}
func (*UnimplementedInternalServer) RangeFeed(req *RangeFeedRequest, srv Internal_RangeFeedServer) error {
	return status.Errorf(codes.Unimplemented, "method RangeFeed not implemented")
}
func (*UnimplementedInternalServer) GossipSubscription(req *GossipSubscriptionRequest, srv Internal_GossipSubscriptionServer) error {
	return status.Errorf(codes.Unimplemented, "method GossipSubscription not implemented")
}
func (*UnimplementedInternalServer) ResetQuorum(ctx context.Context, req *ResetQuorumRequest) (*ResetQuorumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetQuorum not implemented")
}
func (*UnimplementedInternalServer) Join(ctx context.Context, req *JoinNodeRequest) (*JoinNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}

func RegisterInternalServer(s *grpc.Server, srv InternalServer) {
	s.RegisterService(&_Internal_serviceDesc, srv)
}

func _Internal_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/Batch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_RangeLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).RangeLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/RangeLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).RangeLookup(ctx, req.(*RangeLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_RangeFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RangeFeedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).RangeFeed(m, &internalRangeFeedServer{stream})
}

type Internal_RangeFeedServer interface {
	Send(*RangeFeedEvent) error
	grpc.ServerStream
}

type internalRangeFeedServer struct {
	grpc.ServerStream
}

func (x *internalRangeFeedServer) Send(m *RangeFeedEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_GossipSubscription_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GossipSubscriptionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).GossipSubscription(m, &internalGossipSubscriptionServer{stream})
}

type Internal_GossipSubscriptionServer interface {
	Send(*GossipSubscriptionEvent) error
	grpc.ServerStream
}

type internalGossipSubscriptionServer struct {
	grpc.ServerStream
}

func (x *internalGossipSubscriptionServer) Send(m *GossipSubscriptionEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_ResetQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetQuorumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ResetQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/ResetQuorum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ResetQuorum(ctx, req.(*ResetQuorumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.roachpb.Internal/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).Join(ctx, req.(*JoinNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Internal_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.roachpb.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Batch",
			Handler:    _Internal_Batch_Handler,
		},
		{
			MethodName: "RangeLookup",
			Handler:    _Internal_RangeLookup_Handler,
		},
		{
			MethodName: "ResetQuorum",
			Handler:    _Internal_ResetQuorum_Handler,
		},
		{
			MethodName: "Join",
			Handler:    _Internal_Join_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RangeFeed",
			Handler:       _Internal_RangeFeed_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GossipSubscription",
			Handler:       _Internal_GossipSubscription_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "roachpb/api.proto",
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x40
	}
	if m.ResumeReason != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ResumeReason))
		i--
		dAtA[i] = 0x38
	}
	if m.NumKeys != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NumKeys))
		i--
		dAtA[i] = 0x28
	}
	if m.ResumeSpan != nil {
		{
			size, err := m.ResumeSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyLocking != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLocking))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IntentValue != nil {
		{
			size, err := m.IntentValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Blind {
		i--
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConditionalPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionalPutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ExpBytes) > 0 {
		i -= len(m.ExpBytes)
		copy(dAtA[i:], m.ExpBytes)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ExpBytes)))
		i--
		dAtA[i] = 0x32
	}
	if m.AllowIfDoesNotExist {
		i--
		if m.AllowIfDoesNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Blind {
		i--
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DeprecatedExpValue != nil {
		{
			size, err := m.DeprecatedExpValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConditionalPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionalPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionalPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InitPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitPutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitPutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FailOnTombstones {
		i--
		if m.FailOnTombstones {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Blind {
		i--
		if m.Blind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InitPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Increment != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Increment))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewValue != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NewValue))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inline {
		i--
		if m.Inline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReturnKeys {
		i--
		if m.ReturnKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeleteRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Deadline.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RevertRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevertRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevertRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreGcThreshold {
		i--
		if m.IgnoreGcThreshold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EnableTimeBoundIteratorOptimization {
		i--
		if m.EnableTimeBoundIteratorOptimization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.TargetTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RevertRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevertRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevertRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyLocking != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLocking))
		i--
		dAtA[i] = 0x28
	}
	if m.ScanFormat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ScanFormat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchResponses) > 0 {
		for iNdEx := len(m.BatchResponses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BatchResponses[iNdEx])
			copy(dAtA[i:], m.BatchResponses[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BatchResponses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntentRows) > 0 {
		for iNdEx := len(m.IntentRows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntentRows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReverseScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyLocking != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.KeyLocking))
		i--
		dAtA[i] = 0x28
	}
	if m.ScanFormat != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ScanFormat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReverseScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchResponses) > 0 {
		for iNdEx := len(m.BatchResponses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BatchResponses[iNdEx])
			copy(dAtA[i:], m.BatchResponses[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.BatchResponses[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntentRows) > 0 {
		for iNdEx := len(m.IntentRows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntentRows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Terminate) > 0 {
		for iNdEx := len(m.Terminate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Terminate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Checkpoint {
		i--
		if m.Checkpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Mode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x18
	}
	if m.WithDiff {
		i--
		if m.WithDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for iNdEx := len(m.Result) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Result[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CheckConsistencyResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConsistencyResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConsistencyResponse_Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecomputeStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecomputeStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecomputeStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecomputeStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecomputeStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecomputeStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AddedDelta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EndTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InFlightWrites) > 0 {
		for iNdEx := len(m.InFlightWrites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InFlightWrites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.TxnHeartbeating {
		i--
		if m.TxnHeartbeating {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Require1PC {
		i--
		if m.Require1PC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.LockSpans) > 0 {
		for iNdEx := len(m.LockSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.InternalCommitTrigger != nil {
		{
			size, err := m.InternalCommitTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Deadline != nil {
		{
			size, err := m.Deadline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Commit {
		i--
		if m.Commit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EndTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StagingTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.OnePhaseCommit {
		i--
		if m.OnePhaseCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ExpirationTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.SplitKey) > 0 {
		i -= len(m.SplitKey)
		copy(dAtA[i:], m.SplitKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SplitKey)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminUnsplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminUnsplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminUnsplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminUnsplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminUnsplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminUnsplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminMergeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminMergeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminMergeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminMergeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminMergeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminMergeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminTransferLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminTransferLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminTransferLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminTransferLeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminTransferLeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminTransferLeaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReplicationChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicationChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChangeType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminChangeReplicasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminChangeReplicasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminChangeReplicasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalChanges) > 0 {
		for iNdEx := len(m.InternalChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InternalChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.ExpDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.DeprecatedTargets) > 0 {
		for iNdEx := len(m.DeprecatedTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeprecatedTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DeprecatedChangeType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DeprecatedChangeType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminChangeReplicasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminChangeReplicasResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminChangeReplicasResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminRelocateRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRelocateRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRelocateRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonVoterTargets) > 0 {
		for iNdEx := len(m.NonVoterTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NonVoterTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.VoterTargets) > 0 {
		for iNdEx := len(m.VoterTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoterTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminRelocateRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRelocateRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRelocateRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HeartbeatTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HeartbeatTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Threshold.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GCRequest_GCKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest_GCKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCRequest_GCKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PushTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.PushType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PushType))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.PushTo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PusheeTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.PusherTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PushTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PushTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PusheeTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoverTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ImplicitlyCommitted {
		i--
		if m.ImplicitlyCommitted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoverTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RecoveredTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KnownWaitingTxns) > 0 {
		for iNdEx := len(m.KnownWaitingTxns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.KnownWaitingTxns[iNdEx].Size()
				i -= size
				if _, err := m.KnownWaitingTxns[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.WaitForUpdate {
		i--
		if m.WaitForUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxnRecordExists {
		i--
		if m.TxnRecordExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.WaitingTxns) > 0 {
		for iNdEx := len(m.WaitingTxns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.WaitingTxns[iNdEx].Size()
				i -= size
				if _, err := m.WaitingTxns[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.QueriedTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryIntentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIntentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIntentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ErrorIfMissing {
		i--
		if m.ErrorIfMissing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryIntentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIntentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIntentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundIntent {
		i--
		if m.FoundIntent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.IntentTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IgnoredSeqNums) > 0 {
		for iNdEx := len(m.IgnoredSeqNums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IgnoredSeqNums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.MinTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Poison {
		i--
		if m.Poison {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.IntentTxn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResolveIntentRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIntentRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIntentRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MergeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TruncateLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TruncateLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinProposedTS != nil {
		{
			size, err := m.MinProposedTS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.PrevLease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevLease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EvaluatedBy != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EvaluatedBy))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentLease != nil {
		{
			size, err := m.CurrentLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestLeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLeaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComputeChecksumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeChecksumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeChecksumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Terminate) > 0 {
		for iNdEx := len(m.Terminate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Terminate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Checkpoint {
		i--
		if m.Checkpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Mode != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x28
	}
	if m.Snapshot {
		i--
		if m.Snapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComputeChecksumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeChecksumResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeChecksumResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChecksumID.Size()
		i -= size
		if _, err := m.ChecksumID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExternalStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FileTableConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.AzureConfig != nil {
		{
			size, err := m.AzureConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.S3Config != nil {
		{
			size, err := m.S3Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.GoogleCloudConfig != nil {
		{
			size, err := m.GoogleCloudConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.HttpPath.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LocalFile.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Provider != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_LocalFilePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_LocalFilePath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_LocalFilePath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_Http) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseUri) > 0 {
		i -= len(m.BaseUri)
		copy(dAtA[i:], m.BaseUri)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BaseUri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_S3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_S3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_S3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerKMSID) > 0 {
		i -= len(m.ServerKMSID)
		copy(dAtA[i:], m.ServerKMSID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServerKMSID)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ServerEncMode) > 0 {
		i -= len(m.ServerEncMode)
		copy(dAtA[i:], m.ServerEncMode)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ServerEncMode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Auth) > 0 {
		i -= len(m.Auth)
		copy(dAtA[i:], m.Auth)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Auth)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TempToken) > 0 {
		i -= len(m.TempToken)
		copy(dAtA[i:], m.TempToken)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TempToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_GCS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_GCS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_GCS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		i -= len(m.Credentials)
		copy(dAtA[i:], m.Credentials)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Credentials)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BillingProject) > 0 {
		i -= len(m.BillingProject)
		copy(dAtA[i:], m.BillingProject)
		i = encodeVarintApi(dAtA, i, uint64(len(m.BillingProject)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Auth) > 0 {
		i -= len(m.Auth)
		copy(dAtA[i:], m.Auth)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Auth)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountKey) > 0 {
		i -= len(m.AccountKey)
		copy(dAtA[i:], m.AccountKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AccountKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorage_FileTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorage_FileTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorage_FileTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QualifiedTableName) > 0 {
		i -= len(m.QualifiedTableName)
		copy(dAtA[i:], m.QualifiedTableName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.QualifiedTableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintApi(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RetryTracingEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryTracingEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryTracingEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetryError) > 0 {
		i -= len(m.RetryError)
		copy(dAtA[i:], m.RetryError)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RetryError)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AttemptNumber != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.AttemptNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Operation) > 0 {
		i -= len(m.Operation)
		copy(dAtA[i:], m.Operation)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileEncryptionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileEncryptionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileEncryptionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReturnSstBelowSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReturnSstBelowSize))
		i--
		dAtA[i] = 0x58
	}
	if m.TargetFileSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TargetFileSize))
		i--
		dAtA[i] = 0x50
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StorageByLocalityKV) > 0 {
		keysForStorageByLocalityKV := make([]string, 0, len(m.StorageByLocalityKV))
		for k := range m.StorageByLocalityKV {
			keysForStorageByLocalityKV = append(keysForStorageByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForStorageByLocalityKV)
		for iNdEx := len(keysForStorageByLocalityKV) - 1; iNdEx >= 0; iNdEx-- {
			v := m.StorageByLocalityKV[string(keysForStorageByLocalityKV[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForStorageByLocalityKV[iNdEx])
			copy(dAtA[i:], keysForStorageByLocalityKV[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(keysForStorageByLocalityKV[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.EnableTimeBoundIteratorOptimization {
		i--
		if m.EnableTimeBoundIteratorOptimization {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ReturnSST {
		i--
		if m.ReturnSST {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MVCCFilter != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MVCCFilter))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Storage.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BulkOpSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkOpSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkOpSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EntryCounts) > 0 {
		keysForEntryCounts := make([]uint64, 0, len(m.EntryCounts))
		for k := range m.EntryCounts {
			keysForEntryCounts = append(keysForEntryCounts, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForEntryCounts)
		for iNdEx := len(keysForEntryCounts) - 1; iNdEx >= 0; iNdEx-- {
			v := m.EntryCounts[uint64(keysForEntryCounts[iNdEx])]
			baseI := i
			i = encodeVarintApi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintApi(dAtA, i, uint64(keysForEntryCounts[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DeprecatedIndexEntries != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DeprecatedIndexEntries))
		i--
		dAtA[i] = 0x18
	}
	if m.DeprecatedRows != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DeprecatedRows))
		i--
		dAtA[i] = 0x10
	}
	if m.DataSize != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExportResponse_File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportResponse_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportResponse_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalityKV) > 0 {
		i -= len(m.LocalityKV)
		copy(dAtA[i:], m.LocalityKV)
		i = encodeVarintApi(dAtA, i, uint64(len(m.LocalityKV)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SST) > 0 {
		i -= len(m.SST)
		copy(dAtA[i:], m.SST)
		i = encodeVarintApi(dAtA, i, uint64(len(m.SST)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Exported.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RandomizeLeases {
		i--
		if m.RandomizeLeases {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeInfos) > 0 {
		for iNdEx := len(m.RangeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminScatterResponse_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminScatterResponse_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminScatterResponse_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminVerifyProtectedTimestampRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminVerifyProtectedTimestampRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminVerifyProtectedTimestampRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RecordID.Size()
		i -= size
		if _, err := m.RecordID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RecordAliveAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Protected.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminVerifyProtectedTimestampResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminVerifyProtectedTimestampResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminVerifyProtectedTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VerificationFailedRanges) > 0 {
		for iNdEx := len(m.VerificationFailedRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VerificationFailedRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DeprecatedFailedRanges) > 0 {
		for iNdEx := len(m.DeprecatedFailedRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeprecatedFailedRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdminVerifyProtectedTimestampResponse_FailedRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminVerifyProtectedTimestampResponse_FailedRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminVerifyProtectedTimestampResponse_FailedRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddSSTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddSSTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddSSTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IngestAsWrites {
		i--
		if m.IngestAsWrites {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MVCCStats != nil {
		{
			size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DisallowShadowing {
		i--
		if m.DisallowShadowing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddSSTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddSSTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddSSTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RefreshFrom.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RefreshFrom.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RefreshRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubsumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubsumeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubsumeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RightDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LeftDesc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubsumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubsumeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubsumeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadSummary != nil {
		{
			size, err := m.ReadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.ClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.FreezeStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.LeaseAppliedIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LeaseAppliedIndex))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxQueriesPerSecondSet {
		i--
		if m.MaxQueriesPerSecondSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxQueriesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxQueriesPerSecond))))
		i--
		dAtA[i] = 0x29
	}
	{
		size, err := m.RangeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.DeprecatedLastQueriesPerSecond != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeprecatedLastQueriesPerSecond))))
		i--
		dAtA[i] = 0x19
	}
	{
		size, err := m.MVCCStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.RequestHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MigrateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResponseHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RequestUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ConditionalPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalPut != nil {
		{
			size, err := m.ConditionalPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_DeleteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_DeleteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteRange != nil {
		{
			size, err := m.DeleteRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Scan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_EndTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_EndTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndTxn != nil {
		{
			size, err := m.EndTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminSplit != nil {
		{
			size, err := m.AdminSplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminMerge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminMerge != nil {
		{
			size, err := m.AdminMerge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_HeartbeatTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_HeartbeatTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeartbeatTxn != nil {
		{
			size, err := m.HeartbeatTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Gc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Gc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gc != nil {
		{
			size, err := m.Gc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_PushTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_PushTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PushTxn != nil {
		{
			size, err := m.PushTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ResolveIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ResolveIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntent != nil {
		{
			size, err := m.ResolveIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ResolveIntentRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ResolveIntentRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntentRange != nil {
		{
			size, err := m.ResolveIntentRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_TruncateLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_TruncateLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateLog != nil {
		{
			size, err := m.TruncateLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RequestLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RequestLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestLease != nil {
		{
			size, err := m.RequestLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ReverseScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ReverseScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReverseScan != nil {
		{
			size, err := m.ReverseScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ComputeChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ComputeChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ComputeChecksum != nil {
		{
			size, err := m.ComputeChecksum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_CheckConsistency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_CheckConsistency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConsistency != nil {
		{
			size, err := m.CheckConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_InitPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_InitPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InitPut != nil {
		{
			size, err := m.InitPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_TransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_TransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TransferLease != nil {
		{
			size, err := m.TransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminTransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminTransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminTransferLease != nil {
		{
			size, err := m.AdminTransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_LeaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_LeaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseInfo != nil {
		{
			size, err := m.LeaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Export) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Export) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Export != nil {
		{
			size, err := m.Export.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryTxn != nil {
		{
			size, err := m.QueryTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminChangeReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminChangeReplicas != nil {
		{
			size, err := m.AdminChangeReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminScatter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminScatter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminScatter != nil {
		{
			size, err := m.AdminScatter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AddSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AddSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSstable != nil {
		{
			size, err := m.AddSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_ClearRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_ClearRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearRange != nil {
		{
			size, err := m.ClearRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RecomputeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RecomputeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecomputeStats != nil {
		{
			size, err := m.RecomputeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Refresh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Refresh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Refresh != nil {
		{
			size, err := m.Refresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RefreshRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RefreshRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RefreshRange != nil {
		{
			size, err := m.RefreshRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_QueryIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_QueryIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryIntent != nil {
		{
			size, err := m.QueryIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Subsume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Subsume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subsume != nil {
		{
			size, err := m.Subsume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RangeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RangeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeStats != nil {
		{
			size, err := m.RangeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminRelocateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminRelocateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminRelocateRange != nil {
		{
			size, err := m.AdminRelocateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RecoverTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RecoverTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecoverTxn != nil {
		{
			size, err := m.RecoverTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminUnsplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminUnsplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminUnsplit != nil {
		{
			size, err := m.AdminUnsplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_RevertRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_RevertRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RevertRange != nil {
		{
			size, err := m.RevertRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_AdminVerifyProtectedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_AdminVerifyProtectedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminVerifyProtectedTimestamp != nil {
		{
			size, err := m.AdminVerifyProtectedTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *RequestUnion_Migrate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestUnion_Migrate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Migrate != nil {
		{
			size, err := m.Migrate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResponseUnion_Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Get != nil {
		{
			size, err := m.Get.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Put) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Put) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Put != nil {
		{
			size, err := m.Put.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ConditionalPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ConditionalPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConditionalPut != nil {
		{
			size, err := m.ConditionalPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Increment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Increment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Increment != nil {
		{
			size, err := m.Increment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Delete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Delete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_DeleteRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_DeleteRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteRange != nil {
		{
			size, err := m.DeleteRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Scan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_EndTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_EndTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndTxn != nil {
		{
			size, err := m.EndTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminSplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminSplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminSplit != nil {
		{
			size, err := m.AdminSplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminMerge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminMerge != nil {
		{
			size, err := m.AdminMerge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_HeartbeatTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_HeartbeatTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeartbeatTxn != nil {
		{
			size, err := m.HeartbeatTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Gc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Gc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gc != nil {
		{
			size, err := m.Gc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_PushTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_PushTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PushTxn != nil {
		{
			size, err := m.PushTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ResolveIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ResolveIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntent != nil {
		{
			size, err := m.ResolveIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ResolveIntentRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ResolveIntentRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResolveIntentRange != nil {
		{
			size, err := m.ResolveIntentRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_TruncateLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_TruncateLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateLog != nil {
		{
			size, err := m.TruncateLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RequestLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RequestLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestLease != nil {
		{
			size, err := m.RequestLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ReverseScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ReverseScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReverseScan != nil {
		{
			size, err := m.ReverseScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ComputeChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ComputeChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ComputeChecksum != nil {
		{
			size, err := m.ComputeChecksum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_CheckConsistency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_CheckConsistency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConsistency != nil {
		{
			size, err := m.CheckConsistency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_InitPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_InitPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InitPut != nil {
		{
			size, err := m.InitPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminTransferLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminTransferLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminTransferLease != nil {
		{
			size, err := m.AdminTransferLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_LeaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_LeaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseInfo != nil {
		{
			size, err := m.LeaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Export) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Export) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Export != nil {
		{
			size, err := m.Export.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryTxn != nil {
		{
			size, err := m.QueryTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminChangeReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminChangeReplicas != nil {
		{
			size, err := m.AdminChangeReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminScatter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminScatter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminScatter != nil {
		{
			size, err := m.AdminScatter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AddSstable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AddSstable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSstable != nil {
		{
			size, err := m.AddSstable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_ClearRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_ClearRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearRange != nil {
		{
			size, err := m.ClearRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RecomputeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RecomputeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecomputeStats != nil {
		{
			size, err := m.RecomputeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Refresh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Refresh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Refresh != nil {
		{
			size, err := m.Refresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RefreshRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RefreshRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RefreshRange != nil {
		{
			size, err := m.RefreshRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_QueryIntent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_QueryIntent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryIntent != nil {
		{
			size, err := m.QueryIntent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Subsume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Subsume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subsume != nil {
		{
			size, err := m.Subsume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RangeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RangeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RangeStats != nil {
		{
			size, err := m.RangeStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminRelocateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminRelocateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminRelocateRange != nil {
		{
			size, err := m.AdminRelocateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RecoverTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RecoverTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RecoverTxn != nil {
		{
			size, err := m.RecoverTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminUnsplit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminUnsplit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminUnsplit != nil {
		{
			size, err := m.AdminUnsplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_RevertRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_RevertRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RevertRange != nil {
		{
			size, err := m.RevertRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_AdminVerifyProtectedTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_AdminVerifyProtectedTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminVerifyProtectedTimestamp != nil {
		{
			size, err := m.AdminVerifyProtectedTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ResponseUnion_Migrate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseUnion_Migrate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Migrate != nil {
		{
			size, err := m.Migrate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WaitPolicy != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.WaitPolicy))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	{
		size, err := m.ClientRangeInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.CanForwardReadTimestamp {
		i--
		if m.CanForwardReadTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TargetBytes != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TargetBytes))
		i--
		dAtA[i] = 0x78
	}
	if m.AsyncConsensus {
		i--
		if m.AsyncConsensus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.GatewayNodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.GatewayNodeID))
		i--
		dAtA[i] = 0x58
	}
	if m.DistinctSpans {
		i--
		if m.DistinctSpans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxSpanRequestKeys != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxSpanRequestKeys))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadConsistency != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadConsistency))
		i--
		dAtA[i] = 0x30
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.UserPriority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UserPriority))))
		i--
		dAtA[i] = 0x21
	}
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AdmissionHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Source != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateTime != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Priority != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AdmissionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.BatchResponse_Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BatchResponse_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchResponse_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchResponse_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeInfos) > 0 {
		for iNdEx := len(m.RangeInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangeInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CollectedSpans) > 0 {
		for iNdEx := len(m.CollectedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.Now.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLookupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLookupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLookupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrefetchReverse {
		i--
		if m.PrefetchReverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PrefetchNum != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.PrefetchNum))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadConsistency != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ReadConsistency))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeLookupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeLookupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeLookupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PrefetchedDescriptors) > 0 {
		for iNdEx := len(m.PrefetchedDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrefetchedDescriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AdmissionHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.WithDiff {
		i--
		if m.WithDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PrevValue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RangeFeedCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RangeFeedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeFeedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeFeedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Checkpoint != nil {
		{
			size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetQuorumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetQuorumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetQuorumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetQuorumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetQuorumResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetQuorumResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GossipSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for iNdEx := len(m.Patterns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Patterns[iNdEx])
			copy(dAtA[i:], m.Patterns[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Patterns[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GossipSubscriptionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipSubscriptionEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GossipSubscriptionEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.PatternMatched) > 0 {
		i -= len(m.PatternMatched)
		copy(dAtA[i:], m.PatternMatched)
		i = encodeVarintApi(dAtA, i, uint64(len(m.PatternMatched)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JoinNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BinaryVersion != nil {
		{
			size, err := m.BinaryVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JoinNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveVersion != nil {
		{
			size, err := m.ActiveVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StoreID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintApi(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContentionEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentionEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContentionEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n267, err267 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Duration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration):])
	if err267 != nil {
		return 0, err267
	}
	i -= n267
	i = encodeVarintApi(dAtA, i, uint64(n267))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TxnMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintApi(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovApi(uint64(m.Sequence))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ResumeSpan != nil {
		l = m.ResumeSpan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NumKeys != 0 {
		n += 1 + sovApi(uint64(m.NumKeys))
	}
	if m.ResumeReason != 0 {
		n += 1 + sovApi(uint64(m.ResumeReason))
	}
	if m.NumBytes != 0 {
		n += 1 + sovApi(uint64(m.NumBytes))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.KeyLocking != 0 {
		n += 1 + sovApi(uint64(m.KeyLocking))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IntentValue != nil {
		l = m.IntentValue.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Inline {
		n += 2
	}
	if m.Blind {
		n += 2
	}
	return n
}

func (m *PutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ConditionalPutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DeprecatedExpValue != nil {
		l = m.DeprecatedExpValue.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Blind {
		n += 2
	}
	if m.AllowIfDoesNotExist {
		n += 2
	}
	l = len(m.ExpBytes)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Inline {
		n += 2
	}
	return n
}

func (m *ConditionalPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *InitPutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Blind {
		n += 2
	}
	if m.FailOnTombstones {
		n += 2
	}
	return n
}

func (m *InitPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *IncrementRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Increment != 0 {
		n += 1 + sovApi(uint64(m.Increment))
	}
	return n
}

func (m *IncrementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.NewValue != 0 {
		n += 1 + sovApi(uint64(m.NewValue))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *DeleteRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReturnKeys {
		n += 2
	}
	if m.Inline {
		n += 2
	}
	return n
}

func (m *DeleteRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ClearRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Deadline.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ClearRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RevertRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.TargetTime.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.EnableTimeBoundIteratorOptimization {
		n += 2
	}
	if m.IgnoreGcThreshold {
		n += 2
	}
	return n
}

func (m *RevertRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ScanFormat != 0 {
		n += 1 + sovApi(uint64(m.ScanFormat))
	}
	if m.KeyLocking != 0 {
		n += 1 + sovApi(uint64(m.KeyLocking))
	}
	return n
}

func (m *ScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.IntentRows) > 0 {
		for _, e := range m.IntentRows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BatchResponses) > 0 {
		for _, b := range m.BatchResponses {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ReverseScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ScanFormat != 0 {
		n += 1 + sovApi(uint64(m.ScanFormat))
	}
	if m.KeyLocking != 0 {
		n += 1 + sovApi(uint64(m.KeyLocking))
	}
	return n
}

func (m *ReverseScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.IntentRows) > 0 {
		for _, e := range m.IntentRows {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BatchResponses) > 0 {
		for _, b := range m.BatchResponses {
			l = len(b)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CheckConsistencyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WithDiff {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	if m.Checkpoint {
		n += 2
	}
	if len(m.Terminate) > 0 {
		for _, e := range m.Terminate {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CheckConsistencyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CheckConsistencyResponse_Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RecomputeStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DryRun {
		n += 2
	}
	return n
}

func (m *RecomputeStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.AddedDelta.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *EndTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Commit {
		n += 2
	}
	if m.Deadline != nil {
		l = m.Deadline.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.InternalCommitTrigger != nil {
		l = m.InternalCommitTrigger.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LockSpans) > 0 {
		for _, e := range m.LockSpans {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Require1PC {
		n += 2
	}
	if m.Poison {
		n += 2
	}
	if m.TxnHeartbeating {
		n += 2
	}
	if len(m.InFlightWrites) > 0 {
		for _, e := range m.InFlightWrites {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *EndTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.OnePhaseCommit {
		n += 2
	}
	l = m.StagingTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.ExpirationTime.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminUnsplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminUnsplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminMergeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminMergeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminTransferLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Target != 0 {
		n += 1 + sovApi(uint64(m.Target))
	}
	return n
}

func (m *AdminTransferLeaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ReplicationChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovApi(uint64(m.ChangeType))
	}
	l = m.Target.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminChangeReplicasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DeprecatedChangeType != 0 {
		n += 1 + sovApi(uint64(m.DeprecatedChangeType))
	}
	if len(m.DeprecatedTargets) > 0 {
		for _, e := range m.DeprecatedTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.ExpDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.InternalChanges) > 0 {
		for _, e := range m.InternalChanges {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminChangeReplicasResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Desc.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminRelocateRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.VoterTargets) > 0 {
		for _, e := range m.VoterTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.NonVoterTargets) > 0 {
		for _, e := range m.NonVoterTargets {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminRelocateRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *HeartbeatTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Now.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *HeartbeatTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.Threshold.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCRequest_GCKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *GCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *PushTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusherTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusheeTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PushTo.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.PushType != 0 {
		n += 1 + sovApi(uint64(m.PushType))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *PushTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PusheeTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RecoverTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ImplicitlyCommitted {
		n += 2
	}
	return n
}

func (m *RecoverTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RecoveredTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *QueryTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WaitForUpdate {
		n += 2
	}
	if len(m.KnownWaitingTxns) > 0 {
		for _, e := range m.KnownWaitingTxns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *QueryTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.QueriedTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.WaitingTxns) > 0 {
		for _, e := range m.WaitingTxns {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.TxnRecordExists {
		n += 2
	}
	return n
}

func (m *QueryIntentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ErrorIfMissing {
		n += 2
	}
	return n
}

func (m *QueryIntentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.FoundIntent {
		n += 2
	}
	return n
}

func (m *ResolveIntentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.IntentTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Poison {
		n += 2
	}
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ResolveIntentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ResolveIntentRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.IntentTxn.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.Poison {
		n += 2
	}
	l = m.MinTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.IgnoredSeqNums) > 0 {
		for _, e := range m.IgnoredSeqNums {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ResolveIntentRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MergeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MergeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *TruncateLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	return n
}

func (m *TruncateLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RequestLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevLease.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MinProposedTS != nil {
		l = m.MinProposedTS.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TransferLeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevLease.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *LeaseInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *LeaseInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.CurrentLease != nil {
		l = m.CurrentLease.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EvaluatedBy != 0 {
		n += 1 + sovApi(uint64(m.EvaluatedBy))
	}
	return n
}

func (m *RequestLeaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ComputeChecksumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Version != 0 {
		n += 1 + sovApi(uint64(m.Version))
	}
	if m.Snapshot {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	if m.Checkpoint {
		n += 2
	}
	if len(m.Terminate) > 0 {
		for _, e := range m.Terminate {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ComputeChecksumResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ChecksumID.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExternalStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Provider != 0 {
		n += 1 + sovApi(uint64(m.Provider))
	}
	l = m.LocalFile.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.HttpPath.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.GoogleCloudConfig != nil {
		l = m.GoogleCloudConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.S3Config != nil {
		l = m.S3Config.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AzureConfig != nil {
		l = m.AzureConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.FileTableConfig.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExternalStorage_LocalFilePath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NodeID != 0 {
		n += 1 + sovApi(uint64(m.NodeID))
	}
	return n
}

func (m *ExternalStorage_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseUri)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExternalStorage_S3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.TempToken)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServerEncMode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ServerKMSID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExternalStorage_GCS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.BillingProject)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Credentials)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExternalStorage_Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AccountKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExternalStorage_FileTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.QualifiedTableName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RetryTracingEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttemptNumber != 0 {
		n += 1 + sovApi(uint64(m.AttemptNumber))
	}
	l = len(m.RetryError)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *FileEncryptionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ExportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Storage.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.StartTime.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MVCCFilter != 0 {
		n += 1 + sovApi(uint64(m.MVCCFilter))
	}
	if m.ReturnSST {
		n += 2
	}
	if m.EnableTimeBoundIteratorOptimization {
		n += 2
	}
	if len(m.StorageByLocalityKV) > 0 {
		for k, v := range m.StorageByLocalityKV {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TargetFileSize != 0 {
		n += 1 + sovApi(uint64(m.TargetFileSize))
	}
	if m.ReturnSstBelowSize != 0 {
		n += 1 + sovApi(uint64(m.ReturnSstBelowSize))
	}
	return n
}

func (m *BulkOpSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSize != 0 {
		n += 1 + sovApi(uint64(m.DataSize))
	}
	if m.DeprecatedRows != 0 {
		n += 1 + sovApi(uint64(m.DeprecatedRows))
	}
	if m.DeprecatedIndexEntries != 0 {
		n += 1 + sovApi(uint64(m.DeprecatedIndexEntries))
	}
	if len(m.EntryCounts) > 0 {
		for k, v := range m.EntryCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ExportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.StartTime.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *ExportResponse_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Exported.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.SST)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LocalityKV)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AdminScatterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RandomizeLeases {
		n += 2
	}
	return n
}

func (m *AdminScatterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.RangeInfos) > 0 {
		for _, e := range m.RangeInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminScatterResponse_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminVerifyProtectedTimestampRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Protected.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RecordAliveAt.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RecordID.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *AdminVerifyProtectedTimestampResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Verified {
		n += 2
	}
	if len(m.DeprecatedFailedRanges) > 0 {
		for _, e := range m.DeprecatedFailedRanges {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.VerificationFailedRanges) > 0 {
		for _, e := range m.VerificationFailedRanges {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *AdminVerifyProtectedTimestampResponse_FailedRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AddSSTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DisallowShadowing {
		n += 2
	}
	if m.MVCCStats != nil {
		l = m.MVCCStats.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IngestAsWrites {
		n += 2
	}
	return n
}

func (m *AddSSTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RefreshFrom.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RefreshFrom.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RefreshRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *SubsumeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.LeftDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.RightDesc.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *SubsumeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.MVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.LeaseAppliedIndex != 0 {
		n += 1 + sovApi(uint64(m.LeaseAppliedIndex))
	}
	l = m.FreezeStart.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ClosedTimestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.ReadSummary != nil {
		l = m.ReadSummary.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RangeStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.MVCCStats.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.DeprecatedLastQueriesPerSecond != 0 {
		n += 9
	}
	l = m.RangeInfo.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.MaxQueriesPerSecond != 0 {
		n += 9
	}
	if m.MaxQueriesPerSecondSet {
		n += 2
	}
	return n
}

func (m *MigrateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Version.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *MigrateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RequestUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *RequestUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_DeleteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_EndTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndTxn != nil {
		l = m.EndTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminSplit != nil {
		l = m.AdminSplit.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminMerge != nil {
		l = m.AdminMerge.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_HeartbeatTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Gc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gc != nil {
		l = m.Gc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_PushTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ResolveIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ResolveIntentRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_TruncateLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RequestLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestLease != nil {
		l = m.RequestLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ReverseScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReverseScan != nil {
		l = m.ReverseScan.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ComputeChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_CheckConsistency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConsistency != nil {
		l = m.CheckConsistency.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_InitPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitPut != nil {
		l = m.InitPut.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_TransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransferLease != nil {
		l = m.TransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminTransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminTransferLease != nil {
		l = m.AdminTransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_LeaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseInfo != nil {
		l = m.LeaseInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Export) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Export != nil {
		l = m.Export.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryTxn != nil {
		l = m.QueryTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminChangeReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminChangeReplicas != nil {
		l = m.AdminChangeReplicas.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminScatter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminScatter != nil {
		l = m.AdminScatter.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AddSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSstable != nil {
		l = m.AddSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_ClearRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearRange != nil {
		l = m.ClearRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RecomputeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecomputeStats != nil {
		l = m.RecomputeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Refresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refresh != nil {
		l = m.Refresh.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RefreshRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefreshRange != nil {
		l = m.RefreshRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_QueryIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryIntent != nil {
		l = m.QueryIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Subsume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subsume != nil {
		l = m.Subsume.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RangeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeStats != nil {
		l = m.RangeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminRelocateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminRelocateRange != nil {
		l = m.AdminRelocateRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RecoverTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecoverTxn != nil {
		l = m.RecoverTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminUnsplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminUnsplit != nil {
		l = m.AdminUnsplit.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_RevertRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevertRange != nil {
		l = m.RevertRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_AdminVerifyProtectedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminVerifyProtectedTimestamp != nil {
		l = m.AdminVerifyProtectedTimestamp.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *RequestUnion_Migrate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Migrate != nil {
		l = m.Migrate.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *ResponseUnion_Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Put) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ConditionalPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Increment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Delete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_DeleteRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_EndTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndTxn != nil {
		l = m.EndTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminSplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminSplit != nil {
		l = m.AdminSplit.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminMerge != nil {
		l = m.AdminMerge.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_HeartbeatTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Gc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gc != nil {
		l = m.Gc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_PushTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ResolveIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ResolveIntentRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_TruncateLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RequestLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestLease != nil {
		l = m.RequestLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ReverseScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReverseScan != nil {
		l = m.ReverseScan.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ComputeChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_CheckConsistency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConsistency != nil {
		l = m.CheckConsistency.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_InitPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InitPut != nil {
		l = m.InitPut.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminTransferLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminTransferLease != nil {
		l = m.AdminTransferLease.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_LeaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseInfo != nil {
		l = m.LeaseInfo.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Export) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Export != nil {
		l = m.Export.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryTxn != nil {
		l = m.QueryTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminChangeReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminChangeReplicas != nil {
		l = m.AdminChangeReplicas.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminScatter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminScatter != nil {
		l = m.AdminScatter.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AddSstable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSstable != nil {
		l = m.AddSstable.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_ClearRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearRange != nil {
		l = m.ClearRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RecomputeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecomputeStats != nil {
		l = m.RecomputeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Refresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refresh != nil {
		l = m.Refresh.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RefreshRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefreshRange != nil {
		l = m.RefreshRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_QueryIntent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryIntent != nil {
		l = m.QueryIntent.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Subsume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subsume != nil {
		l = m.Subsume.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RangeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeStats != nil {
		l = m.RangeStats.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminRelocateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminRelocateRange != nil {
		l = m.AdminRelocateRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RecoverTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecoverTxn != nil {
		l = m.RecoverTxn.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminUnsplit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminUnsplit != nil {
		l = m.AdminUnsplit.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_RevertRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RevertRange != nil {
		l = m.RevertRange.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_AdminVerifyProtectedTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminVerifyProtectedTimestamp != nil {
		l = m.AdminVerifyProtectedTimestamp.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ResponseUnion_Migrate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Migrate != nil {
		l = m.Migrate.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Replica.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	if m.UserPriority != 0 {
		n += 9
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ReadConsistency != 0 {
		n += 1 + sovApi(uint64(m.ReadConsistency))
	}
	if m.MaxSpanRequestKeys != 0 {
		n += 1 + sovApi(uint64(m.MaxSpanRequestKeys))
	}
	if m.DistinctSpans {
		n += 2
	}
	if m.GatewayNodeID != 0 {
		n += 1 + sovApi(uint64(m.GatewayNodeID))
	}
	if m.AsyncConsensus {
		n += 2
	}
	if m.TargetBytes != 0 {
		n += 1 + sovApi(uint64(m.TargetBytes))
	}
	if m.CanForwardReadTimestamp {
		n += 3
	}
	l = m.ClientRangeInfo.Size()
	n += 2 + l + sovApi(uint64(l))
	if m.WaitPolicy != 0 {
		n += 2 + sovApi(uint64(m.WaitPolicy))
	}
	return n
}

func (m *AdmissionHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovApi(uint64(m.Priority))
	}
	if m.CreateTime != 0 {
		n += 1 + sovApi(uint64(m.CreateTime))
	}
	if m.Source != 0 {
		n += 1 + sovApi(uint64(m.Source))
	}
	return n
}

func (m *BatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = m.AdmissionHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *BatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BatchResponse_Header.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *BatchResponse_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Now.Size()
	n += 1 + l + sovApi(uint64(l))
	if len(m.CollectedSpans) > 0 {
		for _, e := range m.CollectedSpans {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RangeInfos) > 0 {
		for _, e := range m.RangeInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *RangeLookupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ReadConsistency != 0 {
		n += 1 + sovApi(uint64(m.ReadConsistency))
	}
	if m.PrefetchNum != 0 {
		n += 1 + sovApi(uint64(m.PrefetchNum))
	}
	if m.PrefetchReverse {
		n += 2
	}
	return n
}

func (m *RangeLookupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.PrefetchedDescriptors) > 0 {
		for _, e := range m.PrefetchedDescriptors {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RangeFeedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.WithDiff {
		n += 2
	}
	l = m.AdmissionHeader.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.PrevValue.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.ResolvedTS.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *RangeFeedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ResetQuorumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovApi(uint64(m.RangeID))
	}
	return n
}

func (m *ResetQuorumResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GossipSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Patterns) > 0 {
		for _, s := range m.Patterns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GossipSubscriptionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Content.Size()
	n += 1 + l + sovApi(uint64(l))
	l = len(m.PatternMatched)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *JoinNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinaryVersion != nil {
		l = m.BinaryVersion.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *JoinNodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NodeID != 0 {
		n += 1 + sovApi(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovApi(uint64(m.StoreID))
	}
	if m.ActiveVersion != nil {
		l = m.ActiveVersion.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ContentionEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.TxnMeta.Size()
	n += 1 + l + sovApi(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Duration)
	n += 1 + l + sovApi(uint64(l))
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RangeFeedEvent) GetValue() interface{} {
	if this.Val != nil {
		return this.Val
	}
	if this.Checkpoint != nil {
		return this.Checkpoint
	}
	if this.Error != nil {
		return this.Error
	}
	return nil
}

func (this *RangeFeedEvent) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *RangeFeedValue:
		this.Val = vt
	case *RangeFeedCheckpoint:
		this.Checkpoint = vt
	case *RangeFeedError:
		this.Error = vt
	default:
		return false
	}
	return true
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= github_com_cockroachdb_cockroach_pkg_storage_enginepb.TxnSeq(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeSpan == nil {
				m.ResumeSpan = &Span{}
			}
			if err := m.ResumeSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeys", wireType)
			}
			m.NumKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumKeys |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeReason", wireType)
			}
			m.ResumeReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResumeReason |= ResponseHeader_ResumeReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLocking", wireType)
			}
			m.KeyLocking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLocking |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntentValue == nil {
				m.IntentValue = &Value{}
			}
			if err := m.IntentValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedExpValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedExpValue == nil {
				m.DeprecatedExpValue = &Value{}
			}
			if err := m.DeprecatedExpValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIfDoesNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIfDoesNotExist = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpBytes = append(m.ExpBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ExpBytes == nil {
				m.ExpBytes = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionalPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionalPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionalPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blind = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailOnTombstones", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailOnTombstones = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			m.NewValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnKeys = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inline = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevertRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevertRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevertRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTimeBoundIteratorOptimization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTimeBoundIteratorOptimization = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreGcThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreGcThreshold = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevertRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevertRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevertRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanFormat", wireType)
			}
			m.ScanFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanFormat |= ScanFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLocking", wireType)
			}
			m.KeyLocking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLocking |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, KeyValue{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentRows = append(m.IntentRows, KeyValue{})
			if err := m.IntentRows[len(m.IntentRows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchResponses = append(m.BatchResponses, make([]byte, postIndex-iNdEx))
			copy(m.BatchResponses[len(m.BatchResponses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanFormat", wireType)
			}
			m.ScanFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanFormat |= ScanFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLocking", wireType)
			}
			m.KeyLocking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyLocking |= lock.Strength(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, KeyValue{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentRows = append(m.IntentRows, KeyValue{})
			if err := m.IntentRows[len(m.IntentRows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchResponses = append(m.BatchResponses, make([]byte, postIndex-iNdEx))
			copy(m.BatchResponses[len(m.BatchResponses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConsistencyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConsistencyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithDiff = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ChecksumMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkpoint = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminate = append(m.Terminate, ReplicaDescriptor{})
			if err := m.Terminate[len(m.Terminate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConsistencyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConsistencyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, CheckConsistencyResponse_Result{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConsistencyResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CheckConsistencyResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecomputeStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecomputeStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecomputeStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecomputeStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecomputeStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecomputeStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddedDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Commit = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadline == nil {
				m.Deadline = &hlc.Timestamp{}
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalCommitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalCommitTrigger == nil {
				m.InternalCommitTrigger = &InternalCommitTrigger{}
			}
			if err := m.InternalCommitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockSpans = append(m.LockSpans, Span{})
			if err := m.LockSpans[len(m.LockSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Require1PC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Require1PC = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnHeartbeating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxnHeartbeating = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InFlightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InFlightWrites = append(m.InFlightWrites, SequencedWrite{})
			if err := m.InFlightWrites[len(m.InFlightWrites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnePhaseCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnePhaseCommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StagingTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StagingTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminUnsplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminUnsplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminUnsplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminUnsplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminUnsplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminUnsplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminMergeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminMergeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminMergeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminMergeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminMergeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminMergeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminTransferLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminTransferLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminTransferLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminTransferLeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminTransferLeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminTransferLeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= ReplicaChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminChangeReplicasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminChangeReplicasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminChangeReplicasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedChangeType", wireType)
			}
			m.DeprecatedChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedChangeType |= ReplicaChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedTargets = append(m.DeprecatedTargets, ReplicationTarget{})
			if err := m.DeprecatedTargets[len(m.DeprecatedTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalChanges = append(m.InternalChanges, ReplicationChange{})
			if err := m.InternalChanges[len(m.InternalChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminChangeReplicasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminChangeReplicasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminChangeReplicasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRelocateRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRelocateRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRelocateRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoterTargets = append(m.VoterTargets, ReplicationTarget{})
			if err := m.VoterTargets[len(m.VoterTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonVoterTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonVoterTargets = append(m.NonVoterTargets, ReplicationTarget{})
			if err := m.NonVoterTargets[len(m.NonVoterTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRelocateRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRelocateRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRelocateRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, GCRequest_GCKey{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest_GCKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusherTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusherTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PushTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushType", wireType)
			}
			m.PushType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushType |= PushTxnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitlyCommitted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitlyCommitted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveredTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecoveredTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitForUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WaitForUpdate = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownWaitingTxns", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.KnownWaitingTxns = append(m.KnownWaitingTxns, v)
			if err := m.KnownWaitingTxns[len(m.KnownWaitingTxns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriedTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QueriedTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitingTxns", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_pkg_util_uuid.UUID
			m.WaitingTxns = append(m.WaitingTxns, v)
			if err := m.WaitingTxns[len(m.WaitingTxns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxnRecordExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIntentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIntentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIntentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorIfMissing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorIfMissing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIntentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIntentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIntentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundIntent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundIntent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntentTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntentTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poison", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Poison = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredSeqNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoredSeqNums = append(m.IgnoredSeqNums, enginepb.IgnoredSeqNumRange{})
			if err := m.IgnoredSeqNums[len(m.IgnoredSeqNums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIntentRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIntentRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIntentRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinProposedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinProposedTS == nil {
				m.MinProposedTS = &github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp{}
			}
			if err := m.MinProposedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentLease == nil {
				m.CurrentLease = &Lease{}
			}
			if err := m.CurrentLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluatedBy", wireType)
			}
			m.EvaluatedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EvaluatedBy |= StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeChecksumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeChecksumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeChecksumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshot = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= ChecksumMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkpoint = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminate = append(m.Terminate, ReplicaDescriptor{})
			if err := m.Terminate[len(m.Terminate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeChecksumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeChecksumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeChecksumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChecksumID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= ExternalStorageProvider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LocalFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HttpPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoogleCloudConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoogleCloudConfig == nil {
				m.GoogleCloudConfig = &ExternalStorage_GCS{}
			}
			if err := m.GoogleCloudConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S3Config == nil {
				m.S3Config = &ExternalStorage_S3{}
			}
			if err := m.S3Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AzureConfig == nil {
				m.AzureConfig = &ExternalStorage_Azure{}
			}
			if err := m.AzureConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTableConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileTableConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_LocalFilePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalFilePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalFilePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_Http) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Http: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Http: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_S3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TempToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerEncMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerEncMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerKMSID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerKMSID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_GCS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingProject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingProject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorage_FileTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QualifiedTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QualifiedTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryTracingEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryTracingEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryTracingEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttemptNumber", wireType)
			}
			m.AttemptNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttemptNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileEncryptionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileEncryptionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileEncryptionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCFilter", wireType)
			}
			m.MVCCFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MVCCFilter |= MVCCFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnSST", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnSST = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTimeBoundIteratorOptimization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTimeBoundIteratorOptimization = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageByLocalityKV == nil {
				m.StorageByLocalityKV = make(map[string]*ExternalStorage)
			}
			var mapkey string
			var mapvalue *ExternalStorage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ExternalStorage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StorageByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileSize", wireType)
			}
			m.TargetFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnSstBelowSize", wireType)
			}
			m.ReturnSstBelowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnSstBelowSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkOpSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkOpSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkOpSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedRows", wireType)
			}
			m.DeprecatedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedIndexEntries", wireType)
			}
			m.DeprecatedIndexEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedIndexEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EntryCounts == nil {
				m.EntryCounts = make(map[uint64]int64)
			}
			var mapkey uint64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EntryCounts[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, ExportResponse_File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportResponse_File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exported.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SST", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SST = append(m.SST[:0], dAtA[iNdEx:postIndex]...)
			if m.SST == nil {
				m.SST = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityKV", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityKV = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminScatterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminScatterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomizeLeases", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomizeLeases = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminScatterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminScatterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeInfos = append(m.RangeInfos, RangeInfo{})
			if err := m.RangeInfos[len(m.RangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminScatterResponse_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminVerifyProtectedTimestampRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminVerifyProtectedTimestampRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminVerifyProtectedTimestampRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Protected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordAliveAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordAliveAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecordID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminVerifyProtectedTimestampResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminVerifyProtectedTimestampResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminVerifyProtectedTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedFailedRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedFailedRanges = append(m.DeprecatedFailedRanges, RangeDescriptor{})
			if err := m.DeprecatedFailedRanges[len(m.DeprecatedFailedRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationFailedRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationFailedRanges = append(m.VerificationFailedRanges, AdminVerifyProtectedTimestampResponse_FailedRange{})
			if err := m.VerificationFailedRanges[len(m.VerificationFailedRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminVerifyProtectedTimestampResponse_FailedRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddSSTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowShadowing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisallowShadowing = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MVCCStats == nil {
				m.MVCCStats = &enginepb.MVCCStats{}
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestAsWrites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IngestAsWrites = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddSSTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefreshFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefreshFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubsumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubsumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubsumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeftDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RightDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubsumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubsumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubsumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseAppliedIndex", wireType)
			}
			m.LeaseAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseAppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreezeStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreezeStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadSummary == nil {
				m.ReadSummary = &rspb.ReadSummary{}
			}
			if err := m.ReadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedLastQueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeprecatedLastQueriesPerSecond = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxQueriesPerSecond = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueriesPerSecondSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxQueriesPerSecondSet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Put{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConditionalPutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ConditionalPut{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IncrementRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Increment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Delete{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_DeleteRange{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScanRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Scan{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_EndTxn{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminSplitRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminSplit{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminMergeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminMerge{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HeartbeatTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_HeartbeatTxn{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Gc{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PushTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_PushTxn{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResolveIntentRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ResolveIntent{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResolveIntentRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ResolveIntentRange{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MergeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Merge{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateLogRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_TruncateLog{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestLeaseRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RequestLease{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReverseScanRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ReverseScan{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComputeChecksumRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ComputeChecksum{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CheckConsistencyRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_CheckConsistency{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InitPutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_InitPut{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransferLeaseRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_TransferLease{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminTransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminTransferLeaseRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminTransferLease{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeaseInfoRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_LeaseInfo{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Export", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExportRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Export{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_QueryTxn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminChangeReplicasRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminChangeReplicas{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminScatter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminScatterRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminScatter{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddSSTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AddSstable{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_ClearRange{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecomputeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecomputeStatsRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RecomputeStats{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RefreshRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Refresh{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RefreshRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RefreshRange{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryIntentRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_QueryIntent{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubsumeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Subsume{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RangeStatsRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RangeStats{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRelocateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminRelocateRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminRelocateRange{v}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecoverTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RecoverTxn{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUnsplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminUnsplitRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminUnsplit{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RevertRangeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_RevertRange{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminVerifyProtectedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminVerifyProtectedTimestampRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_AdminVerifyProtectedTimestamp{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Migrate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MigrateRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RequestUnion_Migrate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Get{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Put{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConditionalPutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ConditionalPut{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IncrementResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Increment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Delete{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_DeleteRange{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScanResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Scan{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_EndTxn{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminSplitResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminSplit{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminMergeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminMerge{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HeartbeatTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_HeartbeatTxn{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Gc{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PushTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_PushTxn{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResolveIntentResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ResolveIntent{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResolveIntentRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ResolveIntentRange{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MergeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Merge{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateLogResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_TruncateLog{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestLeaseResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RequestLease{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReverseScanResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ReverseScan{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComputeChecksumResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ComputeChecksum{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConsistency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CheckConsistencyResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_CheckConsistency{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InitPutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_InitPut{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminTransferLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminTransferLeaseResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminTransferLease{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeaseInfoResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_LeaseInfo{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Export", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExportResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Export{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_QueryTxn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminChangeReplicasResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminChangeReplicas{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminScatter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminScatterResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminScatter{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSstable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddSSTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AddSstable{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_ClearRange{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecomputeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecomputeStatsResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RecomputeStats{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RefreshResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Refresh{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RefreshRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RefreshRange{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryIntentResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_QueryIntent{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubsumeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Subsume{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RangeStatsResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RangeStats{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRelocateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminRelocateRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminRelocateRange{v}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecoverTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RecoverTxn{v}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUnsplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminUnsplitResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminUnsplit{v}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevertRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RevertRangeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_RevertRange{v}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminVerifyProtectedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminVerifyProtectedTimestampResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_AdminVerifyProtectedTimestamp{v}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Migrate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MigrateResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &ResponseUnion_Migrate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPriority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UserPriority = UserPriority(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			m.ReadConsistency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadConsistency |= ReadConsistencyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSpanRequestKeys", wireType)
			}
			m.MaxSpanRequestKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSpanRequestKeys |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistinctSpans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistinctSpans = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayNodeID", wireType)
			}
			m.GatewayNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayNodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsyncConsensus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsyncConsensus = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBytes", wireType)
			}
			m.TargetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanForwardReadTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanForwardReadTimestamp = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRangeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClientRangeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitPolicy", wireType)
			}
			m.WaitPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitPolicy |= lock.WaitPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= AdmissionHeader_Source(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, RequestUnion{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdmissionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchResponse_Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchResponse_Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, ResponseUnion{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchResponse_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Now.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpans = append(m.CollectedSpans, tracingpb.RecordedSpan{})
			if err := m.CollectedSpans[len(m.CollectedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeInfos = append(m.RangeInfos, RangeInfo{})
			if err := m.RangeInfos[len(m.RangeInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLookupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadConsistency", wireType)
			}
			m.ReadConsistency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadConsistency |= ReadConsistencyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchNum", wireType)
			}
			m.PrefetchNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefetchNum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchReverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrefetchReverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeLookupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeLookupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeLookupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, RangeDescriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchedDescriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrefetchedDescriptors = append(m.PrefetchedDescriptors, RangeDescriptor{})
			if err := m.PrefetchedDescriptors[len(m.PrefetchedDescriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithDiff = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdmissionHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedCheckpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedCheckpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeFeedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeFeedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeFeedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &RangeFeedValue{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &RangeFeedCheckpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &RangeFeedError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetQuorumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetQuorumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetQuorumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetQuorumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetQuorumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetQuorumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patterns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patterns = append(m.Patterns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipSubscriptionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipSubscriptionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipSubscriptionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternMatched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternMatched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryVersion == nil {
				m.BinaryVersion = &Version{}
			}
			if err := m.BinaryVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = append(m.ClusterID[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusterID == nil {
				m.ClusterID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveVersion == nil {
				m.ActiveVersion = &Version{}
			}
			if err := m.ActiveVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentionEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentionEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentionEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Duration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
