// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ts/catalog/chart_catalog.proto

package catalog

import (
	fmt "fmt"
	tspb "github.com/cockroachdb/cockroach/pkg/ts/tspb"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	_go "github.com/prometheus/client_model/go"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AxisUnits describes the Unit options available in the Admin UI. It is defined here
// as opposed to importing the value from the Admin UI because the existing pb doesn't
// include an UNSET value, which we use to check for defaults.
type AxisUnits int32

const (
	// UNSET_UNITS expresses that the metric's DisplayUnit wasn't explicitly set.
	AxisUnits_UNSET_UNITS AxisUnits = 0
	// COUNT expresses that the metric's measurement is a count.
	AxisUnits_COUNT AxisUnits = 1
	// BYTES expresses that the metric's measurement is in bytes.
	AxisUnits_BYTES AxisUnits = 2
	// DURATION expresses that the metric's measurement represents some unit of time.
	AxisUnits_DURATION AxisUnits = 3
)

var AxisUnits_name = map[int32]string{
	0: "UNSET_UNITS",
	1: "COUNT",
	2: "BYTES",
	3: "DURATION",
}

var AxisUnits_value = map[string]int32{
	"UNSET_UNITS": 0,
	"COUNT":       1,
	"BYTES":       2,
	"DURATION":    3,
}

func (x AxisUnits) Enum() *AxisUnits {
	p := new(AxisUnits)
	*p = x
	return p
}

func (x AxisUnits) String() string {
	return proto.EnumName(AxisUnits_name, int32(x))
}

func (x *AxisUnits) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AxisUnits_value, data, "AxisUnits")
	if err != nil {
		return err
	}
	*x = AxisUnits(value)
	return nil
}

func (AxisUnits) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{0}
}

// DescribeAggregator works as a proxy for cockroach.ts.tspb.TimeSeriesQueryAggregator
// which does not support an unset zero value.
type DescribeAggregator int32

const (
	// UNSET_AGG expresses that the Aggregator value wasn't explicitly set and should
	// use the default value for the respective metric type defined in chart_catalog.go.
	DescribeAggregator_UNSET_AGG DescribeAggregator = 0
	// AVG returns the average value of datapoints.
	DescribeAggregator_AVG DescribeAggregator = 1
	// SUM returns the sum value of datapoints.
	DescribeAggregator_SUM DescribeAggregator = 2
	// MAX returns the maximum value of datapoints.
	DescribeAggregator_MAX DescribeAggregator = 3
	// MIN returns the minimum value of datapoints.
	DescribeAggregator_MIN DescribeAggregator = 4
)

var DescribeAggregator_name = map[int32]string{
	0: "UNSET_AGG",
	1: "AVG",
	2: "SUM",
	3: "MAX",
	4: "MIN",
}

var DescribeAggregator_value = map[string]int32{
	"UNSET_AGG": 0,
	"AVG":       1,
	"SUM":       2,
	"MAX":       3,
	"MIN":       4,
}

func (x DescribeAggregator) Enum() *DescribeAggregator {
	p := new(DescribeAggregator)
	*p = x
	return p
}

func (x DescribeAggregator) String() string {
	return proto.EnumName(DescribeAggregator_name, int32(x))
}

func (x *DescribeAggregator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeAggregator_value, data, "DescribeAggregator")
	if err != nil {
		return err
	}
	*x = DescribeAggregator(value)
	return nil
}

func (DescribeAggregator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{1}
}

// DescribeDerivative works as a proxy for cockroach.ts.tspb.TimeSeriesQueryDerivative
// which has an ambiguous zero value; it's unclear if the value isn't set or if it
// is intentionally set to NONE.
type DescribeDerivative int32

const (
	// UNSET_DER expresses that the Derivative value wasn't explicitly set and should
	// use the default value for the respective metric type defined in chart_catalog.go.
	DescribeDerivative_UNSET_DER DescribeDerivative = 0
	// NONE does not apply a derivative function.
	DescribeDerivative_NONE DescribeDerivative = 1
	// DERIVATIVE returns the first-order derivative of values in the time series.
	DescribeDerivative_DERIVATIVE DescribeDerivative = 2
	// NON_NEGATIVE_DERIVATIVE returns only non-negative values of the first-order
	// derivative; negative values are returned as zero. This should be used for
	// counters that monotonically increase, but might wrap or reset.
	DescribeDerivative_NON_NEGATIVE_DERIVATIVE DescribeDerivative = 3
)

var DescribeDerivative_name = map[int32]string{
	0: "UNSET_DER",
	1: "NONE",
	2: "DERIVATIVE",
	3: "NON_NEGATIVE_DERIVATIVE",
}

var DescribeDerivative_value = map[string]int32{
	"UNSET_DER":               0,
	"NONE":                    1,
	"DERIVATIVE":              2,
	"NON_NEGATIVE_DERIVATIVE": 3,
}

func (x DescribeDerivative) Enum() *DescribeDerivative {
	p := new(DescribeDerivative)
	*p = x
	return p
}

func (x DescribeDerivative) String() string {
	return proto.EnumName(DescribeDerivative_name, int32(x))
}

func (x *DescribeDerivative) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeDerivative_value, data, "DescribeDerivative")
	if err != nil {
		return err
	}
	*x = DescribeDerivative(value)
	return nil
}

func (DescribeDerivative) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{2}
}

// ChartMetric converts cockroach.util.metric.Metadata
// into a struct that's useful for generating Admin UI charts.
type ChartMetric struct {
	// name is the name of the metric.
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// help is the help text from the metric.
	Help string `protobuf:"bytes,2,req,name=help" json:"help"`
	// axisLabel is the label for the metric's y-axis.
	AxisLabel string `protobuf:"bytes,3,req,name=axisLabel" json:"axisLabel"`
	// preferredUnits describes the units the chart should be viewed with
	// e.g. BYTES for storage.
	PreferredUnits AxisUnits `protobuf:"varint,4,req,name=preferredUnits,enum=cockroach.ts.catalog.AxisUnits" json:"preferredUnits"`
	// metricType describes the type of metric this is; all metrics on a chart
	// should be of the same type to ensure the information displays behaves in
	// expected ways.
	MetricType _go.MetricType `protobuf:"varint,5,opt,name=metricType,enum=io.prometheus.client.MetricType" json:"metricType"`
}

func (m *ChartMetric) Reset()         { *m = ChartMetric{} }
func (m *ChartMetric) String() string { return proto.CompactTextString(m) }
func (*ChartMetric) ProtoMessage()    {}
func (*ChartMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{0}
}
func (m *ChartMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChartMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartMetric.Merge(m, src)
}
func (m *ChartMetric) XXX_Size() int {
	return m.Size()
}
func (m *ChartMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartMetric.DiscardUnknown(m)
}

var xxx_messageInfo_ChartMetric proto.InternalMessageInfo

// IndividualChart describes both the properties necessary to display
// AdminUI charts, as well as a key to find them (collectionName).
type IndividualChart struct {
	// title is the title of the chart.
	Title string `protobuf:"bytes,1,req,name=title" json:"title"`
	// longname displays the chart's organization within the catalog,
	// as well as its own name.
	LongTitle string `protobuf:"bytes,2,req,name=longTitle" json:"longTitle"`
	// collectionName uniquely identifies a chart.
	CollectionTitle string `protobuf:"bytes,3,req,name=collectionTitle" json:"collectionTitle"`
	// downsampler specifies the chart's downsampler function.
	Downsampler *tspb.TimeSeriesQueryAggregator `protobuf:"varint,4,req,name=downsampler,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"downsampler,omitempty"`
	// aggregator specifies the chart's aggregator function.
	Aggregator *tspb.TimeSeriesQueryAggregator `protobuf:"varint,5,req,name=aggregator,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"aggregator,omitempty"`
	// derivative specifies the chart's derivative function.
	Derivative *tspb.TimeSeriesQueryDerivative `protobuf:"varint,6,req,name=derivative,enum=cockroach.ts.tspb.TimeSeriesQueryDerivative" json:"derivative,omitempty"`
	// units specifies the Admin UI units to display the chart with.
	Units AxisUnits `protobuf:"varint,7,req,name=units,enum=cockroach.ts.catalog.AxisUnits" json:"units"`
	// axisLabel defines the chart's y-axis label.
	AxisLabel string `protobuf:"bytes,8,req,name=axisLabel" json:"axisLabel"`
	// percentiles specifies whether the chart should have its metrics broken
	// out into percentiles; applies only to histograms.
	Percentiles bool `protobuf:"varint,9,req,name=percentiles" json:"percentiles"`
	// metrics specifies the metics the chart should display.
	Metrics []ChartMetric `protobuf:"bytes,10,rep,name=metrics" json:"metrics"`
}

func (m *IndividualChart) Reset()         { *m = IndividualChart{} }
func (m *IndividualChart) String() string { return proto.CompactTextString(m) }
func (*IndividualChart) ProtoMessage()    {}
func (*IndividualChart) Descriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{1}
}
func (m *IndividualChart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualChart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndividualChart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualChart.Merge(m, src)
}
func (m *IndividualChart) XXX_Size() int {
	return m.Size()
}
func (m *IndividualChart) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualChart.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualChart proto.InternalMessageInfo

// ChartSections organize charts into groups that contain slices or charts and
// other subsections.
type ChartSection struct {
	// title is the title of the section.
	Title string `protobuf:"bytes,1,req,name=title" json:"title"`
	// longname displays the section's organization within the catalog.
	LongTitle string `protobuf:"bytes,2,req,name=longTitle" json:"longTitle"`
	// collectionName uniquely identifies a section.
	CollectionTitle string `protobuf:"bytes,3,req,name=collectionTitle" json:"collectionTitle"`
	// description describes how to interpret the relationship of subsections
	// and charts. It's only planned use is in the catalog page for Level 0
	// sections.
	Description string `protobuf:"bytes,4,req,name=description" json:"description"`
	// level represents the section's depth in the catalog's organization.
	Level int32 `protobuf:"varint,5,req,name=level" json:"level"`
	// subsections are deeper levels of the chart's organization.
	Subsections []*ChartSection `protobuf:"bytes,6,rep,name=subsections" json:"subsections,omitempty"`
	// charts are the IndividualCharts that are grouped into this section.
	Charts []*IndividualChart `protobuf:"bytes,7,rep,name=charts" json:"charts,omitempty"`
}

func (m *ChartSection) Reset()         { *m = ChartSection{} }
func (m *ChartSection) String() string { return proto.CompactTextString(m) }
func (*ChartSection) ProtoMessage()    {}
func (*ChartSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_7783dcc7d3642629, []int{2}
}
func (m *ChartSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChartSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartSection.Merge(m, src)
}
func (m *ChartSection) XXX_Size() int {
	return m.Size()
}
func (m *ChartSection) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartSection.DiscardUnknown(m)
}

var xxx_messageInfo_ChartSection proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.ts.catalog.AxisUnits", AxisUnits_name, AxisUnits_value)
	proto.RegisterEnum("cockroach.ts.catalog.DescribeAggregator", DescribeAggregator_name, DescribeAggregator_value)
	proto.RegisterEnum("cockroach.ts.catalog.DescribeDerivative", DescribeDerivative_name, DescribeDerivative_value)
	proto.RegisterType((*ChartMetric)(nil), "cockroach.ts.catalog.ChartMetric")
	proto.RegisterType((*IndividualChart)(nil), "cockroach.ts.catalog.IndividualChart")
	proto.RegisterType((*ChartSection)(nil), "cockroach.ts.catalog.ChartSection")
}

func init() { proto.RegisterFile("ts/catalog/chart_catalog.proto", fileDescriptor_7783dcc7d3642629) }

var fileDescriptor_7783dcc7d3642629 = []byte{
	// 724 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xc1, 0x6e, 0xe2, 0x56,
	0x14, 0xb5, 0x0d, 0x04, 0xb8, 0xa4, 0xc4, 0x7a, 0x8a, 0x54, 0x2b, 0x95, 0x1c, 0x8a, 0xd4, 0x88,
	0x46, 0x95, 0x2d, 0x65, 0x5b, 0x55, 0xaa, 0x13, 0x28, 0x42, 0x0a, 0x46, 0x35, 0x26, 0x6a, 0xb3,
	0x41, 0xc6, 0xbc, 0xc2, 0x53, 0x8d, 0x6d, 0xbd, 0xf7, 0x60, 0x92, 0xbf, 0x98, 0xdf, 0x99, 0x2f,
	0x98, 0x2c, 0xb3, 0xcc, 0x6a, 0x34, 0x43, 0x7e, 0x63, 0x16, 0x23, 0x3f, 0x3b, 0xe0, 0x44, 0x68,
	0x34, 0x33, 0x8b, 0xd9, 0x5d, 0xce, 0xb9, 0xe7, 0xe8, 0xdd, 0x73, 0xaf, 0x01, 0x9d, 0x33, 0xd3,
	0xf7, 0xb8, 0x17, 0x44, 0x33, 0xd3, 0x9f, 0x7b, 0x94, 0x8f, 0xb3, 0x5f, 0x46, 0x4c, 0x23, 0x1e,
	0xa1, 0x43, 0x3f, 0xf2, 0xff, 0xa7, 0x91, 0xe7, 0xcf, 0x0d, 0xce, 0x8c, 0x8c, 0x3b, 0xd2, 0x38,
	0x33, 0x39, 0x8b, 0x27, 0x26, 0x27, 0x0b, 0xcc, 0x30, 0x25, 0x98, 0xa5, 0xfd, 0x47, 0x87, 0xb3,
	0x68, 0x16, 0x89, 0xd2, 0x4c, 0xaa, 0x0c, 0x6d, 0x92, 0xc8, 0x8c, 0x69, 0xb4, 0xc0, 0x7c, 0x8e,
	0x97, 0xcc, 0xf4, 0x03, 0x82, 0x43, 0x6e, 0x2e, 0x30, 0xa7, 0xc4, 0xcf, 0x94, 0xcd, 0x8f, 0x32,
	0xd4, 0x2e, 0x92, 0x17, 0xf4, 0x05, 0x8c, 0x34, 0x28, 0x86, 0xde, 0x02, 0x6b, 0x72, 0x43, 0x69,
	0x55, 0xcf, 0x8b, 0x77, 0xef, 0x8e, 0x25, 0x47, 0x20, 0x09, 0x33, 0xc7, 0x41, 0xac, 0x29, 0x79,
	0x26, 0x41, 0x50, 0x13, 0xaa, 0xde, 0x0d, 0x61, 0x97, 0xde, 0x04, 0x07, 0x5a, 0x21, 0x47, 0x6f,
	0x61, 0xd4, 0x87, 0x7a, 0x4c, 0xf1, 0x7f, 0x98, 0x52, 0x3c, 0x1d, 0x85, 0x84, 0x33, 0xad, 0xd8,
	0x50, 0x5a, 0xf5, 0xb3, 0x63, 0x63, 0xd7, 0xa8, 0x86, 0x75, 0x43, 0x98, 0x68, 0xcb, 0x9c, 0x5e,
	0x88, 0xd1, 0x5f, 0x00, 0xe9, 0x1c, 0xee, 0x6d, 0x8c, 0xb5, 0x52, 0x43, 0x6e, 0xd5, 0xcf, 0x1a,
	0x06, 0x11, 0x93, 0x67, 0xf3, 0x1a, 0xe9, 0xbc, 0x46, 0x7f, 0xd3, 0x97, 0x79, 0xe5, 0x94, 0xcd,
	0x37, 0x45, 0x38, 0xe8, 0x85, 0x53, 0xb2, 0x22, 0xd3, 0xa5, 0x17, 0x88, 0x20, 0xd0, 0x11, 0x94,
	0x38, 0xe1, 0xc1, 0xf3, 0x0c, 0x52, 0x28, 0x19, 0x35, 0x88, 0xc2, 0x99, 0x2b, 0xf8, 0x7c, 0x12,
	0x5b, 0x18, 0x19, 0x70, 0xe0, 0x47, 0x41, 0x80, 0x7d, 0x4e, 0xa2, 0x30, 0xed, 0xcc, 0x87, 0xf2,
	0x92, 0x44, 0x36, 0xd4, 0xa6, 0xd1, 0xab, 0x90, 0x79, 0x8b, 0x38, 0xc0, 0x34, 0xcb, 0xe5, 0xb7,
	0xe7, 0xb9, 0x24, 0x6b, 0x37, 0x5c, 0xb2, 0xc0, 0x43, 0xb1, 0xf6, 0xbf, 0x97, 0x98, 0xde, 0x5a,
	0xb3, 0x19, 0xc5, 0x33, 0x8f, 0x47, 0xd4, 0xc9, 0x1b, 0xa0, 0x4b, 0x00, 0x6f, 0x43, 0x69, 0xa5,
	0x6f, 0xb0, 0xcb, 0xe9, 0x13, 0xb7, 0x29, 0xa6, 0x64, 0xe5, 0x71, 0xb2, 0xc2, 0xda, 0xde, 0x97,
	0xba, 0xb5, 0x37, 0x1a, 0x27, 0xa7, 0x47, 0xbf, 0x43, 0x69, 0x29, 0xb6, 0x5f, 0xfe, 0x9a, 0xed,
	0xa7, 0x9a, 0xe7, 0x77, 0x56, 0xd9, 0x7d, 0x67, 0x27, 0x50, 0x8b, 0x31, 0xf5, 0x71, 0xc8, 0x49,
	0x80, 0x99, 0x56, 0x6d, 0x28, 0xad, 0x4a, 0xd6, 0x95, 0x27, 0x90, 0x05, 0xe5, 0xec, 0x43, 0xd0,
	0xa0, 0x51, 0x68, 0xd5, 0xce, 0x7e, 0xde, 0xfd, 0x94, 0xdc, 0xb7, 0x91, 0xd9, 0x3c, 0xe9, 0x9a,
	0x6f, 0x15, 0xd8, 0x17, 0xf4, 0x30, 0xdd, 0xe6, 0x77, 0x3f, 0x9c, 0x13, 0xa8, 0x4d, 0x31, 0xf3,
	0x29, 0x89, 0x13, 0x4c, 0x1c, 0xce, 0x53, 0x6f, 0x9e, 0x48, 0xde, 0x15, 0xe0, 0x15, 0x0e, 0xc4,
	0x2d, 0x94, 0x9e, 0xde, 0x25, 0x20, 0xd4, 0x86, 0x1a, 0x5b, 0x4e, 0x58, 0x6a, 0xcb, 0xb4, 0x3d,
	0x91, 0x45, 0xf3, 0x33, 0x59, 0x64, 0xc3, 0x3a, 0x79, 0x19, 0xfa, 0x03, 0xf6, 0xc4, 0xdf, 0x58,
	0xb2, 0xd7, 0xc4, 0xe0, 0x97, 0xdd, 0x06, 0x2f, 0xbe, 0x34, 0x27, 0x13, 0x9d, 0xfe, 0x09, 0xd5,
	0xcd, 0xca, 0xd1, 0x01, 0xd4, 0x46, 0xf6, 0xb0, 0xe3, 0x8e, 0x47, 0x76, 0xcf, 0x1d, 0xaa, 0x12,
	0xaa, 0x42, 0xe9, 0x62, 0x30, 0xb2, 0x5d, 0x55, 0x4e, 0xca, 0xf3, 0x7f, 0xdd, 0xce, 0x50, 0x55,
	0xd0, 0x3e, 0x54, 0xda, 0x23, 0xc7, 0x72, 0x7b, 0x03, 0x5b, 0x2d, 0x9c, 0x76, 0x01, 0xb5, 0xc5,
	0xc4, 0x13, 0xbc, 0xbd, 0x63, 0xf4, 0x03, 0x54, 0x53, 0x2b, 0xab, 0xdb, 0x55, 0x25, 0x54, 0x86,
	0x82, 0x75, 0xd5, 0x55, 0xe5, 0xa4, 0x18, 0x8e, 0xfa, 0xaa, 0x92, 0x14, 0x7d, 0xeb, 0x1f, 0xb5,
	0x20, 0x8a, 0x9e, 0xad, 0x16, 0x4f, 0xaf, 0xb7, 0x46, 0xdb, 0x13, 0xde, 0x1a, 0xb5, 0x3b, 0x8e,
	0x2a, 0xa1, 0x0a, 0x14, 0xed, 0x81, 0xdd, 0x51, 0x65, 0x54, 0x07, 0x68, 0x77, 0x9c, 0xde, 0x95,
	0xe5, 0xf6, 0xae, 0x3a, 0xaa, 0x82, 0x7e, 0x82, 0x1f, 0xed, 0x81, 0x3d, 0xb6, 0x3b, 0x5d, 0x81,
	0x8c, 0x73, 0x64, 0xe1, 0xfc, 0xd7, 0xbb, 0x0f, 0xba, 0x74, 0xb7, 0xd6, 0xe5, 0xfb, 0xb5, 0x2e,
	0x3f, 0xac, 0x75, 0xf9, 0xfd, 0x5a, 0x97, 0x5f, 0x3f, 0xea, 0xd2, 0xfd, 0xa3, 0x2e, 0x3d, 0x3c,
	0xea, 0xd2, 0x75, 0x39, 0x4b, 0xea, 0x53, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x5d, 0x7c, 0xe0,
	0x21, 0x06, 0x00, 0x00,
}

func (m *ChartMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.MetricType))
	i--
	dAtA[i] = 0x28
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.PreferredUnits))
	i--
	dAtA[i] = 0x20
	i -= len(m.AxisLabel)
	copy(dAtA[i:], m.AxisLabel)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Help)
	copy(dAtA[i:], m.Help)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Help)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndividualChart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualChart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndividualChart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChartCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	i--
	if m.Percentiles {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	i -= len(m.AxisLabel)
	copy(dAtA[i:], m.AxisLabel)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i--
	dAtA[i] = 0x42
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.Units))
	i--
	dAtA[i] = 0x38
	if m.Derivative == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("derivative")
	} else {
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Derivative))
		i--
		dAtA[i] = 0x30
	}
	if m.Aggregator == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("aggregator")
	} else {
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Aggregator))
		i--
		dAtA[i] = 0x28
	}
	if m.Downsampler == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("downsampler")
	} else {
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Downsampler))
		i--
		dAtA[i] = 0x20
	}
	i -= len(m.CollectionTitle)
	copy(dAtA[i:], m.CollectionTitle)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.CollectionTitle)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.LongTitle)
	copy(dAtA[i:], m.LongTitle)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.LongTitle)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChartSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartSection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartSection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Charts) > 0 {
		for iNdEx := len(m.Charts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Charts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChartCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Subsections) > 0 {
		for iNdEx := len(m.Subsections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subsections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChartCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.Level))
	i--
	dAtA[i] = 0x28
	i -= len(m.Description)
	copy(dAtA[i:], m.Description)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Description)))
	i--
	dAtA[i] = 0x22
	i -= len(m.CollectionTitle)
	copy(dAtA[i:], m.CollectionTitle)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.CollectionTitle)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.LongTitle)
	copy(dAtA[i:], m.LongTitle)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.LongTitle)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Title)
	copy(dAtA[i:], m.Title)
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Title)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintChartCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovChartCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChartMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.Help)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.AxisLabel)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 1 + sovChartCatalog(uint64(m.PreferredUnits))
	n += 1 + sovChartCatalog(uint64(m.MetricType))
	return n
}

func (m *IndividualChart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.LongTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.CollectionTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	if m.Downsampler != nil {
		n += 1 + sovChartCatalog(uint64(*m.Downsampler))
	}
	if m.Aggregator != nil {
		n += 1 + sovChartCatalog(uint64(*m.Aggregator))
	}
	if m.Derivative != nil {
		n += 1 + sovChartCatalog(uint64(*m.Derivative))
	}
	n += 1 + sovChartCatalog(uint64(m.Units))
	l = len(m.AxisLabel)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 2
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	return n
}

func (m *ChartSection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.LongTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.CollectionTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 1 + sovChartCatalog(uint64(m.Level))
	if len(m.Subsections) > 0 {
		for _, e := range m.Subsections {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	if len(m.Charts) > 0 {
		for _, e := range m.Charts {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	return n
}

func sovChartCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChartCatalog(x uint64) (n int) {
	return sovChartCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChartMetric) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Help = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredUnits", wireType)
			}
			m.PreferredUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreferredUnits |= AxisUnits(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricType", wireType)
			}
			m.MetricType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetricType |= _go.MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("help")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("preferredUnits")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualChart) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualChart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualChart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downsampler", wireType)
			}
			var v tspb.TimeSeriesQueryAggregator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= tspb.TimeSeriesQueryAggregator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Downsampler = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var v tspb.TimeSeriesQueryAggregator
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= tspb.TimeSeriesQueryAggregator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aggregator = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivative", wireType)
			}
			var v tspb.TimeSeriesQueryDerivative
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= tspb.TimeSeriesQueryDerivative(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Derivative = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			m.Units = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Units |= AxisUnits(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Percentiles = bool(v != 0)
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, ChartMetric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("longTitle")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("collectionTitle")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("downsampler")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("aggregator")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("derivative")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("units")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("percentiles")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartSection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartSection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartSection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsections = append(m.Subsections, &ChartSection{})
			if err := m.Subsections[len(m.Subsections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charts = append(m.Charts, &IndividualChart{})
			if err := m.Charts[len(m.Charts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("longTitle")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("collectionTitle")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("description")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("level")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChartCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChartCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChartCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChartCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChartCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChartCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChartCatalog = fmt.Errorf("proto: unexpected end of group")
)
