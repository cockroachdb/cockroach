// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ts/catalog/chart_catalog.proto

<<<<<<< HEAD
/*
	Package catalog is a generated protocol buffer package.

	It is generated from these files:
		ts/catalog/chart_catalog.proto

	It has these top-level messages:
		ChartMetric
		IndividualChart
		ChartSection
*/
=======
>>>>>>> admin: Add Chart Catalog infrastructure
package catalog

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
<<<<<<< HEAD
import cockroach_ts_tspb "github.com/cockroachdb/cockroach/pkg/ts/tspb"
import io_prometheus_client "github.com/prometheus/client_model/go"
=======
import _go "github.com/prometheus/client_model/go"
import tspb "github.com/cockroachdb/cockroach/pkg/ts/tspb"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
>>>>>>> admin: Add Chart Catalog infrastructure

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AxisUnits describes the Unit options available in the Admin UI. It is defined here
// as opposed to importing the value from the Admin UI because the existing pb doesn't
// include an UNSET value, which we use to check for defaults.
type AxisUnits int32

const (
	// UNSET_UNITS expresses that the metric's DisplayUnit wasn't explicitly set.
	AxisUnits_UNSET_UNITS AxisUnits = 0
	// COUNT expresses that the metric's measurement is a count.
	AxisUnits_COUNT AxisUnits = 1
	// BYTES expresses that the metric's measurement is in bytes.
	AxisUnits_BYTES AxisUnits = 2
	// DURATION expresses that the metric's measurement represents some unit of time.
	AxisUnits_DURATION AxisUnits = 3
)

var AxisUnits_name = map[int32]string{
	0: "UNSET_UNITS",
	1: "COUNT",
	2: "BYTES",
	3: "DURATION",
}
var AxisUnits_value = map[string]int32{
	"UNSET_UNITS": 0,
	"COUNT":       1,
	"BYTES":       2,
	"DURATION":    3,
}

func (x AxisUnits) Enum() *AxisUnits {
	p := new(AxisUnits)
	*p = x
	return p
}
func (x AxisUnits) String() string {
	return proto.EnumName(AxisUnits_name, int32(x))
}
func (x *AxisUnits) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AxisUnits_value, data, "AxisUnits")
	if err != nil {
		return err
	}
	*x = AxisUnits(value)
	return nil
}
<<<<<<< HEAD
func (AxisUnits) EnumDescriptor() ([]byte, []int) { return fileDescriptorChartCatalog, []int{0} }
=======
func (AxisUnits) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{0}
}
>>>>>>> admin: Add Chart Catalog infrastructure

// DescribeAggregator works as a proxy for cockroach.ts.tspb.TimeSeriesQueryAggregator
// which does not support an unset zero value.
type DescribeAggregator int32

const (
	// UNSET_AGG expresses that the Aggregator value wasn't explicitly set and should
	// use the default value for the respective metric type defined in chart_catalog.go.
	DescribeAggregator_UNSET_AGG DescribeAggregator = 0
	// AVG returns the average value of datapoints.
	DescribeAggregator_AVG DescribeAggregator = 1
	// SUM returns the sum value of datapoints.
	DescribeAggregator_SUM DescribeAggregator = 2
	// MAX returns the maximum value of datapoints.
	DescribeAggregator_MAX DescribeAggregator = 3
	// MIN returns the minimum value of datapoints.
	DescribeAggregator_MIN DescribeAggregator = 4
)

var DescribeAggregator_name = map[int32]string{
	0: "UNSET_AGG",
	1: "AVG",
	2: "SUM",
	3: "MAX",
	4: "MIN",
}
var DescribeAggregator_value = map[string]int32{
	"UNSET_AGG": 0,
	"AVG":       1,
	"SUM":       2,
	"MAX":       3,
	"MIN":       4,
}

func (x DescribeAggregator) Enum() *DescribeAggregator {
	p := new(DescribeAggregator)
	*p = x
	return p
}
func (x DescribeAggregator) String() string {
	return proto.EnumName(DescribeAggregator_name, int32(x))
}
func (x *DescribeAggregator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeAggregator_value, data, "DescribeAggregator")
	if err != nil {
		return err
	}
	*x = DescribeAggregator(value)
	return nil
}
func (DescribeAggregator) EnumDescriptor() ([]byte, []int) {
<<<<<<< HEAD
<<<<<<< HEAD
	return fileDescriptorChartCatalog, []int{1}
=======
	return fileDescriptor_chart_catalog_661c8918e8cad10c, []int{1}
>>>>>>> admin: Add Chart Catalog infrastructure
=======
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{1}
>>>>>>> in progress refactor
}

// DescribeDerivative works as a proxy for cockroach.ts.tspb.TimeSeriesQueryDerivative
// which has an ambiguous zero value; it's unclear if the value isn't set or if it
// is intentionally set to NONE.
type DescribeDerivative int32

const (
	// UNSET_DER expresses that the Derivative value wasn't explicitly set and should
	// use the default value for the respective metric type defined in chart_catalog.go.
	DescribeDerivative_UNSET_DER DescribeDerivative = 0
	// NONE does not apply a derivative function.
	DescribeDerivative_NONE DescribeDerivative = 1
	// DERIVATIVE returns the first-order derivative of values in the time series.
	DescribeDerivative_DERIVATIVE DescribeDerivative = 2
	// NON_NEGATIVE_DERIVATIVE returns only non-negative values of the first-order
	// derivative; negative values are returned as zero. This should be used for
	// counters that monotonically increase, but might wrap or reset.
	DescribeDerivative_NON_NEGATIVE_DERIVATIVE DescribeDerivative = 3
)

var DescribeDerivative_name = map[int32]string{
	0: "UNSET_DER",
	1: "NONE",
	2: "DERIVATIVE",
	3: "NON_NEGATIVE_DERIVATIVE",
}
var DescribeDerivative_value = map[string]int32{
	"UNSET_DER":               0,
	"NONE":                    1,
	"DERIVATIVE":              2,
	"NON_NEGATIVE_DERIVATIVE": 3,
}

func (x DescribeDerivative) Enum() *DescribeDerivative {
	p := new(DescribeDerivative)
	*p = x
	return p
}
func (x DescribeDerivative) String() string {
	return proto.EnumName(DescribeDerivative_name, int32(x))
}
func (x *DescribeDerivative) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescribeDerivative_value, data, "DescribeDerivative")
	if err != nil {
		return err
	}
	*x = DescribeDerivative(value)
	return nil
}
func (DescribeDerivative) EnumDescriptor() ([]byte, []int) {
<<<<<<< HEAD
<<<<<<< HEAD
	return fileDescriptorChartCatalog, []int{2}
=======
	return fileDescriptor_chart_catalog_661c8918e8cad10c, []int{2}
>>>>>>> admin: Add Chart Catalog infrastructure
=======
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{2}
>>>>>>> in progress refactor
}

// ChartMetric converts cockroach.util.metric.Metadata
// into a struct that's useful for generating Admin UI charts.
type ChartMetric struct {
	// name is the name of the metric.
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// help is the help text from the metric.
	Help string `protobuf:"bytes,2,req,name=help" json:"help"`
	// axisLabel is the label for the metric's y-axis.
	AxisLabel string `protobuf:"bytes,3,req,name=axisLabel" json:"axisLabel"`
	// preferredUnits describes the units the chart should be viewed with
	// e.g. BYTES for storage.
	PreferredUnits AxisUnits `protobuf:"varint,4,req,name=preferredUnits,enum=cockroach.ts.catalog.AxisUnits" json:"preferredUnits"`
	// metricType describes the type of metric this is; all metrics on a chart
	// should be of the same type to ensure the information displays behaves in
	// expected ways.
<<<<<<< HEAD
	MetricType io_prometheus_client.MetricType `protobuf:"varint,5,opt,name=metricType,enum=io.prometheus.client.MetricType" json:"metricType"`
}

func (m *ChartMetric) Reset()                    { *m = ChartMetric{} }
func (m *ChartMetric) String() string            { return proto.CompactTextString(m) }
func (*ChartMetric) ProtoMessage()               {}
func (*ChartMetric) Descriptor() ([]byte, []int) { return fileDescriptorChartCatalog, []int{0} }
=======
	MetricType           _go.MetricType `protobuf:"varint,5,opt,name=metricType,enum=io.prometheus.client.MetricType" json:"metricType"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ChartMetric) Reset()         { *m = ChartMetric{} }
func (m *ChartMetric) String() string { return proto.CompactTextString(m) }
func (*ChartMetric) ProtoMessage()    {}
func (*ChartMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{0}
}
func (m *ChartMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChartMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartMetric.Merge(dst, src)
}
func (m *ChartMetric) XXX_Size() int {
	return m.Size()
}
func (m *ChartMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartMetric.DiscardUnknown(m)
}

var xxx_messageInfo_ChartMetric proto.InternalMessageInfo
>>>>>>> admin: Add Chart Catalog infrastructure

// IndividualChart describes both the properties necessary to display
// AdminUI charts, as well as a key to find them (collectionName).
type IndividualChart struct {
	// title is the title of the chart.
	Title string `protobuf:"bytes,1,req,name=title" json:"title"`
	// longname displays the chart's organization within the catalog,
	// as well as its own name.
	LongTitle string `protobuf:"bytes,2,req,name=longTitle" json:"longTitle"`
	// collectionName uniquely identifies a chart.
	CollectionTitle string `protobuf:"bytes,3,req,name=collectionTitle" json:"collectionTitle"`
	// downsampler specifies the chart's downsampler function.
<<<<<<< HEAD
	Downsampler *cockroach_ts_tspb.TimeSeriesQueryAggregator `protobuf:"varint,4,req,name=downsampler,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"downsampler,omitempty"`
	// aggregator specifies the chart's aggregator function.
	Aggregator *cockroach_ts_tspb.TimeSeriesQueryAggregator `protobuf:"varint,5,req,name=aggregator,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"aggregator,omitempty"`
	// derivative specifies the chart's derivative function.
	Derivative *cockroach_ts_tspb.TimeSeriesQueryDerivative `protobuf:"varint,6,req,name=derivative,enum=cockroach.ts.tspb.TimeSeriesQueryDerivative" json:"derivative,omitempty"`
=======
	Downsampler *tspb.TimeSeriesQueryAggregator `protobuf:"varint,4,req,name=downsampler,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"downsampler,omitempty"`
	// aggregator specifies the chart's aggregator function.
	Aggregator *tspb.TimeSeriesQueryAggregator `protobuf:"varint,5,req,name=aggregator,enum=cockroach.ts.tspb.TimeSeriesQueryAggregator" json:"aggregator,omitempty"`
	// derivative specifies the chart's derivative function.
	Derivative *tspb.TimeSeriesQueryDerivative `protobuf:"varint,6,req,name=derivative,enum=cockroach.ts.tspb.TimeSeriesQueryDerivative" json:"derivative,omitempty"`
>>>>>>> admin: Add Chart Catalog infrastructure
	// units specifies the Admin UI units to display the chart with.
	Units AxisUnits `protobuf:"varint,7,req,name=units,enum=cockroach.ts.catalog.AxisUnits" json:"units"`
	// axisLabel defines the chart's y-axis label.
	AxisLabel string `protobuf:"bytes,8,req,name=axisLabel" json:"axisLabel"`
	// percentiles specifies whether the chart should have its metrics broken
	// out into percentiles; applies only to histograms.
	Percentiles bool `protobuf:"varint,9,req,name=percentiles" json:"percentiles"`
	// metrics specifies the metics the chart should display.
<<<<<<< HEAD
	Metrics []ChartMetric `protobuf:"bytes,10,rep,name=metrics" json:"metrics"`
}

func (m *IndividualChart) Reset()                    { *m = IndividualChart{} }
func (m *IndividualChart) String() string            { return proto.CompactTextString(m) }
func (*IndividualChart) ProtoMessage()               {}
func (*IndividualChart) Descriptor() ([]byte, []int) { return fileDescriptorChartCatalog, []int{1} }
=======
	Metrics              []ChartMetric `protobuf:"bytes,10,rep,name=metrics" json:"metrics"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *IndividualChart) Reset()         { *m = IndividualChart{} }
func (m *IndividualChart) String() string { return proto.CompactTextString(m) }
func (*IndividualChart) ProtoMessage()    {}
func (*IndividualChart) Descriptor() ([]byte, []int) {
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{1}
}
func (m *IndividualChart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndividualChart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IndividualChart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndividualChart.Merge(dst, src)
}
func (m *IndividualChart) XXX_Size() int {
	return m.Size()
}
func (m *IndividualChart) XXX_DiscardUnknown() {
	xxx_messageInfo_IndividualChart.DiscardUnknown(m)
}

var xxx_messageInfo_IndividualChart proto.InternalMessageInfo
>>>>>>> admin: Add Chart Catalog infrastructure

// ChartSections organize charts into groups that contain slices or charts and
// other subsections.
type ChartSection struct {
	// title is the title of the section.
	Title string `protobuf:"bytes,1,req,name=title" json:"title"`
	// longname displays the section's organization within the catalog.
	LongTitle string `protobuf:"bytes,2,req,name=longTitle" json:"longTitle"`
	// collectionName uniquely identifies a section.
	CollectionTitle string `protobuf:"bytes,3,req,name=collectionTitle" json:"collectionTitle"`
	// description describes how to interpret the relationship of subsections
	// and charts. It's only planned use is in the catalog page for Level 0
	// sections.
	Description string `protobuf:"bytes,4,req,name=description" json:"description"`
	// level represents the section's depth in the catalog's organization.
	Level int32 `protobuf:"varint,5,req,name=level" json:"level"`
	// subsections are deeper levels of the chart's organization.
	Subsections []*ChartSection `protobuf:"bytes,6,rep,name=subsections" json:"subsections,omitempty"`
	// charts are the IndividualCharts that are grouped into this section.
<<<<<<< HEAD
	Charts []*IndividualChart `protobuf:"bytes,7,rep,name=charts" json:"charts,omitempty"`
}

func (m *ChartSection) Reset()                    { *m = ChartSection{} }
func (m *ChartSection) String() string            { return proto.CompactTextString(m) }
func (*ChartSection) ProtoMessage()               {}
func (*ChartSection) Descriptor() ([]byte, []int) { return fileDescriptorChartCatalog, []int{2} }
=======
	Charts               []*IndividualChart `protobuf:"bytes,7,rep,name=charts" json:"charts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ChartSection) Reset()         { *m = ChartSection{} }
func (m *ChartSection) String() string { return proto.CompactTextString(m) }
func (*ChartSection) ProtoMessage()    {}
func (*ChartSection) Descriptor() ([]byte, []int) {
	return fileDescriptor_chart_catalog_445c1a1faf29dcfc, []int{2}
}
func (m *ChartSection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartSection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ChartSection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartSection.Merge(dst, src)
}
func (m *ChartSection) XXX_Size() int {
	return m.Size()
}
func (m *ChartSection) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartSection.DiscardUnknown(m)
}

var xxx_messageInfo_ChartSection proto.InternalMessageInfo
>>>>>>> admin: Add Chart Catalog infrastructure

func init() {
	proto.RegisterType((*ChartMetric)(nil), "cockroach.ts.catalog.ChartMetric")
	proto.RegisterType((*IndividualChart)(nil), "cockroach.ts.catalog.IndividualChart")
	proto.RegisterType((*ChartSection)(nil), "cockroach.ts.catalog.ChartSection")
	proto.RegisterEnum("cockroach.ts.catalog.AxisUnits", AxisUnits_name, AxisUnits_value)
	proto.RegisterEnum("cockroach.ts.catalog.DescribeAggregator", DescribeAggregator_name, DescribeAggregator_value)
	proto.RegisterEnum("cockroach.ts.catalog.DescribeDerivative", DescribeDerivative_name, DescribeDerivative_value)
}
func (m *ChartMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Help)))
	i += copy(dAtA[i:], m.Help)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i += copy(dAtA[i:], m.AxisLabel)
	dAtA[i] = 0x20
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.PreferredUnits))
	dAtA[i] = 0x28
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.MetricType))
	return i, nil
}

func (m *IndividualChart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndividualChart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x12
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.LongTitle)))
	i += copy(dAtA[i:], m.LongTitle)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.CollectionTitle)))
	i += copy(dAtA[i:], m.CollectionTitle)
	if m.Downsampler == nil {
<<<<<<< HEAD
		return 0, proto.NewRequiredNotSetError("downsampler")
=======
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("downsampler")
>>>>>>> admin: Add Chart Catalog infrastructure
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Downsampler))
	}
	if m.Aggregator == nil {
<<<<<<< HEAD
		return 0, proto.NewRequiredNotSetError("aggregator")
=======
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("aggregator")
>>>>>>> admin: Add Chart Catalog infrastructure
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Aggregator))
	}
	if m.Derivative == nil {
<<<<<<< HEAD
		return 0, proto.NewRequiredNotSetError("derivative")
=======
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("derivative")
>>>>>>> admin: Add Chart Catalog infrastructure
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintChartCatalog(dAtA, i, uint64(*m.Derivative))
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.Units))
	dAtA[i] = 0x42
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.AxisLabel)))
	i += copy(dAtA[i:], m.AxisLabel)
	dAtA[i] = 0x48
	i++
	if m.Percentiles {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			dAtA[i] = 0x52
			i++
			i = encodeVarintChartCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChartSection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartSection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Title)))
	i += copy(dAtA[i:], m.Title)
	dAtA[i] = 0x12
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.LongTitle)))
	i += copy(dAtA[i:], m.LongTitle)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.CollectionTitle)))
	i += copy(dAtA[i:], m.CollectionTitle)
	dAtA[i] = 0x22
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(len(m.Description)))
	i += copy(dAtA[i:], m.Description)
	dAtA[i] = 0x28
	i++
	i = encodeVarintChartCatalog(dAtA, i, uint64(m.Level))
	if len(m.Subsections) > 0 {
		for _, msg := range m.Subsections {
			dAtA[i] = 0x32
			i++
			i = encodeVarintChartCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Charts) > 0 {
		for _, msg := range m.Charts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintChartCatalog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintChartCatalog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ChartMetric) Size() (n int) {
<<<<<<< HEAD
=======
	if m == nil {
		return 0
	}
>>>>>>> admin: Add Chart Catalog infrastructure
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.Help)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.AxisLabel)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 1 + sovChartCatalog(uint64(m.PreferredUnits))
	n += 1 + sovChartCatalog(uint64(m.MetricType))
	return n
}

func (m *IndividualChart) Size() (n int) {
<<<<<<< HEAD
=======
	if m == nil {
		return 0
	}
>>>>>>> admin: Add Chart Catalog infrastructure
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.LongTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.CollectionTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	if m.Downsampler != nil {
		n += 1 + sovChartCatalog(uint64(*m.Downsampler))
	}
	if m.Aggregator != nil {
		n += 1 + sovChartCatalog(uint64(*m.Aggregator))
	}
	if m.Derivative != nil {
		n += 1 + sovChartCatalog(uint64(*m.Derivative))
	}
	n += 1 + sovChartCatalog(uint64(m.Units))
	l = len(m.AxisLabel)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 2
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	return n
}

func (m *ChartSection) Size() (n int) {
<<<<<<< HEAD
=======
	if m == nil {
		return 0
	}
>>>>>>> admin: Add Chart Catalog infrastructure
	var l int
	_ = l
	l = len(m.Title)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.LongTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.CollectionTitle)
	n += 1 + l + sovChartCatalog(uint64(l))
	l = len(m.Description)
	n += 1 + l + sovChartCatalog(uint64(l))
	n += 1 + sovChartCatalog(uint64(m.Level))
	if len(m.Subsections) > 0 {
		for _, e := range m.Subsections {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	if len(m.Charts) > 0 {
		for _, e := range m.Charts {
			l = e.Size()
			n += 1 + l + sovChartCatalog(uint64(l))
		}
	}
	return n
}

func sovChartCatalog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozChartCatalog(x uint64) (n int) {
	return sovChartCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChartMetric) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Help", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Help = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredUnits", wireType)
			}
			m.PreferredUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreferredUnits |= (AxisUnits(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricType", wireType)
			}
			m.MetricType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
<<<<<<< HEAD
				m.MetricType |= (io_prometheus_client.MetricType(b) & 0x7F) << shift
=======
				m.MetricType |= (_go.MetricType(b) & 0x7F) << shift
>>>>>>> admin: Add Chart Catalog infrastructure
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
<<<<<<< HEAD
		return proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("help")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("preferredUnits")
=======
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("help")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("preferredUnits")
>>>>>>> admin: Add Chart Catalog infrastructure
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndividualChart) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndividualChart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndividualChart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Downsampler", wireType)
			}
<<<<<<< HEAD
			var v cockroach_ts_tspb.TimeSeriesQueryAggregator
=======
			var v tspb.TimeSeriesQueryAggregator
>>>>>>> admin: Add Chart Catalog infrastructure
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
<<<<<<< HEAD
				v |= (cockroach_ts_tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
=======
				v |= (tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
>>>>>>> admin: Add Chart Catalog infrastructure
				if b < 0x80 {
					break
				}
			}
			m.Downsampler = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
<<<<<<< HEAD
			var v cockroach_ts_tspb.TimeSeriesQueryAggregator
=======
			var v tspb.TimeSeriesQueryAggregator
>>>>>>> admin: Add Chart Catalog infrastructure
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
<<<<<<< HEAD
				v |= (cockroach_ts_tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
=======
				v |= (tspb.TimeSeriesQueryAggregator(b) & 0x7F) << shift
>>>>>>> admin: Add Chart Catalog infrastructure
				if b < 0x80 {
					break
				}
			}
			m.Aggregator = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Derivative", wireType)
			}
<<<<<<< HEAD
			var v cockroach_ts_tspb.TimeSeriesQueryDerivative
=======
			var v tspb.TimeSeriesQueryDerivative
>>>>>>> admin: Add Chart Catalog infrastructure
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
<<<<<<< HEAD
				v |= (cockroach_ts_tspb.TimeSeriesQueryDerivative(b) & 0x7F) << shift
=======
				v |= (tspb.TimeSeriesQueryDerivative(b) & 0x7F) << shift
>>>>>>> admin: Add Chart Catalog infrastructure
				if b < 0x80 {
					break
				}
			}
			m.Derivative = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			m.Units = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Units |= (AxisUnits(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AxisLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AxisLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Percentiles = bool(v != 0)
			hasFields[0] |= uint64(0x00000100)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, ChartMetric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
<<<<<<< HEAD
		return proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("longname")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("collectionName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("downsampler")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return proto.NewRequiredNotSetError("aggregator")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return proto.NewRequiredNotSetError("derivative")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return proto.NewRequiredNotSetError("units")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return proto.NewRequiredNotSetError("percentiles")
=======
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("longTitle")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("collectionTitle")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("downsampler")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("aggregator")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("derivative")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("units")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("axisLabel")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("percentiles")
>>>>>>> admin: Add Chart Catalog infrastructure
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartSection) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartSection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartSection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsections = append(m.Subsections, &ChartSection{})
			if err := m.Subsections[len(m.Subsections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChartCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charts = append(m.Charts, &IndividualChart{})
			if err := m.Charts[len(m.Charts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChartCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChartCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
<<<<<<< HEAD
		return proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("longName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("collectionName")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return proto.NewRequiredNotSetError("description")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return proto.NewRequiredNotSetError("level")
=======
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("title")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("longTitle")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("collectionTitle")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("description")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("level")
>>>>>>> admin: Add Chart Catalog infrastructure
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChartCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChartCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChartCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthChartCatalog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowChartCatalog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipChartCatalog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthChartCatalog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChartCatalog   = fmt.Errorf("proto: integer overflow")
)

<<<<<<< HEAD
func init() { proto.RegisterFile("ts/catalog/chart_catalog.proto", fileDescriptorChartCatalog) }

var fileDescriptorChartCatalog = []byte{
=======
func init() {
	proto.RegisterFile("ts/catalog/chart_catalog.proto", fileDescriptor_chart_catalog_445c1a1faf29dcfc)
}

<<<<<<< HEAD
var fileDescriptor_chart_catalog_661c8918e8cad10c = []byte{
>>>>>>> admin: Add Chart Catalog infrastructure
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4d, 0x6b, 0x1a, 0x51,
	0x14, 0x75, 0x46, 0x8d, 0x7a, 0x4d, 0xcd, 0xf0, 0x08, 0x74, 0x48, 0xc1, 0x18, 0x21, 0x41, 0x42,
	0x18, 0x21, 0xdb, 0x52, 0xe8, 0x24, 0x5a, 0x11, 0xe2, 0x48, 0xc7, 0x31, 0xb4, 0xd9, 0xc8, 0x38,
	0xbe, 0xea, 0xa3, 0xf3, 0xc5, 0x7b, 0x4f, 0x9b, 0xfc, 0x8b, 0xfe, 0x99, 0xfe, 0x82, 0x6e, 0xb2,
	0xec, 0xb2, 0xab, 0xd2, 0xda, 0xbf, 0xd1, 0x45, 0x99, 0x37, 0x13, 0x9d, 0x04, 0x29, 0x49, 0x77,
	0xd7, 0x73, 0xee, 0x39, 0xbc, 0x7b, 0xee, 0x1d, 0xa1, 0xca, 0x59, 0xd3, 0xb1, 0xb9, 0xed, 0x06,
	0xd3, 0xa6, 0x33, 0xb3, 0x29, 0x1f, 0x25, 0xbf, 0xb4, 0x90, 0x06, 0x3c, 0x40, 0xbb, 0x4e, 0xe0,
	0x7c, 0xa4, 0x81, 0xed, 0xcc, 0x34, 0xce, 0xb4, 0x84, 0xdb, 0x53, 0x39, 0x6b, 0x72, 0x16, 0x8e,
	0x9b, 0x9c, 0x78, 0x98, 0x61, 0x4a, 0x30, 0x8b, 0xfb, 0xf7, 0x76, 0xa7, 0xc1, 0x34, 0x10, 0x65,
	0x33, 0xaa, 0x12, 0xf4, 0x30, 0xa4, 0x81, 0x87, 0xf9, 0x0c, 0xcf, 0x59, 0xd3, 0x71, 0x09, 0xf6,
	0xf9, 0xc8, 0x0b, 0x26, 0xd8, 0x6d, 0x7a, 0x98, 0x53, 0xe2, 0x24, 0xe2, 0xfa, 0x1f, 0x09, 0xca,
	0xe7, 0xd1, 0x23, 0x7a, 0x02, 0x46, 0x2a, 0xe4, 0x7c, 0xdb, 0xc3, 0xaa, 0x54, 0x93, 0x1b, 0xa5,
	0xb3, 0xdc, 0xed, 0x8f, 0xfd, 0x8c, 0x29, 0x90, 0x88, 0x99, 0x61, 0x37, 0x54, 0xe5, 0x34, 0x13,
	0x21, 0xa8, 0x0e, 0x25, 0xfb, 0x9a, 0xb0, 0x0b, 0x7b, 0x8c, 0x5d, 0x35, 0x9b, 0xa2, 0xd7, 0x30,
	0xea, 0x41, 0x25, 0xa4, 0xf8, 0x03, 0xa6, 0x14, 0x4f, 0x86, 0x3e, 0xe1, 0x4c, 0xcd, 0xd5, 0xe4,
	0x46, 0xe5, 0x74, 0x5f, 0xdb, 0x34, 0xad, 0xa6, 0x5f, 0x13, 0x26, 0xda, 0x12, 0xa7, 0x07, 0x62,
	0xf4, 0x06, 0x20, 0x9e, 0xc3, 0xba, 0x09, 0xb1, 0x9a, 0xaf, 0x49, 0x8d, 0xca, 0x69, 0x4d, 0x23,
	0x62, 0xf8, 0x64, 0x6a, 0x2d, 0x9e, 0x5a, 0xeb, 0xad, 0xfa, 0x12, 0xaf, 0x94, 0xb2, 0xfe, 0x25,
	0x07, 0x3b, 0x5d, 0x7f, 0x42, 0x16, 0x64, 0x32, 0xb7, 0x5d, 0x11, 0x04, 0xda, 0x83, 0x3c, 0x27,
	0xdc, 0xbd, 0x9f, 0x41, 0x0c, 0xa1, 0x1a, 0x14, 0xdd, 0xc0, 0x9f, 0x8a, 0x88, 0xd2, 0x41, 0xac,
	0x50, 0x74, 0x02, 0x15, 0x27, 0x70, 0x5d, 0xec, 0x70, 0x12, 0xf8, 0x46, 0xd4, 0x97, 0x4e, 0xe4,
	0x01, 0x87, 0x0c, 0x28, 0x4f, 0x82, 0x4f, 0x3e, 0xb3, 0xbd, 0xd0, 0xc5, 0x34, 0xc9, 0xe4, 0xe4,
	0x7e, 0x26, 0xd1, 0xd6, 0x35, 0x8b, 0x78, 0x78, 0x20, 0xb6, 0xfe, 0x76, 0x8e, 0xe9, 0x8d, 0x3e,
	0x9d, 0x52, 0x3c, 0xb5, 0x79, 0x40, 0xcd, 0xb4, 0x01, 0xba, 0x00, 0xb0, 0x57, 0x94, 0x9a, 0xff,
	0x0f, 0xbb, 0x94, 0x3e, 0x72, 0x9b, 0x60, 0x4a, 0x16, 0x36, 0x27, 0x0b, 0xac, 0x6e, 0x3d, 0xd6,
	0xad, 0xb5, 0xd2, 0x98, 0x29, 0x3d, 0x7a, 0x09, 0xf9, 0xb9, 0xd8, 0x7c, 0xe1, 0x29, 0x9b, 0x8f,
	0x35, 0xf7, 0x6f, 0xac, 0xb8, 0xf9, 0xc6, 0x8e, 0xa0, 0x1c, 0x62, 0xea, 0x60, 0x9f, 0x13, 0x17,
	0x33, 0xb5, 0x54, 0x93, 0x1b, 0xc5, 0xa4, 0x2b, 0x4d, 0x20, 0x1d, 0x0a, 0xc9, 0x47, 0xa0, 0x42,
	0x2d, 0xdb, 0x28, 0x9f, 0x1e, 0x6c, 0x7e, 0x4a, 0xea, 0xbb, 0x48, 0x6c, 0xee, 0x74, 0xf5, 0xaf,
	0x32, 0x6c, 0x0b, 0x7a, 0x10, 0x2f, 0xf3, 0x31, 0x47, 0x63, 0x6c, 0x3c, 0x1a, 0xe3, 0xe9, 0x47,
	0x73, 0x04, 0xe5, 0x09, 0x66, 0x0e, 0x25, 0x61, 0x04, 0x89, 0xa3, 0xb9, 0x6b, 0x4d, 0x13, 0xd1,
	0x9b, 0x5c, 0xbc, 0xc0, 0xae, 0xb8, 0x83, 0xfc, 0xdd, 0x9b, 0x04, 0x84, 0x5a, 0x50, 0x66, 0xf3,
	0x31, 0x8b, 0x5d, 0x99, 0xba, 0x25, 0x72, 0xa8, 0xff, 0x23, 0x87, 0x64, 0x50, 0x33, 0x2d, 0x43,
	0xaf, 0x60, 0x4b, 0xfc, 0x83, 0x45, 0x3b, 0x8d, 0x0c, 0x0e, 0x37, 0x1b, 0x3c, 0xf8, 0xc2, 0xcc,
	0x44, 0x74, 0xfc, 0x1a, 0x4a, 0xab, 0x75, 0xa3, 0x1d, 0x28, 0x0f, 0x8d, 0x41, 0xdb, 0x1a, 0x0d,
	0x8d, 0xae, 0x35, 0x50, 0x32, 0xa8, 0x04, 0xf9, 0xf3, 0xfe, 0xd0, 0xb0, 0x14, 0x29, 0x2a, 0xcf,
	0xde, 0x5b, 0xed, 0x81, 0x22, 0xa3, 0x6d, 0x28, 0xb6, 0x86, 0xa6, 0x6e, 0x75, 0xfb, 0x86, 0x92,
	0x3d, 0xee, 0x00, 0x6a, 0x89, 0x89, 0xc7, 0x78, 0x7d, 0xc3, 0xe8, 0x19, 0x94, 0x62, 0x2b, 0xbd,
	0xd3, 0x51, 0x32, 0xa8, 0x00, 0x59, 0xfd, 0xb2, 0xa3, 0x48, 0x51, 0x31, 0x18, 0xf6, 0x14, 0x39,
	0x2a, 0x7a, 0xfa, 0x3b, 0x25, 0x2b, 0x8a, 0xae, 0xa1, 0xe4, 0x8e, 0xaf, 0xd6, 0x46, 0xeb, 0xf3,
	0x5d, 0x1b, 0xb5, 0xda, 0xa6, 0x92, 0x41, 0x45, 0xc8, 0x19, 0x7d, 0xa3, 0xad, 0x48, 0xa8, 0x02,
	0xd0, 0x6a, 0x9b, 0xdd, 0x4b, 0xdd, 0xea, 0x5e, 0xb6, 0x15, 0x19, 0xbd, 0x80, 0xe7, 0x46, 0xdf,
	0x18, 0x19, 0xed, 0x8e, 0x40, 0x46, 0x29, 0x32, 0x7b, 0x76, 0x70, 0xfb, 0xab, 0x9a, 0xb9, 0x5d,
	0x56, 0xa5, 0x6f, 0xcb, 0xaa, 0xf4, 0x7d, 0x59, 0x95, 0x7e, 0x2e, 0xab, 0xd2, 0xe7, 0xdf, 0xd5,
	0xcc, 0x55, 0x21, 0x49, 0xe8, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x0d, 0xc1, 0x60, 0x14,
	0x06, 0x00, 0x00,
=======
var fileDescriptor_chart_catalog_445c1a1faf29dcfc = []byte{
	// 717 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xc1, 0x6e, 0xda, 0x4a,
	0x14, 0xc5, 0x06, 0x02, 0x5c, 0xf2, 0x88, 0x35, 0x8a, 0xf4, 0xac, 0x3c, 0x89, 0x10, 0xa4, 0x44,
	0x28, 0x7a, 0x32, 0x52, 0xb6, 0x55, 0xa5, 0x3a, 0x81, 0x22, 0xa4, 0x60, 0x54, 0x63, 0xa2, 0x36,
	0x1b, 0x64, 0xcc, 0x14, 0x46, 0x35, 0xb6, 0x35, 0x33, 0xd0, 0xe4, 0x2f, 0xfa, 0x3b, 0xfd, 0x82,
	0x66, 0xd9, 0x65, 0x57, 0x55, 0x4b, 0x7f, 0xa3, 0x8b, 0xca, 0xe3, 0x09, 0x38, 0x11, 0xaa, 0xda,
	0x2e, 0xba, 0xbb, 0x9c, 0x73, 0xcf, 0xd1, 0xdc, 0x73, 0xaf, 0x81, 0x2a, 0x67, 0x4d, 0xcf, 0xe5,
	0xae, 0x1f, 0x4e, 0x9b, 0xde, 0xcc, 0xa5, 0x7c, 0x24, 0x7f, 0x19, 0x11, 0x0d, 0x79, 0x88, 0xf6,
	0xbd, 0xd0, 0x7b, 0x43, 0x43, 0xd7, 0x9b, 0x19, 0x9c, 0x19, 0x92, 0x3b, 0xd0, 0x39, 0x6b, 0x72,
	0x16, 0x8d, 0x9b, 0x9c, 0xcc, 0x31, 0xc3, 0x94, 0x60, 0x96, 0xf4, 0x1f, 0xec, 0x4f, 0xc3, 0x69,
	0x28, 0xca, 0x66, 0x5c, 0x49, 0xf4, 0x38, 0xa2, 0xe1, 0x1c, 0xf3, 0x19, 0x5e, 0xb0, 0xa6, 0xe7,
	0x13, 0x1c, 0xf0, 0xd1, 0x3c, 0x9c, 0x60, 0xbf, 0x39, 0xc7, 0x9c, 0x12, 0x4f, 0x8a, 0xeb, 0xdf,
	0x15, 0x28, 0x5f, 0xc4, 0x8f, 0xe8, 0x09, 0x18, 0xe9, 0x90, 0x0b, 0xdc, 0x39, 0xd6, 0x95, 0x9a,
	0xda, 0x28, 0x9d, 0xe7, 0xee, 0x3e, 0x1f, 0x66, 0x6c, 0x81, 0xc4, 0xcc, 0x0c, 0xfb, 0x91, 0xae,
	0xa6, 0x99, 0x18, 0x41, 0x75, 0x28, 0xb9, 0x37, 0x84, 0x5d, 0xba, 0x63, 0xec, 0xeb, 0xd9, 0x14,
	0xbd, 0x81, 0x51, 0x0f, 0x2a, 0x11, 0xc5, 0xaf, 0x31, 0xa5, 0x78, 0x32, 0x0c, 0x08, 0x67, 0x7a,
	0xae, 0xa6, 0x36, 0x2a, 0x67, 0x87, 0xc6, 0xb6, 0x69, 0x0d, 0xf3, 0x86, 0x30, 0xd1, 0x26, 0x9d,
	0x1e, 0x89, 0xd1, 0x73, 0x80, 0x64, 0x0e, 0xe7, 0x36, 0xc2, 0x7a, 0xbe, 0xa6, 0x34, 0x2a, 0x67,
	0x35, 0x83, 0x88, 0xe1, 0xe5, 0xd4, 0x46, 0x32, 0xb5, 0xd1, 0x5b, 0xf7, 0x49, 0xaf, 0x94, 0xb2,
	0xfe, 0x3e, 0x07, 0x7b, 0xdd, 0x60, 0x42, 0x96, 0x64, 0xb2, 0x70, 0x7d, 0x11, 0x04, 0x3a, 0x80,
	0x3c, 0x27, 0xdc, 0x7f, 0x98, 0x41, 0x02, 0xc5, 0xa3, 0xfa, 0x61, 0x30, 0x75, 0x04, 0x9f, 0x4e,
	0x62, 0x03, 0x23, 0x03, 0xf6, 0xbc, 0xd0, 0xf7, 0xb1, 0xc7, 0x49, 0x18, 0x24, 0x9d, 0xe9, 0x50,
	0x1e, 0x93, 0xc8, 0x82, 0xf2, 0x24, 0x7c, 0x1b, 0x30, 0x77, 0x1e, 0xf9, 0x98, 0xca, 0x5c, 0xfe,
	0x7f, 0x98, 0x4b, 0xbc, 0x79, 0xc3, 0x21, 0x73, 0x3c, 0x10, 0x9b, 0x7f, 0xb1, 0xc0, 0xf4, 0xd6,
	0x9c, 0x4e, 0x29, 0x9e, 0xba, 0x3c, 0xa4, 0x76, 0xda, 0x00, 0x5d, 0x02, 0xb8, 0x6b, 0x4a, 0xcf,
	0xff, 0x81, 0x5d, 0x4a, 0x1f, 0xbb, 0x4d, 0x30, 0x25, 0x4b, 0x97, 0x93, 0x25, 0xd6, 0x77, 0x7e,
	0xd5, 0xad, 0xb5, 0xd6, 0xd8, 0x29, 0x3d, 0x7a, 0x02, 0xf9, 0x85, 0xd8, 0x7e, 0xe1, 0x77, 0xb6,
	0x9f, 0x68, 0x1e, 0xde, 0x59, 0x71, 0xfb, 0x9d, 0x9d, 0x40, 0x39, 0xc2, 0xd4, 0xc3, 0x01, 0x27,
	0x3e, 0x66, 0x7a, 0xa9, 0xa6, 0x36, 0x8a, 0xb2, 0x2b, 0x4d, 0x20, 0x13, 0x0a, 0xf2, 0x43, 0xd0,
	0xa1, 0x96, 0x6d, 0x94, 0xcf, 0x8e, 0xb6, 0x3f, 0x25, 0xf5, 0x6d, 0x48, 0x9b, 0x7b, 0x5d, 0xfd,
	0x83, 0x0a, 0xbb, 0x82, 0x1e, 0x24, 0xdb, 0xfc, 0xeb, 0x87, 0x73, 0x02, 0xe5, 0x09, 0x66, 0x1e,
	0x25, 0x51, 0x8c, 0x89, 0xc3, 0xb9, 0xef, 0x4d, 0x13, 0xf1, 0xbb, 0x7c, 0xbc, 0xc4, 0xbe, 0xb8,
	0x85, 0xfc, 0xfd, 0xbb, 0x04, 0x84, 0x5a, 0x50, 0x66, 0x8b, 0x31, 0x4b, 0x6c, 0x99, 0xbe, 0x23,
	0xb2, 0xa8, 0xff, 0x24, 0x0b, 0x39, 0xac, 0x9d, 0x96, 0xa1, 0xa7, 0xb0, 0x23, 0xfe, 0xc9, 0xe2,
	0xbd, 0xc6, 0x06, 0xc7, 0xdb, 0x0d, 0x1e, 0x7d, 0x69, 0xb6, 0x14, 0x9d, 0x3e, 0x83, 0xd2, 0x7a,
	0xe5, 0x68, 0x0f, 0xca, 0x43, 0x6b, 0xd0, 0x76, 0x46, 0x43, 0xab, 0xeb, 0x0c, 0xb4, 0x0c, 0x2a,
	0x41, 0xfe, 0xa2, 0x3f, 0xb4, 0x1c, 0x4d, 0x89, 0xcb, 0xf3, 0x57, 0x4e, 0x7b, 0xa0, 0xa9, 0x68,
	0x17, 0x8a, 0xad, 0xa1, 0x6d, 0x3a, 0xdd, 0xbe, 0xa5, 0x65, 0x4f, 0x3b, 0x80, 0x5a, 0x62, 0xe2,
	0x31, 0xde, 0xdc, 0x31, 0xfa, 0x07, 0x4a, 0x89, 0x95, 0xd9, 0xe9, 0x68, 0x19, 0x54, 0x80, 0xac,
	0x79, 0xd5, 0xd1, 0x94, 0xb8, 0x18, 0x0c, 0x7b, 0x9a, 0x1a, 0x17, 0x3d, 0xf3, 0xa5, 0x96, 0x15,
	0x45, 0xd7, 0xd2, 0x72, 0xa7, 0xd7, 0x1b, 0xa3, 0xcd, 0x09, 0x6f, 0x8c, 0x5a, 0x6d, 0x5b, 0xcb,
	0xa0, 0x22, 0xe4, 0xac, 0xbe, 0xd5, 0xd6, 0x14, 0x54, 0x01, 0x68, 0xb5, 0xed, 0xee, 0x95, 0xe9,
	0x74, 0xaf, 0xda, 0x9a, 0x8a, 0xfe, 0x83, 0x7f, 0xad, 0xbe, 0x35, 0xb2, 0xda, 0x1d, 0x81, 0x8c,
	0x52, 0x64, 0xf6, 0xfc, 0xe8, 0xee, 0x6b, 0x35, 0x73, 0xb7, 0xaa, 0x2a, 0x1f, 0x57, 0x55, 0xe5,
	0xd3, 0xaa, 0xaa, 0x7c, 0x59, 0x55, 0x95, 0x77, 0xdf, 0xaa, 0x99, 0xeb, 0x82, 0x4c, 0xe8, 0x47,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x6a, 0x3b, 0xea, 0x1c, 0x06, 0x00, 0x00,
>>>>>>> in progress refactor
}
