YACC := ../../../../../../bin/yacc

.PHONY: all
all: sql.go keywords.go reserved_keywords.go

sql.go: sql.y
	# Type checking sql.y
	$(YACC) -o /dev/null -p sql sql.y
	# Compiling sql.go
	$(eval TYPES := $(shell awk '/func.*sqlSymUnion/ {print $$(NF - 1)}' sql.y | \
	  sed -e 's/[]\/$$**.^|[]/\\&/g' | \
	  tr '\n' '|' | \
	  sed -E '$$s/.$$//'))
	@mv sql.y sql.y.tmp
	sed -E "s_(type|token) <($(TYPES))>_\1 <union> /* <\2> */_" sql.y.tmp > sql.y;
	$(YACC) -o sql.go -p sql sql.y
	@mv sql.y.tmp sql.y
	@echo '// Code generated by go yacc.' | \
	  cat - sql.go > sql.go.tmp && mv -f sql.go.tmp sql.go

reserved_keywords.go: sql.y reserved_keywords.awk
	awk -f reserved_keywords.awk < sql.y > reserved_keywords.go
	gofmt -s -w reserved_keywords.go

keywords.go: sql.y all_keywords.awk
	awk -f all_keywords.awk < sql.y > keywords.go
	gofmt -s -w keywords.go

# This target will print unreserved_keywords which are not actually
# used in the grammar.
.PHONY: unused_unreserved_keywords
unused_unreserved_keywords:
	@for kw in $$(awk -f unreserved_keywords.awk < sql.y); do \
	  if [ $$(grep -c $${kw} sql.y) -le 2 ]; then \
	    echo $${kw}; \
	  fi \
	done
