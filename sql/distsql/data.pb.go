// Code generated by protoc-gen-gogo.
// source: cockroach/sql/distsql/data.proto
// DO NOT EDIT!

package distsql

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_roachpb1 "github.com/cockroachdb/cockroach/roachpb"
import cockroach_roachpb2 "github.com/cockroachdb/cockroach/roachpb"
import cockroach_sql_sqlbase1 "github.com/cockroachdb/cockroach/sql/sqlbase"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type OutputRouterSpec_Type int32

const (
	// Each row is sent to all output streams (also used if there is a
	// single output stream).
	OutputRouterSpec_MIRROR OutputRouterSpec_Type = 0
	// Each row is sent to one stream, chosen by hashing certain columns of
	// the row. TODO(radu): an extra optional structure below for the hashing
	// details.
	OutputRouterSpec_BY_HASH OutputRouterSpec_Type = 1
	// Each row is sent to one stream, chosen according to preset boundaries
	// for the values of certain columns of the row. TODO(radu): an extra
	// optional structure below for the range details.
	OutputRouterSpec_BY_RANGE OutputRouterSpec_Type = 2
)

var OutputRouterSpec_Type_name = map[int32]string{
	0: "MIRROR",
	1: "BY_HASH",
	2: "BY_RANGE",
}
var OutputRouterSpec_Type_value = map[string]int32{
	"MIRROR":   0,
	"BY_HASH":  1,
	"BY_RANGE": 2,
}

func (x OutputRouterSpec_Type) Enum() *OutputRouterSpec_Type {
	p := new(OutputRouterSpec_Type)
	*p = x
	return p
}
func (x OutputRouterSpec_Type) String() string {
	return proto.EnumName(OutputRouterSpec_Type_name, int32(x))
}
func (x *OutputRouterSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OutputRouterSpec_Type_value, data, "OutputRouterSpec_Type")
	if err != nil {
		return err
	}
	*x = OutputRouterSpec_Type(value)
	return nil
}
func (OutputRouterSpec_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{5, 0} }

type DatumInfo_EncodingType int32

const (
	// Indicates that the datum is encoded using the order-preserving encoding
	// used for keys (ascending order).
	DatumInfo_ASCENDING_KEY_ENCODING DatumInfo_EncodingType = 0
	// Indicates that the datum is encoded using the order-preserving encoding
	// used for keys (descending order).
	DatumInfo_DESCENDING_KEY_ENCODING DatumInfo_EncodingType = 1
)

var DatumInfo_EncodingType_name = map[int32]string{
	0: "ASCENDING_KEY_ENCODING",
	1: "DESCENDING_KEY_ENCODING",
}
var DatumInfo_EncodingType_value = map[string]int32{
	"ASCENDING_KEY_ENCODING":  0,
	"DESCENDING_KEY_ENCODING": 1,
}

func (x DatumInfo_EncodingType) Enum() *DatumInfo_EncodingType {
	p := new(DatumInfo_EncodingType)
	*p = x
	return p
}
func (x DatumInfo_EncodingType) String() string {
	return proto.EnumName(DatumInfo_EncodingType_name, int32(x))
}
func (x *DatumInfo_EncodingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatumInfo_EncodingType_value, data, "DatumInfo_EncodingType")
	if err != nil {
		return err
	}
	*x = DatumInfo_EncodingType(value)
	return nil
}
func (DatumInfo_EncodingType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{9, 0} }

type Expression struct {
	// TODO(radu): TBD how this will be used
	Version string `protobuf:"bytes,1,opt,name=version" json:"version"`
	// SQL expressions are passed as a string, with ValArgs ($0, $1, ..) used for
	// "input" variables.
	Expr string `protobuf:"bytes,2,opt,name=expr" json:"expr"`
}

func (m *Expression) Reset()                    { *m = Expression{} }
func (m *Expression) String() string            { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()               {}
func (*Expression) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

type TableReaderSpan struct {
	// TODO(radu): the dist_sql APIs should be agnostic to how we map tables to
	// KVs. The span should be described as starting and ending lists of values
	// for a prefix of the index columns, along with inclusive/exclusive flags.
	Span cockroach_roachpb1.Span `protobuf:"bytes,1,opt,name=span" json:"span"`
}

func (m *TableReaderSpan) Reset()                    { *m = TableReaderSpan{} }
func (m *TableReaderSpan) String() string            { return proto.CompactTextString(m) }
func (*TableReaderSpan) ProtoMessage()               {}
func (*TableReaderSpan) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

// TableReaderSpec is the specification for a table reader. A table reader
// performs KV operations to retrieve rows for a table and outputs the desired
// columns of the rows that pass a filter expression.
type TableReaderSpec struct {
	Table cockroach_sql_sqlbase1.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
	// If 0, we use the primary index. If non-zero, we use the index_idx-th index,
	// i.e. table.indexes[index_idx-1]
	IndexIdx uint32            `protobuf:"varint,2,opt,name=index_idx,json=indexIdx" json:"index_idx"`
	Reverse  bool              `protobuf:"varint,3,opt,name=reverse" json:"reverse"`
	Spans    []TableReaderSpan `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	// The filter expression references the columns in the table (table.columns)
	// via $0, $1, etc. If a secondary index is used, the columns that are not
	// available as part of the index cannot be referenced.
	Filter Expression `protobuf:"bytes,5,opt,name=filter" json:"filter"`
	// The table reader will only produce values for these columns, referenced by
	// their indices in table.columns.
	OutputColumns []uint32 `protobuf:"varint,6,rep,packed,name=output_columns,json=outputColumns" json:"output_columns,omitempty"`
}

func (m *TableReaderSpec) Reset()                    { *m = TableReaderSpec{} }
func (m *TableReaderSpec) String() string            { return proto.CompactTextString(m) }
func (*TableReaderSpec) ProtoMessage()               {}
func (*TableReaderSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

type MailboxSpec struct {
	// If set, we are in a special "simple flow" mode. In this mode, we return
	// results directly as part of the RPC call that set up the flow. This saves
	// overhead (extra RPCs) compared to the normal mode where the RPC just sets
	// up the flow. In this mode there are no remote endpoints so this must be the
	// only mailbox in that flow.
	SimpleResponse bool `protobuf:"varint,1,opt,name=simple_response,json=simpleResponse" json:"simple_response"`
}

func (m *MailboxSpec) Reset()                    { *m = MailboxSpec{} }
func (m *MailboxSpec) String() string            { return proto.CompactTextString(m) }
func (*MailboxSpec) ProtoMessage()               {}
func (*MailboxSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

// StreamEndpointSpec describes one of the endpoints (input or output) of a physical
// stream.
type StreamEndpointSpec struct {
	// If set, both ends of the stream are part of the flow on this machine. There
	// will be a corresponding endpoint with the same local stream ID.
	LocalStreamID *int32 `protobuf:"varint,1,opt,name=local_stream_id,json=localStreamId" json:"local_stream_id,omitempty"`
	// If set, the stream crosses flows; the endpoint is a mailbox.
	Mailbox *MailboxSpec `protobuf:"bytes,2,opt,name=mailbox" json:"mailbox,omitempty"`
}

func (m *StreamEndpointSpec) Reset()                    { *m = StreamEndpointSpec{} }
func (m *StreamEndpointSpec) String() string            { return proto.CompactTextString(m) }
func (*StreamEndpointSpec) ProtoMessage()               {}
func (*StreamEndpointSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{4} }

// OutputRouterSpec is the specification for the output router of a processor;
// it decides how to send results to multiple output streams.
type OutputRouterSpec struct {
	Type    OutputRouterSpec_Type `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsql.OutputRouterSpec_Type" json:"type"`
	Streams []StreamEndpointSpec  `protobuf:"bytes,2,rep,name=streams" json:"streams"`
}

func (m *OutputRouterSpec) Reset()                    { *m = OutputRouterSpec{} }
func (m *OutputRouterSpec) String() string            { return proto.CompactTextString(m) }
func (*OutputRouterSpec) ProtoMessage()               {}
func (*OutputRouterSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5} }

type ProcessorCoreUnion struct {
	TableReader *TableReaderSpec `protobuf:"bytes,1,opt,name=tableReader" json:"tableReader,omitempty"`
}

func (m *ProcessorCoreUnion) Reset()                    { *m = ProcessorCoreUnion{} }
func (m *ProcessorCoreUnion) String() string            { return proto.CompactTextString(m) }
func (*ProcessorCoreUnion) ProtoMessage()               {}
func (*ProcessorCoreUnion) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{6} }

type ProcessorSpec struct {
	Core ProcessorCoreUnion `protobuf:"bytes,1,opt,name=core" json:"core"`
	// In most cases, there is one output.
	Output []OutputRouterSpec `protobuf:"bytes,2,rep,name=output" json:"output"`
}

func (m *ProcessorSpec) Reset()                    { *m = ProcessorSpec{} }
func (m *ProcessorSpec) String() string            { return proto.CompactTextString(m) }
func (*ProcessorSpec) ProtoMessage()               {}
func (*ProcessorSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{7} }

// FlowSpec describes a "flow" which is a subgraph of a distributed SQL
// computation consisting of processors and streams.
type FlowSpec struct {
	Processors []ProcessorSpec `protobuf:"bytes,1,rep,name=processors" json:"processors"`
}

func (m *FlowSpec) Reset()                    { *m = FlowSpec{} }
func (m *FlowSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowSpec) ProtoMessage()               {}
func (*FlowSpec) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{8} }

type DatumInfo struct {
	Encoding DatumInfo_EncodingType `protobuf:"varint,1,opt,name=encoding,enum=cockroach.sql.distsql.DatumInfo_EncodingType" json:"encoding"`
}

func (m *DatumInfo) Reset()                    { *m = DatumInfo{} }
func (m *DatumInfo) String() string            { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()               {}
func (*DatumInfo) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{9} }

// StreamHeader is a message that is sent once at the beginning of a stream.
type StreamHeader struct {
	// There is one DatumInfo for each element in a row.
	Info []DatumInfo `protobuf:"bytes,1,rep,name=info" json:"info"`
}

func (m *StreamHeader) Reset()                    { *m = StreamHeader{} }
func (m *StreamHeader) String() string            { return proto.CompactTextString(m) }
func (*StreamHeader) ProtoMessage()               {}
func (*StreamHeader) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{10} }

// StreamData is a message that can be sent multiple times as part of a stream.
type StreamData struct {
	// Encodes one or more data rows. Each datum is encoded according to the
	// corresponding DatumInfo.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
}

func (m *StreamData) Reset()                    { *m = StreamData{} }
func (m *StreamData) String() string            { return proto.CompactTextString(m) }
func (*StreamData) ProtoMessage()               {}
func (*StreamData) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{11} }

// StreamTrailer is a message that is sent once at the end of a stream.
type StreamTrailer struct {
	Error *cockroach_roachpb2.Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *StreamTrailer) Reset()                    { *m = StreamTrailer{} }
func (m *StreamTrailer) String() string            { return proto.CompactTextString(m) }
func (*StreamTrailer) ProtoMessage()               {}
func (*StreamTrailer) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{12} }

type StreamMessage struct {
	// Header is present in the first message.
	Header *StreamHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// Data is present in all messages except possibly the first and last.
	Data StreamData `protobuf:"bytes,2,opt,name=data" json:"data"`
	// Trailer is present in the last message.
	Trailer *StreamTrailer `protobuf:"bytes,3,opt,name=trailer" json:"trailer,omitempty"`
}

func (m *StreamMessage) Reset()                    { *m = StreamMessage{} }
func (m *StreamMessage) String() string            { return proto.CompactTextString(m) }
func (*StreamMessage) ProtoMessage()               {}
func (*StreamMessage) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{13} }

func init() {
	proto.RegisterType((*Expression)(nil), "cockroach.sql.distsql.Expression")
	proto.RegisterType((*TableReaderSpan)(nil), "cockroach.sql.distsql.TableReaderSpan")
	proto.RegisterType((*TableReaderSpec)(nil), "cockroach.sql.distsql.TableReaderSpec")
	proto.RegisterType((*MailboxSpec)(nil), "cockroach.sql.distsql.MailboxSpec")
	proto.RegisterType((*StreamEndpointSpec)(nil), "cockroach.sql.distsql.StreamEndpointSpec")
	proto.RegisterType((*OutputRouterSpec)(nil), "cockroach.sql.distsql.OutputRouterSpec")
	proto.RegisterType((*ProcessorCoreUnion)(nil), "cockroach.sql.distsql.ProcessorCoreUnion")
	proto.RegisterType((*ProcessorSpec)(nil), "cockroach.sql.distsql.ProcessorSpec")
	proto.RegisterType((*FlowSpec)(nil), "cockroach.sql.distsql.FlowSpec")
	proto.RegisterType((*DatumInfo)(nil), "cockroach.sql.distsql.DatumInfo")
	proto.RegisterType((*StreamHeader)(nil), "cockroach.sql.distsql.StreamHeader")
	proto.RegisterType((*StreamData)(nil), "cockroach.sql.distsql.StreamData")
	proto.RegisterType((*StreamTrailer)(nil), "cockroach.sql.distsql.StreamTrailer")
	proto.RegisterType((*StreamMessage)(nil), "cockroach.sql.distsql.StreamMessage")
	proto.RegisterEnum("cockroach.sql.distsql.OutputRouterSpec_Type", OutputRouterSpec_Type_name, OutputRouterSpec_Type_value)
	proto.RegisterEnum("cockroach.sql.distsql.DatumInfo_EncodingType", DatumInfo_EncodingType_name, DatumInfo_EncodingType_value)
}
func (m *Expression) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Expression) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(len(m.Version)))
	i += copy(data[i:], m.Version)
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(len(m.Expr)))
	i += copy(data[i:], m.Expr)
	return i, nil
}

func (m *TableReaderSpan) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableReaderSpan) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Span.Size()))
	n1, err := m.Span.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *TableReaderSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableReaderSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Table.Size()))
	n2, err := m.Table.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.IndexIdx))
	data[i] = 0x18
	i++
	if m.Reverse {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.Spans) > 0 {
		for _, msg := range m.Spans {
			data[i] = 0x22
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x2a
	i++
	i = encodeVarintData(data, i, uint64(m.Filter.Size()))
	n3, err := m.Filter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.OutputColumns) > 0 {
		data5 := make([]byte, len(m.OutputColumns)*10)
		var j4 int
		for _, num := range m.OutputColumns {
			for num >= 1<<7 {
				data5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			data5[j4] = uint8(num)
			j4++
		}
		data[i] = 0x32
		i++
		i = encodeVarintData(data, i, uint64(j4))
		i += copy(data[i:], data5[:j4])
	}
	return i, nil
}

func (m *MailboxSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MailboxSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	if m.SimpleResponse {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}

func (m *StreamEndpointSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamEndpointSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalStreamID != nil {
		data[i] = 0x8
		i++
		i = encodeVarintData(data, i, uint64(*m.LocalStreamID))
	}
	if m.Mailbox != nil {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(m.Mailbox.Size()))
		n6, err := m.Mailbox.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *OutputRouterSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OutputRouterSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.Type))
	if len(m.Streams) > 0 {
		for _, msg := range m.Streams {
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProcessorCoreUnion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessorCoreUnion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TableReader != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.TableReader.Size()))
		n7, err := m.TableReader.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ProcessorSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessorSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Core.Size()))
	n8, err := m.Core.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Output) > 0 {
		for _, msg := range m.Output {
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FlowSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Processors) > 0 {
		for _, msg := range m.Processors {
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DatumInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatumInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.Encoding))
	return i, nil
}

func (m *StreamHeader) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamHeader) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, msg := range m.Info {
			data[i] = 0xa
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StreamData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamData) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RawBytes != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.RawBytes)))
		i += copy(data[i:], m.RawBytes)
	}
	return i, nil
}

func (m *StreamTrailer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamTrailer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.Error.Size()))
		n9, err := m.Error.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *StreamMessage) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamMessage) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.Header.Size()))
		n10, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Data.Size()))
	n11, err := m.Data.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.Trailer != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(m.Trailer.Size()))
		n12, err := m.Trailer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func encodeFixed64Data(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Data(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Expression) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	n += 1 + l + sovData(uint64(l))
	l = len(m.Expr)
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *TableReaderSpan) Size() (n int) {
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *TableReaderSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.IndexIdx))
	n += 2
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	l = m.Filter.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.OutputColumns) > 0 {
		l = 0
		for _, e := range m.OutputColumns {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	return n
}

func (m *MailboxSpec) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}

func (m *StreamEndpointSpec) Size() (n int) {
	var l int
	_ = l
	if m.LocalStreamID != nil {
		n += 1 + sovData(uint64(*m.LocalStreamID))
	}
	if m.Mailbox != nil {
		l = m.Mailbox.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *OutputRouterSpec) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Type))
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *ProcessorCoreUnion) Size() (n int) {
	var l int
	_ = l
	if m.TableReader != nil {
		l = m.TableReader.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *ProcessorSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Core.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *FlowSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Processors) > 0 {
		for _, e := range m.Processors {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *DatumInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Encoding))
	return n
}

func (m *StreamHeader) Size() (n int) {
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *StreamData) Size() (n int) {
	var l int
	_ = l
	if m.RawBytes != nil {
		l = len(m.RawBytes)
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *StreamTrailer) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *StreamMessage) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Data.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Trailer != nil {
		l = m.Trailer.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *StreamEndpointSpec) GetValue() interface{} {
	if this.LocalStreamID != nil {
		return this.LocalStreamID
	}
	if this.Mailbox != nil {
		return this.Mailbox
	}
	return nil
}

func (this *StreamEndpointSpec) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *int32:
		this.LocalStreamID = vt
	case *MailboxSpec:
		this.Mailbox = vt
	default:
		return false
	}
	return true
}
func (this *ProcessorCoreUnion) GetValue() interface{} {
	if this.TableReader != nil {
		return this.TableReader
	}
	return nil
}

func (this *ProcessorCoreUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *TableReaderSpec:
		this.TableReader = vt
	default:
		return false
	}
	return true
}
func (m *Expression) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReaderSpan) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReaderSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReaderSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableReaderSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReaderSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReaderSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIdx", wireType)
			}
			m.IndexIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.IndexIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, TableReaderSpan{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Filter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputColumns = append(m.OutputColumns, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputColumns = append(m.OutputColumns, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputColumns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailboxSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailboxSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailboxSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SimpleResponse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamEndpointSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamEndpointSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamEndpointSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalStreamID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalStreamID = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailbox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mailbox == nil {
				m.Mailbox = &MailboxSpec{}
			}
			if err := m.Mailbox.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputRouterSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputRouterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputRouterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (OutputRouterSpec_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, StreamEndpointSpec{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorCoreUnion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorCoreUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorCoreUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableReader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableReader == nil {
				m.TableReader = &TableReaderSpec{}
			}
			if err := m.TableReader.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Core.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, OutputRouterSpec{})
			if err := m.Output[len(m.Output)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processors = append(m.Processors, ProcessorSpec{})
			if err := m.Processors[len(m.Processors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Encoding |= (DatumInfo_EncodingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamHeader) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, DatumInfo{})
			if err := m.Info[len(m.Info)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], data[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamTrailer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamTrailer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamTrailer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &cockroach_roachpb2.Error{}
			}
			if err := m.Error.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamMessage) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &StreamHeader{}
			}
			if err := m.Header.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trailer == nil {
				m.Trailer = &StreamTrailer{}
			}
			if err := m.Trailer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorData = []byte{
	// 902 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x55, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0x5b, 0x37, 0x49, 0x5f, 0x9a, 0x36, 0x8c, 0x80, 0x8d, 0x0a, 0x4a, 0xdb, 0x01, 0x2d,
	0x54, 0xa2, 0xae, 0xe8, 0x8d, 0x65, 0xc5, 0xaa, 0x49, 0xdc, 0x36, 0x0b, 0x6d, 0x91, 0x5b, 0x10,
	0xcb, 0x25, 0x72, 0xec, 0xd9, 0xae, 0x85, 0xe3, 0x31, 0x33, 0x13, 0x36, 0xfb, 0x5f, 0x20, 0x71,
	0xe4, 0xc2, 0x85, 0xff, 0x25, 0xdc, 0x38, 0x70, 0xe0, 0xb4, 0x82, 0xe5, 0x1f, 0x61, 0x7e, 0xb9,
	0x75, 0x7f, 0x64, 0xbb, 0x07, 0x27, 0x9e, 0x79, 0xef, 0xfb, 0xe6, 0x7d, 0xef, 0x7d, 0xb6, 0x61,
	0x23, 0xa2, 0xd1, 0x0f, 0x8c, 0x86, 0xd1, 0xb3, 0x1d, 0xfe, 0x63, 0xba, 0x13, 0x27, 0x5c, 0xe8,
	0xff, 0x50, 0x84, 0x5e, 0xce, 0xa8, 0xa0, 0xe8, 0x9d, 0x8b, 0x0c, 0x4f, 0x46, 0x3c, 0x9b, 0xb1,
	0xf6, 0xfe, 0x25, 0x50, 0xff, 0xe6, 0xc3, 0x12, 0x68, 0xad, 0x7d, 0x33, 0x4a, 0x18, 0xa3, 0x8c,
	0xdb, 0xf8, 0xfd, 0xab, 0xc7, 0xca, 0x6b, 0x18, 0x72, 0xb2, 0xc3, 0x05, 0x1b, 0x47, 0x62, 0xcc,
	0x48, 0x6c, 0xf3, 0xde, 0x3e, 0xa7, 0xe7, 0x54, 0xdf, 0xee, 0xa8, 0x3b, 0xb3, 0x8b, 0xf7, 0x01,
	0xfc, 0x49, 0xce, 0x08, 0xe7, 0x09, 0xcd, 0x50, 0x1b, 0xaa, 0x3f, 0x11, 0xa6, 0x6e, 0x5b, 0xce,
	0x86, 0xf3, 0xf1, 0x52, 0xc7, 0x9d, 0xbe, 0x5c, 0x9f, 0x0b, 0x8a, 0x4d, 0xd4, 0x02, 0x97, 0xc8,
	0xec, 0xd6, 0x7c, 0x29, 0xa8, 0x77, 0x70, 0x0f, 0x56, 0xcf, 0xc2, 0x61, 0x4a, 0x02, 0x12, 0xc6,
	0x84, 0x9d, 0xe6, 0x61, 0x86, 0x3e, 0x05, 0x97, 0xcb, 0x7f, 0xcd, 0x54, 0xdf, 0xbd, 0xe7, 0x5d,
	0x8a, 0xb7, 0x3a, 0x3c, 0x95, 0x56, 0xb0, 0xa8, 0x54, 0x3c, 0x9d, 0xbf, 0x46, 0x43, 0x22, 0xd4,
	0x81, 0x45, 0xa1, 0xb6, 0x2c, 0xcf, 0x7d, 0xef, 0x6a, 0x13, 0xad, 0x5e, 0x4f, 0xc3, 0x7a, 0x84,
	0x47, 0x2c, 0xc9, 0x05, 0x65, 0x96, 0xd6, 0x40, 0xd1, 0x26, 0x2c, 0x25, 0x59, 0x4c, 0x26, 0x83,
	0x24, 0x9e, 0xe8, 0xe2, 0x1b, 0x36, 0x5e, 0xd3, 0xdb, 0xfd, 0x78, 0xa2, 0xa4, 0x33, 0xa2, 0x74,
	0x92, 0xd6, 0x82, 0x4c, 0xa8, 0x15, 0xd2, 0xed, 0xa6, 0x2a, 0x43, 0x95, 0xc8, 0x5b, 0xee, 0xc6,
	0xc2, 0x2d, 0x65, 0xd8, 0x59, 0x7a, 0xd7, 0x9a, 0x50, 0x94, 0xa1, 0xa1, 0xe8, 0x11, 0x54, 0x9e,
	0x26, 0xa9, 0x20, 0xac, 0xb5, 0xa8, 0xb5, 0x6c, 0xce, 0x20, 0xb9, 0x9c, 0x88, 0xc5, 0x5b, 0x18,
	0xda, 0x82, 0x15, 0x3a, 0x16, 0xf9, 0x58, 0x0c, 0x22, 0x9a, 0x8e, 0x47, 0xb2, 0x9a, 0x8a, 0xac,
	0xa6, 0xd1, 0x99, 0x6f, 0x3a, 0x41, 0xc3, 0x44, 0xba, 0x26, 0x80, 0x1f, 0x42, 0xfd, 0x28, 0x4c,
	0xd2, 0x21, 0x9d, 0xe8, 0x2e, 0x6e, 0xc3, 0x2a, 0x4f, 0x46, 0x79, 0x4a, 0x06, 0x92, 0x39, 0xa7,
	0x19, 0x37, 0xfd, 0x2c, 0x64, 0xae, 0x98, 0x60, 0x60, 0x63, 0xf8, 0x17, 0x07, 0xd0, 0xa9, 0x60,
	0x24, 0x1c, 0xf9, 0x59, 0x9c, 0xd3, 0x24, 0x13, 0x9a, 0xe5, 0x33, 0x58, 0x4d, 0x69, 0x14, 0xa6,
	0x03, 0xae, 0x63, 0xb2, 0x9d, 0x9a, 0x65, 0xb1, 0xf3, 0xd6, 0xab, 0x97, 0xeb, 0x8d, 0xaf, 0x54,
	0xc8, 0xa0, 0xfa, 0xbd, 0xa0, 0x91, 0x96, 0x96, 0x31, 0x7a, 0x08, 0xd5, 0x91, 0xa9, 0x47, 0x0f,
	0xa0, 0xbe, 0x8b, 0x67, 0x88, 0x2f, 0x55, 0x1d, 0x14, 0x90, 0x07, 0xee, 0xf4, 0xb7, 0x75, 0x07,
	0xff, 0xe5, 0x40, 0xf3, 0x44, 0xab, 0x0c, 0xa4, 0x58, 0xeb, 0x8f, 0x7d, 0x70, 0xc5, 0x8b, 0xdc,
	0xc8, 0x59, 0xd9, 0xfd, 0x64, 0x06, 0xeb, 0x75, 0x98, 0x77, 0x26, 0x31, 0x85, 0xf7, 0x14, 0x1e,
	0xf5, 0xa1, 0x6a, 0x54, 0x71, 0x59, 0xa0, 0x1a, 0xf1, 0xd6, 0x0c, 0xaa, 0x9b, 0x7d, 0x29, 0xbc,
	0x62, 0xf1, 0x78, 0x1b, 0x5c, 0x45, 0x8f, 0x00, 0x2a, 0x47, 0xfd, 0x20, 0x38, 0x09, 0x9a, 0x73,
	0xa8, 0x0e, 0xd5, 0xce, 0x93, 0xc1, 0xe1, 0xde, 0xe9, 0x61, 0xd3, 0x41, 0xcb, 0x50, 0x93, 0x8b,
	0x60, 0xef, 0xf8, 0xc0, 0x6f, 0xce, 0xe3, 0x18, 0xd0, 0xd7, 0x8c, 0x46, 0x72, 0xe2, 0x94, 0x75,
	0x29, 0x23, 0xdf, 0x64, 0xea, 0x59, 0x3b, 0x84, 0xba, 0xb8, 0x34, 0xd3, 0x0c, 0xf7, 0xdf, 0x6a,
	0x3b, 0xd9, 0xb8, 0x32, 0xd4, 0x36, 0xef, 0x57, 0x07, 0x1a, 0x17, 0xc7, 0xe8, 0xce, 0x75, 0xc1,
	0x8d, 0xe4, 0x71, 0x96, 0x7a, 0x96, 0xdc, 0x9b, 0xa5, 0x15, 0x6d, 0x53, 0x60, 0xe4, 0x43, 0xc5,
	0x18, 0xcf, 0x76, 0xed, 0xa3, 0x37, 0x1c, 0x40, 0xe1, 0x6c, 0x03, 0xc6, 0xdf, 0x42, 0x6d, 0x3f,
	0xa5, 0xcf, 0x75, 0x5d, 0x8f, 0x01, 0xf2, 0xe2, 0x50, 0x2e, 0xab, 0x53, 0xb4, 0x1f, 0xde, 0x55,
	0x5d, 0x89, 0xb3, 0x84, 0xc6, 0xbf, 0x3b, 0xb0, 0xd4, 0x0b, 0xc5, 0x78, 0xd4, 0xcf, 0x9e, 0x52,
	0x74, 0x02, 0x35, 0x92, 0x45, 0x34, 0x4e, 0xb2, 0x73, 0xeb, 0x97, 0xed, 0x19, 0xbc, 0x17, 0x18,
	0xcf, 0xb7, 0x80, 0x92, 0x61, 0x2e, 0x48, 0xf0, 0x01, 0x2c, 0x97, 0xe3, 0x68, 0x0d, 0xde, 0xdd,
	0x3b, 0xed, 0xfa, 0xc7, 0xbd, 0xfe, 0xf1, 0xc1, 0xe0, 0x4b, 0xff, 0xc9, 0xc0, 0x3f, 0xee, 0x9e,
	0xa8, 0x85, 0x74, 0xc0, 0x7b, 0x70, 0xaf, 0xe7, 0xdf, 0x1e, 0x74, 0xf0, 0x63, 0x58, 0x36, 0xbe,
	0x3a, 0xd4, 0x33, 0x43, 0x0f, 0xc0, 0x4d, 0xe4, 0xe9, 0x56, 0xfd, 0xc6, 0x5d, 0x55, 0x16, 0x23,
	0x51, 0x18, 0xbc, 0x05, 0x60, 0xb8, 0x64, 0x38, 0x94, 0xc7, 0x2e, 0xb1, 0xf0, 0xf9, 0x60, 0xf8,
	0x42, 0x10, 0xae, 0x45, 0x2f, 0x07, 0x35, 0xb9, 0xd1, 0x51, 0x6b, 0xfc, 0x08, 0x1a, 0x26, 0xf5,
	0x8c, 0xc9, 0x27, 0x4d, 0x9e, 0xeb, 0xc1, 0xa2, 0xfe, 0xba, 0x58, 0x53, 0xb4, 0x6e, 0x79, 0x6b,
	0xfb, 0x2a, 0x1e, 0x98, 0x34, 0xfc, 0x87, 0x53, 0x30, 0x1c, 0xc9, 0x8e, 0x87, 0xe7, 0x04, 0x7d,
	0x0e, 0x95, 0x67, 0x65, 0xcb, 0x7e, 0xf0, 0xda, 0xc7, 0xc8, 0xc8, 0x0d, 0x2c, 0x44, 0x82, 0x5d,
	0xf5, 0xe9, 0xb3, 0xaf, 0x88, 0xcd, 0xd7, 0x42, 0x95, 0xba, 0x42, 0xb7, 0x02, 0xa1, 0x2f, 0xa0,
	0x2a, 0x8c, 0x0c, 0xfd, 0x0a, 0x9f, 0x6d, 0x9a, 0x2b, 0x92, 0x83, 0x02, 0xd4, 0xd9, 0x9c, 0xfe,
	0xdb, 0x9e, 0x9b, 0xbe, 0x6a, 0x3b, 0x7f, 0xca, 0xeb, 0x6f, 0x79, 0xfd, 0x23, 0xaf, 0x9f, 0xff,
	0x6b, 0xcf, 0x7d, 0x5f, 0xb5, 0xc8, 0xef, 0x16, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x2a, 0x4e,
	0xf9, 0x36, 0xe6, 0x07, 0x00, 0x00,
}
