// Code generated by protoc-gen-gogo.
// source: cockroach/sql/structured.proto
// DO NOT EDIT!

package sql

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_roachpb1 "github.com/cockroachdb/cockroach/roachpb"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import github_com_cockroachdb_cockroach_roachpb "github.com/cockroachdb/cockroach/roachpb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// These mirror the types supported by the sql/parser. See
// sql/parser/types.go.
type ColumnType_Kind int32

const (
	ColumnType_BOOL      ColumnType_Kind = 0
	ColumnType_INT       ColumnType_Kind = 1
	ColumnType_FLOAT     ColumnType_Kind = 2
	ColumnType_DECIMAL   ColumnType_Kind = 3
	ColumnType_DATE      ColumnType_Kind = 4
	ColumnType_TIMESTAMP ColumnType_Kind = 5
	ColumnType_INTERVAL  ColumnType_Kind = 6
	ColumnType_STRING    ColumnType_Kind = 7
	ColumnType_BYTES     ColumnType_Kind = 8
)

var ColumnType_Kind_name = map[int32]string{
	0: "BOOL",
	1: "INT",
	2: "FLOAT",
	3: "DECIMAL",
	4: "DATE",
	5: "TIMESTAMP",
	6: "INTERVAL",
	7: "STRING",
	8: "BYTES",
}
var ColumnType_Kind_value = map[string]int32{
	"BOOL":      0,
	"INT":       1,
	"FLOAT":     2,
	"DECIMAL":   3,
	"DATE":      4,
	"TIMESTAMP": 5,
	"INTERVAL":  6,
	"STRING":    7,
	"BYTES":     8,
}

func (x ColumnType_Kind) Enum() *ColumnType_Kind {
	p := new(ColumnType_Kind)
	*p = x
	return p
}
func (x ColumnType_Kind) String() string {
	return proto.EnumName(ColumnType_Kind_name, int32(x))
}
func (x *ColumnType_Kind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnType_Kind_value, data, "ColumnType_Kind")
	if err != nil {
		return err
	}
	*x = ColumnType_Kind(value)
	return nil
}

// A descriptor within a mutation is unavailable for reads, writes
// and deletes. It is only available for implicit (internal to
// the database) writes and deletes depending on the state of the mutation.
type DescriptorMutation_State int32

const (
	// Not used.
	DescriptorMutation_UNKNOWN DescriptorMutation_State = 0
	// Operations can use this invisible descriptor to implicitly
	// delete entries.
	// Column: A descriptor in this state is invisible to
	// INSERT and UPDATE. DELETE must delete a column in this state.
	// Index: A descriptor in this state is invisible to an INSERT.
	// UPDATE must delete the old value of the index but doesn't write
	// the new value. DELETE must delete the index.
	//
	// When deleting a descriptor, all descriptor related data
	// (column or index data) can only be mass deleted once
	// all the nodes have transitioned to the DELETE_ONLY state.
	DescriptorMutation_DELETE_ONLY DescriptorMutation_State = 1
	// Operations can use this invisible descriptor to implicitly
	// write and delete entries.
	// Column: INSERT will populate this column with the default
	// value. UPDATE ignores this descriptor. DELETE must delete
	// the column.
	// Index: INSERT, UPDATE and DELETE treat this index like any
	// other index.
	//
	// When adding a descriptor, all descriptor related data
	// (column default or index data) can only be backfilled once
	// all nodes have transitioned into the WRITE_ONLY state.
	DescriptorMutation_WRITE_ONLY DescriptorMutation_State = 2
)

var DescriptorMutation_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "DELETE_ONLY",
	2: "WRITE_ONLY",
}
var DescriptorMutation_State_value = map[string]int32{
	"UNKNOWN":     0,
	"DELETE_ONLY": 1,
	"WRITE_ONLY":  2,
}

func (x DescriptorMutation_State) Enum() *DescriptorMutation_State {
	p := new(DescriptorMutation_State)
	*p = x
	return p
}
func (x DescriptorMutation_State) String() string {
	return proto.EnumName(DescriptorMutation_State_name, int32(x))
}
func (x *DescriptorMutation_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_State_value, data, "DescriptorMutation_State")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_State(value)
	return nil
}

// Direction of mutation.
type DescriptorMutation_Direction int32

const (
	// Not used.
	DescriptorMutation_NONE DescriptorMutation_Direction = 0
	// Descriptor is being added.
	DescriptorMutation_ADD DescriptorMutation_Direction = 1
	// Descriptor is being dropped.
	DescriptorMutation_DROP DescriptorMutation_Direction = 2
)

var DescriptorMutation_Direction_name = map[int32]string{
	0: "NONE",
	1: "ADD",
	2: "DROP",
}
var DescriptorMutation_Direction_value = map[string]int32{
	"NONE": 0,
	"ADD":  1,
	"DROP": 2,
}

func (x DescriptorMutation_Direction) Enum() *DescriptorMutation_Direction {
	p := new(DescriptorMutation_Direction)
	*p = x
	return p
}
func (x DescriptorMutation_Direction) String() string {
	return proto.EnumName(DescriptorMutation_Direction_name, int32(x))
}
func (x *DescriptorMutation_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_Direction_value, data, "DescriptorMutation_Direction")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_Direction(value)
	return nil
}

type ColumnType struct {
	Kind ColumnType_Kind `protobuf:"varint,1,opt,name=kind,enum=cockroach.sql.ColumnType_Kind" json:"kind"`
	// BIT, INT, FLOAT, DECIMAL, CHAR and BINARY
	Width int32 `protobuf:"varint,2,opt,name=width" json:"width"`
	// FLOAT and DECIMAL.
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision"`
}

func (m *ColumnType) Reset()         { *m = ColumnType{} }
func (m *ColumnType) String() string { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()    {}

type ColumnDescriptor struct {
	Name     string     `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID       ColumnID   `protobuf:"varint,2,opt,name=id,casttype=ColumnID" json:"id"`
	Type     ColumnType `protobuf:"bytes,3,opt,name=type" json:"type"`
	Nullable bool       `protobuf:"varint,4,opt,name=nullable" json:"nullable"`
	// Default expression to use to populate the column on insert if no
	// value is provided.
	DefaultExpr *string `protobuf:"bytes,5,opt,name=default_expr" json:"default_expr,omitempty"`
}

func (m *ColumnDescriptor) Reset()         { *m = ColumnDescriptor{} }
func (m *ColumnDescriptor) String() string { return proto.CompactTextString(m) }
func (*ColumnDescriptor) ProtoMessage()    {}

type IndexDescriptor struct {
	Name   string  `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID     IndexID `protobuf:"varint,2,opt,name=id,casttype=IndexID" json:"id"`
	Unique bool    `protobuf:"varint,3,opt,name=unique" json:"unique"`
	// An ordered list of column names of which the index is comprised. This list
	// parallels the column_ids list. If duplicating the storage of the column
	// names here proves to be prohibitive, we could clear this field before
	// saving and reconstruct it after loading.
	ColumnNames []string `protobuf:"bytes,4,rep,name=column_names" json:"column_names,omitempty"`
	// An ordered list of column names which the index stores in
	// addition to the columns which are explicitly part of the index.
	StoreColumnNames []string `protobuf:"bytes,5,rep,name=store_column_names" json:"store_column_names,omitempty"`
	// An ordered list of column ids of which the index is comprised. This list
	// parallels the column_names list.
	ColumnIDs []ColumnID `protobuf:"varint,6,rep,name=column_ids,casttype=ColumnID" json:"column_ids,omitempty"`
	// An ordered list of implicit column ids associated with the index. For
	// non-unique indexes, these columns will be appended to the key. For unique
	// indexes these columns will be stored in the value. The extra column IDs is
	// computed as PrimaryIndex.column_ids - column_ids. For the primary index
	// the list will be empty.
	ImplicitColumnIDs []ColumnID `protobuf:"varint,7,rep,name=implicit_column_ids,casttype=ColumnID" json:"implicit_column_ids,omitempty"`
}

func (m *IndexDescriptor) Reset()         { *m = IndexDescriptor{} }
func (m *IndexDescriptor) String() string { return proto.CompactTextString(m) }
func (*IndexDescriptor) ProtoMessage()    {}

// A DescriptorMutation represents a column or an index that
// has either been added or dropped and hasn't yet transitioned
// into a stable state: completely backfilled and visible, or
// completely deleted. A table descriptor in the middle of a
// schema change will have a DescriptorMutation FIFO queue
// containing each column/index descriptor being added or dropped.
type DescriptorMutation struct {
	// Types that are valid to be assigned to Descriptor_:
	//	*DescriptorMutation_Column
	//	*DescriptorMutation_Index
	Descriptor_ isDescriptorMutation_Descriptor_ `protobuf_oneof:"descriptor"`
	State       DescriptorMutation_State         `protobuf:"varint,3,opt,name=state,enum=cockroach.sql.DescriptorMutation_State" json:"state"`
	Direction   DescriptorMutation_Direction     `protobuf:"varint,4,opt,name=direction,enum=cockroach.sql.DescriptorMutation_Direction" json:"direction"`
}

func (m *DescriptorMutation) Reset()         { *m = DescriptorMutation{} }
func (m *DescriptorMutation) String() string { return proto.CompactTextString(m) }
func (*DescriptorMutation) ProtoMessage()    {}

type isDescriptorMutation_Descriptor_ interface {
	isDescriptorMutation_Descriptor_()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DescriptorMutation_Column struct {
	Column *ColumnDescriptor `protobuf:"bytes,1,opt,name=column,oneof"`
}
type DescriptorMutation_Index struct {
	Index *IndexDescriptor `protobuf:"bytes,2,opt,name=index,oneof"`
}

func (*DescriptorMutation_Column) isDescriptorMutation_Descriptor_() {}
func (*DescriptorMutation_Index) isDescriptorMutation_Descriptor_()  {}

func (m *DescriptorMutation) GetDescriptor_() isDescriptorMutation_Descriptor_ {
	if m != nil {
		return m.Descriptor_
	}
	return nil
}

func (m *DescriptorMutation) GetColumn() *ColumnDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Column); ok {
		return x.Column
	}
	return nil
}

func (m *DescriptorMutation) GetIndex() *IndexDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Index); ok {
		return x.Index
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DescriptorMutation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _DescriptorMutation_OneofMarshaler, _DescriptorMutation_OneofUnmarshaler, []interface{}{
		(*DescriptorMutation_Column)(nil),
		(*DescriptorMutation_Index)(nil),
	}
}

func _DescriptorMutation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DescriptorMutation)
	// descriptor
	switch x := m.Descriptor_.(type) {
	case *DescriptorMutation_Column:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Column); err != nil {
			return err
		}
	case *DescriptorMutation_Index:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Index); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DescriptorMutation.Descriptor_ has unexpected type %T", x)
	}
	return nil
}

func _DescriptorMutation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DescriptorMutation)
	switch tag {
	case 1: // descriptor.column
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Column{msg}
		return true, err
	case 2: // descriptor.index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IndexDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Index{msg}
		return true, err
	default:
		return false, nil
	}
}

// A TableDescriptor represents a table and is stored in a structured metadata
// key. The TableDescriptor has a globally-unique ID, while its member
// {Column,Index}Descriptors have locally-unique IDs.
type TableDescriptor struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// The alias for the table. This is only used during query
	// processing and not stored persistently.
	Alias string `protobuf:"bytes,2,opt,name=alias" json:"alias"`
	ID    ID     `protobuf:"varint,3,opt,name=id,casttype=ID" json:"id"`
	// ID of the parent database.
	ParentID ID `protobuf:"varint,4,opt,name=parent_id,casttype=ID" json:"parent_id"`
	// Monotonically increasing version of the table descriptor.
	//
	// Invariants:
	// 1. not more than two subsequent versions of the table
	// descriptor can be leased. This is to make the system
	// easy to reason about, by permiting mutation state
	// changes (reflected in the next version), only when the existing
	// state (reflected in the current version) is present on all
	// outstanding unexpired leases.
	// 2. A schema change command (ALTER, RENAME, etc) never directly
	// increments the version. This allows the command to execute without
	// waiting for the entire cluster to converge to a single version
	// preventing weird deadlock situations. For instance, a transaction
	// with a schema change command might use a descriptor lease that is
	// at version: v - 1, and therefore deadlock when it tries to wait
	// for version: v, in the process of incrementing it to v + 1.
	// Therefore, a schema change command never increments the version,
	// and instead, sets the up_version boolean to notify the schema
	// changer execution engine that runs a future transaction to
	// increment the version.
	//
	// The schema change commands must therefore make *safe* modifications
	// to the table descriptor, such as scheduling long running schema
	// changes through mutations for future execution, or making simple
	// schema changes like RENAME that only modify the table descriptor in a
	// single transaction.
	//
	// Multiple schema changes in the same transaction set up_version.
	// The actual schema change execution that follows a schema change
	// command sees the up_version boolean set, and increments the
	// table version after ensuring that there are no unexpired leases
	// for version - 1. The schema change execution must increment
	// the version before executing future state changes, to ensure
	// that the scheduled mutations made by the original commands are
	// visible on all leases. Multiple schema change mutations can be
	// grouped together on a particular version increment.
	//
	// If schema change commands are safe to run without incrementing
	// the version, why do it later on? We increment the version
	// to ensure that all the nodes renew their leases with the new version
	// and get to see what the schema change command has done quickly.
	//
	// TODO(vivek): Implement the above invariants by ensuring that
	// the Version is only incremented in LeaseManager.Publish().
	// Move applyMutation() and applyUpVersion() out of the transaction for
	// schema commands and into LeaseManager.Publish(), and remove
	// Version++ from applyUpVersion().
	//
	Version DescriptorVersion `protobuf:"varint,5,opt,name=version,casttype=DescriptorVersion" json:"version"`
	// See comment above.
	UpVersion bool `protobuf:"varint,6,opt,name=up_version" json:"up_version"`
	// Last modification time of the table descriptor.
	ModificationTime cockroach_roachpb1.Timestamp `protobuf:"bytes,7,opt,name=modification_time" json:"modification_time"`
	Columns          []ColumnDescriptor           `protobuf:"bytes,8,rep,name=columns" json:"columns"`
	// next_column_id is used to ensure that deleted column ids are not reused.
	NextColumnID ColumnID        `protobuf:"varint,9,opt,name=next_column_id,casttype=ColumnID" json:"next_column_id"`
	PrimaryIndex IndexDescriptor `protobuf:"bytes,10,opt,name=primary_index" json:"primary_index"`
	// indexes are all the secondary indexes.
	Indexes []IndexDescriptor `protobuf:"bytes,11,rep,name=indexes" json:"indexes"`
	// next_index_id is used to ensure that deleted index ids are not reused.
	NextIndexID IndexID              `protobuf:"varint,12,opt,name=next_index_id,casttype=IndexID" json:"next_index_id"`
	Privileges  *PrivilegeDescriptor `protobuf:"bytes,13,opt,name=privileges" json:"privileges,omitempty"`
	// Columns or indexes being added or deleted in a FIFO order.
	Mutations []DescriptorMutation               `protobuf:"bytes,14,rep,name=mutations" json:"mutations"`
	Lease     *TableDescriptor_SchemaChangeLease `protobuf:"bytes,15,opt,name=lease" json:"lease,omitempty"`
}

func (m *TableDescriptor) Reset()         { *m = TableDescriptor{} }
func (m *TableDescriptor) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor) ProtoMessage()    {}

func (m *TableDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDescriptor) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *TableDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TableDescriptor) GetParentID() ID {
	if m != nil {
		return m.ParentID
	}
	return 0
}

func (m *TableDescriptor) GetVersion() DescriptorVersion {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDescriptor) GetUpVersion() bool {
	if m != nil {
		return m.UpVersion
	}
	return false
}

func (m *TableDescriptor) GetModificationTime() cockroach_roachpb1.Timestamp {
	if m != nil {
		return m.ModificationTime
	}
	return cockroach_roachpb1.Timestamp{}
}

func (m *TableDescriptor) GetColumns() []ColumnDescriptor {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableDescriptor) GetNextColumnID() ColumnID {
	if m != nil {
		return m.NextColumnID
	}
	return 0
}

func (m *TableDescriptor) GetPrimaryIndex() IndexDescriptor {
	if m != nil {
		return m.PrimaryIndex
	}
	return IndexDescriptor{}
}

func (m *TableDescriptor) GetIndexes() []IndexDescriptor {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDescriptor) GetNextIndexID() IndexID {
	if m != nil {
		return m.NextIndexID
	}
	return 0
}

func (m *TableDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *TableDescriptor) GetMutations() []DescriptorMutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *TableDescriptor) GetLease() *TableDescriptor_SchemaChangeLease {
	if m != nil {
		return m.Lease
	}
	return nil
}

// The schema update lease. A single goroutine across a cockroach cluster
// can own it, and will execute pending schema changes for this table.
// Since the execution of a pending schema change is through transactions,
// it is legal for more than one goroutine to attempt to execute it. This
// lease reduces write contention on the schema change.
type TableDescriptor_SchemaChangeLease struct {
	NodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"node_id"`
	// Nanoseconds since the Unix epoch.
	ExpirationTime int64 `protobuf:"varint,2,opt,name=expiration_time" json:"expiration_time"`
}

func (m *TableDescriptor_SchemaChangeLease) Reset()         { *m = TableDescriptor_SchemaChangeLease{} }
func (m *TableDescriptor_SchemaChangeLease) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_SchemaChangeLease) ProtoMessage()    {}

// DatabaseDescriptor represents a namespace (aka database) and is stored
// in a structured metadata key. The DatabaseDescriptor has a globally-unique
// ID shared with the TableDescriptor ID.
// Permissions are applied to all tables in the namespace.
type DatabaseDescriptor struct {
	Name       string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID         ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Privileges *PrivilegeDescriptor `protobuf:"bytes,3,opt,name=privileges" json:"privileges,omitempty"`
}

func (m *DatabaseDescriptor) Reset()         { *m = DatabaseDescriptor{} }
func (m *DatabaseDescriptor) String() string { return proto.CompactTextString(m) }
func (*DatabaseDescriptor) ProtoMessage()    {}

func (m *DatabaseDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DatabaseDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

// Descriptor is a union type holding either a table or database descriptor.
type Descriptor struct {
	// Types that are valid to be assigned to Union:
	//	*Descriptor_Table
	//	*Descriptor_Database
	Union isDescriptor_Union `protobuf_oneof:"union"`
}

func (m *Descriptor) Reset()         { *m = Descriptor{} }
func (m *Descriptor) String() string { return proto.CompactTextString(m) }
func (*Descriptor) ProtoMessage()    {}

type isDescriptor_Union interface {
	isDescriptor_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Descriptor_Table struct {
	Table *TableDescriptor `protobuf:"bytes,1,opt,name=table,oneof"`
}
type Descriptor_Database struct {
	Database *DatabaseDescriptor `protobuf:"bytes,2,opt,name=database,oneof"`
}

func (*Descriptor_Table) isDescriptor_Union()    {}
func (*Descriptor_Database) isDescriptor_Union() {}

func (m *Descriptor) GetUnion() isDescriptor_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Descriptor) GetTable() *TableDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Table); ok {
		return x.Table
	}
	return nil
}

func (m *Descriptor) GetDatabase() *DatabaseDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Database); ok {
		return x.Database
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Descriptor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Descriptor_OneofMarshaler, _Descriptor_OneofUnmarshaler, []interface{}{
		(*Descriptor_Table)(nil),
		(*Descriptor_Database)(nil),
	}
}

func _Descriptor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Descriptor)
	// union
	switch x := m.Union.(type) {
	case *Descriptor_Table:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Table); err != nil {
			return err
		}
	case *Descriptor_Database:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Database); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Descriptor.Union has unexpected type %T", x)
	}
	return nil
}

func _Descriptor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Descriptor)
	switch tag {
	case 1: // union.table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TableDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Table{msg}
		return true, err
	case 2: // union.database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatabaseDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Database{msg}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterType((*ColumnType)(nil), "cockroach.sql.ColumnType")
	proto.RegisterType((*ColumnDescriptor)(nil), "cockroach.sql.ColumnDescriptor")
	proto.RegisterType((*IndexDescriptor)(nil), "cockroach.sql.IndexDescriptor")
	proto.RegisterType((*DescriptorMutation)(nil), "cockroach.sql.DescriptorMutation")
	proto.RegisterType((*TableDescriptor)(nil), "cockroach.sql.TableDescriptor")
	proto.RegisterType((*TableDescriptor_SchemaChangeLease)(nil), "cockroach.sql.TableDescriptor.SchemaChangeLease")
	proto.RegisterType((*DatabaseDescriptor)(nil), "cockroach.sql.DatabaseDescriptor")
	proto.RegisterType((*Descriptor)(nil), "cockroach.sql.Descriptor")
	proto.RegisterEnum("cockroach.sql.ColumnType_Kind", ColumnType_Kind_name, ColumnType_Kind_value)
	proto.RegisterEnum("cockroach.sql.DescriptorMutation_State", DescriptorMutation_State_name, DescriptorMutation_State_value)
	proto.RegisterEnum("cockroach.sql.DescriptorMutation_Direction", DescriptorMutation_Direction_name, DescriptorMutation_Direction_value)
}
func (m *ColumnType) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnType) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.Kind))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.Width))
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.Precision))
	return i, nil
}

func (m *ColumnDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x1a
	i++
	i = encodeVarintStructured(data, i, uint64(m.Type.Size()))
	n1, err := m.Type.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	data[i] = 0x20
	i++
	if m.Nullable {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.DefaultExpr != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintStructured(data, i, uint64(len(*m.DefaultExpr)))
		i += copy(data[i:], *m.DefaultExpr)
	}
	return i, nil
}

func (m *IndexDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IndexDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x18
	i++
	if m.Unique {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			data[i] = 0x30
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	if len(m.ImplicitColumnIDs) > 0 {
		for _, num := range m.ImplicitColumnIDs {
			data[i] = 0x38
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *DescriptorMutation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescriptorMutation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Descriptor_ != nil {
		nn2, err := m.Descriptor_.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.State))
	data[i] = 0x20
	i++
	i = encodeVarintStructured(data, i, uint64(m.Direction))
	return i, nil
}

func (m *DescriptorMutation_Column) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Column != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStructured(data, i, uint64(m.Column.Size()))
		n3, err := m.Column.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *DescriptorMutation_Index) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Index != nil {
		data[i] = 0x12
		i++
		i = encodeVarintStructured(data, i, uint64(m.Index.Size()))
		n4, err := m.Index.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *TableDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x12
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Alias)))
	i += copy(data[i:], m.Alias)
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x20
	i++
	i = encodeVarintStructured(data, i, uint64(m.ParentID))
	data[i] = 0x28
	i++
	i = encodeVarintStructured(data, i, uint64(m.Version))
	data[i] = 0x30
	i++
	if m.UpVersion {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x3a
	i++
	i = encodeVarintStructured(data, i, uint64(m.ModificationTime.Size()))
	n5, err := m.ModificationTime.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x42
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x48
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextColumnID))
	data[i] = 0x52
	i++
	i = encodeVarintStructured(data, i, uint64(m.PrimaryIndex.Size()))
	n6, err := m.PrimaryIndex.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			data[i] = 0x5a
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x60
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextIndexID))
	if m.Privileges != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Privileges.Size()))
		n7, err := m.Privileges.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			data[i] = 0x72
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lease != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Lease.Size()))
		n8, err := m.Lease.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *TableDescriptor_SchemaChangeLease) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor_SchemaChangeLease) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.NodeID))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ExpirationTime))
	return i, nil
}

func (m *DatabaseDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabaseDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	if m.Privileges != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Privileges.Size()))
		n9, err := m.Privileges.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *Descriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Descriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		nn10, err := m.Union.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *Descriptor_Table) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Table != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStructured(data, i, uint64(m.Table.Size()))
		n11, err := m.Table.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Descriptor_Database) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Database != nil {
		data[i] = 0x12
		i++
		i = encodeVarintStructured(data, i, uint64(m.Database.Size()))
		n12, err := m.Database.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func encodeFixed64Structured(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Structured(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStructured(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *ColumnType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.Kind))
	n += 1 + sovStructured(uint64(m.Width))
	n += 1 + sovStructured(uint64(m.Precision))
	return n
}

func (m *ColumnDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Type.Size()
	n += 1 + l + sovStructured(uint64(l))
	n += 2
	if m.DefaultExpr != nil {
		l = len(*m.DefaultExpr)
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func (m *IndexDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 2
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ImplicitColumnIDs) > 0 {
		for _, e := range m.ImplicitColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	return n
}

func (m *DescriptorMutation) Size() (n int) {
	var l int
	_ = l
	if m.Descriptor_ != nil {
		n += m.Descriptor_.Size()
	}
	n += 1 + sovStructured(uint64(m.State))
	n += 1 + sovStructured(uint64(m.Direction))
	return n
}

func (m *DescriptorMutation_Column) Size() (n int) {
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_Index) Size() (n int) {
	var l int
	_ = l
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *TableDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.Alias)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 1 + sovStructured(uint64(m.ParentID))
	n += 1 + sovStructured(uint64(m.Version))
	n += 2
	l = m.ModificationTime.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextColumnID))
	l = m.PrimaryIndex.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextIndexID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func (m *TableDescriptor_SchemaChangeLease) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.NodeID))
	n += 1 + sovStructured(uint64(m.ExpirationTime))
	return n
}

func (m *DatabaseDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func (m *Descriptor) Size() (n int) {
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *Descriptor_Table) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *Descriptor_Database) Size() (n int) {
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func sovStructured(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructured(x uint64) (n int) {
	return sovStructured(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ColumnType) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (ColumnType_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DefaultExpr = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreColumnNames = append(m.StoreColumnNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
			var v ColumnID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColumnIDs = append(m.ColumnIDs, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitColumnIDs", wireType)
			}
			var v ColumnID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitColumnIDs = append(m.ImplicitColumnIDs, v)
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorMutation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Column{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Index{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (DescriptorMutation_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Direction |= (DescriptorMutation_Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (DescriptorVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpVersion = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModificationTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, ColumnDescriptor{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextColumnID", wireType)
			}
			m.NextColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryIndex.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, IndexDescriptor{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndexID", wireType)
			}
			m.NextIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextIndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, DescriptorMutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &TableDescriptor_SchemaChangeLease{}
			}
			if err := m.Lease.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_SchemaChangeLease) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeLease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeLease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			m.ExpirationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpirationTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Descriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Descriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Descriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Table{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Database{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructured(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStructured
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructured(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructured = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructured   = fmt.Errorf("proto: integer overflow")
)
