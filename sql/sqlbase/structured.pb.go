// Code generated by protoc-gen-gogo.
// source: cockroach/sql/sqlbase/structured.proto
// DO NOT EDIT!

package sqlbase

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_util_hlc "github.com/cockroachdb/cockroach/util/hlc"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import github_com_cockroachdb_cockroach_roachpb "github.com/cockroachdb/cockroach/roachpb"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// These mirror the types supported by the sql/parser. See
// sql/parser/types.go.
type ColumnType_Kind int32

const (
	ColumnType_BOOL        ColumnType_Kind = 0
	ColumnType_INT         ColumnType_Kind = 1
	ColumnType_FLOAT       ColumnType_Kind = 2
	ColumnType_DECIMAL     ColumnType_Kind = 3
	ColumnType_DATE        ColumnType_Kind = 4
	ColumnType_TIMESTAMP   ColumnType_Kind = 5
	ColumnType_INTERVAL    ColumnType_Kind = 6
	ColumnType_STRING      ColumnType_Kind = 7
	ColumnType_BYTES       ColumnType_Kind = 8
	ColumnType_TIMESTAMPTZ ColumnType_Kind = 9
)

var ColumnType_Kind_name = map[int32]string{
	0: "BOOL",
	1: "INT",
	2: "FLOAT",
	3: "DECIMAL",
	4: "DATE",
	5: "TIMESTAMP",
	6: "INTERVAL",
	7: "STRING",
	8: "BYTES",
	9: "TIMESTAMPTZ",
}
var ColumnType_Kind_value = map[string]int32{
	"BOOL":        0,
	"INT":         1,
	"FLOAT":       2,
	"DECIMAL":     3,
	"DATE":        4,
	"TIMESTAMP":   5,
	"INTERVAL":    6,
	"STRING":      7,
	"BYTES":       8,
	"TIMESTAMPTZ": 9,
}

func (x ColumnType_Kind) Enum() *ColumnType_Kind {
	p := new(ColumnType_Kind)
	*p = x
	return p
}
func (x ColumnType_Kind) String() string {
	return proto.EnumName(ColumnType_Kind_name, int32(x))
}
func (x *ColumnType_Kind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ColumnType_Kind_value, data, "ColumnType_Kind")
	if err != nil {
		return err
	}
	*x = ColumnType_Kind(value)
	return nil
}
func (ColumnType_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorStructured, []int{0, 0} }

// The direction of a column in the index.
type IndexDescriptor_Direction int32

const (
	IndexDescriptor_ASC  IndexDescriptor_Direction = 0
	IndexDescriptor_DESC IndexDescriptor_Direction = 1
)

var IndexDescriptor_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var IndexDescriptor_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x IndexDescriptor_Direction) Enum() *IndexDescriptor_Direction {
	p := new(IndexDescriptor_Direction)
	*p = x
	return p
}
func (x IndexDescriptor_Direction) String() string {
	return proto.EnumName(IndexDescriptor_Direction_name, int32(x))
}
func (x *IndexDescriptor_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IndexDescriptor_Direction_value, data, "IndexDescriptor_Direction")
	if err != nil {
		return err
	}
	*x = IndexDescriptor_Direction(value)
	return nil
}
func (IndexDescriptor_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{5, 0}
}

// A descriptor within a mutation is unavailable for reads, writes
// and deletes. It is only available for implicit (internal to
// the database) writes and deletes depending on the state of the mutation.
type DescriptorMutation_State int32

const (
	// Not used.
	DescriptorMutation_UNKNOWN DescriptorMutation_State = 0
	// Operations can use this invisible descriptor to implicitly
	// delete entries.
	// Column: A descriptor in this state is invisible to
	// INSERT and UPDATE. DELETE must delete a column in this state.
	// Index: A descriptor in this state is invisible to an INSERT.
	// UPDATE must delete the old value of the index but doesn't write
	// the new value. DELETE must delete the index.
	//
	// When deleting a descriptor, all descriptor related data
	// (column or index data) can only be mass deleted once
	// all the nodes have transitioned to the DELETE_ONLY state.
	DescriptorMutation_DELETE_ONLY DescriptorMutation_State = 1
	// Operations can use this invisible descriptor to implicitly
	// write and delete entries.
	// Column: INSERT will populate this column with the default
	// value. UPDATE ignores this descriptor. DELETE must delete
	// the column.
	// Index: INSERT, UPDATE and DELETE treat this index like any
	// other index.
	//
	// When adding a descriptor, all descriptor related data
	// (column default or index data) can only be backfilled once
	// all nodes have transitioned into the WRITE_ONLY state.
	DescriptorMutation_WRITE_ONLY DescriptorMutation_State = 2
)

var DescriptorMutation_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "DELETE_ONLY",
	2: "WRITE_ONLY",
}
var DescriptorMutation_State_value = map[string]int32{
	"UNKNOWN":     0,
	"DELETE_ONLY": 1,
	"WRITE_ONLY":  2,
}

func (x DescriptorMutation_State) Enum() *DescriptorMutation_State {
	p := new(DescriptorMutation_State)
	*p = x
	return p
}
func (x DescriptorMutation_State) String() string {
	return proto.EnumName(DescriptorMutation_State_name, int32(x))
}
func (x *DescriptorMutation_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_State_value, data, "DescriptorMutation_State")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_State(value)
	return nil
}
func (DescriptorMutation_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{6, 0}
}

// Direction of mutation.
type DescriptorMutation_Direction int32

const (
	// Not used.
	DescriptorMutation_NONE DescriptorMutation_Direction = 0
	// Descriptor is being added.
	DescriptorMutation_ADD DescriptorMutation_Direction = 1
	// Descriptor is being dropped.
	DescriptorMutation_DROP DescriptorMutation_Direction = 2
)

var DescriptorMutation_Direction_name = map[int32]string{
	0: "NONE",
	1: "ADD",
	2: "DROP",
}
var DescriptorMutation_Direction_value = map[string]int32{
	"NONE": 0,
	"ADD":  1,
	"DROP": 2,
}

func (x DescriptorMutation_Direction) Enum() *DescriptorMutation_Direction {
	p := new(DescriptorMutation_Direction)
	*p = x
	return p
}
func (x DescriptorMutation_Direction) String() string {
	return proto.EnumName(DescriptorMutation_Direction_name, int32(x))
}
func (x *DescriptorMutation_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DescriptorMutation_Direction_value, data, "DescriptorMutation_Direction")
	if err != nil {
		return err
	}
	*x = DescriptorMutation_Direction(value)
	return nil
}
func (DescriptorMutation_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{6, 1}
}

// State is set if this TableDescriptor is in the process of being added or deleted.
// A non-public table descriptor cannot be leased.
// A schema changer observing DROP set will truncate the table and delete the
// descriptor.
// It is illegal to transition DROP to any other state.
type TableDescriptor_State int32

const (
	// Not used.
	TableDescriptor_PUBLIC TableDescriptor_State = 0
	// Descriptor is being added.
	TableDescriptor_ADD TableDescriptor_State = 1
	// Descriptor is being dropped.
	TableDescriptor_DROP TableDescriptor_State = 2
)

var TableDescriptor_State_name = map[int32]string{
	0: "PUBLIC",
	1: "ADD",
	2: "DROP",
}
var TableDescriptor_State_value = map[string]int32{
	"PUBLIC": 0,
	"ADD":    1,
	"DROP":   2,
}

func (x TableDescriptor_State) Enum() *TableDescriptor_State {
	p := new(TableDescriptor_State)
	*p = x
	return p
}
func (x TableDescriptor_State) String() string {
	return proto.EnumName(TableDescriptor_State_name, int32(x))
}
func (x *TableDescriptor_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TableDescriptor_State_value, data, "TableDescriptor_State")
	if err != nil {
		return err
	}
	*x = TableDescriptor_State(value)
	return nil
}
func (TableDescriptor_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{7, 0}
}

type ColumnType struct {
	Kind ColumnType_Kind `protobuf:"varint,1,opt,name=kind,enum=cockroach.sql.sqlbase.ColumnType_Kind" json:"kind"`
	// BIT, INT, FLOAT, DECIMAL, CHAR and BINARY
	Width int32 `protobuf:"varint,2,opt,name=width" json:"width"`
	// FLOAT and DECIMAL.
	Precision int32 `protobuf:"varint,3,opt,name=precision" json:"precision"`
}

func (m *ColumnType) Reset()                    { *m = ColumnType{} }
func (m *ColumnType) String() string            { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()               {}
func (*ColumnType) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{0} }

type ForeignKeyReference struct {
	Table ID      `protobuf:"varint,1,opt,name=table,casttype=ID" json:"table"`
	Index IndexID `protobuf:"varint,2,opt,name=index,casttype=IndexID" json:"index"`
	Name  string  `protobuf:"bytes,3,opt,name=name" json:"name"`
}

func (m *ForeignKeyReference) Reset()                    { *m = ForeignKeyReference{} }
func (m *ForeignKeyReference) String() string            { return proto.CompactTextString(m) }
func (*ForeignKeyReference) ProtoMessage()               {}
func (*ForeignKeyReference) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{1} }

type ColumnDescriptor struct {
	Name                   string     `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID                     ColumnID   `protobuf:"varint,2,opt,name=id,casttype=ColumnID" json:"id"`
	Type                   ColumnType `protobuf:"bytes,3,opt,name=type" json:"type"`
	Nullable               bool       `protobuf:"varint,4,opt,name=nullable" json:"nullable"`
	NullableConstraintName string     `protobuf:"bytes,8,opt,name=nullable_constraint_name,json=nullableConstraintName" json:"nullable_constraint_name"`
	// Default expression to use to populate the column on insert if no
	// value is provided.
	DefaultExpr               *string `protobuf:"bytes,5,opt,name=default_expr,json=defaultExpr" json:"default_expr,omitempty"`
	DefaultExprConstraintName string  `protobuf:"bytes,9,opt,name=default_expr_constraint_name,json=defaultExprConstraintName" json:"default_expr_constraint_name"`
	Hidden                    bool    `protobuf:"varint,6,opt,name=hidden" json:"hidden"`
}

func (m *ColumnDescriptor) Reset()                    { *m = ColumnDescriptor{} }
func (m *ColumnDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ColumnDescriptor) ProtoMessage()               {}
func (*ColumnDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{2} }

// ColumnFamilyDescriptor is set of columns stored together in one kv entry.
type ColumnFamilyDescriptor struct {
	Name string   `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID   FamilyID `protobuf:"varint,2,opt,name=id,casttype=FamilyID" json:"id"`
	// A list of column names of which the family is comprised. This list
	// parallels the column_ids list. If duplicating the storage of the column
	// names here proves to be prohibitive, we could clear this field before
	// saving and reconstruct it after loading.
	ColumnNames []string `protobuf:"bytes,3,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
	// A list of column ids of which the family is comprised. This list parallels
	// the column_names list.
	ColumnIDs []ColumnID `protobuf:"varint,4,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
	// If nonzero, the column involved in the single column optimization.
	//
	// Families store colums in a ValueType_TUPLE as repeated <colid><data>
	// entries. As a space optimization and for backward compatibility, a single
	// column is written without the columnid prefix. Because more columns could
	// be added, it would be ambiguous which column was stored when read back in,
	// so this field supplies it.
	DefaultColumnID ColumnID `protobuf:"varint,5,opt,name=default_column_id,json=defaultColumnId,casttype=ColumnID" json:"default_column_id"`
}

func (m *ColumnFamilyDescriptor) Reset()                    { *m = ColumnFamilyDescriptor{} }
func (m *ColumnFamilyDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ColumnFamilyDescriptor) ProtoMessage()               {}
func (*ColumnFamilyDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{3} }

// InterleaveDescriptor represents an index (either primary or secondary) that
// is interleaved into another table's data.
//
// Example:
// Table 1 -> /a/b
// Table 2 -> /a/b/c
// Table 3 -> /a/b/c/d
//
// There are two components (table 2 is the parent and table 1 is the
// grandparent) with shared lengths 2 and 1.
type InterleaveDescriptor struct {
	// Ancestors contains the nesting of interleaves in the order they appear in
	// an encoded key. This means they are always in the far-to-near ancestor
	// order (e.g. grand-grand-parent, grand-parent, parent).
	Ancestors []InterleaveDescriptor_Ancestor `protobuf:"bytes,1,rep,name=ancestors" json:"ancestors"`
}

func (m *InterleaveDescriptor) Reset()                    { *m = InterleaveDescriptor{} }
func (m *InterleaveDescriptor) String() string            { return proto.CompactTextString(m) }
func (*InterleaveDescriptor) ProtoMessage()               {}
func (*InterleaveDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{4} }

type InterleaveDescriptor_Ancestor struct {
	// TableID the ID of the table being interleaved into.
	TableID ID `protobuf:"varint,1,opt,name=table_id,json=tableId,casttype=ID" json:"table_id"`
	// IndexID is the ID of the parent index being interleaved into.
	IndexID IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,casttype=IndexID" json:"index_id"`
	// SharedPrefixLen is how many fields are shared between a parent and child
	// being interleaved, excluding any fields shared between parent and
	// grandparent. Thus, the sum of SharedPrefixLens in the components of an
	// InterleaveDescriptor is always strictly less than the number of fields
	// in the index being interleaved.
	SharedPrefixLen uint32 `protobuf:"varint,3,opt,name=shared_prefix_len,json=sharedPrefixLen" json:"shared_prefix_len"`
}

func (m *InterleaveDescriptor_Ancestor) Reset()         { *m = InterleaveDescriptor_Ancestor{} }
func (m *InterleaveDescriptor_Ancestor) String() string { return proto.CompactTextString(m) }
func (*InterleaveDescriptor_Ancestor) ProtoMessage()    {}
func (*InterleaveDescriptor_Ancestor) Descriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{4, 0}
}

type IndexDescriptor struct {
	Name   string  `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID     IndexID `protobuf:"varint,2,opt,name=id,casttype=IndexID" json:"id"`
	Unique bool    `protobuf:"varint,3,opt,name=unique" json:"unique"`
	// An ordered list of column names of which the index is comprised. This list
	// parallels the column_ids list. If duplicating the storage of the column
	// names here proves to be prohibitive, we could clear this field before
	// saving and reconstruct it after loading.
	ColumnNames []string `protobuf:"bytes,4,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
	// Parallel with column_names - the sort direction of each column.
	ColumnDirections []IndexDescriptor_Direction `protobuf:"varint,8,rep,name=column_directions,json=columnDirections,enum=cockroach.sql.sqlbase.IndexDescriptor_Direction" json:"column_directions,omitempty"`
	// An ordered list of column names which the index stores in
	// addition to the columns which are explicitly part of the index.
	StoreColumnNames []string `protobuf:"bytes,5,rep,name=store_column_names,json=storeColumnNames" json:"store_column_names,omitempty"`
	// An ordered list of column ids of which the index is comprised. This list
	// parallels the column_names list.
	ColumnIDs []ColumnID `protobuf:"varint,6,rep,name=column_ids,json=columnIds,casttype=ColumnID" json:"column_ids,omitempty"`
	// An ordered list of implicit column ids associated with the index. For
	// non-unique indexes, these columns will be appended to the key. For unique
	// indexes these columns will be stored in the value. The extra column IDs is
	// computed as PrimaryIndex.column_ids - column_ids. For the primary index
	// the list will be empty.
	// The distinction about whether the columns are written in the key or the value
	// comes because we want to always do writes using a single operation - this
	// way for unique indexes we can do a conditional put on the key.
	ImplicitColumnIDs []ColumnID            `protobuf:"varint,7,rep,name=implicit_column_ids,json=implicitColumnIds,casttype=ColumnID" json:"implicit_column_ids,omitempty"`
	ForeignKey        ForeignKeyReference   `protobuf:"bytes,9,opt,name=foreign_key,json=foreignKey" json:"foreign_key"`
	ReferencedBy      []ForeignKeyReference `protobuf:"bytes,10,rep,name=referenced_by,json=referencedBy" json:"referenced_by"`
	// Interleave, if it's not the zero value, describes how this index's data is
	// interleaved into another index's data.
	Interleave InterleaveDescriptor `protobuf:"bytes,11,opt,name=interleave" json:"interleave"`
	// InterleavedBy contains a reference to every table/index that is interleaved
	// into this one.
	InterleavedBy []ForeignKeyReference `protobuf:"bytes,12,rep,name=interleaved_by,json=interleavedBy" json:"interleaved_by"`
}

func (m *IndexDescriptor) Reset()                    { *m = IndexDescriptor{} }
func (m *IndexDescriptor) String() string            { return proto.CompactTextString(m) }
func (*IndexDescriptor) ProtoMessage()               {}
func (*IndexDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{5} }

// A DescriptorMutation represents a column or an index that
// has either been added or dropped and hasn't yet transitioned
// into a stable state: completely backfilled and visible, or
// completely deleted. A table descriptor in the middle of a
// schema change will have a DescriptorMutation FIFO queue
// containing each column/index descriptor being added or dropped.
type DescriptorMutation struct {
	// Types that are valid to be assigned to Descriptor_:
	//	*DescriptorMutation_Column
	//	*DescriptorMutation_Index
	Descriptor_ isDescriptorMutation_Descriptor_ `protobuf_oneof:"descriptor"`
	State       DescriptorMutation_State         `protobuf:"varint,3,opt,name=state,enum=cockroach.sql.sqlbase.DescriptorMutation_State" json:"state"`
	Direction   DescriptorMutation_Direction     `protobuf:"varint,4,opt,name=direction,enum=cockroach.sql.sqlbase.DescriptorMutation_Direction" json:"direction"`
	// The mutation id used to group mutations that should be applied together.
	// This is used for situations like creating a unique column, which
	// involve adding two mutations: one for the column, and another for the
	// unique constraint index.
	MutationID MutationID `protobuf:"varint,5,opt,name=mutation_id,json=mutationId,casttype=MutationID" json:"mutation_id"`
}

func (m *DescriptorMutation) Reset()                    { *m = DescriptorMutation{} }
func (m *DescriptorMutation) String() string            { return proto.CompactTextString(m) }
func (*DescriptorMutation) ProtoMessage()               {}
func (*DescriptorMutation) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{6} }

type isDescriptorMutation_Descriptor_ interface {
	isDescriptorMutation_Descriptor_()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DescriptorMutation_Column struct {
	Column *ColumnDescriptor `protobuf:"bytes,1,opt,name=column,oneof"`
}
type DescriptorMutation_Index struct {
	Index *IndexDescriptor `protobuf:"bytes,2,opt,name=index,oneof"`
}

func (*DescriptorMutation_Column) isDescriptorMutation_Descriptor_() {}
func (*DescriptorMutation_Index) isDescriptorMutation_Descriptor_()  {}

func (m *DescriptorMutation) GetDescriptor_() isDescriptorMutation_Descriptor_ {
	if m != nil {
		return m.Descriptor_
	}
	return nil
}

func (m *DescriptorMutation) GetColumn() *ColumnDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Column); ok {
		return x.Column
	}
	return nil
}

func (m *DescriptorMutation) GetIndex() *IndexDescriptor {
	if x, ok := m.GetDescriptor_().(*DescriptorMutation_Index); ok {
		return x.Index
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DescriptorMutation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DescriptorMutation_OneofMarshaler, _DescriptorMutation_OneofUnmarshaler, _DescriptorMutation_OneofSizer, []interface{}{
		(*DescriptorMutation_Column)(nil),
		(*DescriptorMutation_Index)(nil),
	}
}

func _DescriptorMutation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DescriptorMutation)
	// descriptor
	switch x := m.Descriptor_.(type) {
	case *DescriptorMutation_Column:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Column); err != nil {
			return err
		}
	case *DescriptorMutation_Index:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Index); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DescriptorMutation.Descriptor_ has unexpected type %T", x)
	}
	return nil
}

func _DescriptorMutation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DescriptorMutation)
	switch tag {
	case 1: // descriptor.column
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColumnDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Column{msg}
		return true, err
	case 2: // descriptor.index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IndexDescriptor)
		err := b.DecodeMessage(msg)
		m.Descriptor_ = &DescriptorMutation_Index{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DescriptorMutation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DescriptorMutation)
	// descriptor
	switch x := m.Descriptor_.(type) {
	case *DescriptorMutation_Column:
		s := proto.Size(x.Column)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DescriptorMutation_Index:
		s := proto.Size(x.Index)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A TableDescriptor represents a table and is stored in a structured metadata
// key. The TableDescriptor has a globally-unique ID, while its member
// {Column,Index}Descriptors have locally-unique IDs.
type TableDescriptor struct {
	// The table name. It should be normalized using sqlbase.NormalizeName()
	// before comparing it.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID   ID     `protobuf:"varint,3,opt,name=id,casttype=ID" json:"id"`
	// ID of the parent database.
	ParentID ID `protobuf:"varint,4,opt,name=parent_id,json=parentId,casttype=ID" json:"parent_id"`
	// Monotonically increasing version of the table descriptor.
	//
	// Invariants:
	// 1. not more than two subsequent versions of the table
	// descriptor can be leased. This is to make the system
	// easy to reason about, by permiting mutation state
	// changes (reflected in the next version), only when the existing
	// state (reflected in the current version) is present on all
	// outstanding unexpired leases.
	// 2. A schema change command (ALTER, RENAME, etc) never directly
	// increments the version. This allows the command to execute without
	// waiting for the entire cluster to converge to a single version
	// preventing weird deadlock situations. For instance, a transaction
	// with a schema change command might use a descriptor lease that is
	// at version: v - 1, and therefore deadlock when it tries to wait
	// for version: v, in the process of incrementing it to v + 1.
	// Therefore, a schema change command never increments the version,
	// and instead, sets the up_version boolean to notify the schema
	// changer execution engine that runs a future transaction to
	// increment the version.
	//
	// The schema change commands must therefore make *safe* modifications
	// to the table descriptor, such as scheduling long running schema
	// changes through mutations for future execution, or making simple
	// schema changes like RENAME that only modify the table descriptor in a
	// single transaction.
	//
	// Multiple schema changes in the same transaction set up_version.
	// The actual schema change execution that follows a schema change
	// command sees the up_version boolean set, and increments the
	// table version after ensuring that there are no unexpired leases
	// for version - 1. The schema change execution must increment
	// the version before executing future state changes, to ensure
	// that the scheduled mutations made by the original commands are
	// visible on all leases. Multiple schema change mutations can be
	// grouped together on a particular version increment.
	//
	// If schema change commands are safe to run without incrementing
	// the version, why do it later on? We increment the version
	// to ensure that all the nodes renew their leases with the new version
	// and get to see what the schema change command has done quickly.
	Version DescriptorVersion `protobuf:"varint,5,opt,name=version,casttype=DescriptorVersion" json:"version"`
	// See comment above.
	UpVersion bool `protobuf:"varint,6,opt,name=up_version,json=upVersion" json:"up_version"`
	// Last modification time of the table descriptor.
	ModificationTime cockroach_util_hlc.Timestamp `protobuf:"bytes,7,opt,name=modification_time,json=modificationTime" json:"modification_time"`
	Columns          []ColumnDescriptor           `protobuf:"bytes,8,rep,name=columns" json:"columns"`
	// next_column_id is used to ensure that deleted column ids are not reused.
	NextColumnID ColumnID                 `protobuf:"varint,9,opt,name=next_column_id,json=nextColumnId,casttype=ColumnID" json:"next_column_id"`
	Families     []ColumnFamilyDescriptor `protobuf:"bytes,22,rep,name=families" json:"families"`
	// next_family_id is used to ensure that deleted family ids are not reused.
	NextFamilyID FamilyID        `protobuf:"varint,23,opt,name=next_family_id,json=nextFamilyId,casttype=FamilyID" json:"next_family_id"`
	PrimaryIndex IndexDescriptor `protobuf:"bytes,10,opt,name=primary_index,json=primaryIndex" json:"primary_index"`
	// indexes are all the secondary indexes.
	Indexes []IndexDescriptor `protobuf:"bytes,11,rep,name=indexes" json:"indexes"`
	// next_index_id is used to ensure that deleted index ids are not reused.
	NextIndexID IndexID              `protobuf:"varint,12,opt,name=next_index_id,json=nextIndexId,casttype=IndexID" json:"next_index_id"`
	Privileges  *PrivilegeDescriptor `protobuf:"bytes,13,opt,name=privileges" json:"privileges,omitempty"`
	// Columns or indexes being added or deleted in a FIFO order.
	Mutations []DescriptorMutation               `protobuf:"bytes,14,rep,name=mutations" json:"mutations"`
	Lease     *TableDescriptor_SchemaChangeLease `protobuf:"bytes,15,opt,name=lease" json:"lease,omitempty"`
	// An id for the next group of mutations to be applied together.
	NextMutationID MutationID `protobuf:"varint,16,opt,name=next_mutation_id,json=nextMutationId,casttype=MutationID" json:"next_mutation_id"`
	// format_version declares which sql to key:value mapping is being used to
	// represent the data in this table.
	FormatVersion FormatVersion                      `protobuf:"varint,17,opt,name=format_version,json=formatVersion,casttype=FormatVersion" json:"format_version"`
	State         TableDescriptor_State              `protobuf:"varint,19,opt,name=state,enum=cockroach.sql.sqlbase.TableDescriptor_State" json:"state"`
	Checks        []*TableDescriptor_CheckConstraint `protobuf:"bytes,20,rep,name=checks" json:"checks,omitempty"`
	// This array is populated if the descriptor was renamed. If the descriptor is
	// renamed multiple times before the schema chage is processed, there will be
	// one element for each rename.
	// When this is detected in a schema change, the records for the old names are
	// deleted and this field is cleared.
	Renames []TableDescriptor_RenameInfo `protobuf:"bytes,21,rep,name=renames" json:"renames"`
}

func (m *TableDescriptor) Reset()                    { *m = TableDescriptor{} }
func (m *TableDescriptor) String() string            { return proto.CompactTextString(m) }
func (*TableDescriptor) ProtoMessage()               {}
func (*TableDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{7} }

func (m *TableDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TableDescriptor) GetParentID() ID {
	if m != nil {
		return m.ParentID
	}
	return 0
}

func (m *TableDescriptor) GetVersion() DescriptorVersion {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDescriptor) GetUpVersion() bool {
	if m != nil {
		return m.UpVersion
	}
	return false
}

func (m *TableDescriptor) GetModificationTime() cockroach_util_hlc.Timestamp {
	if m != nil {
		return m.ModificationTime
	}
	return cockroach_util_hlc.Timestamp{}
}

func (m *TableDescriptor) GetColumns() []ColumnDescriptor {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableDescriptor) GetNextColumnID() ColumnID {
	if m != nil {
		return m.NextColumnID
	}
	return 0
}

func (m *TableDescriptor) GetFamilies() []ColumnFamilyDescriptor {
	if m != nil {
		return m.Families
	}
	return nil
}

func (m *TableDescriptor) GetNextFamilyID() FamilyID {
	if m != nil {
		return m.NextFamilyID
	}
	return 0
}

func (m *TableDescriptor) GetPrimaryIndex() IndexDescriptor {
	if m != nil {
		return m.PrimaryIndex
	}
	return IndexDescriptor{}
}

func (m *TableDescriptor) GetIndexes() []IndexDescriptor {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDescriptor) GetNextIndexID() IndexID {
	if m != nil {
		return m.NextIndexID
	}
	return 0
}

func (m *TableDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *TableDescriptor) GetMutations() []DescriptorMutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *TableDescriptor) GetLease() *TableDescriptor_SchemaChangeLease {
	if m != nil {
		return m.Lease
	}
	return nil
}

func (m *TableDescriptor) GetNextMutationID() MutationID {
	if m != nil {
		return m.NextMutationID
	}
	return 0
}

func (m *TableDescriptor) GetFormatVersion() FormatVersion {
	if m != nil {
		return m.FormatVersion
	}
	return 0
}

func (m *TableDescriptor) GetState() TableDescriptor_State {
	if m != nil {
		return m.State
	}
	return TableDescriptor_PUBLIC
}

func (m *TableDescriptor) GetChecks() []*TableDescriptor_CheckConstraint {
	if m != nil {
		return m.Checks
	}
	return nil
}

func (m *TableDescriptor) GetRenames() []TableDescriptor_RenameInfo {
	if m != nil {
		return m.Renames
	}
	return nil
}

// The schema update lease. A single goroutine across a cockroach cluster
// can own it, and will execute pending schema changes for this table.
// Since the execution of a pending schema change is through transactions,
// it is legal for more than one goroutine to attempt to execute it. This
// lease reduces write contention on the schema change.
type TableDescriptor_SchemaChangeLease struct {
	NodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"node_id"`
	// Nanoseconds since the Unix epoch.
	ExpirationTime int64 `protobuf:"varint,2,opt,name=expiration_time,json=expirationTime" json:"expiration_time"`
}

func (m *TableDescriptor_SchemaChangeLease) Reset()         { *m = TableDescriptor_SchemaChangeLease{} }
func (m *TableDescriptor_SchemaChangeLease) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_SchemaChangeLease) ProtoMessage()    {}
func (*TableDescriptor_SchemaChangeLease) Descriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{7, 0}
}

type TableDescriptor_CheckConstraint struct {
	Expr string `protobuf:"bytes,1,opt,name=expr" json:"expr"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
}

func (m *TableDescriptor_CheckConstraint) Reset()         { *m = TableDescriptor_CheckConstraint{} }
func (m *TableDescriptor_CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_CheckConstraint) ProtoMessage()    {}
func (*TableDescriptor_CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{7, 1}
}

type TableDescriptor_RenameInfo struct {
	// The database that the table belonged to before the rename (tables can be
	// renamed from one db to another).
	OldParentID ID     `protobuf:"varint,1,opt,name=old_parent_id,json=oldParentId,casttype=ID" json:"old_parent_id"`
	OldName     string `protobuf:"bytes,2,opt,name=old_name,json=oldName" json:"old_name"`
}

func (m *TableDescriptor_RenameInfo) Reset()         { *m = TableDescriptor_RenameInfo{} }
func (m *TableDescriptor_RenameInfo) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor_RenameInfo) ProtoMessage()    {}
func (*TableDescriptor_RenameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorStructured, []int{7, 2}
}

// DatabaseDescriptor represents a namespace (aka database) and is stored
// in a structured metadata key. The DatabaseDescriptor has a globally-unique
// ID shared with the TableDescriptor ID.
// Permissions are applied to all tables in the namespace.
type DatabaseDescriptor struct {
	Name       string               `protobuf:"bytes,1,opt,name=name" json:"name"`
	ID         ID                   `protobuf:"varint,2,opt,name=id,casttype=ID" json:"id"`
	Privileges *PrivilegeDescriptor `protobuf:"bytes,3,opt,name=privileges" json:"privileges,omitempty"`
}

func (m *DatabaseDescriptor) Reset()                    { *m = DatabaseDescriptor{} }
func (m *DatabaseDescriptor) String() string            { return proto.CompactTextString(m) }
func (*DatabaseDescriptor) ProtoMessage()               {}
func (*DatabaseDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{8} }

func (m *DatabaseDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseDescriptor) GetID() ID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DatabaseDescriptor) GetPrivileges() *PrivilegeDescriptor {
	if m != nil {
		return m.Privileges
	}
	return nil
}

// Descriptor is a union type holding either a table or database descriptor.
type Descriptor struct {
	// Types that are valid to be assigned to Union:
	//	*Descriptor_Table
	//	*Descriptor_Database
	Union isDescriptor_Union `protobuf_oneof:"union"`
}

func (m *Descriptor) Reset()                    { *m = Descriptor{} }
func (m *Descriptor) String() string            { return proto.CompactTextString(m) }
func (*Descriptor) ProtoMessage()               {}
func (*Descriptor) Descriptor() ([]byte, []int) { return fileDescriptorStructured, []int{9} }

type isDescriptor_Union interface {
	isDescriptor_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Descriptor_Table struct {
	Table *TableDescriptor `protobuf:"bytes,1,opt,name=table,oneof"`
}
type Descriptor_Database struct {
	Database *DatabaseDescriptor `protobuf:"bytes,2,opt,name=database,oneof"`
}

func (*Descriptor_Table) isDescriptor_Union()    {}
func (*Descriptor_Database) isDescriptor_Union() {}

func (m *Descriptor) GetUnion() isDescriptor_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Descriptor) GetTable() *TableDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Table); ok {
		return x.Table
	}
	return nil
}

func (m *Descriptor) GetDatabase() *DatabaseDescriptor {
	if x, ok := m.GetUnion().(*Descriptor_Database); ok {
		return x.Database
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Descriptor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Descriptor_OneofMarshaler, _Descriptor_OneofUnmarshaler, _Descriptor_OneofSizer, []interface{}{
		(*Descriptor_Table)(nil),
		(*Descriptor_Database)(nil),
	}
}

func _Descriptor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Descriptor)
	// union
	switch x := m.Union.(type) {
	case *Descriptor_Table:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Table); err != nil {
			return err
		}
	case *Descriptor_Database:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Database); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Descriptor.Union has unexpected type %T", x)
	}
	return nil
}

func _Descriptor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Descriptor)
	switch tag {
	case 1: // union.table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TableDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Table{msg}
		return true, err
	case 2: // union.database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DatabaseDescriptor)
		err := b.DecodeMessage(msg)
		m.Union = &Descriptor_Database{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Descriptor_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Descriptor)
	// union
	switch x := m.Union.(type) {
	case *Descriptor_Table:
		s := proto.Size(x.Table)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Descriptor_Database:
		s := proto.Size(x.Database)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ColumnType)(nil), "cockroach.sql.sqlbase.ColumnType")
	proto.RegisterType((*ForeignKeyReference)(nil), "cockroach.sql.sqlbase.ForeignKeyReference")
	proto.RegisterType((*ColumnDescriptor)(nil), "cockroach.sql.sqlbase.ColumnDescriptor")
	proto.RegisterType((*ColumnFamilyDescriptor)(nil), "cockroach.sql.sqlbase.ColumnFamilyDescriptor")
	proto.RegisterType((*InterleaveDescriptor)(nil), "cockroach.sql.sqlbase.InterleaveDescriptor")
	proto.RegisterType((*InterleaveDescriptor_Ancestor)(nil), "cockroach.sql.sqlbase.InterleaveDescriptor.Ancestor")
	proto.RegisterType((*IndexDescriptor)(nil), "cockroach.sql.sqlbase.IndexDescriptor")
	proto.RegisterType((*DescriptorMutation)(nil), "cockroach.sql.sqlbase.DescriptorMutation")
	proto.RegisterType((*TableDescriptor)(nil), "cockroach.sql.sqlbase.TableDescriptor")
	proto.RegisterType((*TableDescriptor_SchemaChangeLease)(nil), "cockroach.sql.sqlbase.TableDescriptor.SchemaChangeLease")
	proto.RegisterType((*TableDescriptor_CheckConstraint)(nil), "cockroach.sql.sqlbase.TableDescriptor.CheckConstraint")
	proto.RegisterType((*TableDescriptor_RenameInfo)(nil), "cockroach.sql.sqlbase.TableDescriptor.RenameInfo")
	proto.RegisterType((*DatabaseDescriptor)(nil), "cockroach.sql.sqlbase.DatabaseDescriptor")
	proto.RegisterType((*Descriptor)(nil), "cockroach.sql.sqlbase.Descriptor")
	proto.RegisterEnum("cockroach.sql.sqlbase.ColumnType_Kind", ColumnType_Kind_name, ColumnType_Kind_value)
	proto.RegisterEnum("cockroach.sql.sqlbase.IndexDescriptor_Direction", IndexDescriptor_Direction_name, IndexDescriptor_Direction_value)
	proto.RegisterEnum("cockroach.sql.sqlbase.DescriptorMutation_State", DescriptorMutation_State_name, DescriptorMutation_State_value)
	proto.RegisterEnum("cockroach.sql.sqlbase.DescriptorMutation_Direction", DescriptorMutation_Direction_name, DescriptorMutation_Direction_value)
	proto.RegisterEnum("cockroach.sql.sqlbase.TableDescriptor_State", TableDescriptor_State_name, TableDescriptor_State_value)
}
func (m *ColumnType) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnType) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.Kind))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.Width))
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.Precision))
	return i, nil
}

func (m *ForeignKeyReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ForeignKeyReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.Table))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.Index))
	data[i] = 0x1a
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	return i, nil
}

func (m *ColumnDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x1a
	i++
	i = encodeVarintStructured(data, i, uint64(m.Type.Size()))
	n1, err := m.Type.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	data[i] = 0x20
	i++
	if m.Nullable {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.DefaultExpr != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintStructured(data, i, uint64(len(*m.DefaultExpr)))
		i += copy(data[i:], *m.DefaultExpr)
	}
	data[i] = 0x30
	i++
	if m.Hidden {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x42
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.NullableConstraintName)))
	i += copy(data[i:], m.NullableConstraintName)
	data[i] = 0x4a
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.DefaultExprConstraintName)))
	i += copy(data[i:], m.DefaultExprConstraintName)
	return i, nil
}

func (m *ColumnFamilyDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ColumnFamilyDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			data[i] = 0x20
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	data[i] = 0x28
	i++
	i = encodeVarintStructured(data, i, uint64(m.DefaultColumnID))
	return i, nil
}

func (m *InterleaveDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InterleaveDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ancestors) > 0 {
		for _, msg := range m.Ancestors {
			data[i] = 0xa
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterleaveDescriptor_Ancestor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InterleaveDescriptor_Ancestor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.TableID))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.IndexID))
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.SharedPrefixLen))
	return i, nil
}

func (m *IndexDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IndexDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x18
	i++
	if m.Unique {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, num := range m.ColumnIDs {
			data[i] = 0x30
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	if len(m.ImplicitColumnIDs) > 0 {
		for _, num := range m.ImplicitColumnIDs {
			data[i] = 0x38
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	if len(m.ColumnDirections) > 0 {
		for _, num := range m.ColumnDirections {
			data[i] = 0x40
			i++
			i = encodeVarintStructured(data, i, uint64(num))
		}
	}
	data[i] = 0x4a
	i++
	i = encodeVarintStructured(data, i, uint64(m.ForeignKey.Size()))
	n2, err := m.ForeignKey.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.ReferencedBy) > 0 {
		for _, msg := range m.ReferencedBy {
			data[i] = 0x52
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x5a
	i++
	i = encodeVarintStructured(data, i, uint64(m.Interleave.Size()))
	n3, err := m.Interleave.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.InterleavedBy) > 0 {
		for _, msg := range m.InterleavedBy {
			data[i] = 0x62
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DescriptorMutation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescriptorMutation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Descriptor_ != nil {
		nn4, err := m.Descriptor_.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.State))
	data[i] = 0x20
	i++
	i = encodeVarintStructured(data, i, uint64(m.Direction))
	data[i] = 0x28
	i++
	i = encodeVarintStructured(data, i, uint64(m.MutationID))
	return i, nil
}

func (m *DescriptorMutation_Column) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Column != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStructured(data, i, uint64(m.Column.Size()))
		n5, err := m.Column.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *DescriptorMutation_Index) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Index != nil {
		data[i] = 0x12
		i++
		i = encodeVarintStructured(data, i, uint64(m.Index.Size()))
		n6, err := m.Index.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *TableDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x18
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	data[i] = 0x20
	i++
	i = encodeVarintStructured(data, i, uint64(m.ParentID))
	data[i] = 0x28
	i++
	i = encodeVarintStructured(data, i, uint64(m.Version))
	data[i] = 0x30
	i++
	if m.UpVersion {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x3a
	i++
	i = encodeVarintStructured(data, i, uint64(m.ModificationTime.Size()))
	n7, err := m.ModificationTime.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x42
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x48
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextColumnID))
	data[i] = 0x52
	i++
	i = encodeVarintStructured(data, i, uint64(m.PrimaryIndex.Size()))
	n8, err := m.PrimaryIndex.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			data[i] = 0x5a
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x60
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextIndexID))
	if m.Privileges != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Privileges.Size()))
		n9, err := m.Privileges.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			data[i] = 0x72
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lease != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Lease.Size()))
		n10, err := m.Lease.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	data[i] = 0x80
	i++
	data[i] = 0x1
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextMutationID))
	data[i] = 0x88
	i++
	data[i] = 0x1
	i++
	i = encodeVarintStructured(data, i, uint64(m.FormatVersion))
	data[i] = 0x98
	i++
	data[i] = 0x1
	i++
	i = encodeVarintStructured(data, i, uint64(m.State))
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			data[i] = 0xa2
			i++
			data[i] = 0x1
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Renames) > 0 {
		for _, msg := range m.Renames {
			data[i] = 0xaa
			i++
			data[i] = 0x1
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Families) > 0 {
		for _, msg := range m.Families {
			data[i] = 0xb2
			i++
			data[i] = 0x1
			i++
			i = encodeVarintStructured(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0xb8
	i++
	data[i] = 0x1
	i++
	i = encodeVarintStructured(data, i, uint64(m.NextFamilyID))
	return i, nil
}

func (m *TableDescriptor_SchemaChangeLease) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor_SchemaChangeLease) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.NodeID))
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ExpirationTime))
	return i, nil
}

func (m *TableDescriptor_CheckConstraint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor_CheckConstraint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Expr)))
	i += copy(data[i:], m.Expr)
	data[i] = 0x12
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	return i, nil
}

func (m *TableDescriptor_RenameInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDescriptor_RenameInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintStructured(data, i, uint64(m.OldParentID))
	data[i] = 0x12
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.OldName)))
	i += copy(data[i:], m.OldName)
	return i, nil
}

func (m *DatabaseDescriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabaseDescriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintStructured(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x10
	i++
	i = encodeVarintStructured(data, i, uint64(m.ID))
	if m.Privileges != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintStructured(data, i, uint64(m.Privileges.Size()))
		n11, err := m.Privileges.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *Descriptor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Descriptor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		nn12, err := m.Union.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *Descriptor_Table) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Table != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStructured(data, i, uint64(m.Table.Size()))
		n13, err := m.Table.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Descriptor_Database) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Database != nil {
		data[i] = 0x12
		i++
		i = encodeVarintStructured(data, i, uint64(m.Database.Size()))
		n14, err := m.Database.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func encodeFixed64Structured(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Structured(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStructured(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *ColumnType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.Kind))
	n += 1 + sovStructured(uint64(m.Width))
	n += 1 + sovStructured(uint64(m.Precision))
	return n
}

func (m *ForeignKeyReference) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.Table))
	n += 1 + sovStructured(uint64(m.Index))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *ColumnDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	l = m.Type.Size()
	n += 1 + l + sovStructured(uint64(l))
	n += 2
	if m.DefaultExpr != nil {
		l = len(*m.DefaultExpr)
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 2
	l = len(m.NullableConstraintName)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.DefaultExprConstraintName)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *ColumnFamilyDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	n += 1 + sovStructured(uint64(m.DefaultColumnID))
	return n
}

func (m *InterleaveDescriptor) Size() (n int) {
	var l int
	_ = l
	if len(m.Ancestors) > 0 {
		for _, e := range m.Ancestors {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *InterleaveDescriptor_Ancestor) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.TableID))
	n += 1 + sovStructured(uint64(m.IndexID))
	n += 1 + sovStructured(uint64(m.SharedPrefixLen))
	return n
}

func (m *IndexDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 2
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.StoreColumnNames) > 0 {
		for _, s := range m.StoreColumnNames {
			l = len(s)
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if len(m.ColumnIDs) > 0 {
		for _, e := range m.ColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ImplicitColumnIDs) > 0 {
		for _, e := range m.ImplicitColumnIDs {
			n += 1 + sovStructured(uint64(e))
		}
	}
	if len(m.ColumnDirections) > 0 {
		for _, e := range m.ColumnDirections {
			n += 1 + sovStructured(uint64(e))
		}
	}
	l = m.ForeignKey.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.ReferencedBy) > 0 {
		for _, e := range m.ReferencedBy {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	l = m.Interleave.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.InterleavedBy) > 0 {
		for _, e := range m.InterleavedBy {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	return n
}

func (m *DescriptorMutation) Size() (n int) {
	var l int
	_ = l
	if m.Descriptor_ != nil {
		n += m.Descriptor_.Size()
	}
	n += 1 + sovStructured(uint64(m.State))
	n += 1 + sovStructured(uint64(m.Direction))
	n += 1 + sovStructured(uint64(m.MutationID))
	return n
}

func (m *DescriptorMutation_Column) Size() (n int) {
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *DescriptorMutation_Index) Size() (n int) {
	var l int
	_ = l
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *TableDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	n += 1 + sovStructured(uint64(m.ParentID))
	n += 1 + sovStructured(uint64(m.Version))
	n += 2
	l = m.ModificationTime.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextColumnID))
	l = m.PrimaryIndex.Size()
	n += 1 + l + sovStructured(uint64(l))
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	n += 1 + sovStructured(uint64(m.NextIndexID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovStructured(uint64(l))
		}
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	n += 2 + sovStructured(uint64(m.NextMutationID))
	n += 2 + sovStructured(uint64(m.FormatVersion))
	n += 2 + sovStructured(uint64(m.State))
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.Renames) > 0 {
		for _, e := range m.Renames {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	if len(m.Families) > 0 {
		for _, e := range m.Families {
			l = e.Size()
			n += 2 + l + sovStructured(uint64(l))
		}
	}
	n += 2 + sovStructured(uint64(m.NextFamilyID))
	return n
}

func (m *TableDescriptor_SchemaChangeLease) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.NodeID))
	n += 1 + sovStructured(uint64(m.ExpirationTime))
	return n
}

func (m *TableDescriptor_CheckConstraint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Expr)
	n += 1 + l + sovStructured(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *TableDescriptor_RenameInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovStructured(uint64(m.OldParentID))
	l = len(m.OldName)
	n += 1 + l + sovStructured(uint64(l))
	return n
}

func (m *DatabaseDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovStructured(uint64(l))
	n += 1 + sovStructured(uint64(m.ID))
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func (m *Descriptor) Size() (n int) {
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *Descriptor_Table) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}
func (m *Descriptor_Database) Size() (n int) {
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovStructured(uint64(l))
	}
	return n
}

func sovStructured(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStructured(x uint64) (n int) {
	return sovStructured(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ColumnType) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (ColumnType_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Table |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DefaultExpr = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullableConstraintName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NullableConstraintName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExprConstraintName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultExprConstraintName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnFamilyDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnFamilyDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnFamilyDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (FamilyID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
			var v ColumnID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColumnIDs = append(m.ColumnIDs, v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultColumnID", wireType)
			}
			m.DefaultColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefaultColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleaveDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterleaveDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterleaveDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ancestors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ancestors = append(m.Ancestors, InterleaveDescriptor_Ancestor{})
			if err := m.Ancestors[len(m.Ancestors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterleaveDescriptor_Ancestor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ancestor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ancestor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TableID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.IndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedPrefixLen", wireType)
			}
			m.SharedPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SharedPrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreColumnNames = append(m.StoreColumnNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
			var v ColumnID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColumnIDs = append(m.ColumnIDs, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitColumnIDs", wireType)
			}
			var v ColumnID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitColumnIDs = append(m.ImplicitColumnIDs, v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnDirections", wireType)
			}
			var v IndexDescriptor_Direction
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (IndexDescriptor_Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColumnDirections = append(m.ColumnDirections, v)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ForeignKey.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferencedBy = append(m.ReferencedBy, ForeignKeyReference{})
			if err := m.ReferencedBy[len(m.ReferencedBy)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interleave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Interleave.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterleavedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterleavedBy = append(m.InterleavedBy, ForeignKeyReference{})
			if err := m.InterleavedBy[len(m.InterleavedBy)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorMutation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorMutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorMutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Column{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Descriptor_ = &DescriptorMutation_Index{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (DescriptorMutation_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Direction |= (DescriptorMutation_Direction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutationID", wireType)
			}
			m.MutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (DescriptorVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpVersion = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModificationTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, ColumnDescriptor{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextColumnID", wireType)
			}
			m.NextColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextColumnID |= (ColumnID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryIndex.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, IndexDescriptor{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndexID", wireType)
			}
			m.NextIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextIndexID |= (IndexID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, DescriptorMutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &TableDescriptor_SchemaChangeLease{}
			}
			if err := m.Lease.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMutationID", wireType)
			}
			m.NextMutationID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextMutationID |= (MutationID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatVersion", wireType)
			}
			m.FormatVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FormatVersion |= (FormatVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (TableDescriptor_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &TableDescriptor_CheckConstraint{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Renames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Renames = append(m.Renames, TableDescriptor_RenameInfo{})
			if err := m.Renames[len(m.Renames)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Families", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Families = append(m.Families, ColumnFamilyDescriptor{})
			if err := m.Families[len(m.Families)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextFamilyID", wireType)
			}
			m.NextFamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextFamilyID |= (FamilyID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_SchemaChangeLease) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChangeLease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChangeLease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			m.ExpirationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpirationTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_CheckConstraint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor_RenameInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldParentID", wireType)
			}
			m.OldParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OldParentID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDescriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (ID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &PrivilegeDescriptor{}
			}
			if err := m.Privileges.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Descriptor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Descriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Descriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Table{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructured
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseDescriptor{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &Descriptor_Database{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructured(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStructured
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructured(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructured
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructured
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStructured
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStructured
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStructured(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStructured = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructured   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cockroach/sql/sqlbase/structured.proto", fileDescriptorStructured) }

var fileDescriptorStructured = []byte{
	// 1892 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x58, 0xcb, 0x72, 0xdb, 0xe6,
	0x15, 0x16, 0x78, 0x05, 0x0f, 0x45, 0x12, 0xfa, 0x7d, 0x09, 0xac, 0x71, 0x25, 0x9a, 0xa9, 0x5d,
	0xb5, 0x4d, 0xa8, 0x54, 0x69, 0x3a, 0x99, 0x5e, 0x3c, 0xe5, 0x4d, 0x36, 0x6c, 0x8a, 0x94, 0x21,
	0x3a, 0x4e, 0x3c, 0xd3, 0xe1, 0x40, 0xc0, 0x4f, 0x11, 0x63, 0x10, 0xa0, 0x01, 0xd0, 0x15, 0x77,
	0xed, 0x2e, 0xcb, 0xf6, 0x05, 0x32, 0x9d, 0x76, 0xd1, 0x45, 0x5f, 0xa0, 0x8f, 0xe0, 0x65, 0x97,
	0x5d, 0x69, 0x5a, 0xf5, 0x01, 0xba, 0xf7, 0xaa, 0xf3, 0xdf, 0x00, 0x50, 0x14, 0x5d, 0x29, 0x59,
	0xd8, 0x43, 0x9c, 0xcb, 0x87, 0x73, 0x3f, 0x07, 0x82, 0x07, 0xa6, 0x67, 0xbe, 0xf2, 0x3d, 0xc3,
	0x1c, 0xef, 0x06, 0xaf, 0x1d, 0xf2, 0xef, 0xd8, 0x08, 0xf0, 0x6e, 0x10, 0xfa, 0x33, 0x33, 0x9c,
	0xf9, 0xd8, 0xaa, 0x4f, 0x7d, 0x2f, 0xf4, 0xd0, 0xad, 0x48, 0xae, 0x1e, 0xbc, 0x76, 0xea, 0x5c,
	0x6e, 0xb3, 0x16, 0xab, 0xcf, 0x42, 0xdb, 0xd9, 0x1d, 0x3b, 0xe6, 0x6e, 0x68, 0x4f, 0x70, 0x10,
	0x1a, 0x93, 0x29, 0x53, 0xdd, 0xbc, 0x7f, 0xf9, 0x2b, 0xa6, 0xbe, 0xfd, 0xc6, 0x76, 0xf0, 0x09,
	0xe6, 0x62, 0x37, 0x4f, 0xbc, 0x13, 0x8f, 0xfe, 0xdc, 0x25, 0xbf, 0x18, 0xb5, 0xf6, 0xc7, 0x14,
	0x40, 0xcb, 0x73, 0x66, 0x13, 0x77, 0x30, 0x9f, 0x62, 0xf4, 0x6b, 0xc8, 0xbc, 0xb2, 0x5d, 0x4b,
	0x95, 0xaa, 0xd2, 0x4e, 0x79, 0xef, 0x41, 0xfd, 0x52, 0xab, 0xea, 0xb1, 0x42, 0xfd, 0xa9, 0xed,
	0x5a, 0xcd, 0xcc, 0xdb, 0xb3, 0xed, 0x35, 0x9d, 0x6a, 0xa2, 0x4d, 0xc8, 0xfe, 0xd6, 0xb6, 0xc2,
	0xb1, 0x9a, 0xaa, 0x4a, 0x3b, 0x59, 0xce, 0x62, 0x24, 0x54, 0x83, 0xc2, 0xd4, 0xc7, 0xa6, 0x1d,
	0xd8, 0x9e, 0xab, 0xa6, 0x13, 0xfc, 0x98, 0x5c, 0xfb, 0x9d, 0x04, 0x19, 0x02, 0x8a, 0x64, 0xc8,
	0x34, 0xfb, 0xfd, 0xae, 0xb2, 0x86, 0xf2, 0x90, 0xd6, 0x7a, 0x03, 0x45, 0x42, 0x05, 0xc8, 0xee,
	0x77, 0xfb, 0x8d, 0x81, 0x92, 0x42, 0x45, 0xc8, 0xb7, 0x3b, 0x2d, 0xed, 0xa0, 0xd1, 0x55, 0xd2,
	0x44, 0xb4, 0xdd, 0x18, 0x74, 0x94, 0x0c, 0x2a, 0x41, 0x61, 0xa0, 0x1d, 0x74, 0x8e, 0x06, 0x8d,
	0x83, 0x43, 0x25, 0x8b, 0xd6, 0x41, 0xd6, 0x7a, 0x83, 0x8e, 0xfe, 0x45, 0xa3, 0xab, 0xe4, 0x10,
	0x40, 0xee, 0x68, 0xa0, 0x6b, 0xbd, 0x47, 0x4a, 0x9e, 0x40, 0x35, 0xbf, 0x1a, 0x74, 0x8e, 0x14,
	0x19, 0x55, 0xa0, 0x18, 0xe9, 0x0c, 0x5e, 0x2a, 0x85, 0xda, 0x29, 0xdc, 0xd8, 0xf7, 0x7c, 0x6c,
	0x9f, 0xb8, 0x4f, 0xf1, 0x5c, 0xc7, 0x23, 0xec, 0x63, 0xd7, 0xc4, 0xa8, 0x0a, 0xd9, 0xd0, 0x38,
	0x76, 0x30, 0x0d, 0x4e, 0xa9, 0x09, 0xc4, 0xf2, 0x77, 0x67, 0xdb, 0x29, 0xad, 0xad, 0x33, 0x06,
	0xba, 0x0f, 0x59, 0xdb, 0xb5, 0xf0, 0x29, 0xf5, 0xbd, 0xd4, 0xac, 0x70, 0x89, 0xbc, 0x46, 0x88,
	0x44, 0x8c, 0x72, 0x91, 0x0a, 0x19, 0xd7, 0x98, 0x60, 0x1a, 0x81, 0x82, 0x08, 0x1e, 0xa1, 0xd4,
	0x7e, 0x9f, 0x06, 0x85, 0x05, 0xb7, 0x8d, 0x03, 0xd3, 0xb7, 0xa7, 0xa1, 0xe7, 0x47, 0xe2, 0xd2,
	0x45, 0x71, 0xf4, 0x00, 0x52, 0xb6, 0xc5, 0x5f, 0x76, 0x9b, 0xd0, 0xcf, 0xa9, 0x39, 0xef, 0xce,
	0xb6, 0x65, 0x86, 0xa2, 0xb5, 0xf5, 0x94, 0x6d, 0xa1, 0x5f, 0x40, 0x26, 0x9c, 0x4f, 0xd9, 0x0b,
	0x8b, 0x7b, 0xf7, 0xfe, 0x6f, 0x56, 0xc5, 0x4b, 0x88, 0x12, 0xaa, 0x82, 0xec, 0xce, 0x1c, 0x87,
	0x7a, 0x9e, 0xa9, 0x4a, 0x3b, 0x32, 0xe7, 0x46, 0x54, 0x74, 0x0f, 0xd6, 0x2d, 0x3c, 0x32, 0x66,
	0x4e, 0x38, 0xc4, 0xa7, 0x53, 0x5f, 0xcd, 0x12, 0x43, 0xf5, 0x22, 0xa7, 0x75, 0x4e, 0xa7, 0x3e,
	0xba, 0x0b, 0xb9, 0xb1, 0x6d, 0x59, 0xd8, 0x55, 0x73, 0x09, 0x08, 0x4e, 0x43, 0x0f, 0x41, 0x15,
	0x60, 0x43, 0xd3, 0x73, 0x83, 0xd0, 0x37, 0x6c, 0x37, 0x1c, 0x52, 0xaf, 0xe5, 0x84, 0xd7, 0xb7,
	0x85, 0x54, 0x2b, 0x12, 0xea, 0x91, 0x38, 0x74, 0xe0, 0x6e, 0xd2, 0x80, 0x25, 0x8c, 0x42, 0x02,
	0xe3, 0x4e, 0xc2, 0xac, 0x45, 0x98, 0x27, 0x19, 0x39, 0xaf, 0xc8, 0xb5, 0xaf, 0x53, 0x70, 0x9b,
	0x85, 0x62, 0xdf, 0x98, 0xd8, 0xce, 0xfc, 0xbb, 0x66, 0x82, 0xa1, 0xf0, 0x4c, 0xdc, 0x83, 0x75,
	0x93, 0x62, 0x53, 0xc3, 0x02, 0x35, 0x5d, 0x4d, 0x93, 0x50, 0x31, 0x1a, 0x31, 0x22, 0x40, 0x9f,
	0x03, 0x70, 0x11, 0xdb, 0x0a, 0xd4, 0x4c, 0x35, 0xbd, 0x53, 0x6a, 0xde, 0x39, 0x3f, 0xdb, 0x2e,
	0x88, 0x94, 0x06, 0x0b, 0xf9, 0x2d, 0x30, 0x61, 0xcd, 0x0a, 0x50, 0x1f, 0x36, 0x44, 0x18, 0x22,
	0x04, 0x9a, 0x8c, 0x52, 0xf3, 0x43, 0x6e, 0x53, 0xa5, 0xcd, 0x04, 0x84, 0xfa, 0x02, 0x54, 0xc5,
	0x5a, 0x60, 0x5a, 0xb5, 0xbf, 0xa5, 0xe0, 0xa6, 0xe6, 0x86, 0xd8, 0x77, 0xb0, 0xf1, 0x06, 0x27,
	0x02, 0xf1, 0x25, 0x14, 0x0c, 0xd7, 0xc4, 0x41, 0xe8, 0xf9, 0x81, 0x2a, 0x55, 0xd3, 0x3b, 0xc5,
	0xbd, 0x9f, 0xae, 0xa8, 0xaa, 0xcb, 0xf4, 0xeb, 0x0d, 0xae, 0x2c, 0xda, 0x3f, 0x02, 0xdb, 0xfc,
	0xbb, 0x04, 0xb2, 0xe0, 0xa2, 0x4f, 0x40, 0xa6, 0x8d, 0x45, 0xfc, 0x60, 0x4d, 0x77, 0x8b, 0xfb,
	0x91, 0x1f, 0x10, 0x3a, 0xb5, 0x9f, 0xf4, 0x5f, 0x9e, 0x8a, 0x69, 0x16, 0xfa, 0x0c, 0x64, 0xda,
	0x63, 0xc3, 0x28, 0x1b, 0x9b, 0x42, 0x83, 0x37, 0x61, 0xb2, 0x1f, 0xf3, 0x54, 0x56, 0xb3, 0x50,
	0x0b, 0x36, 0x82, 0xb1, 0xe1, 0x63, 0x6b, 0x38, 0xf5, 0xf1, 0xc8, 0x3e, 0x1d, 0x3a, 0x98, 0x0d,
	0xa8, 0x52, 0xf3, 0x03, 0x11, 0xb9, 0x23, 0x2a, 0x70, 0x48, 0xf9, 0x5d, 0xec, 0xea, 0x95, 0x60,
	0x91, 0x50, 0xfb, 0x4b, 0x0e, 0x2a, 0x14, 0xf9, 0x4a, 0x15, 0x73, 0x3f, 0x51, 0x31, 0xb7, 0x16,
	0x2a, 0x26, 0x32, 0x8f, 0x14, 0xcc, 0x5d, 0xc8, 0xcd, 0x5c, 0xfb, 0xf5, 0x8c, 0x35, 0x6f, 0xd4,
	0x38, 0x8c, 0xb6, 0x54, 0x4e, 0x99, 0xe5, 0x72, 0xfa, 0x08, 0x10, 0x89, 0x25, 0x1e, 0x2e, 0x08,
	0x66, 0xa9, 0xa0, 0x42, 0x39, 0xad, 0x95, 0xc5, 0x97, 0xbb, 0x46, 0xf1, 0x3d, 0x83, 0x1b, 0xf6,
	0x64, 0xea, 0xd8, 0xa6, 0x9d, 0xa8, 0xbe, 0x40, 0xcd, 0x53, 0x88, 0x7b, 0xe7, 0x67, 0xdb, 0x1b,
	0x1a, 0x67, 0x5f, 0x0e, 0xb5, 0x61, 0x2f, 0xb2, 0xad, 0x00, 0xfd, 0x06, 0x36, 0x38, 0x92, 0x65,
	0xfb, 0xd8, 0x0c, 0x6d, 0xcf, 0x0d, 0x54, 0xb9, 0x9a, 0xde, 0x29, 0xef, 0x7d, 0xb2, 0xb2, 0xda,
	0x16, 0xe2, 0x5f, 0x6f, 0x0b, 0x45, 0x5d, 0x61, 0x50, 0x11, 0x81, 0x58, 0x5c, 0x1c, 0xb1, 0x31,
	0x3f, 0x7c, 0x85, 0xe7, 0x74, 0x48, 0x14, 0xf7, 0x7e, 0xb4, 0x02, 0xf8, 0x92, 0x85, 0xc0, 0x73,
	0x01, 0xa3, 0x88, 0x85, 0x9e, 0x43, 0xc9, 0x17, 0x6c, 0x6b, 0x78, 0x3c, 0x57, 0x81, 0xf6, 0xc6,
	0xf5, 0x41, 0xd7, 0x63, 0x98, 0xe6, 0x1c, 0x3d, 0x03, 0xb0, 0xa3, 0x36, 0x52, 0x8b, 0xd4, 0xd0,
	0x1f, 0x5f, 0xa3, 0xdf, 0x84, 0xa5, 0x31, 0x08, 0x7a, 0x01, 0xe5, 0xf8, 0x89, 0x9a, 0xba, 0xfe,
	0x2d, 0x4d, 0x2d, 0x25, 0x70, 0x9a, 0xf3, 0xda, 0x16, 0x14, 0xa2, 0x18, 0x93, 0xcd, 0xdd, 0x38,
	0x6a, 0x29, 0x6b, 0x74, 0x43, 0x77, 0x8e, 0x5a, 0x8a, 0x54, 0xfb, 0x6f, 0x1a, 0x50, 0x6c, 0xd9,
	0xc1, 0x2c, 0x34, 0xa8, 0x64, 0x03, 0x72, 0x2c, 0x41, 0xb4, 0x55, 0x8a, 0x7b, 0x3f, 0x78, 0xef,
	0x92, 0x8a, 0x01, 0x1e, 0xaf, 0xe9, 0x5c, 0x11, 0x3d, 0x4c, 0x6e, 0xdf, 0xe2, 0xca, 0xe3, 0xe5,
	0x42, 0x89, 0x3c, 0x5e, 0x13, 0x6b, 0xf9, 0x29, 0x64, 0x83, 0xd0, 0x08, 0x59, 0xa7, 0x95, 0xf7,
	0x76, 0x57, 0xe8, 0x2f, 0x1b, 0x5f, 0x3f, 0x22, 0x6a, 0xe2, 0xd4, 0xa1, 0x18, 0xe8, 0x05, 0x14,
	0xa2, 0xa2, 0xa5, 0x6b, 0xb3, 0xbc, 0xf7, 0xe9, 0xd5, 0x01, 0xa3, 0x08, 0x8a, 0x01, 0x19, 0x61,
	0xa1, 0x06, 0x14, 0x27, 0x5c, 0x2c, 0x1e, 0xef, 0x55, 0x3e, 0x40, 0x40, 0x20, 0xd0, 0x41, 0x92,
	0x78, 0xd2, 0x41, 0x28, 0x69, 0x56, 0xed, 0x33, 0xc8, 0x52, 0x8b, 0xc9, 0x11, 0xf5, 0xbc, 0xf7,
	0xb4, 0xd7, 0x7f, 0xd1, 0x53, 0xd6, 0xc8, 0x19, 0xd4, 0xee, 0x74, 0x3b, 0x83, 0xce, 0xb0, 0xdf,
	0xeb, 0x7e, 0xa5, 0x48, 0xa8, 0x0c, 0xf0, 0x42, 0xd7, 0xc4, 0x73, 0xaa, 0xb6, 0x93, 0xcc, 0xac,
	0x0c, 0x99, 0x5e, 0xbf, 0xd7, 0x61, 0xd7, 0x59, 0xa3, 0xdd, 0x56, 0x24, 0x9a, 0x63, 0xbd, 0x7f,
	0xa8, 0xa4, 0x9a, 0xeb, 0x00, 0x56, 0xe4, 0x54, 0xed, 0xaf, 0x65, 0xa8, 0xd0, 0x71, 0x7d, 0xa5,
	0xb9, 0x58, 0xa5, 0x73, 0x91, 0xcd, 0x5e, 0x65, 0x61, 0x2e, 0xa6, 0xf8, 0x48, 0xfc, 0x14, 0x0a,
	0x53, 0xc3, 0xc7, 0x6e, 0x48, 0xfc, 0xcf, 0x2c, 0xac, 0x5c, 0xf9, 0x90, 0x32, 0x22, 0x71, 0x99,
	0x09, 0x6a, 0x44, 0x29, 0xff, 0x06, 0xfb, 0xf4, 0xf0, 0x64, 0x21, 0xbb, 0xc3, 0x8f, 0xb3, 0x8d,
	0xd8, 0xaa, 0x2f, 0x98, 0x80, 0x2e, 0x24, 0xd1, 0x87, 0x00, 0xb3, 0xe9, 0x50, 0xe8, 0x25, 0x2f,
	0x97, 0xc2, 0x6c, 0xca, 0xa5, 0xd1, 0x21, 0x6c, 0x4c, 0x3c, 0xcb, 0x1e, 0xd9, 0x26, 0x4b, 0x0a,
	0x39, 0xcf, 0xd5, 0x3c, 0x2d, 0xc1, 0xef, 0x25, 0x32, 0x4e, 0xce, 0xf7, 0xfa, 0xd8, 0x31, 0xeb,
	0x03, 0x71, 0xbe, 0x73, 0x28, 0x25, 0xa9, 0x4d, 0x98, 0xe8, 0x11, 0xe4, 0x59, 0x49, 0xb3, 0x69,
	0x77, 0xf5, 0x66, 0xe0, 0x88, 0x42, 0x1b, 0xed, 0x43, 0xd9, 0xc5, 0xa7, 0xc9, 0x6b, 0xa0, 0xb0,
	0x50, 0x2e, 0xeb, 0x3d, 0x7c, 0x7a, 0xf9, 0x29, 0xb0, 0xee, 0xc6, 0x1c, 0x0b, 0x3d, 0x83, 0xd2,
	0xd4, 0xb7, 0x27, 0x86, 0x3f, 0x1f, 0xb2, 0x0e, 0x83, 0xeb, 0x74, 0x98, 0x18, 0x69, 0x1c, 0x82,
	0x72, 0xd1, 0x3e, 0xb0, 0xe5, 0x8b, 0x03, 0xb5, 0x48, 0x7d, 0xbc, 0x1e, 0x98, 0x50, 0x46, 0x4d,
	0x28, 0x51, 0x17, 0xa3, 0xad, 0xbf, 0x4e, 0x3d, 0xdc, 0xe2, 0x1e, 0x16, 0x89, 0x87, 0x97, 0x6c,
	0xfe, 0xa2, 0x1b, 0xd1, 0x2d, 0xf4, 0x04, 0x20, 0xfa, 0x58, 0x0a, 0xd4, 0xd2, 0x7b, 0xf7, 0xc0,
	0xa1, 0x10, 0x8c, 0x4d, 0xd2, 0x13, 0xda, 0xe8, 0x00, 0x0a, 0xa2, 0xd3, 0x02, 0xb5, 0x4c, 0x3d,
	0xfb, 0xe1, 0x95, 0xfb, 0x5e, 0x14, 0x57, 0x84, 0x80, 0x7a, 0x90, 0x75, 0xb0, 0x11, 0x60, 0xb5,
	0x42, 0xad, 0xfa, 0x7c, 0x05, 0xd4, 0x85, 0xf6, 0xaa, 0x1f, 0x99, 0x63, 0x3c, 0x31, 0x5a, 0x63,
	0xc3, 0x3d, 0xc1, 0x5d, 0xa2, 0xaf, 0x33, 0x18, 0xd4, 0x03, 0x85, 0x86, 0x2b, 0x39, 0x42, 0x14,
	0x1a, 0xb1, 0xef, 0xf3, 0x88, 0x95, 0x49, 0xc4, 0x56, 0x8e, 0x11, 0x5a, 0x4f, 0xd1, 0xb3, 0x85,
	0x7e, 0x09, 0xe5, 0x91, 0xe7, 0x4f, 0x8c, 0x30, 0xea, 0x92, 0x8d, 0xf8, 0xa2, 0x79, 0x77, 0xb6,
	0x5d, 0xda, 0xa7, 0x5c, 0xd1, 0x59, 0xa5, 0x51, 0xf2, 0x11, 0x3d, 0x16, 0x13, 0xf7, 0x06, 0x1d,
	0x90, 0x1f, 0x5d, 0xd5, 0xbb, 0xe5, 0x71, 0xdb, 0x83, 0x9c, 0x39, 0xc6, 0xe6, 0xab, 0x40, 0xbd,
	0x49, 0x63, 0xfe, 0xb3, 0x2b, 0x42, 0xb5, 0x88, 0x52, 0xfc, 0x19, 0xa0, 0x73, 0x14, 0xf4, 0x0c,
	0xf2, 0x3e, 0x66, 0xa7, 0xd2, 0x2d, 0x0a, 0xf8, 0x93, 0x2b, 0x02, 0xea, 0x54, 0x4b, 0x73, 0x47,
	0x9e, 0xa8, 0x54, 0x8e, 0x83, 0xfa, 0x20, 0x8f, 0xc8, 0xa7, 0x80, 0x8d, 0x03, 0xf5, 0x36, 0xc5,
	0xfc, 0xf8, 0xbd, 0x6d, 0x7d, 0xf1, 0xeb, 0x43, 0x7c, 0x76, 0x09, 0x90, 0xa8, 0xbb, 0x29, 0x61,
	0x4e, 0x32, 0xf9, 0xc1, 0x72, 0x77, 0x8b, 0xaf, 0x8f, 0x85, 0x2f, 0x11, 0xda, 0xdd, 0xfc, 0xc9,
	0xda, 0xfc, 0x46, 0x82, 0x8d, 0xa5, 0x82, 0x41, 0x2f, 0x21, 0xef, 0x7a, 0x56, 0xe2, 0xf4, 0x6e,
	0x70, 0xd8, 0x5c, 0xcf, 0xb3, 0xd8, 0xe5, 0xbd, 0x7b, 0x62, 0x87, 0xe3, 0xd9, 0x71, 0xdd, 0xf4,
	0x26, 0xbb, 0x91, 0x27, 0xd6, 0x71, 0xfc, 0x7b, 0x97, 0xfe, 0x3f, 0x3d, 0xae, 0x33, 0x15, 0x3d,
	0x47, 0x10, 0x35, 0x0b, 0x7d, 0x0c, 0x15, 0x7c, 0x3a, 0xb5, 0xfd, 0xc4, 0xc0, 0x24, 0x3b, 0x3b,
	0xcd, 0x5d, 0x2c, 0xc7, 0x4c, 0x32, 0x0f, 0x37, 0x3b, 0x50, 0xb9, 0x90, 0x27, 0xb2, 0x3f, 0xe8,
	0xa7, 0xe6, 0xc2, 0xfe, 0x20, 0x94, 0x68, 0xb3, 0xa4, 0x2e, 0x6e, 0x96, 0x4d, 0x07, 0x20, 0xce,
	0x0e, 0xfa, 0x15, 0x94, 0x3c, 0xc7, 0x1a, 0xc6, 0x9b, 0x44, 0x8a, 0xd7, 0x02, 0x19, 0x1c, 0x7d,
	0xc7, 0xba, 0xb0, 0x4c, 0x8a, 0x5e, 0x44, 0xb2, 0xd0, 0x36, 0xc8, 0x44, 0x7d, 0xe9, 0x55, 0x79,
	0xcf, 0xb1, 0xc8, 0x29, 0x5d, 0x7b, 0x20, 0x96, 0x2c, 0x40, 0xee, 0xf0, 0x79, 0xb3, 0xab, 0xb5,
	0x2e, 0xdd, 0x95, 0x3f, 0xcf, 0x7c, 0xfd, 0xa7, 0x6d, 0xe9, 0x49, 0x46, 0x46, 0xca, 0x8d, 0xda,
	0x9f, 0x25, 0x40, 0x6d, 0x23, 0x34, 0x48, 0x15, 0x5c, 0x63, 0x59, 0xa6, 0xde, 0xb3, 0x2c, 0x17,
	0x67, 0x5b, 0xfa, 0xbb, 0xcc, 0x36, 0x66, 0x6a, 0xed, 0x1b, 0x09, 0x20, 0x61, 0xdc, 0xc3, 0xe4,
	0x5f, 0x45, 0x56, 0x8f, 0xf1, 0x0b, 0x7d, 0x42, 0xae, 0x2e, 0xf6, 0x37, 0x93, 0x47, 0x20, 0x5b,
	0xdc, 0x65, 0x7e, 0xb8, 0xad, 0x9c, 0x97, 0x4b, 0x91, 0x79, 0xbc, 0xa6, 0x47, 0xca, 0xcd, 0x3c,
	0x64, 0x67, 0x2e, 0x19, 0xa2, 0xf7, 0xde, 0xfe, 0x7b, 0x6b, 0xed, 0xed, 0xf9, 0x96, 0xf4, 0x8f,
	0xf3, 0x2d, 0xe9, 0x9f, 0xe7, 0x5b, 0xd2, 0xbf, 0xce, 0xb7, 0xa4, 0x3f, 0xfc, 0x67, 0x6b, 0xed,
	0x65, 0x9e, 0x43, 0x7d, 0x99, 0xfa, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x14, 0x39, 0xde,
	0x98, 0x13, 0x00, 0x00,
}
