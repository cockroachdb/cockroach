// Code generated by protoc-gen-gogo.
// source: cockroach/server/admin.proto
// DO NOT EDIT!

/*
	Package server is a generated protocol buffer package.

	It is generated from these files:
		cockroach/server/admin.proto
		cockroach/server/status.proto

	It has these top-level messages:
		DatabasesRequest
		DatabasesResponse
		DatabaseDetailsRequest
		DatabaseDetailsResponse
		TableDetailsRequest
		TableDetailsResponse
		UsersRequest
		UsersResponse
		EventsRequest
		EventsResponse
		SetUIDataRequest
		SetUIDataResponse
		GetUIDataRequest
		GetUIDataResponse
		ClusterRequest
		ClusterResponse
		DrainRequest
		DrainResponse
		HealthRequest
		HealthResponse
		ClusterFreezeRequest
		ClusterFreezeResponse
		DetailsRequest
		DetailsResponse
		NodesRequest
		NodesResponse
		NodeRequest
		RangeInfo
		RangesRequest
		RangesResponse
		GossipRequest
		JSONResponse
		LogsRequest
		LogFilesListRequest
		LogFileRequest
		StacksRequest
		MetricsRequest
*/
package server

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"
// skipping weak import google_api1 "github.com/gengo/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type DrainMode int32

const (
	// CLIENT instructs the server to refuse new SQL clients.
	// TODO(tschottdorf): also terminate existing clients in a graceful manner.
	DrainMode_CLIENT DrainMode = 0
	// LEADERSHIP instructs the server to gracefully let all its Replicas'
	// leader leases expire.
	DrainMode_LEADERSHIP DrainMode = 1
)

var DrainMode_name = map[int32]string{
	0: "CLIENT",
	1: "LEADERSHIP",
}
var DrainMode_value = map[string]int32{
	"CLIENT":     0,
	"LEADERSHIP": 1,
}

func (x DrainMode) String() string {
	return proto.EnumName(DrainMode_name, int32(x))
}
func (DrainMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{0} }

// DatabasesRequest requests a list of databases.
type DatabasesRequest struct {
}

func (m *DatabasesRequest) Reset()                    { *m = DatabasesRequest{} }
func (m *DatabasesRequest) String() string            { return proto.CompactTextString(m) }
func (*DatabasesRequest) ProtoMessage()               {}
func (*DatabasesRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{0} }

// DatabasesResponse contains a list of databases.
type DatabasesResponse struct {
	Databases []string `protobuf:"bytes,1,rep,name=databases" json:"databases,omitempty"`
}

func (m *DatabasesResponse) Reset()                    { *m = DatabasesResponse{} }
func (m *DatabasesResponse) String() string            { return proto.CompactTextString(m) }
func (*DatabasesResponse) ProtoMessage()               {}
func (*DatabasesResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{1} }

// DatabaseDetailsRequest requests detailed information about the specified
// database
type DatabaseDetailsRequest struct {
	// database is the name of the database we are querying.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
}

func (m *DatabaseDetailsRequest) Reset()                    { *m = DatabaseDetailsRequest{} }
func (m *DatabaseDetailsRequest) String() string            { return proto.CompactTextString(m) }
func (*DatabaseDetailsRequest) ProtoMessage()               {}
func (*DatabaseDetailsRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{2} }

// DatabaseDetailsResponse contains grant information and table names for a
// database.
type DatabaseDetailsResponse struct {
	// grants are the results of SHOW GRANTS for this database.
	Grants []DatabaseDetailsResponse_Grant `protobuf:"bytes,1,rep,name=grants" json:"grants"`
	// table_names contains the names of all tables (SHOW TABLES) in this
	// database.
	TableNames []string `protobuf:"bytes,2,rep,name=table_names,json=tableNames" json:"table_names,omitempty"`
}

func (m *DatabaseDetailsResponse) Reset()                    { *m = DatabaseDetailsResponse{} }
func (m *DatabaseDetailsResponse) String() string            { return proto.CompactTextString(m) }
func (*DatabaseDetailsResponse) ProtoMessage()               {}
func (*DatabaseDetailsResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{3} }

type DatabaseDetailsResponse_Grant struct {
	// user is the user that this grant applies to.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// privileges are the abilities this grant gives to the user.
	Privileges []string `protobuf:"bytes,2,rep,name=privileges" json:"privileges,omitempty"`
}

func (m *DatabaseDetailsResponse_Grant) Reset()         { *m = DatabaseDetailsResponse_Grant{} }
func (m *DatabaseDetailsResponse_Grant) String() string { return proto.CompactTextString(m) }
func (*DatabaseDetailsResponse_Grant) ProtoMessage()    {}
func (*DatabaseDetailsResponse_Grant) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{3, 0}
}

// TableDetailsRequest is a request for detailed information about a table.
type TableDetailsRequest struct {
	// database is the database that contains the table we're interested in.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// table is the name of the table that we're querying.
	Table string `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
}

func (m *TableDetailsRequest) Reset()                    { *m = TableDetailsRequest{} }
func (m *TableDetailsRequest) String() string            { return proto.CompactTextString(m) }
func (*TableDetailsRequest) ProtoMessage()               {}
func (*TableDetailsRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{4} }

// TableDetailsResponse contains grants, column names, and indexes for
// a table.
type TableDetailsResponse struct {
	Grants  []TableDetailsResponse_Grant  `protobuf:"bytes,1,rep,name=grants" json:"grants"`
	Columns []TableDetailsResponse_Column `protobuf:"bytes,2,rep,name=columns" json:"columns"`
	Indexes []TableDetailsResponse_Index  `protobuf:"bytes,3,rep,name=indexes" json:"indexes"`
	// range_count is the size of the table in ranges. This provides a rough
	// estimate of the storage requirements for the table.
	RangeCount int64 `protobuf:"varint,4,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
}

func (m *TableDetailsResponse) Reset()                    { *m = TableDetailsResponse{} }
func (m *TableDetailsResponse) String() string            { return proto.CompactTextString(m) }
func (*TableDetailsResponse) ProtoMessage()               {}
func (*TableDetailsResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{5} }

// Grant is an entry from SHOW GRANTS.
type TableDetailsResponse_Grant struct {
	// user is the user that this grant applies to.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// privileges are the abilities this grant gives to the user.
	Privileges []string `protobuf:"bytes,2,rep,name=privileges" json:"privileges,omitempty"`
}

func (m *TableDetailsResponse_Grant) Reset()         { *m = TableDetailsResponse_Grant{} }
func (m *TableDetailsResponse_Grant) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Grant) ProtoMessage()    {}
func (*TableDetailsResponse_Grant) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{5, 0}
}

type TableDetailsResponse_Column struct {
	// name is the name of the column.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// type is the SQL type (INT, STRING, etc.) of this column.
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// nullable is whether this column can contain NULL.
	Nullable bool `protobuf:"varint,3,opt,name=nullable,proto3" json:"nullable,omitempty"`
	// default_value is the default value of this column.
	DefaultValue string `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (m *TableDetailsResponse_Column) Reset()         { *m = TableDetailsResponse_Column{} }
func (m *TableDetailsResponse_Column) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Column) ProtoMessage()    {}
func (*TableDetailsResponse_Column) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{5, 1}
}

type TableDetailsResponse_Index struct {
	// name is the name of this index.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// unique is whether this a unique index (i.e. CREATE UNIQUE INDEX).
	Unique bool `protobuf:"varint,2,opt,name=unique,proto3" json:"unique,omitempty"`
	// seq is an internal variable that's passed along.
	Seq int64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// column is the column that this index indexes.
	Column string `protobuf:"bytes,4,opt,name=column,proto3" json:"column,omitempty"`
	// direction is either "ASC" (ascending) or "DESC" (descending).
	Direction string `protobuf:"bytes,5,opt,name=direction,proto3" json:"direction,omitempty"`
	// storing is an internal variable that's passed along.
	Storing bool `protobuf:"varint,6,opt,name=storing,proto3" json:"storing,omitempty"`
}

func (m *TableDetailsResponse_Index) Reset()         { *m = TableDetailsResponse_Index{} }
func (m *TableDetailsResponse_Index) String() string { return proto.CompactTextString(m) }
func (*TableDetailsResponse_Index) ProtoMessage()    {}
func (*TableDetailsResponse_Index) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{5, 2}
}

// UsersRequest requests a list of users.
type UsersRequest struct {
}

func (m *UsersRequest) Reset()                    { *m = UsersRequest{} }
func (m *UsersRequest) String() string            { return proto.CompactTextString(m) }
func (*UsersRequest) ProtoMessage()               {}
func (*UsersRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{6} }

// UsersResponse returns a list of users.
type UsersResponse struct {
	// usernames is a list of users for the CockroachDB cluster.
	Users []UsersResponse_User `protobuf:"bytes,1,rep,name=users" json:"users"`
}

func (m *UsersResponse) Reset()                    { *m = UsersResponse{} }
func (m *UsersResponse) String() string            { return proto.CompactTextString(m) }
func (*UsersResponse) ProtoMessage()               {}
func (*UsersResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{7} }

// User is a CockroachDB user.
type UsersResponse_User struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *UsersResponse_User) Reset()                    { *m = UsersResponse_User{} }
func (m *UsersResponse_User) String() string            { return proto.CompactTextString(m) }
func (*UsersResponse_User) ProtoMessage()               {}
func (*UsersResponse_User) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{7, 0} }

// EventsRequest is a request for event log entries, optionally filtered
// by the specified event type and/or target_id.
type EventsRequest struct {
	Type     string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	TargetId int64  `protobuf:"varint,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
}

func (m *EventsRequest) Reset()                    { *m = EventsRequest{} }
func (m *EventsRequest) String() string            { return proto.CompactTextString(m) }
func (*EventsRequest) ProtoMessage()               {}
func (*EventsRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{8} }

// EventsResponse contains a set of event log entries. This is always limited
// to the latest N entries (N is enforced in the associated endpoint).
type EventsResponse struct {
	Events []EventsResponse_Event `protobuf:"bytes,1,rep,name=events" json:"events"`
}

func (m *EventsResponse) Reset()                    { *m = EventsResponse{} }
func (m *EventsResponse) String() string            { return proto.CompactTextString(m) }
func (*EventsResponse) ProtoMessage()               {}
func (*EventsResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{9} }

type EventsResponse_Event struct {
	// timestamp is the time at which the event occurred.
	Timestamp EventsResponse_Event_Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	// event_type is the type of the event (e.g. "create_table", "drop_table".
	EventType string `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// target_id is the target for this event.
	TargetID int64 `protobuf:"varint,3,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	// reporting_id is the reporting ID for this event.
	ReportingID int64 `protobuf:"varint,4,opt,name=reporting_id,json=reportingId,proto3" json:"reporting_id,omitempty"`
	// info has more detailed information for the event. The contents vary
	// depending on the vent.
	Info string `protobuf:"bytes,5,opt,name=info,proto3" json:"info,omitempty"`
	// unique_id is a unique identifier for this event.
	UniqueID []byte `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *EventsResponse_Event) Reset()                    { *m = EventsResponse_Event{} }
func (m *EventsResponse_Event) String() string            { return proto.CompactTextString(m) }
func (*EventsResponse_Event) ProtoMessage()               {}
func (*EventsResponse_Event) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{9, 0} }

// Timestamp is embedded in each place it's used, because proto3 defines a
// built-in Timestamp message that we can't use, because gogoprotobuf
// doesn't support all proto3 protobuf types yet. See
// https://github.com/gogo/protobuf/issues/155.
type EventsResponse_Event_Timestamp struct {
	// The time in seconds since, January 1, 1970 UTC (Unix time).
	Sec int64 `protobuf:"varint,1,opt,name=sec,proto3" json:"sec,omitempty"`
	// nsec specifies a non-negative nanosecond offset within sec.
	// It must be in the range [0, 999999999].
	Nsec uint32 `protobuf:"varint,2,opt,name=nsec,proto3" json:"nsec,omitempty"`
}

func (m *EventsResponse_Event_Timestamp) Reset()         { *m = EventsResponse_Event_Timestamp{} }
func (m *EventsResponse_Event_Timestamp) String() string { return proto.CompactTextString(m) }
func (*EventsResponse_Event_Timestamp) ProtoMessage()    {}
func (*EventsResponse_Event_Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{9, 0, 0}
}

// SetUIDataRequest stores the given key/value pairs in the system.ui table.
type SetUIDataRequest struct {
	// key_values is a map of keys to bytes values. Each key will be stored
	// with its corresponding value as a separate row in system.ui.
	KeyValues map[string][]byte `protobuf:"bytes,1,rep,name=key_values,json=keyValues" json:"key_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SetUIDataRequest) Reset()                    { *m = SetUIDataRequest{} }
func (m *SetUIDataRequest) String() string            { return proto.CompactTextString(m) }
func (*SetUIDataRequest) ProtoMessage()               {}
func (*SetUIDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{10} }

// SetUIDataResponse is currently an empty response.
type SetUIDataResponse struct {
}

func (m *SetUIDataResponse) Reset()                    { *m = SetUIDataResponse{} }
func (m *SetUIDataResponse) String() string            { return proto.CompactTextString(m) }
func (*SetUIDataResponse) ProtoMessage()               {}
func (*SetUIDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{11} }

// GETUIDataRequest requests the values for the given keys from the system.ui
// table.
type GetUIDataRequest struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *GetUIDataRequest) Reset()                    { *m = GetUIDataRequest{} }
func (m *GetUIDataRequest) String() string            { return proto.CompactTextString(m) }
func (*GetUIDataRequest) ProtoMessage()               {}
func (*GetUIDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{12} }

// GetUIDataResponse contains the requested values and the times at which
// the values were last updated.
type GetUIDataResponse struct {
	// key_values maps keys to their retrieved values. If this doesn't contain a
	// a requested key, that key was not found.
	KeyValues map[string]GetUIDataResponse_Value `protobuf:"bytes,1,rep,name=key_values,json=keyValues" json:"key_values" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetUIDataResponse) Reset()                    { *m = GetUIDataResponse{} }
func (m *GetUIDataResponse) String() string            { return proto.CompactTextString(m) }
func (*GetUIDataResponse) ProtoMessage()               {}
func (*GetUIDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{13} }

// Timestamp is embedded in each place it's used, because proto3 defines a
// built-in Timestamp message that we can't use, because gogoprotobuf doesn't
// support all proto3 protobuf types yet. See gogoprotobuf issue #113.
type GetUIDataResponse_Timestamp struct {
	// The time in seconds since, January 1, 1970 UTC (Unix time).
	Sec int64 `protobuf:"varint,1,opt,name=sec,proto3" json:"sec,omitempty"`
	// nsec specifies a non-negative nanosecond offset within sec.
	// It must be in the range [0, 999999999].
	Nsec uint32 `protobuf:"varint,2,opt,name=nsec,proto3" json:"nsec,omitempty"`
}

func (m *GetUIDataResponse_Timestamp) Reset()         { *m = GetUIDataResponse_Timestamp{} }
func (m *GetUIDataResponse_Timestamp) String() string { return proto.CompactTextString(m) }
func (*GetUIDataResponse_Timestamp) ProtoMessage()    {}
func (*GetUIDataResponse_Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptorAdmin, []int{13, 0}
}

type GetUIDataResponse_Value struct {
	// value is the value of the requested key.
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// last_updated is the time at which the value was last updated.
	LastUpdated GetUIDataResponse_Timestamp `protobuf:"bytes,2,opt,name=last_updated,json=lastUpdated" json:"last_updated"`
}

func (m *GetUIDataResponse_Value) Reset()                    { *m = GetUIDataResponse_Value{} }
func (m *GetUIDataResponse_Value) String() string            { return proto.CompactTextString(m) }
func (*GetUIDataResponse_Value) ProtoMessage()               {}
func (*GetUIDataResponse_Value) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{13, 1} }

// ClusterRequest requests metadata for the cluster.
type ClusterRequest struct {
}

func (m *ClusterRequest) Reset()                    { *m = ClusterRequest{} }
func (m *ClusterRequest) String() string            { return proto.CompactTextString(m) }
func (*ClusterRequest) ProtoMessage()               {}
func (*ClusterRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{14} }

// ClusterResponse contains metadata for the cluster.
type ClusterResponse struct {
	ClusterID string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *ClusterResponse) Reset()                    { *m = ClusterResponse{} }
func (m *ClusterResponse) String() string            { return proto.CompactTextString(m) }
func (*ClusterResponse) ProtoMessage()               {}
func (*ClusterResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{15} }

// DrainRequest requests the server to enter the specified draining mode. The
// server first deactivates all the modes specified in 'off' and then activates
// all those in 'on'.
type DrainRequest struct {
	// These are actually of type DrainMode, but grpc-gateway does not support
	// proxying enum fields (yet: https://github.com/gengo/grpc-gateway/issues/5)
	// and it fails in pretty dramatic ways (panics the server).
	On  []int32 `protobuf:"varint,1,rep,name=on" json:"on,omitempty"`
	Off []int32 `protobuf:"varint,2,rep,name=off" json:"off,omitempty"`
	// When true, terminates the process after the given drain modes have been
	// activated.
	Shutdown bool `protobuf:"varint,3,opt,name=shutdown,proto3" json:"shutdown,omitempty"`
}

func (m *DrainRequest) Reset()                    { *m = DrainRequest{} }
func (m *DrainRequest) String() string            { return proto.CompactTextString(m) }
func (*DrainRequest) ProtoMessage()               {}
func (*DrainRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{16} }

// DrainResponse is the response to a successful DrainRequest and lists the
// modes which are activated after having processing the request.
type DrainResponse struct {
	On []int32 `protobuf:"varint,1,rep,name=on" json:"on,omitempty"`
}

func (m *DrainResponse) Reset()                    { *m = DrainResponse{} }
func (m *DrainResponse) String() string            { return proto.CompactTextString(m) }
func (*DrainResponse) ProtoMessage()               {}
func (*DrainResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{17} }

// HealthRequest inquires whether the addressed node is healthy.
type HealthRequest struct {
}

func (m *HealthRequest) Reset()                    { *m = HealthRequest{} }
func (m *HealthRequest) String() string            { return proto.CompactTextString(m) }
func (*HealthRequest) ProtoMessage()               {}
func (*HealthRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{18} }

// HealthResponse is the response to HealthRequest. It currently does not
// contain any information.
// TODO(tschottdorf): Should it contain information, and if so, what?
type HealthResponse struct {
}

func (m *HealthResponse) Reset()                    { *m = HealthResponse{} }
func (m *HealthResponse) String() string            { return proto.CompactTextString(m) }
func (*HealthResponse) ProtoMessage()               {}
func (*HealthResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{19} }

// ClusterFreezeRequest lets the receiving node go through all Ranges in the
// cluster, freezing them in preparation for an upgrade.
type ClusterFreezeRequest struct {
	// When set, attempt to freeze the cluster in preparation for a
	// stop-the-world upgrade. When unset, attempt to unfreeze any
	// frozen Ranges.
	Freeze bool `protobuf:"varint,1,opt,name=freeze,proto3" json:"freeze,omitempty"`
}

func (m *ClusterFreezeRequest) Reset()                    { *m = ClusterFreezeRequest{} }
func (m *ClusterFreezeRequest) String() string            { return proto.CompactTextString(m) }
func (*ClusterFreezeRequest) ProtoMessage()               {}
func (*ClusterFreezeRequest) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{20} }

// ClusterFreezeResponse is the response to a ClusterFreezeRequest. It contains
// the number of Ranges whose freeze state changed as a result of the request.
type ClusterFreezeResponse struct {
	RangesAffected int64 `protobuf:"varint,1,opt,name=ranges_affected,json=rangesAffected,proto3" json:"ranges_affected,omitempty"`
}

func (m *ClusterFreezeResponse) Reset()                    { *m = ClusterFreezeResponse{} }
func (m *ClusterFreezeResponse) String() string            { return proto.CompactTextString(m) }
func (*ClusterFreezeResponse) ProtoMessage()               {}
func (*ClusterFreezeResponse) Descriptor() ([]byte, []int) { return fileDescriptorAdmin, []int{21} }

func init() {
	proto.RegisterType((*DatabasesRequest)(nil), "cockroach.server.DatabasesRequest")
	proto.RegisterType((*DatabasesResponse)(nil), "cockroach.server.DatabasesResponse")
	proto.RegisterType((*DatabaseDetailsRequest)(nil), "cockroach.server.DatabaseDetailsRequest")
	proto.RegisterType((*DatabaseDetailsResponse)(nil), "cockroach.server.DatabaseDetailsResponse")
	proto.RegisterType((*DatabaseDetailsResponse_Grant)(nil), "cockroach.server.DatabaseDetailsResponse.Grant")
	proto.RegisterType((*TableDetailsRequest)(nil), "cockroach.server.TableDetailsRequest")
	proto.RegisterType((*TableDetailsResponse)(nil), "cockroach.server.TableDetailsResponse")
	proto.RegisterType((*TableDetailsResponse_Grant)(nil), "cockroach.server.TableDetailsResponse.Grant")
	proto.RegisterType((*TableDetailsResponse_Column)(nil), "cockroach.server.TableDetailsResponse.Column")
	proto.RegisterType((*TableDetailsResponse_Index)(nil), "cockroach.server.TableDetailsResponse.Index")
	proto.RegisterType((*UsersRequest)(nil), "cockroach.server.UsersRequest")
	proto.RegisterType((*UsersResponse)(nil), "cockroach.server.UsersResponse")
	proto.RegisterType((*UsersResponse_User)(nil), "cockroach.server.UsersResponse.User")
	proto.RegisterType((*EventsRequest)(nil), "cockroach.server.EventsRequest")
	proto.RegisterType((*EventsResponse)(nil), "cockroach.server.EventsResponse")
	proto.RegisterType((*EventsResponse_Event)(nil), "cockroach.server.EventsResponse.Event")
	proto.RegisterType((*EventsResponse_Event_Timestamp)(nil), "cockroach.server.EventsResponse.Event.Timestamp")
	proto.RegisterType((*SetUIDataRequest)(nil), "cockroach.server.SetUIDataRequest")
	proto.RegisterType((*SetUIDataResponse)(nil), "cockroach.server.SetUIDataResponse")
	proto.RegisterType((*GetUIDataRequest)(nil), "cockroach.server.GetUIDataRequest")
	proto.RegisterType((*GetUIDataResponse)(nil), "cockroach.server.GetUIDataResponse")
	proto.RegisterType((*GetUIDataResponse_Timestamp)(nil), "cockroach.server.GetUIDataResponse.Timestamp")
	proto.RegisterType((*GetUIDataResponse_Value)(nil), "cockroach.server.GetUIDataResponse.Value")
	proto.RegisterType((*ClusterRequest)(nil), "cockroach.server.ClusterRequest")
	proto.RegisterType((*ClusterResponse)(nil), "cockroach.server.ClusterResponse")
	proto.RegisterType((*DrainRequest)(nil), "cockroach.server.DrainRequest")
	proto.RegisterType((*DrainResponse)(nil), "cockroach.server.DrainResponse")
	proto.RegisterType((*HealthRequest)(nil), "cockroach.server.HealthRequest")
	proto.RegisterType((*HealthResponse)(nil), "cockroach.server.HealthResponse")
	proto.RegisterType((*ClusterFreezeRequest)(nil), "cockroach.server.ClusterFreezeRequest")
	proto.RegisterType((*ClusterFreezeResponse)(nil), "cockroach.server.ClusterFreezeResponse")
	proto.RegisterEnum("cockroach.server.DrainMode", DrainMode_name, DrainMode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for Admin service

type AdminClient interface {
	// URL: /_admin/v1/users
	Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// URL: /_admin/v1/databases
	Databases(ctx context.Context, in *DatabasesRequest, opts ...grpc.CallOption) (*DatabasesResponse, error)
	// Example URL: /_admin/v1/databases/system
	DatabaseDetails(ctx context.Context, in *DatabaseDetailsRequest, opts ...grpc.CallOption) (*DatabaseDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui
	TableDetails(ctx context.Context, in *TableDetailsRequest, opts ...grpc.CallOption) (*TableDetailsResponse, error)
	// Example URLs:
	// - /_admin/v1/events?type=create_table
	// - /_admin/v1/events?type=drop_table&target_id=4
	// - /_admin/v1/events
	Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (*EventsResponse, error)
	// This requires a POST. Because of the libraries we're using, the POST body
	// must be in the following format:
	//
	// {"key_values":
	//   { "key1": "base64_encoded_value1"},
	//   ...
	//   { "keyN": "base64_encoded_valueN"},
	// }
	//
	// Note that all keys are quoted strings and that all values are base64-
	// encoded.
	//
	// Together, SetUIData and GetUIData provide access to a "cookie jar" for the
	// admin UI. The structure of the underlying data is meant to be opaque to the
	// server.
	SetUIData(ctx context.Context, in *SetUIDataRequest, opts ...grpc.CallOption) (*SetUIDataResponse, error)
	// Example URLs:
	// - /_admin/v1/uidata?keys=MYKEY
	// - /_admin/v1/uidata?keys=MYKEY1&keys=MYKEY2
	//
	// Yes, it's a little odd that the query parameter is named "keys" instead of
	// "key". I would've preferred that the URL parameter be named "key". However,
	// it's clearer for the protobuf field to be named "keys," which makes the URL
	// parameter "keys" as well.
	GetUIData(ctx context.Context, in *GetUIDataRequest, opts ...grpc.CallOption) (*GetUIDataResponse, error)
	// Cluster returns metadata for the cluster.
	Cluster(ctx context.Context, in *ClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error)
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// Drain puts the node into the specified drain mode(s) and optionally
	// instructs the process to terminate.
	Drain(ctx context.Context, in *DrainRequest, opts ...grpc.CallOption) (*DrainResponse, error)
	// ClusterFreeze freezes/unfreezes the cluster.
	ClusterFreeze(ctx context.Context, in *ClusterFreezeRequest, opts ...grpc.CallOption) (*ClusterFreezeResponse, error)
}

type adminClient struct {
	cc *grpc.ClientConn
}

func NewAdminClient(cc *grpc.ClientConn) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Users", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Databases(ctx context.Context, in *DatabasesRequest, opts ...grpc.CallOption) (*DatabasesResponse, error) {
	out := new(DatabasesResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Databases", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) DatabaseDetails(ctx context.Context, in *DatabaseDetailsRequest, opts ...grpc.CallOption) (*DatabaseDetailsResponse, error) {
	out := new(DatabaseDetailsResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/DatabaseDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) TableDetails(ctx context.Context, in *TableDetailsRequest, opts ...grpc.CallOption) (*TableDetailsResponse, error) {
	out := new(TableDetailsResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/TableDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Events(ctx context.Context, in *EventsRequest, opts ...grpc.CallOption) (*EventsResponse, error) {
	out := new(EventsResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Events", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) SetUIData(ctx context.Context, in *SetUIDataRequest, opts ...grpc.CallOption) (*SetUIDataResponse, error) {
	out := new(SetUIDataResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/SetUIData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) GetUIData(ctx context.Context, in *GetUIDataRequest, opts ...grpc.CallOption) (*GetUIDataResponse, error) {
	out := new(GetUIDataResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/GetUIData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Cluster(ctx context.Context, in *ClusterRequest, opts ...grpc.CallOption) (*ClusterResponse, error) {
	out := new(ClusterResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Cluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	out := new(HealthResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Health", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) Drain(ctx context.Context, in *DrainRequest, opts ...grpc.CallOption) (*DrainResponse, error) {
	out := new(DrainResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/Drain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ClusterFreeze(ctx context.Context, in *ClusterFreezeRequest, opts ...grpc.CallOption) (*ClusterFreezeResponse, error) {
	out := new(ClusterFreezeResponse)
	err := grpc.Invoke(ctx, "/cockroach.server.Admin/ClusterFreeze", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Admin service

type AdminServer interface {
	// URL: /_admin/v1/users
	Users(context.Context, *UsersRequest) (*UsersResponse, error)
	// URL: /_admin/v1/databases
	Databases(context.Context, *DatabasesRequest) (*DatabasesResponse, error)
	// Example URL: /_admin/v1/databases/system
	DatabaseDetails(context.Context, *DatabaseDetailsRequest) (*DatabaseDetailsResponse, error)
	// Example URL: /_admin/v1/databases/system/tables/ui
	TableDetails(context.Context, *TableDetailsRequest) (*TableDetailsResponse, error)
	// Example URLs:
	// - /_admin/v1/events?type=create_table
	// - /_admin/v1/events?type=drop_table&target_id=4
	// - /_admin/v1/events
	Events(context.Context, *EventsRequest) (*EventsResponse, error)
	// This requires a POST. Because of the libraries we're using, the POST body
	// must be in the following format:
	//
	// {"key_values":
	//   { "key1": "base64_encoded_value1"},
	//   ...
	//   { "keyN": "base64_encoded_valueN"},
	// }
	//
	// Note that all keys are quoted strings and that all values are base64-
	// encoded.
	//
	// Together, SetUIData and GetUIData provide access to a "cookie jar" for the
	// admin UI. The structure of the underlying data is meant to be opaque to the
	// server.
	SetUIData(context.Context, *SetUIDataRequest) (*SetUIDataResponse, error)
	// Example URLs:
	// - /_admin/v1/uidata?keys=MYKEY
	// - /_admin/v1/uidata?keys=MYKEY1&keys=MYKEY2
	//
	// Yes, it's a little odd that the query parameter is named "keys" instead of
	// "key". I would've preferred that the URL parameter be named "key". However,
	// it's clearer for the protobuf field to be named "keys," which makes the URL
	// parameter "keys" as well.
	GetUIData(context.Context, *GetUIDataRequest) (*GetUIDataResponse, error)
	// Cluster returns metadata for the cluster.
	Cluster(context.Context, *ClusterRequest) (*ClusterResponse, error)
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// Drain puts the node into the specified drain mode(s) and optionally
	// instructs the process to terminate.
	Drain(context.Context, *DrainRequest) (*DrainResponse, error)
	// ClusterFreeze freezes/unfreezes the cluster.
	ClusterFreeze(context.Context, *ClusterFreezeRequest) (*ClusterFreezeResponse, error)
}

func RegisterAdminServer(s *grpc.Server, srv AdminServer) {
	s.RegisterService(&_Admin_serviceDesc, srv)
}

func _Admin_Users_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Users(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Users",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Users(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Databases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Databases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Databases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Databases(ctx, req.(*DatabasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_DatabaseDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).DatabaseDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/DatabaseDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).DatabaseDetails(ctx, req.(*DatabaseDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_TableDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).TableDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/TableDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).TableDetails(ctx, req.(*TableDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Events_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Events(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Events",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Events(ctx, req.(*EventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_SetUIData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUIDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).SetUIData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/SetUIData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).SetUIData(ctx, req.(*SetUIDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_GetUIData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUIDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).GetUIData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/GetUIData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).GetUIData(ctx, req.(*GetUIDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Cluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Cluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Cluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Cluster(ctx, req.(*ClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_Drain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DrainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).Drain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/Drain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).Drain(ctx, req.(*DrainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ClusterFreeze_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterFreezeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ClusterFreeze(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.Admin/ClusterFreeze",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ClusterFreeze(ctx, req.(*ClusterFreezeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.server.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Users",
			Handler:    _Admin_Users_Handler,
		},
		{
			MethodName: "Databases",
			Handler:    _Admin_Databases_Handler,
		},
		{
			MethodName: "DatabaseDetails",
			Handler:    _Admin_DatabaseDetails_Handler,
		},
		{
			MethodName: "TableDetails",
			Handler:    _Admin_TableDetails_Handler,
		},
		{
			MethodName: "Events",
			Handler:    _Admin_Events_Handler,
		},
		{
			MethodName: "SetUIData",
			Handler:    _Admin_SetUIData_Handler,
		},
		{
			MethodName: "GetUIData",
			Handler:    _Admin_GetUIData_Handler,
		},
		{
			MethodName: "Cluster",
			Handler:    _Admin_Cluster_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Admin_Health_Handler,
		},
		{
			MethodName: "Drain",
			Handler:    _Admin_Drain_Handler,
		},
		{
			MethodName: "ClusterFreeze",
			Handler:    _Admin_ClusterFreeze_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *DatabasesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabasesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DatabasesResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabasesResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Databases) > 0 {
		for _, s := range m.Databases {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DatabaseDetailsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabaseDetailsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Database) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Database)))
		i += copy(data[i:], m.Database)
	}
	return i, nil
}

func (m *DatabaseDetailsResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabaseDetailsResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, msg := range m.Grants {
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TableNames) > 0 {
		for _, s := range m.TableNames {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DatabaseDetailsResponse_Grant) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DatabaseDetailsResponse_Grant) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.User)))
		i += copy(data[i:], m.User)
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *TableDetailsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDetailsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Database) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Database)))
		i += copy(data[i:], m.Database)
	}
	if len(m.Table) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Table)))
		i += copy(data[i:], m.Table)
	}
	return i, nil
}

func (m *TableDetailsResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDetailsResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, msg := range m.Grants {
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			data[i] = 0x12
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Indexes) > 0 {
		for _, msg := range m.Indexes {
			data[i] = 0x1a
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RangeCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAdmin(data, i, uint64(m.RangeCount))
	}
	return i, nil
}

func (m *TableDetailsResponse_Grant) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDetailsResponse_Grant) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.User)))
		i += copy(data[i:], m.User)
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *TableDetailsResponse_Column) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDetailsResponse_Column) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Type) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Nullable {
		data[i] = 0x18
		i++
		if m.Nullable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.DefaultValue) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.DefaultValue)))
		i += copy(data[i:], m.DefaultValue)
	}
	return i, nil
}

func (m *TableDetailsResponse_Index) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TableDetailsResponse_Index) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Unique {
		data[i] = 0x10
		i++
		if m.Unique {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Seq != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAdmin(data, i, uint64(m.Seq))
	}
	if len(m.Column) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Column)))
		i += copy(data[i:], m.Column)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	if m.Storing {
		data[i] = 0x30
		i++
		if m.Storing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UsersRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UsersRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UsersResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UsersResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UsersResponse_User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UsersResponse_User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	return i, nil
}

func (m *EventsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.TargetId != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAdmin(data, i, uint64(m.TargetId))
	}
	return i, nil
}

func (m *EventsResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventsResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EventsResponse_Event) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventsResponse_Event) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintAdmin(data, i, uint64(m.Timestamp.Size()))
	n1, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.EventType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.EventType)))
		i += copy(data[i:], m.EventType)
	}
	if m.TargetID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAdmin(data, i, uint64(m.TargetID))
	}
	if m.ReportingID != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAdmin(data, i, uint64(m.ReportingID))
	}
	if len(m.Info) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Info)))
		i += copy(data[i:], m.Info)
	}
	if len(m.UniqueID) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.UniqueID)))
		i += copy(data[i:], m.UniqueID)
	}
	return i, nil
}

func (m *EventsResponse_Event_Timestamp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventsResponse_Event_Timestamp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sec != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAdmin(data, i, uint64(m.Sec))
	}
	if m.Nsec != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAdmin(data, i, uint64(m.Nsec))
	}
	return i, nil
}

func (m *SetUIDataRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUIDataRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		keysForKeyValues := make([]string, 0, len(m.KeyValues))
		for k := range m.KeyValues {
			keysForKeyValues = append(keysForKeyValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKeyValues)
		for _, k := range keysForKeyValues {
			data[i] = 0xa
			i++
			v := m.KeyValues[string(k)]
			mapSize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + len(v) + sovAdmin(uint64(len(v)))
			i = encodeVarintAdmin(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAdmin(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *SetUIDataResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUIDataResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetUIDataRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUIDataRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *GetUIDataResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUIDataResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		keysForKeyValues := make([]string, 0, len(m.KeyValues))
		for k := range m.KeyValues {
			keysForKeyValues = append(keysForKeyValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKeyValues)
		for _, k := range keysForKeyValues {
			data[i] = 0xa
			i++
			v := m.KeyValues[string(k)]
			msgSize := (&v).Size()
			mapSize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + msgSize + sovAdmin(uint64(msgSize))
			i = encodeVarintAdmin(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAdmin(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAdmin(data, i, uint64((&v).Size()))
			n2, err := (&v).MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n2
		}
	}
	return i, nil
}

func (m *GetUIDataResponse_Timestamp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUIDataResponse_Timestamp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sec != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAdmin(data, i, uint64(m.Sec))
	}
	if m.Nsec != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAdmin(data, i, uint64(m.Nsec))
	}
	return i, nil
}

func (m *GetUIDataResponse_Value) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUIDataResponse_Value) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	data[i] = 0x12
	i++
	i = encodeVarintAdmin(data, i, uint64(m.LastUpdated.Size()))
	n3, err := m.LastUpdated.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *ClusterRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ClusterResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAdmin(data, i, uint64(len(m.ClusterID)))
		i += copy(data[i:], m.ClusterID)
	}
	return i, nil
}

func (m *DrainRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DrainRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, num := range m.On {
			data[i] = 0x8
			i++
			i = encodeVarintAdmin(data, i, uint64(num))
		}
	}
	if len(m.Off) > 0 {
		for _, num := range m.Off {
			data[i] = 0x10
			i++
			i = encodeVarintAdmin(data, i, uint64(num))
		}
	}
	if m.Shutdown {
		data[i] = 0x18
		i++
		if m.Shutdown {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DrainResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DrainResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, num := range m.On {
			data[i] = 0x8
			i++
			i = encodeVarintAdmin(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *HealthRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HealthRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *HealthResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HealthResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ClusterFreezeRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterFreezeRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Freeze {
		data[i] = 0x8
		i++
		if m.Freeze {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClusterFreezeResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterFreezeResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangesAffected != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAdmin(data, i, uint64(m.RangesAffected))
	}
	return i, nil
}

func encodeFixed64Admin(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Admin(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAdmin(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *DatabasesRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DatabasesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Databases) > 0 {
		for _, s := range m.Databases {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DatabaseDetailsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DatabaseDetailsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.TableNames) > 0 {
		for _, s := range m.TableNames {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *DatabaseDetailsResponse_Grant) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *TableDetailsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TableDetailsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.RangeCount != 0 {
		n += 1 + sovAdmin(uint64(m.RangeCount))
	}
	return n
}

func (m *TableDetailsResponse_Grant) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if len(m.Privileges) > 0 {
		for _, s := range m.Privileges {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *TableDetailsResponse_Column) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Nullable {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TableDetailsResponse_Index) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Unique {
		n += 2
	}
	if m.Seq != 0 {
		n += 1 + sovAdmin(uint64(m.Seq))
	}
	l = len(m.Column)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.Storing {
		n += 2
	}
	return n
}

func (m *UsersRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UsersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *UsersResponse_User) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *EventsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.TargetId != 0 {
		n += 1 + sovAdmin(uint64(m.TargetId))
	}
	return n
}

func (m *EventsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *EventsResponse_Event) Size() (n int) {
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovAdmin(uint64(l))
	l = len(m.EventType)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	if m.TargetID != 0 {
		n += 1 + sovAdmin(uint64(m.TargetID))
	}
	if m.ReportingID != 0 {
		n += 1 + sovAdmin(uint64(m.ReportingID))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.UniqueID)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *EventsResponse_Event_Timestamp) Size() (n int) {
	var l int
	_ = l
	if m.Sec != 0 {
		n += 1 + sovAdmin(uint64(m.Sec))
	}
	if m.Nsec != 0 {
		n += 1 + sovAdmin(uint64(m.Nsec))
	}
	return n
}

func (m *SetUIDataRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		for k, v := range m.KeyValues {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + len(v) + sovAdmin(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SetUIDataResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetUIDataRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *GetUIDataResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.KeyValues) > 0 {
		for k, v := range m.KeyValues {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovAdmin(uint64(len(k))) + 1 + l + sovAdmin(uint64(l))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetUIDataResponse_Timestamp) Size() (n int) {
	var l int
	_ = l
	if m.Sec != 0 {
		n += 1 + sovAdmin(uint64(m.Sec))
	}
	if m.Nsec != 0 {
		n += 1 + sovAdmin(uint64(m.Nsec))
	}
	return n
}

func (m *GetUIDataResponse_Value) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = m.LastUpdated.Size()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *ClusterRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ClusterResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DrainRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, e := range m.On {
			n += 1 + sovAdmin(uint64(e))
		}
	}
	if len(m.Off) > 0 {
		for _, e := range m.Off {
			n += 1 + sovAdmin(uint64(e))
		}
	}
	if m.Shutdown {
		n += 2
	}
	return n
}

func (m *DrainResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.On) > 0 {
		for _, e := range m.On {
			n += 1 + sovAdmin(uint64(e))
		}
	}
	return n
}

func (m *HealthRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *HealthResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ClusterFreezeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Freeze {
		n += 2
	}
	return n
}

func (m *ClusterFreezeResponse) Size() (n int) {
	var l int
	_ = l
	if m.RangesAffected != 0 {
		n += 1 + sovAdmin(uint64(m.RangesAffected))
	}
	return n
}

func sovAdmin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdmin(x uint64) (n int) {
	return sovAdmin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DatabasesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabasesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabasesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabasesResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabasesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabasesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Databases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Databases = append(m.Databases, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, DatabaseDetailsResponse_Grant{})
			if err := m.Grants[len(m.Grants)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableNames = append(m.TableNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseDetailsResponse_Grant) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, TableDetailsResponse_Grant{})
			if err := m.Grants[len(m.Grants)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, TableDetailsResponse_Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, TableDetailsResponse_Index{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RangeCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Grant) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Column) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDetailsResponse_Index) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Storing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, UsersResponse_User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersResponse_User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, EventsResponse_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse_Event) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			m.TargetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TargetID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportingID", wireType)
			}
			m.ReportingID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReportingID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueID = append(m.UniqueID[:0], data[iNdEx:postIndex]...)
			if m.UniqueID == nil {
				m.UniqueID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventsResponse_Event_Timestamp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sec", wireType)
			}
			m.Sec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nsec", wireType)
			}
			m.Nsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nsec |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUIDataRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUIDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUIDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAdmin
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.KeyValues == nil {
				m.KeyValues = make(map[string][]byte)
			}
			m.KeyValues[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUIDataResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUIDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUIDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUIDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUIDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUIDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUIDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAdmin
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthAdmin
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &GetUIDataResponse_Value{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.KeyValues == nil {
				m.KeyValues = make(map[string]GetUIDataResponse_Value)
			}
			m.KeyValues[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataResponse_Timestamp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sec", wireType)
			}
			m.Sec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nsec", wireType)
			}
			m.Nsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nsec |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUIDataResponse_Value) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastUpdated.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrainRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.On = append(m.On, v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Off", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Off = append(m.Off, v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shutdown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shutdown = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrainResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.On = append(m.On, v)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFreezeRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFreezeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFreezeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Freeze", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Freeze = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFreezeResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFreezeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFreezeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangesAffected", wireType)
			}
			m.RangesAffected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RangesAffected |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmin(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAdmin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdmin(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdmin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmin   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorAdmin = []byte{
	// 1467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xc6, 0xb1, 0x13, 0x3f, 0xdb, 0x89, 0x33, 0x4d, 0x4b, 0xba, 0x0d, 0x71, 0x3b, 0x2d,
	0x49, 0x5b, 0x15, 0xbb, 0x31, 0x08, 0xa1, 0x82, 0xd4, 0x36, 0x4d, 0x48, 0x03, 0x69, 0x55, 0x6d,
	0x9d, 0x52, 0x71, 0xb1, 0xb6, 0xf6, 0xd8, 0x59, 0xea, 0xec, 0xba, 0xfb, 0x27, 0x10, 0x50, 0x2f,
	0x1c, 0xb8, 0x82, 0x84, 0xb8, 0x70, 0xe4, 0xc0, 0x47, 0x41, 0xbd, 0x20, 0x21, 0x71, 0xe1, 0x54,
	0x41, 0xe1, 0xc0, 0xb7, 0x80, 0x99, 0x37, 0x33, 0xf6, 0xda, 0xde, 0x34, 0xae, 0x38, 0x58, 0x99,
	0x79, 0x3b, 0xef, 0xfd, 0x7e, 0xef, 0xcf, 0xbc, 0x37, 0x81, 0xa5, 0x86, 0xd7, 0x78, 0xec, 0x7b,
	0x76, 0x63, 0xaf, 0x12, 0x30, 0xff, 0x80, 0xf9, 0x15, 0xbb, 0xb9, 0xef, 0xb8, 0xe5, 0xae, 0xef,
	0x85, 0x1e, 0x29, 0xf6, 0xbe, 0x96, 0xe5, 0x57, 0x73, 0xa1, 0xed, 0xb5, 0x3d, 0xfc, 0x58, 0x11,
	0x2b, 0x79, 0xce, 0x5c, 0x6a, 0x7b, 0x5e, 0xbb, 0xc3, 0x2a, 0x76, 0xd7, 0xa9, 0xd8, 0xae, 0xeb,
	0x85, 0x76, 0xe8, 0x78, 0x6e, 0x20, 0xbf, 0x52, 0x02, 0xc5, 0x0d, 0x3b, 0xb4, 0x1f, 0xd9, 0x01,
	0x0b, 0x2c, 0xf6, 0x24, 0x62, 0x41, 0x48, 0xd7, 0x60, 0x3e, 0x26, 0x0b, 0xba, 0xfc, 0x34, 0x23,
	0x4b, 0x90, 0x6d, 0x6a, 0xe1, 0xa2, 0x71, 0x36, 0x75, 0x31, 0x6b, 0xf5, 0x05, 0xf4, 0x6d, 0x38,
	0xa5, 0x55, 0x36, 0x58, 0x68, 0x3b, 0x1d, 0x6d, 0x8c, 0x98, 0x30, 0xa3, 0x8f, 0x71, 0x35, 0x83,
	0xab, 0xf5, 0xf6, 0xf4, 0x67, 0x03, 0x5e, 0x1b, 0x51, 0x53, 0x78, 0x77, 0x20, 0xd3, 0xf6, 0x6d,
	0x37, 0x94, 0x60, 0xb9, 0x6a, 0xa5, 0x3c, 0xec, 0x6f, 0xf9, 0x08, 0xd5, 0xf2, 0x96, 0xd0, 0x5b,
	0x9f, 0x7a, 0xf6, 0xbc, 0x34, 0x61, 0x29, 0x23, 0xa4, 0x04, 0x39, 0x7e, 0xb8, 0xc3, 0xea, 0xae,
	0xbd, 0xcf, 0x1d, 0x98, 0x44, 0x07, 0x00, 0x45, 0x77, 0x85, 0xc4, 0x7c, 0x0f, 0xd2, 0xa8, 0x47,
	0x08, 0x4c, 0x45, 0x1c, 0x40, 0x91, 0xc5, 0x35, 0x59, 0x06, 0xe8, 0xfa, 0xce, 0x81, 0xd3, 0x61,
	0xed, 0xbe, 0x72, 0x5f, 0x42, 0xb7, 0xe0, 0x44, 0x4d, 0x98, 0x1a, 0xdf, 0x77, 0xb2, 0x00, 0x69,
	0x44, 0xe7, 0xd6, 0xc4, 0x07, 0xb9, 0xa1, 0xff, 0x4c, 0xc1, 0xc2, 0xa0, 0x25, 0x15, 0x8e, 0x0f,
	0x87, 0xc2, 0x71, 0x65, 0x34, 0x1c, 0x49, 0x7a, 0x89, 0xb1, 0xb8, 0x03, 0xd3, 0x0d, 0xaf, 0x13,
	0xed, 0xbb, 0xd2, 0x95, 0x5c, 0xf5, 0xcd, 0x31, 0x8d, 0xdd, 0x42, 0x2d, 0x65, 0x4d, 0xdb, 0x20,
	0x3b, 0x30, 0xed, 0xb8, 0x4d, 0xf6, 0x39, 0x8f, 0x4c, 0xea, 0x95, 0xb8, 0x6d, 0x0b, 0x2d, 0x6d,
	0x4d, 0x99, 0x10, 0x89, 0xe2, 0x2c, 0xdb, 0xac, 0xde, 0xf0, 0x22, 0x37, 0x5c, 0x9c, 0xe2, 0xd1,
	0x49, 0x59, 0x80, 0xa2, 0x5b, 0x42, 0xf2, 0xbf, 0x12, 0x65, 0x3e, 0x81, 0x8c, 0x74, 0x42, 0x68,
	0x8b, 0x52, 0xd0, 0xda, 0x62, 0x2d, 0x64, 0xe1, 0x61, 0x57, 0xa7, 0x04, 0xd7, 0x22, 0x87, 0x6e,
	0xd4, 0xe9, 0x60, 0xaa, 0x52, 0x5c, 0x3e, 0x63, 0xf5, 0xf6, 0xe4, 0x3c, 0x14, 0x9a, 0xac, 0x65,
	0x47, 0x9d, 0xb0, 0x7e, 0x60, 0x77, 0x22, 0x86, 0x6c, 0xb3, 0x56, 0x5e, 0x09, 0x1f, 0x08, 0x99,
	0xf9, 0xbd, 0x01, 0x69, 0xf4, 0x34, 0x11, 0xf2, 0x14, 0x64, 0x22, 0xd7, 0xe1, 0xe5, 0x82, 0xa0,
	0x33, 0x96, 0xda, 0x91, 0x22, 0xa4, 0x02, 0xf6, 0x04, 0x11, 0x53, 0x96, 0x58, 0x8a, 0x93, 0x32,
	0xe2, 0x0a, 0x45, 0xed, 0xf0, 0x62, 0x3a, 0x3e, 0x6b, 0x88, 0x5b, 0xbd, 0x98, 0xc6, 0x4f, 0x7d,
	0x01, 0x59, 0x84, 0xe9, 0x20, 0xf4, 0x7c, 0xc7, 0x6d, 0x2f, 0x66, 0x10, 0x40, 0x6f, 0xe9, 0x2c,
	0xe4, 0x77, 0x79, 0xc8, 0x7a, 0xb7, 0x3e, 0x82, 0x82, 0xda, 0xab, 0x92, 0xbb, 0x01, 0x69, 0x11,
	0x53, 0x5d, 0x71, 0x17, 0x46, 0xb3, 0x3a, 0x70, 0x1e, 0x77, 0x2a, 0x9b, 0x52, 0xd1, 0xa4, 0x30,
	0x25, 0x84, 0x22, 0x86, 0x42, 0x10, 0x73, 0xbe, 0xb7, 0xa7, 0x37, 0xa0, 0xb0, 0x79, 0xc0, 0x78,
	0x59, 0xea, 0x4b, 0xa3, 0x93, 0x60, 0xc4, 0x92, 0x70, 0x06, 0xb2, 0xa1, 0xed, 0xb7, 0x59, 0x58,
	0x77, 0x9a, 0x18, 0xa8, 0x94, 0x35, 0x23, 0x05, 0xdb, 0x4d, 0xfa, 0x53, 0x0a, 0x66, 0xb5, 0x09,
	0x45, 0x7d, 0x03, 0x32, 0x0c, 0x25, 0x8a, 0xfb, 0xca, 0x28, 0xf7, 0x41, 0x0d, 0xb9, 0xd5, 0xf7,
	0x44, 0xea, 0x9a, 0xbf, 0x4c, 0x42, 0x1a, 0xe5, 0xa4, 0xc6, 0xf1, 0x1d, 0xde, 0x25, 0x42, 0x7b,
	0xbf, 0x8b, 0xc4, 0x72, 0xd5, 0xab, 0xe3, 0x99, 0x2c, 0xd7, 0xb4, 0x9e, 0x32, 0xde, 0x37, 0x44,
	0x5e, 0x07, 0x40, 0xa4, 0x7a, 0xac, 0xe8, 0xb2, 0x28, 0xa9, 0x09, 0xa7, 0x2f, 0xc5, 0x9d, 0xc6,
	0x42, 0x58, 0xcf, 0xbf, 0x78, 0x5e, 0x9a, 0xa9, 0x49, 0xc7, 0x37, 0xfa, 0x21, 0x20, 0x55, 0xc8,
	0xfb, 0xac, 0xeb, 0xf9, 0x21, 0x4f, 0xac, 0x38, 0x8d, 0xb7, 0x66, 0x7d, 0x8e, 0x9f, 0xce, 0x59,
	0x5a, 0xce, 0x15, 0x72, 0xbd, 0x43, 0x5c, 0x87, 0xc7, 0xd9, 0x71, 0x5b, 0x9e, 0x2a, 0x19, 0x5c,
	0x0b, 0x48, 0x59, 0x7f, 0xc2, 0x88, 0xa8, 0x97, 0xbc, 0x84, 0xdc, 0x45, 0xa1, 0x80, 0x94, 0x9f,
	0xb7, 0x9b, 0xe6, 0x1a, 0x64, 0x7b, 0xae, 0xc9, 0x6a, 0x6d, 0x60, 0x64, 0xb0, 0x5a, 0x1b, 0x58,
	0xeb, 0x42, 0x24, 0xbc, 0x2a, 0x58, 0xb8, 0xa6, 0x3f, 0x1a, 0x50, 0xbc, 0xcf, 0xc2, 0xdd, 0x6d,
	0xd1, 0xb8, 0x75, 0xba, 0xef, 0x01, 0x3c, 0x66, 0x87, 0xf2, 0xfe, 0xe8, 0x74, 0xad, 0x8d, 0xc6,
	0x76, 0x58, 0xaf, 0xfc, 0x11, 0x3b, 0xc4, 0xfb, 0x15, 0x6c, 0xba, 0xa1, 0x7f, 0x68, 0x65, 0x1f,
	0xeb, 0xbd, 0xf9, 0x3e, 0xcc, 0x0e, 0x7e, 0x14, 0xf4, 0xf8, 0x67, 0x55, 0x51, 0x62, 0x29, 0xba,
	0xaf, 0xbc, 0xb1, 0x82, 0x5f, 0xde, 0x92, 0x9b, 0x6b, 0x93, 0xef, 0x1a, 0xf4, 0x04, 0xcc, 0xc7,
	0xb0, 0x64, 0x2a, 0xe9, 0x0a, 0x14, 0xb7, 0x86, 0x89, 0x73, 0x0f, 0xb9, 0x25, 0x3d, 0x0b, 0x71,
	0x4d, 0xff, 0x9d, 0x84, 0xf9, 0xad, 0x61, 0x6d, 0xf2, 0x71, 0x82, 0x8b, 0xd5, 0x51, 0x17, 0x47,
	0x14, 0x87, 0x7c, 0xd4, 0x05, 0xd4, 0xf7, 0xf4, 0xd5, 0x73, 0x60, 0x46, 0x90, 0x46, 0xe5, 0x7e,
	0x04, 0x8c, 0x58, 0x04, 0xc8, 0x03, 0xc8, 0x77, 0xec, 0x20, 0xac, 0x47, 0x5d, 0x3e, 0xa8, 0x98,
	0xbc, 0x6b, 0x89, 0xf3, 0x61, 0x94, 0xec, 0x70, 0xa1, 0xe7, 0x84, 0xa1, 0x5d, 0x69, 0xc7, 0x6c,
	0x8f, 0x91, 0x93, 0xeb, 0xf1, 0x9c, 0xe4, 0xaa, 0x97, 0xc6, 0x01, 0x45, 0x8b, 0xf1, 0xf4, 0x15,
	0x61, 0xf6, 0x56, 0x27, 0x0a, 0x42, 0xe6, 0xeb, 0xbe, 0x76, 0x1d, 0xe6, 0x7a, 0x12, 0x95, 0x90,
	0x2b, 0x00, 0x0d, 0x29, 0x12, 0x75, 0x8e, 0x14, 0xd6, 0x0b, 0xbc, 0xce, 0xb3, 0xea, 0x20, 0x2f,
	0xf4, 0xac, 0x3a, 0xc0, 0xfb, 0xcb, 0x0e, 0xe4, 0x37, 0x7c, 0xdb, 0x71, 0x75, 0xe2, 0x67, 0x61,
	0x92, 0x77, 0x5a, 0x91, 0xc6, 0xb4, 0xc5, 0x57, 0xc2, 0x13, 0xaf, 0xd5, 0xc2, 0x61, 0x93, 0xb6,
	0xc4, 0x52, 0xf4, 0xbb, 0x60, 0x2f, 0x0a, 0x9b, 0xde, 0x67, 0xae, 0x9e, 0x19, 0x7a, 0x4f, 0x4b,
	0x50, 0x50, 0xd6, 0x14, 0x99, 0x21, 0x73, 0x74, 0x0e, 0x0a, 0xb7, 0x99, 0xdd, 0x09, 0xf7, 0xb4,
	0x03, 0xdc, 0x25, 0x2d, 0x50, 0xe5, 0x58, 0x86, 0x05, 0xc5, 0xf4, 0x03, 0x9f, 0xb1, 0x2f, 0x98,
	0x66, 0xc6, 0x47, 0x44, 0x0b, 0x05, 0xe8, 0x13, 0x1f, 0x26, 0x72, 0xc7, 0x7b, 0xec, 0xc9, 0xa1,
	0xf3, 0x0a, 0x7b, 0x15, 0xe6, 0x70, 0xb2, 0x06, 0x75, 0xbb, 0xd5, 0xe2, 0x13, 0x83, 0x35, 0x55,
	0xfd, 0xcc, 0x4a, 0xf1, 0x4d, 0x25, 0xbd, 0xbc, 0x0a, 0x59, 0x64, 0x7d, 0xc7, 0x6b, 0x32, 0x02,
	0x7c, 0x88, 0xee, 0x6c, 0x6f, 0xde, 0xad, 0x15, 0x27, 0x38, 0x7b, 0xd8, 0xd9, 0xbc, 0xb9, 0xb1,
	0x69, 0xdd, 0xbf, 0xbd, 0x7d, 0xaf, 0x68, 0x54, 0x7f, 0x00, 0x48, 0xdf, 0x14, 0xaf, 0x54, 0xf2,
	0x08, 0xd2, 0x38, 0x1f, 0xc8, 0xf2, 0x91, 0x83, 0x03, 0x59, 0x9b, 0xa5, 0x63, 0x06, 0x0b, 0x5d,
	0xfc, 0xea, 0xb7, 0xbf, 0xbf, 0x9b, 0x24, 0xa4, 0x58, 0xa9, 0xe3, 0x03, 0xb8, 0x72, 0xb0, 0x56,
	0xc1, 0x01, 0x43, 0x7c, 0x4e, 0x4b, 0xbf, 0x41, 0x09, 0x3d, 0xfa, 0x85, 0xd8, 0xc3, 0x3a, 0xff,
	0xd2, 0x33, 0x0a, 0x6f, 0x09, 0xf1, 0x4e, 0x91, 0x85, 0x18, 0x5e, 0xef, 0xa9, 0x4b, 0xbe, 0x31,
	0x60, 0x6e, 0xe8, 0xe5, 0x49, 0x2e, 0x8e, 0xf1, 0x38, 0x95, 0x04, 0x2e, 0x8d, 0xfd, 0x8c, 0xa5,
	0xab, 0x48, 0xe3, 0x1c, 0x29, 0x25, 0xd1, 0xa8, 0x7c, 0xa9, 0x97, 0x4f, 0x09, 0x7f, 0x61, 0xe4,
	0xe3, 0x0f, 0x2c, 0xf2, 0xc6, 0x71, 0x0f, 0x30, 0xc9, 0x65, 0x65, 0xbc, 0x77, 0x1a, 0x7d, 0x07,
	0x89, 0x5c, 0x25, 0xe5, 0x63, 0x88, 0x54, 0xf0, 0x0d, 0xcb, 0x25, 0xf8, 0xf7, 0x29, 0x69, 0x41,
	0x46, 0x8e, 0x44, 0x52, 0x3a, 0x7a, 0x58, 0x4a, 0x2a, 0x67, 0x8f, 0x9b, 0xa6, 0xf4, 0x34, 0x92,
	0x38, 0x41, 0xe6, 0x63, 0x24, 0xe4, 0x9c, 0x16, 0x55, 0xd0, 0x6b, 0xd9, 0x49, 0x55, 0x30, 0x3c,
	0x3b, 0x92, 0xaa, 0x60, 0xb4, 0xe7, 0xab, 0x2a, 0xa0, 0x71, 0xc0, 0xc8, 0x11, 0xce, 0x5e, 0x33,
	0x2e, 0x13, 0x0f, 0xb2, 0x5b, 0x2f, 0xc3, 0xdc, 0x1a, 0x03, 0x73, 0xa4, 0x9d, 0x25, 0x3a, 0x29,
	0x31, 0xc9, 0xa7, 0x30, 0xad, 0xee, 0x30, 0x49, 0x08, 0xd6, 0x60, 0xcf, 0x33, 0xcf, 0xbd, 0xe4,
	0x84, 0x82, 0x32, 0x11, 0x6a, 0x81, 0x90, 0x18, 0x94, 0xea, 0x79, 0x22, 0x71, 0xb2, 0xe3, 0x24,
	0x25, 0x6e, 0xa0, 0x39, 0x25, 0x25, 0x6e, 0xa8, 0x59, 0x25, 0xf9, 0xb4, 0x27, 0xad, 0x33, 0x48,
	0x63, 0x57, 0x49, 0x6a, 0x11, 0xf1, 0x96, 0x9b, 0xd4, 0x22, 0x06, 0x9a, 0x28, 0x3d, 0x83, 0x20,
	0x27, 0x69, 0xbc, 0x45, 0x34, 0xc5, 0x09, 0x91, 0xab, 0xaf, 0x0d, 0x28, 0x0c, 0xf4, 0x3f, 0xb2,
	0x72, 0x64, 0x7c, 0x06, 0x1a, 0xaa, 0xb9, 0x7a, 0xec, 0x39, 0x85, 0x7f, 0x01, 0xf1, 0x97, 0xe9,
	0xe9, 0xd1, 0x68, 0x56, 0x64, 0x13, 0xe6, 0x44, 0xd6, 0xcf, 0x3e, 0xfb, 0x73, 0x79, 0xe2, 0xd9,
	0x8b, 0x65, 0xe3, 0x57, 0xfe, 0xfb, 0x9d, 0xff, 0xfe, 0xe0, 0xbf, 0x6f, 0xff, 0x5a, 0x9e, 0xf8,
	0x24, 0x23, 0xad, 0x3f, 0x9c, 0x78, 0x68, 0x3c, 0xca, 0xe0, 0x7f, 0xe6, 0x6f, 0xfd, 0x17, 0x00,
	0x00, 0xff, 0xff, 0xf2, 0x4d, 0x3f, 0x50, 0xff, 0x0f, 0x00, 0x00,
}
