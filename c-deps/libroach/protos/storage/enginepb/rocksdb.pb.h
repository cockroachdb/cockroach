// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage/enginepb/rocksdb.proto

#ifndef PROTOBUF_INCLUDED_storage_2fenginepb_2frocksdb_2eproto
#define PROTOBUF_INCLUDED_storage_2fenginepb_2frocksdb_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include "util/hlc/timestamp.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_storage_2fenginepb_2frocksdb_2eproto 

namespace protobuf_storage_2fenginepb_2frocksdb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_storage_2fenginepb_2frocksdb_2eproto
namespace cockroach {
namespace storage {
namespace enginepb {
class HistogramData;
class HistogramDataDefaultTypeInternal;
extern HistogramDataDefaultTypeInternal _HistogramData_default_instance_;
class SSTUserProperties;
class SSTUserPropertiesDefaultTypeInternal;
extern SSTUserPropertiesDefaultTypeInternal _SSTUserProperties_default_instance_;
class SSTUserPropertiesCollection;
class SSTUserPropertiesCollectionDefaultTypeInternal;
extern SSTUserPropertiesCollectionDefaultTypeInternal _SSTUserPropertiesCollection_default_instance_;
class TickersAndHistograms;
class TickersAndHistogramsDefaultTypeInternal;
extern TickersAndHistogramsDefaultTypeInternal _TickersAndHistograms_default_instance_;
class TickersAndHistograms_HistogramsEntry_DoNotUse;
class TickersAndHistograms_HistogramsEntry_DoNotUseDefaultTypeInternal;
extern TickersAndHistograms_HistogramsEntry_DoNotUseDefaultTypeInternal _TickersAndHistograms_HistogramsEntry_DoNotUse_default_instance_;
class TickersAndHistograms_TickersEntry_DoNotUse;
class TickersAndHistograms_TickersEntry_DoNotUseDefaultTypeInternal;
extern TickersAndHistograms_TickersEntry_DoNotUseDefaultTypeInternal _TickersAndHistograms_TickersEntry_DoNotUse_default_instance_;
}  // namespace enginepb
}  // namespace storage
}  // namespace cockroach
namespace google {
namespace protobuf {
template<> ::cockroach::storage::enginepb::HistogramData* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::HistogramData>(Arena*);
template<> ::cockroach::storage::enginepb::SSTUserProperties* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::SSTUserProperties>(Arena*);
template<> ::cockroach::storage::enginepb::SSTUserPropertiesCollection* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::SSTUserPropertiesCollection>(Arena*);
template<> ::cockroach::storage::enginepb::TickersAndHistograms* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::TickersAndHistograms>(Arena*);
template<> ::cockroach::storage::enginepb::TickersAndHistograms_HistogramsEntry_DoNotUse* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::TickersAndHistograms_HistogramsEntry_DoNotUse>(Arena*);
template<> ::cockroach::storage::enginepb::TickersAndHistograms_TickersEntry_DoNotUse* Arena::CreateMaybeMessage<::cockroach::storage::enginepb::TickersAndHistograms_TickersEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cockroach {
namespace storage {
namespace enginepb {

// ===================================================================

class SSTUserProperties : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.storage.enginepb.SSTUserProperties) */ {
 public:
  SSTUserProperties();
  virtual ~SSTUserProperties();

  SSTUserProperties(const SSTUserProperties& from);

  inline SSTUserProperties& operator=(const SSTUserProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSTUserProperties(SSTUserProperties&& from) noexcept
    : SSTUserProperties() {
    *this = ::std::move(from);
  }

  inline SSTUserProperties& operator=(SSTUserProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SSTUserProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SSTUserProperties* internal_default_instance() {
    return reinterpret_cast<const SSTUserProperties*>(
               &_SSTUserProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SSTUserProperties* other);
  friend void swap(SSTUserProperties& a, SSTUserProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSTUserProperties* New() const final {
    return CreateMaybeMessage<SSTUserProperties>(NULL);
  }

  SSTUserProperties* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SSTUserProperties>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SSTUserProperties& from);
  void MergeFrom(const SSTUserProperties& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SSTUserProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .cockroach.util.hlc.Timestamp ts_min = 2;
  bool has_ts_min() const;
  void clear_ts_min();
  static const int kTsMinFieldNumber = 2;
  private:
  const ::cockroach::util::hlc::Timestamp& _internal_ts_min() const;
  public:
  const ::cockroach::util::hlc::Timestamp& ts_min() const;
  ::cockroach::util::hlc::Timestamp* release_ts_min();
  ::cockroach::util::hlc::Timestamp* mutable_ts_min();
  void set_allocated_ts_min(::cockroach::util::hlc::Timestamp* ts_min);

  // .cockroach.util.hlc.Timestamp ts_max = 3;
  bool has_ts_max() const;
  void clear_ts_max();
  static const int kTsMaxFieldNumber = 3;
  private:
  const ::cockroach::util::hlc::Timestamp& _internal_ts_max() const;
  public:
  const ::cockroach::util::hlc::Timestamp& ts_max() const;
  ::cockroach::util::hlc::Timestamp* release_ts_max();
  ::cockroach::util::hlc::Timestamp* mutable_ts_max();
  void set_allocated_ts_max(::cockroach::util::hlc::Timestamp* ts_max);

  // @@protoc_insertion_point(class_scope:cockroach.storage.enginepb.SSTUserProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::cockroach::util::hlc::Timestamp* ts_min_;
  ::cockroach::util::hlc::Timestamp* ts_max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_storage_2fenginepb_2frocksdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSTUserPropertiesCollection : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.storage.enginepb.SSTUserPropertiesCollection) */ {
 public:
  SSTUserPropertiesCollection();
  virtual ~SSTUserPropertiesCollection();

  SSTUserPropertiesCollection(const SSTUserPropertiesCollection& from);

  inline SSTUserPropertiesCollection& operator=(const SSTUserPropertiesCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSTUserPropertiesCollection(SSTUserPropertiesCollection&& from) noexcept
    : SSTUserPropertiesCollection() {
    *this = ::std::move(from);
  }

  inline SSTUserPropertiesCollection& operator=(SSTUserPropertiesCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SSTUserPropertiesCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SSTUserPropertiesCollection* internal_default_instance() {
    return reinterpret_cast<const SSTUserPropertiesCollection*>(
               &_SSTUserPropertiesCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SSTUserPropertiesCollection* other);
  friend void swap(SSTUserPropertiesCollection& a, SSTUserPropertiesCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSTUserPropertiesCollection* New() const final {
    return CreateMaybeMessage<SSTUserPropertiesCollection>(NULL);
  }

  SSTUserPropertiesCollection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SSTUserPropertiesCollection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SSTUserPropertiesCollection& from);
  void MergeFrom(const SSTUserPropertiesCollection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SSTUserPropertiesCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  int sst_size() const;
  void clear_sst();
  static const int kSstFieldNumber = 1;
  ::cockroach::storage::enginepb::SSTUserProperties* mutable_sst(int index);
  ::google::protobuf::RepeatedPtrField< ::cockroach::storage::enginepb::SSTUserProperties >*
      mutable_sst();
  const ::cockroach::storage::enginepb::SSTUserProperties& sst(int index) const;
  ::cockroach::storage::enginepb::SSTUserProperties* add_sst();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::storage::enginepb::SSTUserProperties >&
      sst() const;

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:cockroach.storage.enginepb.SSTUserPropertiesCollection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::storage::enginepb::SSTUserProperties > sst_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_storage_2fenginepb_2frocksdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistogramData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.storage.enginepb.HistogramData) */ {
 public:
  HistogramData();
  virtual ~HistogramData();

  HistogramData(const HistogramData& from);

  inline HistogramData& operator=(const HistogramData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistogramData(HistogramData&& from) noexcept
    : HistogramData() {
    *this = ::std::move(from);
  }

  inline HistogramData& operator=(HistogramData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const HistogramData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistogramData* internal_default_instance() {
    return reinterpret_cast<const HistogramData*>(
               &_HistogramData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HistogramData* other);
  friend void swap(HistogramData& a, HistogramData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistogramData* New() const final {
    return CreateMaybeMessage<HistogramData>(NULL);
  }

  HistogramData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistogramData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const HistogramData& from);
  void MergeFrom(const HistogramData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double mean = 1;
  void clear_mean();
  static const int kMeanFieldNumber = 1;
  double mean() const;
  void set_mean(double value);

  // double p50 = 2;
  void clear_p50();
  static const int kP50FieldNumber = 2;
  double p50() const;
  void set_p50(double value);

  // double p95 = 3;
  void clear_p95();
  static const int kP95FieldNumber = 3;
  double p95() const;
  void set_p95(double value);

  // double p99 = 4;
  void clear_p99();
  static const int kP99FieldNumber = 4;
  double p99() const;
  void set_p99(double value);

  // double max = 5;
  void clear_max();
  static const int kMaxFieldNumber = 5;
  double max() const;
  void set_max(double value);

  // uint64 count = 6;
  void clear_count();
  static const int kCountFieldNumber = 6;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // uint64 sum = 7;
  void clear_sum();
  static const int kSumFieldNumber = 7;
  ::google::protobuf::uint64 sum() const;
  void set_sum(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cockroach.storage.enginepb.HistogramData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  double mean_;
  double p50_;
  double p95_;
  double p99_;
  double max_;
  ::google::protobuf::uint64 count_;
  ::google::protobuf::uint64 sum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_storage_2fenginepb_2frocksdb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TickersAndHistograms_TickersEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<TickersAndHistograms_TickersEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint64,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<TickersAndHistograms_TickersEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint64,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    0 > SuperType;
  TickersAndHistograms_TickersEntry_DoNotUse();
  TickersAndHistograms_TickersEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TickersAndHistograms_TickersEntry_DoNotUse& other);
  static const TickersAndHistograms_TickersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TickersAndHistograms_TickersEntry_DoNotUse*>(&_TickersAndHistograms_TickersEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class TickersAndHistograms_HistogramsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<TickersAndHistograms_HistogramsEntry_DoNotUse, 
    ::std::string, ::cockroach::storage::enginepb::HistogramData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<TickersAndHistograms_HistogramsEntry_DoNotUse, 
    ::std::string, ::cockroach::storage::enginepb::HistogramData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  TickersAndHistograms_HistogramsEntry_DoNotUse();
  TickersAndHistograms_HistogramsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TickersAndHistograms_HistogramsEntry_DoNotUse& other);
  static const TickersAndHistograms_HistogramsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TickersAndHistograms_HistogramsEntry_DoNotUse*>(&_TickersAndHistograms_HistogramsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class TickersAndHistograms : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.storage.enginepb.TickersAndHistograms) */ {
 public:
  TickersAndHistograms();
  virtual ~TickersAndHistograms();

  TickersAndHistograms(const TickersAndHistograms& from);

  inline TickersAndHistograms& operator=(const TickersAndHistograms& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TickersAndHistograms(TickersAndHistograms&& from) noexcept
    : TickersAndHistograms() {
    *this = ::std::move(from);
  }

  inline TickersAndHistograms& operator=(TickersAndHistograms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TickersAndHistograms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TickersAndHistograms* internal_default_instance() {
    return reinterpret_cast<const TickersAndHistograms*>(
               &_TickersAndHistograms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TickersAndHistograms* other);
  friend void swap(TickersAndHistograms& a, TickersAndHistograms& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TickersAndHistograms* New() const final {
    return CreateMaybeMessage<TickersAndHistograms>(NULL);
  }

  TickersAndHistograms* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TickersAndHistograms>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TickersAndHistograms& from);
  void MergeFrom(const TickersAndHistograms& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TickersAndHistograms* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, uint64> tickers = 1;
  int tickers_size() const;
  void clear_tickers();
  static const int kTickersFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint64 >&
      tickers() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::uint64 >*
      mutable_tickers();

  int histograms_size() const;
  void clear_histograms();
  static const int kHistogramsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::cockroach::storage::enginepb::HistogramData >&
      histograms() const;
  ::google::protobuf::Map< ::std::string, ::cockroach::storage::enginepb::HistogramData >*
      mutable_histograms();

  // @@protoc_insertion_point(class_scope:cockroach.storage.enginepb.TickersAndHistograms)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      TickersAndHistograms_TickersEntry_DoNotUse,
      ::std::string, ::google::protobuf::uint64,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      0 > tickers_;
  ::google::protobuf::internal::MapFieldLite<
      TickersAndHistograms_HistogramsEntry_DoNotUse,
      ::std::string, ::cockroach::storage::enginepb::HistogramData,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > histograms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_storage_2fenginepb_2frocksdb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SSTUserProperties

// string path = 1;
inline void SSTUserProperties::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SSTUserProperties::path() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.SSTUserProperties.path)
  return path_.GetNoArena();
}
inline void SSTUserProperties::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.SSTUserProperties.path)
}
#if LANG_CXX11
inline void SSTUserProperties::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.storage.enginepb.SSTUserProperties.path)
}
#endif
inline void SSTUserProperties::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.storage.enginepb.SSTUserProperties.path)
}
inline void SSTUserProperties::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.storage.enginepb.SSTUserProperties.path)
}
inline ::std::string* SSTUserProperties::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.storage.enginepb.SSTUserProperties.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SSTUserProperties::release_path() {
  // @@protoc_insertion_point(field_release:cockroach.storage.enginepb.SSTUserProperties.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SSTUserProperties::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:cockroach.storage.enginepb.SSTUserProperties.path)
}

// .cockroach.util.hlc.Timestamp ts_min = 2;
inline bool SSTUserProperties::has_ts_min() const {
  return this != internal_default_instance() && ts_min_ != NULL;
}
inline const ::cockroach::util::hlc::Timestamp& SSTUserProperties::_internal_ts_min() const {
  return *ts_min_;
}
inline const ::cockroach::util::hlc::Timestamp& SSTUserProperties::ts_min() const {
  const ::cockroach::util::hlc::Timestamp* p = ts_min_;
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.SSTUserProperties.ts_min)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
inline ::cockroach::util::hlc::Timestamp* SSTUserProperties::release_ts_min() {
  // @@protoc_insertion_point(field_release:cockroach.storage.enginepb.SSTUserProperties.ts_min)
  
  ::cockroach::util::hlc::Timestamp* temp = ts_min_;
  ts_min_ = NULL;
  return temp;
}
inline ::cockroach::util::hlc::Timestamp* SSTUserProperties::mutable_ts_min() {
  
  if (ts_min_ == NULL) {
    auto* p = CreateMaybeMessage<::cockroach::util::hlc::Timestamp>(GetArenaNoVirtual());
    ts_min_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.storage.enginepb.SSTUserProperties.ts_min)
  return ts_min_;
}
inline void SSTUserProperties::set_allocated_ts_min(::cockroach::util::hlc::Timestamp* ts_min) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ts_min_);
  }
  if (ts_min) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ts_min = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ts_min, submessage_arena);
    }
    
  } else {
    
  }
  ts_min_ = ts_min;
  // @@protoc_insertion_point(field_set_allocated:cockroach.storage.enginepb.SSTUserProperties.ts_min)
}

// .cockroach.util.hlc.Timestamp ts_max = 3;
inline bool SSTUserProperties::has_ts_max() const {
  return this != internal_default_instance() && ts_max_ != NULL;
}
inline const ::cockroach::util::hlc::Timestamp& SSTUserProperties::_internal_ts_max() const {
  return *ts_max_;
}
inline const ::cockroach::util::hlc::Timestamp& SSTUserProperties::ts_max() const {
  const ::cockroach::util::hlc::Timestamp* p = ts_max_;
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.SSTUserProperties.ts_max)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
inline ::cockroach::util::hlc::Timestamp* SSTUserProperties::release_ts_max() {
  // @@protoc_insertion_point(field_release:cockroach.storage.enginepb.SSTUserProperties.ts_max)
  
  ::cockroach::util::hlc::Timestamp* temp = ts_max_;
  ts_max_ = NULL;
  return temp;
}
inline ::cockroach::util::hlc::Timestamp* SSTUserProperties::mutable_ts_max() {
  
  if (ts_max_ == NULL) {
    auto* p = CreateMaybeMessage<::cockroach::util::hlc::Timestamp>(GetArenaNoVirtual());
    ts_max_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.storage.enginepb.SSTUserProperties.ts_max)
  return ts_max_;
}
inline void SSTUserProperties::set_allocated_ts_max(::cockroach::util::hlc::Timestamp* ts_max) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ts_max_);
  }
  if (ts_max) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ts_max = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ts_max, submessage_arena);
    }
    
  } else {
    
  }
  ts_max_ = ts_max;
  // @@protoc_insertion_point(field_set_allocated:cockroach.storage.enginepb.SSTUserProperties.ts_max)
}

// -------------------------------------------------------------------

// SSTUserPropertiesCollection

inline int SSTUserPropertiesCollection::sst_size() const {
  return sst_.size();
}
inline void SSTUserPropertiesCollection::clear_sst() {
  sst_.Clear();
}
inline ::cockroach::storage::enginepb::SSTUserProperties* SSTUserPropertiesCollection::mutable_sst(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.storage.enginepb.SSTUserPropertiesCollection.sst)
  return sst_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::storage::enginepb::SSTUserProperties >*
SSTUserPropertiesCollection::mutable_sst() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.storage.enginepb.SSTUserPropertiesCollection.sst)
  return &sst_;
}
inline const ::cockroach::storage::enginepb::SSTUserProperties& SSTUserPropertiesCollection::sst(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.SSTUserPropertiesCollection.sst)
  return sst_.Get(index);
}
inline ::cockroach::storage::enginepb::SSTUserProperties* SSTUserPropertiesCollection::add_sst() {
  // @@protoc_insertion_point(field_add:cockroach.storage.enginepb.SSTUserPropertiesCollection.sst)
  return sst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::storage::enginepb::SSTUserProperties >&
SSTUserPropertiesCollection::sst() const {
  // @@protoc_insertion_point(field_list:cockroach.storage.enginepb.SSTUserPropertiesCollection.sst)
  return sst_;
}

// string error = 2;
inline void SSTUserPropertiesCollection::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SSTUserPropertiesCollection::error() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
  return error_.GetNoArena();
}
inline void SSTUserPropertiesCollection::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
}
#if LANG_CXX11
inline void SSTUserPropertiesCollection::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
}
#endif
inline void SSTUserPropertiesCollection::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
}
inline void SSTUserPropertiesCollection::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
}
inline ::std::string* SSTUserPropertiesCollection::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SSTUserPropertiesCollection::release_error() {
  // @@protoc_insertion_point(field_release:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SSTUserPropertiesCollection::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:cockroach.storage.enginepb.SSTUserPropertiesCollection.error)
}

// -------------------------------------------------------------------

// HistogramData

// double mean = 1;
inline void HistogramData::clear_mean() {
  mean_ = 0;
}
inline double HistogramData::mean() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.mean)
  return mean_;
}
inline void HistogramData::set_mean(double value) {
  
  mean_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.mean)
}

// double p50 = 2;
inline void HistogramData::clear_p50() {
  p50_ = 0;
}
inline double HistogramData::p50() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.p50)
  return p50_;
}
inline void HistogramData::set_p50(double value) {
  
  p50_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.p50)
}

// double p95 = 3;
inline void HistogramData::clear_p95() {
  p95_ = 0;
}
inline double HistogramData::p95() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.p95)
  return p95_;
}
inline void HistogramData::set_p95(double value) {
  
  p95_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.p95)
}

// double p99 = 4;
inline void HistogramData::clear_p99() {
  p99_ = 0;
}
inline double HistogramData::p99() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.p99)
  return p99_;
}
inline void HistogramData::set_p99(double value) {
  
  p99_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.p99)
}

// double max = 5;
inline void HistogramData::clear_max() {
  max_ = 0;
}
inline double HistogramData::max() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.max)
  return max_;
}
inline void HistogramData::set_max(double value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.max)
}

// uint64 count = 6;
inline void HistogramData::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HistogramData::count() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.count)
  return count_;
}
inline void HistogramData::set_count(::google::protobuf::uint64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.count)
}

// uint64 sum = 7;
inline void HistogramData::clear_sum() {
  sum_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HistogramData::sum() const {
  // @@protoc_insertion_point(field_get:cockroach.storage.enginepb.HistogramData.sum)
  return sum_;
}
inline void HistogramData::set_sum(::google::protobuf::uint64 value) {
  
  sum_ = value;
  // @@protoc_insertion_point(field_set:cockroach.storage.enginepb.HistogramData.sum)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TickersAndHistograms

// map<string, uint64> tickers = 1;
inline int TickersAndHistograms::tickers_size() const {
  return tickers_.size();
}
inline void TickersAndHistograms::clear_tickers() {
  tickers_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint64 >&
TickersAndHistograms::tickers() const {
  // @@protoc_insertion_point(field_map:cockroach.storage.enginepb.TickersAndHistograms.tickers)
  return tickers_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::uint64 >*
TickersAndHistograms::mutable_tickers() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.storage.enginepb.TickersAndHistograms.tickers)
  return tickers_.MutableMap();
}

inline int TickersAndHistograms::histograms_size() const {
  return histograms_.size();
}
inline void TickersAndHistograms::clear_histograms() {
  histograms_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::cockroach::storage::enginepb::HistogramData >&
TickersAndHistograms::histograms() const {
  // @@protoc_insertion_point(field_map:cockroach.storage.enginepb.TickersAndHistograms.histograms)
  return histograms_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::cockroach::storage::enginepb::HistogramData >*
TickersAndHistograms::mutable_histograms() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.storage.enginepb.TickersAndHistograms.histograms)
  return histograms_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace enginepb
}  // namespace storage
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_storage_2fenginepb_2frocksdb_2eproto
