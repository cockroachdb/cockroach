// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kv/kvserver/concurrency/lock/locking.proto

#include "kv/kvserver/concurrency/lock/locking.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace kv {
namespace kvserver {
namespace concurrency {
namespace lock {
}  // namespace lock
}  // namespace concurrency
}  // namespace kvserver
}  // namespace kv
}  // namespace cockroach
namespace protobuf_kv_2fkvserver_2fconcurrency_2flock_2flocking_2eproto {
void InitDefaults() {
}

}  // namespace protobuf_kv_2fkvserver_2fconcurrency_2flock_2flocking_2eproto
namespace cockroach {
namespace kv {
namespace kvserver {
namespace concurrency {
namespace lock {
bool Strength_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool Durability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool WaitPolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace lock
}  // namespace concurrency
}  // namespace kvserver
}  // namespace kv
}  // namespace cockroach
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
