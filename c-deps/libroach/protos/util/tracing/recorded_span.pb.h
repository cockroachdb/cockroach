// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: util/tracing/recorded_span.proto

#ifndef PROTOBUF_INCLUDED_util_2ftracing_2frecorded_5fspan_2eproto
#define PROTOBUF_INCLUDED_util_2ftracing_2frecorded_5fspan_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_util_2ftracing_2frecorded_5fspan_2eproto 

namespace protobuf_util_2ftracing_2frecorded_5fspan_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_util_2ftracing_2frecorded_5fspan_2eproto
namespace cockroach {
namespace util {
namespace tracing {
class LogRecord;
class LogRecordDefaultTypeInternal;
extern LogRecordDefaultTypeInternal _LogRecord_default_instance_;
class LogRecord_Field;
class LogRecord_FieldDefaultTypeInternal;
extern LogRecord_FieldDefaultTypeInternal _LogRecord_Field_default_instance_;
class NormalizedSpan;
class NormalizedSpanDefaultTypeInternal;
extern NormalizedSpanDefaultTypeInternal _NormalizedSpan_default_instance_;
class NormalizedSpan_TagsEntry_DoNotUse;
class NormalizedSpan_TagsEntry_DoNotUseDefaultTypeInternal;
extern NormalizedSpan_TagsEntry_DoNotUseDefaultTypeInternal _NormalizedSpan_TagsEntry_DoNotUse_default_instance_;
class RecordedSpan;
class RecordedSpanDefaultTypeInternal;
extern RecordedSpanDefaultTypeInternal _RecordedSpan_default_instance_;
class RecordedSpan_BaggageEntry_DoNotUse;
class RecordedSpan_BaggageEntry_DoNotUseDefaultTypeInternal;
extern RecordedSpan_BaggageEntry_DoNotUseDefaultTypeInternal _RecordedSpan_BaggageEntry_DoNotUse_default_instance_;
class RecordedSpan_TagsEntry_DoNotUse;
class RecordedSpan_TagsEntry_DoNotUseDefaultTypeInternal;
extern RecordedSpan_TagsEntry_DoNotUseDefaultTypeInternal _RecordedSpan_TagsEntry_DoNotUse_default_instance_;
}  // namespace tracing
}  // namespace util
}  // namespace cockroach
namespace google {
namespace protobuf {
template<> ::cockroach::util::tracing::LogRecord* Arena::CreateMaybeMessage<::cockroach::util::tracing::LogRecord>(Arena*);
template<> ::cockroach::util::tracing::LogRecord_Field* Arena::CreateMaybeMessage<::cockroach::util::tracing::LogRecord_Field>(Arena*);
template<> ::cockroach::util::tracing::NormalizedSpan* Arena::CreateMaybeMessage<::cockroach::util::tracing::NormalizedSpan>(Arena*);
template<> ::cockroach::util::tracing::NormalizedSpan_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::cockroach::util::tracing::NormalizedSpan_TagsEntry_DoNotUse>(Arena*);
template<> ::cockroach::util::tracing::RecordedSpan* Arena::CreateMaybeMessage<::cockroach::util::tracing::RecordedSpan>(Arena*);
template<> ::cockroach::util::tracing::RecordedSpan_BaggageEntry_DoNotUse* Arena::CreateMaybeMessage<::cockroach::util::tracing::RecordedSpan_BaggageEntry_DoNotUse>(Arena*);
template<> ::cockroach::util::tracing::RecordedSpan_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::cockroach::util::tracing::RecordedSpan_TagsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cockroach {
namespace util {
namespace tracing {

// ===================================================================

class LogRecord_Field : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.util.tracing.LogRecord.Field) */ {
 public:
  LogRecord_Field();
  virtual ~LogRecord_Field();

  LogRecord_Field(const LogRecord_Field& from);

  inline LogRecord_Field& operator=(const LogRecord_Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogRecord_Field(LogRecord_Field&& from) noexcept
    : LogRecord_Field() {
    *this = ::std::move(from);
  }

  inline LogRecord_Field& operator=(LogRecord_Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LogRecord_Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogRecord_Field* internal_default_instance() {
    return reinterpret_cast<const LogRecord_Field*>(
               &_LogRecord_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LogRecord_Field* other);
  friend void swap(LogRecord_Field& a, LogRecord_Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogRecord_Field* New() const final {
    return CreateMaybeMessage<LogRecord_Field>(NULL);
  }

  LogRecord_Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogRecord_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LogRecord_Field& from);
  void MergeFrom(const LogRecord_Field& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogRecord_Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:cockroach.util.tracing.LogRecord.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_util_2ftracing_2frecorded_5fspan_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogRecord : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.util.tracing.LogRecord) */ {
 public:
  LogRecord();
  virtual ~LogRecord();

  LogRecord(const LogRecord& from);

  inline LogRecord& operator=(const LogRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogRecord(LogRecord&& from) noexcept
    : LogRecord() {
    *this = ::std::move(from);
  }

  inline LogRecord& operator=(LogRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const LogRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogRecord* internal_default_instance() {
    return reinterpret_cast<const LogRecord*>(
               &_LogRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LogRecord* other);
  friend void swap(LogRecord& a, LogRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogRecord* New() const final {
    return CreateMaybeMessage<LogRecord>(NULL);
  }

  LogRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogRecord>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LogRecord& from);
  void MergeFrom(const LogRecord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LogRecord_Field Field;

  // accessors -------------------------------------------------------

  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  ::cockroach::util::tracing::LogRecord_Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord_Field >*
      mutable_fields();
  const ::cockroach::util::tracing::LogRecord_Field& fields(int index) const;
  ::cockroach::util::tracing::LogRecord_Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord_Field >&
      fields() const;

  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  public:
  const ::google::protobuf::Timestamp& time() const;
  ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* time);

  // @@protoc_insertion_point(class_scope:cockroach.util.tracing.LogRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord_Field > fields_;
  ::google::protobuf::Timestamp* time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_util_2ftracing_2frecorded_5fspan_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecordedSpan_BaggageEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<RecordedSpan_BaggageEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<RecordedSpan_BaggageEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  RecordedSpan_BaggageEntry_DoNotUse();
  RecordedSpan_BaggageEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RecordedSpan_BaggageEntry_DoNotUse& other);
  static const RecordedSpan_BaggageEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RecordedSpan_BaggageEntry_DoNotUse*>(&_RecordedSpan_BaggageEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class RecordedSpan_TagsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<RecordedSpan_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<RecordedSpan_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  RecordedSpan_TagsEntry_DoNotUse();
  RecordedSpan_TagsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RecordedSpan_TagsEntry_DoNotUse& other);
  static const RecordedSpan_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RecordedSpan_TagsEntry_DoNotUse*>(&_RecordedSpan_TagsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class RecordedSpan : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.util.tracing.RecordedSpan) */ {
 public:
  RecordedSpan();
  virtual ~RecordedSpan();

  RecordedSpan(const RecordedSpan& from);

  inline RecordedSpan& operator=(const RecordedSpan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordedSpan(RecordedSpan&& from) noexcept
    : RecordedSpan() {
    *this = ::std::move(from);
  }

  inline RecordedSpan& operator=(RecordedSpan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const RecordedSpan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordedSpan* internal_default_instance() {
    return reinterpret_cast<const RecordedSpan*>(
               &_RecordedSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RecordedSpan* other);
  friend void swap(RecordedSpan& a, RecordedSpan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordedSpan* New() const final {
    return CreateMaybeMessage<RecordedSpan>(NULL);
  }

  RecordedSpan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecordedSpan>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RecordedSpan& from);
  void MergeFrom(const RecordedSpan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecordedSpan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> baggage = 5;
  int baggage_size() const;
  void clear_baggage();
  static const int kBaggageFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      baggage() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_baggage();

  // map<string, string> tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      tags() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_tags();

  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 9;
  ::cockroach::util::tracing::LogRecord* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >*
      mutable_logs();
  const ::cockroach::util::tracing::LogRecord& logs(int index) const;
  ::cockroach::util::tracing::LogRecord* add_logs();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >&
      logs() const;

  // string operation = 4;
  void clear_operation();
  static const int kOperationFieldNumber = 4;
  const ::std::string& operation() const;
  void set_operation(const ::std::string& value);
  #if LANG_CXX11
  void set_operation(::std::string&& value);
  #endif
  void set_operation(const char* value);
  void set_operation(const char* value, size_t size);
  ::std::string* mutable_operation();
  ::std::string* release_operation();
  void set_allocated_operation(::std::string* operation);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 7;
  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  public:
  const ::google::protobuf::Timestamp& start_time() const;
  ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* start_time);

  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 8;
  private:
  const ::google::protobuf::Duration& _internal_duration() const;
  public:
  const ::google::protobuf::Duration& duration() const;
  ::google::protobuf::Duration* release_duration();
  ::google::protobuf::Duration* mutable_duration();
  void set_allocated_duration(::google::protobuf::Duration* duration);

  // .google.protobuf.Any stats = 10;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 10;
  private:
  const ::google::protobuf::Any& _internal_stats() const;
  public:
  const ::google::protobuf::Any& stats() const;
  ::google::protobuf::Any* release_stats();
  ::google::protobuf::Any* mutable_stats();
  void set_allocated_stats(::google::protobuf::Any* stats);

  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  ::google::protobuf::uint64 span_id() const;
  void set_span_id(::google::protobuf::uint64 value);

  void clear_parent_span_id();
  static const int kParentSpanIdFieldNumber = 3;
  ::google::protobuf::uint64 parent_span_id() const;
  void set_parent_span_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cockroach.util.tracing.RecordedSpan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      RecordedSpan_BaggageEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > baggage_;
  ::google::protobuf::internal::MapFieldLite<
      RecordedSpan_TagsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > tags_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord > logs_;
  ::google::protobuf::internal::ArenaStringPtr operation_;
  ::google::protobuf::Timestamp* start_time_;
  ::google::protobuf::Duration* duration_;
  ::google::protobuf::Any* stats_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 span_id_;
  ::google::protobuf::uint64 parent_span_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_util_2ftracing_2frecorded_5fspan_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NormalizedSpan_TagsEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<NormalizedSpan_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntryLite<NormalizedSpan_TagsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NormalizedSpan_TagsEntry_DoNotUse();
  NormalizedSpan_TagsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const NormalizedSpan_TagsEntry_DoNotUse& other);
  static const NormalizedSpan_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NormalizedSpan_TagsEntry_DoNotUse*>(&_NormalizedSpan_TagsEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class NormalizedSpan : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.util.tracing.NormalizedSpan) */ {
 public:
  NormalizedSpan();
  virtual ~NormalizedSpan();

  NormalizedSpan(const NormalizedSpan& from);

  inline NormalizedSpan& operator=(const NormalizedSpan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NormalizedSpan(NormalizedSpan&& from) noexcept
    : NormalizedSpan() {
    *this = ::std::move(from);
  }

  inline NormalizedSpan& operator=(NormalizedSpan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NormalizedSpan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NormalizedSpan* internal_default_instance() {
    return reinterpret_cast<const NormalizedSpan*>(
               &_NormalizedSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NormalizedSpan* other);
  friend void swap(NormalizedSpan& a, NormalizedSpan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NormalizedSpan* New() const final {
    return CreateMaybeMessage<NormalizedSpan>(NULL);
  }

  NormalizedSpan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NormalizedSpan>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const NormalizedSpan& from);
  void MergeFrom(const NormalizedSpan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NormalizedSpan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> tags = 2;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      tags() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_tags();

  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 5;
  ::cockroach::util::tracing::LogRecord* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >*
      mutable_logs();
  const ::cockroach::util::tracing::LogRecord& logs(int index) const;
  ::cockroach::util::tracing::LogRecord* add_logs();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >&
      logs() const;

  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 6;
  ::cockroach::util::tracing::NormalizedSpan* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::NormalizedSpan >*
      mutable_children();
  const ::cockroach::util::tracing::NormalizedSpan& children(int index) const;
  ::cockroach::util::tracing::NormalizedSpan* add_children();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::NormalizedSpan >&
      children() const;

  // string operation = 1;
  void clear_operation();
  static const int kOperationFieldNumber = 1;
  const ::std::string& operation() const;
  void set_operation(const ::std::string& value);
  #if LANG_CXX11
  void set_operation(::std::string&& value);
  #endif
  void set_operation(const char* value);
  void set_operation(const char* value, size_t size);
  ::std::string* mutable_operation();
  ::std::string* release_operation();
  void set_allocated_operation(::std::string* operation);

  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  private:
  const ::google::protobuf::Timestamp& _internal_start_time() const;
  public:
  const ::google::protobuf::Timestamp& start_time() const;
  ::google::protobuf::Timestamp* release_start_time();
  ::google::protobuf::Timestamp* mutable_start_time();
  void set_allocated_start_time(::google::protobuf::Timestamp* start_time);

  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  private:
  const ::google::protobuf::Duration& _internal_duration() const;
  public:
  const ::google::protobuf::Duration& duration() const;
  ::google::protobuf::Duration* release_duration();
  ::google::protobuf::Duration* mutable_duration();
  void set_allocated_duration(::google::protobuf::Duration* duration);

  // @@protoc_insertion_point(class_scope:cockroach.util.tracing.NormalizedSpan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      NormalizedSpan_TagsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > tags_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord > logs_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::NormalizedSpan > children_;
  ::google::protobuf::internal::ArenaStringPtr operation_;
  ::google::protobuf::Timestamp* start_time_;
  ::google::protobuf::Duration* duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_util_2ftracing_2frecorded_5fspan_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogRecord_Field

// string key = 1;
inline void LogRecord_Field::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogRecord_Field::key() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.LogRecord.Field.key)
  return key_.GetNoArena();
}
inline void LogRecord_Field::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.LogRecord.Field.key)
}
#if LANG_CXX11
inline void LogRecord_Field::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.util.tracing.LogRecord.Field.key)
}
#endif
inline void LogRecord_Field::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.util.tracing.LogRecord.Field.key)
}
inline void LogRecord_Field::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.util.tracing.LogRecord.Field.key)
}
inline ::std::string* LogRecord_Field::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.LogRecord.Field.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRecord_Field::release_key() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.LogRecord.Field.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRecord_Field::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.LogRecord.Field.key)
}

// string value = 2;
inline void LogRecord_Field::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogRecord_Field::value() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.LogRecord.Field.value)
  return value_.GetNoArena();
}
inline void LogRecord_Field::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.LogRecord.Field.value)
}
#if LANG_CXX11
inline void LogRecord_Field::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.util.tracing.LogRecord.Field.value)
}
#endif
inline void LogRecord_Field::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.util.tracing.LogRecord.Field.value)
}
inline void LogRecord_Field::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.util.tracing.LogRecord.Field.value)
}
inline ::std::string* LogRecord_Field::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.LogRecord.Field.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRecord_Field::release_value() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.LogRecord.Field.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRecord_Field::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.LogRecord.Field.value)
}

// -------------------------------------------------------------------

// LogRecord

inline bool LogRecord::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline const ::google::protobuf::Timestamp& LogRecord::_internal_time() const {
  return *time_;
}
inline const ::google::protobuf::Timestamp& LogRecord::time() const {
  const ::google::protobuf::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.LogRecord.time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* LogRecord::release_time() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.LogRecord.time)
  
  ::google::protobuf::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* LogRecord::mutable_time() {
  
  if (time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.LogRecord.time)
  return time_;
}
inline void LogRecord::set_allocated_time(::google::protobuf::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_);
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(time)->GetArena();
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.LogRecord.time)
}

inline int LogRecord::fields_size() const {
  return fields_.size();
}
inline void LogRecord::clear_fields() {
  fields_.Clear();
}
inline ::cockroach::util::tracing::LogRecord_Field* LogRecord::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.LogRecord.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord_Field >*
LogRecord::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.util.tracing.LogRecord.fields)
  return &fields_;
}
inline const ::cockroach::util::tracing::LogRecord_Field& LogRecord::fields(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.LogRecord.fields)
  return fields_.Get(index);
}
inline ::cockroach::util::tracing::LogRecord_Field* LogRecord::add_fields() {
  // @@protoc_insertion_point(field_add:cockroach.util.tracing.LogRecord.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord_Field >&
LogRecord::fields() const {
  // @@protoc_insertion_point(field_list:cockroach.util.tracing.LogRecord.fields)
  return fields_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RecordedSpan

inline void RecordedSpan::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RecordedSpan::trace_id() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.trace_id)
  return trace_id_;
}
inline void RecordedSpan::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.RecordedSpan.trace_id)
}

inline void RecordedSpan::clear_span_id() {
  span_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RecordedSpan::span_id() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.span_id)
  return span_id_;
}
inline void RecordedSpan::set_span_id(::google::protobuf::uint64 value) {
  
  span_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.RecordedSpan.span_id)
}

inline void RecordedSpan::clear_parent_span_id() {
  parent_span_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RecordedSpan::parent_span_id() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.parent_span_id)
  return parent_span_id_;
}
inline void RecordedSpan::set_parent_span_id(::google::protobuf::uint64 value) {
  
  parent_span_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.RecordedSpan.parent_span_id)
}

// string operation = 4;
inline void RecordedSpan::clear_operation() {
  operation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordedSpan::operation() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.operation)
  return operation_.GetNoArena();
}
inline void RecordedSpan::set_operation(const ::std::string& value) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.RecordedSpan.operation)
}
#if LANG_CXX11
inline void RecordedSpan::set_operation(::std::string&& value) {
  
  operation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.util.tracing.RecordedSpan.operation)
}
#endif
inline void RecordedSpan::set_operation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.util.tracing.RecordedSpan.operation)
}
inline void RecordedSpan::set_operation(const char* value, size_t size) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.util.tracing.RecordedSpan.operation)
}
inline ::std::string* RecordedSpan::mutable_operation() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.RecordedSpan.operation)
  return operation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordedSpan::release_operation() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.RecordedSpan.operation)
  
  return operation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordedSpan::set_allocated_operation(::std::string* operation) {
  if (operation != NULL) {
    
  } else {
    
  }
  operation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation);
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.RecordedSpan.operation)
}

// map<string, string> baggage = 5;
inline int RecordedSpan::baggage_size() const {
  return baggage_.size();
}
inline void RecordedSpan::clear_baggage() {
  baggage_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
RecordedSpan::baggage() const {
  // @@protoc_insertion_point(field_map:cockroach.util.tracing.RecordedSpan.baggage)
  return baggage_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
RecordedSpan::mutable_baggage() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.util.tracing.RecordedSpan.baggage)
  return baggage_.MutableMap();
}

// map<string, string> tags = 6;
inline int RecordedSpan::tags_size() const {
  return tags_.size();
}
inline void RecordedSpan::clear_tags() {
  tags_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
RecordedSpan::tags() const {
  // @@protoc_insertion_point(field_map:cockroach.util.tracing.RecordedSpan.tags)
  return tags_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
RecordedSpan::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.util.tracing.RecordedSpan.tags)
  return tags_.MutableMap();
}

inline bool RecordedSpan::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& RecordedSpan::_internal_start_time() const {
  return *start_time_;
}
inline const ::google::protobuf::Timestamp& RecordedSpan::start_time() const {
  const ::google::protobuf::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* RecordedSpan::release_start_time() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.RecordedSpan.start_time)
  
  ::google::protobuf::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* RecordedSpan::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.RecordedSpan.start_time)
  return start_time_;
}
inline void RecordedSpan::set_allocated_start_time(::google::protobuf::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.RecordedSpan.start_time)
}

inline bool RecordedSpan::has_duration() const {
  return this != internal_default_instance() && duration_ != NULL;
}
inline const ::google::protobuf::Duration& RecordedSpan::_internal_duration() const {
  return *duration_;
}
inline const ::google::protobuf::Duration& RecordedSpan::duration() const {
  const ::google::protobuf::Duration* p = duration_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* RecordedSpan::release_duration() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.RecordedSpan.duration)
  
  ::google::protobuf::Duration* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* RecordedSpan::mutable_duration() {
  
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.RecordedSpan.duration)
  return duration_;
}
inline void RecordedSpan::set_allocated_duration(::google::protobuf::Duration* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(duration_);
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.RecordedSpan.duration)
}

inline int RecordedSpan::logs_size() const {
  return logs_.size();
}
inline void RecordedSpan::clear_logs() {
  logs_.Clear();
}
inline ::cockroach::util::tracing::LogRecord* RecordedSpan::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.RecordedSpan.logs)
  return logs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >*
RecordedSpan::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.util.tracing.RecordedSpan.logs)
  return &logs_;
}
inline const ::cockroach::util::tracing::LogRecord& RecordedSpan::logs(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.logs)
  return logs_.Get(index);
}
inline ::cockroach::util::tracing::LogRecord* RecordedSpan::add_logs() {
  // @@protoc_insertion_point(field_add:cockroach.util.tracing.RecordedSpan.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >&
RecordedSpan::logs() const {
  // @@protoc_insertion_point(field_list:cockroach.util.tracing.RecordedSpan.logs)
  return logs_;
}

// .google.protobuf.Any stats = 10;
inline bool RecordedSpan::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline const ::google::protobuf::Any& RecordedSpan::_internal_stats() const {
  return *stats_;
}
inline const ::google::protobuf::Any& RecordedSpan::stats() const {
  const ::google::protobuf::Any* p = stats_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.RecordedSpan.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* RecordedSpan::release_stats() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.RecordedSpan.stats)
  
  ::google::protobuf::Any* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* RecordedSpan::mutable_stats() {
  
  if (stats_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.RecordedSpan.stats)
  return stats_;
}
inline void RecordedSpan::set_allocated_stats(::google::protobuf::Any* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stats_);
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.RecordedSpan.stats)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NormalizedSpan

// string operation = 1;
inline void NormalizedSpan::clear_operation() {
  operation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NormalizedSpan::operation() const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.NormalizedSpan.operation)
  return operation_.GetNoArena();
}
inline void NormalizedSpan::set_operation(const ::std::string& value) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.util.tracing.NormalizedSpan.operation)
}
#if LANG_CXX11
inline void NormalizedSpan::set_operation(::std::string&& value) {
  
  operation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.util.tracing.NormalizedSpan.operation)
}
#endif
inline void NormalizedSpan::set_operation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.util.tracing.NormalizedSpan.operation)
}
inline void NormalizedSpan::set_operation(const char* value, size_t size) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.util.tracing.NormalizedSpan.operation)
}
inline ::std::string* NormalizedSpan::mutable_operation() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.NormalizedSpan.operation)
  return operation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NormalizedSpan::release_operation() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.NormalizedSpan.operation)
  
  return operation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NormalizedSpan::set_allocated_operation(::std::string* operation) {
  if (operation != NULL) {
    
  } else {
    
  }
  operation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation);
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.NormalizedSpan.operation)
}

// map<string, string> tags = 2;
inline int NormalizedSpan::tags_size() const {
  return tags_.size();
}
inline void NormalizedSpan::clear_tags() {
  tags_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
NormalizedSpan::tags() const {
  // @@protoc_insertion_point(field_map:cockroach.util.tracing.NormalizedSpan.tags)
  return tags_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
NormalizedSpan::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.util.tracing.NormalizedSpan.tags)
  return tags_.MutableMap();
}

inline bool NormalizedSpan::has_start_time() const {
  return this != internal_default_instance() && start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& NormalizedSpan::_internal_start_time() const {
  return *start_time_;
}
inline const ::google::protobuf::Timestamp& NormalizedSpan::start_time() const {
  const ::google::protobuf::Timestamp* p = start_time_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.NormalizedSpan.start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* NormalizedSpan::release_start_time() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.NormalizedSpan.start_time)
  
  ::google::protobuf::Timestamp* temp = start_time_;
  start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* NormalizedSpan::mutable_start_time() {
  
  if (start_time_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    start_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.NormalizedSpan.start_time)
  return start_time_;
}
inline void NormalizedSpan::set_allocated_start_time(::google::protobuf::Timestamp* start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.NormalizedSpan.start_time)
}

inline bool NormalizedSpan::has_duration() const {
  return this != internal_default_instance() && duration_ != NULL;
}
inline const ::google::protobuf::Duration& NormalizedSpan::_internal_duration() const {
  return *duration_;
}
inline const ::google::protobuf::Duration& NormalizedSpan::duration() const {
  const ::google::protobuf::Duration* p = duration_;
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.NormalizedSpan.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* NormalizedSpan::release_duration() {
  // @@protoc_insertion_point(field_release:cockroach.util.tracing.NormalizedSpan.duration)
  
  ::google::protobuf::Duration* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* NormalizedSpan::mutable_duration() {
  
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.NormalizedSpan.duration)
  return duration_;
}
inline void NormalizedSpan::set_allocated_duration(::google::protobuf::Duration* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(duration_);
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:cockroach.util.tracing.NormalizedSpan.duration)
}

inline int NormalizedSpan::logs_size() const {
  return logs_.size();
}
inline void NormalizedSpan::clear_logs() {
  logs_.Clear();
}
inline ::cockroach::util::tracing::LogRecord* NormalizedSpan::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.NormalizedSpan.logs)
  return logs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >*
NormalizedSpan::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.util.tracing.NormalizedSpan.logs)
  return &logs_;
}
inline const ::cockroach::util::tracing::LogRecord& NormalizedSpan::logs(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.NormalizedSpan.logs)
  return logs_.Get(index);
}
inline ::cockroach::util::tracing::LogRecord* NormalizedSpan::add_logs() {
  // @@protoc_insertion_point(field_add:cockroach.util.tracing.NormalizedSpan.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::LogRecord >&
NormalizedSpan::logs() const {
  // @@protoc_insertion_point(field_list:cockroach.util.tracing.NormalizedSpan.logs)
  return logs_;
}

inline int NormalizedSpan::children_size() const {
  return children_.size();
}
inline void NormalizedSpan::clear_children() {
  children_.Clear();
}
inline ::cockroach::util::tracing::NormalizedSpan* NormalizedSpan::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.util.tracing.NormalizedSpan.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::NormalizedSpan >*
NormalizedSpan::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.util.tracing.NormalizedSpan.children)
  return &children_;
}
inline const ::cockroach::util::tracing::NormalizedSpan& NormalizedSpan::children(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.util.tracing.NormalizedSpan.children)
  return children_.Get(index);
}
inline ::cockroach::util::tracing::NormalizedSpan* NormalizedSpan::add_children() {
  // @@protoc_insertion_point(field_add:cockroach.util.tracing.NormalizedSpan.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::util::tracing::NormalizedSpan >&
NormalizedSpan::children() const {
  // @@protoc_insertion_point(field_list:cockroach.util.tracing.NormalizedSpan.children)
  return children_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tracing
}  // namespace util
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_util_2ftracing_2frecorded_5fspan_2eproto
