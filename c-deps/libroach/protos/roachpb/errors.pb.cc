// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: roachpb/errors.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "roachpb/errors.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace roachpb {
class NotLeaseHolderErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<NotLeaseHolderError>
     _instance;
} _NotLeaseHolderError_default_instance_;
class NodeUnavailableErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<NodeUnavailableError>
     _instance;
} _NodeUnavailableError_default_instance_;
class RangeNotFoundErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RangeNotFoundError>
     _instance;
} _RangeNotFoundError_default_instance_;
class RangeKeyMismatchErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RangeKeyMismatchError>
     _instance;
} _RangeKeyMismatchError_default_instance_;
class ReadWithinUncertaintyIntervalErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ReadWithinUncertaintyIntervalError>
     _instance;
} _ReadWithinUncertaintyIntervalError_default_instance_;
class TransactionAbortedErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TransactionAbortedError>
     _instance;
} _TransactionAbortedError_default_instance_;
class TransactionPushErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TransactionPushError>
     _instance;
} _TransactionPushError_default_instance_;
class TransactionRetryErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TransactionRetryError>
     _instance;
} _TransactionRetryError_default_instance_;
class TransactionReplayErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TransactionReplayError>
     _instance;
} _TransactionReplayError_default_instance_;
class TransactionStatusErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TransactionStatusError>
     _instance;
} _TransactionStatusError_default_instance_;
class WriteIntentErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<WriteIntentError>
     _instance;
} _WriteIntentError_default_instance_;
class WriteTooOldErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<WriteTooOldError>
     _instance;
} _WriteTooOldError_default_instance_;
class OpRequiresTxnErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<OpRequiresTxnError>
     _instance;
} _OpRequiresTxnError_default_instance_;
class ConditionFailedErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ConditionFailedError>
     _instance;
} _ConditionFailedError_default_instance_;
class LeaseRejectedErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<LeaseRejectedError>
     _instance;
} _LeaseRejectedError_default_instance_;
class SendErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<SendError>
     _instance;
} _SendError_default_instance_;
class AmbiguousResultErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<AmbiguousResultError>
     _instance;
} _AmbiguousResultError_default_instance_;
class RaftGroupDeletedErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<RaftGroupDeletedError>
     _instance;
} _RaftGroupDeletedError_default_instance_;
class ReplicaCorruptionErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ReplicaCorruptionError>
     _instance;
} _ReplicaCorruptionError_default_instance_;
class ReplicaTooOldErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ReplicaTooOldError>
     _instance;
} _ReplicaTooOldError_default_instance_;
class StoreNotFoundErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<StoreNotFoundError>
     _instance;
} _StoreNotFoundError_default_instance_;
class UnhandledRetryableErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<UnhandledRetryableError>
     _instance;
} _UnhandledRetryableError_default_instance_;
class HandledRetryableTxnErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<HandledRetryableTxnError>
     _instance;
} _HandledRetryableTxnError_default_instance_;
class UntrackedTxnErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<UntrackedTxnError>
     _instance;
} _UntrackedTxnError_default_instance_;
class TxnPrevAttemptErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<TxnPrevAttemptError>
     _instance;
} _TxnPrevAttemptError_default_instance_;
class ErrorDetailDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ErrorDetail>
     _instance;
} _ErrorDetail_default_instance_;
class ErrPositionDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ErrPosition>
     _instance;
} _ErrPosition_default_instance_;
class ErrorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Error>
     _instance;
} _Error_default_instance_;

namespace protobuf_roachpb_2ferrors_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
};

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::cockroach::roachpb::protobuf_roachpb_2fmetadata_2eproto::InitDefaults();
  ::cockroach::roachpb::protobuf_roachpb_2fdata_2eproto::InitDefaults();
  ::cockroach::util::hlc::protobuf_util_2fhlc_2ftimestamp_2eproto::InitDefaults();
  _NotLeaseHolderError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_NotLeaseHolderError_default_instance_);_NodeUnavailableError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_NodeUnavailableError_default_instance_);_RangeNotFoundError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RangeNotFoundError_default_instance_);_RangeKeyMismatchError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RangeKeyMismatchError_default_instance_);_ReadWithinUncertaintyIntervalError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ReadWithinUncertaintyIntervalError_default_instance_);_TransactionAbortedError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TransactionAbortedError_default_instance_);_TransactionPushError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TransactionPushError_default_instance_);_TransactionRetryError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TransactionRetryError_default_instance_);_TransactionReplayError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TransactionReplayError_default_instance_);_TransactionStatusError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TransactionStatusError_default_instance_);_WriteIntentError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_WriteIntentError_default_instance_);_WriteTooOldError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_WriteTooOldError_default_instance_);_OpRequiresTxnError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_OpRequiresTxnError_default_instance_);_ConditionFailedError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ConditionFailedError_default_instance_);_LeaseRejectedError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_LeaseRejectedError_default_instance_);_SendError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_SendError_default_instance_);_AmbiguousResultError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_AmbiguousResultError_default_instance_);_RaftGroupDeletedError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_RaftGroupDeletedError_default_instance_);_ReplicaCorruptionError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ReplicaCorruptionError_default_instance_);_ReplicaTooOldError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ReplicaTooOldError_default_instance_);_StoreNotFoundError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_StoreNotFoundError_default_instance_);_UnhandledRetryableError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_UnhandledRetryableError_default_instance_);_HandledRetryableTxnError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_HandledRetryableTxnError_default_instance_);_UntrackedTxnError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_UntrackedTxnError_default_instance_);_TxnPrevAttemptError_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_TxnPrevAttemptError_default_instance_);_ErrorDetail_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ErrorDetail_default_instance_);_ErrPosition_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ErrPosition_default_instance_);_Error_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Error_default_instance_);_NotLeaseHolderError_default_instance_._instance.get_mutable()->replica_ = const_cast< ::cockroach::roachpb::ReplicaDescriptor*>(
      ::cockroach::roachpb::ReplicaDescriptor::internal_default_instance());
  _NotLeaseHolderError_default_instance_._instance.get_mutable()->lease_holder_ = const_cast< ::cockroach::roachpb::ReplicaDescriptor*>(
      ::cockroach::roachpb::ReplicaDescriptor::internal_default_instance());
  _NotLeaseHolderError_default_instance_._instance.get_mutable()->lease_ = const_cast< ::cockroach::roachpb::Lease*>(
      ::cockroach::roachpb::Lease::internal_default_instance());
  _RangeKeyMismatchError_default_instance_._instance.get_mutable()->mismatched_range_ = const_cast< ::cockroach::roachpb::RangeDescriptor*>(
      ::cockroach::roachpb::RangeDescriptor::internal_default_instance());
  _RangeKeyMismatchError_default_instance_._instance.get_mutable()->suggested_range_ = const_cast< ::cockroach::roachpb::RangeDescriptor*>(
      ::cockroach::roachpb::RangeDescriptor::internal_default_instance());
  _ReadWithinUncertaintyIntervalError_default_instance_._instance.get_mutable()->read_timestamp_ = const_cast< ::cockroach::util::hlc::Timestamp*>(
      ::cockroach::util::hlc::Timestamp::internal_default_instance());
  _ReadWithinUncertaintyIntervalError_default_instance_._instance.get_mutable()->existing_timestamp_ = const_cast< ::cockroach::util::hlc::Timestamp*>(
      ::cockroach::util::hlc::Timestamp::internal_default_instance());
  _TransactionPushError_default_instance_._instance.get_mutable()->pushee_txn_ = const_cast< ::cockroach::roachpb::Transaction*>(
      ::cockroach::roachpb::Transaction::internal_default_instance());
  _WriteTooOldError_default_instance_._instance.get_mutable()->timestamp_ = const_cast< ::cockroach::util::hlc::Timestamp*>(
      ::cockroach::util::hlc::Timestamp::internal_default_instance());
  _WriteTooOldError_default_instance_._instance.get_mutable()->actual_timestamp_ = const_cast< ::cockroach::util::hlc::Timestamp*>(
      ::cockroach::util::hlc::Timestamp::internal_default_instance());
  _ConditionFailedError_default_instance_._instance.get_mutable()->actual_value_ = const_cast< ::cockroach::roachpb::Value*>(
      ::cockroach::roachpb::Value::internal_default_instance());
  _LeaseRejectedError_default_instance_._instance.get_mutable()->requested_ = const_cast< ::cockroach::roachpb::Lease*>(
      ::cockroach::roachpb::Lease::internal_default_instance());
  _LeaseRejectedError_default_instance_._instance.get_mutable()->existing_ = const_cast< ::cockroach::roachpb::Lease*>(
      ::cockroach::roachpb::Lease::internal_default_instance());
  _AmbiguousResultError_default_instance_._instance.get_mutable()->wrapped_err_ = const_cast< ::cockroach::roachpb::Error*>(
      ::cockroach::roachpb::Error::internal_default_instance());
  _UnhandledRetryableError_default_instance_._instance.get_mutable()->perr_ = const_cast< ::cockroach::roachpb::Error*>(
      ::cockroach::roachpb::Error::internal_default_instance());
  _HandledRetryableTxnError_default_instance_._instance.get_mutable()->transaction_ = const_cast< ::cockroach::roachpb::Transaction*>(
      ::cockroach::roachpb::Transaction::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->not_lease_holder_ = const_cast< ::cockroach::roachpb::NotLeaseHolderError*>(
      ::cockroach::roachpb::NotLeaseHolderError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->range_not_found_ = const_cast< ::cockroach::roachpb::RangeNotFoundError*>(
      ::cockroach::roachpb::RangeNotFoundError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->range_key_mismatch_ = const_cast< ::cockroach::roachpb::RangeKeyMismatchError*>(
      ::cockroach::roachpb::RangeKeyMismatchError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->read_within_uncertainty_interval_ = const_cast< ::cockroach::roachpb::ReadWithinUncertaintyIntervalError*>(
      ::cockroach::roachpb::ReadWithinUncertaintyIntervalError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->transaction_aborted_ = const_cast< ::cockroach::roachpb::TransactionAbortedError*>(
      ::cockroach::roachpb::TransactionAbortedError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->transaction_push_ = const_cast< ::cockroach::roachpb::TransactionPushError*>(
      ::cockroach::roachpb::TransactionPushError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->transaction_retry_ = const_cast< ::cockroach::roachpb::TransactionRetryError*>(
      ::cockroach::roachpb::TransactionRetryError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->transaction_replay_ = const_cast< ::cockroach::roachpb::TransactionReplayError*>(
      ::cockroach::roachpb::TransactionReplayError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->transaction_status_ = const_cast< ::cockroach::roachpb::TransactionStatusError*>(
      ::cockroach::roachpb::TransactionStatusError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->write_intent_ = const_cast< ::cockroach::roachpb::WriteIntentError*>(
      ::cockroach::roachpb::WriteIntentError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->write_too_old_ = const_cast< ::cockroach::roachpb::WriteTooOldError*>(
      ::cockroach::roachpb::WriteTooOldError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->op_requires_txn_ = const_cast< ::cockroach::roachpb::OpRequiresTxnError*>(
      ::cockroach::roachpb::OpRequiresTxnError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->condition_failed_ = const_cast< ::cockroach::roachpb::ConditionFailedError*>(
      ::cockroach::roachpb::ConditionFailedError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->lease_rejected_ = const_cast< ::cockroach::roachpb::LeaseRejectedError*>(
      ::cockroach::roachpb::LeaseRejectedError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->node_unavailable_ = const_cast< ::cockroach::roachpb::NodeUnavailableError*>(
      ::cockroach::roachpb::NodeUnavailableError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->send_ = const_cast< ::cockroach::roachpb::SendError*>(
      ::cockroach::roachpb::SendError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->raft_group_deleted_ = const_cast< ::cockroach::roachpb::RaftGroupDeletedError*>(
      ::cockroach::roachpb::RaftGroupDeletedError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->replica_corruption_ = const_cast< ::cockroach::roachpb::ReplicaCorruptionError*>(
      ::cockroach::roachpb::ReplicaCorruptionError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->replica_too_old_ = const_cast< ::cockroach::roachpb::ReplicaTooOldError*>(
      ::cockroach::roachpb::ReplicaTooOldError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->ambiguous_result_ = const_cast< ::cockroach::roachpb::AmbiguousResultError*>(
      ::cockroach::roachpb::AmbiguousResultError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->store_not_found_ = const_cast< ::cockroach::roachpb::StoreNotFoundError*>(
      ::cockroach::roachpb::StoreNotFoundError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->handled_retryable_txn_error_ = const_cast< ::cockroach::roachpb::HandledRetryableTxnError*>(
      ::cockroach::roachpb::HandledRetryableTxnError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->untracked_txn_error_ = const_cast< ::cockroach::roachpb::UntrackedTxnError*>(
      ::cockroach::roachpb::UntrackedTxnError::internal_default_instance());
  _ErrorDetail_default_instance_._instance.get_mutable()->txn_aborted_async_err_ = const_cast< ::cockroach::roachpb::TxnPrevAttemptError*>(
      ::cockroach::roachpb::TxnPrevAttemptError::internal_default_instance());
  _Error_default_instance_._instance.get_mutable()->unexposed_txn_ = const_cast< ::cockroach::roachpb::Transaction*>(
      ::cockroach::roachpb::Transaction::internal_default_instance());
  _Error_default_instance_._instance.get_mutable()->detail_ = const_cast< ::cockroach::roachpb::ErrorDetail*>(
      ::cockroach::roachpb::ErrorDetail::internal_default_instance());
  _Error_default_instance_._instance.get_mutable()->index_ = const_cast< ::cockroach::roachpb::ErrPosition*>(
      ::cockroach::roachpb::ErrPosition::internal_default_instance());
  _Error_default_instance_._instance.get_mutable()->now_ = const_cast< ::cockroach::util::hlc::Timestamp*>(
      ::cockroach::util::hlc::Timestamp::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
namespace {
void AddDescriptorsImpl() {
  InitDefaults();
  ::cockroach::roachpb::protobuf_roachpb_2fmetadata_2eproto::AddDescriptors();
  ::cockroach::roachpb::protobuf_roachpb_2fdata_2eproto::AddDescriptors();
  ::cockroach::util::hlc::protobuf_util_2fhlc_2ftimestamp_2eproto::AddDescriptors();
}
} // anonymous namespace

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}

}  // namespace protobuf_roachpb_2ferrors_2eproto

bool TransactionRetryReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool TransactionRestart_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotLeaseHolderError::kReplicaFieldNumber;
const int NotLeaseHolderError::kLeaseHolderFieldNumber;
const int NotLeaseHolderError::kLeaseFieldNumber;
const int NotLeaseHolderError::kRangeIdFieldNumber;
const int NotLeaseHolderError::kCustomMsgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotLeaseHolderError::NotLeaseHolderError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.NotLeaseHolderError)
}
NotLeaseHolderError::NotLeaseHolderError(const NotLeaseHolderError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  custom_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_custom_msg()) {
    custom_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.custom_msg_);
  }
  if (from.has_replica()) {
    replica_ = new ::cockroach::roachpb::ReplicaDescriptor(*from.replica_);
  } else {
    replica_ = NULL;
  }
  if (from.has_lease_holder()) {
    lease_holder_ = new ::cockroach::roachpb::ReplicaDescriptor(*from.lease_holder_);
  } else {
    lease_holder_ = NULL;
  }
  if (from.has_lease()) {
    lease_ = new ::cockroach::roachpb::Lease(*from.lease_);
  } else {
    lease_ = NULL;
  }
  range_id_ = from.range_id_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.NotLeaseHolderError)
}

void NotLeaseHolderError::SharedCtor() {
  _cached_size_ = 0;
  custom_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&replica_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&range_id_) -
      reinterpret_cast<char*>(&replica_)) + sizeof(range_id_));
}

NotLeaseHolderError::~NotLeaseHolderError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.NotLeaseHolderError)
  SharedDtor();
}

void NotLeaseHolderError::SharedDtor() {
  custom_msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete replica_;
  if (this != internal_default_instance()) delete lease_holder_;
  if (this != internal_default_instance()) delete lease_;
}

void NotLeaseHolderError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotLeaseHolderError& NotLeaseHolderError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

NotLeaseHolderError* NotLeaseHolderError::New(::google::protobuf::Arena* arena) const {
  NotLeaseHolderError* n = new NotLeaseHolderError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotLeaseHolderError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.NotLeaseHolderError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!custom_msg_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*custom_msg_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(replica_ != NULL);
      replica_->::cockroach::roachpb::ReplicaDescriptor::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(lease_holder_ != NULL);
      lease_holder_->::cockroach::roachpb::ReplicaDescriptor::Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(lease_ != NULL);
      lease_->::cockroach::roachpb::Lease::Clear();
    }
  }
  range_id_ = GOOGLE_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NotLeaseHolderError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.NotLeaseHolderError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ReplicaDescriptor lease_holder = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease_holder()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_range_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.Lease lease = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_custom_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.NotLeaseHolderError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.NotLeaseHolderError)
  return false;
#undef DO_
}

void NotLeaseHolderError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.NotLeaseHolderError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->replica_, output);
  }

  // optional .cockroach.roachpb.ReplicaDescriptor lease_holder = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->lease_holder_, output);
  }

  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->range_id(), output);
  }

  // optional .cockroach.roachpb.Lease lease = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->lease_, output);
  }

  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->custom_msg(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.NotLeaseHolderError)
}

size_t NotLeaseHolderError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.NotLeaseHolderError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    if (has_custom_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->custom_msg());
    }

    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional .cockroach.roachpb.ReplicaDescriptor lease_holder = 2;
    if (has_lease_holder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_holder_);
    }

    // optional .cockroach.roachpb.Lease lease = 4;
    if (has_lease()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_);
    }

    if (has_range_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->range_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotLeaseHolderError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotLeaseHolderError*>(&from));
}

void NotLeaseHolderError::MergeFrom(const NotLeaseHolderError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.NotLeaseHolderError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_custom_msg();
      custom_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.custom_msg_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_replica()->::cockroach::roachpb::ReplicaDescriptor::MergeFrom(from.replica());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_lease_holder()->::cockroach::roachpb::ReplicaDescriptor::MergeFrom(from.lease_holder());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_lease()->::cockroach::roachpb::Lease::MergeFrom(from.lease());
    }
    if (cached_has_bits & 0x00000010u) {
      range_id_ = from.range_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NotLeaseHolderError::CopyFrom(const NotLeaseHolderError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.NotLeaseHolderError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotLeaseHolderError::IsInitialized() const {
  return true;
}

void NotLeaseHolderError::Swap(NotLeaseHolderError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotLeaseHolderError::InternalSwap(NotLeaseHolderError* other) {
  using std::swap;
  custom_msg_.Swap(&other->custom_msg_);
  swap(replica_, other->replica_);
  swap(lease_holder_, other->lease_holder_);
  swap(lease_, other->lease_);
  swap(range_id_, other->range_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string NotLeaseHolderError::GetTypeName() const {
  return "cockroach.roachpb.NotLeaseHolderError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotLeaseHolderError

bool NotLeaseHolderError::has_replica() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NotLeaseHolderError::set_has_replica() {
  _has_bits_[0] |= 0x00000002u;
}
void NotLeaseHolderError::clear_has_replica() {
  _has_bits_[0] &= ~0x00000002u;
}
void NotLeaseHolderError::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::roachpb::ReplicaDescriptor::Clear();
  clear_has_replica();
}
const ::cockroach::roachpb::ReplicaDescriptor& NotLeaseHolderError::replica() const {
  const ::cockroach::roachpb::ReplicaDescriptor* p = replica_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NotLeaseHolderError.replica)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ReplicaDescriptor*>(
      &::cockroach::roachpb::_ReplicaDescriptor_default_instance_);
}
::cockroach::roachpb::ReplicaDescriptor* NotLeaseHolderError::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::roachpb::ReplicaDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NotLeaseHolderError.replica)
  return replica_;
}
::cockroach::roachpb::ReplicaDescriptor* NotLeaseHolderError::release_replica() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.NotLeaseHolderError.replica)
  clear_has_replica();
  ::cockroach::roachpb::ReplicaDescriptor* temp = replica_;
  replica_ = NULL;
  return temp;
}
void NotLeaseHolderError::set_allocated_replica(::cockroach::roachpb::ReplicaDescriptor* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NotLeaseHolderError.replica)
}

// optional .cockroach.roachpb.ReplicaDescriptor lease_holder = 2;
bool NotLeaseHolderError::has_lease_holder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NotLeaseHolderError::set_has_lease_holder() {
  _has_bits_[0] |= 0x00000004u;
}
void NotLeaseHolderError::clear_has_lease_holder() {
  _has_bits_[0] &= ~0x00000004u;
}
void NotLeaseHolderError::clear_lease_holder() {
  if (lease_holder_ != NULL) lease_holder_->::cockroach::roachpb::ReplicaDescriptor::Clear();
  clear_has_lease_holder();
}
const ::cockroach::roachpb::ReplicaDescriptor& NotLeaseHolderError::lease_holder() const {
  const ::cockroach::roachpb::ReplicaDescriptor* p = lease_holder_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NotLeaseHolderError.lease_holder)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ReplicaDescriptor*>(
      &::cockroach::roachpb::_ReplicaDescriptor_default_instance_);
}
::cockroach::roachpb::ReplicaDescriptor* NotLeaseHolderError::mutable_lease_holder() {
  set_has_lease_holder();
  if (lease_holder_ == NULL) {
    lease_holder_ = new ::cockroach::roachpb::ReplicaDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NotLeaseHolderError.lease_holder)
  return lease_holder_;
}
::cockroach::roachpb::ReplicaDescriptor* NotLeaseHolderError::release_lease_holder() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.NotLeaseHolderError.lease_holder)
  clear_has_lease_holder();
  ::cockroach::roachpb::ReplicaDescriptor* temp = lease_holder_;
  lease_holder_ = NULL;
  return temp;
}
void NotLeaseHolderError::set_allocated_lease_holder(::cockroach::roachpb::ReplicaDescriptor* lease_holder) {
  delete lease_holder_;
  lease_holder_ = lease_holder;
  if (lease_holder) {
    set_has_lease_holder();
  } else {
    clear_has_lease_holder();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NotLeaseHolderError.lease_holder)
}

// optional .cockroach.roachpb.Lease lease = 4;
bool NotLeaseHolderError::has_lease() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void NotLeaseHolderError::set_has_lease() {
  _has_bits_[0] |= 0x00000008u;
}
void NotLeaseHolderError::clear_has_lease() {
  _has_bits_[0] &= ~0x00000008u;
}
void NotLeaseHolderError::clear_lease() {
  if (lease_ != NULL) lease_->::cockroach::roachpb::Lease::Clear();
  clear_has_lease();
}
const ::cockroach::roachpb::Lease& NotLeaseHolderError::lease() const {
  const ::cockroach::roachpb::Lease* p = lease_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NotLeaseHolderError.lease)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Lease*>(
      &::cockroach::roachpb::_Lease_default_instance_);
}
::cockroach::roachpb::Lease* NotLeaseHolderError::mutable_lease() {
  set_has_lease();
  if (lease_ == NULL) {
    lease_ = new ::cockroach::roachpb::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NotLeaseHolderError.lease)
  return lease_;
}
::cockroach::roachpb::Lease* NotLeaseHolderError::release_lease() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.NotLeaseHolderError.lease)
  clear_has_lease();
  ::cockroach::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
void NotLeaseHolderError::set_allocated_lease(::cockroach::roachpb::Lease* lease) {
  delete lease_;
  lease_ = lease;
  if (lease) {
    set_has_lease();
  } else {
    clear_has_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NotLeaseHolderError.lease)
}

bool NotLeaseHolderError::has_range_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void NotLeaseHolderError::set_has_range_id() {
  _has_bits_[0] |= 0x00000010u;
}
void NotLeaseHolderError::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void NotLeaseHolderError::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
::google::protobuf::int64 NotLeaseHolderError::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NotLeaseHolderError.range_id)
  return range_id_;
}
void NotLeaseHolderError::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.NotLeaseHolderError.range_id)
}

bool NotLeaseHolderError::has_custom_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotLeaseHolderError::set_has_custom_msg() {
  _has_bits_[0] |= 0x00000001u;
}
void NotLeaseHolderError::clear_has_custom_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotLeaseHolderError::clear_custom_msg() {
  custom_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_custom_msg();
}
const ::std::string& NotLeaseHolderError::custom_msg() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NotLeaseHolderError.custom_msg)
  return custom_msg_.GetNoArena();
}
void NotLeaseHolderError::set_custom_msg(const ::std::string& value) {
  set_has_custom_msg();
  custom_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.NotLeaseHolderError.custom_msg)
}
#if LANG_CXX11
void NotLeaseHolderError::set_custom_msg(::std::string&& value) {
  set_has_custom_msg();
  custom_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.NotLeaseHolderError.custom_msg)
}
#endif
void NotLeaseHolderError::set_custom_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_custom_msg();
  custom_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.NotLeaseHolderError.custom_msg)
}
void NotLeaseHolderError::set_custom_msg(const char* value, size_t size) {
  set_has_custom_msg();
  custom_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.NotLeaseHolderError.custom_msg)
}
::std::string* NotLeaseHolderError::mutable_custom_msg() {
  set_has_custom_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NotLeaseHolderError.custom_msg)
  return custom_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NotLeaseHolderError::release_custom_msg() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.NotLeaseHolderError.custom_msg)
  clear_has_custom_msg();
  return custom_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NotLeaseHolderError::set_allocated_custom_msg(::std::string* custom_msg) {
  if (custom_msg != NULL) {
    set_has_custom_msg();
  } else {
    clear_has_custom_msg();
  }
  custom_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NotLeaseHolderError.custom_msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NodeUnavailableError::NodeUnavailableError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.NodeUnavailableError)
}
NodeUnavailableError::NodeUnavailableError(const NodeUnavailableError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.NodeUnavailableError)
}

void NodeUnavailableError::SharedCtor() {
  _cached_size_ = 0;
}

NodeUnavailableError::~NodeUnavailableError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.NodeUnavailableError)
  SharedDtor();
}

void NodeUnavailableError::SharedDtor() {
}

void NodeUnavailableError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NodeUnavailableError& NodeUnavailableError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

NodeUnavailableError* NodeUnavailableError::New(::google::protobuf::Arena* arena) const {
  NodeUnavailableError* n = new NodeUnavailableError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NodeUnavailableError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.NodeUnavailableError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NodeUnavailableError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.NodeUnavailableError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.NodeUnavailableError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.NodeUnavailableError)
  return false;
#undef DO_
}

void NodeUnavailableError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.NodeUnavailableError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.NodeUnavailableError)
}

size_t NodeUnavailableError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.NodeUnavailableError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NodeUnavailableError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NodeUnavailableError*>(&from));
}

void NodeUnavailableError::MergeFrom(const NodeUnavailableError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.NodeUnavailableError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void NodeUnavailableError::CopyFrom(const NodeUnavailableError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.NodeUnavailableError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeUnavailableError::IsInitialized() const {
  return true;
}

void NodeUnavailableError::Swap(NodeUnavailableError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NodeUnavailableError::InternalSwap(NodeUnavailableError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string NodeUnavailableError::GetTypeName() const {
  return "cockroach.roachpb.NodeUnavailableError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NodeUnavailableError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeNotFoundError::kRangeIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeNotFoundError::RangeNotFoundError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RangeNotFoundError)
}
RangeNotFoundError::RangeNotFoundError(const RangeNotFoundError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  range_id_ = from.range_id_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RangeNotFoundError)
}

void RangeNotFoundError::SharedCtor() {
  _cached_size_ = 0;
  range_id_ = GOOGLE_LONGLONG(0);
}

RangeNotFoundError::~RangeNotFoundError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RangeNotFoundError)
  SharedDtor();
}

void RangeNotFoundError::SharedDtor() {
}

void RangeNotFoundError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RangeNotFoundError& RangeNotFoundError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

RangeNotFoundError* RangeNotFoundError::New(::google::protobuf::Arena* arena) const {
  RangeNotFoundError* n = new RangeNotFoundError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeNotFoundError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.RangeNotFoundError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  range_id_ = GOOGLE_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RangeNotFoundError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RangeNotFoundError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_range_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RangeNotFoundError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RangeNotFoundError)
  return false;
#undef DO_
}

void RangeNotFoundError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RangeNotFoundError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->range_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RangeNotFoundError)
}

size_t RangeNotFoundError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.RangeNotFoundError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_range_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->range_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeNotFoundError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RangeNotFoundError*>(&from));
}

void RangeNotFoundError::MergeFrom(const RangeNotFoundError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.RangeNotFoundError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_range_id()) {
    set_range_id(from.range_id());
  }
}

void RangeNotFoundError::CopyFrom(const RangeNotFoundError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.RangeNotFoundError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeNotFoundError::IsInitialized() const {
  return true;
}

void RangeNotFoundError::Swap(RangeNotFoundError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeNotFoundError::InternalSwap(RangeNotFoundError* other) {
  using std::swap;
  swap(range_id_, other->range_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RangeNotFoundError::GetTypeName() const {
  return "cockroach.roachpb.RangeNotFoundError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeNotFoundError

bool RangeNotFoundError::has_range_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeNotFoundError::set_has_range_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeNotFoundError::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeNotFoundError::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
::google::protobuf::int64 RangeNotFoundError::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeNotFoundError.range_id)
  return range_id_;
}
void RangeNotFoundError::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeNotFoundError.range_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeKeyMismatchError::kRequestStartKeyFieldNumber;
const int RangeKeyMismatchError::kRequestEndKeyFieldNumber;
const int RangeKeyMismatchError::kMismatchedRangeFieldNumber;
const int RangeKeyMismatchError::kSuggestedRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeKeyMismatchError::RangeKeyMismatchError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RangeKeyMismatchError)
}
RangeKeyMismatchError::RangeKeyMismatchError(const RangeKeyMismatchError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  request_start_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_request_start_key()) {
    request_start_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_start_key_);
  }
  request_end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_request_end_key()) {
    request_end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_end_key_);
  }
  if (from.has_mismatched_range()) {
    mismatched_range_ = new ::cockroach::roachpb::RangeDescriptor(*from.mismatched_range_);
  } else {
    mismatched_range_ = NULL;
  }
  if (from.has_suggested_range()) {
    suggested_range_ = new ::cockroach::roachpb::RangeDescriptor(*from.suggested_range_);
  } else {
    suggested_range_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RangeKeyMismatchError)
}

void RangeKeyMismatchError::SharedCtor() {
  _cached_size_ = 0;
  request_start_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&mismatched_range_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&suggested_range_) -
      reinterpret_cast<char*>(&mismatched_range_)) + sizeof(suggested_range_));
}

RangeKeyMismatchError::~RangeKeyMismatchError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RangeKeyMismatchError)
  SharedDtor();
}

void RangeKeyMismatchError::SharedDtor() {
  request_start_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete mismatched_range_;
  if (this != internal_default_instance()) delete suggested_range_;
}

void RangeKeyMismatchError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RangeKeyMismatchError& RangeKeyMismatchError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

RangeKeyMismatchError* RangeKeyMismatchError::New(::google::protobuf::Arena* arena) const {
  RangeKeyMismatchError* n = new RangeKeyMismatchError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeKeyMismatchError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.RangeKeyMismatchError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!request_start_key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*request_start_key_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!request_end_key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*request_end_key_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(mismatched_range_ != NULL);
      mismatched_range_->::cockroach::roachpb::RangeDescriptor::Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(suggested_range_ != NULL);
      suggested_range_->::cockroach::roachpb::RangeDescriptor::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RangeKeyMismatchError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RangeKeyMismatchError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_start_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_end_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.RangeDescriptor mismatched_range = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mismatched_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.RangeDescriptor suggested_range = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_suggested_range()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RangeKeyMismatchError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RangeKeyMismatchError)
  return false;
#undef DO_
}

void RangeKeyMismatchError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RangeKeyMismatchError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->request_start_key(), output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->request_end_key(), output);
  }

  // optional .cockroach.roachpb.RangeDescriptor mismatched_range = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->mismatched_range_, output);
  }

  // optional .cockroach.roachpb.RangeDescriptor suggested_range = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->suggested_range_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RangeKeyMismatchError)
}

size_t RangeKeyMismatchError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.RangeKeyMismatchError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 15u) {
    if (has_request_start_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_start_key());
    }

    if (has_request_end_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_end_key());
    }

    // optional .cockroach.roachpb.RangeDescriptor mismatched_range = 3;
    if (has_mismatched_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mismatched_range_);
    }

    // optional .cockroach.roachpb.RangeDescriptor suggested_range = 4;
    if (has_suggested_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->suggested_range_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeKeyMismatchError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RangeKeyMismatchError*>(&from));
}

void RangeKeyMismatchError::MergeFrom(const RangeKeyMismatchError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.RangeKeyMismatchError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_request_start_key();
      request_start_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_start_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_request_end_key();
      request_end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_end_key_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_mismatched_range()->::cockroach::roachpb::RangeDescriptor::MergeFrom(from.mismatched_range());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_suggested_range()->::cockroach::roachpb::RangeDescriptor::MergeFrom(from.suggested_range());
    }
  }
}

void RangeKeyMismatchError::CopyFrom(const RangeKeyMismatchError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.RangeKeyMismatchError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeKeyMismatchError::IsInitialized() const {
  return true;
}

void RangeKeyMismatchError::Swap(RangeKeyMismatchError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeKeyMismatchError::InternalSwap(RangeKeyMismatchError* other) {
  using std::swap;
  request_start_key_.Swap(&other->request_start_key_);
  request_end_key_.Swap(&other->request_end_key_);
  swap(mismatched_range_, other->mismatched_range_);
  swap(suggested_range_, other->suggested_range_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RangeKeyMismatchError::GetTypeName() const {
  return "cockroach.roachpb.RangeKeyMismatchError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeKeyMismatchError

bool RangeKeyMismatchError::has_request_start_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeKeyMismatchError::set_has_request_start_key() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeKeyMismatchError::clear_has_request_start_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeKeyMismatchError::clear_request_start_key() {
  request_start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_start_key();
}
const ::std::string& RangeKeyMismatchError::request_start_key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
  return request_start_key_.GetNoArena();
}
void RangeKeyMismatchError::set_request_start_key(const ::std::string& value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
}
#if LANG_CXX11
void RangeKeyMismatchError::set_request_start_key(::std::string&& value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
}
#endif
void RangeKeyMismatchError::set_request_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
}
void RangeKeyMismatchError::set_request_start_key(const void* value, size_t size) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
}
::std::string* RangeKeyMismatchError::mutable_request_start_key() {
  set_has_request_start_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
  return request_start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RangeKeyMismatchError::release_request_start_key() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
  clear_has_request_start_key();
  return request_start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RangeKeyMismatchError::set_allocated_request_start_key(::std::string* request_start_key) {
  if (request_start_key != NULL) {
    set_has_request_start_key();
  } else {
    clear_has_request_start_key();
  }
  request_start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_start_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeKeyMismatchError.request_start_key)
}

bool RangeKeyMismatchError::has_request_end_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RangeKeyMismatchError::set_has_request_end_key() {
  _has_bits_[0] |= 0x00000002u;
}
void RangeKeyMismatchError::clear_has_request_end_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void RangeKeyMismatchError::clear_request_end_key() {
  request_end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_end_key();
}
const ::std::string& RangeKeyMismatchError::request_end_key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
  return request_end_key_.GetNoArena();
}
void RangeKeyMismatchError::set_request_end_key(const ::std::string& value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
}
#if LANG_CXX11
void RangeKeyMismatchError::set_request_end_key(::std::string&& value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
}
#endif
void RangeKeyMismatchError::set_request_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
}
void RangeKeyMismatchError::set_request_end_key(const void* value, size_t size) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
}
::std::string* RangeKeyMismatchError::mutable_request_end_key() {
  set_has_request_end_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
  return request_end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RangeKeyMismatchError::release_request_end_key() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
  clear_has_request_end_key();
  return request_end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RangeKeyMismatchError::set_allocated_request_end_key(::std::string* request_end_key) {
  if (request_end_key != NULL) {
    set_has_request_end_key();
  } else {
    clear_has_request_end_key();
  }
  request_end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_end_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeKeyMismatchError.request_end_key)
}

// optional .cockroach.roachpb.RangeDescriptor mismatched_range = 3;
bool RangeKeyMismatchError::has_mismatched_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RangeKeyMismatchError::set_has_mismatched_range() {
  _has_bits_[0] |= 0x00000004u;
}
void RangeKeyMismatchError::clear_has_mismatched_range() {
  _has_bits_[0] &= ~0x00000004u;
}
void RangeKeyMismatchError::clear_mismatched_range() {
  if (mismatched_range_ != NULL) mismatched_range_->::cockroach::roachpb::RangeDescriptor::Clear();
  clear_has_mismatched_range();
}
const ::cockroach::roachpb::RangeDescriptor& RangeKeyMismatchError::mismatched_range() const {
  const ::cockroach::roachpb::RangeDescriptor* p = mismatched_range_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeKeyMismatchError.mismatched_range)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::RangeDescriptor*>(
      &::cockroach::roachpb::_RangeDescriptor_default_instance_);
}
::cockroach::roachpb::RangeDescriptor* RangeKeyMismatchError::mutable_mismatched_range() {
  set_has_mismatched_range();
  if (mismatched_range_ == NULL) {
    mismatched_range_ = new ::cockroach::roachpb::RangeDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeKeyMismatchError.mismatched_range)
  return mismatched_range_;
}
::cockroach::roachpb::RangeDescriptor* RangeKeyMismatchError::release_mismatched_range() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.RangeKeyMismatchError.mismatched_range)
  clear_has_mismatched_range();
  ::cockroach::roachpb::RangeDescriptor* temp = mismatched_range_;
  mismatched_range_ = NULL;
  return temp;
}
void RangeKeyMismatchError::set_allocated_mismatched_range(::cockroach::roachpb::RangeDescriptor* mismatched_range) {
  delete mismatched_range_;
  mismatched_range_ = mismatched_range;
  if (mismatched_range) {
    set_has_mismatched_range();
  } else {
    clear_has_mismatched_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeKeyMismatchError.mismatched_range)
}

// optional .cockroach.roachpb.RangeDescriptor suggested_range = 4;
bool RangeKeyMismatchError::has_suggested_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RangeKeyMismatchError::set_has_suggested_range() {
  _has_bits_[0] |= 0x00000008u;
}
void RangeKeyMismatchError::clear_has_suggested_range() {
  _has_bits_[0] &= ~0x00000008u;
}
void RangeKeyMismatchError::clear_suggested_range() {
  if (suggested_range_ != NULL) suggested_range_->::cockroach::roachpb::RangeDescriptor::Clear();
  clear_has_suggested_range();
}
const ::cockroach::roachpb::RangeDescriptor& RangeKeyMismatchError::suggested_range() const {
  const ::cockroach::roachpb::RangeDescriptor* p = suggested_range_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeKeyMismatchError.suggested_range)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::RangeDescriptor*>(
      &::cockroach::roachpb::_RangeDescriptor_default_instance_);
}
::cockroach::roachpb::RangeDescriptor* RangeKeyMismatchError::mutable_suggested_range() {
  set_has_suggested_range();
  if (suggested_range_ == NULL) {
    suggested_range_ = new ::cockroach::roachpb::RangeDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeKeyMismatchError.suggested_range)
  return suggested_range_;
}
::cockroach::roachpb::RangeDescriptor* RangeKeyMismatchError::release_suggested_range() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.RangeKeyMismatchError.suggested_range)
  clear_has_suggested_range();
  ::cockroach::roachpb::RangeDescriptor* temp = suggested_range_;
  suggested_range_ = NULL;
  return temp;
}
void RangeKeyMismatchError::set_allocated_suggested_range(::cockroach::roachpb::RangeDescriptor* suggested_range) {
  delete suggested_range_;
  suggested_range_ = suggested_range;
  if (suggested_range) {
    set_has_suggested_range();
  } else {
    clear_has_suggested_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeKeyMismatchError.suggested_range)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReadWithinUncertaintyIntervalError::kReadTimestampFieldNumber;
const int ReadWithinUncertaintyIntervalError::kExistingTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
}
ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError(const ReadWithinUncertaintyIntervalError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_read_timestamp()) {
    read_timestamp_ = new ::cockroach::util::hlc::Timestamp(*from.read_timestamp_);
  } else {
    read_timestamp_ = NULL;
  }
  if (from.has_existing_timestamp()) {
    existing_timestamp_ = new ::cockroach::util::hlc::Timestamp(*from.existing_timestamp_);
  } else {
    existing_timestamp_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
}

void ReadWithinUncertaintyIntervalError::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&read_timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&existing_timestamp_) -
      reinterpret_cast<char*>(&read_timestamp_)) + sizeof(existing_timestamp_));
}

ReadWithinUncertaintyIntervalError::~ReadWithinUncertaintyIntervalError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  SharedDtor();
}

void ReadWithinUncertaintyIntervalError::SharedDtor() {
  if (this != internal_default_instance()) delete read_timestamp_;
  if (this != internal_default_instance()) delete existing_timestamp_;
}

void ReadWithinUncertaintyIntervalError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadWithinUncertaintyIntervalError& ReadWithinUncertaintyIntervalError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ReadWithinUncertaintyIntervalError* ReadWithinUncertaintyIntervalError::New(::google::protobuf::Arena* arena) const {
  ReadWithinUncertaintyIntervalError* n = new ReadWithinUncertaintyIntervalError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadWithinUncertaintyIntervalError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(read_timestamp_ != NULL);
      read_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(existing_timestamp_ != NULL);
      existing_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ReadWithinUncertaintyIntervalError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_read_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  return false;
#undef DO_
}

void ReadWithinUncertaintyIntervalError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->read_timestamp_, output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->existing_timestamp_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
}

size_t ReadWithinUncertaintyIntervalError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    if (has_read_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->read_timestamp_);
    }

    if (has_existing_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_timestamp_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadWithinUncertaintyIntervalError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadWithinUncertaintyIntervalError*>(&from));
}

void ReadWithinUncertaintyIntervalError::MergeFrom(const ReadWithinUncertaintyIntervalError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_read_timestamp()->::cockroach::util::hlc::Timestamp::MergeFrom(from.read_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_existing_timestamp()->::cockroach::util::hlc::Timestamp::MergeFrom(from.existing_timestamp());
    }
  }
}

void ReadWithinUncertaintyIntervalError::CopyFrom(const ReadWithinUncertaintyIntervalError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ReadWithinUncertaintyIntervalError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadWithinUncertaintyIntervalError::IsInitialized() const {
  return true;
}

void ReadWithinUncertaintyIntervalError::Swap(ReadWithinUncertaintyIntervalError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadWithinUncertaintyIntervalError::InternalSwap(ReadWithinUncertaintyIntervalError* other) {
  using std::swap;
  swap(read_timestamp_, other->read_timestamp_);
  swap(existing_timestamp_, other->existing_timestamp_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ReadWithinUncertaintyIntervalError::GetTypeName() const {
  return "cockroach.roachpb.ReadWithinUncertaintyIntervalError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadWithinUncertaintyIntervalError

bool ReadWithinUncertaintyIntervalError::has_read_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_read_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_has_read_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_read_timestamp() {
  if (read_timestamp_ != NULL) read_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
  clear_has_read_timestamp();
}
const ::cockroach::util::hlc::Timestamp& ReadWithinUncertaintyIntervalError::read_timestamp() const {
  const ::cockroach::util::hlc::Timestamp* p = read_timestamp_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReadWithinUncertaintyIntervalError.read_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
::cockroach::util::hlc::Timestamp* ReadWithinUncertaintyIntervalError::mutable_read_timestamp() {
  set_has_read_timestamp();
  if (read_timestamp_ == NULL) {
    read_timestamp_ = new ::cockroach::util::hlc::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReadWithinUncertaintyIntervalError.read_timestamp)
  return read_timestamp_;
}
::cockroach::util::hlc::Timestamp* ReadWithinUncertaintyIntervalError::release_read_timestamp() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ReadWithinUncertaintyIntervalError.read_timestamp)
  clear_has_read_timestamp();
  ::cockroach::util::hlc::Timestamp* temp = read_timestamp_;
  read_timestamp_ = NULL;
  return temp;
}
void ReadWithinUncertaintyIntervalError::set_allocated_read_timestamp(::cockroach::util::hlc::Timestamp* read_timestamp) {
  delete read_timestamp_;
  read_timestamp_ = read_timestamp;
  if (read_timestamp) {
    set_has_read_timestamp();
  } else {
    clear_has_read_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReadWithinUncertaintyIntervalError.read_timestamp)
}

bool ReadWithinUncertaintyIntervalError::has_existing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_existing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_has_existing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_existing_timestamp() {
  if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
  clear_has_existing_timestamp();
}
const ::cockroach::util::hlc::Timestamp& ReadWithinUncertaintyIntervalError::existing_timestamp() const {
  const ::cockroach::util::hlc::Timestamp* p = existing_timestamp_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
::cockroach::util::hlc::Timestamp* ReadWithinUncertaintyIntervalError::mutable_existing_timestamp() {
  set_has_existing_timestamp();
  if (existing_timestamp_ == NULL) {
    existing_timestamp_ = new ::cockroach::util::hlc::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return existing_timestamp_;
}
::cockroach::util::hlc::Timestamp* ReadWithinUncertaintyIntervalError::release_existing_timestamp() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ReadWithinUncertaintyIntervalError.existing_timestamp)
  clear_has_existing_timestamp();
  ::cockroach::util::hlc::Timestamp* temp = existing_timestamp_;
  existing_timestamp_ = NULL;
  return temp;
}
void ReadWithinUncertaintyIntervalError::set_allocated_existing_timestamp(::cockroach::util::hlc::Timestamp* existing_timestamp) {
  delete existing_timestamp_;
  existing_timestamp_ = existing_timestamp;
  if (existing_timestamp) {
    set_has_existing_timestamp();
  } else {
    clear_has_existing_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReadWithinUncertaintyIntervalError.existing_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransactionAbortedError::TransactionAbortedError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TransactionAbortedError)
}
TransactionAbortedError::TransactionAbortedError(const TransactionAbortedError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TransactionAbortedError)
}

void TransactionAbortedError::SharedCtor() {
  _cached_size_ = 0;
}

TransactionAbortedError::~TransactionAbortedError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TransactionAbortedError)
  SharedDtor();
}

void TransactionAbortedError::SharedDtor() {
}

void TransactionAbortedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionAbortedError& TransactionAbortedError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TransactionAbortedError* TransactionAbortedError::New(::google::protobuf::Arena* arena) const {
  TransactionAbortedError* n = new TransactionAbortedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionAbortedError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TransactionAbortedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TransactionAbortedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TransactionAbortedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TransactionAbortedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TransactionAbortedError)
  return false;
#undef DO_
}

void TransactionAbortedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TransactionAbortedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TransactionAbortedError)
}

size_t TransactionAbortedError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TransactionAbortedError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionAbortedError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionAbortedError*>(&from));
}

void TransactionAbortedError::MergeFrom(const TransactionAbortedError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TransactionAbortedError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void TransactionAbortedError::CopyFrom(const TransactionAbortedError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TransactionAbortedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionAbortedError::IsInitialized() const {
  return true;
}

void TransactionAbortedError::Swap(TransactionAbortedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionAbortedError::InternalSwap(TransactionAbortedError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TransactionAbortedError::GetTypeName() const {
  return "cockroach.roachpb.TransactionAbortedError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionAbortedError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TransactionPushError::kPusheeTxnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransactionPushError::TransactionPushError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TransactionPushError)
}
TransactionPushError::TransactionPushError(const TransactionPushError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pushee_txn()) {
    pushee_txn_ = new ::cockroach::roachpb::Transaction(*from.pushee_txn_);
  } else {
    pushee_txn_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TransactionPushError)
}

void TransactionPushError::SharedCtor() {
  _cached_size_ = 0;
  pushee_txn_ = NULL;
}

TransactionPushError::~TransactionPushError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TransactionPushError)
  SharedDtor();
}

void TransactionPushError::SharedDtor() {
  if (this != internal_default_instance()) delete pushee_txn_;
}

void TransactionPushError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionPushError& TransactionPushError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TransactionPushError* TransactionPushError::New(::google::protobuf::Arena* arena) const {
  TransactionPushError* n = new TransactionPushError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionPushError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TransactionPushError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_pushee_txn()) {
    GOOGLE_DCHECK(pushee_txn_ != NULL);
    pushee_txn_->::cockroach::roachpb::Transaction::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TransactionPushError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TransactionPushError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TransactionPushError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TransactionPushError)
  return false;
#undef DO_
}

void TransactionPushError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TransactionPushError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->pushee_txn_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TransactionPushError)
}

size_t TransactionPushError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TransactionPushError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_pushee_txn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pushee_txn_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionPushError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionPushError*>(&from));
}

void TransactionPushError::MergeFrom(const TransactionPushError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TransactionPushError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_pushee_txn()) {
    mutable_pushee_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.pushee_txn());
  }
}

void TransactionPushError::CopyFrom(const TransactionPushError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TransactionPushError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionPushError::IsInitialized() const {
  return true;
}

void TransactionPushError::Swap(TransactionPushError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionPushError::InternalSwap(TransactionPushError* other) {
  using std::swap;
  swap(pushee_txn_, other->pushee_txn_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TransactionPushError::GetTypeName() const {
  return "cockroach.roachpb.TransactionPushError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionPushError

bool TransactionPushError::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionPushError::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionPushError::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionPushError::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_pushee_txn();
}
const ::cockroach::roachpb::Transaction& TransactionPushError::pushee_txn() const {
  const ::cockroach::roachpb::Transaction* p = pushee_txn_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TransactionPushError.pushee_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Transaction*>(
      &::cockroach::roachpb::_Transaction_default_instance_);
}
::cockroach::roachpb::Transaction* TransactionPushError::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TransactionPushError.pushee_txn)
  return pushee_txn_;
}
::cockroach::roachpb::Transaction* TransactionPushError::release_pushee_txn() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.TransactionPushError.pushee_txn)
  clear_has_pushee_txn();
  ::cockroach::roachpb::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
void TransactionPushError::set_allocated_pushee_txn(::cockroach::roachpb::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TransactionPushError.pushee_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TransactionRetryError::kReasonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransactionRetryError::TransactionRetryError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TransactionRetryError)
}
TransactionRetryError::TransactionRetryError(const TransactionRetryError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reason_ = from.reason_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TransactionRetryError)
}

void TransactionRetryError::SharedCtor() {
  _cached_size_ = 0;
  reason_ = 0;
}

TransactionRetryError::~TransactionRetryError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TransactionRetryError)
  SharedDtor();
}

void TransactionRetryError::SharedDtor() {
}

void TransactionRetryError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionRetryError& TransactionRetryError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TransactionRetryError* TransactionRetryError::New(::google::protobuf::Arena* arena) const {
  TransactionRetryError* n = new TransactionRetryError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionRetryError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TransactionRetryError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reason_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TransactionRetryError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TransactionRetryError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::TransactionRetryReason_IsValid(value)) {
            set_reason(static_cast< ::cockroach::roachpb::TransactionRetryReason >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TransactionRetryError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TransactionRetryError)
  return false;
#undef DO_
}

void TransactionRetryError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TransactionRetryError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->reason(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TransactionRetryError)
}

size_t TransactionRetryError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TransactionRetryError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_reason()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->reason());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRetryError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionRetryError*>(&from));
}

void TransactionRetryError::MergeFrom(const TransactionRetryError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TransactionRetryError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_reason()) {
    set_reason(from.reason());
  }
}

void TransactionRetryError::CopyFrom(const TransactionRetryError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TransactionRetryError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRetryError::IsInitialized() const {
  return true;
}

void TransactionRetryError::Swap(TransactionRetryError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionRetryError::InternalSwap(TransactionRetryError* other) {
  using std::swap;
  swap(reason_, other->reason_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TransactionRetryError::GetTypeName() const {
  return "cockroach.roachpb.TransactionRetryError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionRetryError

bool TransactionRetryError::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionRetryError::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionRetryError::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionRetryError::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
::cockroach::roachpb::TransactionRetryReason TransactionRetryError::reason() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TransactionRetryError.reason)
  return static_cast< ::cockroach::roachpb::TransactionRetryReason >(reason_);
}
void TransactionRetryError::set_reason(::cockroach::roachpb::TransactionRetryReason value) {
  assert(::cockroach::roachpb::TransactionRetryReason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TransactionRetryError.reason)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransactionReplayError::TransactionReplayError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TransactionReplayError)
}
TransactionReplayError::TransactionReplayError(const TransactionReplayError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TransactionReplayError)
}

void TransactionReplayError::SharedCtor() {
  _cached_size_ = 0;
}

TransactionReplayError::~TransactionReplayError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TransactionReplayError)
  SharedDtor();
}

void TransactionReplayError::SharedDtor() {
}

void TransactionReplayError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionReplayError& TransactionReplayError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TransactionReplayError* TransactionReplayError::New(::google::protobuf::Arena* arena) const {
  TransactionReplayError* n = new TransactionReplayError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionReplayError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TransactionReplayError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TransactionReplayError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TransactionReplayError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TransactionReplayError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TransactionReplayError)
  return false;
#undef DO_
}

void TransactionReplayError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TransactionReplayError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TransactionReplayError)
}

size_t TransactionReplayError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TransactionReplayError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionReplayError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionReplayError*>(&from));
}

void TransactionReplayError::MergeFrom(const TransactionReplayError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TransactionReplayError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void TransactionReplayError::CopyFrom(const TransactionReplayError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TransactionReplayError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionReplayError::IsInitialized() const {
  return true;
}

void TransactionReplayError::Swap(TransactionReplayError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionReplayError::InternalSwap(TransactionReplayError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TransactionReplayError::GetTypeName() const {
  return "cockroach.roachpb.TransactionReplayError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionReplayError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TransactionStatusError::kMsgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransactionStatusError::TransactionStatusError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TransactionStatusError)
}
TransactionStatusError::TransactionStatusError(const TransactionStatusError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_msg()) {
    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TransactionStatusError)
}

void TransactionStatusError::SharedCtor() {
  _cached_size_ = 0;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

TransactionStatusError::~TransactionStatusError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TransactionStatusError)
  SharedDtor();
}

void TransactionStatusError::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TransactionStatusError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStatusError& TransactionStatusError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TransactionStatusError* TransactionStatusError::New(::google::protobuf::Arena* arena) const {
  TransactionStatusError* n = new TransactionStatusError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionStatusError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TransactionStatusError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_msg()) {
    GOOGLE_DCHECK(!msg_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*msg_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TransactionStatusError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TransactionStatusError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TransactionStatusError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TransactionStatusError)
  return false;
#undef DO_
}

void TransactionStatusError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TransactionStatusError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->msg(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TransactionStatusError)
}

size_t TransactionStatusError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TransactionStatusError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_msg()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->msg());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStatusError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStatusError*>(&from));
}

void TransactionStatusError::MergeFrom(const TransactionStatusError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TransactionStatusError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_msg()) {
    set_has_msg();
    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
}

void TransactionStatusError::CopyFrom(const TransactionStatusError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TransactionStatusError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStatusError::IsInitialized() const {
  return true;
}

void TransactionStatusError::Swap(TransactionStatusError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionStatusError::InternalSwap(TransactionStatusError* other) {
  using std::swap;
  msg_.Swap(&other->msg_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TransactionStatusError::GetTypeName() const {
  return "cockroach.roachpb.TransactionStatusError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionStatusError

bool TransactionStatusError::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionStatusError::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionStatusError::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionStatusError::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
const ::std::string& TransactionStatusError::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TransactionStatusError.msg)
  return msg_.GetNoArena();
}
void TransactionStatusError::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TransactionStatusError.msg)
}
#if LANG_CXX11
void TransactionStatusError::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.TransactionStatusError.msg)
}
#endif
void TransactionStatusError::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.TransactionStatusError.msg)
}
void TransactionStatusError::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.TransactionStatusError.msg)
}
::std::string* TransactionStatusError::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TransactionStatusError.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TransactionStatusError::release_msg() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.TransactionStatusError.msg)
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TransactionStatusError::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TransactionStatusError.msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WriteIntentError::kIntentsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WriteIntentError::WriteIntentError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.WriteIntentError)
}
WriteIntentError::WriteIntentError(const WriteIntentError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      intents_(from.intents_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.WriteIntentError)
}

void WriteIntentError::SharedCtor() {
  _cached_size_ = 0;
}

WriteIntentError::~WriteIntentError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.WriteIntentError)
  SharedDtor();
}

void WriteIntentError::SharedDtor() {
}

void WriteIntentError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WriteIntentError& WriteIntentError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

WriteIntentError* WriteIntentError::New(::google::protobuf::Arena* arena) const {
  WriteIntentError* n = new WriteIntentError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteIntentError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.WriteIntentError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  intents_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool WriteIntentError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.WriteIntentError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_intents()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.WriteIntentError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.WriteIntentError)
  return false;
#undef DO_
}

void WriteIntentError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.WriteIntentError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->intents_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->intents(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.WriteIntentError)
}

size_t WriteIntentError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.WriteIntentError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  {
    unsigned int count = static_cast<unsigned int>(this->intents_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->intents(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteIntentError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WriteIntentError*>(&from));
}

void WriteIntentError::MergeFrom(const WriteIntentError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.WriteIntentError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  intents_.MergeFrom(from.intents_);
}

void WriteIntentError::CopyFrom(const WriteIntentError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.WriteIntentError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteIntentError::IsInitialized() const {
  return true;
}

void WriteIntentError::Swap(WriteIntentError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteIntentError::InternalSwap(WriteIntentError* other) {
  using std::swap;
  intents_.InternalSwap(&other->intents_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string WriteIntentError::GetTypeName() const {
  return "cockroach.roachpb.WriteIntentError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteIntentError

int WriteIntentError::intents_size() const {
  return intents_.size();
}
void WriteIntentError::clear_intents() {
  intents_.Clear();
}
const ::cockroach::roachpb::Intent& WriteIntentError::intents(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.WriteIntentError.intents)
  return intents_.Get(index);
}
::cockroach::roachpb::Intent* WriteIntentError::mutable_intents(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.WriteIntentError.intents)
  return intents_.Mutable(index);
}
::cockroach::roachpb::Intent* WriteIntentError::add_intents() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.WriteIntentError.intents)
  return intents_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Intent >*
WriteIntentError::mutable_intents() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.WriteIntentError.intents)
  return &intents_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Intent >&
WriteIntentError::intents() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.WriteIntentError.intents)
  return intents_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WriteTooOldError::kTimestampFieldNumber;
const int WriteTooOldError::kActualTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WriteTooOldError::WriteTooOldError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.WriteTooOldError)
}
WriteTooOldError::WriteTooOldError(const WriteTooOldError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_timestamp()) {
    timestamp_ = new ::cockroach::util::hlc::Timestamp(*from.timestamp_);
  } else {
    timestamp_ = NULL;
  }
  if (from.has_actual_timestamp()) {
    actual_timestamp_ = new ::cockroach::util::hlc::Timestamp(*from.actual_timestamp_);
  } else {
    actual_timestamp_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.WriteTooOldError)
}

void WriteTooOldError::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&actual_timestamp_) -
      reinterpret_cast<char*>(&timestamp_)) + sizeof(actual_timestamp_));
}

WriteTooOldError::~WriteTooOldError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.WriteTooOldError)
  SharedDtor();
}

void WriteTooOldError::SharedDtor() {
  if (this != internal_default_instance()) delete timestamp_;
  if (this != internal_default_instance()) delete actual_timestamp_;
}

void WriteTooOldError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WriteTooOldError& WriteTooOldError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

WriteTooOldError* WriteTooOldError::New(::google::protobuf::Arena* arena) const {
  WriteTooOldError* n = new WriteTooOldError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteTooOldError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.WriteTooOldError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(timestamp_ != NULL);
      timestamp_->::cockroach::util::hlc::Timestamp::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(actual_timestamp_ != NULL);
      actual_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool WriteTooOldError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.WriteTooOldError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actual_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.WriteTooOldError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.WriteTooOldError)
  return false;
#undef DO_
}

void WriteTooOldError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.WriteTooOldError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->timestamp_, output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->actual_timestamp_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.WriteTooOldError)
}

size_t WriteTooOldError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.WriteTooOldError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    if (has_actual_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->actual_timestamp_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteTooOldError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WriteTooOldError*>(&from));
}

void WriteTooOldError::MergeFrom(const WriteTooOldError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.WriteTooOldError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_timestamp()->::cockroach::util::hlc::Timestamp::MergeFrom(from.timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_actual_timestamp()->::cockroach::util::hlc::Timestamp::MergeFrom(from.actual_timestamp());
    }
  }
}

void WriteTooOldError::CopyFrom(const WriteTooOldError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.WriteTooOldError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteTooOldError::IsInitialized() const {
  return true;
}

void WriteTooOldError::Swap(WriteTooOldError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteTooOldError::InternalSwap(WriteTooOldError* other) {
  using std::swap;
  swap(timestamp_, other->timestamp_);
  swap(actual_timestamp_, other->actual_timestamp_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string WriteTooOldError::GetTypeName() const {
  return "cockroach.roachpb.WriteTooOldError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteTooOldError

bool WriteTooOldError::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WriteTooOldError::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void WriteTooOldError::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void WriteTooOldError::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::util::hlc::Timestamp::Clear();
  clear_has_timestamp();
}
const ::cockroach::util::hlc::Timestamp& WriteTooOldError::timestamp() const {
  const ::cockroach::util::hlc::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.WriteTooOldError.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
::cockroach::util::hlc::Timestamp* WriteTooOldError::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::util::hlc::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.WriteTooOldError.timestamp)
  return timestamp_;
}
::cockroach::util::hlc::Timestamp* WriteTooOldError::release_timestamp() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.WriteTooOldError.timestamp)
  clear_has_timestamp();
  ::cockroach::util::hlc::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
void WriteTooOldError::set_allocated_timestamp(::cockroach::util::hlc::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.WriteTooOldError.timestamp)
}

bool WriteTooOldError::has_actual_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WriteTooOldError::set_has_actual_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void WriteTooOldError::clear_has_actual_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void WriteTooOldError::clear_actual_timestamp() {
  if (actual_timestamp_ != NULL) actual_timestamp_->::cockroach::util::hlc::Timestamp::Clear();
  clear_has_actual_timestamp();
}
const ::cockroach::util::hlc::Timestamp& WriteTooOldError::actual_timestamp() const {
  const ::cockroach::util::hlc::Timestamp* p = actual_timestamp_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.WriteTooOldError.actual_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
::cockroach::util::hlc::Timestamp* WriteTooOldError::mutable_actual_timestamp() {
  set_has_actual_timestamp();
  if (actual_timestamp_ == NULL) {
    actual_timestamp_ = new ::cockroach::util::hlc::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.WriteTooOldError.actual_timestamp)
  return actual_timestamp_;
}
::cockroach::util::hlc::Timestamp* WriteTooOldError::release_actual_timestamp() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.WriteTooOldError.actual_timestamp)
  clear_has_actual_timestamp();
  ::cockroach::util::hlc::Timestamp* temp = actual_timestamp_;
  actual_timestamp_ = NULL;
  return temp;
}
void WriteTooOldError::set_allocated_actual_timestamp(::cockroach::util::hlc::Timestamp* actual_timestamp) {
  delete actual_timestamp_;
  actual_timestamp_ = actual_timestamp;
  if (actual_timestamp) {
    set_has_actual_timestamp();
  } else {
    clear_has_actual_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.WriteTooOldError.actual_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OpRequiresTxnError::OpRequiresTxnError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.OpRequiresTxnError)
}
OpRequiresTxnError::OpRequiresTxnError(const OpRequiresTxnError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.OpRequiresTxnError)
}

void OpRequiresTxnError::SharedCtor() {
  _cached_size_ = 0;
}

OpRequiresTxnError::~OpRequiresTxnError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.OpRequiresTxnError)
  SharedDtor();
}

void OpRequiresTxnError::SharedDtor() {
}

void OpRequiresTxnError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpRequiresTxnError& OpRequiresTxnError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

OpRequiresTxnError* OpRequiresTxnError::New(::google::protobuf::Arena* arena) const {
  OpRequiresTxnError* n = new OpRequiresTxnError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpRequiresTxnError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.OpRequiresTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OpRequiresTxnError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.OpRequiresTxnError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.OpRequiresTxnError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.OpRequiresTxnError)
  return false;
#undef DO_
}

void OpRequiresTxnError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.OpRequiresTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.OpRequiresTxnError)
}

size_t OpRequiresTxnError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.OpRequiresTxnError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpRequiresTxnError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpRequiresTxnError*>(&from));
}

void OpRequiresTxnError::MergeFrom(const OpRequiresTxnError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.OpRequiresTxnError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void OpRequiresTxnError::CopyFrom(const OpRequiresTxnError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.OpRequiresTxnError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpRequiresTxnError::IsInitialized() const {
  return true;
}

void OpRequiresTxnError::Swap(OpRequiresTxnError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpRequiresTxnError::InternalSwap(OpRequiresTxnError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string OpRequiresTxnError::GetTypeName() const {
  return "cockroach.roachpb.OpRequiresTxnError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpRequiresTxnError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConditionFailedError::kActualValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConditionFailedError::ConditionFailedError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ConditionFailedError)
}
ConditionFailedError::ConditionFailedError(const ConditionFailedError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_actual_value()) {
    actual_value_ = new ::cockroach::roachpb::Value(*from.actual_value_);
  } else {
    actual_value_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ConditionFailedError)
}

void ConditionFailedError::SharedCtor() {
  _cached_size_ = 0;
  actual_value_ = NULL;
}

ConditionFailedError::~ConditionFailedError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ConditionFailedError)
  SharedDtor();
}

void ConditionFailedError::SharedDtor() {
  if (this != internal_default_instance()) delete actual_value_;
}

void ConditionFailedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConditionFailedError& ConditionFailedError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ConditionFailedError* ConditionFailedError::New(::google::protobuf::Arena* arena) const {
  ConditionFailedError* n = new ConditionFailedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionFailedError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ConditionFailedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_actual_value()) {
    GOOGLE_DCHECK(actual_value_ != NULL);
    actual_value_->::cockroach::roachpb::Value::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConditionFailedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ConditionFailedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Value actual_value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actual_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ConditionFailedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ConditionFailedError)
  return false;
#undef DO_
}

void ConditionFailedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ConditionFailedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .cockroach.roachpb.Value actual_value = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->actual_value_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ConditionFailedError)
}

size_t ConditionFailedError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ConditionFailedError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // optional .cockroach.roachpb.Value actual_value = 1;
  if (has_actual_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->actual_value_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionFailedError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConditionFailedError*>(&from));
}

void ConditionFailedError::MergeFrom(const ConditionFailedError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ConditionFailedError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_actual_value()) {
    mutable_actual_value()->::cockroach::roachpb::Value::MergeFrom(from.actual_value());
  }
}

void ConditionFailedError::CopyFrom(const ConditionFailedError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ConditionFailedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionFailedError::IsInitialized() const {
  return true;
}

void ConditionFailedError::Swap(ConditionFailedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionFailedError::InternalSwap(ConditionFailedError* other) {
  using std::swap;
  swap(actual_value_, other->actual_value_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ConditionFailedError::GetTypeName() const {
  return "cockroach.roachpb.ConditionFailedError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionFailedError

// optional .cockroach.roachpb.Value actual_value = 1;
bool ConditionFailedError::has_actual_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionFailedError::set_has_actual_value() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionFailedError::clear_has_actual_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionFailedError::clear_actual_value() {
  if (actual_value_ != NULL) actual_value_->::cockroach::roachpb::Value::Clear();
  clear_has_actual_value();
}
const ::cockroach::roachpb::Value& ConditionFailedError::actual_value() const {
  const ::cockroach::roachpb::Value* p = actual_value_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionFailedError.actual_value)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Value*>(
      &::cockroach::roachpb::_Value_default_instance_);
}
::cockroach::roachpb::Value* ConditionFailedError::mutable_actual_value() {
  set_has_actual_value();
  if (actual_value_ == NULL) {
    actual_value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionFailedError.actual_value)
  return actual_value_;
}
::cockroach::roachpb::Value* ConditionFailedError::release_actual_value() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ConditionFailedError.actual_value)
  clear_has_actual_value();
  ::cockroach::roachpb::Value* temp = actual_value_;
  actual_value_ = NULL;
  return temp;
}
void ConditionFailedError::set_allocated_actual_value(::cockroach::roachpb::Value* actual_value) {
  delete actual_value_;
  actual_value_ = actual_value;
  if (actual_value) {
    set_has_actual_value();
  } else {
    clear_has_actual_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionFailedError.actual_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LeaseRejectedError::kMessageFieldNumber;
const int LeaseRejectedError::kRequestedFieldNumber;
const int LeaseRejectedError::kExistingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LeaseRejectedError::LeaseRejectedError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.LeaseRejectedError)
}
LeaseRejectedError::LeaseRejectedError(const LeaseRejectedError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  if (from.has_requested()) {
    requested_ = new ::cockroach::roachpb::Lease(*from.requested_);
  } else {
    requested_ = NULL;
  }
  if (from.has_existing()) {
    existing_ = new ::cockroach::roachpb::Lease(*from.existing_);
  } else {
    existing_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.LeaseRejectedError)
}

void LeaseRejectedError::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&requested_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&existing_) -
      reinterpret_cast<char*>(&requested_)) + sizeof(existing_));
}

LeaseRejectedError::~LeaseRejectedError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.LeaseRejectedError)
  SharedDtor();
}

void LeaseRejectedError::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete requested_;
  if (this != internal_default_instance()) delete existing_;
}

void LeaseRejectedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaseRejectedError& LeaseRejectedError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

LeaseRejectedError* LeaseRejectedError::New(::google::protobuf::Arena* arena) const {
  LeaseRejectedError* n = new LeaseRejectedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaseRejectedError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.LeaseRejectedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(requested_ != NULL);
      requested_->::cockroach::roachpb::Lease::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(existing_ != NULL);
      existing_->::cockroach::roachpb::Lease::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool LeaseRejectedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.LeaseRejectedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_requested()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.LeaseRejectedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.LeaseRejectedError)
  return false;
#undef DO_
}

void LeaseRejectedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.LeaseRejectedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->requested_, output);
  }

  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->existing_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.LeaseRejectedError)
}

size_t LeaseRejectedError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.LeaseRejectedError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 7u) {
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    if (has_requested()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->requested_);
    }

    if (has_existing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaseRejectedError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaseRejectedError*>(&from));
}

void LeaseRejectedError::MergeFrom(const LeaseRejectedError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.LeaseRejectedError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_requested()->::cockroach::roachpb::Lease::MergeFrom(from.requested());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_existing()->::cockroach::roachpb::Lease::MergeFrom(from.existing());
    }
  }
}

void LeaseRejectedError::CopyFrom(const LeaseRejectedError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.LeaseRejectedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseRejectedError::IsInitialized() const {
  return true;
}

void LeaseRejectedError::Swap(LeaseRejectedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaseRejectedError::InternalSwap(LeaseRejectedError* other) {
  using std::swap;
  message_.Swap(&other->message_);
  swap(requested_, other->requested_);
  swap(existing_, other->existing_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string LeaseRejectedError::GetTypeName() const {
  return "cockroach.roachpb.LeaseRejectedError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaseRejectedError

bool LeaseRejectedError::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaseRejectedError::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaseRejectedError::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaseRejectedError::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& LeaseRejectedError::message() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaseRejectedError.message)
  return message_.GetNoArena();
}
void LeaseRejectedError::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.LeaseRejectedError.message)
}
#if LANG_CXX11
void LeaseRejectedError::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.LeaseRejectedError.message)
}
#endif
void LeaseRejectedError::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.LeaseRejectedError.message)
}
void LeaseRejectedError::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.LeaseRejectedError.message)
}
::std::string* LeaseRejectedError::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaseRejectedError.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* LeaseRejectedError::release_message() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.LeaseRejectedError.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void LeaseRejectedError::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaseRejectedError.message)
}

bool LeaseRejectedError::has_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LeaseRejectedError::set_has_requested() {
  _has_bits_[0] |= 0x00000002u;
}
void LeaseRejectedError::clear_has_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
void LeaseRejectedError::clear_requested() {
  if (requested_ != NULL) requested_->::cockroach::roachpb::Lease::Clear();
  clear_has_requested();
}
const ::cockroach::roachpb::Lease& LeaseRejectedError::requested() const {
  const ::cockroach::roachpb::Lease* p = requested_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaseRejectedError.requested)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Lease*>(
      &::cockroach::roachpb::_Lease_default_instance_);
}
::cockroach::roachpb::Lease* LeaseRejectedError::mutable_requested() {
  set_has_requested();
  if (requested_ == NULL) {
    requested_ = new ::cockroach::roachpb::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaseRejectedError.requested)
  return requested_;
}
::cockroach::roachpb::Lease* LeaseRejectedError::release_requested() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.LeaseRejectedError.requested)
  clear_has_requested();
  ::cockroach::roachpb::Lease* temp = requested_;
  requested_ = NULL;
  return temp;
}
void LeaseRejectedError::set_allocated_requested(::cockroach::roachpb::Lease* requested) {
  delete requested_;
  requested_ = requested;
  if (requested) {
    set_has_requested();
  } else {
    clear_has_requested();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaseRejectedError.requested)
}

bool LeaseRejectedError::has_existing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LeaseRejectedError::set_has_existing() {
  _has_bits_[0] |= 0x00000004u;
}
void LeaseRejectedError::clear_has_existing() {
  _has_bits_[0] &= ~0x00000004u;
}
void LeaseRejectedError::clear_existing() {
  if (existing_ != NULL) existing_->::cockroach::roachpb::Lease::Clear();
  clear_has_existing();
}
const ::cockroach::roachpb::Lease& LeaseRejectedError::existing() const {
  const ::cockroach::roachpb::Lease* p = existing_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaseRejectedError.existing)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Lease*>(
      &::cockroach::roachpb::_Lease_default_instance_);
}
::cockroach::roachpb::Lease* LeaseRejectedError::mutable_existing() {
  set_has_existing();
  if (existing_ == NULL) {
    existing_ = new ::cockroach::roachpb::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaseRejectedError.existing)
  return existing_;
}
::cockroach::roachpb::Lease* LeaseRejectedError::release_existing() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.LeaseRejectedError.existing)
  clear_has_existing();
  ::cockroach::roachpb::Lease* temp = existing_;
  existing_ = NULL;
  return temp;
}
void LeaseRejectedError::set_allocated_existing(::cockroach::roachpb::Lease* existing) {
  delete existing_;
  existing_ = existing;
  if (existing) {
    set_has_existing();
  } else {
    clear_has_existing();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaseRejectedError.existing)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SendError::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SendError::SendError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.SendError)
}
SendError::SendError(const SendError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.SendError)
}

void SendError::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

SendError::~SendError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.SendError)
  SharedDtor();
}

void SendError::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SendError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendError& SendError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

SendError* SendError::New(::google::protobuf::Arena* arena) const {
  SendError* n = new SendError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SendError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.SendError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_message()) {
    GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*message_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SendError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.SendError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.SendError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.SendError)
  return false;
#undef DO_
}

void SendError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.SendError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.SendError)
}

size_t SendError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.SendError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_message()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendError*>(&from));
}

void SendError::MergeFrom(const SendError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.SendError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_message()) {
    set_has_message();
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void SendError::CopyFrom(const SendError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.SendError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendError::IsInitialized() const {
  return true;
}

void SendError::Swap(SendError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SendError::InternalSwap(SendError* other) {
  using std::swap;
  message_.Swap(&other->message_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string SendError::GetTypeName() const {
  return "cockroach.roachpb.SendError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SendError

bool SendError::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SendError::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void SendError::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void SendError::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& SendError::message() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.SendError.message)
  return message_.GetNoArena();
}
void SendError::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.SendError.message)
}
#if LANG_CXX11
void SendError::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.SendError.message)
}
#endif
void SendError::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.SendError.message)
}
void SendError::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.SendError.message)
}
::std::string* SendError::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.SendError.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SendError::release_message() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.SendError.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SendError::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.SendError.message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AmbiguousResultError::kMessageFieldNumber;
const int AmbiguousResultError::kWrappedErrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AmbiguousResultError::AmbiguousResultError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.AmbiguousResultError)
}
AmbiguousResultError::AmbiguousResultError(const AmbiguousResultError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  if (from.has_wrapped_err()) {
    wrapped_err_ = new ::cockroach::roachpb::Error(*from.wrapped_err_);
  } else {
    wrapped_err_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.AmbiguousResultError)
}

void AmbiguousResultError::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  wrapped_err_ = NULL;
}

AmbiguousResultError::~AmbiguousResultError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.AmbiguousResultError)
  SharedDtor();
}

void AmbiguousResultError::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete wrapped_err_;
}

void AmbiguousResultError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AmbiguousResultError& AmbiguousResultError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

AmbiguousResultError* AmbiguousResultError::New(::google::protobuf::Arena* arena) const {
  AmbiguousResultError* n = new AmbiguousResultError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AmbiguousResultError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.AmbiguousResultError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(wrapped_err_ != NULL);
      wrapped_err_->::cockroach::roachpb::Error::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool AmbiguousResultError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.AmbiguousResultError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.Error wrapped_err = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_wrapped_err()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.AmbiguousResultError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.AmbiguousResultError)
  return false;
#undef DO_
}

void AmbiguousResultError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.AmbiguousResultError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  // optional .cockroach.roachpb.Error wrapped_err = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->wrapped_err_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.AmbiguousResultError)
}

size_t AmbiguousResultError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.AmbiguousResultError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .cockroach.roachpb.Error wrapped_err = 2;
    if (has_wrapped_err()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->wrapped_err_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AmbiguousResultError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AmbiguousResultError*>(&from));
}

void AmbiguousResultError::MergeFrom(const AmbiguousResultError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.AmbiguousResultError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_wrapped_err()->::cockroach::roachpb::Error::MergeFrom(from.wrapped_err());
    }
  }
}

void AmbiguousResultError::CopyFrom(const AmbiguousResultError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.AmbiguousResultError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmbiguousResultError::IsInitialized() const {
  return true;
}

void AmbiguousResultError::Swap(AmbiguousResultError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AmbiguousResultError::InternalSwap(AmbiguousResultError* other) {
  using std::swap;
  message_.Swap(&other->message_);
  swap(wrapped_err_, other->wrapped_err_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string AmbiguousResultError::GetTypeName() const {
  return "cockroach.roachpb.AmbiguousResultError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AmbiguousResultError

bool AmbiguousResultError::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AmbiguousResultError::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void AmbiguousResultError::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void AmbiguousResultError::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& AmbiguousResultError::message() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AmbiguousResultError.message)
  return message_.GetNoArena();
}
void AmbiguousResultError::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.AmbiguousResultError.message)
}
#if LANG_CXX11
void AmbiguousResultError::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.AmbiguousResultError.message)
}
#endif
void AmbiguousResultError::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.AmbiguousResultError.message)
}
void AmbiguousResultError::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.AmbiguousResultError.message)
}
::std::string* AmbiguousResultError::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AmbiguousResultError.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AmbiguousResultError::release_message() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.AmbiguousResultError.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AmbiguousResultError::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AmbiguousResultError.message)
}

// optional .cockroach.roachpb.Error wrapped_err = 2;
bool AmbiguousResultError::has_wrapped_err() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void AmbiguousResultError::set_has_wrapped_err() {
  _has_bits_[0] |= 0x00000002u;
}
void AmbiguousResultError::clear_has_wrapped_err() {
  _has_bits_[0] &= ~0x00000002u;
}
void AmbiguousResultError::clear_wrapped_err() {
  if (wrapped_err_ != NULL) wrapped_err_->::cockroach::roachpb::Error::Clear();
  clear_has_wrapped_err();
}
const ::cockroach::roachpb::Error& AmbiguousResultError::wrapped_err() const {
  const ::cockroach::roachpb::Error* p = wrapped_err_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AmbiguousResultError.wrapped_err)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Error*>(
      &::cockroach::roachpb::_Error_default_instance_);
}
::cockroach::roachpb::Error* AmbiguousResultError::mutable_wrapped_err() {
  set_has_wrapped_err();
  if (wrapped_err_ == NULL) {
    wrapped_err_ = new ::cockroach::roachpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AmbiguousResultError.wrapped_err)
  return wrapped_err_;
}
::cockroach::roachpb::Error* AmbiguousResultError::release_wrapped_err() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.AmbiguousResultError.wrapped_err)
  clear_has_wrapped_err();
  ::cockroach::roachpb::Error* temp = wrapped_err_;
  wrapped_err_ = NULL;
  return temp;
}
void AmbiguousResultError::set_allocated_wrapped_err(::cockroach::roachpb::Error* wrapped_err) {
  delete wrapped_err_;
  wrapped_err_ = wrapped_err;
  if (wrapped_err) {
    set_has_wrapped_err();
  } else {
    clear_has_wrapped_err();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AmbiguousResultError.wrapped_err)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RaftGroupDeletedError::RaftGroupDeletedError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RaftGroupDeletedError)
}
RaftGroupDeletedError::RaftGroupDeletedError(const RaftGroupDeletedError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RaftGroupDeletedError)
}

void RaftGroupDeletedError::SharedCtor() {
  _cached_size_ = 0;
}

RaftGroupDeletedError::~RaftGroupDeletedError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RaftGroupDeletedError)
  SharedDtor();
}

void RaftGroupDeletedError::SharedDtor() {
}

void RaftGroupDeletedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RaftGroupDeletedError& RaftGroupDeletedError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

RaftGroupDeletedError* RaftGroupDeletedError::New(::google::protobuf::Arena* arena) const {
  RaftGroupDeletedError* n = new RaftGroupDeletedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RaftGroupDeletedError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.RaftGroupDeletedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RaftGroupDeletedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RaftGroupDeletedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RaftGroupDeletedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RaftGroupDeletedError)
  return false;
#undef DO_
}

void RaftGroupDeletedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RaftGroupDeletedError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RaftGroupDeletedError)
}

size_t RaftGroupDeletedError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.RaftGroupDeletedError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RaftGroupDeletedError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RaftGroupDeletedError*>(&from));
}

void RaftGroupDeletedError::MergeFrom(const RaftGroupDeletedError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.RaftGroupDeletedError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void RaftGroupDeletedError::CopyFrom(const RaftGroupDeletedError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.RaftGroupDeletedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RaftGroupDeletedError::IsInitialized() const {
  return true;
}

void RaftGroupDeletedError::Swap(RaftGroupDeletedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RaftGroupDeletedError::InternalSwap(RaftGroupDeletedError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string RaftGroupDeletedError::GetTypeName() const {
  return "cockroach.roachpb.RaftGroupDeletedError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RaftGroupDeletedError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReplicaCorruptionError::kErrorMsgFieldNumber;
const int ReplicaCorruptionError::kProcessedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReplicaCorruptionError::ReplicaCorruptionError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ReplicaCorruptionError)
}
ReplicaCorruptionError::ReplicaCorruptionError(const ReplicaCorruptionError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  error_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_error_msg()) {
    error_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_msg_);
  }
  processed_ = from.processed_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ReplicaCorruptionError)
}

void ReplicaCorruptionError::SharedCtor() {
  _cached_size_ = 0;
  error_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  processed_ = false;
}

ReplicaCorruptionError::~ReplicaCorruptionError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ReplicaCorruptionError)
  SharedDtor();
}

void ReplicaCorruptionError::SharedDtor() {
  error_msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ReplicaCorruptionError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReplicaCorruptionError& ReplicaCorruptionError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ReplicaCorruptionError* ReplicaCorruptionError::New(::google::protobuf::Arena* arena) const {
  ReplicaCorruptionError* n = new ReplicaCorruptionError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReplicaCorruptionError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ReplicaCorruptionError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_error_msg()) {
    GOOGLE_DCHECK(!error_msg_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*error_msg_.UnsafeRawStringPointer())->clear();
  }
  processed_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ReplicaCorruptionError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ReplicaCorruptionError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_processed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &processed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ReplicaCorruptionError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ReplicaCorruptionError)
  return false;
#undef DO_
}

void ReplicaCorruptionError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ReplicaCorruptionError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->error_msg(), output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->processed(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ReplicaCorruptionError)
}

size_t ReplicaCorruptionError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ReplicaCorruptionError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    if (has_error_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_msg());
    }

    if (has_processed()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicaCorruptionError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReplicaCorruptionError*>(&from));
}

void ReplicaCorruptionError::MergeFrom(const ReplicaCorruptionError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ReplicaCorruptionError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_error_msg();
      error_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_msg_);
    }
    if (cached_has_bits & 0x00000002u) {
      processed_ = from.processed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ReplicaCorruptionError::CopyFrom(const ReplicaCorruptionError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ReplicaCorruptionError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicaCorruptionError::IsInitialized() const {
  return true;
}

void ReplicaCorruptionError::Swap(ReplicaCorruptionError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReplicaCorruptionError::InternalSwap(ReplicaCorruptionError* other) {
  using std::swap;
  error_msg_.Swap(&other->error_msg_);
  swap(processed_, other->processed_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ReplicaCorruptionError::GetTypeName() const {
  return "cockroach.roachpb.ReplicaCorruptionError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReplicaCorruptionError

bool ReplicaCorruptionError::has_error_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReplicaCorruptionError::set_has_error_msg() {
  _has_bits_[0] |= 0x00000001u;
}
void ReplicaCorruptionError::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReplicaCorruptionError::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_msg();
}
const ::std::string& ReplicaCorruptionError::error_msg() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReplicaCorruptionError.error_msg)
  return error_msg_.GetNoArena();
}
void ReplicaCorruptionError::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ReplicaCorruptionError.error_msg)
}
#if LANG_CXX11
void ReplicaCorruptionError::set_error_msg(::std::string&& value) {
  set_has_error_msg();
  error_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.ReplicaCorruptionError.error_msg)
}
#endif
void ReplicaCorruptionError::set_error_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.ReplicaCorruptionError.error_msg)
}
void ReplicaCorruptionError::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.ReplicaCorruptionError.error_msg)
}
::std::string* ReplicaCorruptionError::mutable_error_msg() {
  set_has_error_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReplicaCorruptionError.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ReplicaCorruptionError::release_error_msg() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ReplicaCorruptionError.error_msg)
  clear_has_error_msg();
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ReplicaCorruptionError::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    set_has_error_msg();
  } else {
    clear_has_error_msg();
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReplicaCorruptionError.error_msg)
}

bool ReplicaCorruptionError::has_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReplicaCorruptionError::set_has_processed() {
  _has_bits_[0] |= 0x00000002u;
}
void ReplicaCorruptionError::clear_has_processed() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReplicaCorruptionError::clear_processed() {
  processed_ = false;
  clear_has_processed();
}
bool ReplicaCorruptionError::processed() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReplicaCorruptionError.processed)
  return processed_;
}
void ReplicaCorruptionError::set_processed(bool value) {
  set_has_processed();
  processed_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ReplicaCorruptionError.processed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReplicaTooOldError::kReplicaIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReplicaTooOldError::ReplicaTooOldError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ReplicaTooOldError)
}
ReplicaTooOldError::ReplicaTooOldError(const ReplicaTooOldError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  replica_id_ = from.replica_id_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ReplicaTooOldError)
}

void ReplicaTooOldError::SharedCtor() {
  _cached_size_ = 0;
  replica_id_ = 0;
}

ReplicaTooOldError::~ReplicaTooOldError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ReplicaTooOldError)
  SharedDtor();
}

void ReplicaTooOldError::SharedDtor() {
}

void ReplicaTooOldError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReplicaTooOldError& ReplicaTooOldError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ReplicaTooOldError* ReplicaTooOldError::New(::google::protobuf::Arena* arena) const {
  ReplicaTooOldError* n = new ReplicaTooOldError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReplicaTooOldError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ReplicaTooOldError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  replica_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ReplicaTooOldError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ReplicaTooOldError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_replica_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &replica_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ReplicaTooOldError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ReplicaTooOldError)
  return false;
#undef DO_
}

void ReplicaTooOldError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ReplicaTooOldError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->replica_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ReplicaTooOldError)
}

size_t ReplicaTooOldError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ReplicaTooOldError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_replica_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->replica_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplicaTooOldError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReplicaTooOldError*>(&from));
}

void ReplicaTooOldError::MergeFrom(const ReplicaTooOldError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ReplicaTooOldError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_replica_id()) {
    set_replica_id(from.replica_id());
  }
}

void ReplicaTooOldError::CopyFrom(const ReplicaTooOldError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ReplicaTooOldError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicaTooOldError::IsInitialized() const {
  return true;
}

void ReplicaTooOldError::Swap(ReplicaTooOldError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReplicaTooOldError::InternalSwap(ReplicaTooOldError* other) {
  using std::swap;
  swap(replica_id_, other->replica_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ReplicaTooOldError::GetTypeName() const {
  return "cockroach.roachpb.ReplicaTooOldError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReplicaTooOldError

bool ReplicaTooOldError::has_replica_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReplicaTooOldError::set_has_replica_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ReplicaTooOldError::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReplicaTooOldError::clear_replica_id() {
  replica_id_ = 0;
  clear_has_replica_id();
}
::google::protobuf::int32 ReplicaTooOldError::replica_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReplicaTooOldError.replica_id)
  return replica_id_;
}
void ReplicaTooOldError::set_replica_id(::google::protobuf::int32 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ReplicaTooOldError.replica_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StoreNotFoundError::kStoreIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StoreNotFoundError::StoreNotFoundError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.StoreNotFoundError)
}
StoreNotFoundError::StoreNotFoundError(const StoreNotFoundError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  store_id_ = from.store_id_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.StoreNotFoundError)
}

void StoreNotFoundError::SharedCtor() {
  _cached_size_ = 0;
  store_id_ = GOOGLE_LONGLONG(0);
}

StoreNotFoundError::~StoreNotFoundError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.StoreNotFoundError)
  SharedDtor();
}

void StoreNotFoundError::SharedDtor() {
}

void StoreNotFoundError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoreNotFoundError& StoreNotFoundError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

StoreNotFoundError* StoreNotFoundError::New(::google::protobuf::Arena* arena) const {
  StoreNotFoundError* n = new StoreNotFoundError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StoreNotFoundError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.StoreNotFoundError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  store_id_ = GOOGLE_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StoreNotFoundError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.StoreNotFoundError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_store_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &store_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.StoreNotFoundError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.StoreNotFoundError)
  return false;
#undef DO_
}

void StoreNotFoundError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.StoreNotFoundError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->store_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.StoreNotFoundError)
}

size_t StoreNotFoundError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.StoreNotFoundError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_store_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->store_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoreNotFoundError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoreNotFoundError*>(&from));
}

void StoreNotFoundError::MergeFrom(const StoreNotFoundError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.StoreNotFoundError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_store_id()) {
    set_store_id(from.store_id());
  }
}

void StoreNotFoundError::CopyFrom(const StoreNotFoundError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.StoreNotFoundError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreNotFoundError::IsInitialized() const {
  return true;
}

void StoreNotFoundError::Swap(StoreNotFoundError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StoreNotFoundError::InternalSwap(StoreNotFoundError* other) {
  using std::swap;
  swap(store_id_, other->store_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string StoreNotFoundError::GetTypeName() const {
  return "cockroach.roachpb.StoreNotFoundError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StoreNotFoundError

bool StoreNotFoundError::has_store_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StoreNotFoundError::set_has_store_id() {
  _has_bits_[0] |= 0x00000001u;
}
void StoreNotFoundError::clear_has_store_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void StoreNotFoundError::clear_store_id() {
  store_id_ = GOOGLE_LONGLONG(0);
  clear_has_store_id();
}
::google::protobuf::int64 StoreNotFoundError::store_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.StoreNotFoundError.store_id)
  return store_id_;
}
void StoreNotFoundError::set_store_id(::google::protobuf::int64 value) {
  set_has_store_id();
  store_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.StoreNotFoundError.store_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnhandledRetryableError::kPErrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnhandledRetryableError::UnhandledRetryableError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.UnhandledRetryableError)
}
UnhandledRetryableError::UnhandledRetryableError(const UnhandledRetryableError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_perr()) {
    perr_ = new ::cockroach::roachpb::Error(*from.perr_);
  } else {
    perr_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.UnhandledRetryableError)
}

void UnhandledRetryableError::SharedCtor() {
  _cached_size_ = 0;
  perr_ = NULL;
}

UnhandledRetryableError::~UnhandledRetryableError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.UnhandledRetryableError)
  SharedDtor();
}

void UnhandledRetryableError::SharedDtor() {
  if (this != internal_default_instance()) delete perr_;
}

void UnhandledRetryableError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnhandledRetryableError& UnhandledRetryableError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnhandledRetryableError* UnhandledRetryableError::New(::google::protobuf::Arena* arena) const {
  UnhandledRetryableError* n = new UnhandledRetryableError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnhandledRetryableError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.UnhandledRetryableError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (has_perr()) {
    GOOGLE_DCHECK(perr_ != NULL);
    perr_->::cockroach::roachpb::Error::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UnhandledRetryableError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.UnhandledRetryableError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_perr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.UnhandledRetryableError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.UnhandledRetryableError)
  return false;
#undef DO_
}

void UnhandledRetryableError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.UnhandledRetryableError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->perr_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.UnhandledRetryableError)
}

size_t UnhandledRetryableError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.UnhandledRetryableError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_perr()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->perr_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnhandledRetryableError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnhandledRetryableError*>(&from));
}

void UnhandledRetryableError::MergeFrom(const UnhandledRetryableError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.UnhandledRetryableError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_perr()) {
    mutable_perr()->::cockroach::roachpb::Error::MergeFrom(from.perr());
  }
}

void UnhandledRetryableError::CopyFrom(const UnhandledRetryableError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.UnhandledRetryableError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnhandledRetryableError::IsInitialized() const {
  return true;
}

void UnhandledRetryableError::Swap(UnhandledRetryableError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnhandledRetryableError::InternalSwap(UnhandledRetryableError* other) {
  using std::swap;
  swap(perr_, other->perr_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string UnhandledRetryableError::GetTypeName() const {
  return "cockroach.roachpb.UnhandledRetryableError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnhandledRetryableError

bool UnhandledRetryableError::has_perr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UnhandledRetryableError::set_has_perr() {
  _has_bits_[0] |= 0x00000001u;
}
void UnhandledRetryableError::clear_has_perr() {
  _has_bits_[0] &= ~0x00000001u;
}
void UnhandledRetryableError::clear_perr() {
  if (perr_ != NULL) perr_->::cockroach::roachpb::Error::Clear();
  clear_has_perr();
}
const ::cockroach::roachpb::Error& UnhandledRetryableError::perr() const {
  const ::cockroach::roachpb::Error* p = perr_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.UnhandledRetryableError.pErr)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Error*>(
      &::cockroach::roachpb::_Error_default_instance_);
}
::cockroach::roachpb::Error* UnhandledRetryableError::mutable_perr() {
  set_has_perr();
  if (perr_ == NULL) {
    perr_ = new ::cockroach::roachpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.UnhandledRetryableError.pErr)
  return perr_;
}
::cockroach::roachpb::Error* UnhandledRetryableError::release_perr() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.UnhandledRetryableError.pErr)
  clear_has_perr();
  ::cockroach::roachpb::Error* temp = perr_;
  perr_ = NULL;
  return temp;
}
void UnhandledRetryableError::set_allocated_perr(::cockroach::roachpb::Error* perr) {
  delete perr_;
  perr_ = perr;
  if (perr) {
    set_has_perr();
  } else {
    clear_has_perr();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.UnhandledRetryableError.pErr)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HandledRetryableTxnError::kMsgFieldNumber;
const int HandledRetryableTxnError::kTxnIdFieldNumber;
const int HandledRetryableTxnError::kTransactionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HandledRetryableTxnError::HandledRetryableTxnError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.HandledRetryableTxnError)
}
HandledRetryableTxnError::HandledRetryableTxnError(const HandledRetryableTxnError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_msg()) {
    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
  txn_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_txn_id()) {
    txn_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.txn_id_);
  }
  if (from.has_transaction()) {
    transaction_ = new ::cockroach::roachpb::Transaction(*from.transaction_);
  } else {
    transaction_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.HandledRetryableTxnError)
}

void HandledRetryableTxnError::SharedCtor() {
  _cached_size_ = 0;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  txn_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  transaction_ = NULL;
}

HandledRetryableTxnError::~HandledRetryableTxnError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.HandledRetryableTxnError)
  SharedDtor();
}

void HandledRetryableTxnError::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  txn_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete transaction_;
}

void HandledRetryableTxnError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HandledRetryableTxnError& HandledRetryableTxnError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

HandledRetryableTxnError* HandledRetryableTxnError::New(::google::protobuf::Arena* arena) const {
  HandledRetryableTxnError* n = new HandledRetryableTxnError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HandledRetryableTxnError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.HandledRetryableTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!msg_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*msg_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!txn_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*txn_id_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(transaction_ != NULL);
      transaction_->::cockroach::roachpb::Transaction::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool HandledRetryableTxnError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.HandledRetryableTxnError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_txn_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.HandledRetryableTxnError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.HandledRetryableTxnError)
  return false;
#undef DO_
}

void HandledRetryableTxnError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.HandledRetryableTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->msg(), output);
  }

  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->txn_id(), output);
  }

  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->transaction_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.HandledRetryableTxnError)
}

size_t HandledRetryableTxnError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.HandledRetryableTxnError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 7u) {
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

    if (has_txn_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->txn_id());
    }

    if (has_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HandledRetryableTxnError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HandledRetryableTxnError*>(&from));
}

void HandledRetryableTxnError::MergeFrom(const HandledRetryableTxnError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.HandledRetryableTxnError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_msg();
      msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_txn_id();
      txn_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.txn_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_transaction()->::cockroach::roachpb::Transaction::MergeFrom(from.transaction());
    }
  }
}

void HandledRetryableTxnError::CopyFrom(const HandledRetryableTxnError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.HandledRetryableTxnError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandledRetryableTxnError::IsInitialized() const {
  return true;
}

void HandledRetryableTxnError::Swap(HandledRetryableTxnError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HandledRetryableTxnError::InternalSwap(HandledRetryableTxnError* other) {
  using std::swap;
  msg_.Swap(&other->msg_);
  txn_id_.Swap(&other->txn_id_);
  swap(transaction_, other->transaction_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string HandledRetryableTxnError::GetTypeName() const {
  return "cockroach.roachpb.HandledRetryableTxnError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HandledRetryableTxnError

bool HandledRetryableTxnError::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HandledRetryableTxnError::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
void HandledRetryableTxnError::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
void HandledRetryableTxnError::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
const ::std::string& HandledRetryableTxnError::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HandledRetryableTxnError.msg)
  return msg_.GetNoArena();
}
void HandledRetryableTxnError::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.HandledRetryableTxnError.msg)
}
#if LANG_CXX11
void HandledRetryableTxnError::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.HandledRetryableTxnError.msg)
}
#endif
void HandledRetryableTxnError::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.HandledRetryableTxnError.msg)
}
void HandledRetryableTxnError::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.HandledRetryableTxnError.msg)
}
::std::string* HandledRetryableTxnError::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HandledRetryableTxnError.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* HandledRetryableTxnError::release_msg() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.HandledRetryableTxnError.msg)
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void HandledRetryableTxnError::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HandledRetryableTxnError.msg)
}

bool HandledRetryableTxnError::has_txn_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HandledRetryableTxnError::set_has_txn_id() {
  _has_bits_[0] |= 0x00000002u;
}
void HandledRetryableTxnError::clear_has_txn_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void HandledRetryableTxnError::clear_txn_id() {
  txn_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txn_id();
}
const ::std::string& HandledRetryableTxnError::txn_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HandledRetryableTxnError.txn_id)
  return txn_id_.GetNoArena();
}
void HandledRetryableTxnError::set_txn_id(const ::std::string& value) {
  set_has_txn_id();
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.HandledRetryableTxnError.txn_id)
}
#if LANG_CXX11
void HandledRetryableTxnError::set_txn_id(::std::string&& value) {
  set_has_txn_id();
  txn_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.HandledRetryableTxnError.txn_id)
}
#endif
void HandledRetryableTxnError::set_txn_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_txn_id();
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.HandledRetryableTxnError.txn_id)
}
void HandledRetryableTxnError::set_txn_id(const void* value, size_t size) {
  set_has_txn_id();
  txn_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.HandledRetryableTxnError.txn_id)
}
::std::string* HandledRetryableTxnError::mutable_txn_id() {
  set_has_txn_id();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HandledRetryableTxnError.txn_id)
  return txn_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* HandledRetryableTxnError::release_txn_id() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.HandledRetryableTxnError.txn_id)
  clear_has_txn_id();
  return txn_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void HandledRetryableTxnError::set_allocated_txn_id(::std::string* txn_id) {
  if (txn_id != NULL) {
    set_has_txn_id();
  } else {
    clear_has_txn_id();
  }
  txn_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txn_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HandledRetryableTxnError.txn_id)
}

bool HandledRetryableTxnError::has_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void HandledRetryableTxnError::set_has_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
void HandledRetryableTxnError::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
void HandledRetryableTxnError::clear_transaction() {
  if (transaction_ != NULL) transaction_->::cockroach::roachpb::Transaction::Clear();
  clear_has_transaction();
}
const ::cockroach::roachpb::Transaction& HandledRetryableTxnError::transaction() const {
  const ::cockroach::roachpb::Transaction* p = transaction_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HandledRetryableTxnError.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Transaction*>(
      &::cockroach::roachpb::_Transaction_default_instance_);
}
::cockroach::roachpb::Transaction* HandledRetryableTxnError::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) {
    transaction_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HandledRetryableTxnError.transaction)
  return transaction_;
}
::cockroach::roachpb::Transaction* HandledRetryableTxnError::release_transaction() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.HandledRetryableTxnError.transaction)
  clear_has_transaction();
  ::cockroach::roachpb::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
void HandledRetryableTxnError::set_allocated_transaction(::cockroach::roachpb::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HandledRetryableTxnError.transaction)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UntrackedTxnError::UntrackedTxnError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.UntrackedTxnError)
}
UntrackedTxnError::UntrackedTxnError(const UntrackedTxnError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.UntrackedTxnError)
}

void UntrackedTxnError::SharedCtor() {
  _cached_size_ = 0;
}

UntrackedTxnError::~UntrackedTxnError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.UntrackedTxnError)
  SharedDtor();
}

void UntrackedTxnError::SharedDtor() {
}

void UntrackedTxnError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UntrackedTxnError& UntrackedTxnError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

UntrackedTxnError* UntrackedTxnError::New(::google::protobuf::Arena* arena) const {
  UntrackedTxnError* n = new UntrackedTxnError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UntrackedTxnError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.UntrackedTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UntrackedTxnError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.UntrackedTxnError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.UntrackedTxnError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.UntrackedTxnError)
  return false;
#undef DO_
}

void UntrackedTxnError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.UntrackedTxnError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.UntrackedTxnError)
}

size_t UntrackedTxnError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.UntrackedTxnError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UntrackedTxnError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UntrackedTxnError*>(&from));
}

void UntrackedTxnError::MergeFrom(const UntrackedTxnError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.UntrackedTxnError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void UntrackedTxnError::CopyFrom(const UntrackedTxnError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.UntrackedTxnError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UntrackedTxnError::IsInitialized() const {
  return true;
}

void UntrackedTxnError::Swap(UntrackedTxnError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UntrackedTxnError::InternalSwap(UntrackedTxnError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string UntrackedTxnError::GetTypeName() const {
  return "cockroach.roachpb.UntrackedTxnError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UntrackedTxnError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxnPrevAttemptError::TxnPrevAttemptError()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TxnPrevAttemptError)
}
TxnPrevAttemptError::TxnPrevAttemptError(const TxnPrevAttemptError& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TxnPrevAttemptError)
}

void TxnPrevAttemptError::SharedCtor() {
  _cached_size_ = 0;
}

TxnPrevAttemptError::~TxnPrevAttemptError() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TxnPrevAttemptError)
  SharedDtor();
}

void TxnPrevAttemptError::SharedDtor() {
}

void TxnPrevAttemptError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TxnPrevAttemptError& TxnPrevAttemptError::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

TxnPrevAttemptError* TxnPrevAttemptError::New(::google::protobuf::Arena* arena) const {
  TxnPrevAttemptError* n = new TxnPrevAttemptError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TxnPrevAttemptError::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.TxnPrevAttemptError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TxnPrevAttemptError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TxnPrevAttemptError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TxnPrevAttemptError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TxnPrevAttemptError)
  return false;
#undef DO_
}

void TxnPrevAttemptError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TxnPrevAttemptError)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TxnPrevAttemptError)
}

size_t TxnPrevAttemptError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.TxnPrevAttemptError)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxnPrevAttemptError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TxnPrevAttemptError*>(&from));
}

void TxnPrevAttemptError::MergeFrom(const TxnPrevAttemptError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.TxnPrevAttemptError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void TxnPrevAttemptError::CopyFrom(const TxnPrevAttemptError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.TxnPrevAttemptError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxnPrevAttemptError::IsInitialized() const {
  return true;
}

void TxnPrevAttemptError::Swap(TxnPrevAttemptError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxnPrevAttemptError::InternalSwap(TxnPrevAttemptError* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string TxnPrevAttemptError::GetTypeName() const {
  return "cockroach.roachpb.TxnPrevAttemptError";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TxnPrevAttemptError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ErrorDetail::kNotLeaseHolderFieldNumber;
const int ErrorDetail::kRangeNotFoundFieldNumber;
const int ErrorDetail::kRangeKeyMismatchFieldNumber;
const int ErrorDetail::kReadWithinUncertaintyIntervalFieldNumber;
const int ErrorDetail::kTransactionAbortedFieldNumber;
const int ErrorDetail::kTransactionPushFieldNumber;
const int ErrorDetail::kTransactionRetryFieldNumber;
const int ErrorDetail::kTransactionReplayFieldNumber;
const int ErrorDetail::kTransactionStatusFieldNumber;
const int ErrorDetail::kWriteIntentFieldNumber;
const int ErrorDetail::kWriteTooOldFieldNumber;
const int ErrorDetail::kOpRequiresTxnFieldNumber;
const int ErrorDetail::kConditionFailedFieldNumber;
const int ErrorDetail::kLeaseRejectedFieldNumber;
const int ErrorDetail::kNodeUnavailableFieldNumber;
const int ErrorDetail::kSendFieldNumber;
const int ErrorDetail::kRaftGroupDeletedFieldNumber;
const int ErrorDetail::kReplicaCorruptionFieldNumber;
const int ErrorDetail::kReplicaTooOldFieldNumber;
const int ErrorDetail::kAmbiguousResultFieldNumber;
const int ErrorDetail::kStoreNotFoundFieldNumber;
const int ErrorDetail::kHandledRetryableTxnErrorFieldNumber;
const int ErrorDetail::kUntrackedTxnErrorFieldNumber;
const int ErrorDetail::kTxnAbortedAsyncErrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ErrorDetail::ErrorDetail()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ErrorDetail)
}
ErrorDetail::ErrorDetail(const ErrorDetail& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_not_lease_holder()) {
    not_lease_holder_ = new ::cockroach::roachpb::NotLeaseHolderError(*from.not_lease_holder_);
  } else {
    not_lease_holder_ = NULL;
  }
  if (from.has_range_not_found()) {
    range_not_found_ = new ::cockroach::roachpb::RangeNotFoundError(*from.range_not_found_);
  } else {
    range_not_found_ = NULL;
  }
  if (from.has_range_key_mismatch()) {
    range_key_mismatch_ = new ::cockroach::roachpb::RangeKeyMismatchError(*from.range_key_mismatch_);
  } else {
    range_key_mismatch_ = NULL;
  }
  if (from.has_read_within_uncertainty_interval()) {
    read_within_uncertainty_interval_ = new ::cockroach::roachpb::ReadWithinUncertaintyIntervalError(*from.read_within_uncertainty_interval_);
  } else {
    read_within_uncertainty_interval_ = NULL;
  }
  if (from.has_transaction_aborted()) {
    transaction_aborted_ = new ::cockroach::roachpb::TransactionAbortedError(*from.transaction_aborted_);
  } else {
    transaction_aborted_ = NULL;
  }
  if (from.has_transaction_push()) {
    transaction_push_ = new ::cockroach::roachpb::TransactionPushError(*from.transaction_push_);
  } else {
    transaction_push_ = NULL;
  }
  if (from.has_transaction_retry()) {
    transaction_retry_ = new ::cockroach::roachpb::TransactionRetryError(*from.transaction_retry_);
  } else {
    transaction_retry_ = NULL;
  }
  if (from.has_transaction_status()) {
    transaction_status_ = new ::cockroach::roachpb::TransactionStatusError(*from.transaction_status_);
  } else {
    transaction_status_ = NULL;
  }
  if (from.has_write_intent()) {
    write_intent_ = new ::cockroach::roachpb::WriteIntentError(*from.write_intent_);
  } else {
    write_intent_ = NULL;
  }
  if (from.has_write_too_old()) {
    write_too_old_ = new ::cockroach::roachpb::WriteTooOldError(*from.write_too_old_);
  } else {
    write_too_old_ = NULL;
  }
  if (from.has_op_requires_txn()) {
    op_requires_txn_ = new ::cockroach::roachpb::OpRequiresTxnError(*from.op_requires_txn_);
  } else {
    op_requires_txn_ = NULL;
  }
  if (from.has_condition_failed()) {
    condition_failed_ = new ::cockroach::roachpb::ConditionFailedError(*from.condition_failed_);
  } else {
    condition_failed_ = NULL;
  }
  if (from.has_lease_rejected()) {
    lease_rejected_ = new ::cockroach::roachpb::LeaseRejectedError(*from.lease_rejected_);
  } else {
    lease_rejected_ = NULL;
  }
  if (from.has_node_unavailable()) {
    node_unavailable_ = new ::cockroach::roachpb::NodeUnavailableError(*from.node_unavailable_);
  } else {
    node_unavailable_ = NULL;
  }
  if (from.has_send()) {
    send_ = new ::cockroach::roachpb::SendError(*from.send_);
  } else {
    send_ = NULL;
  }
  if (from.has_raft_group_deleted()) {
    raft_group_deleted_ = new ::cockroach::roachpb::RaftGroupDeletedError(*from.raft_group_deleted_);
  } else {
    raft_group_deleted_ = NULL;
  }
  if (from.has_replica_corruption()) {
    replica_corruption_ = new ::cockroach::roachpb::ReplicaCorruptionError(*from.replica_corruption_);
  } else {
    replica_corruption_ = NULL;
  }
  if (from.has_replica_too_old()) {
    replica_too_old_ = new ::cockroach::roachpb::ReplicaTooOldError(*from.replica_too_old_);
  } else {
    replica_too_old_ = NULL;
  }
  if (from.has_transaction_replay()) {
    transaction_replay_ = new ::cockroach::roachpb::TransactionReplayError(*from.transaction_replay_);
  } else {
    transaction_replay_ = NULL;
  }
  if (from.has_ambiguous_result()) {
    ambiguous_result_ = new ::cockroach::roachpb::AmbiguousResultError(*from.ambiguous_result_);
  } else {
    ambiguous_result_ = NULL;
  }
  if (from.has_store_not_found()) {
    store_not_found_ = new ::cockroach::roachpb::StoreNotFoundError(*from.store_not_found_);
  } else {
    store_not_found_ = NULL;
  }
  if (from.has_handled_retryable_txn_error()) {
    handled_retryable_txn_error_ = new ::cockroach::roachpb::HandledRetryableTxnError(*from.handled_retryable_txn_error_);
  } else {
    handled_retryable_txn_error_ = NULL;
  }
  if (from.has_untracked_txn_error()) {
    untracked_txn_error_ = new ::cockroach::roachpb::UntrackedTxnError(*from.untracked_txn_error_);
  } else {
    untracked_txn_error_ = NULL;
  }
  if (from.has_txn_aborted_async_err()) {
    txn_aborted_async_err_ = new ::cockroach::roachpb::TxnPrevAttemptError(*from.txn_aborted_async_err_);
  } else {
    txn_aborted_async_err_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ErrorDetail)
}

void ErrorDetail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&not_lease_holder_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&txn_aborted_async_err_) -
      reinterpret_cast<char*>(&not_lease_holder_)) + sizeof(txn_aborted_async_err_));
}

ErrorDetail::~ErrorDetail() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ErrorDetail)
  SharedDtor();
}

void ErrorDetail::SharedDtor() {
  if (this != internal_default_instance()) delete not_lease_holder_;
  if (this != internal_default_instance()) delete range_not_found_;
  if (this != internal_default_instance()) delete range_key_mismatch_;
  if (this != internal_default_instance()) delete read_within_uncertainty_interval_;
  if (this != internal_default_instance()) delete transaction_aborted_;
  if (this != internal_default_instance()) delete transaction_push_;
  if (this != internal_default_instance()) delete transaction_retry_;
  if (this != internal_default_instance()) delete transaction_status_;
  if (this != internal_default_instance()) delete write_intent_;
  if (this != internal_default_instance()) delete write_too_old_;
  if (this != internal_default_instance()) delete op_requires_txn_;
  if (this != internal_default_instance()) delete condition_failed_;
  if (this != internal_default_instance()) delete lease_rejected_;
  if (this != internal_default_instance()) delete node_unavailable_;
  if (this != internal_default_instance()) delete send_;
  if (this != internal_default_instance()) delete raft_group_deleted_;
  if (this != internal_default_instance()) delete replica_corruption_;
  if (this != internal_default_instance()) delete replica_too_old_;
  if (this != internal_default_instance()) delete transaction_replay_;
  if (this != internal_default_instance()) delete ambiguous_result_;
  if (this != internal_default_instance()) delete store_not_found_;
  if (this != internal_default_instance()) delete handled_retryable_txn_error_;
  if (this != internal_default_instance()) delete untracked_txn_error_;
  if (this != internal_default_instance()) delete txn_aborted_async_err_;
}

void ErrorDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ErrorDetail& ErrorDetail::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ErrorDetail* ErrorDetail::New(::google::protobuf::Arena* arena) const {
  ErrorDetail* n = new ErrorDetail;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ErrorDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ErrorDetail)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(not_lease_holder_ != NULL);
      not_lease_holder_->::cockroach::roachpb::NotLeaseHolderError::Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(range_not_found_ != NULL);
      range_not_found_->::cockroach::roachpb::RangeNotFoundError::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(range_key_mismatch_ != NULL);
      range_key_mismatch_->::cockroach::roachpb::RangeKeyMismatchError::Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(read_within_uncertainty_interval_ != NULL);
      read_within_uncertainty_interval_->::cockroach::roachpb::ReadWithinUncertaintyIntervalError::Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(transaction_aborted_ != NULL);
      transaction_aborted_->::cockroach::roachpb::TransactionAbortedError::Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(transaction_push_ != NULL);
      transaction_push_->::cockroach::roachpb::TransactionPushError::Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(transaction_retry_ != NULL);
      transaction_retry_->::cockroach::roachpb::TransactionRetryError::Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(transaction_status_ != NULL);
      transaction_status_->::cockroach::roachpb::TransactionStatusError::Clear();
    }
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(write_intent_ != NULL);
      write_intent_->::cockroach::roachpb::WriteIntentError::Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(write_too_old_ != NULL);
      write_too_old_->::cockroach::roachpb::WriteTooOldError::Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(op_requires_txn_ != NULL);
      op_requires_txn_->::cockroach::roachpb::OpRequiresTxnError::Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(condition_failed_ != NULL);
      condition_failed_->::cockroach::roachpb::ConditionFailedError::Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(lease_rejected_ != NULL);
      lease_rejected_->::cockroach::roachpb::LeaseRejectedError::Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(node_unavailable_ != NULL);
      node_unavailable_->::cockroach::roachpb::NodeUnavailableError::Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(send_ != NULL);
      send_->::cockroach::roachpb::SendError::Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(raft_group_deleted_ != NULL);
      raft_group_deleted_->::cockroach::roachpb::RaftGroupDeletedError::Clear();
    }
  }
  if (cached_has_bits & 16711680u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(replica_corruption_ != NULL);
      replica_corruption_->::cockroach::roachpb::ReplicaCorruptionError::Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(replica_too_old_ != NULL);
      replica_too_old_->::cockroach::roachpb::ReplicaTooOldError::Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(transaction_replay_ != NULL);
      transaction_replay_->::cockroach::roachpb::TransactionReplayError::Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(ambiguous_result_ != NULL);
      ambiguous_result_->::cockroach::roachpb::AmbiguousResultError::Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(store_not_found_ != NULL);
      store_not_found_->::cockroach::roachpb::StoreNotFoundError::Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(handled_retryable_txn_error_ != NULL);
      handled_retryable_txn_error_->::cockroach::roachpb::HandledRetryableTxnError::Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(untracked_txn_error_ != NULL);
      untracked_txn_error_->::cockroach::roachpb::UntrackedTxnError::Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(txn_aborted_async_err_ != NULL);
      txn_aborted_async_err_->::cockroach::roachpb::TxnPrevAttemptError::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ErrorDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ErrorDetail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.NotLeaseHolderError not_lease_holder = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_not_lease_holder()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.RangeNotFoundError range_not_found = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_not_found()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.RangeKeyMismatchError range_key_mismatch = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_key_mismatch()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_read_within_uncertainty_interval()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TransactionAbortedError transaction_aborted = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_aborted()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TransactionPushError transaction_push = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_push()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TransactionRetryError transaction_retry = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_retry()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TransactionStatusError transaction_status = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.WriteIntentError write_intent = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_intent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.WriteTooOldError write_too_old = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_too_old()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.OpRequiresTxnError op_requires_txn = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op_requires_txn()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ConditionFailedError condition_failed = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_condition_failed()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.LeaseRejectedError lease_rejected = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u /* 106 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease_rejected()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.NodeUnavailableError node_unavailable = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u /* 114 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node_unavailable()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.SendError send = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(122u /* 122 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_send()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.RaftGroupDeletedError raft_group_deleted = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(130u /* 130 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_raft_group_deleted()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ReplicaCorruptionError replica_corruption = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(138u /* 138 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica_corruption()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ReplicaTooOldError replica_too_old = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(146u /* 146 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica_too_old()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TransactionReplayError transaction_replay = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(178u /* 178 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_replay()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.AmbiguousResultError ambiguous_result = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(210u /* 210 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ambiguous_result()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.StoreNotFoundError store_not_found = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(218u /* 218 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_store_not_found()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.HandledRetryableTxnError handled_retryable_txn_error = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(226u /* 226 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_handled_retryable_txn_error()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.UntrackedTxnError untracked_txn_error = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(234u /* 234 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_untracked_txn_error()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.TxnPrevAttemptError txn_aborted_async_err = 30;
      case 30: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(242u /* 242 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn_aborted_async_err()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ErrorDetail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ErrorDetail)
  return false;
#undef DO_
}

void ErrorDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ErrorDetail)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .cockroach.roachpb.NotLeaseHolderError not_lease_holder = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->not_lease_holder_, output);
  }

  // optional .cockroach.roachpb.RangeNotFoundError range_not_found = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->range_not_found_, output);
  }

  // optional .cockroach.roachpb.RangeKeyMismatchError range_key_mismatch = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->range_key_mismatch_, output);
  }

  // optional .cockroach.roachpb.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->read_within_uncertainty_interval_, output);
  }

  // optional .cockroach.roachpb.TransactionAbortedError transaction_aborted = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->transaction_aborted_, output);
  }

  // optional .cockroach.roachpb.TransactionPushError transaction_push = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->transaction_push_, output);
  }

  // optional .cockroach.roachpb.TransactionRetryError transaction_retry = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->transaction_retry_, output);
  }

  // optional .cockroach.roachpb.TransactionStatusError transaction_status = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->transaction_status_, output);
  }

  // optional .cockroach.roachpb.WriteIntentError write_intent = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, *this->write_intent_, output);
  }

  // optional .cockroach.roachpb.WriteTooOldError write_too_old = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->write_too_old_, output);
  }

  // optional .cockroach.roachpb.OpRequiresTxnError op_requires_txn = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, *this->op_requires_txn_, output);
  }

  // optional .cockroach.roachpb.ConditionFailedError condition_failed = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      12, *this->condition_failed_, output);
  }

  // optional .cockroach.roachpb.LeaseRejectedError lease_rejected = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, *this->lease_rejected_, output);
  }

  // optional .cockroach.roachpb.NodeUnavailableError node_unavailable = 14;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, *this->node_unavailable_, output);
  }

  // optional .cockroach.roachpb.SendError send = 15;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, *this->send_, output);
  }

  // optional .cockroach.roachpb.RaftGroupDeletedError raft_group_deleted = 16;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, *this->raft_group_deleted_, output);
  }

  // optional .cockroach.roachpb.ReplicaCorruptionError replica_corruption = 17;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17, *this->replica_corruption_, output);
  }

  // optional .cockroach.roachpb.ReplicaTooOldError replica_too_old = 18;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      18, *this->replica_too_old_, output);
  }

  // optional .cockroach.roachpb.TransactionReplayError transaction_replay = 22;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      22, *this->transaction_replay_, output);
  }

  // optional .cockroach.roachpb.AmbiguousResultError ambiguous_result = 26;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      26, *this->ambiguous_result_, output);
  }

  // optional .cockroach.roachpb.StoreNotFoundError store_not_found = 27;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      27, *this->store_not_found_, output);
  }

  // optional .cockroach.roachpb.HandledRetryableTxnError handled_retryable_txn_error = 28;
  if (cached_has_bits & 0x00200000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      28, *this->handled_retryable_txn_error_, output);
  }

  // optional .cockroach.roachpb.UntrackedTxnError untracked_txn_error = 29;
  if (cached_has_bits & 0x00400000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      29, *this->untracked_txn_error_, output);
  }

  // optional .cockroach.roachpb.TxnPrevAttemptError txn_aborted_async_err = 30;
  if (cached_has_bits & 0x00800000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      30, *this->txn_aborted_async_err_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ErrorDetail)
}

size_t ErrorDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ErrorDetail)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 255u) {
    // optional .cockroach.roachpb.NotLeaseHolderError not_lease_holder = 1;
    if (has_not_lease_holder()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->not_lease_holder_);
    }

    // optional .cockroach.roachpb.RangeNotFoundError range_not_found = 2;
    if (has_range_not_found()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_not_found_);
    }

    // optional .cockroach.roachpb.RangeKeyMismatchError range_key_mismatch = 3;
    if (has_range_key_mismatch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_key_mismatch_);
    }

    // optional .cockroach.roachpb.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
    if (has_read_within_uncertainty_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->read_within_uncertainty_interval_);
    }

    // optional .cockroach.roachpb.TransactionAbortedError transaction_aborted = 5;
    if (has_transaction_aborted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_aborted_);
    }

    // optional .cockroach.roachpb.TransactionPushError transaction_push = 6;
    if (has_transaction_push()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_push_);
    }

    // optional .cockroach.roachpb.TransactionRetryError transaction_retry = 7;
    if (has_transaction_retry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_retry_);
    }

    // optional .cockroach.roachpb.TransactionStatusError transaction_status = 8;
    if (has_transaction_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_status_);
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional .cockroach.roachpb.WriteIntentError write_intent = 9;
    if (has_write_intent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->write_intent_);
    }

    // optional .cockroach.roachpb.WriteTooOldError write_too_old = 10;
    if (has_write_too_old()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->write_too_old_);
    }

    // optional .cockroach.roachpb.OpRequiresTxnError op_requires_txn = 11;
    if (has_op_requires_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->op_requires_txn_);
    }

    // optional .cockroach.roachpb.ConditionFailedError condition_failed = 12;
    if (has_condition_failed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->condition_failed_);
    }

    // optional .cockroach.roachpb.LeaseRejectedError lease_rejected = 13;
    if (has_lease_rejected()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_rejected_);
    }

    // optional .cockroach.roachpb.NodeUnavailableError node_unavailable = 14;
    if (has_node_unavailable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->node_unavailable_);
    }

    // optional .cockroach.roachpb.SendError send = 15;
    if (has_send()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->send_);
    }

    // optional .cockroach.roachpb.RaftGroupDeletedError raft_group_deleted = 16;
    if (has_raft_group_deleted()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->raft_group_deleted_);
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional .cockroach.roachpb.ReplicaCorruptionError replica_corruption = 17;
    if (has_replica_corruption()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_corruption_);
    }

    // optional .cockroach.roachpb.ReplicaTooOldError replica_too_old = 18;
    if (has_replica_too_old()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_too_old_);
    }

    // optional .cockroach.roachpb.TransactionReplayError transaction_replay = 22;
    if (has_transaction_replay()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_replay_);
    }

    // optional .cockroach.roachpb.AmbiguousResultError ambiguous_result = 26;
    if (has_ambiguous_result()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ambiguous_result_);
    }

    // optional .cockroach.roachpb.StoreNotFoundError store_not_found = 27;
    if (has_store_not_found()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->store_not_found_);
    }

    // optional .cockroach.roachpb.HandledRetryableTxnError handled_retryable_txn_error = 28;
    if (has_handled_retryable_txn_error()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->handled_retryable_txn_error_);
    }

    // optional .cockroach.roachpb.UntrackedTxnError untracked_txn_error = 29;
    if (has_untracked_txn_error()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->untracked_txn_error_);
    }

    // optional .cockroach.roachpb.TxnPrevAttemptError txn_aborted_async_err = 30;
    if (has_txn_aborted_async_err()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_aborted_async_err_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ErrorDetail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ErrorDetail*>(&from));
}

void ErrorDetail::MergeFrom(const ErrorDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ErrorDetail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_not_lease_holder()->::cockroach::roachpb::NotLeaseHolderError::MergeFrom(from.not_lease_holder());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_range_not_found()->::cockroach::roachpb::RangeNotFoundError::MergeFrom(from.range_not_found());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_range_key_mismatch()->::cockroach::roachpb::RangeKeyMismatchError::MergeFrom(from.range_key_mismatch());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_read_within_uncertainty_interval()->::cockroach::roachpb::ReadWithinUncertaintyIntervalError::MergeFrom(from.read_within_uncertainty_interval());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_transaction_aborted()->::cockroach::roachpb::TransactionAbortedError::MergeFrom(from.transaction_aborted());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_transaction_push()->::cockroach::roachpb::TransactionPushError::MergeFrom(from.transaction_push());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_transaction_retry()->::cockroach::roachpb::TransactionRetryError::MergeFrom(from.transaction_retry());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_transaction_status()->::cockroach::roachpb::TransactionStatusError::MergeFrom(from.transaction_status());
    }
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_write_intent()->::cockroach::roachpb::WriteIntentError::MergeFrom(from.write_intent());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_write_too_old()->::cockroach::roachpb::WriteTooOldError::MergeFrom(from.write_too_old());
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_op_requires_txn()->::cockroach::roachpb::OpRequiresTxnError::MergeFrom(from.op_requires_txn());
    }
    if (cached_has_bits & 0x00000800u) {
      mutable_condition_failed()->::cockroach::roachpb::ConditionFailedError::MergeFrom(from.condition_failed());
    }
    if (cached_has_bits & 0x00001000u) {
      mutable_lease_rejected()->::cockroach::roachpb::LeaseRejectedError::MergeFrom(from.lease_rejected());
    }
    if (cached_has_bits & 0x00002000u) {
      mutable_node_unavailable()->::cockroach::roachpb::NodeUnavailableError::MergeFrom(from.node_unavailable());
    }
    if (cached_has_bits & 0x00004000u) {
      mutable_send()->::cockroach::roachpb::SendError::MergeFrom(from.send());
    }
    if (cached_has_bits & 0x00008000u) {
      mutable_raft_group_deleted()->::cockroach::roachpb::RaftGroupDeletedError::MergeFrom(from.raft_group_deleted());
    }
  }
  if (cached_has_bits & 16711680u) {
    if (cached_has_bits & 0x00010000u) {
      mutable_replica_corruption()->::cockroach::roachpb::ReplicaCorruptionError::MergeFrom(from.replica_corruption());
    }
    if (cached_has_bits & 0x00020000u) {
      mutable_replica_too_old()->::cockroach::roachpb::ReplicaTooOldError::MergeFrom(from.replica_too_old());
    }
    if (cached_has_bits & 0x00040000u) {
      mutable_transaction_replay()->::cockroach::roachpb::TransactionReplayError::MergeFrom(from.transaction_replay());
    }
    if (cached_has_bits & 0x00080000u) {
      mutable_ambiguous_result()->::cockroach::roachpb::AmbiguousResultError::MergeFrom(from.ambiguous_result());
    }
    if (cached_has_bits & 0x00100000u) {
      mutable_store_not_found()->::cockroach::roachpb::StoreNotFoundError::MergeFrom(from.store_not_found());
    }
    if (cached_has_bits & 0x00200000u) {
      mutable_handled_retryable_txn_error()->::cockroach::roachpb::HandledRetryableTxnError::MergeFrom(from.handled_retryable_txn_error());
    }
    if (cached_has_bits & 0x00400000u) {
      mutable_untracked_txn_error()->::cockroach::roachpb::UntrackedTxnError::MergeFrom(from.untracked_txn_error());
    }
    if (cached_has_bits & 0x00800000u) {
      mutable_txn_aborted_async_err()->::cockroach::roachpb::TxnPrevAttemptError::MergeFrom(from.txn_aborted_async_err());
    }
  }
}

void ErrorDetail::CopyFrom(const ErrorDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ErrorDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorDetail::IsInitialized() const {
  return true;
}

void ErrorDetail::Swap(ErrorDetail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ErrorDetail::InternalSwap(ErrorDetail* other) {
  using std::swap;
  swap(not_lease_holder_, other->not_lease_holder_);
  swap(range_not_found_, other->range_not_found_);
  swap(range_key_mismatch_, other->range_key_mismatch_);
  swap(read_within_uncertainty_interval_, other->read_within_uncertainty_interval_);
  swap(transaction_aborted_, other->transaction_aborted_);
  swap(transaction_push_, other->transaction_push_);
  swap(transaction_retry_, other->transaction_retry_);
  swap(transaction_status_, other->transaction_status_);
  swap(write_intent_, other->write_intent_);
  swap(write_too_old_, other->write_too_old_);
  swap(op_requires_txn_, other->op_requires_txn_);
  swap(condition_failed_, other->condition_failed_);
  swap(lease_rejected_, other->lease_rejected_);
  swap(node_unavailable_, other->node_unavailable_);
  swap(send_, other->send_);
  swap(raft_group_deleted_, other->raft_group_deleted_);
  swap(replica_corruption_, other->replica_corruption_);
  swap(replica_too_old_, other->replica_too_old_);
  swap(transaction_replay_, other->transaction_replay_);
  swap(ambiguous_result_, other->ambiguous_result_);
  swap(store_not_found_, other->store_not_found_);
  swap(handled_retryable_txn_error_, other->handled_retryable_txn_error_);
  swap(untracked_txn_error_, other->untracked_txn_error_);
  swap(txn_aborted_async_err_, other->txn_aborted_async_err_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ErrorDetail::GetTypeName() const {
  return "cockroach.roachpb.ErrorDetail";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ErrorDetail

// optional .cockroach.roachpb.NotLeaseHolderError not_lease_holder = 1;
bool ErrorDetail::has_not_lease_holder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ErrorDetail::set_has_not_lease_holder() {
  _has_bits_[0] |= 0x00000001u;
}
void ErrorDetail::clear_has_not_lease_holder() {
  _has_bits_[0] &= ~0x00000001u;
}
void ErrorDetail::clear_not_lease_holder() {
  if (not_lease_holder_ != NULL) not_lease_holder_->::cockroach::roachpb::NotLeaseHolderError::Clear();
  clear_has_not_lease_holder();
}
const ::cockroach::roachpb::NotLeaseHolderError& ErrorDetail::not_lease_holder() const {
  const ::cockroach::roachpb::NotLeaseHolderError* p = not_lease_holder_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.not_lease_holder)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::NotLeaseHolderError*>(
      &::cockroach::roachpb::_NotLeaseHolderError_default_instance_);
}
::cockroach::roachpb::NotLeaseHolderError* ErrorDetail::mutable_not_lease_holder() {
  set_has_not_lease_holder();
  if (not_lease_holder_ == NULL) {
    not_lease_holder_ = new ::cockroach::roachpb::NotLeaseHolderError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.not_lease_holder)
  return not_lease_holder_;
}
::cockroach::roachpb::NotLeaseHolderError* ErrorDetail::release_not_lease_holder() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.not_lease_holder)
  clear_has_not_lease_holder();
  ::cockroach::roachpb::NotLeaseHolderError* temp = not_lease_holder_;
  not_lease_holder_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_not_lease_holder(::cockroach::roachpb::NotLeaseHolderError* not_lease_holder) {
  delete not_lease_holder_;
  not_lease_holder_ = not_lease_holder;
  if (not_lease_holder) {
    set_has_not_lease_holder();
  } else {
    clear_has_not_lease_holder();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.not_lease_holder)
}

// optional .cockroach.roachpb.RangeNotFoundError range_not_found = 2;
bool ErrorDetail::has_range_not_found() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ErrorDetail::set_has_range_not_found() {
  _has_bits_[0] |= 0x00000002u;
}
void ErrorDetail::clear_has_range_not_found() {
  _has_bits_[0] &= ~0x00000002u;
}
void ErrorDetail::clear_range_not_found() {
  if (range_not_found_ != NULL) range_not_found_->::cockroach::roachpb::RangeNotFoundError::Clear();
  clear_has_range_not_found();
}
const ::cockroach::roachpb::RangeNotFoundError& ErrorDetail::range_not_found() const {
  const ::cockroach::roachpb::RangeNotFoundError* p = range_not_found_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.range_not_found)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::RangeNotFoundError*>(
      &::cockroach::roachpb::_RangeNotFoundError_default_instance_);
}
::cockroach::roachpb::RangeNotFoundError* ErrorDetail::mutable_range_not_found() {
  set_has_range_not_found();
  if (range_not_found_ == NULL) {
    range_not_found_ = new ::cockroach::roachpb::RangeNotFoundError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.range_not_found)
  return range_not_found_;
}
::cockroach::roachpb::RangeNotFoundError* ErrorDetail::release_range_not_found() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.range_not_found)
  clear_has_range_not_found();
  ::cockroach::roachpb::RangeNotFoundError* temp = range_not_found_;
  range_not_found_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_range_not_found(::cockroach::roachpb::RangeNotFoundError* range_not_found) {
  delete range_not_found_;
  range_not_found_ = range_not_found;
  if (range_not_found) {
    set_has_range_not_found();
  } else {
    clear_has_range_not_found();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.range_not_found)
}

// optional .cockroach.roachpb.RangeKeyMismatchError range_key_mismatch = 3;
bool ErrorDetail::has_range_key_mismatch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ErrorDetail::set_has_range_key_mismatch() {
  _has_bits_[0] |= 0x00000004u;
}
void ErrorDetail::clear_has_range_key_mismatch() {
  _has_bits_[0] &= ~0x00000004u;
}
void ErrorDetail::clear_range_key_mismatch() {
  if (range_key_mismatch_ != NULL) range_key_mismatch_->::cockroach::roachpb::RangeKeyMismatchError::Clear();
  clear_has_range_key_mismatch();
}
const ::cockroach::roachpb::RangeKeyMismatchError& ErrorDetail::range_key_mismatch() const {
  const ::cockroach::roachpb::RangeKeyMismatchError* p = range_key_mismatch_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.range_key_mismatch)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::RangeKeyMismatchError*>(
      &::cockroach::roachpb::_RangeKeyMismatchError_default_instance_);
}
::cockroach::roachpb::RangeKeyMismatchError* ErrorDetail::mutable_range_key_mismatch() {
  set_has_range_key_mismatch();
  if (range_key_mismatch_ == NULL) {
    range_key_mismatch_ = new ::cockroach::roachpb::RangeKeyMismatchError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.range_key_mismatch)
  return range_key_mismatch_;
}
::cockroach::roachpb::RangeKeyMismatchError* ErrorDetail::release_range_key_mismatch() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.range_key_mismatch)
  clear_has_range_key_mismatch();
  ::cockroach::roachpb::RangeKeyMismatchError* temp = range_key_mismatch_;
  range_key_mismatch_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_range_key_mismatch(::cockroach::roachpb::RangeKeyMismatchError* range_key_mismatch) {
  delete range_key_mismatch_;
  range_key_mismatch_ = range_key_mismatch;
  if (range_key_mismatch) {
    set_has_range_key_mismatch();
  } else {
    clear_has_range_key_mismatch();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.range_key_mismatch)
}

// optional .cockroach.roachpb.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
bool ErrorDetail::has_read_within_uncertainty_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ErrorDetail::set_has_read_within_uncertainty_interval() {
  _has_bits_[0] |= 0x00000008u;
}
void ErrorDetail::clear_has_read_within_uncertainty_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
void ErrorDetail::clear_read_within_uncertainty_interval() {
  if (read_within_uncertainty_interval_ != NULL) read_within_uncertainty_interval_->::cockroach::roachpb::ReadWithinUncertaintyIntervalError::Clear();
  clear_has_read_within_uncertainty_interval();
}
const ::cockroach::roachpb::ReadWithinUncertaintyIntervalError& ErrorDetail::read_within_uncertainty_interval() const {
  const ::cockroach::roachpb::ReadWithinUncertaintyIntervalError* p = read_within_uncertainty_interval_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.read_within_uncertainty_interval)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ReadWithinUncertaintyIntervalError*>(
      &::cockroach::roachpb::_ReadWithinUncertaintyIntervalError_default_instance_);
}
::cockroach::roachpb::ReadWithinUncertaintyIntervalError* ErrorDetail::mutable_read_within_uncertainty_interval() {
  set_has_read_within_uncertainty_interval();
  if (read_within_uncertainty_interval_ == NULL) {
    read_within_uncertainty_interval_ = new ::cockroach::roachpb::ReadWithinUncertaintyIntervalError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.read_within_uncertainty_interval)
  return read_within_uncertainty_interval_;
}
::cockroach::roachpb::ReadWithinUncertaintyIntervalError* ErrorDetail::release_read_within_uncertainty_interval() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.read_within_uncertainty_interval)
  clear_has_read_within_uncertainty_interval();
  ::cockroach::roachpb::ReadWithinUncertaintyIntervalError* temp = read_within_uncertainty_interval_;
  read_within_uncertainty_interval_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_read_within_uncertainty_interval(::cockroach::roachpb::ReadWithinUncertaintyIntervalError* read_within_uncertainty_interval) {
  delete read_within_uncertainty_interval_;
  read_within_uncertainty_interval_ = read_within_uncertainty_interval;
  if (read_within_uncertainty_interval) {
    set_has_read_within_uncertainty_interval();
  } else {
    clear_has_read_within_uncertainty_interval();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.read_within_uncertainty_interval)
}

// optional .cockroach.roachpb.TransactionAbortedError transaction_aborted = 5;
bool ErrorDetail::has_transaction_aborted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ErrorDetail::set_has_transaction_aborted() {
  _has_bits_[0] |= 0x00000010u;
}
void ErrorDetail::clear_has_transaction_aborted() {
  _has_bits_[0] &= ~0x00000010u;
}
void ErrorDetail::clear_transaction_aborted() {
  if (transaction_aborted_ != NULL) transaction_aborted_->::cockroach::roachpb::TransactionAbortedError::Clear();
  clear_has_transaction_aborted();
}
const ::cockroach::roachpb::TransactionAbortedError& ErrorDetail::transaction_aborted() const {
  const ::cockroach::roachpb::TransactionAbortedError* p = transaction_aborted_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.transaction_aborted)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TransactionAbortedError*>(
      &::cockroach::roachpb::_TransactionAbortedError_default_instance_);
}
::cockroach::roachpb::TransactionAbortedError* ErrorDetail::mutable_transaction_aborted() {
  set_has_transaction_aborted();
  if (transaction_aborted_ == NULL) {
    transaction_aborted_ = new ::cockroach::roachpb::TransactionAbortedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.transaction_aborted)
  return transaction_aborted_;
}
::cockroach::roachpb::TransactionAbortedError* ErrorDetail::release_transaction_aborted() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.transaction_aborted)
  clear_has_transaction_aborted();
  ::cockroach::roachpb::TransactionAbortedError* temp = transaction_aborted_;
  transaction_aborted_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_transaction_aborted(::cockroach::roachpb::TransactionAbortedError* transaction_aborted) {
  delete transaction_aborted_;
  transaction_aborted_ = transaction_aborted;
  if (transaction_aborted) {
    set_has_transaction_aborted();
  } else {
    clear_has_transaction_aborted();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.transaction_aborted)
}

// optional .cockroach.roachpb.TransactionPushError transaction_push = 6;
bool ErrorDetail::has_transaction_push() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ErrorDetail::set_has_transaction_push() {
  _has_bits_[0] |= 0x00000020u;
}
void ErrorDetail::clear_has_transaction_push() {
  _has_bits_[0] &= ~0x00000020u;
}
void ErrorDetail::clear_transaction_push() {
  if (transaction_push_ != NULL) transaction_push_->::cockroach::roachpb::TransactionPushError::Clear();
  clear_has_transaction_push();
}
const ::cockroach::roachpb::TransactionPushError& ErrorDetail::transaction_push() const {
  const ::cockroach::roachpb::TransactionPushError* p = transaction_push_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.transaction_push)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TransactionPushError*>(
      &::cockroach::roachpb::_TransactionPushError_default_instance_);
}
::cockroach::roachpb::TransactionPushError* ErrorDetail::mutable_transaction_push() {
  set_has_transaction_push();
  if (transaction_push_ == NULL) {
    transaction_push_ = new ::cockroach::roachpb::TransactionPushError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.transaction_push)
  return transaction_push_;
}
::cockroach::roachpb::TransactionPushError* ErrorDetail::release_transaction_push() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.transaction_push)
  clear_has_transaction_push();
  ::cockroach::roachpb::TransactionPushError* temp = transaction_push_;
  transaction_push_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_transaction_push(::cockroach::roachpb::TransactionPushError* transaction_push) {
  delete transaction_push_;
  transaction_push_ = transaction_push;
  if (transaction_push) {
    set_has_transaction_push();
  } else {
    clear_has_transaction_push();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.transaction_push)
}

// optional .cockroach.roachpb.TransactionRetryError transaction_retry = 7;
bool ErrorDetail::has_transaction_retry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ErrorDetail::set_has_transaction_retry() {
  _has_bits_[0] |= 0x00000040u;
}
void ErrorDetail::clear_has_transaction_retry() {
  _has_bits_[0] &= ~0x00000040u;
}
void ErrorDetail::clear_transaction_retry() {
  if (transaction_retry_ != NULL) transaction_retry_->::cockroach::roachpb::TransactionRetryError::Clear();
  clear_has_transaction_retry();
}
const ::cockroach::roachpb::TransactionRetryError& ErrorDetail::transaction_retry() const {
  const ::cockroach::roachpb::TransactionRetryError* p = transaction_retry_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.transaction_retry)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TransactionRetryError*>(
      &::cockroach::roachpb::_TransactionRetryError_default_instance_);
}
::cockroach::roachpb::TransactionRetryError* ErrorDetail::mutable_transaction_retry() {
  set_has_transaction_retry();
  if (transaction_retry_ == NULL) {
    transaction_retry_ = new ::cockroach::roachpb::TransactionRetryError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.transaction_retry)
  return transaction_retry_;
}
::cockroach::roachpb::TransactionRetryError* ErrorDetail::release_transaction_retry() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.transaction_retry)
  clear_has_transaction_retry();
  ::cockroach::roachpb::TransactionRetryError* temp = transaction_retry_;
  transaction_retry_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_transaction_retry(::cockroach::roachpb::TransactionRetryError* transaction_retry) {
  delete transaction_retry_;
  transaction_retry_ = transaction_retry;
  if (transaction_retry) {
    set_has_transaction_retry();
  } else {
    clear_has_transaction_retry();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.transaction_retry)
}

// optional .cockroach.roachpb.TransactionReplayError transaction_replay = 22;
bool ErrorDetail::has_transaction_replay() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void ErrorDetail::set_has_transaction_replay() {
  _has_bits_[0] |= 0x00040000u;
}
void ErrorDetail::clear_has_transaction_replay() {
  _has_bits_[0] &= ~0x00040000u;
}
void ErrorDetail::clear_transaction_replay() {
  if (transaction_replay_ != NULL) transaction_replay_->::cockroach::roachpb::TransactionReplayError::Clear();
  clear_has_transaction_replay();
}
const ::cockroach::roachpb::TransactionReplayError& ErrorDetail::transaction_replay() const {
  const ::cockroach::roachpb::TransactionReplayError* p = transaction_replay_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.transaction_replay)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TransactionReplayError*>(
      &::cockroach::roachpb::_TransactionReplayError_default_instance_);
}
::cockroach::roachpb::TransactionReplayError* ErrorDetail::mutable_transaction_replay() {
  set_has_transaction_replay();
  if (transaction_replay_ == NULL) {
    transaction_replay_ = new ::cockroach::roachpb::TransactionReplayError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.transaction_replay)
  return transaction_replay_;
}
::cockroach::roachpb::TransactionReplayError* ErrorDetail::release_transaction_replay() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.transaction_replay)
  clear_has_transaction_replay();
  ::cockroach::roachpb::TransactionReplayError* temp = transaction_replay_;
  transaction_replay_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_transaction_replay(::cockroach::roachpb::TransactionReplayError* transaction_replay) {
  delete transaction_replay_;
  transaction_replay_ = transaction_replay;
  if (transaction_replay) {
    set_has_transaction_replay();
  } else {
    clear_has_transaction_replay();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.transaction_replay)
}

// optional .cockroach.roachpb.TransactionStatusError transaction_status = 8;
bool ErrorDetail::has_transaction_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ErrorDetail::set_has_transaction_status() {
  _has_bits_[0] |= 0x00000080u;
}
void ErrorDetail::clear_has_transaction_status() {
  _has_bits_[0] &= ~0x00000080u;
}
void ErrorDetail::clear_transaction_status() {
  if (transaction_status_ != NULL) transaction_status_->::cockroach::roachpb::TransactionStatusError::Clear();
  clear_has_transaction_status();
}
const ::cockroach::roachpb::TransactionStatusError& ErrorDetail::transaction_status() const {
  const ::cockroach::roachpb::TransactionStatusError* p = transaction_status_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.transaction_status)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TransactionStatusError*>(
      &::cockroach::roachpb::_TransactionStatusError_default_instance_);
}
::cockroach::roachpb::TransactionStatusError* ErrorDetail::mutable_transaction_status() {
  set_has_transaction_status();
  if (transaction_status_ == NULL) {
    transaction_status_ = new ::cockroach::roachpb::TransactionStatusError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.transaction_status)
  return transaction_status_;
}
::cockroach::roachpb::TransactionStatusError* ErrorDetail::release_transaction_status() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.transaction_status)
  clear_has_transaction_status();
  ::cockroach::roachpb::TransactionStatusError* temp = transaction_status_;
  transaction_status_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_transaction_status(::cockroach::roachpb::TransactionStatusError* transaction_status) {
  delete transaction_status_;
  transaction_status_ = transaction_status;
  if (transaction_status) {
    set_has_transaction_status();
  } else {
    clear_has_transaction_status();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.transaction_status)
}

// optional .cockroach.roachpb.WriteIntentError write_intent = 9;
bool ErrorDetail::has_write_intent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ErrorDetail::set_has_write_intent() {
  _has_bits_[0] |= 0x00000100u;
}
void ErrorDetail::clear_has_write_intent() {
  _has_bits_[0] &= ~0x00000100u;
}
void ErrorDetail::clear_write_intent() {
  if (write_intent_ != NULL) write_intent_->::cockroach::roachpb::WriteIntentError::Clear();
  clear_has_write_intent();
}
const ::cockroach::roachpb::WriteIntentError& ErrorDetail::write_intent() const {
  const ::cockroach::roachpb::WriteIntentError* p = write_intent_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.write_intent)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::WriteIntentError*>(
      &::cockroach::roachpb::_WriteIntentError_default_instance_);
}
::cockroach::roachpb::WriteIntentError* ErrorDetail::mutable_write_intent() {
  set_has_write_intent();
  if (write_intent_ == NULL) {
    write_intent_ = new ::cockroach::roachpb::WriteIntentError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.write_intent)
  return write_intent_;
}
::cockroach::roachpb::WriteIntentError* ErrorDetail::release_write_intent() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.write_intent)
  clear_has_write_intent();
  ::cockroach::roachpb::WriteIntentError* temp = write_intent_;
  write_intent_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_write_intent(::cockroach::roachpb::WriteIntentError* write_intent) {
  delete write_intent_;
  write_intent_ = write_intent;
  if (write_intent) {
    set_has_write_intent();
  } else {
    clear_has_write_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.write_intent)
}

// optional .cockroach.roachpb.WriteTooOldError write_too_old = 10;
bool ErrorDetail::has_write_too_old() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ErrorDetail::set_has_write_too_old() {
  _has_bits_[0] |= 0x00000200u;
}
void ErrorDetail::clear_has_write_too_old() {
  _has_bits_[0] &= ~0x00000200u;
}
void ErrorDetail::clear_write_too_old() {
  if (write_too_old_ != NULL) write_too_old_->::cockroach::roachpb::WriteTooOldError::Clear();
  clear_has_write_too_old();
}
const ::cockroach::roachpb::WriteTooOldError& ErrorDetail::write_too_old() const {
  const ::cockroach::roachpb::WriteTooOldError* p = write_too_old_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.write_too_old)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::WriteTooOldError*>(
      &::cockroach::roachpb::_WriteTooOldError_default_instance_);
}
::cockroach::roachpb::WriteTooOldError* ErrorDetail::mutable_write_too_old() {
  set_has_write_too_old();
  if (write_too_old_ == NULL) {
    write_too_old_ = new ::cockroach::roachpb::WriteTooOldError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.write_too_old)
  return write_too_old_;
}
::cockroach::roachpb::WriteTooOldError* ErrorDetail::release_write_too_old() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.write_too_old)
  clear_has_write_too_old();
  ::cockroach::roachpb::WriteTooOldError* temp = write_too_old_;
  write_too_old_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_write_too_old(::cockroach::roachpb::WriteTooOldError* write_too_old) {
  delete write_too_old_;
  write_too_old_ = write_too_old;
  if (write_too_old) {
    set_has_write_too_old();
  } else {
    clear_has_write_too_old();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.write_too_old)
}

// optional .cockroach.roachpb.OpRequiresTxnError op_requires_txn = 11;
bool ErrorDetail::has_op_requires_txn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ErrorDetail::set_has_op_requires_txn() {
  _has_bits_[0] |= 0x00000400u;
}
void ErrorDetail::clear_has_op_requires_txn() {
  _has_bits_[0] &= ~0x00000400u;
}
void ErrorDetail::clear_op_requires_txn() {
  if (op_requires_txn_ != NULL) op_requires_txn_->::cockroach::roachpb::OpRequiresTxnError::Clear();
  clear_has_op_requires_txn();
}
const ::cockroach::roachpb::OpRequiresTxnError& ErrorDetail::op_requires_txn() const {
  const ::cockroach::roachpb::OpRequiresTxnError* p = op_requires_txn_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.op_requires_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::OpRequiresTxnError*>(
      &::cockroach::roachpb::_OpRequiresTxnError_default_instance_);
}
::cockroach::roachpb::OpRequiresTxnError* ErrorDetail::mutable_op_requires_txn() {
  set_has_op_requires_txn();
  if (op_requires_txn_ == NULL) {
    op_requires_txn_ = new ::cockroach::roachpb::OpRequiresTxnError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.op_requires_txn)
  return op_requires_txn_;
}
::cockroach::roachpb::OpRequiresTxnError* ErrorDetail::release_op_requires_txn() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.op_requires_txn)
  clear_has_op_requires_txn();
  ::cockroach::roachpb::OpRequiresTxnError* temp = op_requires_txn_;
  op_requires_txn_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_op_requires_txn(::cockroach::roachpb::OpRequiresTxnError* op_requires_txn) {
  delete op_requires_txn_;
  op_requires_txn_ = op_requires_txn;
  if (op_requires_txn) {
    set_has_op_requires_txn();
  } else {
    clear_has_op_requires_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.op_requires_txn)
}

// optional .cockroach.roachpb.ConditionFailedError condition_failed = 12;
bool ErrorDetail::has_condition_failed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ErrorDetail::set_has_condition_failed() {
  _has_bits_[0] |= 0x00000800u;
}
void ErrorDetail::clear_has_condition_failed() {
  _has_bits_[0] &= ~0x00000800u;
}
void ErrorDetail::clear_condition_failed() {
  if (condition_failed_ != NULL) condition_failed_->::cockroach::roachpb::ConditionFailedError::Clear();
  clear_has_condition_failed();
}
const ::cockroach::roachpb::ConditionFailedError& ErrorDetail::condition_failed() const {
  const ::cockroach::roachpb::ConditionFailedError* p = condition_failed_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.condition_failed)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ConditionFailedError*>(
      &::cockroach::roachpb::_ConditionFailedError_default_instance_);
}
::cockroach::roachpb::ConditionFailedError* ErrorDetail::mutable_condition_failed() {
  set_has_condition_failed();
  if (condition_failed_ == NULL) {
    condition_failed_ = new ::cockroach::roachpb::ConditionFailedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.condition_failed)
  return condition_failed_;
}
::cockroach::roachpb::ConditionFailedError* ErrorDetail::release_condition_failed() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.condition_failed)
  clear_has_condition_failed();
  ::cockroach::roachpb::ConditionFailedError* temp = condition_failed_;
  condition_failed_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_condition_failed(::cockroach::roachpb::ConditionFailedError* condition_failed) {
  delete condition_failed_;
  condition_failed_ = condition_failed;
  if (condition_failed) {
    set_has_condition_failed();
  } else {
    clear_has_condition_failed();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.condition_failed)
}

// optional .cockroach.roachpb.LeaseRejectedError lease_rejected = 13;
bool ErrorDetail::has_lease_rejected() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ErrorDetail::set_has_lease_rejected() {
  _has_bits_[0] |= 0x00001000u;
}
void ErrorDetail::clear_has_lease_rejected() {
  _has_bits_[0] &= ~0x00001000u;
}
void ErrorDetail::clear_lease_rejected() {
  if (lease_rejected_ != NULL) lease_rejected_->::cockroach::roachpb::LeaseRejectedError::Clear();
  clear_has_lease_rejected();
}
const ::cockroach::roachpb::LeaseRejectedError& ErrorDetail::lease_rejected() const {
  const ::cockroach::roachpb::LeaseRejectedError* p = lease_rejected_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.lease_rejected)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::LeaseRejectedError*>(
      &::cockroach::roachpb::_LeaseRejectedError_default_instance_);
}
::cockroach::roachpb::LeaseRejectedError* ErrorDetail::mutable_lease_rejected() {
  set_has_lease_rejected();
  if (lease_rejected_ == NULL) {
    lease_rejected_ = new ::cockroach::roachpb::LeaseRejectedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.lease_rejected)
  return lease_rejected_;
}
::cockroach::roachpb::LeaseRejectedError* ErrorDetail::release_lease_rejected() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.lease_rejected)
  clear_has_lease_rejected();
  ::cockroach::roachpb::LeaseRejectedError* temp = lease_rejected_;
  lease_rejected_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_lease_rejected(::cockroach::roachpb::LeaseRejectedError* lease_rejected) {
  delete lease_rejected_;
  lease_rejected_ = lease_rejected;
  if (lease_rejected) {
    set_has_lease_rejected();
  } else {
    clear_has_lease_rejected();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.lease_rejected)
}

// optional .cockroach.roachpb.NodeUnavailableError node_unavailable = 14;
bool ErrorDetail::has_node_unavailable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void ErrorDetail::set_has_node_unavailable() {
  _has_bits_[0] |= 0x00002000u;
}
void ErrorDetail::clear_has_node_unavailable() {
  _has_bits_[0] &= ~0x00002000u;
}
void ErrorDetail::clear_node_unavailable() {
  if (node_unavailable_ != NULL) node_unavailable_->::cockroach::roachpb::NodeUnavailableError::Clear();
  clear_has_node_unavailable();
}
const ::cockroach::roachpb::NodeUnavailableError& ErrorDetail::node_unavailable() const {
  const ::cockroach::roachpb::NodeUnavailableError* p = node_unavailable_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.node_unavailable)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::NodeUnavailableError*>(
      &::cockroach::roachpb::_NodeUnavailableError_default_instance_);
}
::cockroach::roachpb::NodeUnavailableError* ErrorDetail::mutable_node_unavailable() {
  set_has_node_unavailable();
  if (node_unavailable_ == NULL) {
    node_unavailable_ = new ::cockroach::roachpb::NodeUnavailableError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.node_unavailable)
  return node_unavailable_;
}
::cockroach::roachpb::NodeUnavailableError* ErrorDetail::release_node_unavailable() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.node_unavailable)
  clear_has_node_unavailable();
  ::cockroach::roachpb::NodeUnavailableError* temp = node_unavailable_;
  node_unavailable_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_node_unavailable(::cockroach::roachpb::NodeUnavailableError* node_unavailable) {
  delete node_unavailable_;
  node_unavailable_ = node_unavailable;
  if (node_unavailable) {
    set_has_node_unavailable();
  } else {
    clear_has_node_unavailable();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.node_unavailable)
}

// optional .cockroach.roachpb.SendError send = 15;
bool ErrorDetail::has_send() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void ErrorDetail::set_has_send() {
  _has_bits_[0] |= 0x00004000u;
}
void ErrorDetail::clear_has_send() {
  _has_bits_[0] &= ~0x00004000u;
}
void ErrorDetail::clear_send() {
  if (send_ != NULL) send_->::cockroach::roachpb::SendError::Clear();
  clear_has_send();
}
const ::cockroach::roachpb::SendError& ErrorDetail::send() const {
  const ::cockroach::roachpb::SendError* p = send_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.send)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::SendError*>(
      &::cockroach::roachpb::_SendError_default_instance_);
}
::cockroach::roachpb::SendError* ErrorDetail::mutable_send() {
  set_has_send();
  if (send_ == NULL) {
    send_ = new ::cockroach::roachpb::SendError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.send)
  return send_;
}
::cockroach::roachpb::SendError* ErrorDetail::release_send() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.send)
  clear_has_send();
  ::cockroach::roachpb::SendError* temp = send_;
  send_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_send(::cockroach::roachpb::SendError* send) {
  delete send_;
  send_ = send;
  if (send) {
    set_has_send();
  } else {
    clear_has_send();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.send)
}

// optional .cockroach.roachpb.RaftGroupDeletedError raft_group_deleted = 16;
bool ErrorDetail::has_raft_group_deleted() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void ErrorDetail::set_has_raft_group_deleted() {
  _has_bits_[0] |= 0x00008000u;
}
void ErrorDetail::clear_has_raft_group_deleted() {
  _has_bits_[0] &= ~0x00008000u;
}
void ErrorDetail::clear_raft_group_deleted() {
  if (raft_group_deleted_ != NULL) raft_group_deleted_->::cockroach::roachpb::RaftGroupDeletedError::Clear();
  clear_has_raft_group_deleted();
}
const ::cockroach::roachpb::RaftGroupDeletedError& ErrorDetail::raft_group_deleted() const {
  const ::cockroach::roachpb::RaftGroupDeletedError* p = raft_group_deleted_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.raft_group_deleted)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::RaftGroupDeletedError*>(
      &::cockroach::roachpb::_RaftGroupDeletedError_default_instance_);
}
::cockroach::roachpb::RaftGroupDeletedError* ErrorDetail::mutable_raft_group_deleted() {
  set_has_raft_group_deleted();
  if (raft_group_deleted_ == NULL) {
    raft_group_deleted_ = new ::cockroach::roachpb::RaftGroupDeletedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.raft_group_deleted)
  return raft_group_deleted_;
}
::cockroach::roachpb::RaftGroupDeletedError* ErrorDetail::release_raft_group_deleted() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.raft_group_deleted)
  clear_has_raft_group_deleted();
  ::cockroach::roachpb::RaftGroupDeletedError* temp = raft_group_deleted_;
  raft_group_deleted_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_raft_group_deleted(::cockroach::roachpb::RaftGroupDeletedError* raft_group_deleted) {
  delete raft_group_deleted_;
  raft_group_deleted_ = raft_group_deleted;
  if (raft_group_deleted) {
    set_has_raft_group_deleted();
  } else {
    clear_has_raft_group_deleted();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.raft_group_deleted)
}

// optional .cockroach.roachpb.ReplicaCorruptionError replica_corruption = 17;
bool ErrorDetail::has_replica_corruption() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void ErrorDetail::set_has_replica_corruption() {
  _has_bits_[0] |= 0x00010000u;
}
void ErrorDetail::clear_has_replica_corruption() {
  _has_bits_[0] &= ~0x00010000u;
}
void ErrorDetail::clear_replica_corruption() {
  if (replica_corruption_ != NULL) replica_corruption_->::cockroach::roachpb::ReplicaCorruptionError::Clear();
  clear_has_replica_corruption();
}
const ::cockroach::roachpb::ReplicaCorruptionError& ErrorDetail::replica_corruption() const {
  const ::cockroach::roachpb::ReplicaCorruptionError* p = replica_corruption_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.replica_corruption)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ReplicaCorruptionError*>(
      &::cockroach::roachpb::_ReplicaCorruptionError_default_instance_);
}
::cockroach::roachpb::ReplicaCorruptionError* ErrorDetail::mutable_replica_corruption() {
  set_has_replica_corruption();
  if (replica_corruption_ == NULL) {
    replica_corruption_ = new ::cockroach::roachpb::ReplicaCorruptionError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.replica_corruption)
  return replica_corruption_;
}
::cockroach::roachpb::ReplicaCorruptionError* ErrorDetail::release_replica_corruption() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.replica_corruption)
  clear_has_replica_corruption();
  ::cockroach::roachpb::ReplicaCorruptionError* temp = replica_corruption_;
  replica_corruption_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_replica_corruption(::cockroach::roachpb::ReplicaCorruptionError* replica_corruption) {
  delete replica_corruption_;
  replica_corruption_ = replica_corruption;
  if (replica_corruption) {
    set_has_replica_corruption();
  } else {
    clear_has_replica_corruption();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.replica_corruption)
}

// optional .cockroach.roachpb.ReplicaTooOldError replica_too_old = 18;
bool ErrorDetail::has_replica_too_old() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void ErrorDetail::set_has_replica_too_old() {
  _has_bits_[0] |= 0x00020000u;
}
void ErrorDetail::clear_has_replica_too_old() {
  _has_bits_[0] &= ~0x00020000u;
}
void ErrorDetail::clear_replica_too_old() {
  if (replica_too_old_ != NULL) replica_too_old_->::cockroach::roachpb::ReplicaTooOldError::Clear();
  clear_has_replica_too_old();
}
const ::cockroach::roachpb::ReplicaTooOldError& ErrorDetail::replica_too_old() const {
  const ::cockroach::roachpb::ReplicaTooOldError* p = replica_too_old_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.replica_too_old)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ReplicaTooOldError*>(
      &::cockroach::roachpb::_ReplicaTooOldError_default_instance_);
}
::cockroach::roachpb::ReplicaTooOldError* ErrorDetail::mutable_replica_too_old() {
  set_has_replica_too_old();
  if (replica_too_old_ == NULL) {
    replica_too_old_ = new ::cockroach::roachpb::ReplicaTooOldError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.replica_too_old)
  return replica_too_old_;
}
::cockroach::roachpb::ReplicaTooOldError* ErrorDetail::release_replica_too_old() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.replica_too_old)
  clear_has_replica_too_old();
  ::cockroach::roachpb::ReplicaTooOldError* temp = replica_too_old_;
  replica_too_old_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_replica_too_old(::cockroach::roachpb::ReplicaTooOldError* replica_too_old) {
  delete replica_too_old_;
  replica_too_old_ = replica_too_old;
  if (replica_too_old) {
    set_has_replica_too_old();
  } else {
    clear_has_replica_too_old();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.replica_too_old)
}

// optional .cockroach.roachpb.AmbiguousResultError ambiguous_result = 26;
bool ErrorDetail::has_ambiguous_result() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void ErrorDetail::set_has_ambiguous_result() {
  _has_bits_[0] |= 0x00080000u;
}
void ErrorDetail::clear_has_ambiguous_result() {
  _has_bits_[0] &= ~0x00080000u;
}
void ErrorDetail::clear_ambiguous_result() {
  if (ambiguous_result_ != NULL) ambiguous_result_->::cockroach::roachpb::AmbiguousResultError::Clear();
  clear_has_ambiguous_result();
}
const ::cockroach::roachpb::AmbiguousResultError& ErrorDetail::ambiguous_result() const {
  const ::cockroach::roachpb::AmbiguousResultError* p = ambiguous_result_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.ambiguous_result)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::AmbiguousResultError*>(
      &::cockroach::roachpb::_AmbiguousResultError_default_instance_);
}
::cockroach::roachpb::AmbiguousResultError* ErrorDetail::mutable_ambiguous_result() {
  set_has_ambiguous_result();
  if (ambiguous_result_ == NULL) {
    ambiguous_result_ = new ::cockroach::roachpb::AmbiguousResultError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.ambiguous_result)
  return ambiguous_result_;
}
::cockroach::roachpb::AmbiguousResultError* ErrorDetail::release_ambiguous_result() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.ambiguous_result)
  clear_has_ambiguous_result();
  ::cockroach::roachpb::AmbiguousResultError* temp = ambiguous_result_;
  ambiguous_result_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_ambiguous_result(::cockroach::roachpb::AmbiguousResultError* ambiguous_result) {
  delete ambiguous_result_;
  ambiguous_result_ = ambiguous_result;
  if (ambiguous_result) {
    set_has_ambiguous_result();
  } else {
    clear_has_ambiguous_result();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.ambiguous_result)
}

// optional .cockroach.roachpb.StoreNotFoundError store_not_found = 27;
bool ErrorDetail::has_store_not_found() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void ErrorDetail::set_has_store_not_found() {
  _has_bits_[0] |= 0x00100000u;
}
void ErrorDetail::clear_has_store_not_found() {
  _has_bits_[0] &= ~0x00100000u;
}
void ErrorDetail::clear_store_not_found() {
  if (store_not_found_ != NULL) store_not_found_->::cockroach::roachpb::StoreNotFoundError::Clear();
  clear_has_store_not_found();
}
const ::cockroach::roachpb::StoreNotFoundError& ErrorDetail::store_not_found() const {
  const ::cockroach::roachpb::StoreNotFoundError* p = store_not_found_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.store_not_found)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::StoreNotFoundError*>(
      &::cockroach::roachpb::_StoreNotFoundError_default_instance_);
}
::cockroach::roachpb::StoreNotFoundError* ErrorDetail::mutable_store_not_found() {
  set_has_store_not_found();
  if (store_not_found_ == NULL) {
    store_not_found_ = new ::cockroach::roachpb::StoreNotFoundError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.store_not_found)
  return store_not_found_;
}
::cockroach::roachpb::StoreNotFoundError* ErrorDetail::release_store_not_found() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.store_not_found)
  clear_has_store_not_found();
  ::cockroach::roachpb::StoreNotFoundError* temp = store_not_found_;
  store_not_found_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_store_not_found(::cockroach::roachpb::StoreNotFoundError* store_not_found) {
  delete store_not_found_;
  store_not_found_ = store_not_found;
  if (store_not_found) {
    set_has_store_not_found();
  } else {
    clear_has_store_not_found();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.store_not_found)
}

// optional .cockroach.roachpb.HandledRetryableTxnError handled_retryable_txn_error = 28;
bool ErrorDetail::has_handled_retryable_txn_error() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void ErrorDetail::set_has_handled_retryable_txn_error() {
  _has_bits_[0] |= 0x00200000u;
}
void ErrorDetail::clear_has_handled_retryable_txn_error() {
  _has_bits_[0] &= ~0x00200000u;
}
void ErrorDetail::clear_handled_retryable_txn_error() {
  if (handled_retryable_txn_error_ != NULL) handled_retryable_txn_error_->::cockroach::roachpb::HandledRetryableTxnError::Clear();
  clear_has_handled_retryable_txn_error();
}
const ::cockroach::roachpb::HandledRetryableTxnError& ErrorDetail::handled_retryable_txn_error() const {
  const ::cockroach::roachpb::HandledRetryableTxnError* p = handled_retryable_txn_error_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.handled_retryable_txn_error)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::HandledRetryableTxnError*>(
      &::cockroach::roachpb::_HandledRetryableTxnError_default_instance_);
}
::cockroach::roachpb::HandledRetryableTxnError* ErrorDetail::mutable_handled_retryable_txn_error() {
  set_has_handled_retryable_txn_error();
  if (handled_retryable_txn_error_ == NULL) {
    handled_retryable_txn_error_ = new ::cockroach::roachpb::HandledRetryableTxnError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.handled_retryable_txn_error)
  return handled_retryable_txn_error_;
}
::cockroach::roachpb::HandledRetryableTxnError* ErrorDetail::release_handled_retryable_txn_error() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.handled_retryable_txn_error)
  clear_has_handled_retryable_txn_error();
  ::cockroach::roachpb::HandledRetryableTxnError* temp = handled_retryable_txn_error_;
  handled_retryable_txn_error_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_handled_retryable_txn_error(::cockroach::roachpb::HandledRetryableTxnError* handled_retryable_txn_error) {
  delete handled_retryable_txn_error_;
  handled_retryable_txn_error_ = handled_retryable_txn_error;
  if (handled_retryable_txn_error) {
    set_has_handled_retryable_txn_error();
  } else {
    clear_has_handled_retryable_txn_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.handled_retryable_txn_error)
}

// optional .cockroach.roachpb.UntrackedTxnError untracked_txn_error = 29;
bool ErrorDetail::has_untracked_txn_error() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void ErrorDetail::set_has_untracked_txn_error() {
  _has_bits_[0] |= 0x00400000u;
}
void ErrorDetail::clear_has_untracked_txn_error() {
  _has_bits_[0] &= ~0x00400000u;
}
void ErrorDetail::clear_untracked_txn_error() {
  if (untracked_txn_error_ != NULL) untracked_txn_error_->::cockroach::roachpb::UntrackedTxnError::Clear();
  clear_has_untracked_txn_error();
}
const ::cockroach::roachpb::UntrackedTxnError& ErrorDetail::untracked_txn_error() const {
  const ::cockroach::roachpb::UntrackedTxnError* p = untracked_txn_error_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.untracked_txn_error)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::UntrackedTxnError*>(
      &::cockroach::roachpb::_UntrackedTxnError_default_instance_);
}
::cockroach::roachpb::UntrackedTxnError* ErrorDetail::mutable_untracked_txn_error() {
  set_has_untracked_txn_error();
  if (untracked_txn_error_ == NULL) {
    untracked_txn_error_ = new ::cockroach::roachpb::UntrackedTxnError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.untracked_txn_error)
  return untracked_txn_error_;
}
::cockroach::roachpb::UntrackedTxnError* ErrorDetail::release_untracked_txn_error() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.untracked_txn_error)
  clear_has_untracked_txn_error();
  ::cockroach::roachpb::UntrackedTxnError* temp = untracked_txn_error_;
  untracked_txn_error_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_untracked_txn_error(::cockroach::roachpb::UntrackedTxnError* untracked_txn_error) {
  delete untracked_txn_error_;
  untracked_txn_error_ = untracked_txn_error;
  if (untracked_txn_error) {
    set_has_untracked_txn_error();
  } else {
    clear_has_untracked_txn_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.untracked_txn_error)
}

// optional .cockroach.roachpb.TxnPrevAttemptError txn_aborted_async_err = 30;
bool ErrorDetail::has_txn_aborted_async_err() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void ErrorDetail::set_has_txn_aborted_async_err() {
  _has_bits_[0] |= 0x00800000u;
}
void ErrorDetail::clear_has_txn_aborted_async_err() {
  _has_bits_[0] &= ~0x00800000u;
}
void ErrorDetail::clear_txn_aborted_async_err() {
  if (txn_aborted_async_err_ != NULL) txn_aborted_async_err_->::cockroach::roachpb::TxnPrevAttemptError::Clear();
  clear_has_txn_aborted_async_err();
}
const ::cockroach::roachpb::TxnPrevAttemptError& ErrorDetail::txn_aborted_async_err() const {
  const ::cockroach::roachpb::TxnPrevAttemptError* p = txn_aborted_async_err_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrorDetail.txn_aborted_async_err)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::TxnPrevAttemptError*>(
      &::cockroach::roachpb::_TxnPrevAttemptError_default_instance_);
}
::cockroach::roachpb::TxnPrevAttemptError* ErrorDetail::mutable_txn_aborted_async_err() {
  set_has_txn_aborted_async_err();
  if (txn_aborted_async_err_ == NULL) {
    txn_aborted_async_err_ = new ::cockroach::roachpb::TxnPrevAttemptError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ErrorDetail.txn_aborted_async_err)
  return txn_aborted_async_err_;
}
::cockroach::roachpb::TxnPrevAttemptError* ErrorDetail::release_txn_aborted_async_err() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.ErrorDetail.txn_aborted_async_err)
  clear_has_txn_aborted_async_err();
  ::cockroach::roachpb::TxnPrevAttemptError* temp = txn_aborted_async_err_;
  txn_aborted_async_err_ = NULL;
  return temp;
}
void ErrorDetail::set_allocated_txn_aborted_async_err(::cockroach::roachpb::TxnPrevAttemptError* txn_aborted_async_err) {
  delete txn_aborted_async_err_;
  txn_aborted_async_err_ = txn_aborted_async_err;
  if (txn_aborted_async_err) {
    set_has_txn_aborted_async_err();
  } else {
    clear_has_txn_aborted_async_err();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ErrorDetail.txn_aborted_async_err)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ErrPosition::kIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ErrPosition::ErrPosition()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ErrPosition)
}
ErrPosition::ErrPosition(const ErrPosition& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  index_ = from.index_;
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ErrPosition)
}

void ErrPosition::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
}

ErrPosition::~ErrPosition() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ErrPosition)
  SharedDtor();
}

void ErrPosition::SharedDtor() {
}

void ErrPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ErrPosition& ErrPosition::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

ErrPosition* ErrPosition::New(::google::protobuf::Arena* arena) const {
  ErrPosition* n = new ErrPosition;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ErrPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.ErrPosition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  index_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ErrPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ErrPosition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_index();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ErrPosition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ErrPosition)
  return false;
#undef DO_
}

void ErrPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ErrPosition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ErrPosition)
}

size_t ErrPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.ErrPosition)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (has_index()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->index());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ErrPosition::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ErrPosition*>(&from));
}

void ErrPosition::MergeFrom(const ErrPosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.ErrPosition)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_index()) {
    set_index(from.index());
  }
}

void ErrPosition::CopyFrom(const ErrPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.ErrPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrPosition::IsInitialized() const {
  return true;
}

void ErrPosition::Swap(ErrPosition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ErrPosition::InternalSwap(ErrPosition* other) {
  using std::swap;
  swap(index_, other->index_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ErrPosition::GetTypeName() const {
  return "cockroach.roachpb.ErrPosition";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ErrPosition

bool ErrPosition::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ErrPosition::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
void ErrPosition::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
void ErrPosition::clear_index() {
  index_ = 0;
  clear_has_index();
}
::google::protobuf::int32 ErrPosition::index() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ErrPosition.index)
  return index_;
}
void ErrPosition::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ErrPosition.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Error::kMessageFieldNumber;
const int Error::kTransactionRestartFieldNumber;
const int Error::kUnexposedTxnFieldNumber;
const int Error::kOriginNodeFieldNumber;
const int Error::kDetailFieldNumber;
const int Error::kIndexFieldNumber;
const int Error::kNowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Error::Error()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.Error)
}
Error::Error(const Error& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  if (from.has_unexposed_txn()) {
    unexposed_txn_ = new ::cockroach::roachpb::Transaction(*from.unexposed_txn_);
  } else {
    unexposed_txn_ = NULL;
  }
  if (from.has_detail()) {
    detail_ = new ::cockroach::roachpb::ErrorDetail(*from.detail_);
  } else {
    detail_ = NULL;
  }
  if (from.has_index()) {
    index_ = new ::cockroach::roachpb::ErrPosition(*from.index_);
  } else {
    index_ = NULL;
  }
  if (from.has_now()) {
    now_ = new ::cockroach::util::hlc::Timestamp(*from.now_);
  } else {
    now_ = NULL;
  }
  ::memcpy(&transaction_restart_, &from.transaction_restart_,
    static_cast<size_t>(reinterpret_cast<char*>(&origin_node_) -
    reinterpret_cast<char*>(&transaction_restart_)) + sizeof(origin_node_));
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.Error)
}

void Error::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&unexposed_txn_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&origin_node_) -
      reinterpret_cast<char*>(&unexposed_txn_)) + sizeof(origin_node_));
}

Error::~Error() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.Error)
  SharedDtor();
}

void Error::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete unexposed_txn_;
  if (this != internal_default_instance()) delete detail_;
  if (this != internal_default_instance()) delete index_;
  if (this != internal_default_instance()) delete now_;
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Error& Error::default_instance() {
  protobuf_roachpb_2ferrors_2eproto::InitDefaults();
  return *internal_default_instance();
}

Error* Error::New(::google::protobuf::Arena* arena) const {
  Error* n = new Error;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Error::Clear() {
// @@protoc_insertion_point(message_clear_start:cockroach.roachpb.Error)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(unexposed_txn_ != NULL);
      unexposed_txn_->::cockroach::roachpb::Transaction::Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(detail_ != NULL);
      detail_->::cockroach::roachpb::ErrorDetail::Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(index_ != NULL);
      index_->::cockroach::roachpb::ErrPosition::Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(now_ != NULL);
      now_->::cockroach::util::hlc::Timestamp::Clear();
    }
  }
  if (cached_has_bits & 96u) {
    ::memset(&transaction_restart_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&origin_node_) -
        reinterpret_cast<char*>(&transaction_restart_)) + sizeof(origin_node_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.Error)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::TransactionRestart_IsValid(value)) {
            set_transaction_restart(static_cast< ::cockroach::roachpb::TransactionRestart >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.Transaction unexposed_txn = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unexposed_txn()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_origin_node();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &origin_node_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ErrorDetail detail = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detail()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .cockroach.roachpb.ErrPosition index = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_index()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_now()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.Error)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.Error)
  return false;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.Error)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->transaction_restart(), output);
  }

  // optional .cockroach.roachpb.Transaction unexposed_txn = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->unexposed_txn_, output);
  }

  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->origin_node(), output);
  }

  // optional .cockroach.roachpb.ErrorDetail detail = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->detail_, output);
  }

  // optional .cockroach.roachpb.ErrPosition index = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->index_, output);
  }

  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->now_, output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.Error)
}

size_t Error::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cockroach.roachpb.Error)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 127u) {
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .cockroach.roachpb.Transaction unexposed_txn = 4;
    if (has_unexposed_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unexposed_txn_);
    }

    // optional .cockroach.roachpb.ErrorDetail detail = 6;
    if (has_detail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->detail_);
    }

    // optional .cockroach.roachpb.ErrPosition index = 7;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->index_);
    }

    if (has_now()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->now_);
    }

    if (has_transaction_restart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transaction_restart());
    }

    if (has_origin_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->origin_node());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Error*>(&from));
}

void Error::MergeFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cockroach.roachpb.Error)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_unexposed_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.unexposed_txn());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_detail()->::cockroach::roachpb::ErrorDetail::MergeFrom(from.detail());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_index()->::cockroach::roachpb::ErrPosition::MergeFrom(from.index());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_now()->::cockroach::util::hlc::Timestamp::MergeFrom(from.now());
    }
    if (cached_has_bits & 0x00000020u) {
      transaction_restart_ = from.transaction_restart_;
    }
    if (cached_has_bits & 0x00000040u) {
      origin_node_ = from.origin_node_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Error::CopyFrom(const Error& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cockroach.roachpb.Error)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  return true;
}

void Error::Swap(Error* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Error::InternalSwap(Error* other) {
  using std::swap;
  message_.Swap(&other->message_);
  swap(unexposed_txn_, other->unexposed_txn_);
  swap(detail_, other->detail_);
  swap(index_, other->index_);
  swap(now_, other->now_);
  swap(transaction_restart_, other->transaction_restart_);
  swap(origin_node_, other->origin_node_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Error::GetTypeName() const {
  return "cockroach.roachpb.Error";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Error

bool Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.message)
  return message_.GetNoArena();
}
void Error::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Error.message)
}
#if LANG_CXX11
void Error::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.roachpb.Error.message)
}
#endif
void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.Error.message)
}
void Error::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.Error.message)
}
::std::string* Error::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.Error.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Error.message)
}

bool Error::has_transaction_restart() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Error::set_has_transaction_restart() {
  _has_bits_[0] |= 0x00000020u;
}
void Error::clear_has_transaction_restart() {
  _has_bits_[0] &= ~0x00000020u;
}
void Error::clear_transaction_restart() {
  transaction_restart_ = 0;
  clear_has_transaction_restart();
}
::cockroach::roachpb::TransactionRestart Error::transaction_restart() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.transaction_restart)
  return static_cast< ::cockroach::roachpb::TransactionRestart >(transaction_restart_);
}
void Error::set_transaction_restart(::cockroach::roachpb::TransactionRestart value) {
  assert(::cockroach::roachpb::TransactionRestart_IsValid(value));
  set_has_transaction_restart();
  transaction_restart_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Error.transaction_restart)
}

// optional .cockroach.roachpb.Transaction unexposed_txn = 4;
bool Error::has_unexposed_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Error::set_has_unexposed_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void Error::clear_has_unexposed_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void Error::clear_unexposed_txn() {
  if (unexposed_txn_ != NULL) unexposed_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_unexposed_txn();
}
const ::cockroach::roachpb::Transaction& Error::unexposed_txn() const {
  const ::cockroach::roachpb::Transaction* p = unexposed_txn_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.unexposed_txn)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::Transaction*>(
      &::cockroach::roachpb::_Transaction_default_instance_);
}
::cockroach::roachpb::Transaction* Error::mutable_unexposed_txn() {
  set_has_unexposed_txn();
  if (unexposed_txn_ == NULL) {
    unexposed_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Error.unexposed_txn)
  return unexposed_txn_;
}
::cockroach::roachpb::Transaction* Error::release_unexposed_txn() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.Error.unexposed_txn)
  clear_has_unexposed_txn();
  ::cockroach::roachpb::Transaction* temp = unexposed_txn_;
  unexposed_txn_ = NULL;
  return temp;
}
void Error::set_allocated_unexposed_txn(::cockroach::roachpb::Transaction* unexposed_txn) {
  delete unexposed_txn_;
  unexposed_txn_ = unexposed_txn;
  if (unexposed_txn) {
    set_has_unexposed_txn();
  } else {
    clear_has_unexposed_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Error.unexposed_txn)
}

bool Error::has_origin_node() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Error::set_has_origin_node() {
  _has_bits_[0] |= 0x00000040u;
}
void Error::clear_has_origin_node() {
  _has_bits_[0] &= ~0x00000040u;
}
void Error::clear_origin_node() {
  origin_node_ = 0;
  clear_has_origin_node();
}
::google::protobuf::int32 Error::origin_node() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.origin_node)
  return origin_node_;
}
void Error::set_origin_node(::google::protobuf::int32 value) {
  set_has_origin_node();
  origin_node_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Error.origin_node)
}

// optional .cockroach.roachpb.ErrorDetail detail = 6;
bool Error::has_detail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Error::set_has_detail() {
  _has_bits_[0] |= 0x00000004u;
}
void Error::clear_has_detail() {
  _has_bits_[0] &= ~0x00000004u;
}
void Error::clear_detail() {
  if (detail_ != NULL) detail_->::cockroach::roachpb::ErrorDetail::Clear();
  clear_has_detail();
}
const ::cockroach::roachpb::ErrorDetail& Error::detail() const {
  const ::cockroach::roachpb::ErrorDetail* p = detail_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ErrorDetail*>(
      &::cockroach::roachpb::_ErrorDetail_default_instance_);
}
::cockroach::roachpb::ErrorDetail* Error::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) {
    detail_ = new ::cockroach::roachpb::ErrorDetail;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Error.detail)
  return detail_;
}
::cockroach::roachpb::ErrorDetail* Error::release_detail() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.Error.detail)
  clear_has_detail();
  ::cockroach::roachpb::ErrorDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
void Error::set_allocated_detail(::cockroach::roachpb::ErrorDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Error.detail)
}

// optional .cockroach.roachpb.ErrPosition index = 7;
bool Error::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Error::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
void Error::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
void Error::clear_index() {
  if (index_ != NULL) index_->::cockroach::roachpb::ErrPosition::Clear();
  clear_has_index();
}
const ::cockroach::roachpb::ErrPosition& Error::index() const {
  const ::cockroach::roachpb::ErrPosition* p = index_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.index)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::roachpb::ErrPosition*>(
      &::cockroach::roachpb::_ErrPosition_default_instance_);
}
::cockroach::roachpb::ErrPosition* Error::mutable_index() {
  set_has_index();
  if (index_ == NULL) {
    index_ = new ::cockroach::roachpb::ErrPosition;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Error.index)
  return index_;
}
::cockroach::roachpb::ErrPosition* Error::release_index() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.Error.index)
  clear_has_index();
  ::cockroach::roachpb::ErrPosition* temp = index_;
  index_ = NULL;
  return temp;
}
void Error::set_allocated_index(::cockroach::roachpb::ErrPosition* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Error.index)
}

bool Error::has_now() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Error::set_has_now() {
  _has_bits_[0] |= 0x00000010u;
}
void Error::clear_has_now() {
  _has_bits_[0] &= ~0x00000010u;
}
void Error::clear_now() {
  if (now_ != NULL) now_->::cockroach::util::hlc::Timestamp::Clear();
  clear_has_now();
}
const ::cockroach::util::hlc::Timestamp& Error::now() const {
  const ::cockroach::util::hlc::Timestamp* p = now_;
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Error.now)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::util::hlc::Timestamp*>(
      &::cockroach::util::hlc::_Timestamp_default_instance_);
}
::cockroach::util::hlc::Timestamp* Error::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::util::hlc::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Error.now)
  return now_;
}
::cockroach::util::hlc::Timestamp* Error::release_now() {
  // @@protoc_insertion_point(field_release:cockroach.roachpb.Error.now)
  clear_has_now();
  ::cockroach::util::hlc::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
void Error::set_allocated_now(::cockroach::util::hlc::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Error.now)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace roachpb
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
