// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ccl/storageccl/engineccl/enginepbccl/key_registry.proto

#ifndef PROTOBUF_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto__INCLUDED
#define PROTOBUF_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace cockroach {
namespace ccl {
namespace storageccl {
namespace engineccl {
namespace enginepbccl {
class DataKeysRegistry;
class DataKeysRegistryDefaultTypeInternal;
extern DataKeysRegistryDefaultTypeInternal _DataKeysRegistry_default_instance_;
class DataKeysRegistry_DataKeysEntry;
class DataKeysRegistry_DataKeysEntryDefaultTypeInternal;
extern DataKeysRegistry_DataKeysEntryDefaultTypeInternal _DataKeysRegistry_DataKeysEntry_default_instance_;
class DataKeysRegistry_StoreKeysEntry;
class DataKeysRegistry_StoreKeysEntryDefaultTypeInternal;
extern DataKeysRegistry_StoreKeysEntryDefaultTypeInternal _DataKeysRegistry_StoreKeysEntry_default_instance_;
class KeyInfo;
class KeyInfoDefaultTypeInternal;
extern KeyInfoDefaultTypeInternal _KeyInfo_default_instance_;
class SecretKey;
class SecretKeyDefaultTypeInternal;
extern SecretKeyDefaultTypeInternal _SecretKey_default_instance_;
}  // namespace enginepbccl
}  // namespace engineccl
}  // namespace storageccl
}  // namespace ccl
}  // namespace cockroach

namespace cockroach {
namespace ccl {
namespace storageccl {
namespace engineccl {
namespace enginepbccl {

namespace protobuf_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto

enum EncryptionType {
  Plaintext = 0,
  AES128_CTR = 1,
  AES192_CTR = 2,
  AES256_CTR = 3,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EncryptionType_IsValid(int value);
const EncryptionType EncryptionType_MIN = Plaintext;
const EncryptionType EncryptionType_MAX = AES256_CTR;
const int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

// ===================================================================


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class DataKeysRegistry : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry) */ {
 public:
  DataKeysRegistry();
  virtual ~DataKeysRegistry();

  DataKeysRegistry(const DataKeysRegistry& from);

  inline DataKeysRegistry& operator=(const DataKeysRegistry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataKeysRegistry(DataKeysRegistry&& from) noexcept
    : DataKeysRegistry() {
    *this = ::std::move(from);
  }

  inline DataKeysRegistry& operator=(DataKeysRegistry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DataKeysRegistry& default_instance();

  static inline const DataKeysRegistry* internal_default_instance() {
    return reinterpret_cast<const DataKeysRegistry*>(
               &_DataKeysRegistry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DataKeysRegistry* other);
  friend void swap(DataKeysRegistry& a, DataKeysRegistry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataKeysRegistry* New() const PROTOBUF_FINAL { return New(NULL); }

  DataKeysRegistry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DataKeysRegistry& from);
  void MergeFrom(const DataKeysRegistry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataKeysRegistry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo> store_keys = 1;
  int store_keys_size() const;
  void clear_store_keys();
  static const int kStoreKeysFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo >&
      store_keys() const;
  ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo >*
      mutable_store_keys();

  // map<string, .cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey> data_keys = 2;
  int data_keys_size() const;
  void clear_data_keys();
  static const int kDataKeysFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey >&
      data_keys() const;
  ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey >*
      mutable_data_keys();

  // string active_store_key = 3;
  void clear_active_store_key();
  static const int kActiveStoreKeyFieldNumber = 3;
  const ::std::string& active_store_key() const;
  void set_active_store_key(const ::std::string& value);
  #if LANG_CXX11
  void set_active_store_key(::std::string&& value);
  #endif
  void set_active_store_key(const char* value);
  void set_active_store_key(const char* value, size_t size);
  ::std::string* mutable_active_store_key();
  ::std::string* release_active_store_key();
  void set_allocated_active_store_key(::std::string* active_store_key);

  // string active_data_key = 4;
  void clear_active_data_key();
  static const int kActiveDataKeyFieldNumber = 4;
  const ::std::string& active_data_key() const;
  void set_active_data_key(const ::std::string& value);
  #if LANG_CXX11
  void set_active_data_key(::std::string&& value);
  #endif
  void set_active_data_key(const char* value);
  void set_active_data_key(const char* value, size_t size);
  ::std::string* mutable_active_data_key();
  ::std::string* release_active_data_key();
  void set_allocated_active_data_key(::std::string* active_data_key);

  // @@protoc_insertion_point(class_scope:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      DataKeysRegistry_StoreKeysEntry;
  private:
  ::google::protobuf::internal::MapFieldLite<
      DataKeysRegistry_StoreKeysEntry,
      ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > store_keys_;
  private:
  public:
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      DataKeysRegistry_DataKeysEntry;
  private:
  ::google::protobuf::internal::MapFieldLite<
      DataKeysRegistry_DataKeysEntry,
      ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > data_keys_;
  private:
  ::google::protobuf::internal::ArenaStringPtr active_store_key_;
  ::google::protobuf::internal::ArenaStringPtr active_data_key_;
  mutable int _cached_size_;
  friend struct protobuf_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo) */ {
 public:
  KeyInfo();
  virtual ~KeyInfo();

  KeyInfo(const KeyInfo& from);

  inline KeyInfo& operator=(const KeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyInfo(KeyInfo&& from) noexcept
    : KeyInfo() {
    *this = ::std::move(from);
  }

  inline KeyInfo& operator=(KeyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const KeyInfo& default_instance();

  static inline const KeyInfo* internal_default_instance() {
    return reinterpret_cast<const KeyInfo*>(
               &_KeyInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(KeyInfo* other);
  friend void swap(KeyInfo& a, KeyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const KeyInfo& from);
  void MergeFrom(const KeyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key_id = 2;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 2;
  const ::std::string& key_id() const;
  void set_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_key_id(::std::string&& value);
  #endif
  void set_key_id(const char* value);
  void set_key_id(const char* value, size_t size);
  ::std::string* mutable_key_id();
  ::std::string* release_key_id();
  void set_allocated_key_id(::std::string* key_id);

  // string source = 4;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // string parent_key_id = 6;
  void clear_parent_key_id();
  static const int kParentKeyIdFieldNumber = 6;
  const ::std::string& parent_key_id() const;
  void set_parent_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_key_id(::std::string&& value);
  #endif
  void set_parent_key_id(const char* value);
  void set_parent_key_id(const char* value, size_t size);
  ::std::string* mutable_parent_key_id();
  ::std::string* release_parent_key_id();
  void set_allocated_parent_key_id(::std::string* parent_key_id);

  // int64 creation_time = 3;
  void clear_creation_time();
  static const int kCreationTimeFieldNumber = 3;
  ::google::protobuf::int64 creation_time() const;
  void set_creation_time(::google::protobuf::int64 value);

  // .cockroach.ccl.storageccl.engineccl.enginepbccl.EncryptionType encryption_type = 1;
  void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 1;
  ::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType encryption_type() const;
  void set_encryption_type(::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType value);

  // bool was_exposed = 5;
  void clear_was_exposed();
  static const int kWasExposedFieldNumber = 5;
  bool was_exposed() const;
  void set_was_exposed(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_id_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr parent_key_id_;
  ::google::protobuf::int64 creation_time_;
  int encryption_type_;
  bool was_exposed_;
  mutable int _cached_size_;
  friend struct protobuf_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecretKey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey) */ {
 public:
  SecretKey();
  virtual ~SecretKey();

  SecretKey(const SecretKey& from);

  inline SecretKey& operator=(const SecretKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SecretKey(SecretKey&& from) noexcept
    : SecretKey() {
    *this = ::std::move(from);
  }

  inline SecretKey& operator=(SecretKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SecretKey& default_instance();

  static inline const SecretKey* internal_default_instance() {
    return reinterpret_cast<const SecretKey*>(
               &_SecretKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SecretKey* other);
  friend void swap(SecretKey& a, SecretKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SecretKey* New() const PROTOBUF_FINAL { return New(NULL); }

  SecretKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SecretKey& from);
  void MergeFrom(const SecretKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SecretKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo& info() const;
  ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* mutable_info();
  ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* release_info();
  void set_allocated_info(::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* info);

  // @@protoc_insertion_point(class_scope:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* info_;
  mutable int _cached_size_;
  friend struct protobuf_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataKeysRegistry

// map<string, .cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo> store_keys = 1;
inline int DataKeysRegistry::store_keys_size() const {
  return store_keys_.size();
}
inline void DataKeysRegistry::clear_store_keys() {
  store_keys_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo >&
DataKeysRegistry::store_keys() const {
  // @@protoc_insertion_point(field_map:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.store_keys)
  return store_keys_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo >*
DataKeysRegistry::mutable_store_keys() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.store_keys)
  return store_keys_.MutableMap();
}

// map<string, .cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey> data_keys = 2;
inline int DataKeysRegistry::data_keys_size() const {
  return data_keys_.size();
}
inline void DataKeysRegistry::clear_data_keys() {
  data_keys_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey >&
DataKeysRegistry::data_keys() const {
  // @@protoc_insertion_point(field_map:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.data_keys)
  return data_keys_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::cockroach::ccl::storageccl::engineccl::enginepbccl::SecretKey >*
DataKeysRegistry::mutable_data_keys() {
  // @@protoc_insertion_point(field_mutable_map:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.data_keys)
  return data_keys_.MutableMap();
}

// string active_store_key = 3;
inline void DataKeysRegistry::clear_active_store_key() {
  active_store_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataKeysRegistry::active_store_key() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
  return active_store_key_.GetNoArena();
}
inline void DataKeysRegistry::set_active_store_key(const ::std::string& value) {
  
  active_store_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
}
#if LANG_CXX11
inline void DataKeysRegistry::set_active_store_key(::std::string&& value) {
  
  active_store_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
}
#endif
inline void DataKeysRegistry::set_active_store_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  active_store_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
}
inline void DataKeysRegistry::set_active_store_key(const char* value, size_t size) {
  
  active_store_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
}
inline ::std::string* DataKeysRegistry::mutable_active_store_key() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
  return active_store_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataKeysRegistry::release_active_store_key() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
  
  return active_store_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataKeysRegistry::set_allocated_active_store_key(::std::string* active_store_key) {
  if (active_store_key != NULL) {
    
  } else {
    
  }
  active_store_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), active_store_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_store_key)
}

// string active_data_key = 4;
inline void DataKeysRegistry::clear_active_data_key() {
  active_data_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataKeysRegistry::active_data_key() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
  return active_data_key_.GetNoArena();
}
inline void DataKeysRegistry::set_active_data_key(const ::std::string& value) {
  
  active_data_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
}
#if LANG_CXX11
inline void DataKeysRegistry::set_active_data_key(::std::string&& value) {
  
  active_data_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
}
#endif
inline void DataKeysRegistry::set_active_data_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  active_data_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
}
inline void DataKeysRegistry::set_active_data_key(const char* value, size_t size) {
  
  active_data_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
}
inline ::std::string* DataKeysRegistry::mutable_active_data_key() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
  return active_data_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataKeysRegistry::release_active_data_key() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
  
  return active_data_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataKeysRegistry::set_allocated_active_data_key(::std::string* active_data_key) {
  if (active_data_key != NULL) {
    
  } else {
    
  }
  active_data_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), active_data_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.DataKeysRegistry.active_data_key)
}

// -------------------------------------------------------------------

// KeyInfo

// .cockroach.ccl.storageccl.engineccl.enginepbccl.EncryptionType encryption_type = 1;
inline void KeyInfo::clear_encryption_type() {
  encryption_type_ = 0;
}
inline ::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType KeyInfo::encryption_type() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.encryption_type)
  return static_cast< ::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType >(encryption_type_);
}
inline void KeyInfo::set_encryption_type(::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType value) {
  
  encryption_type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.encryption_type)
}

// string key_id = 2;
inline void KeyInfo::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::key_id() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
  return key_id_.GetNoArena();
}
inline void KeyInfo::set_key_id(const ::std::string& value) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
}
#if LANG_CXX11
inline void KeyInfo::set_key_id(::std::string&& value) {
  
  key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
}
#endif
inline void KeyInfo::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
}
inline void KeyInfo::set_key_id(const char* value, size_t size) {
  
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
}
inline ::std::string* KeyInfo::mutable_key_id() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
  return key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_key_id() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
  
  return key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_key_id(::std::string* key_id) {
  if (key_id != NULL) {
    
  } else {
    
  }
  key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.key_id)
}

// int64 creation_time = 3;
inline void KeyInfo::clear_creation_time() {
  creation_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KeyInfo::creation_time() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.creation_time)
  return creation_time_;
}
inline void KeyInfo::set_creation_time(::google::protobuf::int64 value) {
  
  creation_time_ = value;
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.creation_time)
}

// string source = 4;
inline void KeyInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::source() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
  return source_.GetNoArena();
}
inline void KeyInfo::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
}
#if LANG_CXX11
inline void KeyInfo::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
}
#endif
inline void KeyInfo::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
}
inline void KeyInfo::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
}
inline ::std::string* KeyInfo::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_source() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.source)
}

// bool was_exposed = 5;
inline void KeyInfo::clear_was_exposed() {
  was_exposed_ = false;
}
inline bool KeyInfo::was_exposed() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.was_exposed)
  return was_exposed_;
}
inline void KeyInfo::set_was_exposed(bool value) {
  
  was_exposed_ = value;
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.was_exposed)
}

// string parent_key_id = 6;
inline void KeyInfo::clear_parent_key_id() {
  parent_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyInfo::parent_key_id() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
  return parent_key_id_.GetNoArena();
}
inline void KeyInfo::set_parent_key_id(const ::std::string& value) {
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
}
#if LANG_CXX11
inline void KeyInfo::set_parent_key_id(::std::string&& value) {
  
  parent_key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
}
#endif
inline void KeyInfo::set_parent_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
}
inline void KeyInfo::set_parent_key_id(const char* value, size_t size) {
  
  parent_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
}
inline ::std::string* KeyInfo::mutable_parent_key_id() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
  return parent_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyInfo::release_parent_key_id() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
  
  return parent_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyInfo::set_allocated_parent_key_id(::std::string* parent_key_id) {
  if (parent_key_id != NULL) {
    
  } else {
    
  }
  parent_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_key_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo.parent_key_id)
}

// -------------------------------------------------------------------

// SecretKey

// .cockroach.ccl.storageccl.engineccl.enginepbccl.KeyInfo info = 1;
inline bool SecretKey::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void SecretKey::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo& SecretKey::info() const {
  const ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* p = info_;
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.info)
  return p != NULL ? *p : *reinterpret_cast<const ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo*>(
      &::cockroach::ccl::storageccl::engineccl::enginepbccl::_KeyInfo_default_instance_);
}
inline ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* SecretKey::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.info)
  return info_;
}
inline ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* SecretKey::release_info() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.info)
  
  ::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void SecretKey::set_allocated_info(::cockroach::ccl::storageccl::engineccl::enginepbccl::KeyInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.info)
}

// bytes key = 2;
inline void SecretKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SecretKey::key() const {
  // @@protoc_insertion_point(field_get:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
  return key_.GetNoArena();
}
inline void SecretKey::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
}
#if LANG_CXX11
inline void SecretKey::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
}
#endif
inline void SecretKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
}
inline void SecretKey::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
}
inline ::std::string* SecretKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecretKey::release_key() {
  // @@protoc_insertion_point(field_release:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecretKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.ccl.storageccl.engineccl.enginepbccl.SecretKey.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace enginepbccl
}  // namespace engineccl
}  // namespace storageccl
}  // namespace ccl
}  // namespace cockroach

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cockroach::ccl::storageccl::engineccl::enginepbccl::EncryptionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ccl_2fstorageccl_2fengineccl_2fenginepbccl_2fkey_5fregistry_2eproto__INCLUDED
