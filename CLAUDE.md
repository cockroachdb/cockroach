# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## CockroachDB Development Environment

CockroachDB is a distributed SQL database written in Go. We use Bazel as a build
system but most operations are wrapped through the `./dev` tool, which should be
preferred to direct `go (build|test)` or `bazel` invocations.

### Essential Commands

**Building a package / package tests**

This is useful as a compilation check.

```bash
# Build package ./pkg/util/log
./dev build pkg/util/log
# Build the tests in package ./pkg/util/log
./dev build pkg/util/log:log_test
```

**Testing:**
```bash
./dev test pkg/sql                   # run unit tests for SQL package (slow!)
./dev test pkg/sql -f=TestParse -v   # run specific test pattern
./dev test pkg/sql --count=5         # run test multiple times
```

Note that when filtering tests via `-f` to include the `-v` flag which
will warn you in the output if your filter didn't match anything. Look
for `testing: warning: no tests to run` in the output.

See `./dev test --help` for all options`.

**Building:**

```bash
./dev build cockroach     # build full cockroach binary
./dev build short         # build cockroach without UI (faster)
```

Building a CockroachDB binary (even in short mode) should be considered
slow. Avoid doing this unless necessary.

Use `./dev build --help` for the entire list of artifacts that can
be built.

**Code Generation and Linting:**

Protocol buffers, SQL parser, SQL Optimizer rules and others rely on Go code
generated by `./dev generate <args>`. This should be considered a slow command.
Rebuild only what is actually needed. `./dev (test|build)` commands
automatically generate their dependencies, but do not lift them into the
worktree, i.e. if they need to be visible to you, you need to invoke the
appropriate `./dev generate` command yourself.

```bash
./dev generate            # generate all code (protobuf, parsers, etc.) - SLOW
./dev generate go         # generate Go code only
./dev generate bazel      # update BUILD.bazel files when dependencies change
./dev generate protobuf   # generate protobuf files - relatively fast
```

See `./dev generate --help`.

### Architecture Overview

CockroachDB consists of many components and subsystems. The file .github/CODEOWNERS is a
good starting point if the overall architecture is relevant to the task.

## Coding Guidelines

### Log and Error Redactability

CockroachDB implements redactability to ensure sensitive information (PII,
confidential data) is automatically removed or marked in log messages and error
outputs. This enables customers to safely share logs with support teams.

#### Core Concepts

**Safe vs Unsafe Data:**
- **Safe data**: Information certainly known to NOT be PII-laden (node IDs, range IDs, error codes)
- **Unsafe data**: Information potentially PII-laden or confidential (user data, SQL statements, keys)

**Redactable Strings:**
- Unsafe data is enclosed in Unicode markers: `‹unsafe_data›`
- Safe data appears without markers
- Log entries show a special indicator: `⋮` (vertical ellipsis)

#### Key Implementation Patterns

**SafeValue Interface** - For types that are always safe:
```go
type NodeID int32
func (n NodeID) SafeValue() {}  // always safe to log

// Interface verification pattern.
var _ redact.SafeValue = NodeID(0)
```

**SafeFormatter Interface** - For complex types mixing safe/unsafe data:
```go
func (s *ComponentStats) SafeFormat(w redact.SafePrinter, _ rune) {
    w.Printf("ComponentStats{ID: %v", s.Component)
    // Use w.Printf(), w.SafeString(), w.SafeRune() to mark safe parts.
}
```

#### Common APIs

- `redact.Safe(value)` - Mark a value as safe
- `redact.SafeString(s)` - Mark string literal as safe

#### Redactcheck Linter

Prefer using SafeFormatter, which does not require the below check.
If implementing SafeValue instead:

The linter in `/pkg/testutils/lint/passes/redactcheck/redactcheck.go`:
- Maintains allowlist of types permitted to implement `SafeValue`
- Validates `RegisterSafeType` calls
- Prevents accidental marking of sensitive types as safe

To add a new safe type:
1. Implement `SafeValue()` method
2. Add interface verification: `var _ redact.SafeValue = TypeName{}`
3. Update redactcheck allowlist if needed

#### Key Files

- `/pkg/util/log/redact.go` - Core redaction logic
- `/docs/RFCS/20200427_log_file_redaction.md` - Design RFC
- `/pkg/testutils/lint/passes/redactcheck/redactcheck.go` - Linter implementation
- `/pkg/util/log/redact_test.go` - Test examples and patterns

### Code Formatting with crlfmt

CockroachDB uses a custom code formatter called `crlfmt` that goes beyond standard Go formatting tools to enforce project-specific style guidelines.

#### What is crlfmt

`crlfmt` is CockroachDB's **custom Go code formatter** (not a wrapper around
standard tools) that enforces specific coding standards beyond what `gofmt` and
`goimports` provide. It's an external tool developed specifically for
CockroachDB's needs. Editor-integrated agents often don't need to invoke this,
since the editor does it automatically. Otherwise, the agent should invoke the
tool after each round of edits to ensure correct formatting.

**Repository**: `github.com/cockroachdb/crlfmt`

#### Formatting Standards

**Line Length and Wrapping:**
- Code: 100 columns, Comments: 80 columns
- Tab width: 2 characters

**Function Signatures:**
```go
func (s *someType) myFunctionName(
    arg1 somepackage.SomeArgType, arg2 int, arg3 somepackage.SomeOtherType,
) (somepackage.SomeReturnType, error) {
    // ...
}

// One argument per line for long lists.
func (s *someType) myFunctionName(
    arg1 somepackage.SomeArgType,
    arg2 int,
    arg3 somepackage.SomeOtherType,
) (somepackage.SomeReturnType, error) {
    // ...
}
```

#### Common Usage Patterns

**Basic Formatting:**
```bash
# Format (in-place) with CockroachDB standard settings
crlfmt -w -tab 2 filename.go

# Check formatting without writing changes
crlfmt -diff filename.go
```

**Note:** `crlfmt` only accepts one filename at a time. To format multiple files, use `xargs` or a loop:
```bash
# Format multiple files with xargs
find pkg/sql -name "*.go" | xargs -n1 crlfmt -w

# Or use a loop
for f in pkg/sql/*.go; do crlfmt -w "$f"; done
```

### Go Coding Guidelines

CockroachDB follows specific Go coding conventions inspired by the Uber Go style guide with CockroachDB-specific modifications.

#### Pointers and Interfaces

**Pointers to Interfaces:**
- Almost never need a pointer to an interface
- Pass interfaces as values—underlying data can still be a pointer
- Interface contains: type-specific information pointer + data pointer

**Receivers and Interfaces:**
```go
type S struct {
    data string
}

// Value receiver - can be called on pointers and values.
func (s S) Read() string {
    return s.data
}

// Pointer receiver - needed to modify data.
func (s *S) Write(str string) {
    s.data = str
}

// Interface verification pattern.
var _ redact.SafeValue = NodeID(0)
```

#### Memory Management and Concurrency

**Mutexes:**
```go
// Zero-value mutex is valid.
var mu sync.Mutex
mu.Lock()

// Embed mutex in struct (preferred for private types).
type smap struct {
    sync.Mutex
    data map[string]string
}

// Named field for exported types.
type SMap struct {
    mu   sync.Mutex
    data map[string]string
}
```

**Defer for Cleanup:**
```go
// Always use defer for locks and cleanup.
func (m *SMap) Get(k string) string {
    m.mu.Lock()
    defer m.mu.Unlock()
    return m.data[k]
}

// For panic protection, use separate function.
func myFunc() error {
    doRiskyWork := func() error {
        p.Lock()
        defer p.Unlock()
        return somethingThatCanPanic()
    }
    return doRiskyWork()
}
```

**Slice and Map Copying:**

Comments should clarify ownership.

```go
// SetTrips sets the driver's trips.
// Note that the slice is captured by reference, the
// caller should take care of preventing unwanted aliasing.
func (d *Driver) SetTrips(trips []Trip) { d.trips = trips }
```

or

```
// SetTrips sets the driver's trips. It does not hold on
// to the provided slice.
func (d *Driver) SetTrips(trips []Trip) {
    d.trips = make([]Trip, len(trips))
    copy(d.trips, trips)
}
```

```
// Snapshot returns a copy of the internal state.
func (s *Stats) Snapshot() map[string]int {
    s.Lock()
    defer s.Unlock()
    result := make(map[string]int, len(s.counters))
    for k, v := range s.counters {
        result[k] = v
    }
    return result
}
```

#### Performance Guidelines

Many code paths are performance-sensitive and in particular
heap allocations should be avoided. In all code paths, reasonably
performant code should be written, as long as complexity does not
significantly increase as a result. Some examples of this follow.

**String Conversion:**
```go
// strconv is faster than fmt for primitives.
s := strconv.Itoa(rand.Int()) // good
s := fmt.Sprint(rand.Int())   // slower
```

**String-to-Byte Conversion:**
```go
// Avoid repeated conversion.
data := []byte("Hello world")      // good - once
for i := 0; i < b.N; i++ {
    w.Write(data)
}

// Bad - repeated allocation.
for i := 0; i < b.N; i++ {
    w.Write([]byte("Hello world"))
}
```

**Channels:**
- Size should be one or unbuffered (zero)
- Any other size requires high scrutiny

**Enums:**
```go
// Start enums at one unless zero value is meaningful.
type Operation int
const (
    Add Operation = iota + 1
    Subtract
    Multiply
)
```

**Import Grouping:**
```go
import (
    // Standard library
    "fmt"
    "os"

    // Everything else
    "go.uber.org/atomic"
    "golang.org/x/sync/errgroup"
)
```

**Variable Declarations:**
```go
// Top-level: omit type if clear from function return.
var _s = F()

// Local: use short declaration.
s := "foo"

// Empty slices: prefer var declaration.
var filtered []int
// Over: filtered := []int{}.

// nil is a valid slice.
return nil // not return []int{}

// Check empty with len(), not nil comparison.
func isEmpty(s []string) bool {
    return len(s) == 0 // not s == nil
}
```

**Struct Initialization:**
```go
// Always specify field names.
k := User{
    FirstName: "John",
    LastName: "Doe",
    Admin: true,
}

// Use &T{} instead of new(T).
sptr := &T{Name: "bar"}
```

**Bool Parameters:**
```go
// Avoid naked bools - use comments or enums.
printInfo("foo", true /* isLocal */, true /* done */)

// Better: custom types.
type EndTxnAction bool
const (
    Commit EndTxnAction = false
    Abort  = true
)
func endTxn(action EndTxnAction) {}
```

**Error Handling:**
```go
// Reduce variable scope.
if err := f.Close(); err != nil {
    return err
}

// Reduce nesting - handle errors early.
for _, v := range data {
    if v.F1 != 1 {
        log.Printf("Invalid v: %v", v)
        continue
    }
    v = process(v)
    if err := v.Call(); err != nil {
        return err
    }
    v.Send()
}
```

**Printf and Formatting:**
```go
// Format strings should be const for go vet.
const msg = "unexpected values %v, %v\n"
fmt.Printf(msg, 1, 2)

// Printf-style function names should end with 'f'.
func Wrapf(format string, args ...interface{}) error

// Use raw strings to avoid escaping.
wantError := `unknown error:"test"`
```

#### Testing Patterns

**Table-Driven Tests:**
```go
tests := []struct{
    give     string
    wantHost string
    wantPort string
}{{
    give:     "192.0.2.0:8000",
    wantHost: "192.0.2.0",
    wantPort: "8000",
}, {
    give:     ":8000",
    wantHost: "",
    wantPort: "8000",
}}

for _, tt := range tests {
    t.Run(tt.give, func(t *testing.T) {
        host, port, err := net.SplitHostPort(tt.give)
        require.NoError(t, err)
        assert.Equal(t, tt.wantHost, host)
        assert.Equal(t, tt.wantPort, port)
    })
}
```

**Functional Options Pattern:**
```go
type Option interface {
    apply(*options)
}

type optionFunc func(*options)
func (f optionFunc) apply(o *options) { f(o) }

func WithTimeout(t time.Duration) Option {
    return optionFunc(func(o *options) {
        o.timeout = t
    })
}

func Connect(addr string, opts ...Option) (*Connection, error) {
    options := options{
        timeout: defaultTimeout,
        caching: defaultCaching,
    }
    for _, o := range opts {
        o.apply(&options)
    }
    // ...
}
```

### Writing Comments

#### Block Comments vs Inline Comments

**Block comments** (standalone line) use full sentences with capitalization and punctuation:
```go
// Bad - panics on wrong type.
t := i.(string)

// Good - handles gracefully.
t, ok := i.(string)
```

**Inline comments** (end of code line) are lowercase without terminal punctuation:
```go
s := strconv.Itoa(rand.Int()) // good
s := fmt.Sprint(rand.Int())   // slower
func (n NodeID) SafeValue() {}  // always safe to log
```

#### Comment Placement Principles

Comments should be placed where they provide the most value and avoid duplication:

**Data Structure Comments:**
- Belong at the **data structure declaration**
- Explain the purpose, lifecycle, and invariants of the struct/type
- Document which code initializes fields, which code accesses them, and when they become obsolete
- Do not repeat this information in function comments that use these structures

**Algorithmic Comments:**
- Belong **inside function bodies**
- Explain the logic, phases, and non-obvious implementation details
- Separate different processing phases with summary comments
- Focus on "why" rather than "what" the code does

**Function Declaration Comments:**
- Focus on **inputs and outputs** - what the function does, not how
- Describe the contract, preconditions, postconditions, and behavior
- Do NOT explain the intricacies of input/output types if those are data structures already documented at their declaration
- Readers should refer to the data structure definition for detailed field explanations

**Overview and Design Comments:**
- Must be **completely understandable with zero knowledge of the code**
- If a reader cannot understand the overview without reading code, either improve the comment or remove it
- Reading an incomprehensible comment followed by code is double work
- To make overview comments understandable:
  - **Minimize new terminology** - use plain language where possible
  - **Define new terms immediately** when you must introduce them
  - **Illustrate with examples** to clarify abstract concepts
  - **Limit term introduction** - avoid introducing many new terms at once; consider using variants of existing terms instead
- If you introduce terms like "satisfiable", "strict", "coverage" in quick succession, step back and see if fewer, clearer terms would suffice

#### Engineering Standards (Enforced in Reviews)

CockroachDB is a complex system and you should write code under the assumption
that it will have to be understood and modified in the future by readers who
have basic familiarity with CockroachDB, but are not experts on the respective
subsystem.

Key concepts and abstractions should be explained clearly, and lifecycles and
ownership clearly stated. Whenever possible, you should use examples to make the
code accessible to the reader. Comments should always add depth to the code
(rather than repeating the code).

When reviewing, other than technical correctness, you should also focus on the
above aspects. Do not over-emphasize on grammar and comment typos, prefix with
"nit:" in reviews.

CockroachDB is a distributed system that allows for rolling upgrades. This means
that any shared state or inter-process communication needs to be mindful of
compatibility issues.  See `pkg/clusterversion` for more on this.

#### Comment Types and Examples

**Top-Level Design Comments:**
Explain concepts/abstractions, show how pieces fit together, connect to use cases. These must be understandable without reading any code - define terms clearly and use examples to illustrate abstract concepts.

Example from `concurrency/concurrency_control.go`:
```go
// Package concurrency provides a concurrency manager that coordinates
// access to keys and key ranges. The concurrency manager sequences
// concurrent txns that access overlapping keys and ensures that locks
// are respected and txn isolation guarantees are upheld.
//
// The concurrency manager is structured as a two-level hierarchy...
```

**API and Interface Comments:**
```go
// AuthConn is the interface used by the authenticator for interacting with the
// pgwire connection.
type AuthConn interface {
    // SendAuthRequest sends a request for authentication information. After
    // calling this, the authenticator needs to call GetPwdData() quickly, as the
    // connection's goroutine will be blocked on providing us the requested data.
    SendAuthRequest(authType int32, data []byte) error

    // GetPwdData returns authentication info that was previously requested with
    // SendAuthRequest. The call blocks until such data is available.
    // An error is returned if the client connection dropped or if the client
    // didn't respect the protocol.
    GetPwdData() ([]byte, error)
}
```

**Function Comments:**
Focus on inputs, outputs, and behavior. Avoid re-documenting data structure details that are explained at their declaration.

```go
// Append appends the provided string and any number of query parameters.
// Instead of using normal placeholders (e.g. $1, $2), use meta-placeholder $.
// This method rewrites the query so that it uses proper placeholders.
//
// For example, suppose we have the following calls:
//
//   query.Append("SELECT * FROM foo WHERE a > $ AND a < $ ", arg1, arg2)
//   query.Append("LIMIT $", limit)
//
// The query is rewritten into:
//
//   SELECT * FROM foo WHERE a > $1 AND a < $2 LIMIT $3
//   /* $1 = arg1, $2 = arg2, $3 = limit */
//
// Note that this method does NOT return any errors. Instead, we queue up
// errors, which can later be accessed.
func (q *sqlQuery) Append(s string, params ...interface{}) { /* ... */ }
```

**Struct Field Comments:**
Document the purpose, lifecycle, and usage of each field. This is where data structure details belong - function comments should not repeat this information.

```go
// cliState defines the current state of the CLI during command-line processing.
//
// Note: options customizable via \set and \unset should be defined in
// sqlCtx or cliCtx instead, so that the configuration remains global
// across multiple instances of cliState.
type cliState struct {
    // forwardLines is the array of lookahead lines. This gets
    // populated when there is more than one line of input
    // in the data read by ReadLine(), which can happen
    // when copy-pasting.
    forwardLines []string

    // partialStmtsLen represents the number of entries in partialLines
    // parsed successfully so far. It grows larger than zero whenever 1)
    // syntax checking is enabled and 2) multi-statement entry starts.
    partialStmtsLen int
}
```

**Phase Comments in Function Bodies:**
Algorithmic comments that separate different processing phases and explain non-obvious logic. These belong inside functions, not at function declarations.

```go
func (r *Replica) executeAdminCommandWithDescriptor(
    ctx context.Context, updateDesc func(*roachpb.RangeDescriptor) error,
) *roachpb.Error {
    // Retry forever as long as we see errors we know will resolve.
    retryOpts := base.DefaultRetryOptions()

    for retryable := retry.StartWithCtx(ctx, retryOpts); retryable.Next(); {
        // The replica may have been destroyed since the start of the retry loop.
        // We need to explicitly check this condition.
        if _, err := r.IsDestroyed(); err != nil {
            return roachpb.NewError(err)
        }

        // Admin commands always require the range lease to begin, but we may
        // have lost it while in this retry loop. Without the lease, a replica's
        // local descriptor can be arbitrarily stale.
        if _, pErr := r.redirectOnOrAcquireLease(ctx); pErr != nil {
            return pErr
        }
    }
}
```

**Protobuf Message Comments:**
```go
// ReplicaType identifies which raft activities a replica participates in. In
// normal operation, VOTER_FULL and LEARNER are the only used states. However,
// atomic replication changes require a transition through a "joint config"; in
// this joint config, the VOTER_DEMOTING and VOTER_INCOMING types are used as
// well to denote voters which are being downgraded to learners and newly added
// by the change, respectively.
enum ReplicaType {
    // VOTER_FULL indicates a replica that is a voter both in the
    // incoming and outgoing set.
    VOTER_FULL = 0;

    // VOTER_INCOMING indicates a voting replica that will be a
    // VOTER_FULL once the ongoing atomic replication change is finalized;
    // that is, it is in the process of being added.
    VOTER_INCOMING = 2;
}
```

#### Comment Maintenance

**When to Update Comments:**
- Add explanations when you discover valuable missing knowledge
- Fix factually incorrect comments immediately (treat as bugs)
- Fix grammar/spelling that significantly impairs reading
- Avoid cosmetic changes that don't improve understanding

**Review Guidelines:**
- Point out when missing comments would help understanding
- Add comments explaining review discussion outcomes
- Prefix grammar suggestions with "nit:" to indicate low priority

### Error Handling

CockroachDB uses the
[github.com/cockroachdb/errors](https://github.com/cockroachdb/errors) library,
a superset of Go's standard `errors` package and `pkg/errors`. Importantly,
`cockroachdb/errors` interoperates with `cockroachdb/redact`. Ensure that
information that is passed to error constructors has proper redaction, as
unredacted information might be stripped before reaching our support team.

#### Creating Errors

```go
// Simple static string errors.
errors.New("connection failed")

// Formatted error strings.
errors.Newf("invalid value: %d", val)

// Assertion failures for implementation bugs (generates louder alerts).
errors.AssertionFailedf("expected non-nil pointer")
```

#### Wrapping and Adding Context

It can be helpful to add context when propagating errors up the call stack:

```go
// Wrap with context (preferred over fmt.Errorf with %w).
return errors.Wrap(err, "opening file")

// Wrap with formatted context.
return errors.Wrapf(err, "connecting to %s", addr)
```

Keep context succinct; avoid phrases like "failed to" which pile up:

```go
// Bad: "failed to x: failed to y: failed to create store: the error"
return errors.Newf("failed to create new store: %s", err)

// Good: "x: y: new store: the error"
return errors.Wrap(err, "new store")
```

#### User-Facing Information

```go
// Add hints for end-users (actionable guidance, excluded from Sentry).
errors.WithHint(err, "check your network connection")

// Add details for developers (contextual info, excluded from Sentry).
errors.WithDetail(err, "request payload was 2.5MB")
```

#### Detecting and Handling Errors

For errors that clients need to detect, use sentinel errors or custom types:

```go
// Sentinel error pattern.
var ErrNotFound = errors.New("not found")

func Find(id string) error {
    return ErrNotFound
}

// Caller detection with errors.Is (works across network boundaries!).
if errors.Is(err, ErrNotFound) {
    // Handle not found.
}
```

For errors with additional information, use custom types:

```go
type NotFoundError struct {
    Resource string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s not found", e.Resource)
}

// Caller detection with errors.As.
var nfErr *NotFoundError
if errors.As(err, &nfErr) {
    log.Printf("missing: %s", nfErr.Resource)
}
```

#### Error Propagation Options

| Scenario | Approach |
|----------|----------|
| No additional context needed | Return original error |
| Adding context | Use `errors.Wrap` or `errors.Wrapf` |
| Passing through goroutine channel | Use `errors.WithStack` on both ends |
| Callers don't need to detect this error | Use `errors.Newf` |
| Hide original cause | Use `errors.Handled` or `errors.Opaque` |

#### Safe Details for PII Protection

Error messages are redacted by default in Sentry reports. Mark data as safe explicitly:

```go
// Mark specific values as safe for reporting.
errors.WithSafeDetails(err, "node_id=%d", nodeID)

// The Safe() wrapper for known-safe values.
errors.Newf("processing %s", errors.Safe(operationName))
```

#### Type Assertions

Always use the "comma ok" idiom to avoid panics:

```go
// Bad - panics on wrong type.
t := i.(string)

// Good - handles gracefully.
t, ok := i.(string)
if !ok {
    return errors.New("expected string type")
}
```

#### Key Files

- `/docs/RFCS/20190318_error_handling.md` - Error handling RFC
- [cockroachdb/errors README](https://raw.githubusercontent.com/cockroachdb/errors/refs/heads/master/README.md) - Full API documentation

### Resources

- **Main Documentation**: https://cockroachlabs.com/docs/stable/
- **Architecture Guide**: https://www.cockroachlabs.com/docs/stable/architecture/overview.html
- **Contributing**: See `/CONTRIBUTING.md` and https://wiki.crdb.io/
- **Design Documents**: `/docs/design.md` and `/docs/tech-notes/`

### When generating PRs and commit records

Use the `commit-helper` skill (invoked via `/commit-helper`) when creating commits and PRs.

- For multi-commit PRs, summarize each commit in the PR record.
- Do not include a test plan unless explicitly asked by the user.

# Interaction Style

* Be direct and honest.
* Skip unnecessary acknowledgments.
* Correct me when I'm wrong and explain why.
* Suggest better alternatives if my ideas can be improved.
* Focus on accuracy and efficiency.
* Challenge my assumptions when needed.
* Prioritize quality information and directness.

## drtprod Package (`pkg/cmd/drtprod`)

**drtprod** (DRT Prod) is a CLI tool for managing **DRT (Disaster Recovery Testing)** clusters using roachprod. It provides a declarative, YAML-based approach to creating, destroying, controlling, and configuring CockroachDB clusters for reliability and disaster recovery testing.

### Package Structure

```
pkg/cmd/drtprod/
├── main.go                          # Entry point
├── README.md                        # Brief documentation
├── cli/                             # CLI implementation
│   ├── handlers.go                  # Environment setup and initialization
│   ├── registry.go                  # Command registration
│   └── commands/                    # Command implementations
│       ├── rootcmd.go               # Root command with DataDog integration
│       ├── yamlprocessor.go         # YAML-based deployment orchestration (core)
│       ├── yamlprocessor_test.go    # Comprehensive unit tests
│       └── slack.go                 # Slack notifications
├── helpers/                         # Utility functions
│   └── utils.go                     # Command execution with prefixed output
├── configs/                         # YAML configuration files
│   ├── drt_test.yaml                # Test deployment example
│   ├── drt_scale.yaml               # 150-node scale test cluster
│   ├── drt_scale_300.yaml           # 300-node cluster
│   ├── drt_chaos.yaml               # Chaos testing configuration
│   ├── drt_multi_cloud.yaml         # Multi-cloud deployment
│   ├── drt_pua_*.yaml               # Production Under Attack configs
│   ├── drt_remote.yaml              # Remote monitor VM config
│   ├── *_destroy.yaml               # Cleanup/teardown configs
│   └── archived/                    # Historical configurations
└── scripts/                         # Shell scripts for cluster operations
    ├── tpcc_init.sh                 # TPC-C workload initialization
    ├── generate_tpcc_run.sh         # TPC-C run script generator
    ├── generate_kv_run.sh           # KV workload generator
    ├── generate_ycsb_run.sh         # YCSB workload generator
    ├── setup_datadog_cluster        # DataDog monitoring setup
    ├── mixed_version.sh             # Mixed version upgrade testing
    └── k8s/                         # Kubernetes templates
```

### Environment Setup (`cli/handlers.go`)

Sets DRT-specific defaults if not already configured:

| Environment Variable | Default Value |
|---------------------|---------------|
| `ROACHPROD_DNS` | `drt.crdb.io` |
| `ROACHPROD_GCE_DNS_DOMAIN` | `drt.crdb.io` |
| `ROACHPROD_GCE_DNS_ZONE` | `drt` |
| `ROACHPROD_GCE_DEFAULT_PROJECT` | `cockroach-drt` |
| `ROACHPROD_GCE_DEFAULT_SERVICE_ACCOUNT` | `622274581499-compute@developer.gserviceaccount.com` |
| `DD_API_KEY` | Fetched from GCP secrets (cockroach-drt/datadog-api-key) |

### YAML Configuration Schema

```yaml
environment:                          # Environment variables to set
  KEY: value

dependent_file_locations:             # Files/scripts needed for deployment
  - path/to/script.sh

targets:                              # Deployment targets
  - target_name: cluster_name
    dependent_targets:                # Dependencies (must complete first)
      - other_target
    ignore_dependent_failure: bool    # Continue even if dependencies fail
    notify_progress: bool             # Send Slack notifications
    steps:                            # Operations to execute
      - command: roachprod_command    # OR script: path/to/script.sh
        args: [args]
        flags:
          key: value
        continue_on_failure: bool     # Don't stop on failure
        wait_before: seconds          # Pre-execution delay
        wait_after: seconds           # Post-execution delay
        skip_notification: bool       # Skip Slack for this step
        on_rollback:                  # Cleanup on failure
          - command: cleanup
```

### Key Data Structures (`cli/commands/yamlprocessor.go`)

| Type | Purpose |
|------|---------|
| `yamlConfig` | Root configuration with environment, targets, and dependencies |
| `target` | Deployment target with steps and dependency info |
| `step` | Individual operation (command or script) |
| `command` | Simplified representation for execution |
| `targetStatusRegistry` | Thread-safe registry tracking target success/failure |
| `executeCmdOptions` | CLI flags: displayOnly, yamlFileLocation, remoteConfigYaml, targets |

### Command-Line Interface

**Execute Command:**
```bash
drtprod execute <yaml_file> [flags]

Flags:
  -d, --display-only          Preview commands without executing
  -t, --targets strings       Execute only specific targets
  -r, --remote-config-yaml    Deploy on remote monitor VM
```

**Pass-Through Commands** (any command not explicitly defined passes to roachprod):
```bash
drtprod create my-cluster --nodes=10    # -> roachprod create ...
drtprod destroy my-cluster              # -> roachprod destroy ...
drtprod ssh my-cluster                  # -> roachprod ssh ...
```

### Execution Flow

1. **Parse YAML**: `yaml.UnmarshalStrict` with strict validation
2. **Check Dependencies**: Verify all referenced files exist
3. **Set Environment**: Export variables from YAML
4. **Build Commands**: Convert steps to executable commands with env expansion (`os.ExpandEnv`)
5. **Register Wait Groups**: Create synchronization primitives for dependencies
6. **Execute Targets**: Run targets concurrently with dependency ordering using `errgroup`
7. **Handle Rollbacks**: On failure, execute rollback commands in reverse order

### Dependency Management

Targets can depend on other targets:
- Uses `sync.WaitGroup` per target for synchronization
- Dependent targets wait until dependencies complete
- `ignore_dependent_failure` allows continuation despite dependency failures
- Parallel execution of independent targets via `errgroup.Group`

### Remote Execution

For long-running deployments, execution can be delegated to a remote monitor VM:

1. Create a monitor VM using `drt_remote.yaml` configuration
2. Upload all dependencies (YAML, scripts, drtprod binary) via `roachprod.Put()`
3. Start execution via `systemd-run` on the remote VM
4. Local process completes immediately after setup

```bash
drtprod execute drt_scale.yaml -r pkg/cmd/drtprod/configs/drt_remote.yaml
```

### Integration with roachprod

drtprod is a wrapper around roachprod that adds:
- **DRT-specific defaults**: GCE project, DNS, service accounts
- **Declarative configuration**: YAML-based cluster definitions
- **Dependency management**: Target ordering and parallelism
- **Audit logging**: DataDog event tracking (via `rootcmd.go`)
- **Notifications**: Slack integration (via `slack.go`)
- **Rollback support**: Automatic cleanup on failures
- **Remote execution**: Long-running deployments on monitor VMs

Key roachprod functions used:
- `roachprod.Run()` - Execute commands on cluster nodes
- `roachprod.Put()` - Upload files to cluster nodes

### Slack Integration (`cli/commands/slack.go`)

```go
type Notifier interface {
    SendNotification(targetName string, message string) error
}
```

Features:
- Thread-based messaging (all messages for a target in one thread)
- Status notifications: Starting, Completed, Failed
- Environment variables: `SLACK_BOT_TOKEN`, `SLACK_CHANNEL`

### DataDog Integration (`cli/commands/rootcmd.go`)

Every command execution is logged to DataDog for audit trail:
- Events include: command start, command finish, timing, and dashboard links
- Tags: `env:development`, `cluster:<name>`, `team:drt`, `service:drt-cockroachdb`

### Available Configurations

| Config File | Purpose | Nodes |
|-------------|---------|-------|
| `drt_test.yaml` | Test cluster example | 3 + 1 workload |
| `drt_scale.yaml` | Scale testing | 150 + 9 workload |
| `drt_scale_300.yaml` | Large scale testing | 300 nodes |
| `drt_chaos.yaml` | Chaos/failure testing | Variable |
| `drt_multi_cloud.yaml` | Multi-cloud deployment | Variable |
| `drt_pua_*.yaml` | Production Under Attack | Variable |
| `drt_remote.yaml` | Monitor VM for remote execution | 1 |
| `*_destroy.yaml` | Cleanup configurations | N/A |

### Typical Workflow

1. **Build binaries** (cross-compiled):
   ```bash
   ./dev build drtprod --cross
   ./dev build roachprod --cross
   ```

2. **Preview deployment**:
   ```bash
   drtprod execute configs/drt_scale.yaml --display-only
   ```

3. **Execute deployment**:
   ```bash
   drtprod execute configs/drt_scale.yaml
   ```

4. **Execute specific targets**:
   ```bash
   drtprod execute configs/drt_scale.yaml -t "post_tasks"
   ```

5. **Remote (long-running) deployment**:
   ```bash
   drtprod execute configs/drt_scale.yaml -r configs/drt_remote.yaml
   ```

### Testing

Run tests with:
```bash
./dev test pkg/cmd/drtprod/... -v
```

Tests in `yamlprocessor_test.go` cover:
- YAML parsing validation
- Display-only mode
- Dependent file checking
- Rollback execution
- Parallel target execution with dependency ordering
- Remote execution (with mocked roachprod)
- Slack notification verification

### Key Design Patterns

1. **Testability**: Function variables (`commandExecutor`, `roachprodRun`, `roachprodPut`) allow mocking in tests
2. **Concurrency**: `errgroup` for parallel execution, `sync.WaitGroup` for dependencies
3. **Thread safety**: `syncutil.Mutex` for shared state (`targetStatusRegistry`, `SlackNotifier.threadTimestamps`)
4. **Environment expansion**: `os.ExpandEnv` for variable substitution in YAML values
5. **Rollback stacking**: Rollback commands stored in LIFO order for proper cleanup sequence
