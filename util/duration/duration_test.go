// Copyright 2016 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// Author: Daniel Harrison (daniel.harrison@gmail.com)

package duration

import (
	"math"
	"testing"
)

type durationTest struct {
	cmp      int
	duration Duration
	err      bool
}

// The negative tests are generated by prepending everything but the 0 case and
// flipping the sign of cmp, since they will be getting bigger in abolute value
// and more negative.
// TODO(dan): Write more tests with a mixture of positive and negative
// components.
var positiveDurationTests = []durationTest{
	{1, Duration{Months: 0, Days: 0, Nanos: 0}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: 1}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInDay - 1}, false},
	{1, Duration{Months: 0, Days: 1, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 0, Nanos: nanosInDay}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInDay + 1}, false},
	{1, Duration{Months: 0, Days: daysInMonth - 1, Nanos: 0}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInMonth - 1}, false},
	{1, Duration{Months: 1, Days: 0, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: daysInMonth, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 0, Nanos: nanosInMonth}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInMonth + 1}, false},
	{1, Duration{Months: 0, Days: daysInMonth + 1, Nanos: 0}, false},
	{1, Duration{Months: 1, Days: 1, Nanos: 1}, false},
	{1, Duration{Months: 1, Days: 10, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 40, Nanos: 0}, false},
	{1, Duration{Months: 2, Days: 0, Nanos: 0}, false},
	{1, Duration{Months: math.MaxInt64 - 1, Days: daysInMonth - 1, Nanos: nanosInDay * 2}, true},
	{1, Duration{Months: math.MaxInt64 - 1, Days: daysInMonth * 2, Nanos: nanosInDay * 2}, true},
	{1, Duration{Months: math.MaxInt64, Days: math.MaxInt64, Nanos: nanosInMonth + nanosInDay}, true},
	{1, Duration{Months: math.MaxInt64, Days: math.MaxInt64, Nanos: math.MaxInt64}, true},
}

func fullDurationTests() []durationTest {
	var ret []durationTest
	for i := 1; i < len(positiveDurationTests); i++ {
		d := positiveDurationTests[i].duration
		negDuration := Duration{Months: -d.Months, Days: -d.Days, Nanos: -d.Nanos}
		ret = append(ret, durationTest{cmp: -positiveDurationTests[i].cmp, duration: negDuration})
	}
	ret = append(ret, positiveDurationTests...)
	return ret
}

func TestEncodeDecode(t *testing.T) {
	for i, test := range fullDurationTests() {
		sortNanos, months, days, err := test.duration.Encode()
		if test.err && err == nil {
			// TODO(dan): Uncomment this when over and underflow are checked.
			// t.Errorf("%d expected error but didn't get one", i)
		} else if !test.err && err != nil {
			t.Errorf("%d expected no error but got one: %s", i, err)
		}
		if err != nil {
			continue
		}
		d, err := Decode(sortNanos, months, days)
		if err != nil {
			t.Fatal(err)
		}
		if test.duration != d {
			t.Errorf("%d encode/decode mismatch [%v] vs [%v]", i, test, d)
		}
	}
}

func TestCompare(t *testing.T) {
	prev := Duration{}
	for i, test := range fullDurationTests() {
		cmp := test.duration.Compare(prev)
		if cmp != test.cmp {
			t.Errorf("%d did not compare correctly got %d expected %d [%s] vs [%s]", i, cmp, test.cmp, prev, test.duration)
		}
		prev = test.duration
	}
}

func TestNormalize(t *testing.T) {
	for i, test := range fullDurationTests() {
		nanos, _, _ := test.duration.EncodeBigInt()
		normalized := test.duration.normalize()
		normalizedNanos, _, _ := normalized.EncodeBigInt()
		if nanos.Cmp(normalizedNanos) != 0 {
			t.Errorf("%d effective nanos were changed [%#v] [%#v]", i, test.duration, normalized)
		}
		if normalized.Days > daysInMonth && normalized.Months != math.MaxInt64 ||
			normalized.Days < -daysInMonth && normalized.Months != math.MinInt64 {
			t.Errorf("%d days were not normalized [%#v]", i, normalized)
		}
		if normalized.Nanos > nanosInDay && normalized.Days != math.MaxInt64 ||
			normalized.Nanos < -nanosInDay && normalized.Days != math.MinInt64 {
			t.Errorf("%d nanos were not normalized [%#v]", i, normalized)
		}
	}
}
