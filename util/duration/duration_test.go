// Copyright 2016 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// Author: Daniel Harrison (daniel.harrison@gmail.com)

package duration

import (
	"math"
	"testing"

	_ "github.com/cockroachdb/cockroach/util/log"
)

type durationTest struct {
	cmpToPrev int
	duration  Duration
	err       bool
}

// positiveDurationTests is used both to check that each duration roudtrips
// through Encode/Decode and that they sort in the expected way. They are not
// required to be listed in ascending order, but for ease of maintenance, it is
// expected that they stay ascending.
//
// The negative tests are generated by prepending everything but the 0 case and
// flipping the sign of cmpToPrev, since they will be getting bigger in abolute
// value and more negative.
//
// TODO(dan): Write more tests with a mixture of positive and negative
// components.
var positiveDurationTests = []durationTest{
	{1, Duration{Months: 0, Days: 0, Nanos: 0}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: 1}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInDay - 1}, false},
	{1, Duration{Months: 0, Days: 1, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 0, Nanos: nanosInDay}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInDay + 1}, false},
	{1, Duration{Months: 0, Days: daysInMonth - 1, Nanos: 0}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInMonth - 1}, false},
	{1, Duration{Months: 1, Days: 0, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: daysInMonth, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 0, Nanos: nanosInMonth}, false},
	{1, Duration{Months: 0, Days: 0, Nanos: nanosInMonth + 1}, false},
	{1, Duration{Months: 0, Days: daysInMonth + 1, Nanos: 0}, false},
	{1, Duration{Months: 1, Days: 1, Nanos: 1}, false},
	{1, Duration{Months: 1, Days: 10, Nanos: 0}, false},
	{0, Duration{Months: 0, Days: 40, Nanos: 0}, false},
	{1, Duration{Months: 2, Days: 0, Nanos: 0}, false},
	{1, Duration{Months: math.MaxInt64 - 1, Days: daysInMonth - 1, Nanos: nanosInDay * 2}, true},
	{1, Duration{Months: math.MaxInt64 - 1, Days: daysInMonth * 2, Nanos: nanosInDay * 2}, true},
	{1, Duration{Months: math.MaxInt64, Days: math.MaxInt64, Nanos: nanosInMonth + nanosInDay}, true},
	{1, Duration{Months: math.MaxInt64, Days: math.MaxInt64, Nanos: math.MaxInt64}, true},
}

func fullDurationTests() []durationTest {
	var ret []durationTest
	for _, test := range positiveDurationTests {
		d := test.duration
		negDuration := Duration{Months: -d.Months, Days: -d.Days, Nanos: -d.Nanos}
		ret = append(ret, durationTest{cmpToPrev: -test.cmpToPrev, duration: negDuration, err: test.err})
	}
	ret = append(ret, positiveDurationTests...)
	return ret
}

func TestEncodeDecode(t *testing.T) {
	for i, test := range fullDurationTests() {
		sortNanos, months, days, err := test.duration.Encode()
		if test.err && err == nil {
			t.Errorf("%d expected error but didn't get one", i)
		} else if !test.err && err != nil {
			t.Errorf("%d expected no error but got one: %s", i, err)
		}
		if err != nil {
			continue
		}
		sortNanosBig, _, _ := test.duration.EncodeBigInt()
		if sortNanos != sortNanosBig.Int64() {
			t.Errorf("%d Encode and EncodeBig didn't match [%d] vs [%s]", i, sortNanos, sortNanosBig)
		}
		d, err := Decode(sortNanos, months, days)
		if err != nil {
			t.Fatal(err)
		}
		if test.duration != d {
			t.Errorf("%d encode/decode mismatch [%v] vs [%v]", i, test, d)
		}
	}
}

func TestCompare(t *testing.T) {
	prev := Duration{Nanos: 1} // It's expected that we start with something greater than 0.
	for i, test := range fullDurationTests() {
		cmp := test.duration.Compare(prev)
		if cmp != test.cmpToPrev {
			t.Errorf("%d did not compare correctly got %d expected %d [%s] vs [%s]", i, cmp, test.cmpToPrev, prev, test.duration)
		}
		prev = test.duration
	}
}

func TestNormalize(t *testing.T) {
	for i, test := range fullDurationTests() {
		nanos, _, _ := test.duration.EncodeBigInt()
		normalized := test.duration.normalize()
		normalizedNanos, _, _ := normalized.EncodeBigInt()
		if nanos.Cmp(normalizedNanos) != 0 {
			t.Errorf("%d effective nanos were changed [%s] [%s]", i, test.duration, normalized)
		}
		if normalized.Days > daysInMonth && normalized.Months != math.MaxInt64 ||
			normalized.Days < -daysInMonth && normalized.Months != math.MinInt64 {
			t.Errorf("%d days were not normalized [%s]", i, normalized)
		}
		if normalized.Nanos > nanosInDay && normalized.Days != math.MaxInt64 ||
			normalized.Nanos < -nanosInDay && normalized.Days != math.MinInt64 {
			t.Errorf("%d nanos were not normalized [%s]", i, normalized)
		}
	}
}
