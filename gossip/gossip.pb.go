// Code generated by protoc-gen-gogo.
// source: cockroach/gossip/gossip.proto
// DO NOT EDIT!

/*
	Package gossip is a generated protocol buffer package.

	It is generated from these files:
		cockroach/gossip/gossip.proto

	It has these top-level messages:
		BootstrapInfo
		Request
		Response
		InfoStatus
		Info
*/
package gossip

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_roachpb1 "github.com/cockroachdb/cockroach/roachpb"
import _ "github.com/cockroachdb/cockroach/roachpb"
import cockroach_util_hlc "github.com/cockroachdb/cockroach/util/hlc"
import cockroach_util "github.com/cockroachdb/cockroach/util"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import github_com_cockroachdb_cockroach_roachpb "github.com/cockroachdb/cockroach/roachpb"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// BootstrapInfo contains information necessary to bootstrapping the
// gossip network from a cold start.
type BootstrapInfo struct {
	// A map from node ID to address.
	Addresses []cockroach_util.UnresolvedAddr `protobuf:"bytes,1,rep,name=addresses" json:"addresses"`
	// Timestamp at which the bootstrap info was written.
	Timestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *BootstrapInfo) Reset()                    { *m = BootstrapInfo{} }
func (m *BootstrapInfo) String() string            { return proto.CompactTextString(m) }
func (*BootstrapInfo) ProtoMessage()               {}
func (*BootstrapInfo) Descriptor() ([]byte, []int) { return fileDescriptorGossip, []int{0} }

// Request is the request struct passed with the Gossip RPC.
type Request struct {
	// Requesting node's ID.
	NodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"node_id,omitempty"`
	// Address of the requesting client.
	Addr cockroach_util.UnresolvedAddr `protobuf:"bytes,2,opt,name=addr" json:"addr"`
	// Map of high water timestamps from infos originating at other
	// nodes, as seen by the requester.
	HighWaterStamps map[github_com_cockroachdb_cockroach_roachpb.NodeID]int64 `protobuf:"bytes,3,rep,name=high_water_stamps,json=highWaterStamps,castkey=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"high_water_stamps" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Delta of Infos originating at sender.
	Delta map[string]*Info `protobuf:"bytes,4,rep,name=delta" json:"delta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorGossip, []int{1} }

// Response is returned from the Gossip.Gossip RPC.
// Delta will be nil in the event that Alternate is set.
type Response struct {
	// Responding Node's ID.
	NodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"node_id,omitempty"`
	// Address of the responding client.
	Addr cockroach_util.UnresolvedAddr `protobuf:"bytes,2,opt,name=addr" json:"addr"`
	// Non-nil means client should retry with this address.
	AlternateAddr *cockroach_util.UnresolvedAddr `protobuf:"bytes,3,opt,name=alternate_addr,json=alternateAddr" json:"alternate_addr,omitempty"`
	// Node ID of the alternate address, if alternate_addr is not nil.
	AlternateNodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,4,opt,name=alternate_node_id,json=alternateNodeId,proto3,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"alternate_node_id,omitempty"`
	// Delta of Infos which are fresh according to the map of Node info messages
	// passed with the request.
	Delta map[string]*Info `protobuf:"bytes,5,rep,name=delta" json:"delta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map of high water timestamps from infos originating at other
	// nodes, as seen by the responder.
	HighWaterStamps map[github_com_cockroachdb_cockroach_roachpb.NodeID]int64 `protobuf:"bytes,6,rep,name=high_water_stamps,json=highWaterStamps,castkey=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"high_water_stamps" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorGossip, []int{2} }

// InfoStatus contains information about the current status of the infoStore.
type InfoStatus struct {
	Infos map[string]Info `protobuf:"bytes,1,rep,name=infos" json:"infos" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InfoStatus) Reset()                    { *m = InfoStatus{} }
func (m *InfoStatus) String() string            { return proto.CompactTextString(m) }
func (*InfoStatus) ProtoMessage()               {}
func (*InfoStatus) Descriptor() ([]byte, []int) { return fileDescriptorGossip, []int{3} }

// Info is the basic unit of information traded over the
// gossip network.
type Info struct {
	Value cockroach_roachpb1.Value `protobuf:"bytes,1,opt,name=value" json:"value"`
	// Wall time of info when generated by originating node (Unix-nanos).
	OrigStamp int64 `protobuf:"varint,2,opt,name=orig_stamp,json=origStamp,proto3" json:"orig_stamp,omitempty"`
	// Wall time when info is to be discarded (Unix-nanos).
	TTLStamp int64 `protobuf:"varint,3,opt,name=ttl_stamp,json=ttlStamp,proto3" json:"ttl_stamp,omitempty"`
	// Number of hops from originator.
	Hops uint32 `protobuf:"varint,4,opt,name=hops,proto3" json:"hops,omitempty"`
	// Originating node's ID.
	NodeID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,5,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"node_id,omitempty"`
	// Peer node ID which passed this info.
	PeerID github_com_cockroachdb_cockroach_roachpb.NodeID `protobuf:"varint,6,opt,name=peer_id,json=peerId,proto3,casttype=github.com/cockroachdb/cockroach/roachpb.NodeID" json:"peer_id,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptorGossip, []int{4} }

func init() {
	proto.RegisterType((*BootstrapInfo)(nil), "cockroach.gossip.BootstrapInfo")
	proto.RegisterType((*Request)(nil), "cockroach.gossip.Request")
	proto.RegisterType((*Response)(nil), "cockroach.gossip.Response")
	proto.RegisterType((*InfoStatus)(nil), "cockroach.gossip.InfoStatus")
	proto.RegisterType((*Info)(nil), "cockroach.gossip.Info")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Gossip service

type GossipClient interface {
	Gossip(ctx context.Context, opts ...grpc.CallOption) (Gossip_GossipClient, error)
}

type gossipClient struct {
	cc *grpc.ClientConn
}

func NewGossipClient(cc *grpc.ClientConn) GossipClient {
	return &gossipClient{cc}
}

func (c *gossipClient) Gossip(ctx context.Context, opts ...grpc.CallOption) (Gossip_GossipClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Gossip_serviceDesc.Streams[0], c.cc, "/cockroach.gossip.Gossip/Gossip", opts...)
	if err != nil {
		return nil, err
	}
	x := &gossipGossipClient{stream}
	return x, nil
}

type Gossip_GossipClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type gossipGossipClient struct {
	grpc.ClientStream
}

func (x *gossipGossipClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gossipGossipClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Gossip service

type GossipServer interface {
	Gossip(Gossip_GossipServer) error
}

func RegisterGossipServer(s *grpc.Server, srv GossipServer) {
	s.RegisterService(&_Gossip_serviceDesc, srv)
}

func _Gossip_Gossip_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GossipServer).Gossip(&gossipGossipServer{stream})
}

type Gossip_GossipServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type gossipGossipServer struct {
	grpc.ServerStream
}

func (x *gossipGossipServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gossipGossipServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Gossip_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.gossip.Gossip",
	HandlerType: (*GossipServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Gossip",
			Handler:       _Gossip_Gossip_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptorGossip,
}

func (m *BootstrapInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BootstrapInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, msg := range m.Addresses {
			data[i] = 0xa
			i++
			i = encodeVarintGossip(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintGossip(data, i, uint64(m.Timestamp.Size()))
	n1, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *Request) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Request) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGossip(data, i, uint64(m.NodeID))
	}
	data[i] = 0x12
	i++
	i = encodeVarintGossip(data, i, uint64(m.Addr.Size()))
	n2, err := m.Addr.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.HighWaterStamps) > 0 {
		keysForHighWaterStamps := make([]int32, 0, len(m.HighWaterStamps))
		for k := range m.HighWaterStamps {
			keysForHighWaterStamps = append(keysForHighWaterStamps, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForHighWaterStamps)
		for _, k := range keysForHighWaterStamps {
			data[i] = 0x1a
			i++
			v := m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(k)]
			mapSize := 1 + sovGossip(uint64(k)) + 1 + sovGossip(uint64(v))
			i = encodeVarintGossip(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintGossip(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintGossip(data, i, uint64(v))
		}
	}
	if len(m.Delta) > 0 {
		keysForDelta := make([]string, 0, len(m.Delta))
		for k := range m.Delta {
			keysForDelta = append(keysForDelta, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDelta)
		for _, k := range keysForDelta {
			data[i] = 0x22
			i++
			v := m.Delta[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGossip(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGossip(uint64(len(k))) + msgSize
			i = encodeVarintGossip(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintGossip(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintGossip(data, i, uint64(v.Size()))
				n3, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *Response) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Response) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGossip(data, i, uint64(m.NodeID))
	}
	data[i] = 0x12
	i++
	i = encodeVarintGossip(data, i, uint64(m.Addr.Size()))
	n4, err := m.Addr.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.AlternateAddr != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintGossip(data, i, uint64(m.AlternateAddr.Size()))
		n5, err := m.AlternateAddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AlternateNodeID != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGossip(data, i, uint64(m.AlternateNodeID))
	}
	if len(m.Delta) > 0 {
		keysForDelta := make([]string, 0, len(m.Delta))
		for k := range m.Delta {
			keysForDelta = append(keysForDelta, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDelta)
		for _, k := range keysForDelta {
			data[i] = 0x2a
			i++
			v := m.Delta[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGossip(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGossip(uint64(len(k))) + msgSize
			i = encodeVarintGossip(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintGossip(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintGossip(data, i, uint64(v.Size()))
				n6, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if len(m.HighWaterStamps) > 0 {
		keysForHighWaterStamps := make([]int32, 0, len(m.HighWaterStamps))
		for k := range m.HighWaterStamps {
			keysForHighWaterStamps = append(keysForHighWaterStamps, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForHighWaterStamps)
		for _, k := range keysForHighWaterStamps {
			data[i] = 0x32
			i++
			v := m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(k)]
			mapSize := 1 + sovGossip(uint64(k)) + 1 + sovGossip(uint64(v))
			i = encodeVarintGossip(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintGossip(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintGossip(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *InfoStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InfoStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		keysForInfos := make([]string, 0, len(m.Infos))
		for k := range m.Infos {
			keysForInfos = append(keysForInfos, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInfos)
		for _, k := range keysForInfos {
			data[i] = 0xa
			i++
			v := m.Infos[string(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovGossip(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovGossip(uint64(len(k))) + msgSize
			i = encodeVarintGossip(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintGossip(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintGossip(data, i, uint64((&v).Size()))
			n7, err := (&v).MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n7
		}
	}
	return i, nil
}

func (m *Info) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Info) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintGossip(data, i, uint64(m.Value.Size()))
	n8, err := m.Value.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.OrigStamp != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGossip(data, i, uint64(m.OrigStamp))
	}
	if m.TTLStamp != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGossip(data, i, uint64(m.TTLStamp))
	}
	if m.Hops != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGossip(data, i, uint64(m.Hops))
	}
	if m.NodeID != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGossip(data, i, uint64(m.NodeID))
	}
	if m.PeerID != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGossip(data, i, uint64(m.PeerID))
	}
	return i, nil
}

func encodeFixed64Gossip(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gossip(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGossip(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *BootstrapInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 1 + l + sovGossip(uint64(l))
		}
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovGossip(uint64(l))
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovGossip(uint64(m.NodeID))
	}
	l = m.Addr.Size()
	n += 1 + l + sovGossip(uint64(l))
	if len(m.HighWaterStamps) > 0 {
		for k, v := range m.HighWaterStamps {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGossip(uint64(k)) + 1 + sovGossip(uint64(v))
			n += mapEntrySize + 1 + sovGossip(uint64(mapEntrySize))
		}
	}
	if len(m.Delta) > 0 {
		for k, v := range m.Delta {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGossip(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGossip(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGossip(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovGossip(uint64(m.NodeID))
	}
	l = m.Addr.Size()
	n += 1 + l + sovGossip(uint64(l))
	if m.AlternateAddr != nil {
		l = m.AlternateAddr.Size()
		n += 1 + l + sovGossip(uint64(l))
	}
	if m.AlternateNodeID != 0 {
		n += 1 + sovGossip(uint64(m.AlternateNodeID))
	}
	if len(m.Delta) > 0 {
		for k, v := range m.Delta {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGossip(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovGossip(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovGossip(uint64(mapEntrySize))
		}
	}
	if len(m.HighWaterStamps) > 0 {
		for k, v := range m.HighWaterStamps {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGossip(uint64(k)) + 1 + sovGossip(uint64(v))
			n += mapEntrySize + 1 + sovGossip(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *InfoStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, v := range m.Infos {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovGossip(uint64(len(k))) + 1 + l + sovGossip(uint64(l))
			n += mapEntrySize + 1 + sovGossip(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Info) Size() (n int) {
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovGossip(uint64(l))
	if m.OrigStamp != 0 {
		n += 1 + sovGossip(uint64(m.OrigStamp))
	}
	if m.TTLStamp != 0 {
		n += 1 + sovGossip(uint64(m.TTLStamp))
	}
	if m.Hops != 0 {
		n += 1 + sovGossip(uint64(m.Hops))
	}
	if m.NodeID != 0 {
		n += 1 + sovGossip(uint64(m.NodeID))
	}
	if m.PeerID != 0 {
		n += 1 + sovGossip(uint64(m.PeerID))
	}
	return n
}

func sovGossip(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGossip(x uint64) (n int) {
	return sovGossip(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BootstrapInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, cockroach_util.UnresolvedAddr{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGossip(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGossip
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Addr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterStamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.HighWaterStamps == nil {
				m.HighWaterStamps = make(map[github_com_cockroachdb_cockroach_roachpb.NodeID]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(mapkey)] = mapvalue
			} else {
				var mapvalue int64
				m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(mapkey)] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGossip
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Delta == nil {
				m.Delta = make(map[string]*Info)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Info{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Delta[mapkey] = mapvalue
			} else {
				var mapvalue *Info
				m.Delta[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGossip(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGossip
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Addr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlternateAddr == nil {
				m.AlternateAddr = &cockroach_util.UnresolvedAddr{}
			}
			if err := m.AlternateAddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateNodeID", wireType)
			}
			m.AlternateNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AlternateNodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGossip
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Delta == nil {
				m.Delta = make(map[string]*Info)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Info{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Delta[mapkey] = mapvalue
			} else {
				var mapvalue *Info
				m.Delta[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterStamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.HighWaterStamps == nil {
				m.HighWaterStamps = make(map[github_com_cockroachdb_cockroach_roachpb.NodeID]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(mapkey)] = mapvalue
			} else {
				var mapvalue int64
				m.HighWaterStamps[github_com_cockroachdb_cockroach_roachpb.NodeID(mapkey)] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGossip(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGossip
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthGossip
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Infos == nil {
				m.Infos = make(map[string]Info)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthGossip
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Info{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Infos[mapkey] = *mapvalue
			} else {
				var mapvalue Info
				m.Infos[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGossip(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGossip
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGossip
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigStamp", wireType)
			}
			m.OrigStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrigStamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLStamp", wireType)
			}
			m.TTLStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TTLStamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hops", wireType)
			}
			m.Hops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Hops |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PeerID |= (github_com_cockroachdb_cockroach_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGossip(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGossip
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGossip(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGossip
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGossip
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGossip
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGossip
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGossip(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGossip = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGossip   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("cockroach/gossip/gossip.proto", fileDescriptorGossip) }

var fileDescriptorGossip = []byte{
	// 748 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x55, 0xd1, 0x6a, 0x13, 0x4d,
	0x14, 0xce, 0x34, 0x9b, 0xb4, 0x99, 0xfe, 0xfd, 0xdb, 0x0e, 0x45, 0x62, 0xb0, 0x49, 0x08, 0x15,
	0x23, 0xc8, 0xae, 0x44, 0xc1, 0x52, 0xf1, 0xa2, 0x6b, 0xab, 0x06, 0x44, 0xcb, 0xb6, 0x56, 0xf1,
	0x26, 0x4c, 0x32, 0xd3, 0xec, 0xd2, 0x4d, 0x26, 0xee, 0x4c, 0x2a, 0xbd, 0xd5, 0x17, 0x10, 0x14,
	0x5f, 0xc0, 0x27, 0xf1, 0xae, 0x78, 0xe5, 0xa5, 0x57, 0x51, 0xe3, 0x5b, 0x78, 0x25, 0x33, 0x93,
	0xdd, 0x4d, 0x9b, 0x54, 0x6a, 0x89, 0xe0, 0x4d, 0x7b, 0x76, 0xce, 0xf7, 0x7d, 0x73, 0xce, 0xe1,
	0x3b, 0x13, 0xb8, 0xdc, 0x60, 0x8d, 0xfd, 0x80, 0xe1, 0x86, 0x6b, 0x35, 0x19, 0xe7, 0x5e, 0x67,
	0xf0, 0xcf, 0xec, 0x04, 0x4c, 0x30, 0xb4, 0x10, 0xa5, 0x4d, 0x7d, 0x9e, 0xbb, 0x14, 0x13, 0xd4,
	0xdf, 0x4e, 0xdd, 0x22, 0x58, 0x60, 0x8d, 0xcf, 0x15, 0x47, 0xb3, 0x2d, 0x2a, 0xf0, 0x10, 0xa2,
	0x14, 0x23, 0xba, 0xc2, 0xf3, 0x2d, 0xd7, 0x6f, 0x58, 0xc2, 0x6b, 0x51, 0x2e, 0x70, 0x6b, 0x70,
	0x6b, 0x6e, 0xe5, 0x04, 0xa6, 0xdb, 0x0e, 0x28, 0x67, 0xfe, 0x01, 0x25, 0x35, 0x4c, 0x48, 0x30,
	0x40, 0x2d, 0x35, 0x59, 0x93, 0xa9, 0xd0, 0x92, 0x91, 0x3e, 0x2d, 0xbd, 0x07, 0x70, 0xce, 0x66,
	0x4c, 0x70, 0x11, 0xe0, 0x4e, 0xb5, 0xbd, 0xc7, 0x90, 0x0d, 0x33, 0x92, 0x45, 0x39, 0xa7, 0x3c,
	0x0b, 0x8a, 0xc9, 0xf2, 0x6c, 0x25, 0x6f, 0xc6, 0x7d, 0xc9, 0x1b, 0xcc, 0x27, 0xd1, 0x0d, 0xeb,
	0x84, 0x04, 0xb6, 0x71, 0xd4, 0x2b, 0x24, 0x9c, 0x98, 0x86, 0xd6, 0x61, 0x26, 0x2a, 0x32, 0x3b,
	0x55, 0x04, 0xe5, 0xd9, 0xca, 0xf2, 0x49, 0x0d, 0xd7, 0x6f, 0x98, 0x3b, 0x21, 0x28, 0x94, 0x88,
	0x58, 0xa5, 0xd7, 0x06, 0x9c, 0x76, 0xe8, 0x8b, 0x2e, 0xe5, 0x02, 0xed, 0xc2, 0xe9, 0x36, 0x23,
	0xb4, 0xe6, 0x91, 0x2c, 0x28, 0x82, 0x72, 0xca, 0xbe, 0xd3, 0xef, 0x15, 0xd2, 0x8f, 0x18, 0xa1,
	0xd5, 0x8d, 0x9f, 0xbd, 0x82, 0xd5, 0xf4, 0x84, 0xdb, 0xad, 0x9b, 0x0d, 0xd6, 0xb2, 0xa2, 0x4b,
	0x48, 0xdd, 0x1a, 0x19, 0xae, 0xa9, 0x29, 0x4e, 0x5a, 0xaa, 0x55, 0x09, 0x5a, 0x85, 0x86, 0xac,
	0x79, 0x50, 0xe1, 0xd9, 0xba, 0x54, 0x0c, 0xf4, 0x16, 0xc0, 0x45, 0xd7, 0x6b, 0xba, 0xb5, 0x97,
	0x58, 0xd0, 0xa0, 0xa6, 0x4a, 0xe6, 0xd9, 0xa4, 0x9a, 0x96, 0x69, 0x9e, 0x74, 0x81, 0x39, 0x68,
	0xc4, 0x7c, 0xe0, 0x35, 0xdd, 0xa7, 0x92, 0xb1, 0xad, 0x08, 0x9b, 0x6d, 0x11, 0x1c, 0xda, 0xb7,
	0xa4, 0xee, 0xab, 0xaf, 0x7f, 0xde, 0xc6, 0xbc, 0x7b, 0x5c, 0x0e, 0xad, 0xc1, 0x14, 0xa1, 0xbe,
	0xc0, 0x59, 0x43, 0x15, 0xb2, 0x72, 0x7a, 0x21, 0x1b, 0x12, 0xa6, 0xae, 0x77, 0x34, 0x25, 0x67,
	0xc3, 0xa5, 0x71, 0xd5, 0xa1, 0x05, 0x98, 0xdc, 0xa7, 0x87, 0x7a, 0xee, 0x8e, 0x0c, 0xd1, 0x12,
	0x4c, 0x1d, 0x60, 0xbf, 0x4b, 0xd5, 0xd8, 0x92, 0x8e, 0xfe, 0x58, 0x9b, 0x5a, 0x05, 0xb9, 0x2d,
	0x08, 0x63, 0xe1, 0x61, 0x66, 0x46, 0x33, 0xaf, 0x0d, 0x33, 0x67, 0x2b, 0x17, 0x46, 0xeb, 0x93,
	0x0e, 0x1c, 0x52, 0x2c, 0x7d, 0x4c, 0xc1, 0x19, 0x87, 0xf2, 0x0e, 0x6b, 0x73, 0xfa, 0x0f, 0xda,
	0x60, 0x13, 0xfe, 0x8f, 0x7d, 0x41, 0x83, 0x36, 0x16, 0x54, 0xed, 0x5a, 0x36, 0x79, 0x16, 0x0d,
	0x67, 0x2e, 0x62, 0xc9, 0x4f, 0x14, 0xc0, 0xc5, 0x58, 0x26, 0x6c, 0xd1, 0x50, 0x2d, 0xde, 0xeb,
	0xf7, 0x0a, 0xf3, 0xeb, 0x61, 0xf2, 0xfc, 0xbd, 0xce, 0xe3, 0x63, 0x1a, 0x04, 0xdd, 0x0e, 0xbd,
	0x92, 0x52, 0x5e, 0xb9, 0x3c, 0xce, 0x2b, 0x7a, 0xee, 0xa3, 0x66, 0x41, 0xef, 0xc6, 0xda, 0x3f,
	0xad, 0x94, 0xac, 0xdf, 0x28, 0xfd, 0x5d, 0xff, 0x4f, 0xde, 0x7f, 0x93, 0xd8, 0x8a, 0xd2, 0x07,
	0x00, 0xa1, 0xd4, 0xdd, 0x16, 0x58, 0x74, 0x39, 0xba, 0x0b, 0x53, 0x5e, 0x7b, 0x8f, 0x85, 0x6f,
	0xeb, 0x95, 0xf1, 0x45, 0x68, 0xb0, 0x0a, 0x07, 0x63, 0xd2, 0xbe, 0xd3, 0x5c, 0xd9, 0x69, 0x9c,
	0x9a, 0xc8, 0xa6, 0x7d, 0x9a, 0x82, 0x86, 0x7a, 0xff, 0x6f, 0x86, 0x54, 0xa0, 0xa8, 0xd9, 0x21,
	0x6a, 0x38, 0xff, 0x5d, 0x99, 0x0f, 0x0b, 0x52, 0x60, 0xb4, 0x0c, 0x21, 0x0b, 0xbc, 0x66, 0x2d,
	0x7e, 0xf2, 0x93, 0x4e, 0x46, 0x9e, 0xa8, 0xa9, 0xa1, 0xab, 0x30, 0x23, 0x84, 0x3f, 0xc8, 0xca,
	0x1d, 0x49, 0xda, 0xff, 0xf5, 0x7b, 0x85, 0x99, 0x9d, 0x9d, 0x87, 0x0a, 0xe0, 0xcc, 0x08, 0xe1,
	0x6b, 0x28, 0x82, 0x86, 0xcb, 0x3a, 0x5c, 0xf9, 0x7f, 0xce, 0x51, 0xf1, 0xf0, 0xe6, 0xa7, 0x26,
	0xb9, 0xf9, 0xbb, 0x70, 0xba, 0x43, 0x69, 0x20, 0x75, 0xd3, 0xb1, 0xee, 0x16, 0xa5, 0xc1, 0x39,
	0x75, 0xa5, 0x5a, 0x95, 0x54, 0x1e, 0xc3, 0xf4, 0x7d, 0x35, 0x66, 0xb4, 0x19, 0x45, 0x17, 0x4f,
	0x7d, 0x8d, 0x73, 0xb9, 0xd3, 0x57, 0xa6, 0x94, 0x28, 0x83, 0xeb, 0xc0, 0x2e, 0x1e, 0x7d, 0xcf,
	0x27, 0x8e, 0xfa, 0x79, 0xf0, 0xb9, 0x9f, 0x07, 0x5f, 0xfa, 0x79, 0xf0, 0xad, 0x9f, 0x07, 0x6f,
	0x7e, 0xe4, 0x13, 0xcf, 0xd3, 0x9a, 0xf0, 0xcc, 0xa8, 0xa7, 0xd5, 0x2f, 0xfa, 0x8d, 0x5f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xb5, 0xbf, 0x01, 0xdd, 0xa4, 0x08, 0x00, 0x00,
}
